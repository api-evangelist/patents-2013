---

title: Performing customized deployment scenarios in shared environments
abstract: Various embodiments of systems and methods to process customized deployment scenarios in a shared computing environment are described. In one aspect, a deployment request is received at the shared computing environment by a client associated with a customized deployment scenario. In a response, a deploy service of the shared computing environment is instantiated. In another aspect, one or more custom deploy processors are identified by the deploy service, where the one or more custom deploy processors correspond to one or more customized deployment scenarios. In yet another aspect, a part of a deployable content passed to the one or more custom deploy processors by the deploy service, is deployed to the shared computing environment by at least one corresponding custom deploy processor.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09614730&OS=09614730&RS=09614730
owner: SAP SE
number: 09614730
owner_city: Walldorf
owner_country: DE
publication_date: 20131031
---
Cloud based computer services represent a rapidly growing market in current information technology industry. One of the factors for providing a successful cloud platform is the flexibility to deploy a broad range of applications for different clients. Often to deploy different applications on a cloud based platform means meeting different requirements or deployment scenarios for processing the deployable content. There may be differences regarding the runtime specifics for the different applications to be executed the data they need to be uploaded and available on the platform the applied security constraints etc. Whenever a new application requires specific or customized deployment process a deploy service of the cloud based application platform needs to be modified which may require substantial resources in both work power and time. On the other hand the integration of the specific requirements into the existing deploy processes is prone to errors. Additionally the provider of the cloud based application platform is not able to serve the client s customized deployment scenario while the deploy service is not updated accordingly.

Embodiments of techniques to provision customized deployment scenarios in shared computer environments are described herein. In the following description numerous specific details are set forth to provide a thorough understanding of the embodiments. One skilled in the relevant art will recognize however that the presented ideas can be practiced without one or more of the specific details or with other methods components materials etc. In other instances well known structures materials or operations are not shown or described in detail to avoid obscuring.

Reference throughout this specification to one embodiment this embodiment and similar phrases means that a particular feature structure or characteristic described in connection with the embodiment is included in at least one embodiment. Thus the appearances of these phrases in various places throughout this specification are not necessarily all referring to the same embodiment. Furthermore the particular features structures or characteristics may be combined in any suitable manner in one or more embodiments.

In one embodiment deploy service may provide a common interface allowing plugging in a number of custom deploy processors e.g. custom deploy processor A custom deploy processor B and custom deploy processor M to address specific deployment needs of the clients. Thus when a new request for customized deployment scenario is received instead of modifying the deploy service an additional custom deploy processor may be developed and introduced in the cloud platform .

For example a user of client may request deployment of content at application server of cloud platform by following a specific or customized scenario. In one embodiment one or more custom deploy processor plugins may be separately developed to handle the specifics of the customized deployment scenario for the content . When the deployment of the deployable content is initiated e.g. by a user of users at client systems A the deploy service may pass the artifacts of the deployable content to a corresponding content processor e.g. based on their type. If necessary the content processor validates and transforms the deployable content artifacts and stores them as content of the application server at cloud platform repository . Generally the cloud platform repository may be used to store different kinds of data related to the cloud infrastructure or the application server and respectively the applications running on the application server including service cloud service X and cloud service Y .

In one embodiment the content processor calls the plugged in custom deploy processors to perform the deployment of the artifacts. The deployable content may include artifacts pertinent to specific application or applications e.g. service cloud service X and or cloud service Y that require customized deployment. The deploy service passes the deployable content artifacts to the custom deploy processors through content processor . Each of the custom deploy processors recognizes its corresponding artifacts if any and process them according to the customized deployment scenario and uploads data e.g. content or configuration information as requested by the client.

Deploy service can plugin custom deploy processors to lookup corresponding artifacts in the deployable content . One custom deploy processor may search for one type of content another for different type of content. When corresponding content is found a custom deploy processor may open it read it parse it and store it in a predefined place e.g. in the repository content . Additionally a custom deploy processor may generate a notification through exception if there is an error during the deploy process e.g. if the custom deploy processor decides that the corresponding content is incorrect or cannot parse it correctly. In case of exception during the deployment the whole deploy process may be terminated and canceled. The content deployed during the customized scenario e.g. content may be removed by the same corresponding content deploy processors.

From implementation perspective the deploy service and the custom deploy processors e.g. follow a predefined contract or interface. Such contract may encompass a list of rules for example defining call methods parameters handling of exceptions etc. Thus the functionality of the deploy service may be flexibly enhanced by plugging in contract compliant custom deploy processors without changing the deploy service itself. The contract may by defined by a specific Application Programming Interface API implemented by the custom deploy processors. Each custom deploy processor may need to register when instantiated to be discoverable by the deploy service or by the relevant content processor.

In one embodiment same deployable content e.g. may be processed by the deploy service and one or more custom deploy processors where the deploy service and the custom deploy processors separately process the content or corresponding parts of the content as defined. For example one of the custom deploy processors may write part of the content in the repository another of the custom deploy processors may write the same part of the content or elements of it in a file system of the application server a third of the custom deploy processors may use that part the content for processing another part of the content etc. Thus different types of the same deployable content may be handled by different custom deploy processors. For example a deployable content provided as a Web application Archive WAR file could be processed by a number of custom deploy processor plugins of the deploy service where one may extract and deploy definitions of security roles another may extract properties for instrumenting or setup the Web application during runtime etc.

In one aspect the deployable content may store metadata such as deployment descriptors DD annotations etc. pointing out to corresponding custom deploy processor. In another aspect a custom deploy processor may recognize pertinent deployable content based on predefined marks. For example the security roles are usually described in a special eXtensible Markup Language XML file in the deployable content WAR file policy files allowing or enabling encryption of application data may be placed in a specific structure folder of the WAR file. Thus if a corresponding custom deploy processor detects such XML file or a file in a specific structure of the deployable content applies the customized deploy operations as programmed.

The company SAP AG is one of the vendors of cloud platforms based on Java called Java Platform as a Service jPaaS compliant with the Open Service Gateway Initiative OSGi standard that is deploying content provided as WAR files. A user may request the deployment of new or updated content to the cloud platform e.g. by using Integrated Development Environment IDE tool provided by SAP AG or by using Call Level Interface CLI The deployable content may be of different type including WAR files OSGi bundles P2 update sites P2 is a component of Equinox project and provides provisioning platform for Eclipse based applications etc. When deployed on the cloud platform by the deploy service e.g. via the separate custom deploy processor plugins the content may be stored permanently in JPaaS repository of the platform.

At a deploy service is instantiated at the cloud based application platform to receive or access the deployable content. In one embodiment the deploy service is part of the infrastructure of the cloud based application platform provided by the vendor and is based on the standard of the technology upon which the cloud based application platform is built. For example in a jPaaS based application platform the deployment service is built according to the Java Enterprise Edition Java EE specification and the OSGi standard. In one embodiment the deploy service is enhanced to implement a contract defining rules as part of an API for plugging in one or more custom deploy processors. The custom deploy processors may provide functionality for handling customized deployment scenarios when such functionality is not provided by the general deploy service responsible for the regular deployment scenarios.

The deploy service may search for instantiated custom deploy processor plugins at . In one embodiment the available custom deploy processors may be instantiated when the cloud based application platform starts one or more corresponding application server environments. When started or instantiated a custom deploy processor may register in a special registry accessible by the deploy service. The deploy service may look up the instantiate custom deploy process plugins in the registry to discover and call them according with the adopted contract API and potentially data or metadata provided by the custom deploy process at registration.

At a check is performed to verify whether there is at least one custom deploy processor that is instantiated. In case there is the deployable content is passed to each of the instantiated custom deploy processors to identify and deploy their corresponding parts if any according to an applicable customized deployment scenario at . Depending on factors such as the implementation the registration information the custom deploy processors setup either all deployable content is passed to a custom deploy processor or just its corresponding part for deployment.

Process continues at where the deployment of the deployable content or what is not deployed yet is processed in a way that is standard or regular for the cloud based application platform. This deployment may be handled entirely according to the functionality the deploy service and may be executed before or after the deployment according to the customized deployment scenario performed by the custom deploy processors.

At a check is performed to verify whether the deployment of the deployable content according with the client request is successful. The check may periodically search for a notification for a failed deploy operation from any of the deploy service and or the instantiated custom deploy processors. In case of such notification all executed or currently executing deploy operations are rolled back at . Alternatively instead of verifying the successful deployment at the deploy operations rollback may be triggered at directly when an error occurs. If the execution of all deploy operations is successful the deployment of the deployable content according with the client request is committed at .

A client requests a customized deployment scenario when the standard functionality of the deploy service as implemented and offered by the cloud based application platform is not enough. For example a client may request the cloud based application platform to provide strong encryption for the Hypertext Transfer Protocol Secure HTTPS connections of one or more deployed applications and or services when communicating with customers. The Java Development Kit JDK as an implementation of a Java EE based platform does not standardly support strong encryption HTTPS communication. Therefore special policy files enabling such communication for an application need to be provided during deploy to the cloud based application platform built upon Java EE e.g. jPaaS . The deployment of such special policy files requires additional functionality not provided by the general deploy service.

One possible way for provisioning customized deployment scenarios in a cloud based or otherwise shared computer environments according to one embodiment is shown in with process . Initially at a contract is defined at a deploy service of a cloud based application platform for plugging in custom deploy processors. The contract may specify an API to be implemented by the deploy service and the custom deploy processors enabling method calls and execution of deploy operations by the custom deploy processors over deployable content accessed by the deploy service.

At a client request for customized deployment scenario is received specifying the type of content to be deployed and how. Alternatively or in combination the request may specify the characteristics of the service or application that needs to be deployed and provided to the customers of the client. Based on the request one or more custom deploy processors are developed compliant with the defined contract at . The one or more custom deploy processors provide the functionality necessary for deploying content in a scenario based on the received client request. The developed one or more custom deploy processors are implemented in the cloud based application platform as plugins of the deploy service according to the contract.

The developed and implemented one or more custom deploy processors may be started or instantiated when the cloud based application platform starts or when an application server on the cloud based application platform starts or when the deploy service is instantiated. Regardless the triggering condition when instantiated a custom deploy processor registers with the cloud based application platform or with the application server or directly with the deploy service at . The registration may be as simple as creating a corresponding record with identification data in a registry where the registry may be a file or a table or some other data structure accessible by the deploy service. In one embodiment the registering custom deployment scenario may provide additional metadata together with the identification data. The metadata may contain declaration or configuration information to filter the deployable content passed to the custom deploy processor plugin.

By following process any number of developed custom deploy processors may be available for calling and utilizing by the deploy service. For example the deploy service may not know how many custom deploy processors are created for a particular customized deployment scenario. The deploy service opens a service registry upon deployment request reads or identifies the registered custom deploy processors discovers them based on the register data and passes the deployable content to all one by one and or in parallel. The customized deployment scenario may be executed as requested by the client when the one or more custom deploy processors recognize and deploy the specific content as required when called by the deploy service. The created custom deploy processors could be switched on and off e.g. on demand.

In one embodiment the role of a custom deploy processors may include finding data and or metadata in the deployable content and uploading this information to the cloud based application platform. The information uploaded by the custom deploy processor may be accessible by different components of the cloud based application platform e.g. during runtime and where components working over other services e.g. documentation widgets application affecting another application can find them. The custom deploy processor may provide not just deploy of specific information or application but also additional functionality to run the specific application or to run other applications in a specific way.

At deployable content is preprocessed or extracted e.g. from an archive on a local update site to be deployed to the repository of the cloud based application platform e.g. cloud repository . In one embodiment the deploy service could be the one responsible for extracting and or preprocessing the deployable content. Further the deploy service may collect all available IDeployListener services and call method IDeployListener.beginDeploy for each of them simultaneously or in parallel based on the predefined API. One or more Uniform Resource Identifiers URIs of Web application binaries to be deployed may be provided e.g. pointing to the local update site.

At a check is performed whether a method call for a IDeployListener service has failed. If for example a method call fails with exception the content deployed on the cloud repository will be removed at and the deployment will fail. All IDeployListener services that were called until this moment will be notified that the deployment has failed by calling the method IDeployListener.rollbackDeploy String passing an ID of the deploy operation as a String data type at .

When there are no failed method calls for the IDeployListener services the deployable content is deployed to the cloud repository at . After successful deployment of the content to the repository method IDeployListener.commitDeploy of the predefined API is called for all instantiated IDeployListener services to notify that the deploy operation was successful. The IDeployListener.commitDeploy method requires finalization of the customized deployment scenario processing of the deployable content by the IDeployListener services and the changes done by the customized deployment are stored persistently. At the temporarily locally extracted deployable content is deleted.

In one embodiment if a IDeployListener.commitDeploy method call fails with an exception the deploy service may continue calling the IDeployListener.commitDeploy method for the rest of the custom deploy processors. Afterwards an undeployment may be performed of the deployed artifacts in order to clean up possible inconsistencies. Thus a deployment failure may be simulated.

At all the available IDeployListener services are discovered or collected and the method IDeployListener.beginUndeploy is called for each of them by the deploy service. A check is performed at to verify whether a method call for a IDeployListener service has failed. In one embodiment if any of the method calls fails with an exception the undeploy operation will fail with error. All available IDeployListener services that were called until this moment will be notified that the undeploy operation has failed by calling the method IDeployListener.rollbackUndeploy String passing an ID of the undeploy operation.

When there are no failed method calls for the IDeployListener services content corresponding to the customized deployment scenario is undeployed from the repository of the cloud based application platform at . After successful undeployment of the content method IDeployListener.commitUndeploy of the predefined API is called for all instantiated IDeployListener services to notify that the undeploy operation was successful. This requires finalization of the content processing by the services and storing any changes persistently.

In one embodiment the deploy service may crash during the execution of a deploy or undeploy operation. Therefore the deploy service may persist a status of a currently executed operation or operations to be able to rollback unfinished processing after a crash. In one embodiment the processing of deploy and or undeploy operations may have transactional behavior. For example the data processed in method call IDeployListener.beginDeploy makes no changes in the repository or any other store that are not revertible. The implementation waits for a call of any of the methods IDeployListener.commitDeploy or IDeployListener.rollbackDeploy in order to complete the operation. If the method IDeployListener.commitDeploy or IDeployListener.rollbackDeploy fails with exception an error will be logged but the deploy or undeploy operation may continue because at that point the operation cannot be undone.

In one embodiment the implementation of a IDeployListener service could be placed in a new component of the cloud based application platform e.g. a new OSGi bundle and may be included in a deploy service feature. Table 1 illustrates an example source code definition of such IDeployListener service 

Some embodiments may include the above described methods being written as one or more software components. These components and the functionality associated with each may be used by client server distributed or peer computer systems. These components may be written in a computer language corresponding to one or more programming languages such as functional declarative procedural object oriented lower level languages and the like. They may be linked to other components via various application programming interfaces and then compiled into one complete application for a server or a client. Alternatively the components maybe implemented in server and client applications. Further these components may be linked together via various distributed programming protocols. Some example embodiments may include remote procedure calls being used to implement one or more of these components across a distributed programming environment. For example a logic level may reside on a first computer system that is remotely located from a second computer system containing an interface level e.g. a graphical user interface . These first and second computer systems can be configured in a server client peer to peer or some other configuration. The clients can vary in complexity from mobile and handheld devices to thin clients and on to thick clients or even other servers.

The above illustrated software components are tangibly stored on a computer readable storage medium as instructions. The term computer readable storage medium should be taken to include a single medium or multiple media that stores one or more sets of instructions. The term computer readable storage medium should be taken to include any physical article that is capable of undergoing a set of physical changes to physically store encode or otherwise carry a set of instructions for execution by a computer system which causes the computer system to perform any of the methods or process steps described represented or illustrated herein. Examples of computer readable storage media include but are not limited to magnetic media such as hard disks floppy disks and magnetic tape optical media such as CD ROMs DVDs and holographic devices magneto optical media and hardware devices that are specially configured to store and execute such as application specific integrated circuits ASICs programmable logic devices PLDs and ROM and RAM devices. Examples of computer readable instructions include machine code such as produced by a compiler and files containing higher level code that are executed by a computer using an interpreter. For example an embodiment may be implemented using Java C or other object oriented programming language and development tools. Another embodiment may be implemented in hard wired circuitry in place of or in combination with machine readable software instructions.

A data source is an information resource. Data sources include sources of data that enable data storage and retrieval. Data sources may include databases such as relational transactional hierarchical multi dimensional e.g. OLAP object oriented databases and the like. Further data sources include tabular data e.g. spreadsheets delimited text files data tagged with a markup language e.g. XML data transactional data unstructured data e.g. text files screen scrapings hierarchical data e.g. data in a file system XML data files a plurality of reports and any other data source accessible through an established protocol such as Open DataBase Connectivity ODBC produced by an underlying software system e.g. ERP system and the like. Data sources may also include a data source where the data is not tangibly stored or otherwise ephemeral such as data streams broadcast data and the like. These data sources can include associated data foundations semantic layers management systems security systems and so on.

Although the processes illustrated and described herein include series of steps it will be appreciated that the different embodiments are not limited by the illustrated ordering of steps as some steps may occur in different orders some concurrently with other steps apart from that shown and described herein. In addition not all illustrated steps may be required to implement a methodology in accordance with the presented embodiments. Moreover it will be appreciated that the processes may be implemented in association with the apparatus and systems illustrated and described herein as well as in association with other systems not illustrated.

The above descriptions and illustrations of embodiments including what is described in the Abstract is not intended to be exhaustive or to limiting to the precise forms disclosed. While specific embodiments and examples are described herein for illustrative purposes various equivalent modifications are possible as those skilled in the relevant art will recognize. These modifications can be made in light of the above detailed description. Rather the scope of the specification is to be determined by the following claims which are to be interpreted in accordance with established doctrines of claim construction.

