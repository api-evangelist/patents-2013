---

title: Transferring objects between virtual machines
abstract: Object calls for objects not available on a local virtual machine are fulfilled by requesting the object itself from a remote virtual machine and reconstructing a local instance of the requested object on the local virtual machine. The local instance is reconstructed using information about the class, variables, and methods associated with the remote instance of the object communicated to the local virtual machine. Present and future calls to the object are then directed to the local instance of the requested object.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09135039&OS=09135039&RS=09135039
owner: INTERNATIONAL BUSINESS MACHINES CORPORATION
number: 09135039
owner_city: Armonk
owner_country: US
publication_date: 20130530
---
This application is a continuation of U.S. patent application Ser. No. 12 938 595 filed Nov. 3 2010 entitled TRANSFERRING OBJECTS BETWEEN VIRTUAL MACHINES now allowed the disclosure of which is hereby incorporated by reference.

Various aspects of the present invention relate generally to virtual machines and more particularly to the efficient transfer of objects between virtual machines.

A virtual machine is a software representation of a physical machine that provides resources and abstractions to software running within the virtual machine. A virtual machine may be implemented as a system virtual machine which can be used to create a virtual environment in which an operating system programs and other software can execute as if the software were being executed on a conventional physical machine. A virtual machine may also be implemented as a process virtual machine which can be used to create a virtual environment that supports a single application or process.

A virtual machine is software and must therefore run on a physical machine. However a single physical machine may host multiple virtual machines. When a virtual machine is started the underlying physical machine allocates memory resources called a heap to the virtual machine. As such each virtual machine has a unique reserved memory space within the memory of the host physical machine. Examples of virtual machines include but are not limited to Java virtual machine Parrot CPython and the Perl virtual machine.

Object oriented programming is a programming paradigm that facilitates application development utilizing data structures to represent bundled state and behavior information as objects. In object oriented programming classes are used to define the types of objects available to an application. Basically a class is a template on which objects are based. An object is created instantiated from a class and thus represents a specific instance of the class from which the object is instantiated. Each object stores variables sometimes called fields or attributes which are used to represent the state of the object. Each object also stores methods sometimes called functions which are used to represent the behavior of the object. In the context of object oriented processing using virtual machines the classes and or objects necessary to an application executing in a virtual machine are stored in the virtual machine s heap.

According to aspects of the present invention an object call is fulfilled by identifying a reference to an object made by an application where the referenced object is not located on a local virtual machine hosting the application. Further the object call is fulfilled by identifying a remote virtual machine having an instance of the referenced object and by requesting object information from the identified remote virtual machine. Still further the object call is fulfilled by creating a local instance of the requested object by reconstructing the object on the local virtual machine based at least in part on information about the runtime state of the object on the remote virtual machine and by delegating future object calls referencing the object by the application to the local instance of the object.

Various aspects of the present invention relate to the transfer of objects between virtual machines. In object oriented programming an object comprises variables which identify the state of the object and methods which identify the behavior of the object. Together the object s variables and methods define the runtime state of the object. Depending upon the specific needs of an application objects can range from relatively simple to extremely complex. For example in the context of Java based applications Plain Old Java Objects POJO are simple Java objects which usually do not have many levels of cross reference to other objects. Thus a POJO is generally considered a light weight object. Comparatively Enterprise Java beans are typically considered heavy weight objects.

Memory resources are allocated to a virtual machine in a structure called a heap. A heap is typically a contiguous block of physical memory that is reserved for use by an associated virtual machine. Thus the heap is intrinsically tied to a resource on a physical machine that is running the virtual machine. One of the aspects of the present invention is to enable communication between the heaps of multiple virtual machines i.e. inter heap communication.

Inter heap communication allows for the transfer of information such as objects from the heap of one virtual machine to the heap of another virtual machine. Thus for example inter heap communication can be used to transfer objects including the runtime state of the transferred object thus facilitating the ability to rapidly share and reuse code. According to aspects of the present invention inter heap communication between Java Virtual Machines enables a local Java Virtual Machine to reconstruct an object such as a POJO obtained from a remote virtual Java Virtual Machine locally in the heap of the local Java Virtual Machine.

Referring now to the drawings and in particular to a method for fulfilling an object call is illustrated according to various aspects of the present invention. The method may be embodied for example as a computer program product comprising a computer readable storage medium having computer readable program code embodied there on. When the computer readable program code is executed by a processor the program code implements the method . Moreover the method may be implemented by a processor of a computing device executing instructions stored in memory. The method may alternatively be distributed across multiple processors capable of communication with one another.

The method is useful for example for obtaining an object by an application associated with a first virtual machine by reconstructing an existing object from a second virtual machine.

The method is implemented by identifying a reference to an object made by an application where the referenced object is not located on a local virtual machine hosting the application. For instance an application running on a first virtual machine referred to herein as a local virtual machine makes a call for an object at . Accordingly a determination is made at e.g. by the runtime if the object is available locally present on the local machine. If the object is available then the application uses that object to fulfill the object call e.g. at . If the requested object is not available i.e. if the requested object is not locally present or located on a local virtual machine hosting the application a process is implemented for fulfilling the object call for the requested object.

Further the object call is fulfilled by identifying a remote virtual machine at that has an instance of the requested object. This identification process at is described in greater detail in reference to below. Moreover the object call is fulfilled by requesting object information associated with the object from the identified remote virtual machine. In response to the request the remote virtual machine returns for example a serialized object with the state of the object from the remote virtual machine intact. In this example the class definition of the object along with instance information runtime status which includes variables and methods associated with the object are returned to the caller such that the serialized object can be reverted back to a copy of the requested object.

Still further the object call is fulfilled by creating a local instance of the object at by reconstructing the object on the local virtual machine based at least in part on information about the runtime state of the object on the remote virtual machine. Keeping with the above example using the information received from the remote virtual machine e.g. a serialized version of the requested object the local virtual machine reconstructs the requested object. In practice creating a local instance of the object may be implemented using a mechanism built into the local virtual machine. However at the physical level the creation of a local instance of the object may be implemented by a processor of a corresponding host physical computer device which allocates the object to the physical memory heap associated with the local virtual machine.

Still further the object call is fulfilled by delegating current and future calls referencing the object by the application to the local instance of the object at . Thus current calls and future calls for the object by the application can use the locally stored version of the object at .

According to aspects of the present invention a local virtual machine can use an object located in another different virtual machine as is. In this regard the desired object in the remote virtual machine can be obtained without having to import class libraries into the local virtual machine or place the library references in the local virtual machine. Thus by way of illustration and not by way of limitation a class that implements a data access mechanism running on a remote virtual machine can be obtained and reconstructed into a local virtual machine so that an instance of the data access mechanism is also running in the local virtual machine. Moreover the process of obtaining the object e.g. the data access mechanism is achieved without exposing the object as a service over a high level protocol.

Referring to a flow chart illustrates an exemplary method for implementing the identification process of the method of . A list of names corresponding to remote virtual machines is supplied identified or otherwise derived e.g. by an associated programmer process or via other technique. The process comprises choosing a name from the list and selecting the remote virtual machine associated with the chosen name at . The process then queries the selected remote virtual machine at for the presence of the requested object. If the selected remote virtual machine responds at that the requested object is present then the method ends. For instance flow may return to requesting the object at in the example of . However if it is determined that the object is not available e.g. if the selected remote virtual machine responds that the object is not available then the method determines at if there are more names of remote virtual machines on the list that have not yet been selected.

If the list still includes unselected names and the requested object has not been located then the process selects a previously unselected name and selects the remote virtual machine associated with that name at . In a manner analogous to that described above the process flow loops back to which queries the selected remote virtual machine for the presence of an instance of the object. This process repeats until the requested object is found or all the names of virtual machines on the list have been selected.

If all of the names on the list have been selected and the requested object is not located then end of list processing is optionally performed at . The process at may report or otherwise throw an error. For instance in certain implementations it may be satisfactory to throw an error back to the user stating that the class definition could not be found. Still further an alternative process at may include for example but is not limited to reporting an error finding a shared class from a remote virtual machine not on the list and instantiating a new object finding an object available on a remote virtual machine not on the list and exposing that object as a service using a high level protocol and any combination thereof.

The name from the list may be chosen in several ways. In an illustrative example the first name on the list is chosen. If the selected virtual machine cannot provide the requested object the method works down the list until the object is provided or not found. The method may choose a name alphabetically and work through the list that way. Other techniques may alternatively be selected for ordering the list of virtual machines.

The method comprises starting a first virtual machine at with a unique bind name against which the objects are bound 

Further the command may include a permission grant to the virtual machine that is allowed to make a call i.e. the local virtual machine 

The classes which need to be transferable are marked using a marker interface to enable the transfers. The method thus further comprises exposing a class in the heap of the first virtual machine as transferable at . For example the class may be marked as Shareable 

The heap registry may be implemented as a service in the virtual machine that hands out objects to an application calling for the object e.g. virtual machine JVM in the above example and can be run on any port. Objects are registered in the heap registry using a bind name. A second virtual machine calls for an object of the class marked for transfer at . For instance the second virtual machine could comprise the local virtual machine associated with the process described with reference to .

The first virtual machine receives the request for the object at and determines at if an instance of the object is present on the first virtual machine. If an instance is present then the first virtual machine transmits the object information including the runtime state of the object at . The second virtual machine receives the information at and reconstructs an instance of the object on the first virtual machine at . If a determination is made at that an instance of the object is not present on the virtual machine the process may end.

An illustrative example of pseudo code provided below may be useful for example when writing code to compile the sources e.g. in a Java application. The code can be written such that when the source is referring to a class which is non existent in the classpath the class definition can also be obtained from a different virtual machine by enabling flags during compilation.

In general optimizations can be built into the compiler to generate class files in a manner that suits the transportation of that object to a different runtime. For instance in the context of a Java implementation the byte code generation may automatically be used when a marker interface Shareable is encountered as described above. Further modifications to the serialization algorithm may also be implemented. As such when a runtime requests an object in a different runtime a relatively small amount of work is required to recreate the object hierarchy in the new runtime. The Java runtime can be enabled to automatically get objects ready to be transportable when a virtual machine implements the Sharable interface or specific classes can be made shareable by specifying the specific classes as command line arguments. Since object construction happens within the runtime security implications major minor version matches etc. are taken care of. In case an object cannot be reconstructed a runtime exception such as NonTransportableException can be thrown. If an issue is found during the compilation phase itself the issue may be flagged as a compilation error.

Whenever an object cannot be found in a virtual machine a communication happens to the listed heap registries in the order listed e.g. at designated ports against the bind name. If a registration is found then the located object is serialized marshaled and reconstructed in the caller s virtual machine. This is a one time effort and may be equivalent for example to an RMI call. Subsequent object references are isolated to the caller s virtual machine.

The communication protocol between virtual machines includes but is not limited to RMI remote method invocation proprietary protocols or a combination thereof. However the protocol used should not be an application layer protocol because an application layer protocol adds unnecessary parsing of the data along the layers. The heap registry API could also be private so that only the virtual machines internal processes alone can use the API. Still further certain methods could be exposed to programmers who can write code to register their classes with the heap registry.

The heap API exposes certain methods including finder services transport services and object handling. For instance the heap API may expose methods to implement finder services such as locating class definitions based on bind names and locating a running object instance. The heap API may expose methods to implement transport services such as transporting a class definition and transporting an object instance.

The heap API may also expose methods to implement object handling services such as creating a new object locally fetching an object instance and introspecting a running object instance. By way of illustration an example usage of creating a new object locally comprises 

The introspect service allows a user to find a specific instance of an object if more than one are present on the remote machine. For example 

The above approach may be used to get a running instance of an object e.g. by filtering out a desired instance from many running instances of the desired object. By matching the MetaData argument to a value of an object s variable or method the introspector may be used to identify a specific running instance of the object.

Referring now to an example system is illustrated for implementing aspects disclosed herein. The exemplary system includes a local virtual machine LVM . The LVM is running an application and has a heap which includes a class library .

The system also includes a first remote virtual machine RVM . The first remote virtual machine RVM includes an application and a heap which includes a class library and several objects designated A N.

The system still further comprises a second virtual machine . The second remote virtual machine RVM includes an application and a heap which includes a class library and three objects designated as objects X  X  and Y. The class library of RVM includes a class definition for class X. Two of the objects in the RVM are instances class X and are thus further designated as X  and X . Object X  has a variable having the current value of A and a method defined as B. Variable A and method B comprise the runtime status of object X . Similarly the value of the variable associated with object X  is designated C . Variable C and method B comprise the runtime status of object X .

The local virtual machine and remote virtual machines may be executed on the same physical machine or the local virtual machine and remote virtual machines may be distributed across multiple physical machines.

The local virtual machine is so named because it is the virtual machine running the application . RVM and RVM are identified as potential sources for objects e.g. RVM and RVM may be on a list of remote virtual machines to look for any objects not available on the LVM as described in greater detail herein.

The application running on the LVM makes a call for an object which is of class X. The class library on the LVM does not have a definition for the class X so the LVM looks for an instance of class X on the remote virtual machines . The LVM selects RVM which is the first name on the list of remote virtual machines and makes a query to determine if an instance of class X is present on RVM . While RVM has some objects in its heap none of those objects are of class X. RVM replies that it does not have an instance of class X.

The LVM proceeds to the next name on the list RVM and makes a query to determine if an instance of class X is present on RVM . RVM has two objects object X  and object X  of class X present in its heap . Therefore RVM can respond to the request. Moreover there are two instances of an object of class X. Therefore a process is utilized to filter the object instances e.g. based upon a metadata argument. In the illustrative example object X  is selected to respond to the request. RVM transmits to the LVM a serialized version of object X  as illustrated by the dashed lines.

The LVM uses the class and instance information to reconstruct a local instance of object X . So within the system there are two identical versions of object X  one on RVM and one on the LVM . All future calls to object X  made by the application on the LVM are fulfilled by the local instance of the object now in heap .

The two instances of the object are identical when the local instance is reconstructed. However either application may make changes to the state of the object associated with their virtual machine respectively. Eventually the two instances of the object may not be identical.

Besides the benefits mentioned above concerning performance and resource management the present invention may also be used as a type of Object as a Service similar to Software as a Service concept. Therefore code developed by one developer may be shared by another developer.

Various aspects of the present invention provide approaches for reconstructing an object locally such that the class library of the local virtual machine does not need to have a full set of class definitions required for the application. Moreover as described herein the local virtual machine has to query outside its own heap only once. In this regard all future calls to the object are then referenced to the locally instantiated object. Moreover there is less overhead than when using high level protocols such as but not limited to SOAP simple object access protocol CORBA common object request broker architecture and REST style representational state transfer communication for implementing requests.

Referring to a block diagram of a data processing system is depicted in accordance with the present invention. Data processing system may comprise a symmetric multiprocessor SMP system or other configuration including a plurality of processors connected to system bus . Alternatively a single processor may be employed. Also connected to system bus is memory controller cache which provides an interface to local memory . An I O bus bridge is connected to the system bus and provides an interface to an I O bus . The I O bus may be utilized to support one or more buses and corresponding devices such as bus bridges input output devices I O devices storage network adapters etc. Network adapters may also be coupled to the system to enable the data processing system to become coupled to other data processing systems or remote printers or storage devices through intervening private or public networks.

Also connected to the I O bus may be devices such as a graphics adapter storage and a computer usable storage medium having computer usable program code embodied thereon. The computer usable program code may be executed to implement any aspect of the present invention for example to implement any aspect of any of the methods and or system components illustrated in . Moreover the computer usable program code may be utilized to implement any other processes that are associated with transferring objects inter heap communication or other aspects as set out further herein.

The data processing system depicted in may comprise for example an IBM RS 6000 system a product of International Business Machines Corporation in Armonk N.Y. running the Advanced Interactive Executive AIX operating system. An object oriented programming system such as Java may run in conjunction with the operating system and provides calls to the operating system from Java programs or applications executing on data processing system.

As will be appreciated by one skilled in the art aspects of the present invention may be embodied as a system method or computer program product. Accordingly aspects of the present invention may take the form of an entirely hardware embodiment an entirely software embodiment including firmware resident software micro code etc. or an embodiment combining software and hardware aspects that may all generally be referred to herein as a circuit module or system. Furthermore aspects of the present invention may take the form of a computer program product embodied in one or more computer readable storage medium s having computer readable program code embodied thereon e.g. providing program code for use by or in connection with a computer or any instruction execution system.

Any combination of one or more computer readable medium s may be utilized. The computer readable medium may be a computer readable signal medium or a computer readable storage medium. A computer readable storage medium may be for example but not limited to an electronic magnetic optical electromagnetic infrared or semiconductor system apparatus or device or any suitable combination of the foregoing. More specific examples a non exhaustive list of the computer readable storage medium would include the following an electrical connection having one or more wires a portable computer diskette a hard disk a random access memory RAM a read only memory ROM an erasable programmable read only memory EPROM or Flash memory an optical fiber a portable compact disc read only memory CD ROM an optical storage device a magnetic storage device or any suitable combination of the foregoing. In the context of this document a computer readable storage medium may be any tangible medium that can contain or store a program for use by or in connection with an instruction execution system apparatus or device.

A computer readable signal medium may include a propagated data signal with computer readable program code embodied therein for example in baseband or as part of a carrier wave. Such a propagated signal may take any of a variety of forms including but not limited to electro magnetic optical or any suitable combination thereof. A computer readable signal medium may be any computer readable medium that is not a computer readable storage medium and that can communicate propagate or transport a program for use by or in connection with an instruction execution system apparatus or device.

Program code embodied on a computer readable medium may be transmitted using any appropriate medium including but not limited to wireless wireline optical fiber cable RF etc. or any suitable combination of the foregoing.

Computer program code for carrying out operations for aspects of the present invention may be written in any combination of one or more programming languages including an object oriented programming language such as Java Smalltalk C or the like and conventional procedural programming languages such as the C programming language or similar programming languages. The program code may execute entirely on the user s computer partly on the user s computer as a stand alone software package partly on the user s computer and partly on a remote computer or entirely on the remote computer or server. In the latter scenario the remote computer may be connected to the user s computer through any type of network including a local area network LAN or a wide area network WAN or the connection may be made to an external computer for example through the Internet using an Internet Service Provider .

Aspects of the present invention are described below with reference to flowchart illustrations and or block diagrams of methods apparatus systems and computer program products according to embodiments of the invention. It will be understood that each block of the flowchart illustrations and or block diagrams and combinations of blocks in the flowchart illustrations and or block diagrams can be implemented by computer program instructions. These computer program instructions may be provided to a processor of a general purpose computer special purpose computer or other programmable data processing apparatus to produce a machine such that the instructions which execute via the processor of the computer or other programmable data processing apparatus create means for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

These computer program instructions may also be stored in a computer readable medium that can direct a computer other programmable data processing apparatus or other devices to function in a particular manner such that the instructions stored in the computer readable medium produce an article of manufacture including instructions which implement the function act specified in the flowchart and or block diagram block or blocks.

The computer program instructions may also be loaded onto a computer other programmable data processing apparatus or other devices to cause a series of operational steps to be performed on the computer other programmable apparatus or other devices to produce a computer implemented process such that the instructions which execute on the computer or other programmable apparatus provide processes for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

The flowchart and block diagrams in the Figures illustrate the architecture functionality and operation of possible implementations of systems methods and computer program products according to various embodiments of the present invention. In this regard each block in the flowchart or block diagrams may represent a module segment or portion of code which comprises one or more executable instructions for implementing the specified logical function s . It should also be noted that in some alternative implementations the functions noted in the block may occur out of the order noted in the figures. For example two blocks shown in succession may in fact be executed substantially concurrently or the blocks may sometimes be executed in the reverse order depending upon the functionality involved. It will also be noted that each block of the block diagrams and or flowchart illustration and combinations of blocks in the block diagrams and or flowchart illustration can be implemented by special purpose hardware based systems that perform the specified functions or acts or combinations of special purpose hardware and computer instructions.

The terminology used herein is for the purpose of describing particular embodiments only and is not intended to be limiting of the invention. As used herein the singular forms a an and the are intended to include the plural forms as well unless the context clearly indicates otherwise. It will be further understood that the terms comprises and or comprising when used in this specification specify the presence of stated features integers steps operations elements and or components but do not preclude the presence or addition of one or more other features integers steps operations elements components and or groups thereof.

The corresponding structures materials acts and equivalents of all means or step plus function elements in the claims below are intended to include any structure material or act for performing the function in combination with other claimed elements as specifically claimed. The description of the present invention has been presented for purposes of illustration and description but is not intended to be exhaustive or limited to the invention in the form disclosed. Many modifications and variations will be apparent to those of ordinary skill in the art without departing from the scope and spirit of the invention. The embodiment was chosen and described in order to best explain the principles of the invention and the practical application and to enable others of ordinary skill in the art to understand the invention for various embodiments with various modifications as are suited to the particular use contemplated.

Having thus described the invention of the present application in detail and by reference to embodiments thereof it will be apparent that modifications and variations are possible without departing from the scope of the invention defined in the appended claims.

