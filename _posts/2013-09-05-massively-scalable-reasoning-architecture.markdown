---

title: Massively scalable reasoning architecture
abstract: Techniques for reasoning data are disclosed. The techniques may include storing data in an ontology. The data may be partitioned and/or distributed to a plurality of reasoners. Processed data from the plurality of reasoners may then be combined, the processed data having been received from the plurality of reasoners and/or having been processed by the plurality of reasoners.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08756191&OS=08756191&RS=08756191
owner: Oracle International Corporation
number: 08756191
owner_city: Redwood Shores
owner_country: US
publication_date: 20130905
---
This application is a continuation of prior U.S. application Ser. No. 12 874 821 filed on Sep. 2 2010 titled Massively Scalable Reasoning Architecture and claims the benefit of U.S. Provisional Application Ser. No. 61 253 054 filed on Oct. 19 2009 titled Massively Scalable Reasoning Architecture the contents of each are hereby incorporated in their entirety by reference. This application also incorporates by reference for all purposes co pending U.S. patent application Ser. No. 12 576 176 filed on Oct. 08 2009 entitled Techniques for Processing Ontologies and U.S. patent application Ser. No. 12 581 804 filed on Oct. 19 2009 entitled Techniques for Extracting Semantic Data Stores. 

Businesses often have internal business policies intended to address a wide range of issues such as security privacy trade secrets criminal activity of employees or others with access to the business and many others. These business policies address various aspects of a business such as purchasing selling marketing and internal administration. Because of the large number of activities occurring during the course of running a business which may have various entities located in a variety of geographical locations it is often impractical to manually monitor all activities in which improper behavior or mistakes may occur.

One approach to implementing business policies has been to monitor and control computer systems used to facilitate a business activities. For example information regarding various activities such as sales and payroll are often stored in one or more data stores. This information may be analyzed to find activity that might be in violation of a business policy such as an item on an invoice or paycheck to an employee being outside of a specified range or a particular employee attempting to access information to which he or she is not entitled access.

One approach to monitoring and controlling a business computer systems involves storing business data in one or more ontologies. With the advent of semantic technologies the importance of ontologies and semantic query languages has grown manifold. An ontology is a formal representation of knowledge specifically a formal representation of a set of concepts within a domain and relationships between the concepts. Ontologies are used in several different areas including business analytics enterprise systems artificial intelligence and the like and have the potential to be used in several other fields and applications 

An ontology is typically encoded using an ontology language. Several ontology languages are available. The OWL Web Ontology Language has become the industry standard for representing web ontologies. OWL can be used to explicitly represent the meaning of terms in vocabularies and the relationships between the terms. OWL thus provides facilities for expressing meaning and semantics that goes far beyond the capabilities of languages such as XML. OWL is being developed by the Web Ontology Working Group as part of the W3C Semantic Web Activity. Further information related to OWL may be found at the W3C website 

An ontology may be persisted in memory such as in a database or other data store. There are several standard ways of querying and manipulating the data in an ontology using query languages such as RDQL Resource Description Format Query Language OWL QL SPARQL SPARQL Protocol and RDF Query Language and others. Among the ontology query languages SPARQL is considered by many to be the de facto industry standard.

In the context of a business data from one or more data stores may be periodically compiled in an ontology such as in a batch process occurring at times when there is less use of the business computer systems such as at night when most employees are not present. Once compiled in an ontology an ontology reasoner can be used to make logical inferences from the ontology. Generally an ontology reasoner or semantic reasoning module is a module implemented in hardware or software executed by a processor configured to infer logical consequences from a set of facts or axioms stored in an ontology. This process is often referred to as reasoning. Data from an ontology may be converted into a form convenient for processing by the reasoner such as in a manner described in co pending U.S. patent application Ser. No. 12 576 176 entitled Techniques for Processing Ontologies filed on Oct. 8 2009 and which is incorporated herein by reference for ail purposes. Ontology reasoners are also known as reasoning engines rules engines or simply reasoners. Examples include RETE based rules engines such as JESS a rules engine for the Java platform available for download at http www.jessrules.com and probabilistic description logic reasoners such as Pronto available from Clark Parsia LLC located at 926 N St. NW Rear Studio 1 Washington D.C. 20001. Ontology reasoners typically incorporate algorithms that if possible avoid analyzing complete data sets and instead analyze only relevant data.

Often the rules used by reasoners to ensure compliance with one or more policies change over time. For example as laws computer systems and other things applicable to a business operations change new types of fraud emerge. In addition those wishing to perpetrate fraud on a business become more clever as prior ways of committing fraud become known and therefore more easily detected. Thus in order to detect emerging methods of committing fraud or generally in order to ensure compliance with new and or changing policies the reasoners that analyze data must be updated accordingly. Typically updating reasoners is a cumbersome process that involves reprogramming the rules by which the reasoners operate.

Moreover different reasoners may use data in various ways. For instance pattern based reasoners analyze data using various statistical techniques in order to make inferences based on the analysis. As an example correlations among invoice amounts check amounts and other data items may be found using statistical techniques in order to identify potential cases of fraud. Likewise various statistical techniques may be used to identify suspicious transactions for follow up by an investigator. For instance patterns for spending transferring money and the like may be analyzed so that activity falling outside of a pattern may be identified as potential fraud.

Other types of reasoners may use data in a completely different way. For instance transitive reasoners may be used to infer relationships from a given set of relationships as will be discussed in more detail below. Briefly a transitive reasoner may infer that because a first entity is related to a second entity and because the second entity is related to a third entity the first entity is related to the third entity. Typically while various reasoners provide useful information in various contexts combination of disparate reasoners has been difficult to achieve.

The following presents a simplified summary of some embodiments of the invention in order to provide a basic understanding of the invention. This summary is not an extensive overview of the invention. It is not intended to identify key critical elements of the invention or to delineate the scope of the invention. Its sole purpose is to present some embodiments of the invention in a simplified form as a prelude to the more detailed description that is presented later.

Embodiments of the present invention provide techniques for reasoning data. In one embodiment a method of reasoning data is disclosed. The method may be performed under the control of one or more computer systems configured with executable instructions and may include storing data in an ontology partitioning the data of the ontology distributing the partitioned data to a plurality of reasoners and combining processed data received from the plurality of reasoners the processed data having been processed by the plurality of reasoners. The method may also include enabling at least one of the plurality of reasoners to reason the data using at least one semantic reasoning module and at least one pattern based reasoning module in series with the semantic reasoning module to determine a conclusion. In one embodiment reasoning the data by the at least one of the plurality of reasoners includes using output of at least one of the semantic reasoning module or the pattern based reasoning module as input of at least the other of the semantic reasoning module or the pattern based reasoning module. Further the ontology may be encoded using a business ontology language the data may be created from a plurality of business data sources the data may be encoded in a matrix and or combining the processed data may include connecting results from different reasoners of the plurality of reasoners according to a relationship associating different sets of the results.

In another embodiment a system for reasoning data is disclosed. The system includes a memory storing a plurality of instructions and a processor configured to access the memory wherein the processor is further configured to execute the plurality of instructions. The instructions when executed may cause the system to store data in an ontology of the memory partition the data of the ontology distribute the partitioned data to a plurality of reasoners and or combine processed data received from the plurality of reasoners the processed data having been processed by the plurality of reasoners. The instructions when executed may also cause the system to enable at least one of the plurality of reasoners to reason the data using at least one semantic reasoning module and at least one pattern based reasoning module in series with the semantic reasoning module to determine a conclusion. The reasoning of the data by the at least one of the plurality of reasoners may include using output of at least one of the semantic reasoning module or the pattern based reasoning module as input of at least the other of the semantic reasoning module or the pattern based reasoning module. Further the data may be stored in the ontology based at least in part on a periodically executed batch process the data stored in the ontology may be transformed using an adapter configured to convert the data from a first form to a second form suitable for storage in the ontology and or a matrix of the data is partitioned using one or more matrix partitioning techniques or a directed graph of the data is partitioned using one or more graph partitioning techniques. In some examples combining the processed data may comprise connecting results from different reasoners of the plurality of reasoners according to a relationship associating different sets of the results.

In yet another embodiment a computer readable storage medium having stored thereon instructions for causing one or more computer systems to perform instructions. The instructions include instructions that cause the one or more processors to cause storage of data in an ontology of the memory and partitioning of the data of the ontology. The instructions may also cause distribution of the partitioned data to a plurality of reasoners and combination of processed data received from the plurality of reasoners the processed data having been processed by the plurality of reasoners. The instructions may also cause enablement of at least one of the plurality of reasoners to reason the data using at least one semantic reasoning module and at least one pattern based reasoning module in series with the semantic reasoning module to determine a conclusion. Also reasoning of the data by the at least one of the plurality of reasoners may include using output of at least one of the semantic reasoning module or the pattern based reasoning module as input of at least the other of the semantic reasoning module or the pattern based reasoning module. The combining of the processed data may comprise connecting results from different reasoners of the plurality of reasoners according to a relationship associating different sets of the results. In some aspects a matrix of the data may be partitioned using one or more matrix partitioning techniques or a directed graph of the data is partitioned using one or more graph partitioning techniques. In on example the ontology may be encoded using a business ontology language.

For a fuller understanding of the nature and advantages of the present invention reference should be made to the ensuing detailed description and accompanying drawings.

In the following description for the purposes of explanation specific details are set forth in order to provide a thorough understanding of embodiments of the invention. However it will be apparent that the invention may be practiced without these specific details.

The following description describes an embodiment of the present invention in the business policy domain and specifically with implementing business policies using ontologies that encode business data. However the scope of the present invention is not restricted to business policies but may be applied to other domains or applications. For example any domain or application where a set of rules or criteria is used to analyze data may make use of the present invention. Examples of domains in which embodiments of the present invention may be used include segregation of duties separation of powers transaction monitoring fraud or other crime detection semantic web applications and generally applications dealing with large sets of data.

In general embodiments of the present invention provide techniques for processing one or more ontologies where the ontologies encode data such as business data. Processing ontologies can be used for example in order to implement business policies where unless otherwise clear from context a policy is a set of one or more conditions and a set of one or more actions to be taken when the one or more of the conditions are met. For example a policy may specify that all transactions of a certain type such as credit card charges over a specified amount require approval by a person of a specified class such as a manager. In this example the conditions of the policy are that transactions have a specified type and amount and an action of the policy is authorization of transactions meeting the conditions by a person of a specified class. An action of a policy may also be simply identification of data that meets the policy s condition s . For instance a policy may specify that all transactions of a certain type and over a certain amount should be identified. In this example the conditions are the same as in the previous example but the action is identification of transactions meeting the conditions so that for example a manager may review the identified transactions and investigate any transactions he or she deems suspicious.

Typically a policy is used to implement a business policy which is one or more rules guidelines and or principles related to the conduct of a business. For instance a business policy specifying that invoices over a specific amount require manager approval may be implemented by creating a policy that includes criteria for identifying invoices over the specified dollar amount from information stored in one or more data stores.

In a specific embodiment business data is extracted from a plurality of operational data stores of an organization and stored in one or more semantic data stores where the one or more semantic data stores store data in a manner associating the data among one another according to semantic relationships among semantic objects represented by the data. The data in the one or more semantic data stores is then reasoned with a reasoner. The reasoner in this embodiment comprises a modular architecture that includes a plurality of reasoning modules. The reasoning modules may be semantic reasoning modules pattern based reasoning modules and or other types of reasoning modules and or composites of various types of reasoning modules. Reasoning modules with their own input and output format types may be added to the reasoner dynamically and in order.

Turning now to the drawings is a simplified block diagram of a computer system that may be used to practice an embodiment of the present invention. Computer system may serve as a user workstation or server such as those described in connection with below. As shown in computer system includes a processor that communicates with a number of peripheral subsystems via a bus subsystem . These peripheral subsystems may include a storage subsystem comprising a memory subsystem and a file storage subsystem user interface input devices user interface output devices and a network interface subsystem .

Bus subsystem provides a mechanism for letting the various components and subsystems of computer system communicate with each other as intended. Although bus subsystem is shown schematically as a single bus alternative embodiments of the bus subsystem may utilize multiple busses.

Network interface subsystem provides an interface to other computer systems networks and portals. Network interface subsystem serves as an interface for receiving data from and transmitting data to other systems from computer system .

User interface input devices may include a keyboard pointing devices such as a mouse trackball touchpad or graphics tablet a scanner a barcode scanner a touch screen incorporated into the display audio input devices such as voice recognition systems microphones and other types of input devices. In general use of the term input device is intended to include all possible types of devices and mechanisms for inputting information to computer system . A user may use an input device in order to execute commands in connection with implementation of specific embodiments of the present invention such as to select reasoning modules for and direct operation of a reasoner as described below.

User interface output devices may include a display subsystem a printer a fax machine or non visual displays such as audio output devices etc. The display subsystem may be a cathode ray tube CRT a flat panel device such as a liquid crystal display LCD or a projection device. In general use of the term output device is intended to include all possible types of devices and mechanisms for outputting information from computer system . Results of implementing policies defining policies and configuring various components of a computer system may be output to the user via an output device 

Storage subsystem provides a computer readable medium for storing the basic programming and data constructs that provide the functionality of the present invention. Software programs code modules instructions that when executed by a processor provide the functionality of the present invention may be stored in storage subsystem . These software modules or instructions may be executed by processor s . Storage subsystem may also provide a repository for storing data used in accordance with the present invention for example the data stored in the diagnostic data repository. For example storage subsystem provides a storage medium for persisting one or more ontologies. Storage subsystem may comprise memory subsystem and file disk storage subsystem .

Memory subsystem may include a number of memories including a main random access memory RAM for storage of instructions and data during program execution and a read only memory ROM in which fixed instructions are stored. File storage subsystem provides persistent non volatile storage for program and data files and may include a hard disk drive a floppy disk drive along with associated removable media a Compact Disk Read Only Memory CD ROM drive an optical drive removable media cartridges and other like storage media.

Computer system can be of various types including a personal computer a portable computer a workstation a network computer a mainframe a kiosk personal digital assistant PDA cellular telephone a server or any other data processing system. Due to the ever changing nature of computers and networks the description of computer system depicted in is intended only as a specific example for purposes of illustrating the preferred embodiment of the computer system. Many other configurations having more or fewer components than the system depicted in are possible.

In accordance with an embodiment the enterprise computer system includes a first location and a second location communicatively connected by a network such as the Internet or any suitable communications network or combination of networks. In an embodiment the first location and second location correspond to separate physical locations of a business such as offices in two separate cities states or countries. While shows two locations it should be understood that a business may have only a single location and may include more than two locations. As shown in the drawing the enterprise computer system may include one or more user workstations a development server and a developer workstation . The user workstation development server and or development workstation may be physically present at any of the locations or at separate locations. In an embodiment the user workstation and development server are communicatively connected to the network so as to access various components of the enterprise computer system. For example the user workstation may include a browser used for viewing content provided from the Internet and or from other systems within the business. Further the developer workstation may be connected to the network through the development server and may be adapted to enable certain employees within the organization to configure install modify and perform other actions in connection with the business computing systems. As an example a developer within the organization may utilize the developer workstation in order to create policies that are used to define policies and execute one or more applications that stores data in one or more ontologies and that reason the data according to the policies in accordance with various embodiments of the invention. Instructions for controlling the applications and the defined policies may be sent over the network to an appropriate computing device executing the one or more applications.

As noted above the first location may include various computer systems used in operating the business. For example as depicted in the first location includes a web server configured to receive requests from various users such as from a user of the user workstation and to respond to the requests over the network . While shows the web server as a hardware component as with any of the servers described herein the web server may also be a software module operating on a computer system. Responses from the web server may be provided from the web server itself or through the web server but from a variety of sources in communication with the web server such as from components of an internal computer system of the first location or from other web servers located at other possibly third party locations.

In an embodiment the web server is communicably coupled to an application server which is a hardware component or software module configured to run one or more applications such as one or more policy engines and other applications for managing organizational data. As is known a user of the user workstation may send a request to the web server that specifies a specific action to be taken in connection with an internal business application implemented on the application server . The web server then relays the request to the application server which takes the specified action and returns the result of that action to the web server which in turn relays the result to the user workstation . In accordance with an embodiment the web server or other component may modify the content returned to the user workstation in accordance with one or more policies applicable to a user of the user workstation .

As shown in the example of the application server interacts with data stored in a first data store and a second data store each of which may store data relevant to the business operation such as in one or more relational or other databases. While the disclosed example shows the first location having two data stores it should be understood that the first location may have less than two data stores or more than two data stores. Information in the data stores can include a wide variety of data such as data relating to business transactions invoices human resources data user account data receipts bank account data accounting data payroll data and generally any data relevant to the operation of a particular business. Information from the data stores and other sources may be extracted from the data stores converted to a uniform format and stored in an ontology in accordance with an embodiment.

In an embodiment the second location includes its own web server application server first data store and second data store which may be configured to function similarly to the identically named components above.

In an embodiment data is stored in an ontology by creating ontology data from various business data sources at a data storage step . As noted below the data can be enterprise business data or generally any type of data. Storage of the data can be performed in a variety of ways. For instance in an embodiment a batch process is periodically executed that causes data stored in data stores to be compiled into an ontology. For instance data stored in a first form can be transformed using one or more adapters configured to convert data from a first form to a form suitable for storage in the ontology. In addition automatic Extract Transfer and Load ETL operations from a business data sources to a semantic data store that embodies the ontology may be defined and set to run when trigger conditions are met such as at certain times or when a certain amount of data has been changed.

At a partitioning step the ontology data is partitioned so as to be distributable among a plurality of processors. Each processor may implement the same or a different reasoner instance. Partitioning the data may include encoding the ontology data in a matrix such as in a manner described below and partitioning the matrix using one or more matrix partitioning techniques. In alternate embodiments the ontology data is not necessarily encoded in a matrix but is distributed using other methods. For instance because ontologies can be represented as graphs such as directed graphs graph partitioning techniques may be used. Generally any technique for partitioning data among a plurality of reasoners may be used.

At a distribution step the partitioned ontology data is distributed among a plurality of processors each of which may implement of instances of the same or a different reasoner. Techniques such as those described in by Jeffery Dean and Janjay Ghemawat published at the Sixth Symposium on Operating System Design and Implementation which is incorporated by reference for all purposes may be used to coordinate the actions of the reasoners. In this manner the processing of the ontology data is performed by a plurality of reasoners so as to reduce the time necessary for processing. At a combination step the results of the processing by the plurality of reasoners are combined into a set of processed data. Combination may include connecting results of separate processing according to relationships associating different sets of separately processed data such as data encoded in intersection vectors such as those described above. Again in an embodiment MapReduce techniques may be used to coordinate combination the results from the reasoners.

In this manner the work done in processing an ontology is performed efficiently and more quickly than if the ontology was processed with a single reasoner. Other benefits in using the above method are also incurred. For example the embodiments of the disclosed method allow for efficient handling of new and or modified data as described in more detail below in connection with .

As businesses and other organizations operate the data they store changes as a result of business operations. New invoices are created new payments are made to vendors employee roles change new people or organizations become customers peoples position within an organization changes and other events happen during the course of operating a business that may influence the addition subtraction or modification of associated data. Moreover because the amount of data stored by a business is typically very large creation or modification of an ontology based on the data typically takes a large amount of resources and therefore is performed as a batch process often during times when a business systems are under a lighter work load such as at a time of the day when many employees may be at home or when most potential customers are asleep.

As a concrete example A may represent John Doe and B may represent a specific class of employee such as a manager. In the relationship shown in the example of the first triple Pconnecting A to B indicates that John Doe is a manager. As shown in the example in relationships between nodes may be directional as indicated in the example by an arrow. For example continuing with the example of the first triple the arrow extending from A to B indicates that John Doe is a manager but not necessarily that all managers are John Doe. A node may relate to more than one other nodes. For example shows a second triple showing a relationship Pbetween the node A and a node D. Thus considering both the first triple and the second triple it can be seen that the node A relates to both B and to D by two different relationships. Specifically A is related to B by Pand related to D by P. For example D may indicate a class of employees having access to a particular system such as a security system accounting computer system and the like. Thus read together the first triple and second triple indicate that John Doe is a manager and John Doe also has access to the system represented by D. In addition various nodes can be related to each other through inferred relationships. Briefly for example shows a third triple showing a relationship Pbetween nodes B and C. Continuing the example discussed above C may be a specific set of accounting data for an organization. Thus the relationship represented by the third triple indicates that all managers have access to the accounting data Thus when reading the first triple and the third triple together a relationship between A and C may be inferred that John Doe has access to accounting data because John Doe is a manager. Further details on inferred relationships are provided below.

In an embodiment the data set may be represented in a matrix. For example shows a matrix in accordance with an embodiment. The matrix in the example shown is formed by a series of row vectors each row vector corresponding to a relationship of the data set . As shown in the example the order of the row vectors of the matrix does not have any particular significance however specific orderings such as an ordering proceeding according to an index of possible relationships and other orderings may be used.

Each column vector in the matrix represents a node and as with the row vectors the columns need not be in any particular order but may be. Matrix comprises an entry at each intersection of a row vector and a column vector. The entries in the matrix store values that encode data set . In an embodiment that values for the entries in matrix are either zeros or ones. Although the example given shows entries having values of 0 or 1 other values such as Boolean values of true and false or generally any set of distinguishable values may also be used in alternative embodiments.

As noted the columns and rows of the matrix may or may not be in any particular order. For instance in an embodiment data is extracted from one or more data stores and used to construct the matrix and the manner or order in which the matrix is constructed or extracted may dictate the matrix s initial form. For instance in an embodiment rows may be added to the matrix sequentially as relationships between extracted data are determined. In another embodiment columns may be appended to the matrix as each data point is examined to determine the relationships associated with the data point.

In an embodiment a particular row includes entries of zero or one. The relationship associated with the row may be determined by the one entries. Specifically a column of the matrix that intersects the row at a one entry is associated with a node involved in the relationship. Likewise a column of the matrix that intersects the row at a zero entry is associated with a node that is not involved in the relationship. Thus counting from the top looking at the first row of the matrix which corresponds to the relationship P the intersection between the A column and the Prow includes a zero entry thereby indicating that relationship Pdoes not involve the node A. The intersections of the Prow with columns J and I includes entries of one indicating that the relationship Pinvolves I and J. In a like manner ones or zeroes are filled in matrix to represent the relationships represented by data set .

It should be understood that while shows a matrix representation of the data set other representations can be used. For example matrices may be constructed differently than shown in the figures. For instance in an alternative embodiment row vectors may correspond to nodes while column vectors may correspond to relationships. As another example as is known data sets stored in ontologies may be represented in a graph a directed graph or another representation which may encode data differently. Techniques analogous to the techniques described below such as techniques for graph partitioning may also be used in accordance with the present invention. Further it should be understood that while the examples in the figures show graphical representations of specific matrices including the entries of the matrices matrices corresponding to data sets will typically be too large to be displayed in the same manner but may be stored in computer memory either volatile or non volatile in a manner dictated by a specific application used to create the matrices or other representations of the data.

In an embodiment the matrix is partitioned into a convenient form for example by using known techniques of linear algebra. For instance the matrix may be placed into block form by using elementary row operations such as swapping rows. Column operations such as switching columns may also be used. When row column or other operations are used an index vector list or other mechanism that may be part of the matrix or stored in another location may be updated to keep track of which relationships and or nodes correspond to each vector. For example each entry of the first row may include information such as a string or number identifying a particular relationship and the first entry of each column may include information identifying a particular node. In this manner when a row or column operation is performed the identifying information of the associated rows and or columns are affected by the operation in a way that keeps track of the rows and or columns. As a concrete example if the first and second rows are switched in an embodiment the information identifying the first row moves to the second row and the information identifying the second row moves to the first row.

In an embodiment partitioning a matrix includes arranging the columns such that the matrix encodes the directions of the relationships of the represented triples. Thus the columns may be arranged such that the column corresponding to the first node in a triple is to the left of the column corresponding to the second node in the triple. Other configurations of matrices that encode the direction of the relationships may also be used such as the inclusion of an additional encoding column that includes entries that correspond to the direction of triples included in a particular row. For instance an additional column may be added to the matrix so that the intersection of a row with the additional column includes a 0 if the order of the columns corresponds to the direction of the relationship encoded in the row and a 1 otherwise. For instance the first row has a 1 in the intersections with the I and J columns but the J column appears before the I column so the order to the I and J columns does not correspond to the relationship Pextending between the I and J nodes. Therefore in this example an encoding column would have a 1 in the intersection of the first row with the encoding column to indicate that the relationship Pextends from I to J.

In an embodiment with the columns arranged the rows are arranged so that the matrix is in block form. Matrices used in accordance with the present invention will generally be sparse matrices because each row in an embodiment will have only two non zero entries corresponding to the specific data represented in the row. As a result such partitioning may be performed to form a matrix having more than one block which is convenient for visualizing and processing of the data set as described more fully below.

Generally when a matrix is used to encode data the matrix can be partitioned into a convenient form such as block form using various techniques. For example spectral partitioning can be used to partition incidence Laplacian or other matrices that encode a graph representative of ontological data. Likewise multilevel coarsening and partitioning techniques such as those that coarsen partition and then uncoarsen a matrix may be used. Of course hybrid approaches of the above techniques and or other techniques can be used as well.

It should be noted that such rearrangement of the columns may not be straight forward if a data set includes a circuit which is a set of one or more nodes and one or more relationships arranged such that an inferred or direct relationship exists between a node and itself. For example a circuit exists in a situation where A relates to B B relates to C and C relates to A with the directions of the relationships extending from A to B from B to C and from C to A. With a circuit it is not straight forward to order the columns in order to encode the directions of the relationships without taking additional measures. For instance in the circuit described above the C column would have to occur simultaneously before and after the A column. Nevertheless one with ordinary skill in the art would recognize that such situations may be remedied through a variety of techniques. For example a data set may be pre processed to locate any circuits. If any circuits are found triples may be removed from the data set to break any circuitous paths. For instance the triple of C to A may be removed in the example given above so that A does not indirectly refer to itself The removed triples may be separately processed and the results of the separate processing may be combined with results of processing the modified data set.

Because the data set is stored in an ontology it can be considered as a graph having vertices being the nodes and the relationships being edges. In an embodiment partitioning a matrix representative of a data set can be visualized by equivalent operations on a graph representing the data set. For instance shows a representation of a graph of a data set such as the data set above which shows the transitive properties of the data set. For example if A is related to B and B is related to C then the graph shows edges connecting B to both A and C. As shown in the example the graph includes a first subgraph and a second subgraph . The first subgraph and the second subgraph are related to each other through the relationship Pconnecting node E which is in the first subgraph to node F which is in the second subgraph . In this manner processing the data set can be performed by separately processing data in the subgraphs and combining the results. For example the data in the first subgraph may be processed in a first processor executing instructions for a first reasoner instance the data in the second subgraph may be processed in a second processor executing instructions for another reasoner instance which may employ the same or a different set of rules for processing than the first reasoner instance. Either the first or second or another processer may be used to combine the results according to the relationship P.

It should be understood that data sets will vary and as a result decomposition of a graph representing a data set will vary accordingly. For instance a graph may be partitioned into subgraphs that are disconnected or may be partitioned into subgraphs that are connected to one another by more than one edge. In addition a typical data set in accordance with an embodiment will be partitioned into more than two subgraphs which may be processed separately. Further data in some subgraphs may be processed in one processor while data in other subgraphs may be processed in another processer or processors.

Turning to the matrix representation also shows a matrix which has been partitioned into a convenient form. For example the matrix in an embodiment is a matrix resulting from the transformation of the matrix described above. As described above the columns of the unpartitioned matrix have been rearranged such that they encode the direction of the relationships between the nodes. In an embodiment if a relationship extends from a first node to a second node then the column associated with the first node is placed before the column associated with the second node. For example because the relationship Pextends between A and B the A column is placed before the B column.

Further the rows of the matrix have been arranged so as to put the matrix in block form which as described below results in partitioning the data into separately processable partitions. As discussed above many different techniques for partitioning matrices into block form may be used in accordance with various embodiments. As shown the matrix includes a first vector set SET A comprising the upper seven rows of vectors and a second vector set SET B comprising the lower six rows of vectors where the first vector set is above the second vector set . An intersection vector set comprises the row vectors that are common to both the first vector set and second vector set . As discussed the matrix and sub matrices of are provided for the purposes of illustration and generally matrices used in accordance with various embodiments may have vector sets and sub matrices having different characteristics such as more or less rows.

As shown in the example the first vector set includes a first submatrix in the upper left corner that comprises entries that are either zero or one and a first zero matrix in the upper left corner that comprises entries that are ail zero. In an embodiment the first submatrix is situated to the left of the first zero matrix . Likewise the second vector set includes a second submatrix and a second zero matrix where the second submatrix sits to the right of the second zero matrix and the second submatrix includes entries being zero or one and the second zero matrix having entries all zero. In this manner it can be seen that the partitioned matrix is partitioned into discreet blocks and may include a vector connecting the blocks. While the partitioned matrix is composed of four block matrices and the intersection vector it should be understood that data sets in general in accordance with an embodiment will be partitioned into a larger or smaller number of blocks which may or may not be separated by non zero intersection row vectors. In addition it should be understood that the particular positioning of the blocks of the matrix is made according to mathematical convention with the blocks located along a main diagonal of the matrix but that other configurations are possible.

Returning to the example in the drawing the first submatrix encodes the first subgraph while the second submatrix encodes the second subgraph in the manner described above. The intersection vector encodes the relationship between the first subgraph and the second subgraph . If a graph of a data set includes two disconnected subgraphs a partitioned matrix representation may not include any intersection vectors between blocks representing the disconnected subgraphs. In addition one or more row vectors of all zero entries may be situated between blocks representing disconnected subgraphs.

In an embodiment a map function and a reduce function are employed in order to distribute the reasoning of an ontology among various processors and to combine the results of the distributed reasoning. Reasoning an ontology may include application of a predefined set of rules to the data of the ontology. As an example a commonly used rule in reasoning ontologies is the transitive rule where if node A relates to node B and node B relates to node C then node A relates to node C. Other rules depending on specific applications may be used in addition to or in place of the transitive rule. In an embodiment the map function takes as input data corresponding to a subgraph of a graph representing an ontology and a set of rules to be used by a reasoner to process the individual triples represented in the subgraph. For a subgraph and set of rules input to the map function the output of the map function includes data corresponding to a subgraph typically a different subgraph and an inferred vector which may encode information about one or more triples. In an embodiment the subgraphs output by the map function may include nodes that are common to more than one subgraph so as to encode any relationships between subgraphs.

Similarly the second vector set encodes the second vector set and the intersection vector described above in connection with thereby encoding the second subgraph and the triple represented by E F and P. As shown in in an embodiment the row vectors of the first set of vectors are simply the row vectors of the first data set and intersection vector . In this manner the map function outputs the first vector set and second vector set . Subgraphs corresponding to the first vector set and second vector set may be ascertained from the entries in the vector sets as described above. In an embodiment the first vector set forms a first matrix which may be in block form and whose columns and rows represent nodes and relationships respectively as described above.

As noted above the map function also outputs inferred vectors which may encode the relationship between two or more nodes as determined by a reasoner. For example a set of rules may include a transitive rule for an ontology which provides for example that if A is related to B and B is related to C then A is related to C. The set of rules may also include information identifying which rows should be considered when implementing the transitive rule. The transitive rule in processing of ontologies is convenient because when matrix representations are used as described above processing the transitive rule on a subgraph can be performed using an OR operation of the relevant rows which is computationally efficient. In an embodiment an OR operation on a plurality of rows is performed by performing an OR operation on corresponding entries in the rows. For example if the third entry of one row is a zero and the third entry of another row is zero an OR operation performed on the two rows will have a zero in the third entry. If the third entry of both rows is a one then an OR operation performed on the two rows will have a zero in the third entry. If one of the rows has a one in the third entry and the other row has a zero in the third entry then the result of an OR operation performed on the two rows will have a one in the third entry.

In an embodiment the inferred vectors form a set of inferred vectors whose columns and rows encode triples as described above. For example a first inferred vector set results from processing the first vector set according to a plurality of user selected or predefined rules of a reasoner. Likewise a second inferred vector set results from processing the second vector set . In the example shown the first row of the first inferred vector set is a result of performing an OR operation on the rows P P Pand Pof the first submatrix . This particular operation for instance may be chosen by a user of the reasoner and any suitable operation or operations may be used. Likewise the remaining rows of the inferred vector set are formed using various OR operations on various rows of the first submatrix depending on the particular rules chosen by the user. Generally the type of operations used to make inferred vector sets will vary depending on specific applications and reasoners and it should be understood that the particular operations used to form the inferred vector sets are chosen merely as an example.

In an embodiment a reduce function is constructed or provided whose input includes information about subgraphs and inferred triples from each subgraph. For example the input of the reduce function may include a list of nodes directly related to nodes of the subgraph. Thus the input of the reduce function may include ail the nodes of the subgraph as well as one or more nodes of another subgraph related to the input subgraph by a relationship. For example in reference to the first subgraph and second subgraph shown in the input of the reduce function may include the list A B C D E F F G H J. In this example the nodes A B C D E and F are from the first subgraph and the nodes F G H I and J are from the second subgraph . The node F is included in both lists because it is the node in the second subgraph to which the first subgraph refers through the relationship P. The input of the reduce function may also include a list of inferred triples within the subgraphs such as a triple including nodes A and E.

The reduce function determines based upon the input whether additional reasoning should take place. For instance referring to the same example because the first subgraph and second subgraph are related to each other by the relationship P the reduce function then takes the inferred triples from each subgraph and applies the rules of the reasoner to the inferred triples input to the function and returns a list of inferences. For complicated data sets the reduce function may be applied repeatedly or recursively to ensure that desirable inferences are identified. Thus for example the output of the reduce function may include an inferred triple that includes the nodes A from the first subgraph and J from the second subgraph because A and J are indirectly related to one another through a series of relationships.

In the example of four different data sources of a business are shown although a business or other entity may use more than four data sources or less than four. Also the four different data sources may be physically realized in separate data stores which may be in separate geographical locations or two or more data sources may be incorporated into a single data store. As shown in the example demonstrated in a business may include a first relational database which is modeled by a first relational schema . As it applies to data storage a schema is a structure configured to organize the data of one or more data sources. For example in a relational database a schema that models the relational database defines the tables of the database the fields of each table and the relationships between the fields and tables.

In the provided example the business may also include a second relational database which is modeled by a second relational schema . There can be various reasons for having more than one source of business data for example for storing data for different aspects of a businesses activities such as sales and human resources. Businesses may also store data in different forms depending on the particular application. For example in a lightweight directory access protocol LDAP directory is modeled by a LDAP schema . Likewise a flat file database may be modeled by a flat file schema . Thus in the example shown in a business may include data from a variety of sources in a variety of formats.

As can be seen in the figure data from each of the data sources is mapped to the semantic data store . In an embodiment mapping data from a data source to the semantic data store is described in more detail below but generally includes extracting data from the source and loading it or a portion of it into the semantic data store which may or may not involve reformatting data from one form to a form suitable for the semantic data store . In addition mapping data from a data source to the semantic data store may involve mapping ail data from the data source or using a filter to only map some data from the data source. For instance the data source may include data that is not pertinent to the purposes for which the business ontology is used and as a result only pertinent data would be mapped to the semantic data store. A filter may be used to control which data is mapped to the semantic data store. For example the data mappings above can be used in connection with Oracle Data Integration ODI Tools available from Oracle International Corporation in order to perform ETL processes that constrain and filter data from the various data stores and merge the data into a common format in the semantic data store . As described below once maps are constructed the maps can be used in automated processes that extract data from one data store and appropriately load the data into the semantic data store . Extraction and loading of data can occur for example at predetermined intervals such as once a day or at predetermined triggers such as when data is changed.

As shown in the example data from the first relational database is stored in the semantic data store as well as data from the second relational database the LDAP Directory and the flat file database . In an embodiment schemas of various data stores are mapped to the business ontology such that semantic concepts embodied in the data stores are stored in the business ontology . For example the first relational database may include a plurality of tables each table having one or more columns. The first relational schema may relate tables together in a useful manner for example relating customers to invoices such that a customer is related to an invoice for goods or services purchased by the customer. Thus relationships defined by the relational schema are mapped to the business ontology such that semantic concepts defined by the relational schema are preserved in the business ontology .

Also in an embodiment each relation is a binary relationship between two classes. For example a relation orgHasEmployees may be a relationship between a member of an organization class and an employee class. This relationship for example may specify employees that are part of an organization. Relations may be further classified in terms of their domains the class or classes from which they relate and ranges the class or classes to which they relate . Also in an embodiment some relations have super relations. For instance orgHasEmployees may be a super relation of an orgHasManagers relation because for example all managers may be employees.

As shown in the diagram the ontological meta model also includes storage for ontological data types which may be for example strings integers floats dates Boolean or other types of data. In an embodiment datatypes are the ranges value sets of the attributes and consist of sets of similar data forms. In the embodiment presented in the drawings ontological type data is stored separately from instance data which is stored in a hyper denormalized relationed form. As used herein semantic data that is in hyper denormalized relationed form is stored such that every attribute is stored in its own table. This form provides an advantage in that instance data is easily and quickly accessible which in turn allows for a highly distributed approach to solve problems of inferencing persistence and other issues. In other words the architecture in the disclosed embodiment provides the power and flexibility of ontological storage with the performance of modern relational database management system. However one with skill in the art will appreciate that variations are possible and that in other contexts different architecture may be appropriate. For example one with skill in the art would recognize that type and instance data may be stored in the same storage system and that instance data need not be hyper denormalized but that different degrees of denormalization of data may be used and different kinds of instance data may be combined in one or more containers.

As shown in the drawing in an embodiment between the classes are relations between the classes and there may be relations among the relations . Also each class is an aggregation of attributes in accordance with an embodiment.

As noted above the relational meta model is mapped to the ontological meta model as described more fully below. In an embodiment of relational meta model includes relational concepts which are super classes of tables columns and keys . Also as is known each table is an aggregation of columns. As can be seen various mappings are provided between various elements of the ontological meta model in relational meta model . For instance in an embodiment one or more columns of a table are mapped to an attribute of the ontological meta model . Likewise tables are mapped to classes of the ontological meta model . As keys define relationships between tables in the relational meta model keys of the relational meta model are mapped to relations of the ontological meta model in a manner preserving the relationships between the tables . In an embodiment relational data types are mapped to a ontological datatypes .

In an embodiment the relational meta model may be implemented using a relational database management system RDBMS and the meta data in the relational meta model is therefore readily available. The mapping shown in in an embodiment may also be achieved by utilizing Application Programming Interfaces APIs exposed by the systems implementing the relational meta model such as Java Database Connectivity JDBC meta data Open Database Connectivity ODBC meta data and the like.

In an embodiment the semantic data store translates policies queries expressed in terms of the sales ontology into queries expressed in terms of the semantic store schema and executing the translated queries on the data store. The actual execution of the query may be delegated to a reasoner. Thus in an embodiment a query expressed in terms of classes and relations will be translated by the semantic data store in terms of tables and keys. For example in an embodiment the ontological query 

In addition appropriate relations may be substituted with foreign key primary key pairings when the query is translated into the relational form.

As discussed above the ontological meta model is comprises of classes relations and attributes The sales ontology comprises specific instances of the members of the ontology meta model . For example as shown the sales ontology includes several classes including a person class a buyer class an employee class an invoice class and invoice item class . As seen by it s name the person class corresponds to people such as employees buyers and other people. Accordingly the buyer class and employee class are sub classes of the person class . Also clear from its name the invoice class may be associated with invoices and the invoice item class may be comprised of various invoice items such as various products sold by a business employing the disclosed ontology. In an embodiment the employee class invoice class and invoice item class have corresponding tables in the semantic data store . Other classes of the sales ontology may also have corresponding tables in the semantic data store .

As shown the sales ontology includes various relations from the relations such as a buyerOf relation and a sellerOf relation and a hasItems relation . The names of the various relations also may be related to their semantic meaning. For instance as can be seen in the figure a buyer of the buyer class may be related to an invoice of the invoice class by the relation buyerOf because the buyer may have purchased the particular items of the invoice. Likewise an invoice of the invoice class is related to invoice items of the invoice item class by the relation hasItems because the invoice items were included on the invoice. Also the sellerOf relation relates an employee of the employee class to an invoice of the invoice class when the employee was the person who sold the items listed on the invoice. In an embodiment relations are represented in the semantic data store by the pairing of the primary key of the tables of the semantic data store as discussed below.

Further various items of the sales ontology may include various members of the attribute class . As an example person may include a first name and a last name which as indicated in the drawing may be stored as strings. Likewise a buyer may have a buyerID unique to the buyer as may an employee have an employee ID unique to the employee. Continuing this example the invoice may include an invoiceID unique to the invoice and a date for example on which the invoice was created. As a final example an invoice item of the invoiceItem class may include an amount corresponding to the price at which the associated item was sold to the buyer .

As discussed above various items of the sales ontology are stored in a semantic data store . In an embodiment the semantic data store may closely resemble a data store of another data model such as a relational database model. Thus in an embodiment the semantic data store includes a plurality of tables where each table corresponds to a class of the ontology meta model . It should be understood however that the example semantic data store shown in the drawings may be in an intermediate format used to facilitate transformation of the data. Data from the semantic data store may be further transformed for example into a format suitable for use with a particular reasoner operable to reason the data.

Thus as shown in the illustrative example of the semantic data store includes an employee table an invoice table and an invoice item table . Each of the tables of the semantic data store may include a key comprising an attribute unique to the entities represented by the table. For instance the employee table may include a column having each employee ID Other attributes may also be stored in tables such as the last name and first name attributes of employees in the employee table . Likewise the invoice table may include a column corresponding to an invoice ID primary key employee ID foreign key and buyer ID foreign key such that in this manner for example an ID of an invoice may be located in the invoice table and the employee associated with the invoice and buyer to which items on the invoice are sold may be identified.

The above embodiments and variations thereof provide advantages additional to those discussed above. shows an environment in which embodiments of the invention may be practiced. As shown the environment includes a plurality of data stores from which data is extracted and stored in a semantic data store . Extraction and storage of data from the data stores into the semantic data store may be performed in any suitable manner including in accordance with the above disclosure. In an embodiment data stored in the semantic data store is reasoned by a reasoner which is operated by a user of a user terminal in accordance with an embodiment. While the drawing shows the reasoner analyzing data from a single semantic data store the reasoner may utilize data from multiple semantic data stores as well as from one or more of the data stores or data from other sources.

The semantic data store in an embodiment is a data store whose persistence mechanism is be the file system database or memory depending on the usage within the application and as described above. Further the semantic data store may be dynamically optimized for storage of data based on deployed semantic domain definitions. As described above semantic domain definitions may be OWL files that encapsulate domain taxonomy which may be defined by a business expert for any particular domain.

In addition it should be noted that shows a simplified environment for the purposes of illustration but that actual implementations may utilize various components in addition to that which is illustrated. For example in an embodiment the reasoner is implemented in one of several layers of a software architecture adapted for enforcing policies. As an example an interface such as a Web 2.0 interface may be provided for users to operate various components. Customized interfaces may be created using REST Web Services. One or more interfaces may be used to operate application services which coordinate components of policy enforcement such as a policy engine that operates the reasoner and the semantic data store data services that coordinate the transfer of data to the semantic data store and report services that provide reporting documents based on analysis of data in the semantic data store and the like. In an embodiment the data services utilize Oracle Data Integrator 11gR1 and the report services utilize Oracle Business Intelligence Publisher both available from Oracle Corporation.

As shown in the drawing the reasoner comprises a plurality of reasoning modules where each reasoning module applies a set of rules to analyze data in the semantic data store . While shows a certain number of reasoning modules of the reasoner the reasoner may have more or less reasoning modules. When reasoning data the reasoner may use all or some of its reasoning modules depending on the type of reasoning being conducted. For instance a user may through an input device define a particular analysis that he or she would like to perform and the reasoner may use one or more applicable modules such as in a manner described below. Further a user may define his or her own reasoning modules which may include a combination of some of the reasoning modules of the reasoner directed to analyze data in a particular manner.

In an embodiment the reasoner includes one or more pattern based reasoning modules abbreviated as PBRM and one or more semantic reasoning modules abbreviated as SRM . In an embodiment a PBRM is a sub reasoner of the reasoner that uses a predefined statistical analysis on data from the semantic data store in order to infer information from the data. PBRMs may utilize range reasoning where data is looked at over a specified range such as over a specified time period. As an example utilizing a matrix based approach such as the approach described above a covariance matrix of a vector may be constructed in order to measure how the changes of variables in the vector depend on others. Likewise the covariance of two variables may be measured for other objects such as matrices or higher dimensional objects. Correlation between two seemingly random variables such as between invoice amounts and payments unrelated to the invoices may signify fraud. A PBRM may take as input a set of data such as a sampling of numerical values such as invoice line items over a time period and may output conclusions based on a statistical analysis of the numerical values such as covariance matrices or other objects.

Other statistical techniques may be used in PBRMs. For instance pattern recognition may be used to identify activities that are out of the ordinary. As an example certain invoices payments and or other items may be flagged for review if they contain an amount that is above or below a predefined threshold or if they deviate from a mean value for similar items by a predetermined amount. As another example pattern recognition techniques may be used to flag invoices payments or other items that are not necessarily above or below a threshold but that are otherwise abnormal such as invoice amounts that are larger or smaller than usual but not outside of a range that would cause any flags to be set. Pattern recognition may also be used to compare activity with activity of those having similar duties. For instance pattern recognition may be used to identify through analysis of purchases and or other data that a manager of a location is replacing parts on equipment more frequently than managers of other locations. An investigation may be subsequently made to determine whether the manager is legitimately acting differently than his or her peers whether corrective action needs to be taken and or whether fraud is being committed such as by profiting off the sale of used parts.

Generally techniques that may be employed in PBRMs include cross correlation analysis to discover the relationship between multiple dependent variables Bayesian filters to look at past events and build probabilistic models to predict future events to detect whether past present and or future events violate a policy and wavelets for detection of data that is most likely to be suspect. Other techniques may also be used and as new techniques are developed a user may define reasoning modules that are able to apply any given technique. For instance in an embodiment users may define techniques that may be employed by a PBRM using combinations of the above techniques and or defining additional techniques.

As discussed one or more SRMs may be used in connection with one or more PBRMs in order to increase the effectiveness of the modules. In an embodiment an SRM is a reasoning module that applies one or more rules to a set of data to provide information about the relationships among the various data. Data for a SRM may be encoded into a matrix form such as described above. A semantic reasoning module may for example identify all invoices related to a particular employee.

Generally use of SRMs and PBRMs provides increased flexibility in choosing the data to be analyzed and the techniques to be used for analysis. For instance output of one or more SRMs may be used as input for one or more PBRMs. As an example if John Doe is an employee a SRM may be used to identify invoices issued by John Doe such as using any of the techniques or variations thereof discussed above. One or more covariance techniques may be used by one or more PBRMs to determine whether there is a correlation between the invoice amounts and other data. An SRM may be used to exclude from the analysis data that should be correlated to the invoice amounts such as payments to the vendors identified on the invoices. An SRM may take as input objects from the semantic data store may construct appropriate matrices and may perform matrix operations on the matrices depending on the nature of the reasoning being performed although matrices may be input into SRMs in other embodiments. Output from an SRM may be a set of inferences or other conclusions about the relationship among semantic data may be a set of numerical values such as invoice line items or other data.

Likewise the output of one or more PBRMs may be used as input to one or more SRMs. For instance as discussed PBRMs may be used to find correlations among various data. A SRM may be used to provide useful information about data having correlations such as people roles vendors and others associated with a particular datum. This information may be viewed by an analyst who may decide whether to investigate further and or take corrective action. Additionally the information may be used in order to define rules for additional analysis. The reasoner may include additional logic to coordinate the flow of data among reasoning modules being used such as by formatting output of one reasoning module into a format suitable as input for another reasoning module. For instance if an SRM outputs a set of inferences the reasoner may extract from a semantic data store objects such as numerical values corresponding to objects associated with the inferences and provide those values to a PBRM for processing by the PBRM. In one embodiment each reasoning module has a corresponding input type and output type. A reasoning module with a particular input type may accept information from another reasoning module with an output type that matches the particular input type. In an embodiment each reasoning module of the reasoner has an output type that matches the input type of the other reasoning modules.

As discussed in the preceding paragraphs SRMs and PBRMs may be used in series where output of one or more modules is used as input for one or more other modules . SRMs and PBRMs may also be used in parallel in appropriate circumstances. For instance output of an SRM and output of a PBRM may together be used as input for one or more other modules each of which may be an SRM or PBRM. Additionally while the above discussion pertains to SRMs and PBRMs other types of modules may be employed. In an embodiment one or more hybrid modules may be used in ways discussed above where a hybrid module is a reasoning module that employs both semantic reasoning such as transitive reasoning of semantic data and statistical reasoning such as pattern based reasoning of numerical data . A hybrid module may comprise a combination of one or more SRMs and or PBRMs in series and or parallel.

In accordance with an embodiment at a semantic data storage step at least a portion of the data stored in the one or more data stores is stored in a semantic data store such as a semantic data store configured as described above. As discussed storing data in the semantic data store may involve the use of various filters in order to exclude some data from the one or more data stores and also may involve the use of various transformations of the data that put the data in a form suitable for storage in the semantic data store such as in a manner described above. In addition while the method describes a single semantic data store more than one semantic data store may be utilized.

At a semantic reasoning step in an embodiment data from the semantic data store is reasoned using a SRM where the SRM may be as described above. For instance a SRM may apply transitive reasoning to data in the semantic data store in order to identify relationships specified by a user of a system employing the method such as ail invoices associated with a particular employee and or having particular attributes. Semantic reasoning may include construction of one or more matrices or other objects whose entries represent some significance in the data such as an amount or a 0 or 1 as described above. Once the matrix or matrices are constructed semantic reasoning may include applying matrix operations and or other analysis to the matrices depending on the particular type of reasoning being performed. At a statistical reasoning step data from the semantic data store is reasoned using a PBRM in accordance with an embodiment. For instance a PBRM may apply statistical reasoning to data specified by a user such as to particular invoice values for the invoices identified by the SRM. As with the semantic reasoning step the statistical reasoning step may include construction and or operations and or other analysis on one or more matrices whose entries have a significance to the data.

While the method shows the semantic reasoning step performed before the statistical reasoning step the steps may be performed in another order or at the same time as described above. For example a PBRM may be used to identify suspicious values in the Semantic data store and a SRM may then identify employees and other semantic objects associated with the suspicious values. Further also described above a plurality of SRMs and or PBRMs may be used to reason data in the semantic data store and may reason data in series and or in parallel. Also reasoning modules other than SRMs and PBRMs may be used as well. In order to provide customizability and or scalability each reasoning module may be adaptable to receive as input from other reasoning modules. For instance operations in an embodiment where matrices are used such as those described above the dimensions of a matrix output by a reasoning module which may vary based on the amount of data being reasoned are used by another reasoning module so that operations on the matrix by the other reasoning module proceed properly.

In an embodiment at a results step results of the reasoning are provided to a user of a system employing the method . Providing the results may include causing the display of information corresponding to the results through a graphical user interface of the system. The results may be presented in various forms which may employ text graphics video audio and other features. For example graphs that illustrate statistical relationships between semantic objects may be displayed as may text describing the relationships.

In an embodiment at a SRM selection step an SRM is selected. Selection of the SRM may be based at least in part on user input. For example if a user specifies that he or she would like to analyze all invoices belonging to a particular employee or group of employees an SRM configured to identify invoices associated with the employee s may be selected. At a PBRM selection step in an embodiment a PBRM is selected. As with the SRM selection of the PBRM may be based at least in part on user input. For example if a user specifies that he or she would like to analyze the correlation between invoice values and other semantic objects a PBRM operable to perform this analysis may be selected. For instance a PBRM that constructs a covariance matrix from vectors in a matrix constructed in accordance with the above description may be selected.

While shows the SRM selection step occurring before the PBRM selection step the steps may be performed in another order or at the same time. In addition as discussed above embodiments of the present invention provide for scalability. Accordingly the method may include selection of a plurality of SRMs and or a plurality of PBRMs.

At a data reasoning step the identified data is reasoned according to the selected SRMs and PBRMs in accordance with an embodiment. Reasoning the data may include applying any selected SRMs and PBRMs in an order that is based at least in part on user input. At a results step results of the reasoning are provided such as in a manner described above.

Although specific embodiments of the invention have been described various modifications alterations alternative constructions and equivalents are also encompassed within the scope of the invention. Embodiments of the present invention are not restricted to operation within certain specific data processing environments but are free to operate within a plurality of data processing environments. Additionally although embodiments of the present invention have been described using a particular series of transactions and steps it should be apparent to those skilled in the art that the scope of the present invention is not limited to the described series of transactions and steps.

Further while embodiments of the present invention have been described using a particular combination of hardware and software it should be recognized that other combinations of hardware and software are also within the scope of the present invention. Embodiments of the present invention may be implemented only in hardware or only in software or using combinations thereof.

The specification and drawings are accordingly to be regarded in an illustrative rather than a restrictive sense. It will however be evident that additions subtractions deletions and other modifications and changes may be made thereunto without departing from the broader spirit and scope as set forth in the claims.

Other variations are within the spirit of the present invention. Thus while the invention is susceptible to various modifications and alternative constructions certain illustrated embodiments thereof are shown in the drawings and have been described above in detail. It should be understood however that there is no intention to limit the invention to the specific form or forms disclosed but on the contrary the intention is to cover all modifications alternative constructions and equivalents falling within the spirit and scope of the invention as defined in the appended claims.

The use of the terms a and an and the and similar referents in the context of describing the invention especially in the context of the following claims are to be construed to cover both the singular and the plural unless otherwise indicated herein or clearly contradicted by context. The terms comprising having including and containing are to be construed as open ended terms i.e. meaning including but not limited to unless otherwise noted. The term connected is to be construed as partly or wholly contained within attached to or joined together even if there is something intervening. Recitation of ranges of values herein are merely intended to serve as a shorthand method of referring individually to each separate value falling within the range unless otherwise indicated herein and each separate value is incorporated into the specification as if it were individually recited herein. All methods described herein can be performed in any suitable order unless otherwise indicated herein or otherwise clearly contradicted by context. The use of any and all examples or exemplary language e.g. such as provided herein is intended merely to better illuminate embodiments of the invention and does not pose a limitation on the scope of the invention unless otherwise claimed. No language in the specification should be construed as indicating any non claimed element as essential to the practice of the invention.

Preferred embodiments of this invention are described herein including the best mode known to the inventors for carrying out the invention. Variations of those preferred embodiments may become apparent to those of ordinary skill in the art upon reading the foregoing description. The inventors expect skilled artisans to employ such variations as appropriate and the inventors intend for the invention to be practiced otherwise than as specifically described herein. Accordingly this invention includes all modifications and equivalents of the subject matter recited in the claims appended hereto as permitted by applicable law. Moreover any combination of the above described elements in ail possible variations thereof is encompassed by the invention unless otherwise indicated herein or otherwise clearly contradicted by context.

All references including publications patent applications and patents cited herein are hereby incorporated by reference to the same extent as if each reference were individually and specifically indicated to be incorporated by reference and were set forth in its entirety herein.

For the Examiner s convenience Applicants note that this application is a continuation of U.S. application Ser. No. 12 874 821. The claims of the present application are different and possibly at least in some aspects broader in scope than the claims pursued in the parent application. To the extent any prior amendments or characterizations of the scope of any claim of the parent or any cited documents could be construed as a disclaimer of any subject matter supported by the present disclosure. Applicants hereby rescind and retract such disclaimer. Accordingly the references previously presented in the parent applications may need to be revisited.

