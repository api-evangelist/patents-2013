---

title: Insuring integrity of remote procedure calls used in a client and server storage system
abstract: A system and method generates a message integrity check. The message integrity check value is computed by hashing one or more block checksums from procedure specific parameters of an RPC and then encrypting the resulting hash value. The computed message integrity check is appended to the RPC to thereby provide a level of security approaching or equal to the level of Integrity defined by the RPCSEC_GSS protocol specification.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09401921&OS=09401921&RS=09401921
owner: NetApp, Inc.
number: 09401921
owner_city: Sunnyvale
owner_country: US
publication_date: 20131224
---
The present application is a continuation of commonly assigned copending U.S. patent application Ser. No. 11 118 665 which was filed on Apr. 29 2005 by Peter F. Corbett for an INSURING INTEGRITY OF REMOTE PROCEDURE CALLS USED IN A CLIENT AND SERVER STORAGE SYSTEM and is hereby incorporated by reference.

The present invention is directed to network protocols and in particular to a technique for providing a message integrity check for data transmissions.

A storage system typically comprises one or more storage devices into which information may be entered and from which information may be obtained as desired. The storage system includes a storage operating system that functionally organizes the system by inter alia invoking storage operations in support of a storage service implemented by the system. The storage system may be implemented in accordance with a variety of storage architectures including but not limited to a network attached storage environment a storage area network and a disk assembly directly attached to a client or host computer. The storage devices are typically disk drives organized as a disk array wherein the term disk commonly describes a self contained rotating magnetic media storage device. The term disk in this context is synonymous with hard disk drive HDD or direct access storage device DASD .

The storage system may be further configured to operate according to a client server model of information delivery to thereby allow many clients to access data containers such as files and logical units stored on the system. In this model the client may comprise an application such as a database application executing on a computer that connects to the storage system over a computer network such as a point to point link shared local area network LAN wide area network WAN or virtual private network VPN implemented over a public network such as the Internet. Each client may request the services of the storage system by issuing file based and block based protocol messages in the form of packets to the system over the network.

A plurality of storage systems may be interconnected to provide a storage system cluster configured to service many clients. Each storage system or node may be configured to service one or more volumes wherein each volume stores one or more data containers. Communication among the nodes involves the exchange of information between two or more entities interconnected by communication links. These entities are typically software programs executing on the nodes. The nodes communicate by exchanging discrete packets or messages of information according to predefined protocols. In this context a protocol consists of a set of rules defining how the nodes interact with each other.

Each node generally provides its services through the execution of software modules such as processes. A process is a software program that is defined by a memory address space. For example an operating system of the node may be implemented as a single process with a large memory address space wherein pieces of code within the process provide operating system services such as process management. Yet the node s services may also be implemented as separately scheduled processes in distinct protected address spaces. These separate processes each with its own process address space execute on the node to manage resources internal to the node and in the case of a database or network protocol to interact with users.

Services that are part of the same process address space communicate by accessing the same memory space. That is information exchanged between services implemented in the same process address space is not transferred but rather may be accessed in a common memory. However communication among services that are implemented as separate processes is typically effected by the exchange of messages. For example information exchanged between different addresses spaces of processes is transferred as one or messages between different memory spaces of the processes. A known message passing mechanism provided by an operating system to transfer information between process address spaces is the Inter Process Communication IPC mechanism.

Resources internal to the node may include communication resources that enable a process on one node to communicate over the communication links or network with another process on a different node. The communication resources include the allocation of memory and data structures such as messages as well as a network protocol stack. The network protocol stack in turn comprises layers of software such as a session layer a transport layer and a network layer. The Internet protocol IP is a network layer protocol that provides network addressing between nodes whereas the transport layer provides a port service that identifies each process executing on the nodes and creates a connection between those processes that indicate a willingness to communicate. Examples of conventional transport layer protocols include the reliable connection RC protocol and the Transmission Control Protocol TCP .

Broadly stated the connection provided by the transport layer such as TCP is a reliable securable logical circuit between pairs of processes. A TCP process executing on each node establishes the TCP connection in accordance with a conventional 3 way handshake arrangement involving the exchange of TCP message or segment data structures. The resulting TCP connection is identified by port numbers and IP addresses of the nodes. The TCP transport service provides reliable delivery of a message using a TCP transport header. The TCP protocol and establishment of a TCP connection are described in 3 particularly at pgs. 521 542 which is hereby incorporated by reference as though fully set forth herein.

Messages passed between nodes of a cluster are typically implemented as remote procedure calls RPCs . One format for RPCs is defined in Request for Comments 1831 entitled 2 by R. Srinivasan dated August 1995 the contents of which are hereby incorporated by reference. Generally a RPC comprises a header portion and a set of procedure specific parameters. The procedure specific parameters may include a set of control information and data associated with the message.

In systems using RPCs it is desirous that data is secure and not vulnerable to a network security attack. The Generic Security Service application program interface GSS API described in Request for Comments 2078 entitled 2 by J. Linn dated January 1997 the contents of which are hereby incorporated by reference provides a set of security services in a generic fashion for a variety of transport mechanisms. The GSS API defines its services and primitives independently of the underlying transport mechanism and or programming language environment.

To utilize the GSS API within a RPC protocol environment the RPCSEC GSS protocol defined in Request for Comments 2203 entitled   by M. Eisler dated September 1997 and hereby incorporated by reference is typically employed. The RPCSEC GSS protocol defines a variety of levels of protection including an Authentication level and an Integrity level. In the Authentication level the credential within a message is hashed and then encrypted to form an Authentication verifier. In the Integrity level a hash is executed over the procedure specific parameters contained within a RPC and the resulting hash value is encrypted to produce a message verifier which is then appended to the RPC.

However a disadvantage associated with both of these protection levels involves the computational overhead required to perform the necessary calculation. For example the entire procedure specific parameters section including any data contained therein must be hashed in the Integrity level. This introduces substantial overhead in terms of time as well as a concomitant reduction in available processing resources for performing other tasks. Moreover this additional overhead may result in additional latency when retrieving data in a storage system environment.

The present invention overcomes the disadvantages of the prior art by providing a system and method for generating a message integrity check for use in a data transmissions including e.g. remote procedure call RPC based network protocols executing on storage systems or nodes of a cluster. Each node is generally organized as a network element N blade and a disk element D blade . Each element includes a cluster fabric interface module adapted to implement a network protocol that enables intra cluster communication among the elements. The network protocol is a multi layered protocol that integrates a session infrastructure and an application operation set into a session layer that obviates encapsulation and buffering overhead typically associated with protocol layering. The network protocol is illustratively a request response protocol wherein an element requester receiving a data access request from a client redirects that request to another element responder that services the request and upon completion returns a response.

All network protocol communication in the cluster occurs via connections which provide a network transport for sessions between the requesters responders. At least one connection is required for each session wherein the connection is used for both requests and responses. Each request response is embodied as an RPC that is transmitted over one of the connections. Each RPC comprises a header and a set of procedure specific parameters. For network protocol RPCs the procedure specific parameters include a control portion and the data associated with the RPC.

In one illustrative embodiment of the invention one or more block checksums are generated in the control portion of the RPC. These block checksums may be quickly computed using conventional data checksumming procedures for the data contained within the RPC. In addition block sizes of the checksums are illustratively selected so that the checksum may be utilized at multiple stages of processing. For example assume a file system executing on the D blade utilizes 4 kilobyte KB blocks for internal operations and for writing to disk. Accordingly the block size for the block checksums may be selected as 4 KB in size. This permits the use of the checksum for end to end data protection e.g. from N blade to D blade to disk or vice versa.

According to the invention the block checksum s of the data portion that is stored in the control portion of the RPC are hashed and the resulting hash value encrypted to generate the message integrity check. This aspect of the invention contemplates use of a strong data checksum such as the well known MD 5 to provide a high confidence that the transmitted data is valid without checksumming the same data twice as is required in prior GSS API levels of security. It is noted that a block checksum may not be removed without detection accordingly by utilizing a sufficiently secure checksumming algorithm an attacker would be required to modify the data in a way that does not modify the block checksum.

The clients may be general purpose computers configured to interact with the node in accordance with a client server model of information delivery. That is each client may request the services of the node and the node may return the results of the services requested by the client by exchanging packets over the network . The client may issue packets including file based access protocols such as the Common Internet File System CIFS protocol or Network File System NFS protocol over the Transmission Control Protocol Internet Protocol TCP IP when accessing information in the form of files and directories. Alternatively the client may issue packets including block based access protocols such as the Small Computer Systems Interface SCSI protocol encapsulated over TCP iSCSI and SCSI encapsulated over Fibre Channel FCP when accessing information in the form of blocks.

Each node is illustratively embodied as a dual processor storage system executing a storage operating system that preferably implements a high level module such as a file system to logically organize the information as a hierarchical structure of named directories files and special types of files called virtual disks hereinafter generally blocks on the disks. However it will be apparent to those of ordinary skill in the art that the node may alternatively comprise a single or more than two processor system. Illustratively one processor executes the functions of the N blade on the node while the other processor executes the functions of the D blade .

The memory illustratively comprises storage locations that are addressable by the processors and adapters for storing software program code and data structures associated with the present invention. The processor and adapters may in turn comprise processing elements and or logic circuitry configured to execute the software code and manipulate the data structures. The storage operating system portions of which is typically resident in memory and executed by the processing elements functionally organizes the node by inter alia invoking storage operations in support of the storage service implemented by the node. It will be apparent to those skilled in the art that other processing and memory means including various computer readable media may be used for storing and executing program instructions pertaining to the invention described herein.

The network adapter comprises a plurality of ports adapted to couple the node to one or more clients over point to point links wide area networks virtual private networks implemented over a public network Internet or a shared local area network. The network adapter thus may comprise the mechanical electrical and signaling circuitry needed to connect the node to the network. Illustratively the computer network may be embodied as an Ethernet network or a Fibre Channel FC network. Each client may communicate with the node over network by exchanging discrete frames or packets of data according to pre defined protocols such as TCP IP.

The storage adapter cooperates with the storage operating system executing on the node to access information requested by the clients. The information may be stored on any type of attached array of writable storage device media such as video tape optical DVD magnetic tape bubble memory electronic random access memory micro electro mechanical and any other similar media adapted to store information including data and parity information. However as illustratively described herein the information is preferably stored on the disks of array . The storage adapter comprises a plurality of ports having input output I O interface circuitry that couples to the disks over an I O interconnect arrangement such as a conventional high performance FC link topology.

Storage of information on each array is preferably implemented as one or more storage volumes that comprise a collection of physical storage disks cooperating to define an overall logical arrangement of volume block number vbn space on the volume s . Each logical volume is generally although not necessarily associated with its own file system. The disks within a logical volume file system are typically organized as one or more groups wherein each group may be operated as a Redundant Array of Independent or Inexpensive Disks RAID . Most RAID implementations such as a RAID 4 level implementation enhance the reliability integrity of data storage through the redundant writing of data stripes across a given number of physical disks in the RAID group and the appropriate storing of parity information with respect to the striped data. An illustrative example of a RAID implementation is a RAID 4 level implementation although it should be understood that other types and levels of RAID implementations may be used in accordance with the inventive principles described herein.

To facilitate access to the disks the storage operating system implements a write anywhere file system that cooperates with one or more virtualization modules to virtualize the storage space provided by disks . The file system logically organizes the information as a hierarchical structure of named directories and files on the disks. Each on disk file may be implemented as set of disk blocks configured to store information such as data whereas the directory may be implemented as a specially formatted file in which names and links to other files and directories are stored. The virtualization module s allow the file system to further logically organize information as a hierarchical structure of blocks on the disks that are exported as named logical unit numbers luns .

In the illustrative embodiment the storage operating system is preferably the NetApp Data ONTAP operating system available from Network Appliance Inc. Sunnyvale Calif. that implements a Write Anywhere File Layout WAFL file system. However it is expressly contemplated that any appropriate storage operating system may be enhanced for use in accordance with the inventive principles described herein. As such where the term WAFL is employed it should be taken broadly to refer to any storage operating system that is otherwise adaptable to the teachings of this invention.

In addition the storage operating system includes a series of software layers organized to form a storage server that provides data paths for accessing information stored on the disks of the node . To that end the storage server includes a file system module in cooperating relation with a volume striping module VSM a RAID system module and a disk driver system module . The RAID system manages the storage and retrieval of information to and from the volumes disks in accordance with I O operations while the disk driver system implements a disk access protocol such as e.g. the SCSI protocol. The VSM illustratively implements a striped volume set SVS and cooperates with the file system to enable storage server to service a volume of the SVS. In particular the VSM implements a Locate function to compute the location of data container content in the SVS volume to thereby ensure consistency of such content served by the cluster.

The file system implements a virtualization system of the storage operating system through the interaction with one or more virtualization modules illustratively embodied as e.g. a virtual disk vdisk module not shown and a SCSI target module . The vdisk module enables access by administrative interfaces such as a user interface of a management framework not shown in response to a user system administrator issuing commands to the node . The SCSI target module is generally disposed between the FC and iSCSI drivers and the file system to provide a translation layer of the virtualization system between the block lun space and the file system space where luns are represented as blocks.

The file system is illustratively a message based system that provides logical volume management capabilities for use in access to the information stored on the storage devices such as disks. That is in addition to providing file system semantics the file system provides functions normally associated with a volume manager. These functions include i aggregation of the disks ii aggregation of storage bandwidth of the disks and iii reliability guarantees such as mirroring and or parity RAID . The file system illustratively implements the WAFL file system hereinafter generally the write anywhere file system having an on disk format representation that is block based using e.g. 4 kilobyte kB blocks and using index nodes inodes to identify files and file attributes such as creation time access permissions size and block location . The file system uses files to store meta data describing the layout of its file system these meta data files include among others an inode file. A file handle i.e. an identifier that includes an inode number is used to retrieve an inode from disk.

Broadly stated all inodes of the write anywhere file system are organized into the inode file. A file system fs info block specifies the layout of information in the file system and includes an inode of a file that includes all other inodes of the file system. Each logical volume file system has an fsinfo block that is preferably stored at a fixed location within e.g. a RAID group. The inode of the inode file may directly reference point to data blocks of the inode file or may reference indirect blocks of the inode file that in turn reference data blocks of the inode file. Within each data block of the inode file are embedded inodes each of which may reference indirect blocks that in turn reference data blocks of a file.

Operationally a request from the client is forwarded as a packet over the computer network and onto the node where it is received at the network adapter . A network driver of layer or layer processes the packet and if appropriate passes it on to a network protocol and file access layer for additional processing prior to forwarding to the write anywhere file system . Here the file system generates operations to load retrieve the requested data from disk if it is not resident in core i.e. in memory . If the information is not in memory the file system indexes into the inode file using the inode number to access an appropriate entry and retrieve a logical vbn. The file system then passes a message structure including the logical vbn to the RAID system the logical vbn is mapped to a disk identifier and disk block number disk dbn and sent to an appropriate driver e.g. SCSI of the disk driver system . The disk driver accesses the dbn from the specified disk and loads the requested data block s in memory for processing by the node. Upon completion of the request the node and operating system returns a reply to the client over the network .

It should be noted that the software path through the storage operating system layers described above needed to perform data storage access for the client request received at the node may alternatively be implemented in hardware. That is in an alternate embodiment of the invention a storage access request data path may be implemented as logic circuitry embodied within a field programmable gate array FPGA or an application specific integrated circuit ASIC . This type of hardware implementation increases the performance of the storage service provided by node in response to a request issued by client . Moreover in another alternate embodiment of the invention the processing elements of adapters may be configured to offload some or all of the packet processing and storage access operations respectively from processor to thereby increase the performance of the storage service provided by the node. It is expressly contemplated that the various processes architectures and procedures described herein can be implemented in hardware firmware or software.

As used herein the term storage operating system generally refers to the computer executable code operable on a computer to perform a storage function that manages data access and may in the case of a node implement data access semantics of a general purpose operating system. The storage operating system can also be implemented as a microkernel an application program operating over a general purpose operating system such as UNIX or Windows NT or as a general purpose operating system with configurable functionality which is configured for storage applications as described herein.

In addition it will be understood to those skilled in the art that the invention described herein may apply to any type of special purpose e.g. file server filer or storage serving appliance or general purpose computer including a standalone computer or portion thereof embodied as or including a storage system. Moreover the teachings of this invention can be adapted to a variety of storage system architectures including but not limited to a network attached storage environment a storage area network and disk assembly directly attached to a client or host computer. The term storage system should therefore be taken broadly to include such arrangements in addition to any subsystems configured to perform a storage function and associated with other equipment or systems. It should be noted that while this description is written in terms of a write any where file system the teachings of the present invention may be utilized with any suitable file system including a write in place file system.

In the illustrative embodiment the storage server is embodied as D blade of the storage operating system to service one or more volumes of array . In addition the multi protocol engine is embodied as N blade to i perform protocol termination with respect to a client issuing incoming data access request packets over the network as well as ii redirect those data access requests to any storage server of the cluster . Moreover the N blade and D blade cooperate to provide a highly scalable distributed storage system architecture of the cluster . To that end each blade includes a cluster fabric CF interface module adapted to implement a network protocol that enables intra cluster communication among the blades as described herein.

The protocol layers e.g. the NFS CIFS layers and the iSCSI FC layers of the N blade function as protocol servers that translate file based and block based data access requests from clients into network protocol messages used for communication with the D blade . That is the N blade servers convert the incoming data access requests into primitive operations commands that are embedded within messages by the CF interface module for transmission to the D blades of the cluster . Notably the CF interface modules cooperate to provide a single file system image across all D blades in the cluster . Thus any network port of an N blade that receives a client request can access any data container within the single file system image located on any D blade of the cluster.

Further to the illustrative embodiment the N blade and D blade are implemented as separately scheduled processes of storage operating system however in an alternate embodiment the blades may be implemented as pieces of code within a single operating system process. Communication between an N blade and D blade is thus illustratively effected through the use of message passing between the blades although in the case of remote communication between an N blade and D blade of different nodes such message passing occurs over the cluster switching fabric . A known message passing mechanism provided by the storage operating system to transfer information between blades processes is the Inter Process Communication IPC mechanism.

The network protocol illustratively described herein is the Spin network protocol SpinNP that comprises a collection of methods functions constituting a SpinNP application programming interface API . The SpinNP API in this context is a set of software calls and routines that are made available exported by a process and that can be referenced by other processes. As described herein all SpinNP protocol communication in the cluster occurs via connections. Communication is illustratively effected by the D m blade exposing the SpinNP API to which an N blade or another D blade issues calls. To that end the CF interface module is organized as a CF encoder and CF decoder. The CF encoder of e.g. CF interface on N blade encapsulates a SpinNP message as i a local procedure call LPC when communicating a command to a D blade residing on the same node or ii a remote procedure call RPC when communicating the command to a D blade residing on a remote node of the cluster . As used herein the term RPC shall be taken to mean both LPCs and RPCs. In either case the CF decoder of CF interface on D blade de encapsulates the SpinNP message and processes the command. In accordance with the illustrative embodiment of the present invention the CF encoder implements that message integrity check of the present invention.

The SpinNP network protocol is illustratively a multi layered protocol that integrates a session infrastructure and an application operation set into a session layer. The session layer manages the establishment and termination of sessions between blades in the cluster and is illustratively built upon a connection layer that defines a set of functionality or services provided by a connection oriented protocol. The connection oriented protocol may include a framing protocol layer over a network transport such as RC and or TCP or a memory based IPC protocol. These connections are formed via the network transport or via the local memory to memory or adapter to memory transport and provide a packet message transport service with flow control. It should be noted that other connection oriented protocols perhaps over other transports can be used as long as those transports provide the same minimum guaranteed functionality e.g. reliable message delivery.

The SpinNP network protocol is illustratively a request response protocol wherein a blade requester receiving a data access request from a client redirects that request to another blade responder that services the request and upon completion returns a response. The network protocol is illustratively implemented by the CF interface modules and as such a SpinNP session provides a context for the flow of request messages requests and a reverse direction flow of corresponding response messages responses to those requests. Each request consists of one SpinNP message and generates one response unless the connection is lost or the session terminates abnormally. is a schematic block diagram illustrating the organization of the CF interface modules adapted to implement the SpinNP protocol in accordance with the present invention. Each module comprises a SpinNP session layer and a connection layer

As noted the SpinNP network protocol relies on connections for reliable message delivery. As such a session is disposed over one or more connections and is illustratively established between a pair of blades or other participants. For example a session can be established between D blades between an N blade and a D blade and between N blades if there proves to be a need for N blade to N blade SpinNP calls . The session can also be used to inter connect other entities or agents including user space processes and services to blades or to each other. Each pair of blades typically requires only one session to communicate however multiple sessions can be opened simultaneously between the same pair of blades. Each session requires bi directional request flow over the same connection. The session also provides an infrastructure that makes messages secure and supports recovery without requiring an additional protocol layer between the network transport layer RC or TCP and the application layer e.g. file access operations . Each session is independently negotiated and initiated to thereby enable a high level of message concurrency and asynchrony.

The connections are established by the connection layers and provide the network transport for the sessions between the blades. At least one connection is required for each session wherein the connection is used for both requests and responses. Although more than one connection can be bound to a session only connections that are bound to the session can be used to carry the requests and responses for that session. The connections are bi directional allowing message flow in each direction. For example requests flow in both directions on each session thereby allowing forward operational and reverse callback flows to be sent through the same session. Responses for both directions of request flow are also carried in the session. Connections that are bound to sessions cannot be shared by multiple sessions however multiple sessions may be multiplexed onto a single connection. That is operational and callback sessions between an N blade D blade pair can be multiplexed onto a single connection. Sessions can also multiplex operations for different clients and different users.

Each session is illustratively identified by a globally unique identifier id formed of the universal unique ids UUIDs of its two participant blades with the session initiator s UUID listed first. The globally unique id is combined with a 64 bit uniquifier that is unique for all concurrent sessions between the pair of blades regardless of which blade is the initiator as well as for any dormant recoverable session for which any state is still stored on either of the two blades. The uniquifier may be generated using the current time indicating the time of constructing a session initiation operation i.e. CREATE SESSION conveyed within an appropriate request. The resulting session id uniquifier is then confirmed to be unique by the receiver blade. Note that the id uniquifier should be unique unless both blades are trying to create a session to each other simultaneously. If so each blade can counter propose a different session id possibly by simply adding a small random number to the original proposed session id uniquifier.

Illustratively GSS security is performed on a per session basis. During session initialization a secure GSS API key exchange is performed. The exchanged keys are utilized for subsequent encryption of a message integrity check described further below. It should be noted that while in the illustrative embodiment the participants to a GSS security session are the blades of a node the principles of the present invention may be utilized in other contexts. As such the use of the message integrity check between blades of a node should be taken as exemplary only.

The present invention is directed to a system and method for generating a message integrity check for use in data transmissions including e.g. RPC based network protocols executing on nodes of a cluster. All network protocol communication in the cluster occurs via connections which provide a network transport for sessions between the requesters responders. At least one connection is required for each session wherein the connection is used for both requests and responses. Each request response is embodied as a RPC that is transmitted over one of the connections. Each RPC comprises a header and a set of procedure specific parameters. For network protocol RPCs the procedure specific parameters include a control portion and the data associated with the RPC.

In the illustrative embodiment of the invention one or more block checksums are generated in the control portion of the RPC. These block checksums may be quickly computed using conventional data checksumming procedures for the data contained within the RPC. In addition block sizes of the checksums are illustratively selected so that the checksum may be utilized at multiple stages of processing. For example assume a file system executing on the D blade utilizes 4 kilobyte KB blocks for internal operations and for writing to disk. Accordingly the block size for the block checksums may be selected as 4 KB in size. This permits the use of the checksum for end to end data protection e.g. from N blade to D blade to disk or vice versa. It should be noted that the block checksum s would typically be computed by either the sender and or recipient.

According to one embodiment of the invention the block checksum s of the control portion of the RPC are hashed and the resulting hash value encrypted to generate the message integrity check. This aspect of the invention contemplates use of a strong data checksum such as the well known MD 5 to provide a high confidence that the transmitted data is valid without checksumming the same data twice. It is noted that a block checksum may not be removed without detection accordingly an attacker would only be able to modify the data in a way that does not modify the block checksum. By using a sufficiently strong hashing algorithm the probability of successfully modifying the data while maintaining the proper checksum is greatly reduced.

Advantageously use of a hash of the block checksum preserves the integrity of the data within the protocol specific parameters of a RPC. An attempt to compromise the integrity of the data by e.g. a network attacker would require modifying the data in a meaningful way that does not modify the block checksum. As noted above the use of a sufficiently strong hashing algorithm provides a high degree of security by rendering it highly improbable that an attacker could succeed in modifying the data while maintaining the proper block checksum. Additionally it is highly improbable that the checksums could be removed or modified without detection via the message integrity check.

It is important to note that the system would typically compute the block checksum even if the present invention was not utilized. As such the added computations to hash the block checksums is minimal compared to the processing required to hash the data to generate the block checksums. Thus the message integrity check of the present invention may be utilized with any data transmission including RPCs data streams file level protocols etc. To compute the message integrity check of the data transmission one only needs to compute the message integrity of the block checksums and any header information which may be performed substantially faster than conventional Integrity verification.

The foregoing description has been directed to particular embodiments of this invention. It will be apparent however that other variations and modifications may be made to the described embodiments with the attainment of some or all of their advantages. The present invention may be applied to any wire protocol or other form of data transmission. While the present invention has been written in terms of protection of file protocols or RPCs the teachings of the present invention may be applied to any form of data transmission that includes block checksums. Additionally the procedures processes layers and or modules described herein may be implemented in hardware software embodied as a computer readable medium having program instructions firmware or a combination thereof. Therefore it is the object of the appended claims to cover all such variations and modifications as come within the true spirit and scope of the invention.

