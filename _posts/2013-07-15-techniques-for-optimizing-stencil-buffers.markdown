---

title: Techniques for optimizing stencil buffers
abstract: One embodiment sets forth a method for associating each stencil value included in a stencil buffer with multiple fragments. Components within a graphics processing pipeline use a set of stencil masks to partition the bits of each stencil value. Each stencil mask selects a different subset of bits, and each fragment is strategically associated with both a stencil value and a stencil mask. Before performing stencil actions associated with a fragment, the raster operations unit performs stencil mask operations on the operands. No fragments are associated with both the same stencil mask and the same stencil value. Consequently, no fragments are associated with the same stencil bits included in the stencil buffer. Advantageously, by reducing the number of stencil bits associated with each fragment, certain classes of software applications may reduce the wasted memory associated with stencil buffers in which each stencil value is associated with a single fragment.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09098925&OS=09098925&RS=09098925
owner: NVIDIA Corporation
number: 09098925
owner_city: Santa Clara
owner_country: US
publication_date: 20130715
---
Embodiments of the present invention relate generally to graphics processing and more specifically to techniques for optimizing stencil buffers.

Some conventional graphics processing units GPUs include different processing engines configured to operate in parallel with one another to implement a graphics processing pipeline. A graphics processing pipeline is the collection of processing steps performed to transform 3 D images into rendered 2 D images. When a given processing engine finishes processing data that processing engine may copy the processed data from local memory to a memory that is shared between the different processing engines within the GPU. Other processing engines may then access the processed data and then perform additional processing operations with that data. One type of data structure used in a graphics processing pipeline to allow different processing engines to access that data is a stencil buffer.

Stencil buffers include stencil values associated with each pixel or sample included in an image surface. Typically each stencil value is an unsigned integer represented by 8 bits. The meaning and use of the stencil values varies by application. But in general stencil values are compared with reference values as part of stencil tests. The outcome of a particular stencil test is often coupled with a depth test and the result determines whether a sample is discarded. This result may also be used to control the updating of the stencil value. In operation the stencil buffer is often used to identify a set of samples in one render pass and then control the fate of the identified samples and the updating of the associated stencil values in subsequent render passes.

In addition to well known operations such as limiting the rendering area the stencil buffer may be used in a variety of different algorithms. For some classes of algorithms the stencil values included in the stencil buffer are used as binary switches the stencil value associated with each sample is either on or off. In subsequent rendering passes the samples associated with stencil values that are on are processed in an application specific manner. In addition the stencil values that are off are typically discarded. For instance even odd path rendering may be implemented using a stencil then cover algorithm where stencil values are assigned either a 1 or a 0. In even odd path rendering if an odd number of path edges lie between the sample and the outside of the shape then the sample is considered to be inside the shape. Conversely if an even number of path edges lie between the sample and the outside of the shape then the sample is considered to be outside the shape. In a first rendering pass the stencil values corresponding to all of the samples within the path are assigned a 1. In a second rendering pass the samples associated with stencil values equal to 1 are colored and the samples associated with stencil values equal to 0 are discarded.

One limitation to using stencil buffers in a binary fashion is that the stencil buffer requires a relatively large amount of sparsely accessed memory. For example suppose that each pixel included 16 samples and an algorithm were to use a stencil buffer in a binary fashion. In such a scenario the stencil buffer corresponding to each surface would include 128 bits per pixel but the algorithm would only utilize 16 bits per pixel. Consequently 122 bits per pixel of memory would be wasted. Because the local memory capacity of GPUs is limited such memory wastage is undesirable. The negative impact of wasted memory is particularly noticeable for systems that include relatively small local memories such as those in low cost mobile environments.

As the foregoing illustrates what is needed in the art is a more effective technique for implementing stencil buffers.

One embodiment of the present invention sets forth a method for associating fragments with stencil bits included in stencil values. The method includes subdividing a first surface into partitions based on a number of stencil bits defined per fragment associating a first partition included in the partitions with a first stencil mask that includes a first number of bits equal to the number of stencil bits defined per fragment mapping surface coordinates of a first fragment to a first virtual address included in a virtual address space where the first fragment resides within the first partition selecting a first stencil value based on the first virtual address and performing a logical operation between the first stencil mask and the first stencil value to associate the first fragment with the first number of bits included in the first stencil mask.

One advantage of the disclosed techniques is that stencil buffers are optimally sized based on the requirements of the software application. In particular the amount of physical memory used to store stencil buffers is reduced for software applications that require less than the nominal prior art number of stencil bits per sample. Thus the amount of wasted memory may be dramatically reduced for such software applications.

In the following description numerous specific details are set forth to provide a more thorough understanding of the present invention. However it will be apparent to one of skill in the art that the present invention may be practiced without one or more of these specific details.

In operation I O bridge is configured to receive user input information from input devices such as a keyboard or a mouse and forward the input information to CPU for processing via communication path and memory bridge . Switch is configured to provide connections between I O bridge and other components of the computer system such as a network adapter and various add in cards and .

As also shown I O bridge is coupled to a system disk that may be configured to store content and applications and data for use by CPU and parallel processing subsystem . As a general matter system disk provides non volatile storage for applications and data and may include fixed or removable hard disk drives flash memory devices and CD ROM compact disc read only memory DVD ROM digital versatile disc ROM Blu ray HD DVD high definition DVD or other magnetic optical or solid state storage devices. Finally although not explicitly shown other components such as universal serial bus or other port connections compact disc drives digital versatile disc drives film recording devices and the like may be connected to I O bridge as well.

In various embodiments memory bridge may be a Northbridge chip and I O bridge may be a Southbrige chip. In addition communication paths and as well as other communication paths within computer system may be implemented using any technically suitable protocols including without limitation AGP Accelerated Graphics Port HyperTransport or any other bus or point to point communication protocol known in the art.

In some embodiments parallel processing subsystem comprises a graphics subsystem that delivers pixels to a display device that may be any conventional cathode ray tube liquid crystal display light emitting diode display or the like. In such embodiments the parallel processing subsystem incorporates circuitry optimized for graphics and video processing including for example video output circuitry. Such circuitry may be incorporated across one or more parallel processing units PPUs included within parallel processing subsystem . In other embodiments the parallel processing subsystem incorporates circuitry optimized for general purpose and or compute processing. Again such circuitry may be incorporated across one or more PPUs included within parallel processing subsystem that are configured to perform such general purpose and or compute operations. In yet other embodiments the one or more PPUs included within parallel processing subsystem may be configured to perform graphics processing general purpose processing and compute processing operations. System memory includes at least one device driver configured to manage the processing operations of the one or more PPUs within parallel processing subsystem .

In various embodiments parallel processing subsystem may be integrated with one or more other the other elements of to form a single system. For example parallel processing subsystem may be integrated with CPU and other connection circuitry on a single chip to form a system on chip SoC .

In operation the CPU is the master processor of the computer system controlling and coordinating operations of other system components. In particular the CPU issues commands that control the operation of the parallel processing subsystem . Those commands may originate within a software application resident in the system memory and executing on the CPU . Advantageously the parallel processing subsystem may execute commands asynchronously relative to the operation of the CPU . A graphics application programming interface API is also resident in the system memory . The graphics API includes calls and libraries that expose parallel processing subsystem functionality to application developers. Among other things the graphics API enables application developers to tailor the software application to optimize the way the parallel processing subsystem functions. In general the software application issues calls to the graphics API to produce a desired set of results using components included in the parallel processing subsystem . In alternate embodiments the graphics API may be replaced with any software program that exposes parallel processing subsystem functionality. For example the graphics API may be replaced with a different general purpose API. Further the graphics API may be configured to inter operate with one or more additional software APIs.

It will be appreciated that the system shown herein is illustrative and that variations and modifications are possible. The connection topology including the number and arrangement of bridges the number of CPUs and the number of parallel processing subsystems may be modified as desired. For example in some embodiments system memory could be connected to CPU directly rather than through memory bridge and other devices would communicate with system memory via memory bridge and CPU . In other alternative topologies parallel processing subsystem may be connected to I O bridge or directly to CPU rather than to memory bridge . In still other embodiments I O bridge and memory bridge may be integrated into a single chip instead of existing as one or more discrete devices. Lastly in certain embodiments one or more components shown in may not be present. For example switch could be eliminated and network adapter and add in cards would connect directly to I O bridge .

In some embodiments one or more PPUs not explicitly shown in either or included within the parallel processing subsystem comprise a graphics processing unit GPU . The GPU may be configured to implement a graphics processing pipeline to perform various operations related to generating pixel data based on graphics data supplied by CPU and or system memory . Further the graphics processing pipeline may comprise a world space pipeline and a screen space pipeline. The world space pipeline processes graphics objects in 3D space where the position of each graphics object is known relative to other graphics objects and relative to a 3D coordinate system. The screen space pipeline processes graphics objects that have been projected from the 3D coordinate system onto a 2D planar surface representing the surface of the display device .

A tiling unit included in the parallel processing subsystem is a graphics primitive sorting engine that resides between the world space pipeline and the screen space pipeline. Graphics primitives are processed in the world space pipeline and then transmitted to the tiling unit . The screen space is divided into cache tiles where each cache tile is associated with a portion of the screen space. The size of a cache tile may be based on a number of factors including the quantity and configuration of render targets associated with the screen space the quantity of samples per pixel and whether the data stored in the cache tile is compressed. As a general matter a cache tile is sized to increase the likelihood that the cache tile data remains resident in the cache memory of the parallel processing subsystem until all graphics primitives associated with the cache tile are fully processed.

For each graphics primitive the tiling unit identifies the set of cache tiles that intersect with the graphics primitive a process referred to herein as tiling. After tiling a certain number of graphics primitives the tiling unit processes the graphics primitives on a cache tile basis where graphics primitives associated with a particular cache tile are transmitted to screen space pipeline. The tiling unit transmits graphics primitives to the screen space pipeline one cache tile at a time. Graphics primitives that intersect with multiple cache tiles are typically processed once in the world space pipeline but are then transmitted multiple times to the screen space pipeline. Each cache tile is further divided into multiple raster tiles. Consequently each raster tile represents a portion of the portion of the screen space represented by a cache tile. The processing of the different raster tiles within a given cache tile may be distributed among any processing entities included within computer system in any technically feasible manner.

Within the screen space pipeline one of the components that operates on raster tiles is a raster operations unit ROP unit . The ROP unit is a processing unit that performs raster operations such as stencil z test blending and the like and transmits pixel data as processed graphics data for storage in graphics memory where graphics memory is typically structured as one or more render targets. The processed graphics data may be stored in graphics memory the PP memory or the system memory for display on the display device or for further processing by the CPU or the parallel processing subsystem . In some embodiments the ROP unit is configured to compress z or color data that is written to memory and decompress z or color data that is read from memory.

When processing graphics data the PP memory can be used as graphics memory that stores one or more conventional frame buffers and if needed one or more other render targets as well. Among other things the PP memory may be used to store and update pixel data and deliver final pixel data or display frames to the display device for display. As shown the PP memory includes a stencil buffer that is configured as a render target. The stencil buffer includes stencil information associated with samples corresponding to screen space coordinates. As also shown the PP memory includes multiple stencil masks . In particular the PP memory includes a number N of stencil masks where N 2. Herein multiple instances of like objects are denoted with reference numbers identifying the object and parenthetical numbers identifying the instance where needed. 

The stencil buffer is typically organized into 8 bit stencil values. The ROP unit is configured to operate upon the 8 bit stencil values in conjunction with the stencil masks . As outlined previously herein in prior art systems each 8 bit stencil value is typically associated with a single fragment such as a sample or a pixel. However many software applications implement algorithms that involve fewer than 8 bits of the stencil buffer per sample. In particular some software applications require only binary stencil functionality. Irrespective of the software application prior art systems often allocate the amount of physical memory required to store 8 stencil bits per sample. Advantageously the parallel processing subsystem allocates the amount of physical memory required to store only an application specific number of stencil bits per sample. In particular the graphics API includes calls that expose this additional flexibility to the software application thereby allowing the software application to specify the number of stencil bits per sample to include in the stencil buffer . In operation the graphics processing pipeline is configured to generate and apply the stencil masks to associate the 8 bits included in each 8 bit stencil value with different samples.

More specifically a unit within the graphics processing pipeline receives the number of stencil bits per sample and then associates the samples the stencil buffer and the stencil masks based on the number of stencil bits per sample. In one embodiment the tiling unit receives the number of stencil bits per sample. The tiling unit then determines the number of samples per stencil value by computing the number of samples that each individual 8 bit stencil value has the capacity to uniquely represent. For example if the number of stencil bits per sample were 1 then each individual 8 bit stencil value would have the capacity to uniquely represent 8 samples and the samples per stencil value would be 8. If the number of stencil bits per sample were 2 then the samples per stencil value would be 4 and so forth. The tiling unit then creates a set of stencil masks . The total number of stencil masks equals the samples per stencil value and each of the stencil masks selects a different subset of 8 total bits. For instance if the number of stencil bits per sample were 1 then the stencil masks through would be 0b00000001 0b00000010 0b00000100 0b00001000 0b00010000 0b00100000 0b01000000 and 0b10000000. Alternatively or additionally the stencil masks can be stored in registers within the parallel processing subsystem.

Subsequently the tiling unit receives a surface generally via receiving parameters such as location in PP memory dimensions etc. The tiling unit subdivides the surface into regions where the number of regions equals the number of stencil masks and each region is associated with a different stencil mask . Upon receiving a sample the tiling unit uses the x y screen space coordinates associated with the sample to select the region of the surface that includes the sample. The tiling unit then outputs the stencil mask associated with the selected region thereby associating the stencil mask with the sample. The associated stencil value is assigned based on the virtual address of the stencil buffer corresponding to the x y screen space coordinates associated with the sample. Notably if tile caching is enabled then the tiling unit is configured to compute and output the stencil mask only once per cache tile based on the x y screen space coordinates associated with the cache tile.

In this fashion the tiling unit associates the stencil masks and the samples to ensure that each bit included in the stencil buffer is associated with only a single sample. In particular each region of the surface corresponds to a different subset of bits in each 8 bit sample value. To optimize memory usage the page table entries PTEs included in the MMU are configured such that the virtual address space of the stencil buffer corresponding to each region in the surface maps to the same physical address space. Consequently the physical memory allocated to the stencil buffer is proportional to the number of stencil bits per sample. For example suppose that the software application were to specify 1 stencil bit per sample. The amount of PP memory that the parallel processing subsystem would dedicate to the stencil buffer would be one eighth the amount of PP memory that a prior art system would dedicate to the stencil buffer .

After the tiling unit outputs the appropriate stencil mask subsequent units in the graphics processing pipeline apply the stencil mask when performing any stencil actions involving the sample associated with the stencil mask . Stencil actions include any types of action performed using the stencil buffer such as stencil tests stencil comparisons stencil operations stencil value reads stencil value writes etc. In general existing functionality included within the graphics processing pipeline ensures that only the subset of bits specified by the stencil mask are accessed in conjunction with the associated sample. For example before performing any stencil action the ROP unit performs a bitwise logical AND operation of the stencil mask and the stencil value associated with the sample and included in the stencil buffer . Further before performing a stencil test between the stencil value and a reference stencil value the ROP unit also performs a bitwise logical AND operation of the stencil mask and the reference stencil value. Advantageously by leveraging the existing stencil functionality the changes to existing units included in the graphics processing pipeline are minimized.

In some embodiments the ROP unit or the device driver may include functionality that tailors stencil actions to reflect the number of stencil bits per sample. For example suppose that the number of stencil bits per sample were 1. In such a scenario the ROP unit would implement both an increment stencil operation and a decrement stencil operation using an inversion stencil operation. As another example if the number of stencil bits per sample were 2 the ROP unit would implement two bit arithmetic for an increment stencil operation and a decrement stencil operation.

In alternate embodiments the graphics processing pipeline may be configured to operate on a pixel or group of pixel instead of a sample. In such a scenario the bits in each 8 bit stencil value may be associated with different pixels or group of pixels instead of different samples.

It will be appreciated that the system shown herein is illustrative and that variations and modifications are possible. For example within the parallel processing subsystem any units or combination of units may be configured to receive the stencil bits per sample and associates the bits in each stencil value with different samples in any technically feasible manner. In particular instead of dividing the surface into a number of regions equal to the number of stencil masks units within the parallel processing subsystem may further subdivide the regions. Finer levels of interleaving partitions may provide better cache locality in the ROP unit .

The tiling unit sets the stencil mask to select the least significant bit 0x01 included in the stencil value. In addition the tiling unit associates the stencil mask with the first region of the surface . By associating the stencil mask with the first region of the surface the tiling unit also associates any samples or cache tiles that lie within the first region in screen space with the first stencil mask . Thus subsequent stencil actions associated with any sample that lies within the first region in screen space access only the least significant bit of the corresponding stencil value.

In contrast the tiling unit sets the stencil mask to select the most significant bit 0x80 included in the stencil value. In addition the tiling unit associates the stencil mask with the eighth region of the surface . By associating the stencil mask with the eighth region of the surface the tiling unit also associates any samples or cache tiles that lie within the eighth region in screen space with the eight stencil mask . Thus subsequent stencil actions associated with any sample that lies within the eighth region in screen space access only the most significant bit of the corresponding stencil value.

In a similar fashion each of the remaining stencil masks through selects a single different intermediate bit included in the stencil value. And each of these stencil masks is associated with an intermediate region of the surface . In this fashion samples that lie within different regions of the partitioned surface are associated with a different individual bit included in the stencil values. The specific stencil value associated with each sample is determined by the x y screen space coordinates corresponding to the sample.

The surface corresponds to the virtual address space of the stencil buffer . The virtual address space includes a different virtual address for each sample included in the surface . However the tiling unit configures the page table entries included in the MMU such that the virtual address spaces of the stencil buffer corresponding to region through region all map to the same stencil buffer physical address space . Consequently as shown the stencil buffer physical address space is one eighth the size of the virtual address space corresponding to the surface . The MMU allocates the PP memory based on the stencil buffer physical address space . Thus the PP memory footprint that the MMU allocates for the stencil buffer is one eighth the size of the PP memory footprint that a MMU included in a prior art system would allocate for the stencil buffer .

As shown the virtual addresses of the first stencil value included in each of the regions through all map to the address of the first stencil value in the stencil buffer physical address space . As also shown each of the first stencil values included in each of the regions is associated with a different stencil mask . Thus the sample corresponding to the first virtual address included in region of the surface is associated with the LSB of the first stencil value included in the stencil buffer . Similarly the sample corresponding to the first virtual address included in region of the surface is associated with the MSB of the first stencil value included in the stencil buffer . Advantageously by strategically assigning the stencil masks and overlapping regions of the virtual address space in the stencil buffer physical address space the tiling unit preserves the integrity of the stencil buffer . More specifically the tiling unit ensures that each of the bits included in the stencil buffer is accessed in conjunction with stencil operations associated with only one particular sample.

As shown a method begins at step where the tiling unit receives the surface and subdivides the surface into 8 different regions. In alternate embodiments a different number of regions may be used. The tiling unit may subdivide the surface in any technically feasible fashion. For instance the tiling unit may subdivide the surface based on the x y screen space coordinates. In alternate embodiments the tiling unit may subdivide the surface based on the virtual addresses corresponding to samples represented by the surface . At step the tiling unit configures the MMU to map the virtual address range of each of the 8 different regions to the same physical address range. As a result each sample is associated with the stencil value whose physical memory location is specified by the offset of the coordinates of the sample relative to the first coordinates of the region in which the sample lies. Advantageously the entire physical address range is the same size as the virtual address range corresponding to a single region in the surface . In other words the physical address range is one eighth the size of the virtual address range corresponding to the entire surface .

At step the tiling unit uses a different stencil mask to each of the 8 regions. Each of the stencil masks selects a different individual bit of an 8 bit stencil value. In this fashion the tiling unit ensures that each sample included in the surface is uniquely associated with a single bit included in the stencil buffer and backed by the PP memory .

At step the tiling unit receives a cache tile. At step the tiling unit uses the x y screen space coordinates of the cache tile to select the region of the surface that includes the cache tile. At step the tiling unit outputs the stencil mask assigned to the selected region. Advantageously the tiling unit is configured to output the stencil mask for each cache tile instead of for each sample thereby streamlining the graphics processing pipeline.

Persons of ordinary skill in the art will understand that various modifications and changes may be made to optimize different processing steps included in the graphics processing pipeline. In particular the ROP unit instead of the tiling unit may be configured to generate the stencil masks . Further the ROP unit may be configured to vary the stencil masks per raster tile instead of per partition thereby optimizing the cache locality of the ROP unit . In one embodiment the ROP unit is configured to determine the stencil masks based on a virtual address associated with a stencil raster tile.

The ROP unit receives a software application specification of 1 stencil bit per sample. Further as shown the ROP unit receives the 8 bit stencil raster tile virtual address VA . Instead of assigning the stencil mask based on the x y screen coordinates of the 8 bit stencil raster tile VA the ROP unit decomposes the 8 bit stencil raster tile VA into the stencil mask and a 1 bit stencil raster tile VA .

Notably as shown the ROP unit decomposes the 8 bit stencil raster tile VA into three separate sets of bits. The least significant bits are grouped together as a first set of bits and represent a virtual address internal to a raster tile. Consequently the number of bits included in the first set of bits is equal to the number of bits required to represent an entire raster tile. Because the 8 bit stencil rater tile VA is aligned to a stencil tile boundary the bits included in the first set of bits are all zero. In alternate embodiments the number of bits included in the first set of bits may exceed the number of bits required to represent an entire raster tire. The next three bits are grouped together as a second set of bits the stencil index bits . Finally the remaining most significant bits are grouped together as a third set of bits.

As shown the ROP unit is configured to retain LSBs from 8 bit stencil raster tile VA . In operation the ROP unit uses the first set of bits as the LSB bits of the corresponding 1 bit stencil raster tile VA without altering the bits. As also shown the ROP unit is configured to shift MSBs from 8 bit stencil raster tile VA right 3 bits . First the ROP unit performs a bitwise shift operation shifting the third set of bits to the right by three bits. Second the ROP unit prepends the third shifted set of bits to the first set of bits forming the entire 1 bit stencil raster tile VA . As shown the 1 bit stencil raster tile VA is 3 bits smaller than the original 8 bit stencil raster tile VA . Consequently the virtual address space corresponding to the 1 bit stencil raster tile VA is one eighth the size of the virtual address space corresponding to the 8 bit stencil raster tile VA .

The ROP unit is also configured to repurpose 3 bits of the 8 bit stencil raster tile VA . In operation the ROP unit uses the second set of bits the 3 stencil index bits to create the stencil mask . More specifically the ROP unit computes the stencil mask by performing a bitwise shift operation shifting the bit 1 to the left by the value of the stencil index bits . For example as shown the ROP unit repurposes the exemplary stencil index bits 0b011 by performing a bitwise shift operation shifting 1 to the left by 3. The ROP unit assigns the results of this bitwise shift operation 0x8 to the stencil mask . This stencil mask selects a single bit included in an 8 bit stencil value corresponding to the 1 bit stencil raster tile VA . In this fashion the ROP unit is configured to convert each 8 bit stencil raster tile VA into a unique combination of the stencil mask and the 1 bit stencil raster tile VA . Consequently each 8 bit stencil raster tile VA selects a unique bit included in the stencil buffer .

Advantageously the MMU allocate PP memory for the 1 bit stencil raster tile VA not the 8 bit stencil raster tile VA . Consequently the amount of PP memory that the MMU allocates for the stencil buffer is one eighth smaller than the amount of PP memory that a MMU included in a prior art system would allocate for the stencil buffer . Further the computed 1 bit stencil raster tile VAs typically associate samples that are adjacent in screen space with adjacent stencil values. Advantageously this provides good coherence in the mini cache associated with the ROP unit .

As is apparent to one skilled in the art the techniques disclosed herein may be applied to various different types of fragments and to various numbers of stencil bits. For instance in alternate embodiments the ROP unit may be configured to assign any number of stencil bits per sample. Further the parallel processing pipeline including the ROP unit may be configured to perform stencil actions associated with separate pixels or separate groups of pixels instead of separate samples.

As shown a method begins at step where the ROP unit receives an original virtual address VA corresponding to an 8 stencil bits per sample stencil buffer . At step the ROP unit determines the number of LSB bits sufficient to represent the addresses included in a raster tile. The ROP unit may determine the number of LSB bits in any technical feasible fashion. For example the ROP unit may compute the log base 2 of the number of addresses included in the raster tile and round this value up to determine the number of LSB bits.

At step the ROP unit divides the original virtual address into 3 sets of bits a set of LSB bits a set of 3 stencil index bits and a set of MSB bits. In particular the ROP unit assigns the lowest original VA bits to the set of LSB bits the 3 middle original VA bits to the set of stencil index bits and the remaining bits of the original VA bits to the set of MSB bits. At step the ROP unit computes the stencil mask by performing a bitwise shift operation 1 

At step the ROP unit performs a bitwise shift operation shifting the MSB bits to the right by 3. At step the ROP unit combines the shifted MSB bits and the LSB bits to create a virtual address corresponding to a 1 stencil bit per sample stencil buffer . Advantageously together the stencil mask and the virtual address corresponding to a 1 stencil bit per sample stencil buffer select a single unique stencil bit included in the stencil buffer . Further the size of the PP memory that the parallel processing subsystem allocates to the stencil buffer is optimized to reflect the number of stencil bits per sample not the nominal 8 stencil bits per sample included in each stencil value.

In sum stencil buffers may be more effectively implemented by allowing software applications to specify the number of stencil bits per sample. More specifically the graphics processing pipeline is configured to create and access an optimally sized stencil buffer based on the number of stencil bits per sample. In one example using the techniques disclosed herein a tiling unit included in the graphics processing pipelines subdivides a surface into 8 regions. The tiling unit then creates a set of 8 stencil masks where each stencil mask is associated with a different bit and a different region. Upon receiving a cache tile the tiling unit uses the cache tile screen space coordinates to select the region that includes the cache tile. The tiling unit outputs the stencil mask associated with the selected region. Existing stencil mask functionality supports 8 bit stencil values and corresponding 8 bit stencil masks. Consequently stencil actions associated with a sample included in the cache tile access only one bit of the stencil value associated with the sample. The tiling unit also configures the MMU to map the range of virtual addresses corresponding to the stencil buffer in each region to the same range of physical addresses. Thus the physical address space corresponding to the stencil buffer is one eighth the size of the virtual address space corresponding to the stencil buffer. Because each region selects a different bit in the 8 bit stencil values no two samples are associated with the same bit in the stencil buffer.

In another example a ROP unit included in the graphics processing pipeline converts a virtual address corresponding to an 8 bit stencil raster tile into a virtual address corresponding to a 1 bit stencil raster tile and a corresponding stencil mask. More specifically the ROP unit divides the 8 bit stencil raster tile virtual address into three sets of bits. The first set of bits includes the least significant bits included in the 8 bit stencil raster tile virtual address and represents an address internal to a raster tile. The second set of bits includes 3 intermediate stencil index bits included in the 8 bit stencil raster tile virtual address. The third set of bits includes the remaining most significant bits included in the 8 bit stencil raster tile virtual address. The ROP unit then creates a stencil mask that selects a single bit based on the stencil index bits. Further the ROP unit creates a corresponding 1 bit stencil raster tile virtual address based on the set of most significant bits and the set of least significant bits. Only the 1 bit stencil raster tile virtual addresses are backed by physical memory. Consequently the physical address space associated with the stencil buffer is one eighth the size of the virtual address range corresponding to 8 bit stencil raster tile virtual addresses. Together the stencil mask and the 1 bit stencil raster tile virtual address specify a single bit included in the stencil buffer.

Advantageously by using stencil masks to associate less than 8 stencil bits with each sample the amount of physical memory used to store the stencil buffer is reduced compared to prior art techniques. More specifically the amount of physical memory used to store a stencil buffer is reduced by a factor of 2 to 8 in inverse proportion to the specified number of stencil bits per sample. In particular if a software application requires only binary stencil buffer functionality then the software application specifies 1 stencil bit per sample. Using the disclosed techniques the physical memory allocated for a 1 bit stencil per sample stencil buffer is a factor of 8 smaller than the physical memory allocated for an 8 bit stencil per sample stencil buffer. Consequently the memory waste associated with the stencil buffer is reduced compared to prior art techniques in which 8 stencil bits are invariably associated with each sample. Further in some implementations the groups of samples associated with each 8 bit stencil value may be selected to optimize cache locality within the ROP unit thereby optimizing stencil buffer accesses.

While the foregoing is directed to embodiments of the present invention other and further embodiments of the invention may be devised without departing from the basic scope thereof. For example aspects of the present invention may be implemented in hardware or software or in a combination of hardware and software. One embodiment of the invention may be implemented as a program product for use with a computer system. The program s of the program product define functions of the embodiments including the methods described herein and can be contained on a variety of computer readable storage media. Illustrative computer readable storage media include but are not limited to i non writable storage media e.g. read only memory devices within a computer such as CD ROM disks readable by a CD ROM drive flash memory ROM chips or any type of solid state non volatile semiconductor memory on which information is permanently stored and ii writable storage media e.g. floppy disks within a diskette drive or hard disk drive or any type of solid state random access semiconductor memory on which alterable information is stored.

The invention has been described above with reference to specific embodiments. Persons of ordinary skill in the art however will understand that various modifications and changes may be made thereto without departing from the broader spirit and scope of the invention as set forth in the appended claims. The foregoing description and drawings are accordingly to be regarded in an illustrative rather than a restrictive sense.

