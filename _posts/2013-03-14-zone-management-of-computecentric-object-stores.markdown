---

title: Zone management of compute-centric object stores
abstract: Zone management of compute-based object stores is provided herein. An exemplary method may include assigning a virtual operating system container from the reserve zone pool to a task group, the task group including a set of tasks for a phase of a first request, and executing the set of tasks within the assigned virtual operating system container.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09104456&OS=09104456&RS=09104456
owner: Joyent, Inc.
number: 09104456
owner_city: San Francisco
owner_country: US
publication_date: 20130314
---
The present technology relates generally to zone management of compute based object stores. More specifically but not by limitation the present technology allows for the management and assignment of compute zones that comprise virtual operating system containers. The present technology assigns zones to task groups to maximize efficiency and ensure fair allocation of resources to multitenant compute based object stores.

Various methods and systems for providing multitenant computing systems such as cloud computing have been attempted. In general a cloud based computing environment is a resource that typically combines the computational power of a large model of processors and or that combines the storage capacity of a large model of computer memories or storage devices. For example systems that provide a cloud resource may be utilized exclusively by their owners or such systems may be accessible to outside users who deploy applications within the computing infrastructure to obtain the benefit of large computational or storage resources.

The cloud may be formed for example by a network of servers with each server or at least a plurality thereof providing processor and or storage resources. These servers may manage workloads provided by multiple users e.g. cloud resource consumers or other users . Typically each user places workload demands upon the cloud that vary in real time sometimes dramatically. The nature and extent of these variations typically depend on the type of business associated with the user.

Oftentimes these cloud computing systems leverage virtual machines for their users. A virtual machine VM is an emulation of a real world computing system. Often the virtual machine provides a user with one or more different operating systems than the operating system of the local machine host that is running the virtual machine. The VM provides a complete system platform that provides the one or more operating systems. The VM is typically managed by a hypervisor that mediates computing resources of the host machine for use by the VM via hardware emulation. The use of hardware emulation is often deleterious to VM performance and in turn reduces the number of VMs that may run on a given host machine. Additionally as the number of VMs on a host machine increases and they begin to operate concurrently the hypervisor must coordinate the varying workloads of the VMs to prevent instability. Thus the scheduling required by the hypervisor is critical in ensuring that the underlying hardware system is utilized properly.

According to some embodiments the present technology may be directed to systems that comprise a one or more processors and b logic encoded in one or more tangible media for execution by the one or more processors and when executed operable to perform operations comprising i assigning a virtual operating system container from any of a reserve zone pool and a non reserve zone pool to a task group the task group comprising a set of tasks for a phase of a request ii and executing the set of tasks within the assigned virtual operating system container.

According to some embodiments the present technology may be directed to a system that comprises a one or more processors and b logic encoded in one or more tangible media for execution by the one or more processors and when executed operable to perform operations comprising i establishing a reserve zone pool of virtual operating system containers ii assigning a virtual operating system container from the reserve zone pool to a task group the task group comprising a set of tasks for a phase of a first request and iii executing the set of tasks within the assigned virtual operating system container.

According to some embodiments the present technology may be directed to a method that comprises a establishing a reserve zone pool of virtual operating system containers b assigning virtual operating system containers from any of a reserve zone pool and a non reserve pool zone to a plurality of task groups in a proportional manner c establishing an expected concurrency rate for each of the task groups d comparing an actual concurrency rate for each of the task groups to their expected concurrency rate and e reassigning virtual operating system containers to a task group based upon the step of comparing.

While this technology is susceptible of embodiment in many different forms there is shown in the drawings and will herein be described in detail several specific embodiments with the understanding that the present disclosure is to be considered as an exemplification of the principles of the technology and is not intended to limit the technology to the embodiments illustrated.

The terminology used herein is for the purpose of describing particular embodiments only and is not intended to be limiting of the present technology. As used herein the singular forms a an and the are intended to include the plural forms as well unless the context clearly indicates otherwise. It will be further understood that the terms comprises and or comprising when used in this specification specify the presence of stated features integers steps operations elements and or components but do not preclude the presence or addition of one or more other features integers steps operations elements components and or groups thereof.

It will be understood that like or analogous elements and or components referred to herein may be identified throughout the drawings with like reference characters. It will be further understood that several of the figures are merely schematic representations of the present technology. As such some of the components may have been distorted from their actual scale for pictorial clarity.

In general the system comprises an object store A that provides compute as a first class citizen of an object store A. More specifically compute operations e.g. instructing the system to compute on objects in the object store of the present technology resemble a top level API function similar to processes like storing or fetching objects in the object store A.

It will be understood that the terms object store comprise a network service for storing unstructured arbitrary sized chunks of data objects . It will be further understood that the object store may not support modifications to existing objects but supports full object replacement operations although systems that support both object modification and full object replacement operations may also utilize the features of the present technology to perform compute operations directly on e.g. in situ objects within the object store.

In some embodiments the system may be configured to receive a request to perform a compute operation on at least a portion of an object store from a first user. Again the user may be associated with one of the client devices. The request identifies parameters of the compute operation as well as objects against which the compute operation is executed.

In some instances the system may assign virtual operating system containers to a user based upon a request. The system may map objects to the containers that are associated with the user. Typically these objects are identified by the user in the request. A virtual operating system container performs the compute operation on an object according to the identified parameters of the request. The system may then clear the virtual operating system containers and return the virtual operating system containers to a pool of virtual operating system containers. Additional aspects of the system will be described in greater detail below.

It will be understood that a compute centric object store may be created to operate without the user of virtual operating system global kernel or virtual operating system containers. While such an object store would provide advantages such as in situ computation of data where objects are processed directly on the object store the object store may not isolate tenants in the similarly to systems that utilize a virtual operating system and or virtual operating system containers.

In these instances the compute centric object store may be configured to receiving a request to perform a compute operation on at least a portion of an object store from a first user via a network service the request identifying parameters of the compute operation. The object store may also execute an operating system process for the objects identified in the request. The operating system process may perform the compute operation on the object according to the identified parameters of the request. Additionally once the compute operation has been executed the operating system process may be terminated by the virtual operating system.

The terms in situ computation will be understood to include the execution of compute operations against objects in an object store where the objects not moved or copied from or within the object store.

In some embodiments the system is comprised of a hardware layer that provides a logical interface with at least one or more processors and a memory which stores logic that is executed by the one or more processors. Generally the hardware layer controls one or more of the hardware components of a computing system such as the computing system of which will be described in greater detail below. By way of non limiting example the hardware layer may manage the hardware components of a server blade or another similar device. The hardware layer provides access to the physical hardware that services a global operating system kernel that cooperates with the hardware layer . The global operating system kernel may also be referred to as a host operating system kernel.

Generally the global operating system kernel is configured to administer and manage a pool of guest virtual operating system containers such as containers A N. The containers A N may operate on a distributed object store in a multitenant manner where multiple containers can operate on the same object store simultaneously. It will be understood that each user is assigned container from the pool on an as needed basis. When a container is applied to an object store the container is referred to as a tenant.

According to some embodiments the system kernel may be utilized to setup the pool of guest virtual operating system containers. The system kernel may also be configured to provide a command line interpreter interface that allows users to request jobs execute other operating system implemented applications and interact with a virtual operating system in a manner that is substantially indistinguishable relative to an operating system executing on a bare metal device.

Generally a job may be input by a user via a command line interpreter such as a Unix shell terminal. More specifically the user may express a computation using the same language as the language used by a Unix shell terminal. The actual request is submitted to the network service B. Indeed a request may be submitted as an HTTP request to the network service B. The body of the request describes the computation to perform in terms of what commands are input into the command line interpreter which is running within a container. Contrastingly systems that utilize multiple VMs that each comprises an operating system kernel which are managed by a hypervisor often require users to construct complex programs or scripts to perform compute operations. Compute operations for traditional VM systems require complex programming due to a complex framework that is used by the hypervisor to coordinate hardware emulation for each of the VMs.

Using the command line interpreter interface the user may specify one or more desired compute operations that are to be executed against objects such as object within an object store A see . It is noteworthy that the object store A may include for example a local or distributed object store that maintains contiguous blobs blocks or chunks of data. It will be understood that the objects stored in the object store A are complete objects such as files or other similar data structures. Moreover the compute operations executed against the object store A may be performed in such a way that partial stores of data are avoided.

In order to perform compute operations on objects for multiple users the system kernel may collocate containers A N onto the object store A and execute the containers A N simultaneously. In a plurality of containers such as container A has been placed onto each of a plurality of objects within the object store A. Thus a virtual operating system container is assigned to each of the plurality of objects specified in the user request. Most frequently the assignment of a single container to a single object occurs when the system executes a map phase operation. The details of map and reduce phases provide by the system will be described in greater detail below.

Broadly speaking a virtual operating system container may be a lightweight virtualization solution offering a complete and secure user environment that operates on a single global kernel system kernel providing performance characteristics that are similar to operating systems that operate on bare metal devices. That is a virtual machine operates on emulated hardware and is subject to control by a hypervisor which produces computing inefficiencies. A virtual operating system container may operate without the computing inefficiencies of a typical virtual machine.

In some instances the system kernel may utilize a KVM Kernel Virtual Machine that improves the efficiency of the a virtual operating system such as the global operating system kernel by leveraging CPU virtualization extensions to eliminate a substantial majority of the binary translation i.e. hardware emulation that are frequently required by VMs.

Turning to an exemplary virtual operating system container A is shown as comprising a quick emulation layer QEMU a virtual guest operating system and a compute application that is managed by the virtual guest operating system . The QEMU provides hardware emulation and is also VMM virtual machine monitor . It is noteworthy that in some embodiments the QEMU is not a strict hypervisor layer but rather each QEMU may be independent in some exemplary embodiments. That is there may be one QEMU one per container instead of a single QEMU supporting several VMs. Advantageously the operations of both a VM and a VMM may be combined into the QEMU .

According to some embodiments the compute application that is executed may include a primitive O S compute operation. Exemplary compute operations may include operating system primitive operations such as query word count send receive and so forth. Additionally the operations may comprise more sophisticated operations such as operations that include audio or video transcoding. Additionally in some instances users may store programs or applications in the object store itself. Users may then execute the programs as a part of a compute operation.

In some instances the compute operations may include one or more phases such as a map phase followed by a reduce phase. Generally a map phase may include an operation that is executed against each of a plurality of objects individually by a plurality of containers. In some instances a unique container is assigned to each object that is to be processed.

In contrast a reduce phase may be executed by a single container against a plurality of objects in a batch manner. Using an example such as word count it will be assumed that the objects of the object store A may comprise text files. The application may execute a map phase to count the words in each of the text files. The output of the application may be stored in a plurality of output objects that are stored in the object store A. A compute application of another container may execute a reduce phase that sums the output objects of the map phase and generates a word count for all objects within the object store A.

It will be understood that the system kernel may schedule and coordinate various compute operations and phases performed by the compute applications of all containers. In sum the system kernel may act similarly to a hypervisor that manages the compute operations of the various active containers. Based upon the request input by the user the system kernel may instruct the containers to perform a series of map functions as well as a reduce functions. The map and reduce functions may be coordinated to produce the desired output specified in the request.

Turning to after receiving a request from a user the system kernel may select a first set of containers which includes container A from the pool of containers. This container A is assigned to a user. In response to receiving a request from a second user the system kernel may also select a second set of containers from the pool of containers.

Based upon the request received from the first tenant the system kernel may map the first set of containers to a plurality of objects such as object stored in the object store A. Likewise the system kernel may map a second set of containers to a plurality of different objects stored in the object store A for the second user. The objects and containers for the first user may be referred to as a compute zone of the first user while the objects mapped to the container N may be referred to as a compute zone of the second user. The maintenance of compute zones allows the system kernel to provide multitenant access to the object store A even when the first and second users are potentially adversarial. For example the first and second users may be commercial competitors. For security the system kernel maintains compute zones in order to balkanize object storage and prevent access to objects of other users. Additionally the balkanization of object storage also ensures fair distribution of resources between users.

It will be understood that the system kernel may maintain as many containers and compute zones as allowed by the processor s of the hardware layer . Additionally the system kernel assigns a container to a user on an as needed basis meaning that containers may not be assigned permanently to a user which would result in a monopolization of resources when the user is not performing compute operations.

Additionally because the container is placed onto the object store the system kernel need not transfer objects from the object store A into the container for processing in some exemplary embodiments. Advantageously the container operates directly on the objects of the object store A.

According to some embodiments the containers A N managed by the system kernel are empty when the containers A N are in the pool. After objects are mapped to the container compute operations may be executed by the container on the objects and a desired output is generated the system kernel may clear the container and return the container to the pool.

In some instances the system kernel may not generate containers until a request is received from a user. That is the system kernel may spin up or launch containers when a request is received from the user. This allows for minimum impact to the bare metal resources such as the CPU as the system kernel need not even maintain a pool of virtual operating system containers which are awaiting user requests. That is maintaining a pool of containers requires CPU and memory resources. When the compute operations have been completed the system kernel may terminate the containers rather than clearing the containers and returning the containers to a pool.

In accordance with the present disclosure an instruction set architecture may be implemented within the system . In some embodiments the instruction set architecture may specify an application programming interface that allows the system to interact with the distributed object store.

According to some embodiments the system communicatively couples with the object store A using a services related application programming interface SAPI which may provide features such as automatic discovery of object stores dynamic configuration of object stores and an API for a user portal. In sum the SAPI may allow users to configure deploy and upgrade applications using a set of loosely coupled federated services. In some embodiments the SAPI may include an underlying API and an autoconfig agent also referred to as a daemon . A SAPI client may also be disseminated to clients. It will be understood that the daemon may be associated with a physical node of the object store A.

In some embodiments according to the present disclosure various object stores such as object store A of comprise a single SAPI zone. It will be understood that the SAPI zone may be stateless and the SAPI zone may be configured to write objects into the object store A. In addition to storing objects the SAPI zone may also communicatively couple with a VM API to provision zones and a network API NAPI to reserve network interface controllers NIC and lookup network universal unique identifiers UUID .

It will be understood that the SAPI may comprise main object types including but not limited to applications services and instances. It is noteworthy that an application may comprise one or more services and each service may comprise one or more instances. Moreover instances may represent actual object store zones and such zones inherit zone parameters and metadata from their associated applications and services.

Also the application service and instance information may be used by the compute application of a virtual operating system container that is placed onto an object store. The daemon may control the operation of the containers operating on the daemon s object store.

The various applications services and instances may include three sets of properties. For example params may comprise zone parameters like a zone s RAM size disk quota image UUID and so forth. These parameters are evaluated when a zone is provisioned. Another property may comprise metadata which defines metadata available to the daemon . These metadata keys and values form the input of a script template in a configuration manifest described below . As these values are updated the daemon may rewrite any configuration and make reference to changed metadata values. Yet another property may comprise manifests that define a set of configuration manifests are indexed by name to facilitate inheriting manifest from parent objects.

It is noteworthy that creating applications and services have no effect on running zones in some exemplary embodiments. When an instance is created a zone is provisioned using the above information from its associated application service and instance. Stated otherwise applications and services e.g. a job or request may be defined separately from the objects that the applications and services are to be executed against. Thus a job may be thought of abstractly as a workflow template. Advantageously when the user requests the execution of a job objects need only be defined by the user. The workflow template is then applied against the objects.

In some embodiments the daemon of a zone may be tasked with maintaining configuration inside that zone. The daemon queries the SAPI directly to determine which files to write and where to write them within the object store A.

The daemon uses objects called configuration manifests those objects describe the contents location and semantics of configuration files for a zone. Those manifests contain a script template which is rendered using the metadata from the associated application service and instance.

When a user provides a request to the system the system kernel may coordinate a compute flow of compute operations which are managed by the daemon . That is the system kernel may receive a request or job from a user via a command line interpreter. The request identifies parameters of a compute operation that is to be executed against objects in a distributed object store. For example a request may include performing a word count operation on a file.

To facilitate compute flow during the compute process the system kernel may assign an input key for the request. This input key provides a unique identifier that allows objects and outputs of compute operations to be correlated to the user. Objects previously stored in the object store may be correlated to the user utilizing a unique identifier.

The user may also identify objects for the compute operation using for example the command line interpreter. An exemplary find object command may include Find User Object Store Location where the Object Store Location defines the object store that includes the object s which are necessary for execution of the compute operation.

In some instances the system kernel may query various daemons of object stores to locate the objects within the distributed object store. After the object have been located the system kernel may generate a set of tasks e.g. an instruction set that defines the various compute operations that are to be performed by the daemon of the located object store. In the example provided above the set of tasks may include only one word count task that is provided to a single daemon of an object store e.g. physical node . This relatively simple compute operation does not require coordination or scheduling of operations of multiple objects.

The daemon may provide instructions to one or more virtual operating system containers that are placed onto the object store by the system kernel . That is the instruction sets provided to the containers is based upon the task assigned to the daemon from the system kernel .

In some instances the set of tasks may include a more complex arrangement of operations that are executed against a plurality of objects stores. The system kernel may interact with the daemon to coordinate processing of these objects in a specified order.

Additionally the set of tasks may define various map phases that are to be executed on the objects of the object store as well as various reduce phases that are executed on the outputs of the map phases. It will be understood that objects within the workflow may be tracked and correlated together using the input key established by the system kernel . For example if an instruction set passed to a daemon requires performing a word count compute operation on 100 text files each of the objects of the compute operation may be correlated using the input key in some embodiments. Thus the objects of the compute operation could comprise 100 objects that each in some embodiments includes a word count value for their corresponding text file. The input key may be appended to the object as metadata.

It will also be understood that a map phase may result in multiple outputs which are generated from a single input object. For example assume that usage logs for a computing device are stored for a 24 hour time period. To determine hourly usage rates the 24 hour log object may be separated into 24 distinct objects. Thus the map phase may receive the 24 hour log object and may split the same into constituent output objects to complete the map phase.

It will be understood that a more complex request may require a more complicated set of tasks e.g. phases . For example if the user desires to look at all 11 p.m. to 12 p.m. user logs for a plurality of computing devices the set of tasks may require not only the map task where a single input object is processed into multiple objects but also a reduce phase that sums a plurality of 11 p.m. to 12 p.m. user logs for a plurality of devices.

In sum the system kernel may provide a daemon with tasks that include a map phase for generating the hour increment logs from various input objects. Additionally the tasks also inform the daemon to return the output objects which may be stored as an aggregate 11 p.m. to 12 p.m. log object within the object store.

It will be understood that the daemon of a physical node e.g. object store may control execution of compute operations by the one or more virtual operating system containers that are placed onto the object store via the system kernel .

Thus it is appreciated with that intermediate output objects may not be output to the user directly but may be fed back into the system for additional processing such as with the map and reduce phases described above. Moreover the set of tasks generated by the system kernel may include any number of map phases and or reduce phases which vary according to the steps required to produce the desired output.

Returning to the system kernel may in some instances be referred to as a global zone while the individual virtual operating system containers may be referred to as guest compute zones. Generally a guest compute zone may also be referred to as a guest virtual operating system container as described above.

Generally the daemon may be coupled with the system kernel that runs in the global zone e.g. global operating system kernel of participating compute and physical nodes. The daemon may manage tasks run on that node. Additionally the daemon is responsible for setting up compute zones for user jobs executing the jobs monitoring the user code instruction sets generated from request parameters tearing down the zones and emitting progress updates to the appropriate job executors. This daemon is closely coupled with a lackey that runs in the compute zones and manages task execution in that zone.

Recall that users submit jobs to the system and each job is made up of one or more phases in which a user command is invoked on a single object at a time for map phases or many objects at once for reduce phases . To execute each phase the system kernel divides the work into individual map and or reduce tasks with each task representing a single execution of the user s command on one or more objects in some embodiments.

To preserve isolation where a user only has access to their objects tasks are executed inside dedicated compute zones that are reset to their initial state in between tenants. But because this reset function requires computing resources tasks are allowed to run sequentially in a single compute zone without resetting the zone as long as all such tasks belong to the same task group meaning that these tasks belong to the same job and phase.

While the tasks executed sequentially in a zone are part of one task group tasks from a single group may be run in parallel task streams where each stream executed in its own zone. Since some tasks in a group may take longer than others to execute in order to maximize concurrency within each group a task may not be assigned to a particular stream until the corresponding zone is actually ready to execute the task.

Generally task groups may be referred to as jobs. Tasks in different jobs cannot be executed in the same zone without resetting the zone between them in some embodiments. Rather different phases of the same job may be treated by the system as separate jobs relative to executing zone resets. With regard to task scheduling the system may implement a scheduling algorithm for scheduling tasks on compute zones is driven by several principles.

First the system may be optimized to allow the system kernel to do as much of the scheduling duties as possible. The system kernel is good at scheduling heavy workloads on finite resources and deals well with CPU saturation. This principle illuminates the advantages of configuring systems with as many zones as possible to make sure the system kernel has plenty of work with which to make best use of the CPUs.

According to some embodiments the system kernel should be responsive to incoming jobs even when the system kernel is already very busy. To accomplish this the system kernel may establish a threshold of reserve zones that are available only to newly arriving task groups. From an implementation perspective when the number of available zones drops below the reserve threshold existing task groups cannot grow to use the remaining zones. Thus only newly created task groups can use the remaining zones and each new group can only use one zone. This policy allows newly submitted jobs small or large to get initial results quickly even when large jobs are occupying most of the CPU resources of the system .

The system kernel may be configured to ensure that all task groups should share the non reserved zones in a fair manner. For example if there is only one task group the system kernel should allow that task group to run on all non reserved zones. If there are two task groups of equal size see below these task groups should each get half of the non reserved zones.

The share of zones of a task group is determined by the system kernel by evaluating the number of tasks ready to run in that group divided by the total number of tasks ready to run in the system. Advantageously the share cannot be less than one zone. It will be understood that because the system kernel uses a fair task division instead of counting each task group the system kernel may avoid having users break up large jobs into multiple smaller ones just to get more concurrency. Other types of fairness policies may be implemented by the system kernel . For example the system kernel may establish priorities for users such that certain users may be given higher priority and preferred task prioritization and access compared to other users of lower priority.

As an example if a system with 512 non reserved zones has one task group with 50 tasks ready to run and another task group with 150 tasks ready to run then the first group gets zones and the second group gets in some embodiments.

It is noteworthy that setting up a zone for a particular task group is relatively cheap in terms of computing resource consumption and that running additional sequential tasks from the same group in the same zone is free but that resetting a zone for use by a different group may be relatively more expensive from a workload perspective. As a result when there is a tie for the number of shares the system kernel keeps a zone running for a task group that is already running. For example if a 512 zone box is saturated with task groups where each task is scheduled on one zone and another task group arrives the arriving task group will be queued by the system kernel until one of the other task groups completes since the task groups all have the same number of shares.

Maximizing utilization and sharing resources fairly. On an idle system a large task group arrives to process thousands of objects. This group is scheduled on all of the non reserve zones. When a second large task group arrives the system kernel gradually switches half of the zones to processing the new task group. When a third large group arrives each of the three groups is scheduled by the system kernel onto one third of the available zones.

Maintaining responsiveness for incoming small jobs. On an idle system a large task group arrives to process thousands of objects. As described in Example 1 this group will be scheduled onto all of the system s non reserve zones. When a small group arrives to process a single task it immediately gets scheduled onto one of the reserve zones by the system kernel . Additional tasks for the same group may be scheduled by the system kernel on the same zone. If the number of tasks grows large its growing share causes it to be scheduled on some of the zones previously used for the first group as described in Example 1.

A saturated system. Assume that a system is saturated with as many task groups as there are available zones including reserves. Each task group is thus scheduled onto exactly one zone. As additional task groups arrive they will be unable to run until one of the existing task groups completes.

A pathological job. On an idle system a large task group arrives whose execution goes into an infinite loop. All non reserve zones are occupied in this loop. As new small groups arrive these new groups are allowed to run immediately in a reserve zone see Example 2 . But if one of these groups becomes large this large group is not immediately allowed by the system kernel to get its expected half of the zones since most of the zones are still occupied in the loop. Eventually the system kernel decides that the first job s desired concurrency has exceeded its actual concurrency by too much for too long and the system kernel begins terminating these tasks allowing the second large job to take some of the zones.

With all this in mind the actual scheduling algorithm implemented by the system kernel may begin when a new task arrives. If the task does not belong to any existing task group and there is a zone available to run the task reserve or not then the task is scheduled on that zone. If there are no zones available then the newly created task group is en queued in first in first out FIFO order on a ready to run queue. If the task belongs to an existing task group and the system has at least nreserve 1 zones available then the task is scheduled on any available zone. Otherwise the task is en queued in its task group. The fact that nreserve zones are off limits to existing task groups ensures responsiveness for new task groups and the fact that the expansion is otherwise unbounded ensures that jobs can expand to use all of the non reserve resources.

The system kernel may also manage termination of zones such as when a zone finishes executing a task. If the zone is the only zone executing tasks for the given task group then the zone picks up the next task in the same task group. This pickup feature of the zone results from system principles that specify that all groups are entitled to at least one zone. Moreover it is undesirable to reset a zone for a different group when the system kernel will be required to reset the zone again to finish the group which is currently being executing. Otherwise if there are any task groups on the ready to run queue the zone resets and picks up the task group which has been waiting the longest.

By proportion the waiting task group has a delta between desired concurrency at least one and actual concurrency zero for a percentage delta of infinity that exceeds that of the current zone. Otherwise all task groups must already be scheduled on at least one zone but the distribution may not match the desired concurrency levels for each task group. First the system kernel computes whether a group would be above or below its desired concurrency if the current zone is assigned to a different group. If the system kernel determines that the group is not above or below the zone picks up the next task in the same task group. Otherwise the zone resets and switches to the task group with the biggest delta between actual and desired concurrency. The system kernel executes this analysis by iterating all the task groups.

With regard to user authentication within the system it will be understood that the daemon may communicate with containers within a zone to manage an assigned compute task. The container s forward output to the daemon . It is noteworthy that the daemon may maintain a separate http server for each or at least a plurality of compute zones. Advantageously the daemon also tracks requests and the socket on which the request was received. The daemon also tracks the compute zone associated with the request as well as tasks associated with the compute zone. Furthermore the daemon may track which tasks are assigned to a particular zone.

Because the user is linked to the task via the input key the daemon may leverage this chain of linkages between users tasks and zones and automatically authenticate the user. That is the user may not be required to input authentication credentials to submit sequential tasks to a zone if the zone is already running. In sum the user is authenticated to submit any request within the compute zone.

Additionally the method may include a step of assigning virtual operating system containers from any of a reserve zone pool and a non reserve pool zone to a plurality of task groups in a proportional manner.

After assignment of virtual operating system containers the method may include a step of establishing an expected concurrency rate for each or at least a plurality of the task groups. The expected concurrency rate may include a desired concurrency rate that is specified by the user or may be determined from an analysis of the requirements of a user over a period of time e.g. historical context .

The method may then include a step of comparing an actual concurrency rate for each or at least a plurality of the task groups to their expected concurrency rate. That is the system monitors the concurrency rates of the task groups and compares them to their expected values. The comparison may be executed by calculating a concurrency delta which is an expected versus actual metric.

The method may include a step of reassigning virtual operating system containers to a task group based upon the step of comparing. Assignment may occur based upon the concurrency delta where task groups that have large concurrency deltas are preferred for assignment relative to task groups with smaller concurrency deltas.

The step of assigning may also include evaluating the tasks in the task group relative to a total number of tasks for the system. A task group may be assigned virtual operating system containers from either the reserve and or non reserve zone pools based upon the this type of evaluation. By way of example a task group that currently includes a large number of tasks may be assigned a larger number of zones relative to a task group with fewer tasks.

The components shown in are depicted as being connected via a single bus . The components may be connected through one or more data transport means. Processor unit and main memory may be connected via a local microprocessor bus and the mass storage device peripheral device s portable storage device and display system may be connected via one or more input output I O buses.

Mass storage device which may be implemented with a magnetic disk drive or an optical disk drive is a non volatile storage device for storing data and instructions for use by processor unit . Mass storage device may store the system software for implementing embodiments of the present technology for purposes of loading that software into main memory .

Portable storage device operates in conjunction with a portable non volatile storage medium such as a floppy disk compact disk digital video disc or USB storage device to input and output data and code to and from the computer system of . The system software for implementing embodiments of the present technology may be stored on such a portable medium and input to the computer system via the portable storage device .

User input devices provide a portion of a user interface. User input devices may include an alphanumeric keypad such as a keyboard for inputting alpha numeric and other information or a pointing device such as a mouse a trackball stylus or cursor direction keys. Additional user input devices may comprise but are not limited to devices such as speech recognition systems facial recognition systems motion based input systems gesture based systems and so forth. For example user input devices may include a touchscreen. Additionally the system as shown in includes output devices . Suitable output devices include speakers printers network interfaces and monitors.

Display system may include a liquid crystal display LCD or other suitable display device. Display system receives textual and graphical information and processes the information for output to the display device.

Peripherals device s may include any type of computer support device to add additional functionality to the computer system. Peripheral device s may include a modem or a router.

The components provided in the computer system of are those typically found in computer systems that may be suitable for use with embodiments of the present technology and are intended to represent a broad category of such computer components that are well known in the art. Thus the computer system of may be a personal computer hand held computing system telephone mobile computing system workstation server minicomputer mainframe computer or any other computing system. The computer may also include different bus configurations networked platforms multi processor platforms etc. Various operating systems may be used including Unix Linux Windows Mac OS Palm OS Android iOS known as iPhone OS before June 2010 QNX and other suitable operating systems.

It is noteworthy that any hardware platform suitable for performing the processing described herein is suitable for use with the systems and methods provided herein. Computer readable storage media refer to any medium or media that participate in providing instructions to a central processing unit CPU a processor a microcontroller or the like. Such media may take forms including but not limited to non volatile and volatile media such as optical or magnetic disks and dynamic memory respectively. Common forms of computer readable storage media include a floppy disk a flexible disk a hard disk magnetic tape any other magnetic storage medium a CD ROM disk digital video disk DVD any other optical storage medium RAM PROM EPROM a FLASHEPROM any other memory chip or cartridge.

Computer program code for carrying out operations for aspects of the present technology may be written in any combination of one or more programming languages including an object oriented programming language such as Java Smalltalk C or the like and conventional procedural programming languages such as the C programming language or similar programming languages. The program code may execute entirely on the user s computer partly on the user s computer as a stand alone software package partly on the user s computer and partly on a remote computer or entirely on the remote computer or server. In the latter scenario the remote computer may be coupled with the user s computer through any type of network including a local area network LAN or a wide area network WAN or the connection may be made to an external computer for example through the Internet using an Internet Service Provider .

The corresponding structures materials acts and equivalents of all means or step plus function elements in the claims below are intended to include any structure material or act for performing the function in combination with other claimed elements as specifically claimed. The description of the present technology has been presented for purposes of illustration and description but is not intended to be exhaustive or limited to the present technology in the form disclosed. Many modifications and variations will be apparent to those of ordinary skill in the art without departing from the scope and spirit of the present technology. Exemplary embodiments were chosen and described in order to best explain the principles of the present technology and its practical application and to enable others of ordinary skill in the art to understand the present technology for various embodiments with various modifications as are suited to the particular use contemplated.

Aspects of the present technology are described above with reference to flowchart illustrations and or block diagrams of methods apparatus systems and computer program products according to embodiments of the present technology. It will be understood that each block of the flowchart illustrations and or block diagrams and combinations of blocks in the flowchart illustrations and or block diagrams can be implemented by computer program instructions. These computer program instructions may be provided to a processor of a general purpose computer special purpose computer or other programmable data processing apparatus to produce a machine such that the instructions which execute via the processor of the computer or other programmable data processing apparatus create means for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

These computer program instructions may also be stored in a computer readable medium that can direct a computer other programmable data processing apparatus or other devices to function in a particular manner such that the instructions stored in the computer readable medium produce an article of manufacture including instructions which implement the function act specified in the flowchart and or block diagram block or blocks.

The computer program instructions may also be loaded onto a computer other programmable data processing apparatus or other devices to cause a series of operational steps to be performed on the computer other programmable apparatus or other devices to produce a computer implemented process such that the instructions which execute on the computer or other programmable apparatus provide processes for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

The flowchart and block diagrams in the Figures illustrate the architecture functionality and operation of possible implementations of systems methods and computer program products according to various embodiments of the present technology. In this regard each block in the flowchart or block diagrams may represent a module segment or portion of code which comprises one or more executable instructions for implementing the specified logical function s . It should also be noted that in some alternative implementations the functions noted in the block may occur out of the order noted in the figures. For example two blocks shown in succession may in fact be executed substantially concurrently or the blocks may sometimes be executed in the reverse order depending upon the functionality involved. It will also be noted that each block of the block diagrams and or flowchart illustration and combinations of blocks in the block diagrams and or flowchart illustration can be implemented by special purpose hardware based systems that perform the specified functions or acts or combinations of special purpose hardware and computer instructions.

While various embodiments have been described above it should be understood that they have been presented by way of example only and not limitation. The descriptions are not intended to limit the scope of the technology to the particular forms set forth herein. Thus the breadth and scope of a preferred embodiment should not be limited by any of the above described exemplary embodiments. It should be understood that the above description is illustrative and not restrictive. To the contrary the present descriptions are intended to cover such alternatives modifications and equivalents as may be included within the spirit and scope of the technology as defined by the appended claims and otherwise appreciated by one of ordinary skill in the art. The scope of the technology should therefore be determined not with reference to the above description but instead should be determined with reference to the appended claims along with their full scope of equivalents.

