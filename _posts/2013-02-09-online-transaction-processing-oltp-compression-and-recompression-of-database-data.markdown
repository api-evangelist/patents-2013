---

title: On-line transaction processing (OLTP) compression and re-compression of database data
abstract: A computer is programmed to compress data of a database in response to database modification language (DML) statements generated by on-line transaction processing (OLTP) systems. In several embodiments, data that is initially added to a database block is left uncompressed until a predetermined condition is satisfied, which happens infrequently (relative to OLTP transactions on the block). When satisfied, the computer automatically compresses all uncompressed data in the block, which increases the amount of unused space in the block. New data is thereafter added uncompressed to the partially compressed block, until satisfaction of a predetermined condition whereby the partially compressed block is again compressed, i.e. re-compressed. Adding of new data to a partially compressed block and its compression are repeated unless another predetermined condition is met, in response to which the block is not further re-compressed, thereby to recognize a limit on the benefit from compression.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08943029&OS=08943029&RS=08943029
owner: Oracle International Corporation
number: 08943029
owner_city: Redwood Shores
owner_country: US
publication_date: 20130209
---
This application is a continuation application of U.S. application Ser. No. 11 875 642 filed on Oct. 19 2007 entitled ON LINE TRANSACTION PROCESSING OLTP COMPRESSION AND RE COMPRESSION OF DATABASE DATA by Vineet Marwah et al. that is incorporated by reference herein in its entirety.

Applicants hereby rescind any disclaimer of claim scope in the parent application namely U.S. application Ser. No. 11 875 642 or the prosecution history thereof and advise the US Patent and Trademark Office USPTO that the claims in this continuation application may be broader than any claim in the parent application. Accordingly Applicants hereby notify the USPTO of a need to re visit all prior art cited in the parent application including but not limited to prior art over which any disclaimer of claim scope was made in the parent application or the prosecution history thereof.

It is well known in the art for a computer to be programmed with a database management system DBMS that provides support for OLTP systems. OLTP systems typically require real time processing of statements that are expressed in a structured query language SQL which has been standardized by American National Standards Institute ANSI . SQL statements to access and change data may use one of the four keywords SELECT UPDATE DELETE and INSERT which together form a Data Manipulation Language DML part of SQL.

On receipt of such statements it is necessary for computer to execute the requested transaction on the database very quickly and respond back to the OLTP system with appropriate results. Examples of OLTP transactions include processing of real time sales e.g. at a cash register in a grocery store a database of inventory is updated in real time as items are scanned by the clerk. A prior art DBMS is typically implemented in computer to include a parser an optimizer a query plan generator and an execution engine not labeled see . The execution engine operates on data brought from a disk to a region in main memory which region is known as a buffer cache or simply cache.

During normal operation of DBMS data is retrieved from disk in fixed size pieces called blocks pages data blocks logical blocks etc an example of which is block . A block is the smallest unit of data that is stored into or retrieved from a database on disk . The block typically includes a header region data in region and an empty region in to which additional data can be written. Contiguous blocks that are allocated for storing a specific type of information constitute another level of data granularity and are together called an extent. A set of extents which are stored in the same table space constitute a segment in a table. For more information on storage structures used to access data in databases see Chapter 2 of the publication Oracle Database Concepts 10gRelease 2 10.2 publication B14220 02 published in October 2005.

Referring to block is an in memory copy of a block B from disk which disk holds the database managed by DBMS . Initially for a given table in the database DBMS starts with an empty block B at time t and as a number of OLTP transactions take place block B to eventually fills up as illustrated in the time sequence t t. When a new row can no longer be written to block B DBMS allocates a new block B which is then again progressively filled as shown by the time sequence t t. When block B cannot hold a new row DBMS again allocates a new block B at time t . Note that all data in blocks B B is uncompressed i.e. prior art DBMS does not support compression of blocks B B. Instead data that is received from an OLTP application is stored directly i.e. uncompressed in database .

One reason for storing database data uncompressed is that transactions for an OLTP application must be executed in real time whereas compression can delay the response. However compression for certain data warehouse transactions that are executed as batch jobs such as bulk loads into the database is supported in certain prior art DBMS systems such as ORACLE 10gR2 sold by ORACLE CORPORATION Redwood Shores Calif. Specifically stored data on disk can be compressed by reducing or eliminating duplicate values in a block of data. For example as illustrated in duplicate values Meyer 11 Homestead Rd 1.99 McGryen and 3 Main Street are replaced with references to a symbol table which holds a single copy of each duplicate value. The smallest granularity of values in a symbol table is at the level of a column. However a value in a symbol table can occur as a sequence of column values and this is called multi column compression.

One prior art method used to support bulk load operations in a relational database management system RDBMS is described in a paper by Miekel and Poess and Dmitry Potapov entitled Data Compression in Oracle published in the Proceedings of the 29VLDB Conference Berlin Germany 2003 which paper is incorporated by reference herein in its entirety as background.

One reason compression works well in bulk load operations is that all of the data to be written to a database block is immediately available within the prior art DBMS for use in computing an appropriate symbol table that is applicable to the entire block. For the same reason compression is normally not available for data management language DML statements of the type generated during on line transaction processing OLTP . Specifically due to their nature OLTP transactions within the computer may access different tables and even if the same table is accessed they may access different blocks. Accordingly only a small fraction of the data of a block may be supplied by each OLTP transaction which makes compression of such data and therefore compression of the block difficult.

A database management system in a computer is programmed in accordance with the invention to compress the data of a database table used by data modification language DML statements of the type generated by on line transaction processing OLTP systems. In several embodiments a number of rows that are initially added to an empty block of the table are left uncompressed until at least a predetermined condition is satisfied which happens infrequently relative to the frequency of OLTP transactions on the block . When at least the predetermined condition is satisfied the computer of some embodiments automatically compresses all rows in the block which increases the amount of unused space in the block. In several embodiments new rows are thereafter added into unused space in the block in response to OLTP transactions. The new rows are added uncompressed to the block and hence at this stage the block holds compressed and uncompressed rows partially compressed block .

Unused space in a partially compressed block is used to hold new rows until a predetermined condition is again satisfied whereby the partially compressed block is again compressed which process is also called re compression . Addition of uncompressed rows to a partially compressed block and that block s occasionally re compression as described in the preceding sentence are repeatedly performed unless another condition limiting condition is met in response to which the block is no longer re compressed until rows are deleted from the block to generate additional unused space .

Compressing and re compressing a block every once in a while based on predetermined condition s as described above i.e. not each time when a new row is inserted enables a database management system of several embodiments to service OLTP transactions in real time with no degradation in performance on almost all transactions except for the few infrequent occasions when the predetermined conditions are satisfied. Also in some embodiments a database block s compression or re compression is performed in a separate transaction which is different from execution of the database transaction itself to ensure that unused space generated from compression is available to other transactions and remains available even if the database transaction is rolled back.

A database management system of several embodiments of the invention benefits from data compression but without incurring a large penalty in responsiveness incurred if a block of data is decompressed and compressed during every transaction by only compressing and re compressing a block every once in a while e.g. based on one or more predetermined condition s .

Accordingly in many embodiments a computer system is programmed in accordance with the invention to compress the data of a database lazily in response to data management language DML statements that are normally received as per act in from on line transaction processing OLTP systems. Initially a database block B that is loaded into memory as per act in is empty as shown at time T . In response to several OLTP transactions that reference a table to which block B belongs data is written to block B as per act in and B is left uncompressed as shown during the time period T T see bottom of . The newly added data in block B remains uncompressed over time as more new data is added to block B until a predetermined condition is satisfied as per act in .

The predetermined condition which is used depends on the embodiment and can be different in different embodiments. In an illustrative embodiment the predetermined condition is on the amount of unused space F within block B . In a first example the predetermined condition checks if F falls below a preset minimum e.g. 2K . In a second example the predetermined condition checks if F falls below a predetermined fraction e.g. 1 10 of size of block B. In a third example the predetermined condition is independent of unused space and instead it simply checks if a number of rows U that are uncompressed in block B is greater than a preset maximum. In a fourth example the predetermined condition is independent of block B altogether and instead it simply checks if new data to be inserted is of a size that is greater than a upper limit. In a fifth example the predetermined condition checks if a commit statement has been received. In a sixth example the predetermined condition checks if F becomes less than an integral multiple of the average size of a row in block B. In the sixth example if the integral multiple is chosen to be 1 then the condition checks for F less than the average size of a row i.e. a new row is unlikely to be accommodated in block B. In the sixth example the likelihood of accommodating a new row is increased if the integral multiple is greater than 1 e.g. 2 or 3 and a specific integral multiple that is used depends on the embodiment. As will be apparent to the skilled artisan any two or more of the just described conditions may be combined to form a predetermined condition of some embodiments. Accordingly the predetermined condition can take many different forms depending on the embodiment.

The predetermined condition is appropriately selected ahead of time to ensure that for most OLTP transactions the predetermined condition is not satisfied. Accordingly the NO branch is taken from act wherein the block B is written to disk or any other storage device that is non volatile e.g. flash memory followed by returning to act described above . Occasionally which happens infrequently the predetermined condition is met in act and the YES branch is taken to an operation which compresses all the data in block B . The first time that the YES branch is taken all data within block B is uncompressed see time T in . Accordingly operation compresses all the data in block B followed by storing the block as per act to disk or other such storage device that is non volatile e.g. flash memory . Hence the block compression in operation increases the unused space in block B to F as illustrated in at time T. The just described sequence of steps from time T to T which begin with the block B being empty is also called hereinafter as initial compression .

After time T in the next several OLTP transactions for the same table the above described acts the NO branch from 213 are repeatedly performed. Hence unused space in block B is used as illustrated at time T to hold additional data uncompressed which additional data is received after the above described compression. At this stage block B holds a combination of compressed data and uncompressed data as illustrated at time T . Such a block which holds both kinds of data compressed and uncompressed is also referred to as a partially compressed block. In some embodiments block B contains metadata which identifies the compression state of the data e.g. each row has a flag which indicates whether or not that row is compressed.

Addition of uncompressed data to the partially compressed block continues between times T and T until satisfaction of the predetermined condition in act which happens at time T. Depending on the embodiment the predetermined condition re compression condition used to perform act at time T may be same as or different from an initial condition which is used to perform act for the first time at time T. At time T the partially compressed block B is again compressed re compression as per operation . Since block B is already partially compressed at this stage act is performed to decompress any compressed data in block B followed by a compression in act .

Specifically in act computer system compresses three uncompressed data from three sources A uncompressed data if any output by act B pre existing uncompressed data if any e.g. stored in block B between times T and T and C new uncompressed data resulting from a most recent OLTP transaction that has triggered the current iteration of acts i.e. immediately before the re compression condition was satisfied. After compression in act the block B is stored to disk as per act as illustrated by the block B shown in for the time T. The just described process is again repeated with the uncompressed data being added to block B at time T followed by compression as illustrated at time T followed by adding uncompressed data again to block B as illustrated at time T.

Repetition of the just described process is stopped when another condition limiting condition is satisfied. Specifically when the limiting condition on the repetition is satisfied the block B is not re compressed any more i.e. the computer system is programmed to recognize a limit on the benefit from re compression. In some embodiments the limiting condition is based on the amount of unused space generated by re compression specifically F F wherein F is the unused space after re compression and F is the unused space prior to re compression. In certain illustrative embodiments the limiting condition checks if F F falls below a predetermined percentage of the size of block B e.g. 10 or 20 or 30 depending on the embodiment.

Although a specific sequence of acts is illustrated in for some embodiments the sequence can be different in other embodiments. For example in certain embodiments the predefined condition is checked in act immediately after loading of a block from disk into memory of computer system . If the condition is met then compression operation is performed. In this example writing of data into the block is not performed until after compression operation . If the predefined condition is not met then the no branch is taken from act and uncompressed data is written directly into the block as per act . In the embodiment shown in the block is stored to disk as per act which follows the writing in act . Note that the compression act C in differs from the corresponding compression act B in in the specific data that is being compressed. Specifically act B of compresses data from three sources A C as noted above while act C of compresses data from two sources A and B .

Certain embodiments of computer system implement the invention by performing the acts illustrated in . Specifically computer system receives a SQL statement from an OLTP system in an act . The SQL statement includes DML operators such as INSERT UPDATE DELETE and ARRAY INSERT. Next in act the computer system loads into memory one or more database blocks that hold data of a table identified in the SQL statement. Next in act the computer system checks if a current block for the given table has any unused space to hold uncompressed data that is generated by executing the SQL statement received in act .

If the answer is yes in act the computer system checks as per act if the writing of uncompressed data into the block B will cause the unused space in block B to fall below a threshold. If so the computer simply sets a flag as per act and then goes to act to write the uncompressed data into the block. If the answer is no in act the computer directly goes to act without setting any flags. If the answer is no in act computer system allocates a new database block or gets an existing block as per act and thereafter uses that block to write uncompressed data therein.

After act computer system goes to act to see if the flag is set which was to have been set in act . If flat is not set then a compression or re compression is not required and hence computer system proceeds to act which is implemented same as act described above in reference to . Thereafter computer system returns to act described above . If the flag is set then compression operation A is performed as follows. The computer system makes a copy of the block B which is to be compressed in an act . Next in act any compressed data in block B is retrieved and decompressed followed by compression in act . As noted above the act compresses not only uncompressed data but also decompressed data and new data. Next in act the computer system checks if free space in block B is sufficient and if so goes to act to update metadata for block B e.g. by computing a symbol table and or calculating a check sum. In act if the free space in block B is not sufficient i.e. unused space is less than the threshold then computer system proceeds to act . In act the computer system restores the block based on a copy that was saved in act . After act the computer system proceeds to act discussed above .

Although a specific sequence of acts is illustrated in for some embodiments the sequence can be different in other embodiments. For example in certain embodiments acts and related to the flag are not performed as illustrated in . Specifically after act in a compression operation B is performed. Operation B is similar to operation A described above in reference to except for the order in which these two operations are performed relative to act for writing uncompressed data into the block. Specifically act of is performed prior to operation A whereas act of is performed subsequent to corresponding operation B. Accordingly as will be apparent to the skilled artisan in view of this disclosure illustrate details for implementing the corresponding embodiments shown in .

In some embodiments a pre existing database management system DBMS that implements bulk loading for data warehousing systems is modified to provide OLTP support in the above described manner in a programmed computer . Hence a compression and decompression module is used by an execution engine to perform database data compression in a single table against which both types of transactions are executed by DBMS i.e. OLTP transactions as well as OLAP transactions as illustrated in . Specifically DBMS of some embodiments uses pre existing functionality that is already built into compression and decompression module originally used for bulk operations by modifying them e.g. by placing wrapper function s around one or more preexisting software functions in module to assist in additional acts that implement OLTP data compression.

Specifically in one illustrative embodiment shown in DBMS in a programmed computer system performs pre existing bulk loading inserting method consisting of acts which are modified to perform a method which includes additional acts and for OLTP data compression. Note that the just described acts are similar or identical to the corresponding acts described above in reference to and many of the reference numerals in are obtained by adding to the corresponding reference numerals in except for act . As is seen in after the decompression in act control is transferred via an application programming interface API to a module that performs compression in operation . On being called by method module compresses the data in the block to which data was written in act by method . After compression is completed in act method returns control back to method specifically to act . In act method writes the symbol table into the block and also writes the compressed data into the block. Then method performs act which is similar or identical to corresponding act described above in reference to .

Note that although a specific sequence of acts is illustrated in for some embodiments the sequence can be different in other embodiments. For example certain embodiments perform the methods of which illustrates implementation of the corresponding methods shown in .

The compression that is performed by act of some embodiments uses one of two techniques namely recursive compression and in line compression. Specifically in recursive compression when executing a DML statement within a current transaction if compression is to be performed a new transaction is started to do the compression compression transaction . When the compression transaction completes it commits its work and returns control back to the current transaction which then proceeds to execute one or more DML operators in the normal manner. Hence any unused space that is generated by compression transaction becomes available in the current block regardless of whether or not the current transaction completes successfully or is rolled back. On the other hand another technique namely in line compression is performed within a current transaction itself and so any unused space that is generated depends on whether and when the current transaction commits. So if the current transaction is rolled back any unused space generated by in line compression is not available.

Recursive transaction is performed if the following conditions are satisfied A there is no active transaction in the block to be compressed or re compressed i.e. no transaction including the current transaction is modifying the block and B the current transaction is able to place a lock on the block as a whole. If either of A or B cannot be met then compression is not performed on the block at this stage i.e. the block will be compressed at some point in future whenever the predetermined condition is met again . An in line compression can be performed if only the current transaction is active in the current block. So in line compression can be used even after the current transaction has started working on the current block so long as no other transaction is active in the current block.

Computer system may be implemented in some embodiments by use of a computer e.g. an IBM PC or workstation e.g. Sun Ultra 20 that is programmed with a database management system Oracle 11gR1 available from Oracle Corporation of Redwood Shores Calif. Such a computer can be implemented by use of hardware that forms a computer system as illustrated in . Specifically computer system includes a bus or other communication mechanism for communicating information and a processor coupled with bus for processing information.

Computer system also includes a main memory such as a random access memory RAM or other dynamic storage device coupled to bus for storing information and instructions to be executed by processor . Main memory also may be used for storing temporary variables or other intermediate information during execution of instructions to be executed by processor . Computer system further includes a read only memory ROM or other static storage device coupled to bus for storing static information and instructions for processor . A storage device such as a magnetic disk or optical disk is provided and coupled to bus for storing information and instructions.

Computer system may be coupled via bus to a display such as a cathode ray tube CRT for displaying information to a computer user. An input device including alphanumeric and other keys is coupled to bus for communicating information and command selections to processor . Another type of user input device is cursor control such as a mouse a trackball or cursor direction keys for communicating direction information and command selections to processor and for controlling cursor movement on display . This input device typically has two degrees of freedom in two axes a first axis e.g. x and a second axis e.g. y that allows the device to specify positions in a plane.

As described elsewhere herein incrementing of multi session counters shared compilation for multiple sessions and execution of compiled code from shared memory are performed by computer system in response to processor executing instructions programmed to perform the above described acts and contained in main memory . Such instructions may be read into main memory from another computer readable medium such as storage device . Execution of instructions contained in main memory causes processor to perform the process steps described herein. In alternative embodiments hard wired circuitry may be used in place of or in combination with software instructions to implement an embodiment of the type illustrated in . Thus embodiments of the invention are not limited to any specific combination of hardware circuitry and software.

The term computer readable medium as used herein refers to any non transitory medium that participates in providing instructions to processor for execution. Such a non transitory medium may take many forms including but not limited to non transitory storage media which may be non volatile media or volatile media . Non volatile media includes for example optical or magnetic disks such as storage device . Volatile media includes dynamic memory such as main memory .

Transmission media includes coaxial cables copper wire and fiber optics including the wires that comprise bus . Transmission media can also take the form of acoustic or light waves such as those generated during radio wave and infra red data communications.

Common forms of non transitory computer readable storage media include for example a floppy disk a flexible disk hard disk magnetic tape or any other magnetic medium a CD ROM any other non transitory optical medium punch cards paper tape any other non transitory physical medium with patterns of holes a RAM a PROM and EPROM a FLASH EPROM any other memory chip or cartridge as described hereinafter or any other non transitory storage medium from which a computer can read.

Various forms of non transitory computer readable media may be involved in carrying the above described instructions to processor to implement an embodiment of the type illustrated in . For example such instructions may initially be carried on a magnetic disk of a remote computer. The remote computer can load such instructions into its dynamic memory and send the instructions over a telephone line using a modem. A modem local to computer system can receive such instructions on the telephone line and use an infra red transmitter to convert the received instructions to an infra red signal. An infra red detector can receive the instructions carried in the infra red signal and appropriate circuitry can place the instructions on bus . Bus carries the instructions to main memory in which processor executes the instructions contained therein. The instructions held in main memory may repair optionally be stored on storage device either before or after execution by processor .

Computer system also includes a communication interface coupled to bus . Communication interface provides a two way data communication coupling to a network link that is connected to a local network . Local network may interconnect multiple computers as described above . For example communication interface may be an integrated services digital network ISDN card or a modem to provide a data communication connection to a corresponding type of telephone line. As another example communication interface may be a local area network LAN card to provide a data communication connection to a compatible LAN. Wireless links may also be implemented. In any such implementation communication interface sends and receives electrical electromagnetic or optical signals that carry digital data streams representing various types of information.

Network link typically provides data communication through one or more networks to other data devices. For example network link may provide a connection through local network to a host computer or to data equipment operated by an Internet Service Provider ISP . ISP in turn provides data communication services through the world wide packet data communication network now commonly referred to as the Internet . Local network and network both use electrical electromagnetic or optical signals that carry digital data streams. The signals through the various networks and the signals on network link and through communication interface which carry the digital data to and from computer system are exemplary forms of carrier waves transporting the information.

Computer system can send messages and receive data including program code through the network s network link and communication interface . In the Internet example a server might transmit a code bundle through Internet ISP local network and communication interface . In accordance with the invention one such downloaded set of instructions implements an embodiment of the type illustrated in . The received set of instructions may be executed by processor as received and or stored in storage device or other non volatile storage for later execution. In this manner computer system may obtain the instructions in the form of a carrier wave.

Numerous modifications and adaptations of the embodiments described herein will be apparent to the skilled artisan in view of the disclosure.

For example although several embodiments have been described in reference to a block as a unit of storage of a database other embodiments use other storage structures. Specifically in some embodiments methods of the type described herein and illustrated in are used with a segment as a unit of storage wherein the segment includes a number of pages of fixed size. Such embodiments may use for example a symbol table for the segment as a whole whereby references within all pages of the segment point to symbols in the segment level symbol table. In certain embodiments each database table is allocated a single segment and accordingly the symbol table is common to the database table as a whole unless the database table is partitioned into partitions in which case there is one symbol table for each extent .

