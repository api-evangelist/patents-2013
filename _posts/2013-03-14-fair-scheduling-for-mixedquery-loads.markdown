---

title: Fair scheduling for mixed-query loads
abstract: A fair scheduling system with methodology for fairly scheduling queries for execution by a database management system is disclosed. The techniques involve obtaining computer-executable query jobs and cost estimates to execute the query jobs. For example, the cost estimate can be a number of results the query is expected to return. Based on the cost estimates, the fair scheduling system causes the database management system to execute the query jobs as separately executable sub-query tasks in a round-robin fashion which can decrease latency of low cost queries concurrently executing with high cost queries.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09092482&OS=09092482&RS=09092482
owner: Palantir Technologies, Inc.
number: 09092482
owner_city: Palo Alto
owner_country: US
publication_date: 20130314
---
The present disclosure relates generally to scheduling computer executable tasks for execution by computing devices and more specifically to techniques for scheduling queries for execution by database management systems.

Many database management systems are available to help users manage data. One way such systems help users is to answer questions the users have about the data. In the context of database management systems questions are typically referred to as queries and answers typically referred to as results . Users submit queries to database management systems and receive answers to the queries in the form of results.

To answer queries database management systems use computing resources such as memory and processor resources. Different queries require different amounts of computing resources to answer. For example a query that returns 50 000 results may consume more computing resources than one that returns 10 results.

Many database management systems have the ability to execute multiple queries at the same time i.e. concurrently . The process performed by a database management system of determining the results of a query is often referred to as executing the query. Multiple queries executed concurrently by a database management system can contend with each other for use of the same computing resources. Many database management systems perform synchronization and scheduling functions for the purpose of sharing computing resources amongst multiple concurrent query executions.

Unfortunately despite these synchronization and scheduling efforts problems can arise when database management systems execute multiple queries concurrently where some of the queries are high cost queries and others are low cost queries. With this type of mixed query load execution of the high cost queries can require use of so many computing resources that they starve low cost queries of computing resources. The result may be that the database management systems take a long amount of time to return answers to the low cost queries. Overall some database management systems handle mixed query loads in such a way that latency of the low cost queries and the throughput of the query load are longer than users expect them to be.

The approaches described in this section are approaches that could be pursued but not necessarily approaches that have been previously conceived or pursued. Therefore unless otherwise indicated it should not be assumed that any of the approaches described in this section qualify as prior art merely by virtue of their inclusion in this section.

A fair scheduling system with methodology for scheduling queries for execution by a database management system is described. In one embodiment for example a method is described for scheduling a query job for execution by a database management system as separately executable sub query tasks. Each sub query task can have a lower execution cost than the execution cost of the query job as a whole. Further each sub query task can have the same or approximately the same execution cost. The method may be performed multiply or concurrently for multiple query jobs.

The method includes obtaining the query job and a cost estimate to execute the job. As an example the cost estimate may be a number of results the query job is expected to return.

The method further includes dividing the query job into a plurality of sub query tasks based on the cost estimate exceeding a predetermined threshold cost.

The method further includes enqueing a query job item representing the query job onto the end tail of a job execution queue. When the query job item is enqueued the job execution queue can contain other previously enqueued query job items corresponding to previously obtained query jobs.

After the query job item reaches the front head of the job execution queue which in typical operation does not occur until all previously enqueued query job items have been dequeued from the front of the job execution queue the method further includes dequeing the query job item from the front of the job execution queue.

After dequeing the query job item the method initiates execution of the first sub query task of the query job by the database management system. After causing the database management system to begin executing the first sub query task of the query job the method determines whether there are more sub query tasks of the query job to execute. If there are more sub query tasks to execute then the method again enqueues the query job item onto the end of the job execution queue. The dequeing of the query job item from the front of the job execution queue initiating execution of the next sub query task of the query job and enqueing the query job item back onto the end of the job execution queue can be repeated until execution of all of the sub query tasks of the query job have been initiated.

If after dequeing a query job item from the front of the job execution queue and initiating execution of the last sub query task there are no more sub query tasks to execute then the query job item is not enqueued again onto the end of the job execution queue.

In some embodiments the method enforces a maximum number of query job items that can be enqueued onto the job execution at the same time. In particular a query job item for a newly obtained query job is not enqueued onto the end of the job execution queue if the number of query job items already in the job execution queue is at the maximum number. The query job item is enqueued onto the job execution after an existing query job item is dequeued and the method determines that there are no more sub query tasks to execute for the query job corresponding to the dequeued query job item. Since multiple query jobs can be obtained when the number of query job items already in the job execution queue is at the maximum number a separate queue can be maintained to hold query job items for query jobs that are waiting to be added to job execution queue. Enforcing the maximum number of query job items that can be enqueued onto the job execution at the same time effectively limits the number of sub query tasks concurrently executed by the database management system and can avoid negatively affecting throughput of query loads with a large number of high cost queries.

Further features of various embodiments of the invention its nature and various advantages will be more apparent from the accompanying drawings and the following detailed description.

In the following description for the purposes of explanation numerous specific details are set forth in order to provide a thorough understanding of the present invention. It will be apparent however that the present invention may be practiced without these specific details. In other instances well known structures and devices are shown in block diagram form in order to avoid unnecessarily obscuring the present invention.

Techniques are provided for fairly scheduling queries for execution by database management systems. In one embodiment the techniques involve obtaining a computer executable job and a cost estimate to execute the job. For example the computer executable job can be a query and the cost estimate can be a number of results the query is expected to return.

Based on the cost estimate exceeding a threshold cost the job is divided into a sequence of computer executable tasks. For example if the query is expected to return 50 000 results and the threshold cost is 1 000 results the query can be divided evenly into 50 sub query tasks each of which returns 1 000 results. The techniques further involve enqueing a job item representing the job onto the end of a job execution queue. Other previously obtained jobs can be similarly divided and job items representing those other jobs similarly previously enqueued onto the end of the job execution queue.

After the job item for the job has reached the front of the job execution queue the job item is dequeued from the front of the job execution queue. After dequeing the job item the techniques further involve causing execution of the first task of the job to be initiated by a database management system. After initiating execution of the first task a determination is made whether there are more tasks of the job to execute. If there are more tasks of the job to execute the job item for the job is re enqueued onto the end of the job execution queue. If there are no more tasks of the job to execute then the job item is not re enqueued. The dequeing initiating execution of the next task of the job and re enqueing of the job item repeats until all tasks of the job have completed or the job is cancelled. The dequeing initiating execution of the next task and re enqueing can be similarly repeated for all job items in the job execution queue.

According to one aspect the techniques involving dividing a query job into multiple sub query tasks where each sub query task when executed returns a page of the results that the query job would return if executed as a single task. For example a query job that is expected to return 50 000 results can be divided into 50 sub query tasks where the first sub query task returns the first 1 000 results of the 50 000 results the second sub query task returns the next 1 000 results of the 50 000 results etc. to the fiftieth sub query task of that returns the last 1 000 results of the 50 000 results.

Clients can be any set of one or more computing devices that submit query job requests to fair scheduler . Examples of clients include but are not limited to personal computing devices desktop computing devices workstation computing devices server computing devices mobile phones tablets laptops or any other phone or general purpose computing device that is executing software for submitting query job requests to fair scheduler . Clients also may comprise processes or programs.

Clients can be operated by users in which case the users can command clients to submit query job requests to fair scheduler . Such commands can be caused by user interactions with graphical user interfaces or command line interfaces for example. Alternatively clients can operate unattended . In this case an automated process executing on clients can submit query job requests to fair scheduler . In addition some clients can be operated by users and other clients can operate unattended. Thus a mix of user operated and unattended clients is possible. In some usage scenarios multiple clients submit multiple query job requests to the fair scheduler at or about the same time.

Fair scheduler can be any set of one or more computing devices configured to perform any of the fair scheduling techniques described herein. Examples of fair scheduler include but are not limited to personal computing devices desktop computing devices workstation computing devices server computing devices or any other general purpose computing device that is executing software for performing any of the fair scheduling techniques described herein.

Database management system can be any set of one or more computing devices used to execute queries against database . Examples of database management system include but are not limited to personal computing devices desktop computing devices workstation computing devices server computing devices or any other general purpose computing device that is executing database management software. The database management software can be any database management software capable of supporting any of the fair scheduling techniques disclosed herein. In one exemplary non limiting embodiment the database management software is a version of Apache Cassandra. In another exemplary non limiting embodiment the database management software is a version of Apache HBase.

Database can be any set of one or more computing devices used to store data against which the database management system executes queries. Examples of database include but are not limited to personal computing devices desktop computing devices workstation computing devices server computing devices or any other general purpose computing device that is storing database data managed by database management system .

In some embodiments such as the embodiment of the clients fair scheduler database management system and database are each separate sets of computing devices. In other embodiments one or more of clients fair scheduler database management system and database are the same set of computing devices in other embodiments. For example client fair scheduler database management system and database can be the same computing device. Where more than one of clients fair scheduler database management system and database are the same set of computing devices software components executing on the computing devices can execute as part of the same process or the same set of processes or in different processes or different sets of processes. For example where the fair scheduler and the database management system are the same set of computing devices software components for performing fair scheduling techniques described herein and software components for executing queries against database can execute as part of the same Java Virtual Machine JVM process or set of processes.

If executing in separate processes or separate sets of processes software components of clients fair scheduler and database management system can communicate with each other using any suitable inter process communications mechanism including but not limited to networking communications protocols such as for example Transmission Control Protocol Internet Protocol TCP IP . If executing in the same process the software components can communicate with each other through one or more Application Programming Interfaces APIs .

In an embodiment clients submit query job requests to the fair scheduler . A query job request can contain values for query parameters and can contain a query execution cost estimate among other information. As discussed in greater detail below the fair scheduler can use the query parameter values and the cost estimate in the query job request when causing sub query tasks of query job to be executed by the database management system .

The query parameters can vary between different query jobs according to the requirements of the implementation at hand. One non limiting example of a query job is get the group of columns contained by a specified column family for a specified row of the column family that satisfy a specified column name range predicate. An example of such a query job expressed according a version of the Apache Cassandra Thrift API is 

In the above example query job there are six query parameters key column family start column name end column name reverse and count. Other query jobs may have more or less query parameters or different query parameters. In the above example query job values for one or more of the six query parameters can be specified in a query job request. Values for any other query parameters that are not specified in the query job request can be provided by the fair scheduler. For example a query job request can specify a value for the key parameter and a value for the start column name parameter and the fair scheduler can provide values for the column family end column name reverse and count query parameters as just one example.

In the above example query job the value of the key query parameter uniquely identifies a row in the column family specified by the value of the column family parameter. The columns of that row of that column family can be ordered by column name. The value of the reverse parameter is a Boolean value. If the value of the reverse parameter is false then the column name range predicate of the above example query job restricts results to columns having a column name that is greater than or equal to the value of start column name parameter and less than or equal to the value of the end column name parameter. If the value of the reverse parameter is true then the column name range predicate restricts results to columns having a column name that is less than or equal to the value of start column name parameter and greater than or equal to the value of the end column name parameter. The value of the count parameter limits the number results to the specified number of the columns that satisfy the column name range predicate.

For the purpose of providing clear examples embodiments of the fair scheduling techniques of the present disclosure are described hereinafter with respect to an example query job request. However the techniques are not limited to the example query job request.

The example query job request follows an example use case in which network access information is stored in a column family of the database by network address of the accessing network device and the time of the network access.

A possible data model of a database for storing the network access information is illustrated in . The data model includes a column family . The column family contains one or more rows. Each row can be keyed by a unique key. For example key can uniquely identify the first row of column family . Each row can contain a set of zero or more ordered columns. Each column can have a name and a value. Within a row each column name can be unique. The columns of a row can be ordered by column name according to an ordering scheme. Example ordering schemes include ASCII UTF 8 Long UUID lexical or time date a combination two or more of the foregoing ordering schemes and other ordering schemes. Different rows can have different numbers of columns. For example one row can have only one column and another row can have a billion or more columns. Different column values may have different sizes. For example one column value can be just a few bytes in size while another column value can be 1 gigabyte or more in size.

For the use case of storing network access information each key of the column family can be a network address. For example key may be an Internet Protocol IP address such as 192.168.0.10 . The columns in a row of the column family can store information about network access involving the network address identified by the key of the row. For example each column of the row can correspond to a single network access event involving the network address. For example the name of the column within a row can be a unique timestamp value unique for a column name within the row representing the date and time of the network access event and the value of the column can be information about the network access event such as information collected from network access logs e mail messages call data records etc.

In a variation of on the example use case each column of a row can correspond to multiple network access events involving the network address. For example the name of the column within the row can be a unique timestamp value unique for a column name within the row representing a range of time during which one or more network access events involving the network address occurred. The name of the column can correspond to the starting time of the range. Recalling that columns of a row can be stored in ascending order by column name the ending time of the range can be determined from the name of the next column in the row. The value of the column can include one or more sub values. The value can be variable length encoded or otherwise encoded or compressed. Each sub value can correspond to a single network access event involving the network address. A sub value corresponding to a network access event can have three parts 

Different query job requests can request different numbers of results. For example with the example use cases the number of results returned can depend on the range of time specified in the query job requests. For example one query job request can request network access information involving a specified network address for a range of time that spans days weeks or months while another query job request can request network access information for a range of time that spans minutes. The query job request for the larger span of time can return tens of thousands of results or more while the query job request for the smaller span of time can return only ten results of less. If the larger query job is executed by the database management system concurrently with the smaller query job the latency of the smaller query job can be negatively affected by the concurrent execution of the larger query job.

As mentioned above a query job request from a client can include a cost estimate for the database management system to execute the query job. For example the query job request can specify the number of results the query job is expected to return. For example for the above example query job involving network access information a query job request can specify a number of columns that the query job is expected to return.

Alternatively a query job request may not specify a query job cost estimate. In this case the fair scheduler may generate a query cost estimate. Such estimate may be generated in a number of different ways and the fair scheduler is not limited to any particular way of generating a query cost estimate. For example the fair scheduler may generate a query cost estimate based on query parameters values specified in the query job request. For example the fair scheduler may ask the database management system for a cost estimate providing the query parameter values for use by the database management system in generated the cost estimate. The database management system may not completely execute the query job when generating the estimate. The fair scheduler may generate a query cost estimate in other ways and embodiments are not limited to any particular way of generating a query cost estimate.

As yet another alternative a final query cost estimate may be generated based on a combination of a query cost estimate provided in a query job request and an preliminary query cost estimate generated by the fair scheduler . The preliminary cost estimate may be generated according to the approach in the previous paragraph for example. For example the fair scheduler may generate the final query cost estimate based on a mathematical combination of the query cost estimate in the query job request and the preliminary query cost estimate generated by the fair scheduler. This alternative can be performed by the fair scheduler to reduce cost estimation errors relative the above approaches where only one of the query job request or the fair scheduler provides the cost estimate.

As indicated above the query cost estimate for a query job is used by the fair scheduler to determine whether the query job should be broken down into separately executable sub query tasks. This determination can be made by comparing the query cost estimate to a threshold cost. If the query cost estimate exceeds the threshold cost then the fair scheduler can cause the query job to be executed by the database management system as multiple sub query tasks. If the query cost estimate is lower than the threshold cost then the query job can be executed as a single query task.

The threshold cost can be predefined. For example a query job with a cost estimate above 1 000 results can be broken up into multiple separately executable sub query tasks. In this case if the cost estimate is at or below 1 000 the query job can be executed as a single task.

The threshold cost can be determined based on query execution metrics collected for previously executed query jobs. Such metrics can include measured executions latencies of the previously executed query jobs. Execution latency for a query job can be measured for example as the time between 

Query execution metrics collected for previously executed query jobs can also include measured execution throughput. Measured execution throughput can be measured for example as the number of query jobs that start and finish execution within a certain period of time.

Collected query execution metrics can be used by the fair scheduler to adjust the threshold cost on an ongoing basis.

As mentioned above the fair scheduler can divide the query job into multiple sub query tasks if the cost estimate for the query exceeds the threshold cost. In one approach the fair scheduler divides the query job evenly based on the cost estimate and the current threshold cost. For example if the cost estimate for a query job is 100 000 results and the current threshold cost is 1 000 results the fair scheduler can divide the query job into 100 sub query tasks each expected to return 1 000 results. By dividing each query job of a mixed query load evenly or approximately evenly as separately executable sub query tasks that are executed in a round robin fashion through the job execution queue the high cost query jobs of the mixed load are executed fairly with the low cost query jobs of the mixed load thereby preventing the high cost query jobs from starving the low cost query jobs for computing resources of the database management system.

In other approaches query jobs are divided unevenly. For example a query job that exceeds the threshold cost can be divided into multiple sub query tasks where each successive sub query task is expected to return fewer and fewer results or alternatively more and more results .

The fair scheduler can divide a query job into multiple sub query tasks by using a result limiter for each of the sub query tasks. The result limiter limits the number of results that the sub query task returns when executed by the database management system . For example the count query parameter can be used in the following sub query task to limit the number of results returned when the sub query task executed by the database management system to at most the specified number of results.

If a sub query task when executed actually returns the number of results specified as the result limiter then the fair scheduler can determine that more results of the query job are available. In this case the fair scheduler can configure the next sub query task to get the next set of results based on the last result returned by the previous sub query task. For example given a threshold cost of 1 000 results and a query job request with a cost estimate of 10 000 results the fair scheduler can cause the database management system to execute the following sub query task to obtain the first 1 000 results 

In the above example sub query task the value for the end sub parameter indicates to the database management system that at most 1000 columns should be returned from the row keyed by the value for the key parameter starting with the column in the row having the name matching the value of the start column name parameter. If less than 1000 columns are returned by this sub query task then the query job is finished and no more sub query tasks need be executed for the query job. If this is the case the query estimate of 10 000 columns was inaccurate by an order of magnitude. If as expected 1 000 columns are returned by this sub query tasks then the next sub query task for the query job can be configured based on the name of the last column returned by the previous sub query task. For example assume the parameter last column name holds as its value the name of the last column e.g. the 1000column returned by the first sub query task that returned the first 1 000 columns. The fair scheduler can cause the database management system to execute the following sub query task to obtain the next 1 000 results 

Here since name of the last column returned by the previous sub query task is provided as the value for the start parameter in this sub query task the first column returned by this sub query task will be the same as the last column returned by the previous sub query task. This is done to avoid inadvertently skipping columns between two consecutively executed sub query tasks for a query job. Accordingly a value of 1001 is provided for the count parameter to obtain the next 1 000 columns.

The above paging scheme assumes that the columns within a row are ordered by column name and the names of the columns within the row are unique within the row. More generally the above paging scheme can be applied over a set of potential results in which each potential result is ordered within the set by a unique value associated with the potential result.

The following description presents method steps that may be implemented using computer executable instructions for directing operation of a device under processor control. The computer executable instructions may be stored on a computer readable medium such as hard disk CD DVD flash memory or the like. The computer executable instructions may also be stored as a set of downloadable computer executable instructions for example for downloading and installation from an Internet location e.g. Web server .

At step the system obtains a cost estimate for the query job. As with the query job how the system obtains the cost estimate is not particularly important. For example the cost estimate may be specified in a query job request if the query job was obtained in a query job request. As another example the cost estimate may be obtained from a cost analysis of the query job performed by the system. The cost analysis may be based on the query parameters specified in the query job.

At step the system obtains a threshold cost in some manner. The threshold cost may be predetermined before step i.e. before the query job is obtained . Generally a threshold cost is selected so that high cost query jobs are broken down into multiple separately executable lower cost sub query tasks. If the threshold cost is too high not enough high cost query jobs may be broken down into multiple separately executable lower cost sub query tasks by the system thereby causing excessive starvation of concurrently executing low cost query jobs for shared computing resources. If on the other hand the threshold cost is too low low cost query jobs may be unnecessarily broken down into multiple separately executable lower cost sub query tasks by the system thereby causing excessive latency for the low cost query jobs.

The threshold cost may be configured by an administrator of the system. During operation the system may dynamically adjust the threshold cost based on query workload history. Such history may include query execution metrics for low cost and high cost query jobs. Such query execution metrics can include latency and throughput of query jobs among other metrics.

At step the system determines whether the obtained cost estimate exceeds or equals the obtained threshold cost. If so system determines step to divide the query job into multiple separately executable sub query tasks. The division may be based on the cost estimate and the threshold cost. For example the query job can be divided evenly into N sub query tasks where N is the cost estimate threshold cost 1 . In this case the first N 1 tasks would be expected to have equal execution cost. The Nth task would be expected to have at most the execution cost of one of the first N 1 tasks. If the system determines that the obtained cost estimate does not exceed or equals the obtained threshold cost then the query job is not divided and executed as a single query task.

Whether the query job is divided or not at step a job item representing the query job is enqueued to the end of a job execution queue. The job execution queue holds up to M number of job items where M represents the maximum number of query jobs that the system will allow the database management system to concurrently execute query tasks for. Like the threshold cost the size of the job execution queue e.g. the maximum number M of job items allowed in the job execution queue at one time may be predetermined and or dynamically adjusted based on query workload history. If the job execution queue has M job items in it when a new query job is obtained at step i.e. the job execution queue is full then the system may block further processing of the new query job until an existing query job finishes execution e.g. until an existing query job is cancelled and the job item for the query job is removed from the job execution queue or until all sub query tasks of an existing query job have been executed and the job item for the query is dequeued from the job execution queue . The system may maintain another queue for ordering and tracking new query jobs that are obtained when the job execution queue is full.

At step the job item enqueued at step is dequeued after the job item reaches the front of the job execution queue. The job item will not reach the front of the job execution queue until all job items closer to the front of the job execution queue have been dequeued or removed from the job execution queue. Among other information a job item representing a query job enqueued onto the job execution queue may contain query job specification data such as query parameters for the query job. The job item may also contain fair scheduling bookkeeping data such as a the number of sub query tasks the query job was divided into if the query job was divided at step b a numerical result limiter to be used for all sub query tasks or per sub query tasks numerical result limiters and c a paging value representing the last result returned from the most recently completed sub query task which can be used to configure the next sub query task.

At step the system causes the next sub query task to be executed by the database management system. If the query job was not divided the next sub query task will be the only query task executed for the query job. If the query job was divided then the next sub query task is configured with a result limiter that limits the number of results returned by the database management system.

At step the system determines if there are more sub query tasks of the query job to execute. If so the method returns to step to re enqueue the job item for the query job to the end of the job execution queue. If at step there are no more sub query tasks to execute then the query job is considered to be finished and the job item for the query job is not re enqueued to the end of the job execution queue.

Scheduling query jobs through the job execution may be performed by the system to ensure a fair scheduling of mixed query loads. Through the system s use of the job execution queue both high cost and low cost query jobs may be fairly and concurrently executed by the database management system in a round robin fashion.

It may be the case that execution of a sub query task for a query job by the database management system is not progressing. For this or some other reason a user of the fair scheduling system may wish to cancel a currently executing query job. Accordingly in some embodiments a request to the fair scheduling system to cancel a currently executing query job is received. Upon receiving the cancel request the fair scheduling system removes the job item corresponding to the query job from the job execution queue. As a result no further sub query tasks of query job will be executed. This cancellation may have no effect on execution of the currently sub query tasks.

In some embodiments in which the database management system operates on multiple computing nodes the system re submits a cancelled query job as a new query job with the same query parameters but for execution on a different computing node than the computing device that the cancelled query job was last executing on when cancelled. This is useful if the reason the cancelled query job was not progressing was because of a problem particular to the computing node on which the cancelled query job was last executing.

The cancellation request may be provided by a user through a graphical user interface presented on the user s personal computing device. For example the user interface may present a list of currently executing query jobs and associated interactive graphical user interface elements for cancelling selected query jobs.

According to one embodiment the techniques described herein are implemented by one or more special purpose computing devices. The special purpose computing devices may be hard wired to perform the techniques or may include digital electronic devices such as one or more application specific integrated circuits ASICs or field programmable gate arrays FPGAs that are persistently programmed to perform the techniques or may include one or more general purpose hardware processors programmed to perform the techniques pursuant to program instructions in firmware memory other storage or a combination. Such special purpose computing devices may also combine custom hard wired logic ASICs or FPGAs with custom programming to accomplish the techniques. The special purpose computing devices may be desktop computer systems portable computer systems handheld devices networking devices or any other device that incorporates hard wired and or program logic to implement the techniques.

For example is a block diagram that illustrates a computer system upon which an embodiment of the invention may be implemented. Computer system includes a bus or other communication mechanism for communicating information and a hardware processor coupled with bus for processing information. Hardware processor may be for example a general purpose microprocessor.

Computer system also includes a main memory such as a random access memory RAM or other dynamic storage device coupled to bus for storing information and instructions to be executed by processor . Main memory also may be used for storing temporary variables or other intermediate information during execution of instructions to be executed by processor . Such instructions when stored in non transitory storage media accessible to processor render computer system into a special purpose machine that is customized to perform the operations specified in the instructions.

Computer system further includes a read only memory ROM or other static storage device coupled to bus for storing static information and instructions for processor . A storage device such as a magnetic disk or optical disk is provided and coupled to bus for storing information and instructions.

Computer system may be coupled via bus to a display such as a cathode ray tube CRT for displaying information to a computer user. An input device including alphanumeric and other keys is coupled to bus for communicating information and command selections to processor . Another type of user input device is cursor control such as a mouse a trackball or cursor direction keys for communicating direction information and command selections to processor and for controlling cursor movement on display . This input device typically has two degrees of freedom in two axes a first axis e.g. x and a second axis e.g. y that allows the device to specify positions in a plane.

Computer system may implement the techniques described herein using customized hard wired logic one or more ASICs or FPGAs firmware and or program logic which in combination with the computer system causes or programs computer system to be a special purpose machine. According to one embodiment the techniques herein are performed by computer system in response to processor executing one or more sequences of one or more instructions contained in main memory . Such instructions may be read into main memory from another storage medium such as storage device . Execution of the sequences of instructions contained in main memory causes processor to perform the process steps described herein. In alternative embodiments hard wired circuitry may be used in place of or in combination with software instructions.

The term storage media as used herein refers to any non transitory media that store data and or instructions that cause a machine to operation in a specific fashion. Such storage media may comprise non volatile media and or volatile media. Non volatile media includes for example optical or magnetic disks such as storage device . Volatile media includes dynamic memory such as main memory . Common forms of storage media include for example a floppy disk a flexible disk hard disk solid state drive magnetic tape or any other magnetic data storage medium a CD ROM any other optical data storage medium any physical medium with patterns of holes a RAM a PROM and EPROM a FLASH EPROM NVRAM any other memory chip or cartridge.

Storage media is distinct from but may be used in conjunction with transmission media. Transmission media participates in transferring information between storage media. For example transmission media includes coaxial cables copper wire and fiber optics including the wires that comprise bus . Transmission media can also take the form of acoustic or light waves such as those generated during radio wave and infra red data communications.

Various forms of media may be involved in carrying one or more sequences of one or more instructions to processor for execution. For example the instructions may initially be carried on a magnetic disk or solid state drive of a remote computer. The remote computer can load the instructions into its dynamic memory and send the instructions over a telephone line using a modem. A modem local to computer system can receive the data on the telephone line and use an infra red transmitter to convert the data to an infra red signal. An infra red detector can receive the data carried in the infra red signal and appropriate circuitry can place the data on bus . Bus carries the data to main memory from which processor retrieves and executes the instructions. The instructions received by main memory may optionally be stored on storage device either before or after execution by processor .

Computer system also includes a communication interface coupled to bus . Communication interface provides a two way data communication coupling to a network link that is connected to a local network . For example communication interface may be an integrated services digital network ISDN card cable modem satellite modem or a modem to provide a data communication connection to a corresponding type of telephone line. As another example communication interface may be a local area network LAN card to provide a data communication connection to a compatible LAN. Wireless links may also be implemented. In any such implementation communication interface sends and receives electrical electromagnetic or optical signals that carry digital data streams representing various types of information.

Network link typically provides data communication through one or more networks to other data devices. For example network link may provide a connection through local network to a host computer or to data equipment operated by an Internet Service Provider ISP . ISP in turn provides data communication services through the world wide packet data communication network now commonly referred to as the Internet . Local network and Internet both use electrical electromagnetic or optical signals that carry digital data streams. The signals through the various networks and the signals on network link and through communication interface which carry the digital data to and from computer system are example forms of transmission media.

Computer system can send messages and receive data including program code through the network s network link and communication interface . In the Internet example a server might transmit a requested code for an application program through Internet ISP local network and communication interface .

The received code may be executed by processor as it is received and or stored in storage device or other non volatile storage for later execution.

In the foregoing specification embodiments of the invention have been described with reference to numerous specific details that may vary from implementation to implementation. The specification and drawings are accordingly to be regarded in an illustrative rather than a restrictive sense. The sole and exclusive indicator of the scope of the invention and what is intended by the applicants to be the scope of the invention is the literal and equivalent scope of the set of claims that issue from this application in the specific form in which such claims issue including any subsequent correction.

