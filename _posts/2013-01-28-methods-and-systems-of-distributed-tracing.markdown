---

title: Methods and systems of distributed tracing
abstract: A system and methods are provided for distributed tracing in a distributed application. In one embodiment, a method includes observing a plurality of messages sent and received among components of the distributed application, generating a probabilistic model of a call flow from observed messages of the distributed system, and constructing a call flow graph based on the probabilistic model for the distributed application. Distributed tracing may include observing messages by performing the subscription-based observation techniques and operations to receive, message traces describing messages being communicated among components of the distributed application. In this regard, the tracing service may merge message traces from different instrumentation points with message traces obtained by observing message queues to generate a probabilistic model and call flow graph. A distributed application developer or other relevant user may benefit in efficiently and effectively tracking down a cause of an abnormal behavior or analyzing performance profiles.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09135145&OS=09135145&RS=09135145
owner: Rackspace US, Inc.
number: 09135145
owner_city: San Antonio
owner_country: US
publication_date: 20130128
---
This application is related to co pending non provisional U.S. patent application Ser. No. 13 752 255 entitled Methods and Systems of Generating a Billing Feed of a Distributed Network filed Jan. 28 2013 and Ser. No. 13 752 234 entitled Methods and Systems of Function Specific Tracing filed Jan. 28 2013.

The present disclosure relates generally to tools for program development and more particularly to systems and methods for tracing distributed systems.

Tracing can be one of the most important tools for program development and debugging. Typically a debugger allows for execution of an application to be observed recorded and used to identify particular problems with the application. The problem with typical methods and programs for debugging is that traditional debuggers are meant to deal with one process only. As such even multiple threads of control within a single process can be difficult to trace. While conventional tracing methods and debuggers exist these methods and programs are not suited for tracing distributed applications. Architecturally distributed applications can be built like middleware and as a distributed system where requests for work are routed through a system of central queues with a number of dispatcher and worker units at the edges of an application. Cross process cross platform and cross machine tracing are difficult and still under developed. What is desired is a system and method for providing distributed tracing and to provide for debugging of applications.

Conventional systems for debugging can allow for snooping on messages in a distributed system. However these methods treat what goes across the distributed application as an isolated message. What is desired is further integration between tracing and process debugging.

The following disclosure has reference to tracing and debugging in a distributed computing environment.

According to one embodiment application includes tracing service configured to provide distributed tracing of the distributed application. As will be described in more detail below distributed tracing can provide visibility into the performance into the causes of errors or bugs and increase reliability of the distributed application. By way of example tracing service can observe messages within the distributed application across queues and from particular components of the application. As depicted in tracing service interfaces with message service of application . Message service connects various subsystems of the application and message service may be configured to pass messages relative to one or more elements of system .

System may include one or more subsystems such as controllers and services . System may include one or more controllers for the application to be employed in a distributed architecture such as cloud computing services. As depicted in controllers include a compute controller a storage controller auth controller image service controller and network controller . Controllers are described with reference to a cloud computing architecture in . By way of example network controller deals with host machine network configurations and can perform operations for allocating IP addresses configuring VLANs implementing security groups and configuring networks. Each of controllers may interface with one or more services. As depicted in compute controller interfaces with compute pool storage controller may interface with object store auth controller may interface with authentication authorization controller image service controller may interface with image store and network controller may interface with virtual networking devices . Although controllers and services are with reference to an open architecture it should be appreciated that the methods and systems for tracing may be equally applied to other distributed applications.

Referring now to an external view of a cloud computing system is illustrated. Cloud computing system includes tracing service and message service . According to one embodiment tracing service can observe messages of cloud computing system and constructs a call flow graph within each service and between services of the could computing system . According to another embodiment controllers and services of the cloud computing system may include tracing services to transmit message traces in response to sending or receiving of messages.

The cloud computing system includes a user device connected to a network such as for example a Transport Control Protocol Internet Protocol TCP IP network e.g. the Internet. The user device is coupled to the cloud computing system via one or more service endpoints . Depending on the type of cloud service provided these endpoints give varying amounts of control relative to the provisioning of resources within the cloud computing system . For example SaaS endpoint typically only gives information and access relative to the application running on the cloud storage system and the scaling and processing aspects of the cloud computing system is obscured from the user. PaaS endpoint typically gives an abstract Application Programming Interface API that allows developers to declaratively request or command the backend storage computation and scaling resources provided by the cloud without giving exact control to the user. IaaS endpoint typically provides the ability to directly request the provisioning of resources such as computation units typically virtual machines software defined or software controlled network elements like routers switches domain name servers etc. file or object storage facilities authorization services database services queue services and endpoints etc. In addition users interacting with an IaaS cloud are typically able to provide virtual machine images that have been customized for user specific functions. This allows the cloud computing system to be used for new user defined services without requiring specific support.

It is important to recognize that the control allowed via an IaaS endpoint is not complete. Within the cloud computing system are one or more cloud controllers running what is sometimes called a cloud operating system that work on an even lower level interacting with physical machines managing the contradictory demands of the multi tenant cloud computing system . In one embodiment these correspond to the controllers and services discussed relative to . The workings of the cloud controllers are typically not exposed outside of the cloud computing system even in an IaaS context. In one embodiment the commands received through one of the service endpoints are then routed via one or more internal networks . The internal network couples the different services to each other. The internal network may encompass various protocols or services including but not limited to electrical optical or wireless connections at the physical layer Ethernet Fiber channel ATM and SONET at the MAC layer TCP UDP ZeroMQ or other services at the connection layer and XMPP HTTP AMPQ STOMP SMS SMTP SNMP or other standards at the protocol layer. The internal network is typically not exposed outside the cloud computing system except to the extent that one or more virtual networks may be exposed that control the internal routing according to various rules. The virtual networks typically do not expose as much complexity as may exist in the actual internal network but varying levels of granularity can be exposed to the control of the user particularly in IaaS services.

In one or more embodiments it may be useful to include various processing or routing nodes in the network layers and such as proxy gateway . Other types of processing or routing nodes may include switches routers switch fabrics caches format modifiers or correlators. These processing and routing nodes may or may not be visible to the outside. It is typical that one level of processing or routing nodes may be internal only coupled to the internal network whereas other types of network services may be defined by or accessible to users and show up in one or more virtual networks . Either of the internal network or the virtual networks may be encrypted or authenticated according to the protocols and services described below.

In various embodiments one or more parts of the cloud computing system may be disposed on a single host. Accordingly some of the network layers and may be composed of an internal call graph inter process communication IPC or a shared memory communication system.

Once a communication passes from the endpoints via a network layer or as well as possibly via one or more switches or processing devices it is received by one or more applicable cloud controllers . The cloud controllers are responsible for interpreting the message and coordinating the performance of the necessary corresponding services returning a response if necessary. Although the cloud controllers may provide services directly more typically the cloud controllers are in operative contact with the service resources necessary to provide the corresponding services. For example it is possible for different services to be provided at different levels of abstraction. For example a service may be a compute service that will work at an IaaS level allowing the creation and control of user defined virtual computing resources. In addition to the services discussed relative to a cloud computing system may provide a declarative storage API a SaaS level Queue service a DNS service or a Database service or other application services without exposing any of the underlying scaling or computational resources. Other services are contemplated as discussed in detail below.

In various embodiments various cloud computing services or the cloud computing system itself may require a message passing system. The message routing service is available to address this need but it is not a required part of the system architecture in at least one embodiment. In one embodiment the message routing service is used to transfer messages from one component to another without explicitly linking the state of the two components. Note that this message routing service may or may not be available for user addressable systems in one preferred embodiment there is a separation between storage for cloud service state and for user data including user service state.

In various embodiments various cloud computing services or the cloud computing system itself may require a persistent storage for system state. The data store is available to address this need but it is not a required part of the system architecture in at least one embodiment. In one embodiment various aspects of system state are saved in redundant databases on various hosts or as special files in an object storage service. In a second embodiment a relational database service is used to store system state. In a third embodiment a column graph or document oriented database is used. Note that this persistent storage may or may not be available for user addressable systems in one preferred embodiment there is a separation between storage for cloud service state and for user data including user service state.

In various embodiments it may be useful for the cloud computing system to have a system controller . In one embodiment the system controller is similar to the cloud computing controllers except that it is used to control or direct operations at the level of the cloud computing system rather than at the level of an individual service.

For clarity of discussion above only one user device has been illustrated as connected to the cloud computing system and the discussion generally referred to receiving a communication from outside the cloud computing system routing it to a cloud controller and coordinating processing of the message via a service the infrastructure described is also equally available for sending out messages. These messages may be sent out as replies to previous communications or they may be internally sourced. Routing messages from a particular service to a user device is accomplished in the same manner as receiving a message from user device to a service just in reverse. The precise manner of receiving processing responding and sending messages is described below with reference to the various discussed service embodiments. One of skill in the art will recognize however that a plurality of user devices may and typically will be connected to the cloud computing system and that each element or set of elements within the cloud computing system is replicable as necessary. Further the cloud computing system whether or not it has one endpoint or multiple endpoints is expected to encompass embodiments including public clouds private clouds hybrid clouds and multi vendor clouds.

Each of the user device the cloud computing system the endpoints the cloud controllers and the cloud services typically include a respective information processing system a subsystem or a part of a subsystem for executing processes and performing operations e.g. processing or communicating information . An information processing system is an electronic device capable of processing executing or otherwise handling information such as a computer. shows an information processing system that is representative of one of or a portion of the information processing systems described above.

Referring now to diagram shows an information processing system configured to host one or more virtual machines coupled to a network . The network could be one or both of the networks and described above. An information processing system is an electronic device capable of processing executing or otherwise handling information. Examples of information processing systems include a server computer a personal computer e.g. a desktop computer or a portable computer such as for example a laptop computer a handheld computer and or a variety of other information handling systems known in the art. The information processing system shown is representative of one of or a portion of the information processing systems described above.

The information processing system may include any or all of the following a a processor for executing and otherwise processing instructions b one or more network interfaces e.g. circuitry for communicating between the processor and other devices those other devices possibly located across the network c a memory device e.g. FLASH memory a random access memory RAM device or a read only memory ROM device for storing information e.g. instructions executed by processor and data operated upon by processor in response to such instructions . In some embodiments the information processing system may also include a separate computer readable medium operably coupled to the processor for storing information and instructions as described further below.

In one embodiment there is more than one network interface so that the multiple network interfaces can be used to separately route management production and other traffic. In one exemplary embodiment an information processing system has a management interface at 1 GB s a production interface at GB s and may have additional interfaces for channel bonding high availability or performance. An information processing device configured as a processing or routing node may also have an additional interface dedicated to public Internet traffic and specific circuitry or resources necessary to act as a VLAN trunk.

In some embodiments the information processing system may include a plurality of input output devices which are operably coupled to the processor for inputting or outputting information such as a display device a print device or other electronic circuitry for performing other operations of the information processing system known in the art.

With reference to the computer readable media including both memory device and secondary computer readable medium the computer readable media and the processor are structurally and functionally interrelated with one another as described below in further detail and information processing system of the illustrative embodiment is structurally and functionally interrelated with a respective computer readable medium similar to the manner in which the processor is structurally and functionally interrelated with the computer readable media and . As discussed above the computer readable media may be implemented using a hard disk drive a memory device and or a variety of other computer readable media known in the art and when including functional descriptive material data structures are created that define structural and functional interrelationships between such data structures and the computer readable media and other aspects of the system . Such interrelationships permit the data structures functionality to be realized. For example in one embodiment the processor reads e.g. accesses or copies such functional descriptive material from the network interface the computer readable media onto the memory device of the information processing system and the information processing system more particularly the processor performs its operations as described elsewhere herein in response to such material stored in the memory device of the information processing system . In addition to reading such functional descriptive material from the computer readable medium the processor is capable of reading such functional descriptive material from or through the network . In one embodiment the information processing system includes at least one type of computer readable media that is non transitory. For explanatory purposes below singular forms such as computer readable medium memory and disk are used but it is intended that these may refer to all or any portion of the computer readable media available in or to a particular information processing system without limiting them to a specific location or implementation.

The information processing system includes a hypervisor . The hypervisor may be implemented in software as a subsidiary information processing system or in a tailored electrical circuit or as software instructions to be used in conjunction with a processor to create a hardware software combination that implements the specific functionality described herein. To the extent that software is used to implement the hypervisor it may include software that is stored on a computer readable medium including the computer readable medium . The hypervisor may be included logically below a host operating system as a host itself as part of a larger host operating system or as a program or process running above or on top of a host operating system. Examples of hypervisors include Xenserver KVM VMware Microsoft s Hyper V and emulation programs such as QEMU.

The hypervisor includes the functionality to add remove and modify a number of logical containers associated with the hypervisor. Zero one or many of the logical containers contain associated operating environments . The logical containers can implement various interfaces depending upon the desired characteristics of the operating environment. In one embodiment a logical container implements a hardware like interface such that the associated operating environment appears to be running on or within an information processing system such as the information processing system . For example one embodiment of a logical container could implement an interface resembling an x86 x86 64 ARM or other computer instruction set with appropriate RAM busses disks and network devices. A corresponding operating environment for this embodiment could be an operating system such as Microsoft Windows Linux Linux Android or Mac OS X. In another embodiment a logical container implements an operating system like interface such that the associated operating environment appears to be running on or within an operating system. For example one embodiment of this type of logical container could appear to be a Microsoft Windows Linux or Mac OS X operating system. Another possible operating system includes an Android operating system which includes significant runtime functionality on top of a lower level kernel. A corresponding operating environment could enforce separation between users and processes such that each process or group of processes appeared to have sole access to the resources of the operating system. In a third environment a logical container implements a software defined interface such a language runtime or logical process that the associated operating environment can use to run and interact with its environment. For example one embodiment of this type of logical container could appear to be a Java Dalvik Lua Python or other language virtual machine. A corresponding operating environment would use the built in threading processing and code loading capabilities to load and run code. Adding removing or modifying a logical container may or may not also involve adding removing or modifying an associated operating environment . For ease of explanation below these operating environments will be described in terms of an embodiment as Virtual Machines or VMs but this is simply one implementation among the options listed above.

In one or more embodiments a VM has one or more virtual network interfaces . How the virtual network interface is exposed to the operating environment depends upon the implementation of the operating environment. In an operating environment that mimics a hardware computer the virtual network interface appears as one or more virtual network interface cards. In an operating environment that appears as an operating system the virtual network interface appears as a virtual character device or socket. In an operating environment that appears as a language runtime the virtual network interface appears as a socket queue message service or other appropriate construct. The virtual network interfaces VNIs may be associated with a virtual switch Vswitch at either the hypervisor or container level. The VNI logically couples the operating environment to the network and allows the VMs to send and receive network traffic. In one embodiment the physical network interface card is also coupled to one or more VMs through a Vswitch.

In one or more embodiments each VM includes identification data for use naming interacting or referring to the VM. This can include the Media Access Control MAC address the Internet Protocol IP address and one or more unambiguous names or identifiers.

In one or more embodiments a volume is a detachable block storage device. In some embodiments a particular volume can only be attached to one instance at a time whereas in other embodiments a volume works like a Storage Area Network SAN so that it can be concurrently accessed by multiple devices. Volumes can be attached to either a particular information processing device or a particular virtual machine so they are or appear to be local to that machine. Further a volume attached to one information processing device or VM can be exported over the network to share access with other instances using common file sharing protocols. In other embodiments there are areas of storage declared to be local storage. Typically a local storage volume will be storage from the information processing device shared with or exposed to one or more operating environments on the information processing device. Local storage is guaranteed to exist only for the duration of the operating environment recreating the operating environment may or may not remove or erase any local storage associated with that operating environment.

Between the various virtual machines and virtual devices it may be necessary to have a reliable messaging infrastructure. In various embodiments a message queuing service is used for both local and remote communication so that there is no requirement that any of the services exist on the same physical machine. Various existing messaging infrastructures are contemplated including AMQP ZeroMQ STOMP and XMPP. Note that this messaging system may or may not be available for user addressable systems in one preferred embodiment there is a separation between internal messaging services and any messaging services associated with user data.

In one embodiment the message service sits between various components and allows them to communicate in a loosely coupled fashion. This can be accomplished using Remote Procedure Calls RPC hereinafter to communicate between components built atop either direct messages and or an underlying publish subscribe infrastructure. In a typical embodiment it is expected that both direct and topic based exchanges are used. This allows for decoupling of the components full asynchronous communications and transparent balancing between equivalent components. In some embodiments calls between different APIs can be supported over the distributed system by providing an adapter class which takes care of marshalling and unmarshalling of messages into function calls.

In one embodiment a cloud controller or the applicable cloud service creates two queues at initialization time one that accepts node specific messages and another that accepts generic messages addressed to any node of a particular type. This allows both specific node control as well as orchestration of the cloud service without limiting the particular implementation of a node. In an embodiment in which these message queues are bridged to an API the API can act as a consumer server or publisher.

Turning now to one implementation of a message service is shown. For simplicity of description shows the message service when a single instance is deployed and shared in the cloud computing system but the message service can be either centralized or fully distributed.

In one embodiment the message service keeps traffic associated with different queues or routing keys separate so that disparate services can use the message service without interfering with each other. Accordingly the message queue service may be used to communicate messages between network elements between cloud services between cloud controllers between network elements or between any group of sub elements within the above. More than one message service may be used and a cloud service may use its own message service as required.

For clarity of exposition access to the message service will be described in terms of Invokers and Workers but these labels are purely expository and are not intended to convey a limitation on purpose in some embodiments a single component such as a VM may act first as an Invoker then as a Worker the other way around or simultaneously in each role. An Invoker is a component that sends messages in the system via two operations 1 an RPC Remote Procedure Call directed message and ii an RPC broadcast. A Worker is a component that receives messages from the message system and replies accordingly.

In one embodiment there is a message node including one or more exchanges . In a second embodiment the message system is brokerless and one or more exchanges are located at each client. The exchanges act as internal message routing elements so that components interacting with the message service can send and receive messages. In one embodiment these exchanges are subdivided further into a topic exchange and a direct exchange . An exchange is a routing structure or system that exists in a particular context. In a currently preferred embodiment multiple contexts can be included within a single message service with each one acting independently of the others. In one embodiment the type of exchange such as a topic exchange vs. direct exchange determines the routing policy. In a second embodiment the routing policy is determined via a series of routing rules evaluated by the exchange .

The topic exchange is a routing element created during or for RPC directed broadcast operations. In one simple embodiment every message received by the topic exchange is received by every other connected component. In a second embodiment the routing rule within a topic exchange is described as publish subscribe wherein different components can specify a discriminating function and only topics matching the discriminator are passed along. In one embodiment there are many instances of a topic exchange that are created as needed for the message service. In one embodiment there is one topic based exchange for every topic created in the cloud computing system. In a second embodiment there are a set number of topics that have pre created and persistent topic exchanges

The direct exchange is a routing element created during or for RPC directed message operations. In one embodiment there are many instances of a direct exchange that are created as needed for the message service. In a further embodiment there is one direct exchange created for each RPC directed message received by the system.

Within one or more of the exchanges it may be useful to have a queue element . A queue is a message stream messages sent into the stream are kept in the queue until a consuming component connects to the queue and fetches the message. A queue can be shared or can be exclusive. In one embodiment queues with the same topic are shared amongst Workers subscribed to that topic.

In a typical embodiment a queue will implement a FIFO policy for messages and ensure that they are delivered in the same order that they are received. In other embodiments however a queue may implement other policies such as LIFO a priority queue highest priority messages are delivered first or age oldest objects in the queue are delivered first or other configurable delivery policies. In other embodiments a queue may or may not make any guarantees related to message delivery or message persistence.

In one embodiment element is a topic publisher. A topic publisher is created instantiated or awakened when an RPC directed message or an RPC broadcast operation is executed this object is instantiated and used to push a message to the message system. Every publisher connects always to the same topic based exchange its life cycle is limited to the message delivery.

In one embodiment element is a direct consumer. A direct consumer is created instantiated or awakened if an RPC directed message operation is executed this component is instantiated and used to receive a response message from the queuing system. Every direct consumer connects to a unique direct based exchange via a unique exclusive queue identified by a UUID or other unique name. The life cycle of the direct consumer is limited to the message delivery. In one embodiment the exchange and queue identifiers are included the message sent by the topic publisher for RPC directed message operations.

In one embodiment elements elements and are topic consumers. In one embodiment a topic consumer is created instantiated or awakened at system start. In a second embodiment a topic consumer is created instantiated or awakened when a topic is registered with the message system . In a third embodiment a topic consumer is created instantiated or awakened at the same time that a Worker or Workers are instantiated and persists as long as the associated Worker or Workers have not been destroyed. In this embodiment the topic consumer is used to receive messages from the queue and it invokes the appropriate action as defined by the Worker role. A topic consumer connects to the topic based exchange either via a shared queue or via a unique exclusive queue. In one embodiment every Worker has two associated topic consumers one that is addressed only during an RPC broadcast operations and it connects to a shared queue whose exchange key is defined by the topic and the other that is addressed only during an RPC directed message operations connected to a unique queue whose with the exchange key is defined by the topic and the host.

In one embodiment element is a direct publisher. In one embodiment a direct publisher is created instantiated or awakened for RPC directed message operations and it is instantiated to return the message required by the request response operation. The object connects to a direct based exchange whose identity is dictated by the incoming message.

Turning now to one embodiment of the process of sending an RPC directed message is shown relative to the elements of the message system as described relative to . All elements are as described above relative to unless described otherwise. At step a topic publisher is instantiated. At step the topic publisher sends a message to an exchange . At step a direct consumer is instantiated to wait for the response message. At step the message is dispatched by the exchange . At step the message is fetched by the topic consumer dictated by the routing key either by topic or by topic and host . At step the message is passed to a Worker associated with the topic consumer . If needed at step a direct publisher is instantiated to send a response message via the message system . At step the direct publisher sends a message to an exchange . At step the response message is dispatched by the exchange . At step the response message is fetched by the direct consumer instantiated to receive the response and dictated by the routing key. At step the message response is passed to the Invoker.

Turning now to one embodiment of the process of sending an RPC broadcast message is shown relative to the elements of the message system as described relative to . All elements are as described above relative to unless described otherwise. At step a topic publisher is instantiated. At step the topic publisher sends a message to an exchange . At step the message is dispatched by the exchange . At step the message is fetched by a topic consumer dictated by the routing key either by topic or by topic and host . At step the message is passed to a Worker associated with the topic consumer .

In some embodiments a response to an RPC broadcast message can be requested. In that case the process follows the steps outlined relative to to return a response to the Invoker. As the process of instantiating and launching a VM instance in shows requests to a distributed service or application may move through various software components which may be running on one physical machine or may span across multiple machines and network boundaries.

Turning now to an IaaS style computational cloud service a compute service is shown at according to one embodiment. This is one embodiment of a cloud controller with associated cloud service as described relative to . Except as described relative to specific embodiments the existence of a compute service does not require or prohibit the existence of other portions of the cloud computing system nor does it require or prohibit the existence of other cloud controllers with other respective services .

To the extent that some components described relative to the compute service are similar to components of the larger cloud computing system those components may be shared between the cloud computing system and a compute service or they may be completely separate. Further to the extent that controllers nodes servers managers VMs or similar terms are described relative to the compute service those can be understood to comprise any of a single information processing device as described relative to multiple information processing devices a single VM as described relative to a group or cluster of VMs or information processing devices as described relative to . These may run on a single machine or a group of machines but logically work together to provide the described function within the system.

In one embodiment compute service includes an API Server a Compute Controller an Auth Manager an Object Store a Volume Controller a Network Controller and a Compute Manager . These components are coupled by a communications network of the type previously described. In one embodiment communications between various components are message oriented using HTTP or a messaging protocol such as AMQP ZeroMQ or STOMP.

Although various components are described as calling each other or sending data or messages one embodiment makes the communications or calls between components asynchronous with callbacks that get triggered when responses are received. This allows the system to be architected in a shared nothing fashion. To achieve the shared nothing property with multiple copies of the same component compute service further includes distributed data store . Global state for compute service is written into this store using atomic transactions when required. Requests for system state are read out of this store. In some embodiments results are cached within controllers for short periods of time to improve performance. In various embodiments the distributed data store can be the same as or share the same implementation as Object Store .

In one embodiment the API server includes external API endpoints . In one embodiment the external API endpoints are provided over an RPC style system such as CORBA DCE COM SOAP or XML RPC. These follow the calling structure and conventions defined in their respective standards. In another embodiment the external API endpoints are basic HTTP web services following a REST pattern and identifiable via URL. Requests to read a value from a resource are mapped to HTTP GETs requests to create resources are mapped to HTTP PUTs requests to update values associated with a resource are mapped to HTTP POSTs and requests to delete resources are mapped to HTTP DELETEs. In some embodiments other REST style verbs are also available such as the ones associated with WebDay. In a third embodiment the API endpoints are provided via internal function calls IPC or a shared memory mechanism. Regardless of how the API is presented the external API endpoints are used to handle authentication authorization and basic command and control functions using various API interfaces. In one embodiment the same functionality is available via multiple APIs including APIs associated with other cloud computing systems. This enables API compatibility with multiple existing tool sets created for interaction with offerings from other vendors.

The Compute Controller coordinates the interaction of the various parts of the compute service . In one embodiment the various internal services that work together to provide the compute service are internally decoupled by adopting a service oriented architecture SOA . The Compute Controller serves as an internal API server allowing the various internal controllers managers and other components to request and consume services from the other components. In one embodiment all messages pass through the Compute Controller . In a second embodiment the Compute Controller brings up services and advertises service availability but requests and responses go directly between the components making and serving the request. In a third embodiment there is a hybrid model in which some services are requested through the Compute Controller but the responses are provided directly from one component to another.

In one embodiment communication to and from the Compute Controller is mediated via one or more internal API endpoints provided in a similar fashion to those discussed above. The internal API endpoints differ from the external API endpoints in that the internal API endpoints advertise services only available within the overall compute service whereas the external API endpoints advertise services available outside the compute service . There may be one or more internal APIs that correspond to external APIs but it is expected that there will be a greater number and variety of internal API calls available from the Compute Controller .

In one embodiment the Compute Controller includes an instruction processor for receiving and processing instructions associated with directing the compute service . For example in one embodiment responding to an API call involves making a series of coordinated internal API calls to the various services available within the compute service and conditioning later API calls on the outcome or results of earlier API calls. The instruction processor is the component within the Compute Controller responsible for marshaling arguments calling services and making conditional decisions to respond appropriately to API calls.

In one embodiment the instruction processor is implemented as a tailored electrical circuit or as software instructions to be used in conjunction with a hardware processor to create a hardware software combination that implements the specific functionality described herein. To the extent that one embodiment includes computer executable instructions those instructions may include software that is stored on a computer readable medium. Further one or more embodiments have associated with them a buffer. The buffer can take the form of data structures a memory a computer readable medium or an off script processor facility. For example one embodiment uses a language runtime as an instruction processor running as a discrete operating environment as a process in an active operating environment or can be run from a low power embedded processor. In a second embodiment the instruction processor takes the form of a series of interoperating but discrete components some or all of which may be implemented as software programs. In another embodiment the instruction processor is a discrete component using a small amount of flash and a low power processor such as a low power ARM processor. In a further embodiment the instruction processor includes a rule engine as a submodule as described herein.

In one embodiment the Compute Controller includes a message queue as provided by message service . In accordance with the service oriented architecture described above the various functions within the compute service are isolated into discrete internal services that communicate with each other by passing data in a well defined shared format or by coordinating an activity between two or more services. In one embodiment this is done using a message queue as provided by message service . The message service brokers the interactions between the various services inside and outside the Compute Service .

In one embodiment the message service is implemented similarly to the message service described relative to . The message service may use the message service directly with a set of unique exchanges or may use a similarly configured but separate service.

The Auth Manager provides services for authenticating and managing user account role project group quota and security group information for the compute service . In a first embodiment every call is necessarily associated with an authenticated and authorized entity within the system and so is or can be checked before any action is taken. In another embodiment internal messages are assumed to be authorized but all messages originating from outside the service are suspect. In this embodiment the Auth Manager checks the keys provided associated with each call received over external API endpoints and terminates and or logs any call that appears to come from an unauthenticated or unauthorized source. In a third embodiment the Auth Manager is also used for providing resource specific information such as security groups but the internal API calls for that information are assumed to be authorized. External calls are still checked for proper authentication and authorization. Other schemes for authentication and authorization can be implemented by flagging certain API calls as needing verification by the Auth Manager and others as needing no verification.

In one embodiment external communication to and from the Auth Manager is mediated via one or more authentication and authorization API endpoints provided in a similar fashion to those discussed above. The authentication and authorization API endpoints differ from the external API endpoints in that the authentication and authorization API endpoints are only used for managing users resources projects groups and rules associated with those entities such as security groups RBAC roles etc. In another embodiment the authentication and authorization API endpoints are provided as a subset of external API endpoints .

In one embodiment the Auth Manager includes a rules processor not shown for processing the rules associated with the different portions of the compute service . In one embodiment this is implemented in a similar fashion to the instruction processor described above.

The Object Store provides redundant scalable object storage capacity for arbitrary data used by other portions of the compute service . At its simplest the Object Store can be implemented one or more block devices exported over the network. In a second embodiment the Object Store is implemented as a structured and possibly distributed data organization system. Examples include relational database systems both standalone and clustered as well as non relational structured data storage systems like MongoDB Apache Cassandra or Redis. In a third embodiment the Object Store is implemented as a redundant eventually consistent fully distributed data storage service.

In one embodiment external communication to and from the Object Store is mediated via one or more object storage API endpoints provided in a similar fashion to those discussed above. In one embodiment the object storage API endpoints are internal APIs only. In a second embodiment the Object Store is provided by a separate cloud service so the internal API used for compute service is the same as the external API provided by the object storage service itself.

In one embodiment the Object Store includes an Image Service . The Image Service is a lookup and retrieval system for virtual machine images. In one embodiment various virtual machine images can be associated with a unique project group user or name and stored in the Object Store under an appropriate key. In this fashion multiple different virtual machine image files can be provided and programmatically loaded by the compute service .

The Volume Controller coordinates the provision of block devices for use and attachment to virtual machines. In one embodiment the Volume Controller includes Volume Workers . The Volume Workers are implemented as unique virtual machines processes or threads of control that interact with one or more backend volume providers to create update delete manage and attach one or more volumes to a requesting VM.

In a first embodiment the Volume Controller is implemented using a SAN that provides a sharable network exported block device that is available to one or more VMs using a network block protocol such as iSCSI. In this embodiment the Volume Workers interact with the SAN to manage and iSCSI storage to manage LVM based instance volumes stored on one or more smart disks or independent processing devices that act as volume providers using their embedded storage . In a second embodiment disk volumes are stored in the Object Store as image files under appropriate keys. The Volume Controller interacts with the Object Store to retrieve a disk volume and place it within an appropriate logical container on the same information processing system that contains the requesting VM. An instruction processing module acting in concert with the instruction processor and hypervisor on the information processing system acts as the volume provider managing mounting and unmounting the volume on the requesting VM. In a further embodiment the same volume may be mounted on two or more VMs and a block level replication facility may be used to synchronize changes that occur in multiple places. In a third embodiment the Volume Controller acts as a block device proxy for the Object Store and directly exports a view of one or more portions of the Object Store as a volume. In this embodiment the volumes are simply views onto portions of the Object Store and the Volume Workers are part of the internal implementation of the Object Store .

In one embodiment the Network Controller manages the networking resources for VM hosts managed by the compute manager . Messages received by Network Controller are interpreted and acted upon to create update and manage network resources for compute nodes within the compute service such as allocating fixed IP addresses configuring VLANs for projects or groups or configuring networks for compute nodes.

In one embodiment the Network Controller may use a shared cloud controller directly with a set of unique addresses identifiers and routing rules or may use a similarly configured but separate service.

In one embodiment the Compute Manager manages computing instances for use by API users using the compute service . In one embodiment the Compute Manager is coupled to a plurality of resource pools each of which includes one or more compute nodes . Each compute node is a virtual machine management system as described relative to and includes a compute worker a module working in conjunction with the hypervisor and instruction processor to create administer and destroy multiple user or system defined logical containers and operating environments VMs according to requests received through the API. In various embodiments the pools of compute nodes may be organized into clusters such as clusters and . In one embodiment each resource pool is physically located in one or more data centers in one or more different locations. In another embodiment resource pools have different physical or software resources such as different available hardware higher throughput network connections or lower latency to a particular location.

In one embodiment the Compute Manager allocates VM images to particular compute nodes via a Scheduler . The Scheduler is a matching service requests for the creation of new VM instances come in and the most applicable Compute nodes are selected from the pool of potential candidates. In one embodiment the Scheduler selects a compute node using a random algorithm. Because the node is chosen randomly the load on any particular node tends to be non coupled and the load across all resource pools tends to stay relatively even.

In a second embodiment a smart scheduler is used. A smart scheduler analyzes the capabilities associated with a particular resource pool and its component services to make informed decisions on where a new instance should be created. When making this decision it consults not only all the Compute nodes across available resource pools until the ideal host is found.

In a third embodiment a distributed scheduler is used. A distributed scheduler is designed to coordinate the creation of instances across multiple compute services . Not only does the distributed scheduler analyze the capabilities associated with the resource pools available to the current compute service it also recursively consults the schedulers of any linked compute services until the ideal host is found.

In one embodiment either the smart scheduler or the distributed scheduler is implemented using a rules engine not shown and a series of associated rules regarding costs and weights associated with desired compute node characteristics. When deciding where to place an Instance rules engine compares a Weighted Cost for each node. In one embodiment the Weighting is just the sum of the total Costs. In a second embodiment a Weighting is calculated using an exponential or polynomial algorithm. In the simplest embodiment costs are nothing more than integers along a fixed scale although costs can also be represented by floating point numbers vectors or matrices. Costs are computed by looking at the various Capabilities of the available node relative to the specifications of the Instance being requested. The costs are calculated so that a good match has lower cost than a bad match where the relative goodness of a match is determined by how closely the available resources match the requested specifications.

In one embodiment specifications can be hierarchical and can include both hard and soft constraints. A hard constraint is a constraint is a constraint that cannot be violated and have an acceptable response. This can be implemented by having hard constraints be modeled as infinite cost requirements. A soft constraint is a constraint that is preferable but not required. Different soft constraints can have different weights so that fulfilling one soft constraint may be more cost effective than another. Further constraints can take on a range of values where a good match can be found where the available resource is close but not identical to the requested specification. Constraints may also be conditional such that constraint A is a hard constraint or high cost constraint if Constraint B is also fulfilled but can be low cost if Constraint C is fulfilled.

As implemented in one embodiment the constraints are implemented as a series of rules with associated cost functions. These rules can be abstract such as preferring nodes that don t already have an existing instance from the same project or group. Other constraints hard or soft may include a node with available GPU hardware a node with an available network connection over 100 Mbps a node that can run Windows instances a node in a particular geographic location etc.

When evaluating the cost to place a VM instance on a particular node the constraints are computed to select the group of possible nodes and then a weight is computed for each available node and for each requested instance. This allows large requests to have dynamic weighting if 1000 instances are requested the consumed resources on each node are virtually depleted so the Cost can change accordingly.

Turning now to a diagram showing one embodiment of the process of instantiating and launching a VM instance is shown as diagram . At time the API Server receives a request to create and run an instance with the appropriate arguments. In one embodiment this is done by using a command line tool that issues arguments to the API server . In a second embodiment this is done by sending a message to the API Server . In one embodiment the API to create and run the instance includes arguments specifying a resource type a resource image and control arguments. A further embodiment includes requester information and is signed and or encrypted for security and privacy. At time API server accepts the message examines it for API compliance and relays a message to Compute Controller including the information needed to service the request. In an embodiment in which user information accompanies the request either explicitly or implicitly via a signing and or encrypting key or certificate the Compute Controller sends a message to Auth Manager to authenticate and authorize the request at time and Auth Manager sends back a response to Compute Controller indicating whether the request is allowable at time . If the request is allowable a message is sent to the Compute Manager to instantiate the requested resource at time . At time the Compute Manager selects a Compute Worker and sends a message to the selected Worker to instantiate the requested resource. At time Compute Worker identifies and interacts with Network Controller to get a proper VLAN and IP address. At time the selected Worker interacts with the Object Store and or the Image Service to locate and retrieve an image corresponding to the requested resource. If requested via the API or used in an embodiment in which configuration information is included on a mountable volume the selected Worker interacts with the Volume Controller at time to locate and retrieve a volume for the to be instantiated resource. At time the selected Worker uses the available virtualization infrastructure to instantiate the resource mount any volumes and perform appropriate configuration. At time selected Worker interacts with Network Controller to configure routing. At time a message is sent back to the Compute Controller via the Compute Manager indicating success and providing necessary operational details relating to the new resource. At time a message is sent back to the API Server with the results of the operation as a whole. At time the API specified response to the original command is provided from the API Server back to the originally requesting entity. If at any time a requested operation cannot be performed then an error is returned to the API Server at time and the API specified response to the original command is provided from the API server at time . For example an error can be returned if a request is not allowable at time if a VLAN cannot be created or an IP allocated at time if an image cannot be found or transferred at time etc.

Having described an example of a distributed application various embodiments of methods and systems for distributed tracing of such a distributed application will now be described with references to . Various embodiments of the methods and systems disclosed herein may permit construction of a distributed call stack which may advantageously show how such requests may flow through and be processed by various functions procedures methods or other applicable units of software routines. In various embodiments such a distributed call stack may be constructed at least in part by tracing request and response messages across processes software components virtual machines physical machines software services and network boundaries from receiving of requests e.g. an entry of a call to the API all the way down to where work as performed e.g. at worker units or other back end processes and back as further described herein.

In this regard various embodiments of the methods and systems may construct a call flow graph may also be referred herein as a call tree by observing request and response messages between various components of a distributed application. A call flow graph may be used to capture and represent causal relationships between processing activities of various components. That is a call flow graph may encode how a processing activity of one or more components may be caused or triggered by a processing activity of one or more other components.

For example and are interrelated in that describes a system and describes a call flow graph across the different parts of that system indicating a series of actions that are taken by each part of the system and how they in turn call on or depend on other parts of the system. helps the understanding of at least for the flows illustrated but was not automatically generated from nor was it generated by observing the functioning of the system of . Instead was created by examining the underlying code and components used to implement the system of . As described below call flow diagrams in a distributed system can be automatically generated and used to understand and debug a system.

By way of example illustrates an example depiction of a call flow graph that may be constructed by observing the message flows. In particular is a call flow graph in an example scenario of . The example directed graph of is provided herein to explain such a call flow using nodes and to represent processing activities of respective components with directed arcs showing that a processing activity at a source node calls or causes another processing activity at a destination node.

In components may each represent logical unit of processing which may communicate with one another via messages A D in processing a request made to a distributed application. In one example such logical units of processing may be API server compute controller authorization manager compute manager object store or compute worker of the example distributed application in . Other component granularities are also contemplated by various embodiments of the disclosure. For example a component may represent a process a virtual machine a physical machine a cluster of machines or other software hardware unit.

Messages A D may be any type or format of messages utilized for communication between components of a distributed application e.g. cloud service application . In one example messages A D may be routed through a message queuing service such as AMQP ZeroMQ STOMP or XMPP. In another example messages A D may be transported over HTTP. Messages A D may include a payload encoded in appropriate serialization formats such as XML or JSON regardless of the transport mechanism. In yet another example messages A D may represent remote SQL requests and responses.

In the example scenario of message A message B message C and message D may be observed in the order indicated for example by using message snooping instrumentation or other observation techniques further disclosed herein. As also indicated in it may be observed that message A and message C are request messages to component and component respectively whereas message B and message D are response message to message C and message A respectively. Based on such observation a call flow graph such as shown in may be constructed encoding the causal relationship in which Component calls component which in turn calls component . More specifically by observing that the request response message pair of message C and message D is nested inside e.g. appears in between the request response message pair of message A and message B it may be inferred that the two request response message pairs belong to one call flow initiated by and returning to component .

In the example scenario above it is assumed that the request response pairs and the order thereof may be deterministically identified to construct a representative call flow graph. However in a distributed application it may be often the case that request response message pairs and the order thereof are not so definite especially if the distributed application permits asynchronous communication between components. In fact even for the simple example scenario of it cannot be conclusively determined that message C is caused by message A since message C may well have been triggered by another earlier asynchronous request to component .

In this regard some embodiments of the disclosure may be adapted to provide a probabilistic picture of call flows originating from and returning to a particular component. That is if necessary or desired some embodiments of the disclosure may construct a plurality of probable call flow graphs with probabilistic values attached to them instead of constructing one definite call flow graph. illustrate an example scenario in which construction of probabilistic call flow graphs may be beneficial.

In component transmits asynchronous request messages A and B e.g. without waiting for a response to message A or B to which component and component respond with messages G and F respectively. However as shown in in some situations component may in turn request some further processing by component as can be identified by request message C and response message D. For example component may need to request a clean copy of data from component depending on a status e.g. invalidated or missing of a locally cached copy of the data. Other causes of non determinism may include for example delay due to previous asynchronous requests to a component message queuing delay network delay or other I O related delay. It will be appreciated that the probabilistic construction of call flow graphs as disclosed herein may adequately handle the various causes of non determinism and uncertainties including those that may be due to message observation inaccuracies e.g. clock skews missed observations as further discussed below. Also note that the request identified by message E from component to component does not require an explicit response in the example scenario of . For example message E may be a delayed write back or update request that does not require an explicit acknowledgement.

As this example scenario demonstrates in a distributed application even identical or similar requests from the same components e.g. requests message B may lead to different call flows which may in turn produce different mixes and orders of observable messages. Example sequences of observed messages for the two cases in are indicated in the parentheses next to the message labels. This example scenario also demonstrates that it may not be possible to match every request message e.g. message E with a corresponding response message. For these and other reasons discussed herein it may be beneficial to construct probabilistic call flow graphs as provided by embodiments of the disclosure.

Some embodiments of the systems and methods disclosed herein may further generate profile information e.g. performance profile service profile or execution profile associated with the constructed call flow graph. The profile information may include various metrics such as the number of times a component is called the average response time of a component or other execution related metrics. For example show average response times A I associated with nodes. In one embodiment various metrics for the profile information may be generated by observing frequency of request messages to a particular component and by measuring durations between request messages to and response message from a particular component as further described below. In another embodiment a more detailed and or accurate profile information may be generated by receiving and combining various measurements obtained at each component or process. The profile information may beneficially aid distributed application developers in identifying critical paths or hot spots in a distributed execution and or otherwise understanding execution behavior of a distributed application.

In some embodiments the call flow graph may be combined or augmented with information relating to call stacks e.g. execution stacks runtime stacks of processes associated with the call flow identified in the call flow graph as will be further described herein. As known in the art a call stack of a process is a stack data structure that stores information about active functions subroutines methods or procedures of the process. Thus by appropriately integrating information relating to per process call stacks into the call flow graph a distributed call stack may be constructed to provide tracing of calls down into processes and out of processes as well as across process component machine and network boundaries.

Again it should be appreciated that the graphs diagrams illustrations or presentations of call flow graphs and distributed call stacks given above are provided for purposes of exposition and that the systems and methods of the disclosure may utilizing any other suitable form data structure or presentation in constructing and or presenting call flow graphs and distributed call stacks.

Turning now to a flowchart of a distributed tracing method is illustrated in accordance with an embodiment of the disclosure. For example all or part of distributed tracing method may be performed to construct a call flow graph or a distributed call stack described above with respect to .

At block messages sent and received among various components of a distributed application may be snooped on monitored or otherwise observed. As would be understood by one skill in the art a component is an encapsulation of a set of related functions and data. Components in a distributed application may communicate with each other via associated interfaces e.g. APIs over one or more defined communication mechanisms. Thus messages exchanged among various components may be understood as being in any form of data unit or packet that carries requests and responses among components through any form of associated interfaces over any communication mechanism supported by a distributed application. Further while the logical boundary of a component may typically be defined by the associated interface that is shared by functions or objects that make up the component other component granularities may well be supported by embodiments of method . For example the messages being observed may be those that are exchanged among software processes among virtual machines among physical machines among network nodes or among other logical physical units. In one embodiment method may permit a user to define component boundaries or granularities.

For many distributed applications infrastructure for asynchronous communication between various components may be provided by a message oriented middleware MOM such as those based on AMQP STOMP ZeroMQ or XMPP. MOMs typically support asynchronous communication through publish subscribe messaging pattern and or a message queuing service. Accordingly in one embodiment messages may be observed by subscribing to various message queues or mailboxes through which components communicate various requests and responses. A message queuing service may support passive listening on message queues which may be utilized to implement the subscription based observation technique. If a passive listening mode is not supported the message queuing service may be modified to allow receiving of messages from queues without consuming them.

For some distributed applications requests and responses between components may be managed through an object request broker ORB such as those provided in CORBA DCOM XPCOM or other distributed object architecture. In some distributed applications components may communicate through various other conventional inter process or inter component communication protocols and standards such as HTTP requests responses remote SQL queries responses RPC or remote method invocation RMI . Yet in other distributed applications components may communicate through any combination of the above communication mechanisms.

Accordingly in some embodiments messages between components may be observed by instrumenting e.g. modifying to generate message traces various libraries runtimes or other applicable system or middleware routines at appropriate tap points. For example in one embodiment an ORB runtime or other similar runtime for marshalling messages in a distributed object broker architecture may be instrumented to generate and transmit a message trace describing the object call or return message being marshaled or otherwise processed for transmission. In another embodiment an RPC RMI or other IPC runtime may be instrumented to generate and transmit a message trace when a call or a return is being handled. Conventional RPC or RMI logging tools may be leveraged in this embodiment. In yet another embodiment an HTTP gateway or a remote database server gateway may be instrumented to generate and transmit a message trace in response to receiving and sending of requests and responses.

Observing messages at lower layers of communication is also contemplated. For example the tap point for observation may be at a transport network layer where TCP packets may be sniffed or otherwise monitored. Conventional tools such as tcpdump may be leveraged for such a purpose. In another example the tap point may be at a data link layer where network frames may be sniffed or otherwise monitored. This may be achieved by for example running a promiscuous mode on a network interface controller NIC and an associated driver software that are capable of such a mode.

Packet sniffing frame sniffing or other lower layer observation technique may permit leveraging of existing tools to support message observation across various platforms regardless of the communication or messaging protocols being utilized in the distributed application. As such a lower layer observation technique may be utilized if instrumentation of messaging runtimes and or frameworks is not desired or convenient. However because request response messages may be translated into multiple e.g. fragmented partial or overlapping e.g. pipelined packets frames at a lower layer some processing may be required to reconstruct or group such packets frames into a corresponding message. Further if the communication pattern of a distributed application exhibits a high packet rate the packet sniffer or the frame sniffer e.g. a software and or hardware module for passive observation of packets frames may become overloaded and drop some packets or frames. While such overloading may be mitigated if flow control is enabled controlling the flow of packets may be too intrusive and or adversely affect tracing performance.

In various embodiments any one or any combination of the various tap points and the associated message observation techniques described above may be utilized as desired or necessary to observe request response messages among a set of related components e.g. components in one or more services involved in processing a request made to a distributed system. For example a lower layer observation technique may or may not be utilized depending on the above identified benefits and costs of such a technique under a given distributed application architecture. In another example a message queue mailbox subscription technique may be utilized to observe messages that are not traceable in lower layers such as those messages that are exchanged among components or virtual machines residing in one physical machine and thus only pass through message queues mailboxes within that same physical machine. In yet another example a combination of two or more observation techniques may be desired to observe all messages being exchanged through more than one message exchange mechanisms being utilized by the distributed application to be traced.

In this regard some embodiments of method may handle heterogeneity of request response message formats tap points and transport mechanisms. In one aspect management of such heterogeneity may involve merging of multiple streams of observed messages or message trace from different tap points and or different machines into one stream of observed messages. To merge multiple streams in an order approximating the correct message ordering some embodiments may timestamp observed messages or message traces. Timestamp synchronization may be performed using known techniques such as the network time protocol NTP . As known in the art NTP may be able to synchronize clocks on the same local area network with a clock skew of less than 1 msec. and over the global Internet with a clock skew of less than 5 msec. under typical conditions. As such NTP or other available techniques with similar guarantees may be sufficient for most communication patterns among components of distributed applications. Approximating a merged stream of observed messages without relying on timestamps and or time synchronization is also contemplated.

Another aspect of handling such heterogeneity may involve capturing the observed messages in a uniform abstract representation. Although the observed messages may rely on different formats and communication mechanisms depending on the tap point for observation some common information may be extracted for a uniform abstract representation. For example a process identifier ID a node ID or other information identifying a sender and or a receiver of a message may be obtained by inspecting the routing envelop of a message published to a messaging queue mailbox or by inspecting appropriate data structures or protocol stacks associated with an ORB an RPC mechanism a TCP mechanism or other communication mechanism. For some types of messages e.g. a conventional RPC message an RPC directed message over a message queuing service or other messages supporting a matched request response communication pattern a call ID a message ID a socket descriptor a socket address or other information that permits matching of a request and response pair may be obtained. For some types of messages it may be possible to obtain information as to whether a message is a request or a response.

Accordingly in one embodiment various types of messages observed at various tap points may be abstracted and uniformly represented as a tuple comprising a sender ID a receiver ID a request response indicator and or a call ID. As may be appreciated such a representation need not be complete but instead capture only the information obtainable from a particular observed message. For example a tuple representing an observed message may be missing a receiver ID or a call ID if not obtainable. In another embodiment a tuple representing an observed message may further comprise a timestamp to be utilized in merging and ordering multiple message streams as discussed above. In another embodiment a tuple representing an observed message may further comprise an information field regarding the form of the message e.g. whether the message is a published message to a messaging queue mailbox an RPC call return an HTTP request response or other form of message that may be supported in a distributed application .

Using the information captured in the abstract representation of messages a request message may be matched with a corresponding response message. In some embodiments if a call ID a message ID or other information that uniquely identifies a request message is available a later response message carrying the same ID may be matched with the request message as a request response pair. In some embodiments if a call ID a message ID or other information that uniquely identifies a request message is not available but sender ID and receiver ID are available a probable request response pair may be statistically identified by observing historical occurrences of a later message with sender and receivers inverted from those of an earlier message e.g. a receiver of an earlier message sends back a later message to the sender of the earlier message .

In some embodiments the abstract representation of messages may further include other information obtainable from messages. For example various forms of request messages in a distributed application may comprise information regarding the name of a function e.g. a method a procedure to be called along with any applicable function arguments. Such information may be embedded in a payload or message body for some forms of messages e.g. a published message to a queue or an HTTP request and may be embedded in a header or other data structure for other forms of messages e.g. an RPC call . In one embodiment such information may be obtained by for example parsing a serialization data format e.g. JSON SOAP or other similar format encapsulating a function name and arguments. In another example response data e.g. a function return value may be extracted from the payload or message body to be included in the abstract representation of messages for some embodiments.

In some embodiments the above described representations of messages may be utilized in the message traces described above in connection with various instrumentation techniques. In other words in some embodiments what may be generated and transmitted through instrumentation is one of these abstract representations of an observed message.

By abstractly and uniformly representing the observed messages as described above various embodiments of method may permit identification of similar messages transmitted among various components of a distributed system. For example an earlier request message from component 0 to component 1 and a later request message again from component 0 to component 1 may be identified as similar request messages. Such identification may allow embodiments of method to observe historical patterns of communication behavior among components to build a probabilistic model of a call flow as briefly described above with respect to and further described below with respect to block .

Various embodiments of method may permit identification of similar messages at various levels of differentiation. That is by adjusting how tight or loose the match between messages is made the messages may be treated as dissimilar or similar. For example suppose that two request messages share the same sender the same receiver and the same function name to be called but differ with respect to function arguments. The two messages may be classified as dissimilar messages if function arguments are also considered. Otherwise the two messages may be identified as similar.

In another example suppose that similar request messages from a sender may be received and responded to by any one of multiple receivers capable of performing similar tasks e.g. multiple workers with similar personality and subscribing to a same topic queue . Such a situation may be encountered when requests are broadcast and or when requests are routed for load balancing. Response message to the sender from the various receivers may be treated as similar or different depending on the extent of differentiation desired. Other examples include but are not limited to differentiating based on machines including virtual and physical machines that sender or receiver may be running on based on IP address domains or based on message communication mechanisms e.g. through a message queuing service over an HTTP request response an RPC call return or other forms .

The extent of message differentiation may affect how a call flow among components may be presented. That is a more aggregate view of a call flow may be presented e.g. as a call flow graph described further herein if messages are less differentiated whereas a more differentiated view of a call flow may be presented if messages are further differentiated. A more aggregate view may permit a distributed application developer or other relevant user to efficiently and quickly understand the overall call flow whereas a more differentiated view may allow tracking and pinpointing of a particular behavior specific to a particular situation.

For example in the multiple workers situation in the preceding paragraph an aggregate view may present the different calls received at different workers as a single call whereas a differentiated view may present the different calls to different workers as separate calls. The differentiated view may be beneficial for example in case an abnormal behavior afflicts a specific worker at a specific node rather than a specific tasks that all workers are configured to perform. Thus by permitting various levels of differentiation or aggregation of like messages various embodiments of process may beneficially aid distributed application developers or other relevant users through alternate views of call flows corresponding to different levels of aggregation. A front end user interface or other front end tool for method may be configured for example to allow users to choose a criterion for differentiation and to aggregate or expand view of a call flow as desired.

In some distributed applications components may be grouped into one or more sets of related components that together provide a well defined set of related functionalities. Such a set of components may be referred to as a service. Some distributed applications such as a cloud service system may comprise one or more independent interoperable services to process external client requests. The cloud computing system of for example may be a distributed application with distributed components.

While in some cases services may be purely logical groupings of components in more typical cases services may be structurally or architecturally distinguishable as well. That is services are typically independent and loosely coupled through external endpoints e.g. API server whereas within services components are typically limited to communicating with components within the same service through internal communication points e.g. internal API .

As such some embodiments of method may distinguish between inter service messages and intra service messages. For example in embodiments where message observation may be through subscription to message queues or mailboxes provided in a MOM messages may be distinguished by whether they are from message queues utilized by a particular service or by a group services for inter service communication. In such embodiments message queues associated with each service as well as message queues for inter service communication may be subscribed to for message observation thus permitting distinguishing of messages associated with a particular service a group of services or inter service communication as desired. In an embodiment illustrating call endpoints as nodes and messages as directed edges of a graph community detection techniques can be used to identify the centrality of particular nodes and inter service and intra service cliques.

In embodiments utilizing other observation techniques such as the instrumentation based observation techniques appropriate tap points within each service e.g. RPC runtimes utilized by components within one service as well as appropriate tap points for inter service communication e.g. HTTP gateway or external API endpoint associated with a service may be instrumented to observe and or distinguish all intra service and inter service messages of interest for purposes of distributed tracing and or debugging of a distributed application.

More generally messages may be referred herein as being associated with a message domain. In the description above each service may comprise a distinct message domain. As such intra service messages and inter service message may well be referred to as intra domain messages and inter domain messages respectively in the description above. However it is also contemplated that more than one service may belong to a same message domain as desired for an application of method .

Thus in various embodiments method may advantageously permit presentation of a view of call flows e.g. as call flow graphs constructed as further described below that may be limited to a particular service domain to a particular set of services domains or to only calls among services domains as desired for a tracing and or debugging activity of a distributed application. As such various embodiments of method may beneficially aid a distributed application developer or other relevant user in efficiently and effectively tracking down a cause of an abnormal behavior or analyzing performance profiles.

Turning now to block a probabilistic model of call flows may be generated using the observed messages e.g. a sequence of merged message traces . In one embodiment a Markov chain may be modified and utilized as the probabilistic model. As may be appreciated a Markov chain may be efficiently constructed by observing a sequence of historical patterns and may provide probabilistic prediction of future states e.g. patterns based on a current state. Accordingly in one embodiment a Markov chain may be generated from the sequence of observed messages obtained at block . The generated Markov chain may provide probabilities of a particular message or sequence of messages being communicated following an occurrence of a given message in a distributed system.

Generation of a Markov chain according to one embodiment will now be described with respect to which illustrates a transition diagram generated from an example sequence of messages in accordance with an embodiment of the disclosure. For assume that components and in a distributed application may communicate with each other through messages labeled A E as summarized in table . Further assume that sequence of messages may be obtained by observing messages communicated in the distributed system over time.

Using a history table or other suitable data structure the frequency of messages that follow a given message may be recorded. From the recorded frequency transition probabilities may be calculated as provided transition diagram . Transition diagram encodes the probabilities of a particular message being transmitted following a transmission of a given message. For example looking at node A of transition diagram it may be observed that after component receives request message A from component it may send back response message E to component with a 20 probability send request message B to component with a 40 probability and send request message C to component with a 40 probability. Note that any diagram data structure or other representation in are provided only for purposes of exposition and that any other appropriate data structures or representations may be utilized in embodiments of the disclosure to generate a Markov chain.

In another embodiment an n history or n th order Markov chain may be utilized as the probabilistic model. For example a second order Markov chain may look at a two consecutive messages to probabilistically predict a sequence of two messages that may follow. An n history Markov chain may take advantage of more history information trading increased storage requirement and complexity with improved accuracy. If desired one skilled in the art would be able to devise a process of obtaining an n history Markov chain for probabilistic modeling of call flows based on the description of the process of obtaining a Markov chain provided herein.

In another embodiment a hidden Markov model HMM may be utilized as the probabilistic model. As generally known a HMM encodes multiple probabilistic chains with an underlying probabilistic chain that is hidden but may be observed through another set of probabilistic chains that may produce some observed sequence of patterns. As such HMMs may be more flexible than Markov chains in encoding complex behaviors such as asynchronous communication and concurrent executions but at the cost of increased computational complexity.

In embodiments where a HMM is utilized the HMM may be generated or trained applying the Baum Welch training algorithm or other suitable training algorithm with the observed sequence of messages as a training input set as would be understood by one skilled in the art. As may be appreciated to train a HMM it may be necessary to supply how many hidden states may be present in the HMM. While there is no correct number of hidden states for a HMM the number of hidden states may be initially estimated based on an observation of the overall architecture of the distributed application being traced. For example one estimate may be double the number of components being traced i.e. two hidden states e.g. one for synchronous communication and the other for asynchronous communication per component. In one embodiment the number of hidden states may be determined based on trial and error where different HMMs with different number of hidden states may be tried and evaluated e.g. using forward algorithms to find the HMM that better fits the observed sequence of messages.

In other embodiments a probabilistic model of call flows may be generated using other suitable techniques for discovering probabilistic correlations in an observed pattern. For example such techniques may include but are not limited to variations of Markov models stochastic grammar modeling regression analysis stochastic dynamic programming correlation analysis in a frequency domain and various machine learning techniques.

In some embodiments the probabilistic model may be generated on the fly e.g. continuously updated as messages communicated among components are being observed. In other embodiments the probabilistic model may be generated offline using a stored sequence of observed messages.

At block a call flow graph may be constructed based on the generated probabilistic model. As described with respect to the call flow graph may comprise one or more candidate call flow graphs with associated probabilities of occurrence. In various embodiments one or more probabilities associated with corresponding one or more sequences of messages may be calculated from the probabilistic model. If desired the one or more sequences of messages may be required to have the same start message and the same end message. For example the start message may be the first message in a call flow to be traced such as a request message sent from an external API of a service into a component of the service that may in turn trigger a sequence of messages between components of the service. For example the end message may be a response message sent back to the external API of the service.

The process of calculating of a probability associated with a sequence of message may vary depending on the underlying probabilistic model. For example in embodiments where the underlying probabilistic model may be adapted to produce a state transition diagram including state transition matrix probabilistic state machine or other similar representation the probability of a given sequence of messages occurring is a product of transition probabilities corresponding to the given sequence. Referring back briefly to the example state transition diagram of the sequence A E occurs with probability 0.2 the sequence A C D E occurs with probability 0.267 and the sequence A B E occurs with probability 0.267 which can be calculated by following the corresponding transitions and multiplying the transition probabilities encountered.

While all possible paths in a state transition diagram may be traversed to calculate probabilities for all possible sequences this may not be necessary or efficient. Accordingly in some embodiments heuristics may be employed to limit the number of paths to be traversed to find a limited number of most probable sequences. For example greedy algorithms or dynamic programming techniques may be applied to quickly discover more probable paths first. In another example path traversal may be abandoned as soon as the cumulative probability becomes lower than a threshold.

In embodiments where a HMM is utilized as the probabilistic model a probability of a given sequence occurring may be evaluated using a forward algorithm such as the Trellis algorithm. In some embodiments heuristics may be employed to limit the number of evaluations required to obtain some number of most probable sequences. For example other simpler models such as a Markov chain finite state machine or a context free grammar may be generated along with a HMM to provide as input for evaluation only a limited number of possible sequences rather than all possible permutations. In another example path traversal may be abandoned as soon as the cumulative probability becomes lower than a threshold.

From the one or more most probable message sequences obtained as described above one or more corresponding candidate call flow graphs may be constructed. In one embodiment the sender and receiver information contained in the messages of the most probable sequences may be extracted to construct a representation of flow in terms of calls between components. For example illustrates example candidate call flow graphs and that may be constructed from the sequence A B E the sequence A C D E and the sequence A E in the state transition diagram of in accordance with an embodiment of the disclosure. As noted earlier the directed graph representation of call flow graphs in is provided for purposes of exposition and any other suitable data structure and representation e.g. a sequence diagram may be utilized to encode and or represent call flow graphs. Note also that it is not necessary to present any specific number of multiple candidate call flow graphs. Instead for example only the most probable call flow graph may be presented with any number of other probable candidate call flow graphs available for presentation as desired for debugging purposes.

The various operations of blocks may be omitted for example if a probabilistic picture of call flows is not necessary or desired. That is for example if call flows are deterministic e.g. all call return pairs are synchronous and all calls are to pure functions without side effects or pseudo deterministic e.g. having a very low probability of non deterministic behavior a call flow graph may be constructed without a need for the probabilistic modeling described above. In such a case the observed sequence of messages e.g. a repeating chunk of messages in the observed sequence may be constructed directly into a call flow graph.

At block a distributed call stack may be constructed. As described above with respect to a distributed call stack may describe a more comprehensive execution flow through and across processes of components in a distributed application. In various embodiments descriptions of one or more call stacks e.g. execution stacks runtime stacks associated with corresponding one or more processes of components in the call flow e.g. as identified in the constructed call flow graphs may be received from for example per process tracers. The received descriptions of per process call stacks may then be combined with the call flow graph to construct a distributed call stack.

In one embodiment a description of a call stack associated with a process of a component may be transmitted when a message to another component is transmitted. For example the description may be transmitted when the message is published to a messaging queue e.g. when a publisher object is instantiated to push the message to the queue an RPC call routine is invoked or a send call to a network socket is invoked. Further when a message from another component is received a description of a call stack associated with a process of a receiving component may be transmitted with an updated description being transmitted when the call stack grows or otherwise changes. By transmitting updated descriptions a more comprehensive view may be provided of the execution flow within the process once the message is received from another component. For example a per process tracer may be configured transmit initial and updated call stacks once the message is fetched from a messaging queue e.g. when a consumer object is instantiated to dispatch the message to an appropriate process an RPC routine dispatches an RPC call to an appropriate process or an operating system trap indicating a receipt of packet is signaled.

In other embodiments the description may be transmitted based on other schedules. In one example the description of per process call stacks may be transmitted on demand when requested by for example a distributed tracing service configured to perform various operations of method . In another example the description may be transmitted periodically by processes associated with components in the call flow. In yet another example the description may be transmitted at user defined breakpoints.

The description of per process call stacks may comprise in one embodiment the name if available from a symbol table or other debugging information or other identifiers of the functions methods in the call stack. In other embodiments the description may comprise other information such as the function arguments return values and or local variables.

In one embodiment the received descriptions of per process call stacks may be recorded and matched with corresponding observed messages. The appropriate ones of the recorded descriptions may then be selected and combined with the constructed call flow graphs to construct a distributed call stack. For example the appropriate ones of the recorded descriptions may be selected by locating from the sequence of observed messages one or more subsequences that match the constructed call graph where the per recorded descriptions associated with the messages in the subsequences may be selected as the appropriate ones of the recorded descriptions. Multiple per process call stacks may be provided as alternates in case there are more than one per process call stacks that may be associated with a process of a component in the call flow. In another embodiment the descriptions of per process call stacks may be received matched and combined with the call flow graph on the fly for example when the call flow graph is replayed and or stepped through.

At block profile information e.g. performance profile service profile or execution profile associated with the constructed call flow graph may be generated. In various embodiments the profile information may include one or more metrics such as the number of times a component is called the average response time of a component or other execution related metrics. In one embodiment the number of calls to a component may be obtained by counting the number of request messages sent to the component in the observed messages. In one embodiment the timestamps differences between request messages to and corresponding response messages from a component may be statistically compiled to provide an approximation of execution time spent in the component. In one embodiment per process performance profile information e.g. execution time of and or frequency of calls to each function in a process may be received and combined with the component level profile information to provide more detailed and or accurate profile information for the distributed call stack. The profile information may beneficially aid distributed application developers in identifying critical paths or hot spots in a distributed execution and or otherwise understanding execution behavior of a distributed application.

Therefore a system and methods are provided for a cross process cross platform and cross machine tracing of a distributed application. Tracing as described herein provides superior visibility into performance of a distributed application and causes for error in order to increase the reliability of applications and provide higher service. In addition call flow graphs enable tracing down into a process output the process and across the process machine service and network boundaries to show an entire call stack from entry of a call to the API to where work is performed and back.

Referring now to a block diagram is illustrated of a distributed tracing system in accordance with an embodiment of the disclosure. For example distributed tracing system may be configured to perform all or part of method of to construct a call flow graph or a distributed call stack. Distributed tracing system may comprise in one embodiment a distributed tracing service one or more instrumentation points and one or more per process tracers . In one embodiment distributed tracing system may be implemented on top of or as part of for example distributed application of . It will be appreciated that distributed tracing system in no way is limited to or requires distributed application and that distributed tracing system may be implemented on top of or as part of any other suitable distributed application middleware or computing system to beneficially provide thereto distributed tracing and or debugging capabilities described herein.

In one embodiment distributed tracing service may be configured to subscribe or otherwise attach to one or more message queues to observe messages communicated among components A D through message queues . For example distributed tracing service may be configured to observe messages by performing the subscription based observation techniques and operations described above in connection with block of .

In one embodiment distributed tracing service may be configured to receive from instrumentation points message traces describing messages being communicated among components A D. In this regard distributed tracing service may be configured to merge message traces from different instrumentation points . Further in this regard distributed tracing service may be configured to merge message traces received from instrumentation points with message traces obtained by observing message queues . For example distributed tracing service may be configured to implement the merging and message representation techniques and operations described in connection with block of .

In one embodiment instrumentation points may be located at various tap points described above with respect to block of including an RPC runtime an ORB a HTTP or remote database gateway and a network protocol stack . In one embodiment instrumentation points may be configured to generate and transmit to distributed tracing service message traces describing request response messages that pass through the corresponding tap points as described above with respect to block of .

Per process tracer may be configured to trace a call stack e.g. an execution stack a runtime stack of a process of component A D by running the process under its environment in a manner similar to call stack tracing in conventional single process tracers or debuggers. In one embodiment per process tracer may be further configured to transmit a description of the traced call stack to distributed tracing service in a manner described with respect to the distributed call stack generation at block of . In one embodiment distributed tracing system may comprise as many per process tracers as the number of processes that may run in the underlying distributed application. In other embodiments there may be per process tracers for some but not all of the processes that may run in the underlying distributed application.

In one embodiment distributed tracing service may comprise appropriate data structures and related functions for encoding constructing and or storing an observed sequence of messages per process call stacks probabilistic models and call flow graphs . Such data structures and related functions may be implemented for example as provided in the corresponding descriptions of method of . Thus distributed tracing service may be configured to observe and store messages sent and received among components A D generate a probabilistic model of a call flow construct a call flow graph based on the probabilistic model and receive and combine the descriptions of the per process call stacks to generate a distributed call stack in a manner consistent with the various techniques and operations described for method of .

In one embodiment distributed tracing is implemented as an electrical circuit or as software instructions to be used in conjunction with a hardware processor to create a hardware software combination that implements the specific functionality described herein. To the extent that one embodiment includes computer executable instructions those instructions may include software that is stored on a computer readable medium. Further one or more embodiments have associated with them a buffer. The buffer can take the form of data structures a memory a computer readable medium or an off script processor facility. For example one embodiment uses a language runtime as an instruction processor running as a discrete operating environment as a process in an active operating environment or can be run from a low power embedded processor. In a second embodiment the instruction processor takes the form of a series of interoperating but discrete components some or all of which may be implemented as software programs. In another embodiment the instruction processor is a discrete component using a small amount of flash and a low power processor such as a low power ARM processor. In a further embodiment the instruction processor includes a rule engine as a submodule as described herein.

In though illustrative embodiments have been shown and described a wide range of modification change and substitution is contemplated in the foregoing disclosure and in some instances some features of the embodiments may be employed without a corresponding use of other features. Accordingly it is appropriate that the appended claims be construed broadly and in a manner consistent with the scope of the embodiments disclosed herein.

