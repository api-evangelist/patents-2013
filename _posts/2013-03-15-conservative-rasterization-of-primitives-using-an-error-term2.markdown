---

title: Conservative rasterization of primitives using an error term
abstract: A system, method, and computer program product are provided for conservative rasterization of primitives using an error term. In use, an edge equation is determined for each edge of a primitive, the edge equation having coefficients defining the edge of the primitive. Each edge of the primitive is shifted to enlarge the primitive by modifying coefficients of the edge equation defining the edge by an error term that is a predetermined amount. Pixels that intersect the primitive are then determined using the enlarged primitive.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09633469&OS=09633469&RS=09633469
owner: NVIDIA Corporation
number: 09633469
owner_city: Santa Clara
owner_country: US
publication_date: 20130315
---
The present invention relates to graphics processing and more particularly to rasterization of primitives.

A graphics processing pipeline converts input graphics data e.g. that may be associated with three dimensional objects into pixel data that is associated with a two dimensional surface. In conventional implementations a world space portion of the graphics processing pipeline is responsible for processing the input graphics data which is usually composed of a collection of triangles and related vertices prior to when the data is converted into pixel data. A screen space portion of the graphics processing pipeline is responsible for processing the converted pixel data and generating final pixel values for display.

One of the stages in the graphics processing pipeline is the rasterization stage which typically involves converting the graphics data processed by the world space portion of the pipeline into pixel data. Rasterization may involve generating edge equations that describe the edges of triangles processed in the world space portion of the pipeline determining coverage information for those triangles and computing attribute values for the pixels and fragments covered by the triangles. The calculations involved in rasterization are sometimes fixed point calculations that are normally performed with a fixed fractional pixel precision. Thus the results of fixed point rasterization calculations can be thought of as snapped to a grid where the boxes of the grid correspond to boxes of fractional pixel size.

In many implementations a graphics processing pipeline may rasterize the same three dimensional object at different resolutions. For example a triangle may first be rasterized at a low resolution to make certain determinations about the triangle such as what general portions of a surface are covered by the triangle. The triangle may subsequently be rasterized at a higher resolution to generate image data for display. However rasterization conducted at a lower resolution generally provides results that are snapped to a coarser grid than rasterization conducted at a higher resolution. Therefore lower resolution rasterization may produce coverage results that do not properly align with the coverage results of higher resolution rasterization. For example if frame buffer memory is allocated for sparse rendering based on the results of low resolution rasterization memory may be over allocated or under allocated due to the fact that the results of lower resolution rasterization are snapped to a coarser grid. More specifically memory may be allocated for blocks for which no allocation is necessary or memory may fail to be allocated for blocks for which allocation is necessary.

Thus there is a need for addressing accuracy issues when rasterizing graphics data and or for addressing other issues associated with the prior art.

A system method and computer program product are provided for conservative rasterization of primitives using an error term. In use an edge equation is determined for each edge of a primitive the edge equation having coefficients defining the edge of the primitive. Each edge of the primitive is shifted to enlarge the primitive by modifying coefficients of the edge equation defining the edge by an error term that is a predetermined amount. Pixels that intersect the primitive are then determined using the enlarged primitive.

Conservative rasterization is a rasterization technique where if any area of a pixel is intersected by a primitive the pixel is considered for rasterization of the primitive. This differs from traditional rasterization techniques that consider a pixel as a sample point or multiple sample points and if the sample point s are inside the primitive the sample point s are considered for rasterization of the primitive. With conservative rasterization all pixels that actually intersect the primitive will always be identified. However the conservative rasterization process may identify pixels as intersecting a primitive that with perfect precision would not be identified as intersecting the primitive. It should be noted that in the present description pixels are considered to occupy a rectangular area of a display and each primitive may be a triangle line or point.

Conservative rasterization is useful to allow a graphics processing unit GPU to quickly identify the pixels that intersect a primitive so that they can be used by other resources to further do complex computations on the pixel. For example a GPU with conservative rasterization capability can quickly find the pixels that may be intersected by a primitive send those pixels to another compute resource and perform computations that the fixed function pipelines in the GPU may not have the capability to perform. An example of this is extremely fine multisampling for antialiasing. If the GPU is configured to perform multisampling up to 4 4 samples per pixel another computational resource may be configured to perform multisampling when more than 4 4 samples per pixel are used e.g. 16 16 multisampling. The 16 16 multisampling may be performed by programmable shader resources within the GPU itself or may be performed in another chip or computing resource such as a CPU central processing unit . Other examples that may benefit from conservative rasterization at low resolution to partition a processing workload include ray tracing or global illumination where a pixels that intersect a primitive are identified then complex or customized illumination computations are performed to determine the actual color of the pixels.

When conservative rasterization is used the primitive positions are snapped to a grid. When the pixel resolution changes becoming finer or coarser the snapping can affect the shape of the primitives. In other words the shape of the primitives is inconsistent for different pixel resolutions therefore the pixels that are considered to be covered by the primitives may vary for different pixel resolutions.

For example a triangular primitive may be defined by a set of edges. Further each edge of the primitive can be defined by three coefficients for an equation that describes the placement of the primitive on the display. The equation may be defined as 

The coefficients may be computed from vertices of the primitive that have been transformed into screen space. In one embodiment the vertices may have been snapped to a fixed number of fractional bits e.g. 8 bits in order to enable exact precision in raster computations and thus uniform precision across the display. Thus the coefficients may define the placement of a snapped edge.

Further the coefficients and resulting edge equations may be computed such that if any point x y is on the line i.e. edge the edge equation result will be zero. If x y is on the side of line that the primitive lies the result is will be positive and on the other side of the edge negative. So if a point x y computes to positive for all 3 edges the point is inside the primitive.

In step each edge of the primitive is shifted to enlarge the primitive by modifying coefficients of the edge equation defining the edge by an error term that is a predetermined amount. As noted above this error term may be used for the purpose of compensating for inconsistencies introduced by snapping primitives to a grid during the conservative rasterization process. The error term may also be used to compensate for precision discrepancies of the arithmetic operations that applied to the primitives. As an option the error term may be programmable such that for example the value of the error term is a function of the amount of precision introduced by the conservative rasterization process. Just by way of example where the inconsistency is at least in part introduced by virtue of the above described snapping of the primitive the error term may be a function of the distance by which each edge of the primitive has been snapped where the edge is snapped by virtue of the edge being defined by the snapped vertices. In one optional embodiment the error term may be one half of the distance by which each edge of the primitive has been snapped. Further the same error term may be used to modify the coefficients.

It should be noted that the coefficients may be modified by the predetermined amount in any preconfigured manner that results in the enlargement of the primitive. For example when the predetermined amount indicative of the error term is a power of 2 then the coefficients of the edge equation may be modified by shifting the coefficients of the edge equation based on the predetermined amount. As another example the coefficients may be modified by the predetermined amount according to the following equation Error Error 

In the equation shown above the error term may be selectively added or subtracted from the coefficients. In particular the error term may be chosen to enlarge the primitive by the error term. Table 1 illustrates an exemplary configuration for selecting the sign or of each applied error term namely where the signs are based on the direction and orientation of the edge.

In step pixels that intersect the primitive are then determined using the enlarged primitive. As an option only a subset of pixels may be analyzed according to step . For example step may be performed with respect to a fine raster process and further may be performed only for pixels of multi pixel tiles determined during a coarse raster process to intersect the primitive. More information regarding such coarse raster process will be provided below.

In one embodiment a pixel may be determined to at least potentially intersect the primitive when it is determined that not all corners of the pixel are on the negative side of any edge of the enlarged primitive or in other words that all four corners of the pixel are not outside any edge of the enlarged primitive. Where step only determines that a pixel may potentially intersect the primitive further processing may be performed to determine whether the pixel actually intersects the primitive. Such further processing will be described in more detail below.

More illustrative information will now be set forth regarding various optional architectures and features with which the foregoing framework may or may not be implemented per the desires of the user. It should be strongly noted that the following information is set forth for illustrative purposes and should not be construed as limiting in any manner. Any of the following features may be optionally incorporated with or without the exclusion of other features described.

In step vertices of a primitive are snapped to a fixed number of bits. Additionally in step edge coefficients and a bounding box are computed for the primitive. Thus the edge coefficients and bounding box may reflect the placement of the primitive once snapped. In the present description the bounding box may be the minimum or smallest rectangle that bounds i.e. encloses the primitive.

In step one or more coarse tiles that intersect the primitive are determined. The coarse tiles may be any block of pixels of a preconfigured size e.g. 16 16 pixels . The primitive may be scanned in coarse tile steps to determine whether each tile intersects the primitive. It may be determined that the primitive intersects the coarse tile if 1 the bounding box must intersect the coarse tile and 2 not all corners of the coarse tile are on the negative side of any edge of the primitive. As an option not shown for each coarse tile determined to intersect the primitive it may further be determined whether each fine tile e.g. 8 8 pixels making up the coarse tile intersects the primitive.

For each determined coarse tile the pixels of the coarse tile that intersect the primitive are also determined. Note step . Where the intersecting fine tiles have been determined not shown the pixels of each intersecting fine tile that intersect the primitive may alternatively be determined. During conservative rasterization a pixel may be determined to intersect the primitive if any part of the pixel area touches the primitive.

To this end a hierarchical technique may be used to determine the pixels that intersect the primitive. Namely the coarse tiles that intersect the primitive are determined in step and further in step for each determined coarse tile the pixels of such coarse tile that intersect the primitive are determined. In step the determined pixels are processed. Examples of such processing are described below with reference to .

In step a pixel is identified. For example the pixel may be included in a coarse tile previously determined to intersect a primitive. To conservatively determine whether the pixel intersects the primitive instead of basing the determination on a number of sample points as is done in traditional rasterization techniques the corners of the pixel may be used as a basis for the intersection determination. Further only one of the four corners needs to be computed per edge as long as the correct corner is selected. In other words if the correct corner is selected only that corner needs to be tested against the primitive. The correct corner to select is the one farthest from the edge that lies on the same side of the edge as the primitive. The direction and orientation of the edge can be determined by the signs of the edge coefficients as shown in the Table 1 above. Depending on how the edges are defined and the coordinate system the signs can be different but the idea is the same.

To effectively test the selected corner in step the primitive is enlarged by shifting each edge of the primitive a first predetermined amount. For example the traditional aliased rasterizer has one sample point defined in the center of the pixel. The conservative raster of the present method may be implemented by shifting the center sample to the selected corner per edge of the primitive or in other words by shifting each edge of the primitive in the proper direction by the first predetermined amount to make the center sample look like a corner point. The first predetermined amount may be a predetermined fraction of a size of a pixel such as one half of the size of the pixel.

Specifically step may includes modifying coefficients of the edge equation defining the edge by the first predetermined amount in order to enlarge the primitive. The following equation shows an example of a technique for modifying the coefficients to shift the primitive 0.5 0.5 where Eo Eo 0.5Ex 0.5Ey or Eo Eo Ex 1 Ey 1 where is shift right

To this end the coefficients may be modified by a same first predetermined amount but the sign by which the coefficients are modified i.e. or may differ. With respect to the present embodiment the sign may be selected based on the direction and orientation of the edge as configured in Table 1.

Further in step the primitive is further enlarged by shifting each edge of the primitive by an error term. The error term may be a second predetermined amount that is less than the first predetermined amount used to shift the position of the primitive. Thus the primitive may be enlarged by both the first predetermined amount and the error term. In step the bounding box computed for the primitive is also enlarged by shifting each edge of the bounding box. For example the each edge of the bounding box may be shifted by the error term used to enlarge the primitive.

It is then determined in step whether the pixel sample intersects the enlarged primitive. If it is determined that the pixel sample does not intersect the enlarged primitive it is determined in step that the pixel does not intersect the primitive. If however it is determined in step that the pixel sample does intersect the enlarged primitive it is further determined in decision whether the pixel sample intersects the enlarged bounding box. If it is determined that the pixel sample does not intersect the enlarged bounding box it is determined in step that the pixel does not intersect the primitive. However if it is determined in decision that the pixel sample does intersect the enlarged bounding box the pixel is determined to intersect the primitive. Note step .

The graphics processing pipeline may be implemented using a programmable processing unit or using dedicated processing units for one or more functions. A vertex processing unit is a programmable execution unit that is configured to execute vertex shader programs lighting and transforming vertex data as specified by vertex shader programs. For example the vertex processing unit may be programmed to transform the vertex data from an object based coordinate representation object space to an alternatively based coordinate system such as world space or normalized device coordinates NDC space.

The tessellation and geometry processing unit is a programmable execution unit that is configured to execute tessellation shader programs. The tessellation and geometry processing unit processes vertices produced by the vertex processing unit and may be configured to generate graphics primitives known as patches and various patch attributes. In some embodiments the tessellation and geometry processing unit may also perform topology configuration indexing the vertices including vertices associated with patches and compute texture coordinates corresponding to the vertices. The tessellation and geometry processing unit may also be configured to execute geometry shader programs thereby transforming graphics primitives. Vertices are grouped to construct graphics primitives for processing where graphics primitives include triangles line segments points and the like. For example the tessellation and geometry processing unit may be programmed to subdivide the graphics primitives into one or more new graphics primitives and calculate parameters such as plane equation coefficients that are used to rasterize the new graphics primitives. In some embodiments the tessellation and geometry processing unit may also add or delete elements in the geometry stream. The tessellation and geometry processing unit outputs the parameters and vertices specifying new graphics primitives to a viewport scale cull and clip unit .

The viewport scale cull and clip unit receives geometric data related to an object and executes a viewport transform on the geometric data to produce coordinates for the vertices of the object in two dimensional screen space. A viewport processing unit within the viewport scale cull and clip unit may be configured to perform the viewport transform varying the snap spacing based on the viewport resolution. A certain resolution e.g. width and height in pixels that generally corresponds to a two dimensional grid or space is specified for the viewport transform. The coordinates of the vertices of the object in the two dimensional space have values that correspond to this resolution. Thus for a resolution of 320 240 pixels horizontal coordinates for vertices of an object can range from 0 to 320 and vertical coordinates can range from 0 to 240. For other resolutions coordinates can have different ranges.

Calculations for the viewport transform typically include some rounding. That is coordinates that result from the viewport transform have a certain amount of rounding applied meaning that the results of the calculations for generating the screen space vertices are rounded to a certain precision. The viewport transform also snaps coordinates for the object vertices to a specified sub pixel grid. In other words the screen space positions for the vertices of the object that has had a viewport transform applied are aligned with a grid where the cells or sub pixels of the grid have a size equal to a specified fraction of a pixel for example all cells in the grid may have a size equal to th or 1 64th of a pixel . The snap spacing controls the precision to which vertices are snapped relative to the resolution of the viewport. The snap spacing is the dimension height or width of the cells in the grid and is specified as a fraction of a pixel. The snapping causes the coordinates of an object to be aligned with the sub pixel grid. The results of the viewport transform include the effects of the snapping and rounding and generally include screen space coordinates for each vertex of each object aligned to the sub pixel grid.

The viewport scale cull and clip unit performs clipping culling and viewport scaling and outputs processed graphics primitives to a primitive setup unit . The primitive setup unit computes the edge equation coefficients for each edge of each primitive e.g. start values delta x delta y the edge slopes etc. . When snapping is used an edge may be defined by two of the adjusted i.e. snapped vertices of a primitive.

The setup unit may be configured to compensate for inconsistencies resulting from snapping by enlarging the primitive by the error term and by enlarging the bounding box by the error term. In one embodiment the setup unit determines a starting tile based on the top leftmost vertex. All edge equations are based on the starting tile. At the output of the setup unit the edge coefficients are in fixed point and are exactly precise in all cases. So re referencing the edge equations at this point will not change the primitive location or shape. In other words from the setup unit through the downstream processing unit in the graphics processing pipeline conservative rasterization is consistent.

The error term that is incorporated into the coefficients for the edge equations may take into account the enlarging and also a half pixel shifting needed to make the center pixel sample look like a corner point of each pixel. Note that the half pixel shifting can be performed by either bloating the edges by Y2 pixel or by doing a shift from center to corner. starting tile 16 16 error starting tile 16 6 error The sign of the error term is determined by the edge orientation and direction. Table 1 above shows the configuration for determining the sign.

For conservative rasterization all edges of a primitive are inclusive meaning if the edge lies exactly on the sample point the sample point is on the primitive. Any logic that exists in the setup unit to make the left top edges inclusive and the right bottom exclusive may be capable of being disabled. The bounding box computed by the setup unit is inclusive in terms of the edges however the bounding box may be enlarged by the absolute value of the error terms. If the bounding box sides are snapped to the closest sample point that lies inside the bounding box this shrinking of the bounding box must be disabled. The setup unit may be configured to compute the bounding box dimensions with 8 fractional bits and that are truncated to 4 fractional bits at the output of the setup unit . The truncation may floor the left and top sides of the bounding box and ceiling the right and bottom sides when truncating to 4 fractional bits.

A technique to rasterize zero area primitives may be employed optionally in the context of the setup unit . Initially a primitive having zero area resulting from colinear vertices is identified. A minimum vertex and a maximum vertex of the primitive are determined to define the primitive as a line. Further attributes may be interpolated along the line.

Just by way of example zero area primitives can result in a point or line. They may occur due to snapping or imprecision upstream. Zero area primitive may be processed by setup. Thus zero area primitives may be treated as a point or a line. Even though the primitive is enlarged e.g. by at least 0.5 pixel the setup unit starts with a line. The setup unit may be configured to change from a triangle primitive to line or point mode after the area of the primitive is computed. If all three vertices are collocated a point is drawn and if 2 vertices are collocated a line is drawn. If none of the three vertices are collocated but still zero area the two vertices of the line are the two that lie on the bounding box.

The rasterizer receives the screen space coordinates for vertices of an object and the edge equation coefficients from the primitive setup unit . Thus the edge equation coefficients received by the rasterizer may be those modified to enlarge the primitive. The rasterizer takes primitives and edge equations from the setup unit and evaluates the edge equations provided by the primitive setup unit to determine coverage of samples or pixels for the object. The rasterizer scan converts the new graphics primitives and outputs fragments and coverage data to fragment processing unit . Additionally the rasterizer may be configured to perform z culling and other z based optimizations. In one embodiment the rasterizer may be implemented as a coarse rasterizer that computes coarse coverage information and a fine rasterizer that computes coverage information at a sub pixel granularity.

In some cases it is desirable to have conservative depth e.g. for Z cull conservative compression etc. . Initially a Z anchor for a triangle or tile of pixels is identified. For example there may be a per primitive anchor computed by Setup or optionally from that per primitive anchor fine raster may compute a per tile anchor. The Z anchor is then offset by a predetermined fraction of the pixel to place the Z anchor at a corner of the pixel. Optionally the anchor offset could be applied either in Setup per primitive or in fine raster per tile . The Z anchor placed at the corner of the pixel is then evaluated to provide one of a maximum Z value or a minimum Z value for the pixel.

Just by way of example conservative depth can be accomplished by determining the Z slope direction and evaluating Z at the minimum or maximum corner of a tile. If Z is computed based on plane equation for example if Z is computed as 0 delta  delta  where delta x and delta y describe sample positions evaluation of Z at the minimum or maximum corner can be accomplished by offsetting the Z anchor Z0 by of a pixel toward the minimum or maximum Z for example 00.50.5 to compute the maximum Z per pixel if Z increases with X and decreases with y.

The fragment processing unit is a programmable execution unit that is configured to execute fragment shader programs transforming fragments received from the rasterizer as specified by the fragment shader programs. For example the fragment processing unit may be programmed to perform operations such as perspective correction texture mapping shading blending and the like to produce shaded fragments that are output to raster operations unit . The fragment processing unit . Fragments may be shaded at pixel sample or other granularity depending on the programmed sampling rate.

The raster operations unit is a processing unit that performs raster operations such as stencil z test blending and the like and outputs pixel data as processed graphics data for storage in graphics memory. The processed graphics data may be stored in memory for display or for further processing. In some embodiments of the present invention raster operations unit is configured to compress z or color data that is written to memory and decompress z or color data that is read from memory.

At step the primitive vertex positions are adjusted to a sub pixel grid according to the viewport dependent snap spacing to produce snapped vertex positions. At step the primitives defined by the snapped vertex positions are rasterized.

In one embodiment the PPU includes an input output I O unit configured to transmit and receive communications i.e. commands data etc. from a central processing unit CPU not shown over the system bus . The I O unit may implement a Peripheral Component Interconnect Express PCIe interface for communications over a PCIe bus. In alternative embodiments the I O unit may implement other types of well known bus interfaces.

The PPU also includes a host interface unit that decodes the commands and transmits the commands to the grid management unit or other units of the PPU e.g. memory interface as the commands may specify. In the context of the grid management unit a grid is a quantity of processing work. The host interface unit is configured to route communications between and among the various logical units of the PPU .

In one embodiment a program encoded as a command stream is written to a buffer by the CPU. The buffer is a region in memory e.g. memory or system memory that is accessible i.e. read write by both the CPU and the PPU . The CPU writes the command stream to the buffer and then transmits a pointer to the start of the command stream to the PPU . The host interface unit provides the grid management unit GMU with pointers to one or more streams. The GMU selects one or more streams and is configured to organize the selected streams as a pool of pending grids. The pool of pending grids may include new grids that have not yet been selected for execution and grids that have been partially executed and have been suspended.

A work distribution unit that is coupled between the GMU and the SMs manages a pool of active grids selecting and dispatching active grids for execution by the SMs . Pending grids are transferred to the active grid pool by the GMU when a pending grid is eligible to execute i.e. has no unresolved data dependencies. An active grid is transferred to the pending pool when execution of the active grid is blocked by a dependency. When execution of a grid is completed the grid is removed from the active grid pool by the work distribution unit . In addition to receiving grids from the host interface unit and the work distribution unit the GMU also receives grids that are dynamically generated by the SMs during execution of a grid. These dynamically generated grids join the other pending grids in the pending grid pool.

In one embodiment the CPU executes a driver kernel that implements an application programming interface API that enables one or more applications executing on the CPU to schedule operations for execution on the PPU . An application may include instructions i.e. API calls that cause the driver kernel to generate one or more grids for execution. In one embodiment the PPU implements a SIMD Single Instruction Multiple Data architecture where each thread block i.e. warp in a grid is concurrently executed on a different data set by different threads in the thread block. The driver kernel defines thread blocks that are comprised of k related threads such that threads in the same thread block may exchange data through shared memory. In one embodiment a thread block comprises 32 related threads and a grid is an array of one or more thread blocks that execute the same stream and the different thread blocks may exchange data through global memory.

In one embodiment the PPU comprises X SMs X . For example the PPU may include 15 distinct SMs . Each SM is multi threaded and configured to execute a plurality of threads e.g. 32 threads from a particular thread block concurrently. Each of the SMs is connected to a level two L2 cache via a crossbar or other type of interconnect network .

The L2 cache is connected to one or more memory interfaces . Memory interfaces implement 16 32 64 128 bit data buses or the like for high speed data transfer. In one embodiment the PPU comprises U memory interfaces U where each memory interface U is connected to a corresponding memory device U . For example PPU may be connected to up to 6 memory devices such as graphics double data rate version 5 synchronous dynamic random access memory GDDR5 SDRAM .

In one embodiment the PPU implements a multi level memory hierarchy. The memory is located off chip in SDRAM coupled to the PPU . Data from the memory may be fetched and stored in the L2 cache which is located on chip and is shared between the various SMs . In one embodiment each of the SMs also implements an L1 cache. The L1 cache is private memory that is dedicated to a particular SM . Each of the L1 caches is coupled to the shared L2 cache . Data from the L2 cache may be fetched and stored in each of the L1 caches for processing in the functional units of the SMs .

In one embodiment the PPU comprises a graphics processing unit GPU . The PPU is configured to receive commands that specify shader programs for processing graphics data. Graphics data may be defined as a set of primitives such as points lines triangles quads triangle strips and the like. Typically a primitive includes data that specifies a number of vertices for the primitive e.g. in a model space coordinate system as well as attributes associated with each vertex of the primitive. The PPU can be configured to process the graphics primitives to generate a frame buffer i.e. pixel data for each of the pixels of the display . The driver kernel implements a graphics processing pipeline such as the graphics processing pipeline defined by the OpenGL API.

An application writes model data for a scene i.e. a collection of vertices and attributes to memory. The model data defines each of the objects that may be visible on a display. The application then makes an API call to the driver kernel that requests the model data to be rendered and displayed. The driver kernel reads the model data and writes commands to the buffer to perform one or more operations to process the model data. The commands may encode different shader programs including one or more of a vertex shader hull shader geometry shader pixel shader etc.

The GMU may configure one or more SMs to perform the functions of one or more of the processing units shown in e.g. a vertex processing unit a tessellation processing unit a geometry processing unit and a fragment processing unit. The functions of viewport scale cull and clip processing unit coarse rasterizer fine rasterizer and raster operations unit may also be performed by other processing engines within a GMU .

For example the GMU may configure one or more SMs to execute a vertex shader program that processes a number of vertices defined by the model data. In one embodiment the GMU may configure different SMs to execute different shader programs concurrently. For example a first subset of SMs may be configured to execute a vertex shader program while a second subset of SMs may be configured to execute a pixel shader program. The first subset of SMs processes vertex data to produce processed vertex data and writes the processed vertex data to the L2 cache and or the memory . After the processed vertex data is rasterized i.e. transformed from three dimensional data into two dimensional data in screen space to produce fragment data the second subset of SMs executes a pixel shader to produce processed fragment data which is then blended with other processed fragment data and written to the frame buffer in memory . The vertex shader program and pixel shader program may execute concurrently processing different data from the same scene in a pipelined fashion until all of the model data for the scene has been rendered to the frame buffer. Then the contents of the frame buffer are transmitted to a display controller for display on a display device.

The PPU may be included in a desktop computer a laptop computer a tablet computer a smart phone e.g. a wireless hand held device personal digital assistant PDA a digital camera a hand held electronic device and the like. In one embodiment the PPU is embodied on a single semiconductor substrate. In another embodiment the PPU is included in a system on a chip SoC along with one or more other logic units such as a reduced instruction set computer RISC CPU a memory management unit MMU a digital to analog converter DAC and the like.

In one embodiment the PPU may be included on a graphics card that includes one or more memory devices such as GDDR5 SDRAM. The graphics card may be configured to interface with a PCIe slot on a motherboard of a desktop computer that includes e.g. a northbridge chipset and a southbridge chipset. In yet another embodiment the PPU may be an integrated graphics processing unit iGPU included in the chipset i.e. Northbridge of the motherboard.

As described above the work distribution unit dispatches active grids for execution on one or more SMs of the PPU . The scheduler unit receives the grids from the work distribution unit and manages instruction scheduling for one or more thread blocks of each active grid. The scheduler unit schedules threads for execution in groups of parallel threads where each group is called a warp. In one embodiment each warp includes 32 threads. The scheduler unit may manage a plurality of different thread blocks allocating the thread blocks to warps for execution and then scheduling instructions from the plurality of different warps on the various functional units i.e. cores DPUs SFUs and LSUs during each clock cycle.

In one embodiment each scheduler unit includes one or more instruction dispatch units . Each dispatch unit is configured to transmit instructions to one or more of the functional units. In the embodiment shown in the scheduler unit includes two dispatch units that enable two different instructions from the same warp to be dispatched during each clock cycle. In alternative embodiments each scheduler unit may include a single dispatch unit or additional dispatch units .

Each SM includes a register file that provides a set of registers for the functional units of the SM . In one embodiment the register file is divided between each of the functional units such that each functional unit is allocated a dedicated portion of the register file . In another embodiment the register file is divided between the different warps being executed by the SM . The register file provides temporary storage for operands connected to the data paths of the functional units.

Each SM comprises L processing cores . In one embodiment the SM includes a large number e.g. 192 etc. of distinct processing cores . Each core is a fully pipelined single precision processing unit that includes a floating point arithmetic logic unit and an integer arithmetic logic unit. In one embodiment the floating point arithmetic logic units implement the IEEE 754 2008 standard for floating point arithmetic. Each SM also comprises M DPUs that implement double precision floating point arithmetic N SFUs that perform special functions e.g. copy rectangle pixel blending operations and the like and P LSUs that implement load and store operations between the shared memory L1 cache and the register file . In one embodiment the SM includes 64 DPUs 32 SFUs and 32 LSUs .

Each SM includes an interconnect network that connects each of the functional units to the register file and the shared memory L1 cache . In one embodiment the interconnect network is a crossbar that can be configured to connect any of the functional units to any of the registers in the register file or the memory locations in shared memory L1 cache .

In one embodiment the SM is implemented within a GPU. In such an embodiment the SM comprises J texture units . The texture units are configured to load texture maps i.e. a 2D array of texels from the memory and sample the texture maps to produce sampled texture values for use in shader programs. The texture units implement texture operations such as anti aliasing operations using mip maps i.e. texture maps of varying levels of detail . In one embodiment the SM includes 16 texture units .

The PPU described above may be configured to perform highly parallel computations much faster than conventional CPUs. Parallel computing has advantages in graphics processing data compression biometrics stream processing algorithms and the like.

The system also includes input devices a graphics processor and a display i.e. a conventional CRT cathode ray tube LCD liquid crystal display LED light emitting diode plasma display or the like. User input may be received from the input devices e.g. keyboard mouse touchpad microphone and the like. In one embodiment the graphics processor may include a plurality of shader modules a rasterization module etc. Each of the foregoing modules may even be situated on a single semiconductor platform to form a graphics processing unit GPU .

In the present description a single semiconductor platform may refer to a sole unitary semiconductor based integrated circuit or chip. It should be noted that the term single semiconductor platform may also refer to multi chip modules with increased connectivity which simulate on chip operation and make substantial improvements over utilizing a conventional central processing unit CPU and bus implementation. Of course the various modules may also be situated separately or in various combinations of semiconductor platforms per the desires of the user.

The system may also include a secondary storage . The secondary storage includes for example a hard disk drive and or a removable storage drive representing a floppy disk drive a magnetic tape drive a compact disk drive digital versatile disk DVD drive recording device universal serial bus USB flash memory. The removable storage drive reads from and or writes to a removable storage unit in a well known manner.

Computer programs or computer control logic algorithms may be stored in the main memory and or the secondary storage . Such computer programs when executed enable the system to perform various functions. For example a compiler program that is configured to examiner a shader program and enable or disable attribute buffer combining may be stored in the main memory . The compiler program may be executed by the central processor or the graphics processor . The main memory the storage and or any other storage are possible examples of computer readable media.

In one embodiment the architecture and or functionality of the various previous figures may be implemented in the context of the central processor the graphics processor an integrated circuit not shown that is capable of at least a portion of the capabilities of both the central processor and the graphics processor a chipset i.e. a group of integrated circuits designed to work and sold as a unit for performing related functions etc. and or any other integrated circuit for that matter.

Still yet the architecture and or functionality of the various previous figures may be implemented in the context of a general computer system a circuit board system a game console system dedicated for entertainment purposes an application specific system and or any other desired system. For example the system may take the form of a desktop computer laptop computer server workstation game consoles embedded system and or any other type of logic. Still yet the system may take the form of various other devices including but not limited to a personal digital assistant PDA device a mobile phone device a television etc.

Further while not shown the system may be coupled to a network e.g. a telecommunications network local area network LAN wireless network wide area network WAN such as the Internet peer to peer network cable network or the like for communication purposes.

While various embodiments have been described above it should be understood that they have been presented by way of example only and not limitation. Thus the breadth and scope of a preferred embodiment should not be limited by any of the above described exemplary embodiments but should be defined only in accordance with the following claims and their equivalents.

