---

title: Stateful reference monitor
abstract: A Stateful Reference Monitor can be loaded into an existing commercial operating system, and then can regulate access to many different types of resources. The reference monitor maintains an updateable storage area whose contents can be used to affect access decisions, and access decisions can be based on arbitrary properties of the request.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09141812&OS=09141812&RS=09141812
owner: Cisco Technology, Inc.
number: 09141812
owner_city: San Jose
owner_country: US
publication_date: 20131125
---
This application claims the benefit under 35 U.S.C. 120 as a continuation of application Ser. No. 11 865 344 filed Oct. 1 2007 now U.S. Pat. No. 8 595 170 which is a continuation of application Ser. No. 10 071 328 filed Feb. 8 2002 issued as U.S. Pat. No. 7 290 266 on Oct. 30 2007 which claims priority under 35 U.S.C. 119 e to provisional application 60 298 590 filed Jun. 14 2001 the entire contents of which are hereby incorporated by reference for all purposes as if fully set forth herein.

The present invention related generally to software that controls an operating policy of a computer system. For example access to various system resources such as files and network connections may be so controlled.

Modem computer systems are controlled by two levels of software an operating system and application software. The operating system maintains a separation in the memory of the computer between the operating system said to execute in operating system space and the applications said to execute in applications space.

Applications are the software that provides solutions to business problem such as processing e mail messages. Applications perform their work by communicating requests for access to resources such as network connections or files stored on a storage medium to the operating system which then fills these requests.

It may be desired to control anyone or more of a wide variety of operating policies. One common scenario is to control access to various system resources as mentioned above for purposes of securing a system against deliberate and malicious attack or for purposes of ensuring correct and non interfering operation of various processes. For purposes of illustration access control for security purposes is discussed. However the skilled artist will understand that the discussion has wider implications as explicitly pointed out and as implied in the following discussion.

Referring to the example of security systems access is conventionally controlled by one or more real time processes while policy is independently established with the assistance of one or more non real time processes. In the context of this description a real time process is one whose action is sufficiently immediate as to imperceptibly affect the speed at which transactions with which the real time process is connected are processed. A non real time process is one that processes transactions at a speed substantially slower than the instantaneous rate at which transactions naturally occur.

Real time access control processes and data structures include but are not limited to reference monitors access control lists permissions flags access tokens and process ID checking.

A reference monitor is a component of a computer system that determines whether an access by one component for example a user process of another component for example a file is permitted.

As used hereinafter dynamic state is a collection of information that is collected in real time indicative of a condition of a machine or process as a result of a particular sequence of events leading to the condition. A stateless system or component is one which does not collect such data.

Conventional reference monitors herein referred to as stateless reference monitors are found in the kernels of various Operating Systems including for example MicroSoft Windows 2000 or UNIX. They are used to determine whether a particular access to a file or other resource is permitted.

Conventional operating systems contain embedded stateless reference monitors to control access to resources. User processes are started and identified to users on the basis of the user supplying certain identity tokens. In most cases the access decision is made based on the identity of the user whose local program or process makes the request and one or more static permissions flags or an access control list associated with the resource. For examples see Unix or Windows 2000. The contents of static permissions flags and access control lists do not include information representing the current state of the system but rather include information that produces identical results regardless of the state of the system.

Most conventional reference monitors deals with a single resource type such as files or network connections . Some such as eTrust Access Control v.5.1 from Computer Associates protect multiple resource types.

Some operating systems give finer control by associating individual permissions with each user and then checking those permissions against the static access control list of the resource. This is an improvement but typically there are only a limited number of permission flags. Security Enhanced Linux is an example of such an operating system.

There are operating systems that are even finer grained and allow individual users to offer a set of tokens and if any match those found in the access control list then access is granted.

There are operating environments that can include the origin of the requesting program in their access control decision. For example see Dan Wallach and Edward Felton Understanding Java Stack Inspection IEEE Proceedings of Security Privacy May 1998.

Non real time processes are conventionally employed to collect date and analyze past events in order to establish or modify effective policies for example security policies. Typical conventional non real time processes include intrusion detection systems for example.

One type of intrusion detection system is an autonomous agent that polls monitors and or periodically mines log files for data indicative of an intrusion. A drawback of such non real time systems is that intrusions are only detected after the fact. The intruder leaves an audit trail of actions recorded in log files and elsewhere for which the only reasonable explanation is an intrusion. However by the time such a non real time intrusion detection system identifies an intrusion the intruder is long gone and damage done.

For examples see Peter G. Neumann and Phillip A. Porras Experience with EMERALD to Date 1st USENIX Workshop on Intrusion Detection and Network Monitoring April 1999 Eugene Spafford et al. Intrusion detection using autonomous agents Computer Networks 34 2000 and Steven R. Snapp et al. DIDS Distributed Intrusion Detection System Motivation Architecture and An Early Prototype Proceedings of the 14th National Computer Security Conference October 1991.

The analysis performed by intrusion detection systems such as have been described or referred to above is useful for developing policies to be enforced by real time components such as also described above. For example there are reference monitors who can follow more complex rules based on patterns mined by an intrusion detector from past behavior but they cannot update their state on each controlled request. For example see Debra Anderson et al. Next generation Intrusion Detection Expert System NIDES A Summary SRI International May 1995.

The rise of network computing with the attendant dangers of remote hackers renders the access control decision more difficult. Most systems base their access control decisions on the identity of the local requesting program which is tied to a particular user as noted above and not on the presumably unknown identity of the remote hacker.

Moreover conventional systems constructed of obvious combinations of the foregoing do not detect or control access based on pattern of behavior that cross the lines between diverse users processes access types etc. Conventional systems constructed of obvious combinations of the foregoing do not adjust policies dynamically in real time in response to newly experienced threats.

Conventional systems suffer from a lack of dynamic state inherent to stateless reference monitors and that they are not very resilient in the face of local application programming errors through which a remote attacker can subvert a trusted local program. Application programming errors i.e. bugs will always continue to exist as the programmers are fallible and the testing cannot reasonably anticipate all manner of malicious attacks.

When conventional reference monitors are used once an attacker has managed to subvert a local application the attacker typically has all the rights and privileges of that application. In the case of an e commerce server this may include the ability to look at transaction histories and the associated credit card information.

Finally as already discussed above conventional systems cannot detect and react to attacks in which diverse parts of the attack are performed by seemingly normal operations of diverse programs or processes that only form the attack when taken in combination.

The present invention provides an improved system method and software product for controlling an operating policy of a computer system such as a security policy. According to one aspect of an embodiment of the invention a real time reference monitor software produce comprises on a machine readable medium a sequence of instructions defining a storage area where real time state information is stored and from which the state information is restored a plurality of rules defining allowable activity based on a pattern of activity and plural interceptors identifying and governing the activity based on an application of the rules to the activity. The software product may include a process which correlates the state information across different ones of the plural interceptors. At least one of the plural interceptors can be a pre existing element of a conventional computer operating system. The process which correlates the state information can include a rule which defines permissible resource references in view of activity identified by the interceptors resource reference and the state information and a rule interpreter which applies the rule to the activity identified and the state information. The rule can be modified without restarting the real time reference monitor. The plural reference interceptors can correspond to more than one resource type and wherein the storage area is a single storage area. The storage area contents can be preserved when the rules are modified. The software product can further include an application program interface that can send messages to application programs on the same system. The software product can also further include an application program interface that can send messages to application programs on other systems. The plural reference interceptors can monitor two or more of file access registry access network access object access system call access keyboard access external inputs and user input. According to another aspect of an embodiment of the invention a computer implemented reference monitor includes a monitoring process executing on a computer which detects plural defined events and generate event messages a storage device on the computer in which is stored information related to the event messages generated by the monitoring process and a rule interpreting process executing on the computer which responds to characteristics of an event message the information stored in the storage device and a set of rules by modifying operation of the computer. The set of rules can be modified in response to the information stored in the storage device. The set of rules can be modified and wherein information stored in the storage device is preserved when the set of rules is modified. Finally an external event message generating process can execute on another computer and can communicate event messages to the rule interpreting process.

According to yet another aspect of an embodiment of the invention a method of implementing a processing policy on a computer includes detecting first and second events each having one of a plurality of defined event types generating first and second event messages each containing information about a corresponding one of the first and second events storing the information about the first event and enforcing the policy responsive to the stored information about the first event and the information about the second event. The method may further include applying one of a set of rules to the stored information about the first event and the information about the second event to determine the nature of enforcing the policy. The method may yet further include executing an operating system on the computer changing the set of rules without restarting the operating system and without losing the stored information. Finally the method may include changing the set of rules without interrupting the detecting generating storing and enforcing.

The invention will be better understood upon reading the following detailed description of various aspects of embodiments thereof.

Aspects of an embodiment of the invention are now illustrated in connection with . The exemplary embodiment is in the computer system security field but the invention can readily be embodied in systems in other fields of endeavor as will be evident to the skilled artisan.

In computers one important aspect of system security is monitoring system events e.g. access requests to a resource and controlling the effect of those events e.g. blocking or allowing the requested access to a resource. In order to monitor events interceptors are inserted in the control or communication paths traversed by those events. For example if an event monitored is a network access request the interceptor is inserted in the operating system at a point where the network access request is communicated from one portion of the operating system to another. The interceptor generates an event message for each event intercepted. Event messages are communicated to a stateful reference monitor which returns a policy message to the interceptor . The policy message may be an action for the interceptor to take such as allowing an access request event to continue along the control or communication path to have its intended effect or not allowing the event to pass along path . External event messages generated by other unspecified event monitors can also be processed by the stateful reference monitor . The stateful reference monitor also communicates with a user console and log files .

The stateful reference monitor of is now explained in further detail in connection with . An exemplary reference monitor is designed to run as part of the operating system as a driver. The exemplary reference monitor is referred to herein as a stateful reference monitor because it retains and relies on changing system state information in implementing decision policies as explained below. The stateful reference monitor communicates with other parts of the operating system and with applications through communication channels. One channel carries event messages and policy messages as discussed above. The other channel carries external event messages as well as other messages to and from application space including but not limited to messages to and from the user console and logs .

Communication channel transfers messages into and out of the stateful reference monitor through a rule application programming interface API . Communication channel transfers messages into and out of the stateful reference monitor through a user API .

Within the stateful reference monitor messages of all kinds but particularly event messages and external event messages are routed and directed by an event router between the rule API the user API and other components of the stateful reference monitor . The event router is the communication center of the stateful reference monitor directing and controlling all internal communication.

The primary operational logic of the stateful reference monitor is contained in the rule interpreter which also makes use of the contents of a state database and of compiled rule byte code . The rule interpreter can be a small straightforward piece of logic that can be made extremely bug proof by design. The state database is simply a repository of dynamic state information and thus also easily bug proofed. The state database may reside at least in part in a persistent memory or storage location so that it survives an operating system reboot.

The compiled rule byte code represents the operational policies to be enforced and against which activities and state in the system are checked. As such much of the complexity of the system can reside in the byte code . Although the byte code also should yield to design techniques that reduce or eliminate bugs it is worth noting that bugs in the byte code cannot cause the operating system to crash but can merely result in improper policy decisions. Thus a more robust system results from the partitioning of the rules into the byte code and the interpretive logic into the rules interpreter .

State information can be but is not limited to information that a certain event occurred within a certain time of the present time. Suppose a prohibited combination of events is denoted X Y Z. That is Event X Event Y and Event Z must occur within a certain time frame to produce a bad result. Then if the state database holds information X Y a rule in byte code will prohibit Z. But another rule in byte code will cause event X and or event Y to be purged from state database after a suitable time. Events X Y and Z need not be associated with the same user or process or may be so associated depending upon the type of behavior to be controlled. Finally the stateful reference monitor includes mappable memory to aid with communication between the stateful reference monitor and applications in application space or accessible through a network . Mappable memory is simply a portion of system memory addressable by both the stateful reference monitor and other applications such that data transfer may be easily accomplished by writing to and reading from a predetermined location without requiring special communication apparatus mechanisms or protocols.

Interceptors like the stateful reference monitor are also implemented in the exemplary embodiment as drivers loaded with but independent of the operating system kernel. Interceptors interact with the operating system at a very low level by intercepting various types of operating system requests etc. referred to herein as events for example requests for access to operating system resources such as a file or network connection. When an interceptor intercepts an event it generates an event message as discussed above. Each intercepted event is treated by the stateful reference monitor as a request for an interpretation of the event in light of the rules represented by the rules byte code and the contents of the state database . The result of the stateful reference monitor applying the rules contained in the byte code to the event message and the contents of the state database is a policy message which is sent to the interceptor . The interceptor then implements the contents of the policy message for example blocking or allowing a resource access.

Interceptors can take other forms as well. They may simply be APIs allowing the stateful reference monitor to observe some aspect of operating system behavior and to modify that behavior accordingly. For example with suitable modification an interceptor can detect an operating system performance characteristic and tune a related parameter in response.

Interceptors need be inserted only in paths affecting resources important to the purpose for which the stateful reference monitor is intended. In a security application such resources may include but are not limited to one or more of Windows Registry access requests network access request windows system directory access requests and Outlook personal address books access requests. Interceptors can also extract inputs from other sources such as a virus scanner log file.

As indicated above access to user level applications or to the stateful reference monitor through user level applications is given through the application space . A graphical user interface GUI running on a user console may give the user access to the stateful reference monitor for example to monitor performance to view logs and to adjust operational parameters and policies. The GUI accessed through the user console may be a conventional browser for example or may be a proprietary software program designed for the purpose. A database or file system holding operational logs error logs and the like is also accessible through application space . The use of logs and the specific types of logs used will be defined by the skilled artisan based upon specific individual requirements. Network connections are also accessed by the stateful reference monitor through application space . These network connections are those over which external event messages arrive.

Now the detailed operation of the stateful reference monitor is described. Operations may be divided into two classes normal operations and boot time operations.

During normal operations an event is intercepted by an interceptor and an event message transmitted to the stateful reference monitor . Events which are normally passed on to other parts of the operating system such as file access requests and network connection requests are temporarily held up by the interceptor so that they do not have their ordinary immediate effect while the stateful reference monitor makes a decision based on the processing policy then in effect as to whether to block or allow the event to be transmitted.

Event messages from the interceptors are received in the stateful reference monitor by the rule API . The rule API is a simple interface for receiving and transmitting messages to interceptors which may be specially written for compatibility with the stateful reference monitor or may be a packaged component of the operating system or may be provided by any party as an add on component. The rule API simply passes event messages on to the event router . As will be seen below the rule API also passes messages out from the event router to the interceptors when required.

The event router queues messages for the receiving components of the stateful reference monitor according to priority. In the case of event messages priority may be based on event type for example. Thus a network access event that may be time sensitive may be processed ahead of a file access event that has no such time sensitivity.

Events are identified in the event messages to the application which produced the event rather than the user as is customary in conventional systems which allows policies to be set and executed orthogonal to the user community. This is in contrast to those conventional systems in which processing policies such as security and access control policies operate on the basis of the user generating an event and the rights and privileges attributed to that user.

Queued events are picked up in priority order by the rule interpreter for processing. First the rule interpreter determines whether the event described by the event message is of a type designated as part of the dynamic state information to be stored in the state database .

If so then information about the event is stored in the state database . The information stored may include some or all of but not necessarily limited to time of the event type of event application generating the event user owning the application and the like.

Next the type of the event determines which segment of the compiled rules byte code will be addressed by the rule interpreter . Within the segment of the compiled rules byte code the rule interpreter executes a switch function based on the opcode.

A significant performance improvement may be obtained by optimizing the argument of the foregoing switch Opcode statement. Switch statements are most efficient when the expected cases are consecutive integers beginning with . Therefore in order to manage the values of opcodes that must be handled by the switch function in the rule interpreter the opcodes are translated by the following pseudo code before the byte code is first used 

Boot time operation is similar to normal operation except that different rules may be followed especially in security applications in order to specialize policies for what could be a particularly vulnerable process. Moreover specialized boot time rules can be extremely simple and tightly written because the boot time operating system environment is highly controlled.

In order to provide different sets of rules at different times the compiled rule byte code is stored in a data structure that permits selection between an active rule set and inactive rule sets by use of a software switch as is known in the art. Thus the system is assured to be running only one set of rules at a time not a mixture of rules. Moreover when rules are loaded various processes such as rule checks can be performed. This arrangement is particularly advantageous for having different sets of rules operative during boot time than other times. The rules need not all be stored and loaded at boot up thus saving space and time. Boot time rules can be stored in and loaded from the Windows based system. Later the rules for use when boot up is done can be loaded from a network resource or from a file. In general rules byte code is a downloadable program and rules interpreter is a virtual machine. Thus the rules can be changed at any time without shutting down or restarting the operating system. In an alternate arrangement the compiled rule byte code can be stored in a fixed location that can be overwritten easily without shutting down the stateful reference monitor or rebooting the operating system.

As indicated above various types of patterns of events can be programmed into the rules byte code for detection and action. A simple combination X Y Z was given as an example earlier. However the rules can also identify as a prohibited pattern any pattern not seen before. This type of rule is useful in an environment where the system can first be profiled i.e. operated in a state collection mode wherein normal combinations and patterns of activity are stored in state database . Such a system is subsequently placed into a lockdown mode wherein both pre programmed patterns and unusual patterns are detected and acted upon. This type of profiling is preferably done in the environment in which the system will be operated so as to capture the true range of behavior. Rules can also be tightened or relaxed dynamically through user manipulation of the bye code through a suitable program interface at the user console .

In addition to policy messages and communication with the user console the stateful reference monitor can generate a variety of levels of warning and alarm at least some of which permit the user to select whether to allow a questionable action or not. This feature is generally useful but has particular use in a system which was profiled as described above. Once in lockdown there may still be unseen but nominally safe behaviors that the user can pass judgment on. The stateful reference monitor alerts the user as to the condition and can record the behavior as permissible or not depending on the rules defined in byte code .

An embodiment of the invention is now described in connection with securing computer systems against malicious users and software.

Security of computer systems is enhanced by using a stateful reference monitor that can make use of saved state including previous access control decisions in making new decisions. The illustrative stateful reference monitor integrates and correlates the access requests for a number of different resource types files system configuration information network access system calls local or remote object invocation etc. This comprehensive view into the operating environment enables the stateful reference monitor to make better access control decisions than a conventional single resource type stateless reference monitor.

The stateful reference monitor detects anomalous behavior and prevents further accesses. For example if an e commerce server has once been subverted it will subsequently behave differently and this can be detected as a departure from normal.

The stateful reference monitor uses a state database to hold information for periods of time and uses this information to improve the quality of its decisions.

As described above the stateful reference monitor intercepts the access requests using interceptors inserted into the request path. These interceptors are implemented using a variety of mechanisms depending on the resource type and operating system. For example under Windows NT 

On other operating systems there may be other resources that need protecting and some of the examples above may not be applicable. However the general approaches of either using an operating system provided interception API or replacing function pointers with alternative interception code may be used. Other approaches can be used for example that involve patching the actual function code to make callouts.

The stateful reference monitor acts as an additional processing step over and above any existing stateless reference monitor in the operating system. Thus it cannot grant access when the standard stateless reference monitor would have denied access.

The rules which control the actions of the stateful reference monitor can be modified and take instant effect. The contents of the storage area can be modified as part of this process.

The stateful reference monitor can prompt the user when marginal situations occur. This provides valuable additional information to make correct decisions.

Other events can be received from local and remote sources including control servers local operating system logs application logs application monitors and other system monitors. These events can then modify the contents of the state database which has the effect of potentially changing future access control decisions.

The stateful reference monitor receives a request for example from one of the following sources an interceptor a user prompt response a regular timer a user space daemon or the central server.

This request is broken down into fields and each field is copied into a separate location in the state database . Additionally the type of request is noted.

The stateful reference monitor then starts to execute the security policy. One embodiment uses a byte code interpreter to step through the security policy implementation. The byte code can perform simple actions such as examining a location in the storage area and then performing arithmetic computations or complex actions such as formatting and sending an event to another component. Other languages and methods of expressing security policy are possible.

An optimization is to split the byte code program into a number of smaller and simpler byte code programs where each one handles a particular subset of requests. For example each program might handle requests for a specific resource type. This reduces the number of byte code instructions that need to be inspected for each request.

Alternative embodiments include directly executing machine level instructions but while the performance of such an approach would be better than using byte code the disadvantage of complexity and the difficulty of adequately securing the machine code from attack make direct comparison difficult.

The byte code can modify locations in the storage area to record results either temporarily or permanently for use by subsequent requests. Results may be recorded for a period of time after which the result will be erased. This is useful when trying to detect when a sequence of actions takes place within a specific period of time.

Once the byte code is complete and the request is to either allowed or denied the stateful reference monitor responds to the interceptor and passes back the access determination.

If the request is to be queued then it is placed in a queue for subsequent analysis. This can happen when the user needs to be prompted for some information or when an operation needs to be performed by a user daemon before the final result of the request can be determined. In these cases the stateful reference monitor will be triggered again by the user response or by a user daemon with additional information. The byte code will be invoked and it will detect that this request is associated with a previously queued request. The information received as part of the request is saved in the storage area.

The previously queued request is then woken up and is resubmitted to the byte code portion of the stateful reference monitor. The byte code processes the original request but it now has the saved information in the storage area from the user response. This allows it to complete the processing of the request and allow or deny response.

The stateful reference monitor ensures that requests are ordered i.e. a request either happens before or after another request. Further a request is run through the byte code completely i.e. until the allow deny queue response is found before the next request can start. This simplifies the implementation of both the stateful reference monitor and of the security policies.

The security policy may be written in a C like language that is compiled into byte code and loaded into the stateful reference monitor. Other embodiments could use a different source language or could compile into different code formats including machine code.

The security policy contains data about resource names e.g. file names network ports object names etc. that need to be protected. An alternative would be to split the data from the program and load them independently. The single program with embedded data approach is simpler.

The security policy program contains handlers for all the possible events that it can receive. Some of these handlers just return an allow or deny response while others just cause the storage area to be updated and some are a mixture.

The security policy program can be reloaded while the system is operational. This does not cause the storage area to be modified and so information that was saved before the policy program was reloaded continues to be available. A special request is triggered as the first request after a reload and this request can perform any storage area cleanup or modification that is required.

The stateful reference monitor of the illustrative embodiment calls on a user daemon to perform various services that are either time consuming or difficult to perform in kernel space. These services are invoked by the stateful reference monitor sending a message to the user daemon and queuing the request. The user daemon processes the message performs the requested service and sends a message back to the stateful reference monitor which then saves the result and wakes up the original request.

The stateful reference monitor can be loaded with a set of rules that prevent incoming email messages from automatically sending out copies of them. This can be achieved by noting when an email client detected by monitoring network accesses writes out a file detected by monitoring file accesses while file is then read in by a scripting program detected by monitoring file accesses which then invokes an email sender detected by object invocation or other means which then reads in the original file detected by file access. At this point the user can be queried and the action allowed or denied. In order to detect this chain of events requires the maintenance of significant amounts of state.

However this example does not prevent the script embedded within the email from causing damage to the host computer. In order to prevent damage an additional step is performed. At the final stage above a message is sent to a management server which may then notify other stateful reference monitors that this script is to be blocked from access. The security policy program that is in effect at each stateful reference monitor decides how to handle the notification message. It may for example block all further writes to files once a process tries to write to a restricted file.

In addition to the variations and aspects described above embodiments of aspects of the invention can also include the following.

Multiple stateful reference monitors may be instantiated on a single system each with a Storage Area and a communications mechanism that permits the exchange of information either directly or via another component. The stateful reference monitors might be partitioned based on resource type or based on kernel space versus user space.

A stateful reference monitor can send configuration information to an interceptor to increase or decrease the number and types of requests sent. For example the stateful reference monitor be able to change dynamically whether the CreateProcess system call under Windows NT is to be intercepted and whether requests to this system service are sent to the stateful reference monitor.

A stateful reference monitor may have its security policy program updated frequently to incorporate new dynamic rules rather than having a relatively static policy program and frequently updated state database.

A stateful reference monitor may either replace or wrap the existing stateless reference monitors provided by the operating system.

A computer system shown in with which the various elements of the embodiments described above either individually or in combination may be implemented typically includes at least one main unit connected to both one or more output devices which store information transmit information or display information to one or more users or machines and one or more input devices which receives input from one or more users or machines. The main unit may include one or more processors connected to a memory system via one or more interconnection mechanisms such as a bus or switch. Any input device and output device also are connected to the processor and memory system via the interconnection mechanism . The computer system may further include a storage system in which information is held on or in a non volatile medium. The medium may be fixed in the system or may be removable.

The computer system may be a general purpose computer system which is programmable using a computer programming language. Computer programming languages suitable for implementing such a system include procedural programming languages object oriented programming languages combinations of the two or other languages. The computer system may also be specially programmed special purpose hardware or an application specific integrated circuit ASIC .

In a general purpose computer system the processor is typically a commercially available processor which executes a program called an operating system which controls the execution of other computer programs and provides scheduling debugging input output control accounting compilation storage assignment data management and memory management and communication control and related services. The processor and operating system defines computer platform for which application programs in other computer programming languages are written. The invention is not limited to any particular processor operating system or programming language.

The storage system shown in greater detail in typically includes a computer readable and writeable nonvolatile recording medium in which signals are stored that define a program to be executed by the processor or information stored on or in the medium to be processed by the program. The medium may for example be a disk or flash memory. Typically in operation the processor causes data to be read from the nonvolatile recording medium into another memory that allows for faster access to the information by the processor than does the medium . This memory is typically a volatile random access memory such as a dynamic random access memory DRAM or static memory SRAM . It may be located in storage system as shown or in memory system not shown. The processor generally manipulates the data within the integrated circuit memory and then copies the data to the medium after processing is completed. A variety of mechanisms are known for managing data movement between the medium and the integrated circuit memory element and the invention is not limited thereto. The invention is not limited to a particular memory system or storage system .

Aspects of embodiments of the invention may be implemented in software or hardware or firmware or any combination thereof. The various elements of an embodiment either individually or in combination may be implemented as a computer program product including a computer readable medium on which instructions are stored for access and execution by a processor. When executed by the computer the instructions instruct the computer to perform the various steps of the process.

The present invention has now been described in connection with a number of specific embodiments thereof. However numerous modifications which are contemplated as falling within the scope of the present invention should now be apparent to those skilled in the art. Therefore it is intended that the scope of the present invention be limited only by the scope of the claims appended hereto.

