---

title: Management of mixed programming languages for a simulation environment
abstract: A system and a method for simulation using multiple programming languages is provided. The method can include receiving an annotated source having a first plurality of instructions written in a first programming language and receiving an annotation having a second plurality of instructions written in a second programming language and associated with an annotated instruction from the first plurality of instructions. The method can include extracting the second plurality of instructions to create a routine from the annotation. The method can include building a shared library that contains the routine. The method can include building an application object file by assigning an address to each instruction of the first plurality instructions. The method can include creating an annotation table that contains an address for the annotated instruction and an associated symbol.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09134966&OS=09134966&RS=09134966
owner: International Business Machines Corporation
number: 09134966
owner_city: Armonk
owner_country: US
publication_date: 20131212
---
This disclosure generally relates to programming of computing systems and in particular to managing programming languages in a simulation environment. Although computer programming in the modern era is dominated by programming in high level languages such as C and Java many instances still arise where programming is done in assembly language. Critical computational kernels may benefit from hand tuning as assembler routines especially if they use architecture specific instructions that are not supported by compilers. The core code of any operating system or real time kernel may include at least some assembly language for context management and interrupt handling. Space constrained embedded applications may be programmed in assembly language to give the programmer full control over the size and performance of the final binary. Some embedded environments may not support high level language compilers at all leaving assembly language as the remaining programming option. Therefore systems and methods for assembly language programming have wide practical importance.

Consistent with embodiments of the disclosure a method and system for simulation using multiple programming languages resource is provided.

In certain embodiments of the disclosure a method can be directed toward simulation using multiple programming languages. The method can include receiving an annotated source having a first plurality of instructions written in a first programming language and receiving an annotation having a second plurality of instructions written in a second programming language and associated with an annotated instruction from the first plurality of instructions. The method can include extracting the second plurality of instructions to create a routine from the annotation. The method can include building a shared library that contains the routine. The method can include building an application object file by assigning an address to each instruction of the first plurality instructions. The method can include creating an annotation table that contains an address for the annotated instruction and an associated symbol. The method can include creating a symbol table that links the associated symbol to the routine in the shared library.

In embodiments of the disclosure a method can be directed toward simulating an execution of an application object file having a high level programming language element and an assembly programming language element. The method can include uploading the application object file that contains instruction addresses for first instructions written in assembly programming language and a shared library that contains a routine that contains second instructions written in a high level programming language. The method can include receiving as part of executing the first instructions an instruction address for one of the first instructions. The method can include accessing an annotation table that contains an instruction address for the received instruction address and an associated symbol. The method can include comparing the received instruction address to at least one instruction address in the annotation table. The method can include accessing in response to the comparison a symbol table that links the associated symbol to the routine in the shared library. The method can also include executing the routine from the shared library.

Various embodiments of the disclosure are directed toward a system for managing a high level programming language on a simulator. The system can include a pre processor module operating on one or more computer processors. The pre processor module can be configured to receive an annotated assembler source file that contains instruction addresses for first instructions written in assembly programming language and a shared library that contains a routine that contains second instructions written in a high level programming language. The pre processor module can be configured to extract a routine containing the second instructions from the annotated assembler source file into an extracted routine file using an extraction script. The system can also include a build engine operating on one or more computer processors. The build engine can be configured to create an application object file from the annotated assembler source file. The build engine can be configured to create an annotation shared library from the extracted routine file and from a symbol table of the application object file. The system can also include an annotation manager operating on one or more computer processors. The annotation manager can be configured to load the annotation shared library and the application object file. The annotation manager can be configured to receive an instruction address from a simulator that indicates a first instruction on the application object file. The annotation manager can be configured to access an annotation table that associates an annotation table address with the extracted routine file in the annotation shared library. The annotation manager can be configured to compare the instruction address with the annotation table address. The annotation manager can be configured to access in response to the comparison a routine in the extracted routine file from the annotation shared library. The annotation manager can be configured to execute the routine from the annotation shared library.

Aspects of the present disclosure are directed toward a method and system of implementing in a simulation the association of a routine written in a high level language with assembler instructions written in an assembly language.

Embodiments of system can aid in the successive transformation of high level language algorithms into equivalent assembly language programs for cases where no compiler for the target machine exists add assertions and other verification constructs to assembly language that do not alter the final target binary and add various forms of debugging procedures to assembly language programs that again do not alter the final binary 

Embodiments of the present disclosure can be implemented using a method to prepare files for use in the simulator and a method to simulate the instructions and routines from the files. Particular embodiments are directed toward preparing files in a manner that allows for assembly language to be annotated with higher level code and without the use of instructions that alter the target binary generated from the assembly language. During simulation the annotations can be used to trigger the execution of functions written in the higher level code. The preparation can include extracting the routines written in a high level language from an annotated assembler source file. The preparation can include associating the routine with an address of the instruction from the annotated assembler source file. The simulation can include executing the routine when the address is used. Although not necessarily limited thereto embodiments of the present disclosure can be appreciated in the context of using high level language routines in an assembly language simulation.

Aspects of the present disclosure can facilitate difficulties in verification and debugging of assembly programming. Programmers can annotate their high level language code with assertions and print statements to check important invariants and provide detailed traces of the execution of a program to help locate bugs. These approaches may not be practical or even possible with assembler programs in embedded environments. Adding an inline assertion or a call to a logging routine in an assembler program can consume space may only be possible if an output device or file system is available to capture the logs and may radically alter the program depending on whether verification support is present or not alterations normally assumed to be correct when high level language compilers are used to implement similar support. Debugging with an external debugging tool may be difficult for proprietary embedded controller architectures e.g. without a significant development effort to create hardware and or software interfaces to the debugger.

According to embodiments of the present disclosure assembler programs can be annotated with snippets of code written in a high level language that can be referred to as annotations or hooks. The term hook can be used to refer to an annotation throughout the disclosure. The annotations can be executed in the context of the Instruction Set Simulator ISS used to simulate the assembly language program during development and debugging and modern programming infrastructures may allow the annotations to be written in virtually any language. For illustrative purposes C can be used through the disclosure for the annotations and examples that follow. The various embodiments allow for the annotations to be written in a variety of other languages.

According to embodiments annotations can be coded as special forms of comments that can be ignored during the assembly of the program. Thus the comments do not affect the binary and the same source code generating the same binary can be used both for production purposes and for system level simulation analysis. The annotations can be recognized and processed by an extraction and build processes discussed herein. Generally two types of annotations can be used to support C annotations. Declarative annotations can be extracted verbatim into the C annotation source code and functional annotations can be extracted as subroutine calls that are virtually invoked at that point in the execution of the assembler binary. The concept of annotation is illustrated in the disclosure herein and annotations can be extended to transformation and other applications of arbitrary complexity.

References to an address can apply to an instruction address but can also apply to a data address. A memory simulation address can refer to either an instruction address or a data address. In various embodiments reference to an instruction address or programming instruction address can be used interchangeably with the data address. The term instruction can refer to a part of a program or a sequence of code that is processed by a simulator.

An example of the annotated assembler source file can be found in the table . Table illustrates a potential structure of the annotated assembler source file . For example the instructions can be in the assembly language and the annotations e.g. annotation0 and annotation4 can be written in the high level language. The annotations can be indicated by special forms of comments to indicate that an assembler should not process the annotation. The annotations can contain high level language statements or subroutine bodies for the simulator to execute.

The annotated assembler source file can be processed by the pre processor which can also be referred to as the pre processor module . The pre processor can receive the annotated assembler source file as an input and separate the annotations from the annotated assembler source file . The pre processor can use an extraction script in order to extract the routines from the annotated assembler source file . In various embodiments the pre processor can be a program that performs the extraction of an extracted routine file from the annotated assembler source file .

The pre processor can extract the annotations from the annotated assembler source file into a new file i.e. a labeled assembler source file . The virtual link between a functional annotation and its address in the final binary is established by inserting a label into the annotated assembler source file to denote the location of the functional annotation. Naming conventions can allow the label to be associated with the functional annotation at run time in an Instruction Set Simulator ISS .

Since assembly language is a line oriented language and since the annotations are easily recognized special forms of comment lines the annotations can be easily located and extracted. The pre processor can also provide syntax to the extracted routines in the extracted routine file . For example the pre processor can add syntax that transforms high level language statements and subroutine bodies into complete and valid subroutine forms for a high level language including argument prototypes that allow the annotation routines to fully access and control the state of the simulated system. The pre processor can also expand macros in the assembler source file and in the annotations. In addition the pre processor can add labels to the annotated assembler source file to indicate where the routines are located and produce a labeled assembler source file . The label can be a reference to the routine found in the annotations. According to various embodiments the labels can be referred to as meta information.

An example of the labeled assembler source file is found on table . Table illustrates the labels in the labeled assembler source file . The labels in the labeled assembler source file can refer to routines in the extracted routine file . Table illustrates an embodiment where the labels are not inserted explicitly in the labeled assembler source file but are instead generated by assembler macros. An example of the extracted routine file is found on table . The routines in the extracted routine file can refer to the annotations found in the annotated assembler source file . In various embodiments the extracted routine file can correspond based on the annotations in a single annotated assembler source file .

The extracted routine file can also be formed for a particular high level language in a single annotated assembler source file . For example there may be an extracted routine file for all the routines in the annotated assembler source file written in the Python language and an extracted routine file for all the routines in the annotated assembler source file written in C . The extracted routine file can include the routines with the appropriate syntax to allow an interpreter to read the high level language. The labels implied by the assembler macros in table e.g. .hook compute.S0 can refer to routines in e.g. Routine 0. The extracted routine file can also correspond to a set of routines. For example the extracted routine file can be a file for the compute.S series of routines. Each routine can be indexed to compute.S. The labels in table can reference routines in the extracted routine file .

A build engine can take the labeled assembler source file and convert the labeled assembler source file into an application object file . The build engine can be described further herein. The application object file can be formatted into machine readable code. The application object file can include a symbol table . The symbol table can associate an address in the application object file to the label from the labeled assembler source file . The annotation indexer can use the symbol table in the application object file and one or more extracted routine files to produce an annotation shared library . The annotation shared library can be a collection of one or more extracted routine files for a series of annotated assembler source files. The annotation shared library can be shared between a plurality of annotated assembler source file in the simulation. For example the annotation shared library can contain the routines for compute.S but could also contain the routines for multiple labels. The annotation shared library can be a dynamic link library DLL that refers to one or more extracted routine files. An ISS can locate the compute.S routine file based on an address and execute the routine in high level code from the compute.S routine file as described herein.

The special comment form on line 2 signifies a declarative annotation and the remainder of the line i.e. include compute.h can be copied verbatim to the extracted routine file in . The special comment form on line 7 signifies a functional annotation. By convention contiguous lines can be combined into a single routine. In various embodiments a one liner annotation form 1 can be added so that continuous lines are not used. The one liner can be used where annotations are generated by C pre processor or assembler macro expansions.

The formal parameters of routines will vary depending on the particular simulation environment and other requirements. The final form of the extracted routine can allow the routine to access the register and control state of the CPU being simulated as well as the state of the entire simulation if necessary. For example the routines can have the C prototype void functionalHook CpuState cpu SimState sim where cpu is a reference to the particular CPU being simulated and sim is a reference to the entire simulated system state. The environment can assume that any errors are signaled directly to the simulator or the routines may be required to provide return values indicating success or failure.

The example can assume a computation mapping two data register inputs D0 and D1 into the result again stored in D0 and also assumes that register values in the simulated state are accessible via data members of the CpuState object. At entry the routine at lines 7 and 8 can compute the expected value of an assembler computation using the golden model computeSpec into the annotation global variable G expected . At exit the routine beginning at line 11 compares the contents of D0 with the expected value and signals an error in the event of a mismatch. Several methods could be used to make state saving annotations to support multiprocessor simulations.

A functional annotation can be always active and associated with the current assembler location counter effectively binding the routine to the assembler instruction following the annotation. Other types of associations and policies are also possible e.g. a form that associates the routine with the previous instruction or forms that identify code in the process of transformation that should not be present or executed in the final application. A functional annotation can access a simulated register state and stop the simulation. Other behaviors can include injecting data into registers to simulate responses of devices that are not yet modeled in the simulation environment using the system model to read and write system memories or altering the flow of control to bypass assembler statements which should not be executed under conditions determined by the annotation.

The data that routines access or modify can be held in a small set of target machine registers accessible by name through the ISS CPU model. A custom ISS can also provide Application Programming Interfaces APIs that allow annotations to access memory in the simulated memory space and similar symbol table APIs also exist in the Simics environment.

Even though the example illustrates a labeled assembler source file the difference between the annotated assembler source file and labeled assembler source file can be the insertion of the labels i.e. .hook macro calls at the final lines of functional annotations i.e. lines 8 and 15. The .hook macros are not inserted on separate lines so that the line numbering of the original source file is the same with or without the use of the macros. Modifying the source code line numbering can confuse assembler listings and diagnostics which are keyed to the annotated assembler source file in the assembler e.g. a GNU assembler. The example assumes the .hook macro is defined by the header file hook.h which can be included into any assembler source file that uses annotations.

The system level simulation environment can be enhanced with a C singleton class named Hookmanager or Annotation manager implementing a generic symbol table and lookup mechanism for functional annotations. The code following the routines lines 18 30 comprises static load time initialization of Hookmanager data structures that allow the functional annotations to be identified and executed at run time. The address of each routine can be sequentially stored in a particular table then the table can be installed in the Hookmanager and indexed by the annotated assembler source file. The HookInitializer can be a simple class with no behavior other than a constructor that executes an arbitrary function e.g. init .

The build engine can build the application object file using an assembler and a linker . In various embodiments the assembler can assemble the instructions from the labeled assembler source file . The assembler can create object code by translating assembly instruction mnemonics into opcodes and by resolving symbolic names for memory locations and other entities. The assembler can include macro facilities for performing textual substitution e.g. to generate common short sequences of instructions as inline. The assembler converts the assembly language into machine readable code according to various embodiments. The assembler can also lay the groundwork for the relocation process performed by linker the linker .

The linker or link editor can accept the results from assembler having assembled one or more labeled assembler source files as input and produce an application object file which may be an executable program. The linker can perform relocation fixups and symbol resolution. The linker can also merge symbolic information and search for referenced labels in shared libraries and archive libraries. Linkers can be producers and consumers of object files and consumers of archive files. The selection of command line options determines what type of object the linker produces. A final link can produce an executable object file or shared library. A partial link can produce a re locatable object that can be included in a future link. The linker can be responsible for linking the segments of machine readable code to each other and using the address of the instructions. The annotations found in the labeled assembler source would not be present in the application object file .

The application object file can be processed by an annotation indexer which can be a script that indexes the annotations in the application object file . The output produced by the annotation Indexer can also be a C file that is compiled and linked with all of the extracted routine files to create an annotation shared library e.g. a Dynamic Link Library DLL that can be loaded into the system level simulator.

The annotation indexer can examine the symbol table of the application object file which can be created by the linker from labels in the labeled assembler source . The annotation indexer can collect from the symbol table the names and final link addresses of all of the labels associated with functional annotations. For example in a Linux implementation the symbol table can be accessed using the nm utility. The labels can be easily recognized by naming convention. For example if compute.S is assembled and linked with hello.S then the application object file might contain the symbols and addresses shown herein e.g. . When multiple hooks are associated with the same address the binary string portion of the label name can be used as a key to ensure that the routines are always executed in the order they appear in the labeled assembler source file . The annotation indexer can then generate an annotation index source file .

The compiler can receive and compile the annotation index source and one or more extracted routine files into machine readable code. The extracted routine file can include compute.S produced in . The linker can link the machine readable segments into the annotation shared library .

The ISS can create a simulated state using the instructions from the application object file . The ISS can output simulation results to a simulation interface . The ISS can have an annotation manager that accesses the routines written in the high level language. The term annotation manager can be used interchangeably with the term Hookmanager.

The simulator system can load the application object file into a simulated memory contained in a simulated state and then dynamically load the annotation shared library into the context of the ISS . The annotation files created by extraction and indexing scripts implement dynamic load time initialization of the annotation manager with the information required to locate and execute the routines. The ISS can be modified to simulate behavior with the high level routines. An ISS can execute a continuous fetch decode execute loop fetching instructions from simulated memory decoding and executing the instructions against the simulated system state. Now as each instruction is fetched the ISS can request the annotation manager to run any hooks that might be associated with the current instruction address. If an address references an annotation file then the routines associated with the annotation file are located and executed in the order of appearance in the annotated assembler source file. A routine may be called simply for side effect may halt simulation or may change the state of the simulated CPU in such a way as to force the control flow of the executed program to change.

The ISS can receive the application object file in the system . The application object file can have a number of machine readable instructions as shown on table . The ISS can read the application object file by address and as shown on table each address has a corresponding instruction.

The annotation manager can look up the addresses in the annotation table to determine if there is a match. If the address in the annotation table matches the address being read from the application object file e.g. table then the annotation table can refer to an annotation file with a particular index. The annotation manager can reference the table associated with the file to locate the corresponding routine. The routine can be processed either before or after the instruction is processed. In various embodiments the ISS can specify whether to execute the routine before or after an instruction for the simulated address or for the address being simulated.

As an example the ISS can read the application object file at address 0004011c. The annotation manager can scan the list of addresses in the annotation table for address 0004011c. Since the address 0004011c has an annotation associated with it the annotation manager can obtain the routine associated with 0004011c. The annotation manager can note that the routine is written in C and to process the routine after the instruction is processed for 0004011c. In various embodiments the routine can be processed before the instruction is processed for 0004011c. The annotation manager can be referred to an annotation file i.e. compute.S and an index that points to the section in the annotation file i.e. index 0. The annotation manager can find compute.S in the annotation shared library and execute ROUTINE 0 at index 0 after the instruction for 0004011c is executed.

According to various embodiments the compute.S table can be optional. For example the annotation table and compute.S table can both be private and would require the compute.S table . If the annotation table is private but the routines are public then the annotation table can refer to the routine directly.

The annotation table can be created when the annotation shared library is loaded by the annotation manager . The annotation shared library could be loaded first and the annotation manager can determine which libraries were loaded.

Multiple routines can be associated with a single instruction address. Assuming that multiple routines are associated with an instruction address then the annotations can be executed in the order they effectively appear in the annotated assembler source file. In various embodiments the execution of a routine may alter control flow. A routine may simply halt simulation or may change the state of the simulated CPU in such a way as to force the control flow of the executed program to change.

In various embodiments annotations in routines can be associated with the actions of reading and writing selected instruction addresses. For example the simulator system can add a special annotation at the instruction address where data is declared to link the reading and or writing of data at the instruction address to the routine. The simulator system can use a special annotation form to indicate whether to run the routine on the reading and or writing of data.

In operation the pre processor can receive an assembler source file with annotations written in a high level language. The pre processor and assembler source file can be the same as the pre processor and the annotated assembler source file found in . Once the annotated assembler source file is received then the method can continue to operation .

In operation the pre processor can identify the high level annotations. As discussed herein the annotations can have a or other symbol to indicate that the code is an annotation. Once the high level annotation has been identified then the method can continue to operation .

In operation the pre processor can extract the annotations from the annotated assembler source file into a separate extracted routine file. The extracted annotations can then be processed further to insert the syntax necessary to enable the annotations to be compiled. The annotations with the syntax and the compiled machine code can be referred to as a routine. In various embodiments one or more routines can be combined into a separate file e.g. an annotation file which can further have an index in the metadata. The index can point to the routine in the annotation file. Once the extracted routine file is created then the method can continue to operation .

In operation the pre processor can insert labels into the annotated assembler source file where the original annotations start. The labels can refer to the location of the routine in the annotation file. Each label can correspond to a particular address in the annotated assembler source file. The address and labels can be uploaded into a symbol table in the metadata of the labeled assembler source file. Aspects of operation and are described in more detail herein including the discussion of the system in . After operation the method can continue to operation .

In operation a build engine can build an annotation shared library from the extracted routine file and the symbol table. The processes in Operation can correspond with the components in the description of system in . After the annotation shared library is built the method can continue to operation .

In operation the annotations in the simulator can be validated to ensure the correct annotation shared library corresponds to the correct application object file address. The validation can occur by computing a cryptographic hash according to various embodiments. By computing a cryptographic hash the build engine can ensure that the application object file that generates the annotation shared library is matched to a specific version of the annotation shared library to ensure compatibility between different versions of the application object file. For example if a first annotation shared library is indexed based on a symbol table of a first application object file and the first application object file changes to a second application object file e.g. from an added line then the simulator can have an incorrect address for the reference to an annotation shared library. However a cryptographic hash can be computed from the application object file which can associate a version of the application object file with the correct annotation shared library. For example the annotation shared library can be named based on the cryptographic hash of the associated application object file. Operation can be described further herein. In various embodiments the validation can be optional. After the validation of the annotations then the method can continue to operation .

In operation the simulator can perform a simulation of the routines that are referenced by the instruction addresses in the application object file. Aspects of operation can be further described in the system in .

In operation the simulator can examine the next instruction address. The next instruction address can be the address for the next instruction that the simulator will access. Once the next instruction address is located then the method can continue to operation .

In operation the annotation manager in the simulator can determine whether the instruction address refers to an annotation. In various embodiments the simulator can access an annotation table similar to annotation table in . The annotation manager can compare the instruction address with the addresses in the annotation table. If there is a match then the method can continue to operation . If there is not a match then the method can continue to operation .

In operation the annotation manager can locate the routine. The routine can be written in a high level language. The annotation table can specify the language and arrange the proper interpreter for the routine. The annotation table can reference a particular file and an index in the file. The annotation manager can use the annotation to find the file and use the index to locate the corresponding routine.

The annotation table can specify whether the routine is executed before or after the instruction for the address. The simulator can set a default configuration that prefers to execute the routine before the instruction but other configurations are contemplated. Assuming that the routine is to be executed before the instruction then the method can continue to operation .

In operation the simulator can execute the routine. After the routine is executed then the method can continue to operation . In operation the simulator can determine whether to continue the simulation at a current instruction. This may occur when the routine is executed at the end of a simulation and there are no more instructions to read in the application object file. If the simulator does not continue the simulation at the current instruction then the method can continue to operation . If the simulator continues the simulation then the method can continue to operation .

In operation the simulator can determine whether the simulation continues at an alternate instruction. For example a routine can force execution in another part of the application object file or call up an alternate instruction in addition to the current instruction. If the simulator continues the simulation at an alternate instruction then the method can continue to that particular instruction and undergo the analysis in operation . If the simulator does not continue the simulation at an alternate instruction then the simulation halts.

In operation the simulator can execute the instruction at the next instruction address. For example the simulator can execute the next instruction once the instruction at the existing instruction address is executed. The address can contain both an instruction and a reference to a routine. If there are no more routines to run then the simulator can continue executing instructions in a sequential manner. In various embodiments the simulator can fetch the instruction at a particular address and decode the instruction prior to executing the instruction.

After the next instruction is executed then the method can continue to operation where the simulator can determine whether to process additional instructions. A parameter in the simulator can automatically stop the simulation. For example the simulator can stop the simulation if a routine determines that the chip being simulated is failing after 5 instructions. The method can continue to operation if the simulation continues or can halt.

According to various embodiments a Unix based Executable and Linkable Format ELF module can add a special section to the application object file that includes the date time host name and process ID of the process implementing the validation protocol. The introduction of the special section in the hash module can produce a prepared application object file . The addition of the special section can disambiguate versions of the application object file intended to be run against different annotation environments. The special section can be added as metadata that does not affect the final application binary in the prepared application object file .

According to various embodiments a system can also increase the uniqueness of the annotation shared library with a hash module . The hash module can further make the annotation shared library more unique by utilizing a cryptographic hash.

In various embodiments a hash of the application object file can be used e.g. a cryptographic hash function such as secure hash algorithm SHA 1. With an SHA 1 hash function the probability that two different application object files produce the same SHA 1 signature is astronomically small i.e. on the order of 1 in 1 quintillion. In order to implement the SHA 1 hash function the annotation indexer can be modified from the annotation indexer illustrated in to compute a cryptographic hash of the prepared application object file using the hash module and then name the affected library in the hashed annotation shared library with a name that includes a representation of the hash. For example an SHA 1 hash value can be represented by a 40 character string. The simulation process described in operation and can be modified so that whenever a prepared application object file is loaded a hash module e.g. the simulator configuration script can compute the hash of the prepared application object file and request that the hashed annotation shared library containing that name be loaded.

An example of a library in the hashed annotation shared library is shown in the table . The table can be a special archive folder that includes Dynamic Link Libraries DLLs that are identified with a unique hash according to various embodiments. The hash can be associated with the prepared application object file . When the prepared application object file is loaded by the simulator the simulator can compute the hash of the application object file through the hash module and load the corresponding DLL from the hook DLL archive directory.

The RAM can be configured to store a simulator . The simulator can also include one or more associated components as separate programs within the simulator . The RAM can include a build engine a module of computer program instructions designed for building an application object file and an annotation shared library according to embodiments of the present invention. The RAM can also include a preprocessing module that can be computer instructions for separating the annotations from a primary file. Also stored in RAM is an operating system . Operating systems useful for record filtering according to embodiments of the present invention include UNIX Linux Microsoft XP AIX IBM s i5 OS and others. The operating system and simulator are shown in RAM but many components of such software typically are stored in non volatile memory also such as for example on a disk drive .

The computer can also include disk drive adapter coupled through expansion bus and bus adapter to processor and other components of the computer . Disk drive adapter connects non volatile data storage to the computer in the form of disk drive . Disk drive adapters useful in computers include Integrated Drive Electronics IDE adapters Small Computer System Interface SCSI adapters and others. Non volatile computer memory also may be implemented for as an optical disk drive electrically erasable programmable read only memory so called EEPROM or Flash memory RAM drives and so on.

The disk drive can be a RAID configured storage device that includes one or more disk drives. The disk drive can store the shared library and the application object file used by the simulator.

The example computer includes one or more input output I O adapters . I O adapters implement user oriented input output through for example software drivers and computer hardware for controlling output to display devices such as computer display screens as well as user input from user input devices such as keyboards and mice. The example computer includes a video adapter which is an example of an I O adapter specially designed for graphic output to a display device such as a display screen or computer monitor. Video adapter is connected to processor through a high speed video bus bus adapter and the front side bus which is also a high speed bus.

The example computer includes a communications adapter for data communications with other computers e.g. mobile devices and for data communications with a data communications network . Such data communications may be carried out serially through RS 232 connections through external buses such as a Universal Serial Bus USB through data communications networks such as IP data communications networks and in other ways as will occur to those of skill in the art. Communications adapters implement the hardware level of data communications through which one computer sends data communications to another computer directly or through a data communications network. Examples of communications adapters include modems for wired dial up communications Ethernet IEEE 802.3 adapters for wired data communications network communications and IEEE 802.11 adapters for wireless data communications network communications.

A mobile device can have local programs that are separate from the simulator . The local programs can work in conjunction with the simulator .

Embodiments of the disclosure can take the form of an entirely hardware embodiment an entirely software embodiment or an embodiment containing both hardware and software elements. In one embodiment the disclosure is implemented in software which includes but is not limited to firmware resident software microcode etc.

Furthermore embodiments of the disclosure can take the form of a computer program product accessible from a computer usable or computer readable storage medium providing program code for use by or in connection with a computer or any instruction execution system. For the purposes of this description a computer usable or computer readable storage medium can be any apparatus that can store the program for use by or in connection with the instruction execution system apparatus or device.

The computer useable or computer readable storage medium can be an electronic magnetic optical electromagnetic or semiconductor system or apparatus or device or a propagation medium. Examples of a computer readable storage medium include a semiconductor or solid state memory magnetic tape a removable computer diskette a random access memory RAM a read only memory ROM a rigid magnetic disk and an optical disk. Current examples of optical disks include a compact disk with read only memory CD ROM a compact disk with read Write CD R W Blu Ray Disc and a digital video disk DVD .

An embodiment of a data processing system suitable for storing and or executing program code includes at least one processor coupled directly or indirectly to memory elements through a system bus such as a data address and or control bus. The memory elements can include local memory employed during actual execution of the program code bulk storage and cache memories which may provide temporary storage of at least some program code in order to reduce the number of times code must be retrieved from bulk storage during execution.

Input output or I O devices including but not limited to keyboards displays pointing devices etc. can be coupled to the system either directly or through intervening I O controllers. Additionally network adapters also may be coupled to the system to enable the data processing system to become coupled to other data processing systems or remote printers or storage devices through intervening private or public networks. Modems cable modems and Ethernet cards are just a few of the currently available types of network adapters.

Although the operations of the method s herein are shown and described in a particular order the order of the operations of each method may be altered so that certain operations may be performed in an inverse order or so that certain operations may be performed at least in part concurrently with other operations. In another embodiment instructions or sub operations of distinct operations may be implemented in an intermittent and or alternating manner.

Although specific embodiments of the disclosure have been described and illustrated the disclosure is not to be limited to the specific forms or arrangements of parts so described and illustrated. The scope of the disclosure is to be defined by the claims appended hereto and their equivalents.

