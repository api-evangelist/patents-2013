---

title: Security system and method for the android operating system
abstract: A method of linking a security policy stored in a policy database that is specific to an application in the application layer with a new corresponding process launched in the LINUX layer in a security system for an operating system running on a device that comprises a LINUX-based kernel. The system architecture is defined by a middleware layer between the LINUX layer associated with the kernel and the higher application layer comprising the applications.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08893222&OS=08893222&RS=08893222
owner: Auckland Uniservices Ltd.
number: 08893222
owner_city: 
owner_country: NZ
publication_date: 20131004
---
The present application claims the benefit of priority under 35 U.S.C. 119 to Australian Patent Application No. 2012904941 filed Nov. 13 2012 and claims the benefit of priority under 35 U.S.C. 119 to Australian Patent Application No. 2013902750 filed Jul. 25 2013 both of which are incorporated herein by reference in their entirety.

The present invention relates to a security system and method for the ANDROID operating system. In particular although not exclusively the security system is suited for hardware devices and systems such as mobile phones smartphones tablet computers and other portable computing and communication devices that run on ANDROID operating system.

The ANDROID operating system is a LINUX based operating system designed primarily for touchscreen mobile devices such as smartphones and tablet computers. The ANDROID operating system uses a LINUX kernel at its core and also provides an application framework that software developers incorporate into their ANDROID operating system applications and services. The ANDROID operating system additionally provides a middleware layer between the LINUX operating system at the LINUX operating system layer and the ANDROID operating system applications and services at the higher the application layer to enable easier cross platform development for deploying the same applications or services across different types of smartphones tablets or other hardware.

The middleware layer comprises libraries that provide services such as data storage screen display multimedia and web browsing and are compiled to machine language to enable services to execute quickly. The middleware libraries implement device specific functions so applications and the application framework need not concern themselves with the variations between devices running the ANDROID operating system. The middleware layer also supports a specialized version of Java to simplify cross platform development. In particular it contains the Dalvik Virtual Machine DVM and its core Java application libraries. Applications or services can be compiled from Java or other supported languages to a byte code that can be run by the DVM.

Although the middleware layer simplifies application development it also adds significantly more complexity to the overall ANDROID operating system. This additional complexity can be exploited by applications or services programmed to perform malicious tasks malware or execute malicious code malcode .

By way of example malware or malcode can exploit Inter Process Communications IPC to attack sensitive applications and their data. Referring to each application is executed in a respective DVM . When launched each application corresponds to an instance of a DVM. Each DVM is mapped into a dedicated process running in User Mode in the LINUX operating system layer . In the ANDROID operating system applications can communicate with each other using IPC mechanisms. The standard mechanism in the ANDROID operating system to implement IPC is though the Binder framework. The Binder framework has the facility to provide bindings to functions and data from one process to another. The Binder framework in the ANDROID operating system is provided in three levels. At the application layer there is an Application Programming Interface API to enable applications to communicate with each other such as the ANDROID Interface Definition Language AIDL . The AIDL allows application developers to define the interface for remote service and an AIDL parser generates the required Java client and server code. At the middleware layer a Binder such as C code is provided which has user space facilities to be used by the applications via Java Native Interface JNI and interacts with the Binder kernel driver in the LINUX operating system layer . The Binder kernel driver in the LINUX kernel carries out the message passing between processes and provides a shared memory facility. The driver sits behind a special device dev binder and implements various system calls such as open and ioctl to enable processes to communicate with each other.

As shown in the IPC mechanism can be described in two layers. At the ANDROID operating system layer when Application sends an IPC through its AIDL API as shown at the binder code in the middleware will take care of the delivery of the request to the destination Application as shown at . At the LINUX operating system layer this operation is translated into a sequence of system calls open and ioctl executed by Process corresponding to Application using the binder kernel driver dev binder as shown at . The request is then forwarded to Process corresponding to Application as shown at .

In conventional UNIX and LINUX operating systems security systems have been proposed that use kernel modules in order to trace a process to enforce security policies and this involves recompiling the kernel image in order to register the module. Additionally as new applications are launched by the user via a shell the monitoring module is able to link the correct security policy to the newly launched process. Such security systems do not work effectively on the ANDROID operating system which uses a distinctly different way of launching and managing programs. It is also desirable to have a security system for the ANDROID operating system that does not require recompilation of the LINUX kernel.

In this specification where reference has been made to patent specifications other external documents or other sources of information this is generally for the purpose of providing a context for discussing the features of the invention. Unless specifically stated otherwise reference to such external documents is not to be construed as an admission that such documents or such sources of information in any jurisdiction are prior art or form part of the common general knowledge in the art.

It is an object of the invention to provide a security system and method for the ANDROID operating system in which security policies for each application can be configured at the ANDROID operating system layer and which are enforced at the lower LINUX operating system layer or to at least provide the public with a useful choice.

In a first aspect the invention broadly consists in a method for securing an operating system running on a device comprising a LINUX based kernel and a system architecture defined by a middleware layer between the LINUX operating system layer associated with the kernel and the higher application layer comprising applications the method comprising 

By way of example the new application or part of an application may be launched by the user of the device the operating system itself or an already running application or process. The launch of a new application or part of an application in the application layer corresponds to the starting launching or forking of a process in the LINUX operating system layer.

Preferably the method further comprises providing security policies for the applications in the application layer in a policy database. More preferably the policy database is stored on the device or is stored remotely but is accessible to the device.

Preferably the method further comprises defining and storing security policies for the applications in the application layer in a policy database.

Preferably the operating system is the ANDROID operating system. More preferably the mother process is the Zygote process.

Preferably attaching a monitor process to the new process in the LINUX operating system layer comprises configuring the monitor process as a master process and the associated new process as its target process. More preferably attaching the monitor process to the new process comprises requesting the kernel to execute a tracing system call that is configured to intercept all or at least a set of system calls executed by the target process and report those to the master process prior to execution of the system call. By way of example the tracing system call may be a process trace system call ptrace . Preferably the kernel is configured to report to the master process system calls made by the target process both prior to and after the execution of the system call.

Preferably the monitor process is configured to access and retrieve the security policy for its attached new process from a security system service at the application layer which has access to the configurable security policies for the applications of the application layer in the policy database. More preferably the monitor process at the LINUX operating system layer is configured to establish a communication link with the security system service at the application layer. By way of example the communication link may be a direct link such as a transmission control protocol TCP link or connection or similar.

Preferably the method further comprises loading the new process monitor with the relevant security policies for its attached target process by 

By way of example the application identification data may be the application package name. In one form the method comprises extracting the application identification data from a system call in the specialization process. In another form the method comprises extracting the application identification data from a specialization data file that the full application package name of the target process is written to during the specialization process.

Preferably retrieving the relevant security policies for the target process based on the extracted application identification data comprises sending a request for the security policies to a security system service in the application layer the request comprising the application identification data.

Preferably the monitor process is configured to enforce the retrieved security policy for its attached new process by implementing a security action at the LINUX operating system layer in regard to the detected system call based on the retrieved security policy. The security action may comprise any one or more of the following allowing the system call to proceed blocking the system call from proceeding modifying parameters of the system call prior to execution or return values generated by the system call after execution or prompting the user of the device to select a security action. By way of example the monitor process may implement a security action by instructing and controlling the kernel in regard to its execution of the requested system call by the attached monitored process.

Preferably each process monitor is configured to enforce security policies based on parameters extracted from the detected system calls. For explicit system calls the security policies may be evaluated and enforced based directly on extracted system call parameters. For implicit system calls the process monitors may be configured to retrieve further information about the system call from the security system service in the application layer before evaluating and enforcing the security policies.

Preferably the method further comprises initially stalling execution of the new process until the monitor process has been attached to the new process. More preferably stalling execution of the new process comprises creating a breakpoint in the new process to prevent it from executing and subsequently removing the breakpoint to allow the new process to specialise as the new application and execute once the monitor process has been established and attached to the new process. By way of example the breakpoint may be an endless loop.

Preferably monitoring system calls to the kernel made by a mother process comprises establishing a main monitor process before the mother process initiates and attaching the main monitor process to the mother process by configuring the main monitor process as a master process and the mother process as its target process. More preferably attaching the main monitor process to the mother process comprises requesting the kernel to execute a tracing system call that is configured to intercept all or at least a set of system calls executed by the mother process and report those to the main monitor process prior to execution of the system call.

Preferably the method further comprises attaching a new individual monitor process to each newly launched process created by the mother process each individual monitor process being configured to enforce the security policy corresponding to the application for its attached monitor process.

In a second aspect the invention broadly consists in a security system for an operating system running on a device that comprises a LINUX based kernel and a system architecture defined by a middleware layer between the LINUX operating system layer associated with the kernel and the higher application layer comprising applications the system comprising 

Preferably the security system further comprises an accessible policy database comprising stored configurable security policies for the applications in the application layer. The policy database may be stored on the device or remotely stored and accessible to the device.

Preferably the operating system is the ANDROID operating system. More preferably the mother process is the Zygote process.

Preferably the main monitor process is attached to the mother process. More preferably the attachment is created by a process trace system call with the main monitor configured as the master process and the mother process being configured as the target process.

Preferably each process monitor is attached to its respective process by a process trace system call with the process monitor being the master process and its respective attached process being the target process.

Preferably each process monitor is configured to load the security policies for its attached target process by retrieving the security policies from the security system service. More preferably each process monitor is configured to monitor the specialization process of its target process to extract application identification data indicative of the application the target process is specializing as and to retrieve the relevant security policies for the target process from the security system service based on the extracted application identification data.

Preferably the process monitor s communicate with the security system service over a communication link or mechanism between the LINUX operating system layer and application layer. By way of example the communication mechanism may be client server transactions over a TCP link or similar.

The second aspect of the invention may have any one or more features mentioned in respect of the first aspect of the invention above.

In a third aspect the present invention broadly consists in a method of configuring a process monitor attached to a new target process in a security system for an operating system running on a device that comprises a LINUX based kernel and a system architecture defined by a middleware layer between the LINUX operating system layer associated with the kernel and the higher application layer comprising applications the method comprising 

In a fourth aspect the present invention broadly consists in a method of linking a security policy stored in a policy database and which is specific to an application in the application layer with a new corresponding process launched in the LINUX operating system layer in a security system for an operating system running on a device that comprises a LINUX based kernel and a system architecture defined by a middleware layer between the LINUX operating system layer associated with the kernel and the higher application layer comprising the applications the method comprising 

In one form creating a link comprises retrieving the security policy from the policy database and loading it into a process monitor attached to the new process for enforcing them.

In a fifth aspect the present invention broadly consists in a method of implementing security policies at the LINUX operating system layer the policies being defined for applications or types of applications in the application layer wherein the method comprises monitoring the loading and or identification of code used to specialize a new LINUX operating system process to implement its corresponding intended application and linking a security policy for implementing at the LINUX operating system layer to the new LINUX operating system process based on the loaded or identified code.

By way of example the security policies may be defined for each application or a type of application.

Preferably linking a security policy to the new LINUX operating system process comprises identifying a security policy for new LINUX operating system process from the code used to specialize the new LINUX operating system process.

The third fifth aspects of the invention may comprise any one or more features mentioned in respect of the first and second aspects of the invention.

The phrase specialization process or term specializing as used in this specification and claims is intended to mean unless the context suggests otherwise the process by which a newly created process in the LINUX operating system layer identifies the corresponding application in the application layer to which it relates and then retrieves and loads the application specific code for that application for execution.

The term attached or attaching as used in this specification and claims is intended to mean unless the context suggests otherwise creating a relationship between two processes in the LINUX operating system layer whereby one process is configured to monitor and control the other process in parent child or master target relationship and by way of example includes attachment by way of a process trace system call e.g. ptrace or any other mechanism that creates a link or attachment between processes which enables one process to control one or more aspects or functions of the other process.

The term LINUX as used in this specification and claims is intended to mean unless the context suggests otherwise any LINUX operating system employing a LINUX or UNIX or UNIX like kernel.

The phrase LINUX operating system layer as used in this specification and claims is intended to mean unless the context suggests otherwise the layer in the operating system architecture for describing the operation of processes in User Mode and their interaction with the kernel in Kernel Mode.

The phrase middleware layer as used in this specification and claims is intended to mean unless the context suggests otherwise the layer in the operating system architecture for describing the software operating between the LINUX operating system layer and the application software in the application layer.

The phrase application layer as used in this specification and claims is intended to mean unless the context suggests otherwise the layer in the operating system architecture for describing the operation of user application software and services.

The phrase mother process as used in this specification and claims is intended to mean unless the context suggests otherwise typically the process running after boot up of the operating system that controls the launch or initiation of all new children processes at the LINUX operating system layer via interaction with the kernel and for example in the context of the ANDROID operating system is equivalent to the Zygote process which initiates new processes by forking a new replica or image of itself and may also be referred to as a parent process .

The term monitoring as used in this specification and claims is intended to mean in the context of master target process or parent child process relationship where the master or parent intercepts controls modifies and or traces system calls made by the target or child process to the kernel and may also include or be referred to technically as interposing and or interleaving .

The term comprising as used in this specification and claims means consisting at least in part of . When interpreting each statement in this specification and claims that includes the term comprising features other than that or those prefaced by the term may also be present. Related terms such as comprise and comprises are to be interpreted in the same manner.

The invention consists in the foregoing and also envisages constructions of which the following gives examples only.

In the following description specific details are given to provide a thorough understanding of the embodiments. However it will be understood by one of ordinary skill in the art that the embodiments may be practiced without these specific details. For example software modules functions circuits etc. may be shown in block diagrams in order not to obscure the embodiments in unnecessary detail. In other instances well known modules structures and techniques may not be shown in detail in order not to obscure the embodiments.

Also it is noted that the embodiments may be described as a process that is depicted as a flowchart a flow diagram a structure diagram or a block diagram. Although a flowchart may describe the operations as a sequential process many of the operations can be performed in parallel or concurrently. In addition the order of the operations may be rearranged. A process is terminated when its operations are completed. A process may correspond to a method a function a procedure a subroutine a subprogram etc. in a computer program. When a process corresponds to a function its termination corresponds to a return of the function to the calling function or a main function.

Aspects of the systems and methods described below may be operable on any type of device running the ANDROID operating system including but not limited to a desktop laptop notebook tablet or mobile device. The term mobile device includes but is not limited to a wireless device a mobile phone a smartphone a mobile communication device a user communication device personal digital assistant mobile hand held computer a laptop computer an electronic book reader and reading devices capable of reading electronic contents and or other types of mobile devices typically carried by individuals and or having some form of communication capabilities e.g. wireless infrared short range radio etc. .

In conventional UNIX and LINUX operating systems security systems have been proposed to mitigate malware IPC attacks between application programs by intercepting system calls to the kernel. System calls are a key instruction that need to be monitored because they can be used to access sensitive parts of the operation system that are controlled by the kernel for example the file system shared memory network connections and the like. For setting security policies it is necessary to know which application has requested a specific system call. An application may consist of one or multiple process. In turn each process may run one or multiple threads concurrently to execute instructions some of which may be system calls that interact with the kernel. In conventional UNIX and LINUX operating systems the names of the processes and the application they belong to are known to the kernel as the applications are launched by the user via a shell. The security system monitors all system calls and based on the relevant policy specified for an application they are either allowed or blocked. This prevents malicious applications from executing illegal system calls while allowing normal applications to carry out their functions. Such security systems do not work on the ANDROID operating system which uses a distinctly different way of launching and managing programs. In particular the kernel in the ANDROID operating system in the LINUX operating system layer is not aware of which processes in the user mode correspond to which applications in the ANDROID operating system layer until a very late stage and therefore which applications may be attempting to communicate with each other via system calls is very difficult to ascertain.

This invention relates to a security system for the ANDROID operating system or other computer architectures having similar structures or configuration. The security system utilizes an approach that allows monitoring user space code without the need to modify the ANDROID operating system framework or the underlying LINUX kernel. In particular the security system is configured to control inter process communications IPC between applications to mitigate attacks that malware might perform on sensitive applications and their data. In principle this invention is able to control and enforce security policies to any process running on an ANDROID operating system. This includes system services that are offered in the stock ANDROID operating system such as SMS service Activity Manager Service Manager etc. . In this way this invention is able to mitigate vulnerabilities present in the ANDROID operating system services that might be exploited by malicious code.

The security system is implemented based on a feature unique to the ANDROID operating system namely the mother process called Zygote. Every ANDROID operating system application is run as a child forked out from the Zygote process and then it specializes itself by loading the specific application package and all the classes within it and making use of Java reflection it will eventually start the application by invoking the static main method. The security system runs a system process that attaches to the Zygote process and intercepts all its fork system call invocations so that whenever a fork system call is intercepted the security system starts monitoring the new process and enforcing the specific security policies for that specific ANDROID operating system application. The security system is able to enforce a set of security policies on devices running the ANDROID operating system which can be provided either by the security system itself a systems administrator the device user a third party service or system the ANDROID operating system application or a combination of these.

The security system enables the specification or configuration of application specific security policies at the application layer that can be enforced in the LINUX operating system layer. The security system will be described by way of example with specific reference to an ANDROID operating system on a device running the ANDROID operating system. However it will be appreciated that the security system may be configured to operate on any other suitable operating system having a similar architecture to the ANDROID operating system which uses a mother process to launch new processes in the LINUX operating system layer.

Referring to an embodiment of the security system comprises three main components or modules namely a main monitor application or process monitors and a security system service .

The monitors are in charge of enforcing a set of security policies for one or more processes and are implemented in the LINUX operating system layer. The monitors contain the policy enforcement point as well as the policy decision point which will be described later. In this embodiment there is a single main monitor that is configured to monitor the Zygote system process . The rest of the process monitors are forked out of this main monitor process. There may be zero or more application monitors one for each ANDROID operating system application that is forked out of the Zygote process. Process monitors are created as children of the main monitor when a fork system call from the Zygote process is intercepted. In contrast to the main monitor that is configured to monitor the main Zygote thread the individual process monitors are configured to monitor all application threads and sub processes to which they are attached.

The security system service is configured as an ANDROID operating system service in the Application layer that provides access to all the ANDROID operating system framework functionality in the ANDROID operating system layer to the monitors which are not able to use such functions from the LINUX operating system layer. In this embodiment the monitors in the LINUX operating system layer communicate with the security system service in the Application layer using a client server communication configuration such as but not limited to TCP sockets.

Further explanation of the security system configuration and functionality of the main modules will now be described with reference to the example in . corresponds to the architecture described in and like numerals represent like components. In brief each LINUX operating system process in the LINUX operating system layer that belongs to an ANDROID operating system application has its own attached process monitor shown at respectively. Each process monitor is configured to intercept all or a subset of the system calls that the attached LINUX operating system process executes on behalf of its associated application . When each LINUX operating system process executes a system call the attached process monitor intercepts the system call and undertakes a security action based on a security policy associated with the application which indicates whether the LINUX operating system process has authorisation to execute that system call. By way of example the process monitor may be configured to allow the system call block the system call modify the parameters of the system call modify the values returned by the system call or other suitable security action or a combination of these. If the LINUX operating system process is authorised to make the system call the process monitor lets the execution of the system call proceed. Alternatively the process monitor may block the system call from executing or otherwise modify the system call parameters or return values. For example the process monitor is able to retrieve the parameters of the system call and additionally the values that the system call returns. This enables the process monitor to modify the system call for example by filtering out one or more return values or changing or modifying one or more parameters of the system call prior to execution depending on the configured security policy for the application. By way of example the process monitor may be configured to modify the system call rather than blocking the system call for application that may crash as a result of a blocked system call.

By way of example the process monitor is configured to intercept IPC system calls through the binder by intercepting the open and ioctl system calls made to the binder kernel driver in the LINUX kernel. The process monitor then decides based on the security policy configured for the associated application in the application layer whether to block the system call or otherwise allow the system call to proceed in its original or a modified state as shown at .

Each process monitor is configured and attached to a new LINUX operating system process by a main monitor which is a LINUX operating system process created at boot up of the device before the initiation of any other processes and which will be explained in further detail later. The security policy dictating the authorisations of applications installed on the device in the application layer and in particular which application may communicate with each other or employ each other s services or permissions or other sensitive stored data is configurable and stored and or retrieved by a security system server in the application layer which will be described in further detail later. The security policies may be stored in memory locally on the device or remotely on an external database server or network accessible by the device.

Each process monitor is attached to its corresponding LINUX operating system process by establishing the monitor process as the master process and associated LINUX operating system process as its target process and using a tracing system call that is configured to enable a master process to control a target process by inspecting its memory and intercepting its system call. In this embodiment the tracing system call is the process trace system call ptrace . To use ptrace the master process has to be either running as the route user or the parent process of the target process. The master process will be able to monitor and control all the child processes that are forked by its target process by intercepting the forked system call.

As mentioned the security system is configured to monitor all applications and corresponding processes executed on the device running the ANDROID operating system by exploiting a configuration feature of the ANDROID operating system which controls the management and launching of applications. In the ANDROID operating system all applications in the application layer and corresponding LINUX operating system processes are launched by a special mother process known as the Zygote process. The Zygote process is the only process that has the right to fork a new ANDROID operating system application and corresponding LINUX operating system process. All ANDROID operating system applications and corresponding LINUX operating system processes executing can be considered children of this Zygote process. The configuration of the security system and operation of the main modules will now be described in further detail.

The security system starts as a part of the ANDROID operating system. As mentioned the security system controls the mother or Zygote process so that every time a new LINUX operating system process corresponding to an ANDROID operating system application is started a new monitor can be attached to the process. Controlling the Zygote processes achieved by modifying the booting sequence of the ANDROID operating system.

By way of example the booting sequence is modified such that the main monitor of the security system replaces the initial Zygote process. During the boot process the initialization script is run and the main monitor is started. The Zygote process is then launched as a child of the main monitor. The main monitor then executes a tracing system call such as ptrace to attach to the child Zygote process to control its execution from the first moment it begins by intercepting system calls to the kernel made by the Zygote process. At this point in boot up the main monitor is now attached to and monitoring the Zygote process.

In this embodiment the security system service is also started by the ANDROID operating system during the boot process. By way of example the security system service is located within the directory for system applications such that it launches before a user can log in or any user application can be run on the device running the ANDROID operating system. Once the security system service is running every time a new ANDROID operating system application is forked from Zygote a new process monitor is forked from the main monitor and attached to the new application process as explained in further detail next.

The sequence of main operations executed by the security system to generate and configure a process monitor for a newly launched ANDROID operating system application will be described. When the security system starts only the main monitor process is running along with the security system service. The main monitor is attached to and monitoring the Zygote process. New process monitors are created as children of the main monitor. In order to do this the main monitor is configured to intercept the Zygote process invocations of the fork system call which is called every time a new application is launched in the the ANDROID operating system.

Referring to the scenario of a user launching the SKYPE application on their ANDROID operating system smartphone will be used by way of example. When the user clicks on the SKYPE icon on their smartphone a message or signal is sent to the Zygote process to fork a new process that executes in a new DVM for the SKYPE application.

Every time Zygote implements a fork system call to the kernel it will be stopped with signal by the kernel and the main monitor will be notified by the kernel with signal e.g. SIGCHILD and woken up. The kernel dispatches these signals because the main monitor is monitoring Zygote through the ptrace system call. A new process monitor must now be created as fork system call of the main monitor and attached to the newly created process .

Due to the scheduling performed by the ANDROID operating system scheduler there s no way to guarantee that the process execution order will allow the new process monitor to attach to the new LINUX operating system process corresponding to the SKYPE application before it executes any system calls. In some circumstances the new process could start executing its code without the process monitor be able to control it which could lead to security issues.

In order to avoid this situation the main monitor is configured to inject a breakpoint e.g. an endless loop into the Zygote process code so that when its image is duplicated to create the new process it will contain that breakpoint as well. The new process now containing the loop is initially stuck inside the loop and it is not able to execute any other code until the breakpoint is removed. By way of example the breakpoint may be an infinite loop in ARM assembly code or any other equivalent method of stalling program execution. An example of the breakpoint injection for this embodiment and the remaining process monitor generation will be further described below.

As set out above every time a new ANDROID operating system application forks from Zygote the security system injects a breakpoint into Zygote so that when its image is duplicated the new process will contain the breakpoint as well and the new process monitor can attach to it before it continues its execution without missing any system calls.

As mentioned the breakpoint may be for example an infinite loop in ARM assembly code. The breakpoint is injected at the current program counter address PC within the Zygote process memory as follows using the following procedure. Firstly in order to resume the Zygote program execution the state of Zygote registers should be backed up in the memory of the main monitor as well as the Zygote program code that will be replaced by the breakpoint itself. By way of example the main monitor may copy the Zygote program code into its memory using ptrace PTRACE PEEKDATA which allows to read data from the monitored process memory in this case Zygote. The main monitor may read and store the state of the Zygote process registers in its own memory using ptrace PTRACE GETREGS . After this the main monitor is configured to reset the PC to its previous address that will later contain the breakpoint so that it continues its execution at the breakpoint code injected. The register R of Zygote is set to zero which enables the breakpoint. Next the main monitor is configured to inject the breakpoint code into Zygote. The main monitor contains a function that compiles ARM assembly code that executes an infinite loop based on the value of R and this is the code that is injected into the Zygote process memory. The breakpoint function machine code is obtained from the function address in the main monitor memory as an array of bytes. Then the breakpoint code is copied from the main monitor memory into the Zygote memory at the program counter address using ptrace PTRACE POKEDATA which allows the tracer to insert data into the monitored process memory space.

Once the breakpoint code has been inserted into Zygote as above the main monitor is configured to send a signal to the kernel to allow the kernel space code of the Zygote fork system call to execute. As the fork system call executes a new process intended to eventually be SKYPE in this example is created. The new process is a clone of Zygote or a duplicate of the Zygote process image in memory including the injected breakpoint. The newly created process may then run but will be stalled in the breakpoint loop . The main monitor is then configured to wait until it receives the fork system call exit notification. In particular the main monitor is configured to monitor for the exit notification and intercept it.

When the fork system call returns in Zygote the system call is exiting the process will be stopped by the kernel and the kernel will notify the main monitor via signal e.g. SIGCHILD . At this point the Process Identification PID of the new process is already available. Each process has a unique PID that allows the kernel to identify the different processes running. The main monitor is configured to retrieve the PID of the new process as shown at from Zygote. For example the main monitor may retrieve the PID from the Zygote process register RO using ptrace PTRACE GETREGS . The main monitor is then configured to generate a new process monitor attached to that retrieved PID.

The main monitor forks the new process monitor by executing a fork system call to the kernel . When the main monitor process forks a new process the newly created process monitor is at the beginning of its execution an exact replica of the parent main monitor process. This means that when the main monitor forks the new process monitor the process monitor has in its memory structure the PID of the new process intend to eventually be SKYPE created by Zygote .

The main monitor is then configured to replace the breakpoint code in Zygote with the original code backup at the original location using ptrace PTRACE POKEDATA and resets the registers to their original stored values using ptrace PTRACE SETREGS as shown at . The main monitor then resets the PC of Zygote and controls the kernel to continue the Zygote process using signals as if nothing had happened.

The newly created child process monitor uses the PID in its memory structure to attach itself to trace the new SKYPE process using ptrace PTRACE ATTACH as shown at . The process monitor is also configured to replace a main dummy policy decision point of the main monitor with one specific for application process monitors as shown at which will not yet contain any security policies until the application package name in this case SKYPE associated with the monitored new process is known. The process monitor is also configured to replace the breakpoint code in the new process with the original code as shown at and initiate execution of the new process via signals . This is done in a similar manner to the way the main monitor replaced the breakpoint code in the Zygote process as discussed above. The monitored new process can now start executing. As the process monitor is attached to the new process it can intercept and control all the system calls that this process executes.

Configuration of Security Policy for New Process Monitor At this point there will be the main monitor tracing monitoring Zygote and a new process monitor tracing monitoring the newly created LINUX operating system process corresponding to the ANDROID operating system application SKYPE. The new LINUX operating system process hasn t specialized as SKYPE yet meaning that it is not yet executing the code of the SKYPE application. The specific security policy for the new process monitor cannot be loaded until the new process specialises. The security system is configured to retrieve and load a specific security policy or set of policies to the new process monitor based on application identification data that is indicative of the

ANDROID operating system application the new LINUX operating system process is specializing as. In this embodiment the application identification data is the appication s package name and the process monitor is configured to retrieve this during the specialization of the new process it is monitoring.

To specialize the new process needs to retrieve the SKYPE application package name so that it can then load the SKYPE application specific code the application database on the device for execution. During the specialization process the ANDROID operating system framework writes the application s package name into a specialization data file e.g. proc pid cmdline within the proc pseudo filesystem . This occurs right after the new process is forked and before the static main method is invoked using reflection.

The ANDROID operating system Process Java class invokes through the Java Native Interface JNI the function android os Process setArgV setting the package name as parameter. It will then call the ProcessState setArgV method which resets the process argv which effectively changes the specialization data file i.e. updates it with the application s package name and then after this sets the process name by using the prctl PR SET NAME system call. The process name that can be set through the prctl system call is limited to 16 bytes which means that in some cases the package name in this system call might not be complete. There are no system calls generated by the monitored process when the argv parameter is set into the specialization data file which actually contains the whole package name.

In this embodiment instead of checking the application name specified by the prctl function parameters the process monitor is configured to read the contents of the specialization data file which contains the full application package name set when the argv was overwritten. In particular the process monitor is configured to detect when the prctl system call is exiting.

Once this is detected this signals to the process monitor that the full application package name has now been written to the specialization data file. The process monitor is configured to then read and retrieve the full application package name from the specialization data file upon detection of the prctl system call exiting.

Once the package name e.g. com.skype.apk has been obtained by the process monitor it can then retrieve and load the security policy or policies specific to that application. In particular the process monitor policies can be initialized and policies can be enforced specific to that process. The package name is forwarded to the process monitor s policy decision point which will load the specific policies for the monitored process. To do this the process monitor makes use of a special service in the application layer framework called the security system service which will be described in further detail later on.

Each process monitor is configured to enforce the retrieved security policy for its attached new process by implementing a security action at the LINUX operating system layer in regard to the detected system call based on the retrieved security policy. The security action may comprise any one or more of the following allowing the system call to proceed blocking the system call from proceeding or modifying parameters of the system call prior to execution or return values generated by the system call after execution. By way of example the monitor process may implement a security action by instructing and controlling the kernel in regard to its execution of the requested system call by the attached monitored process. An example implementation of the enforcement of policies is explained below although it will be appreciated that alternative enforcement mechanisms may be used.

In this embodiment the main monitor and process monitors each contain two components namely a policy enforcement point and a policy decision point. The policy enforcement point is in charge of tracing the monitored process through its system calls and enforcing the policies and provides the information from the process state to the policy decision point. The policy decision point generates decisions based on the process state and the policies assigned to it. These decisions are sent to the enforcement point which makes sure they are enforced.

The policy decision point uses a policies repository which depends on the security system configuration for each decision point and that might change on runtime if the configuration is eventually modified. Depending on which type the monitor belongs to e.g. main monitor or an individual process monitor it will contain a different type of policy decision point.

The main monitor contains a dummy decision point that is used to intercept the fork system call and retrieve the PID of the new process in order to generate new application process monitors as explained previously.

In contrast the process monitors are able to retrieve the application package name associated with their respective target process and perform the policy initialization. By way of example there may be various types of policies supported by the process monitors such as 

Specifically block access to the various ANDROID operating system shared memory services ANDROID operating system shared memory ashmem Process memory allocator PMEM and processor specific variants CMEM NVMAP etc. and the ANDROID operating system ION memory allocator. Furthermore a child process can be prevented to use shared memory mechanisms with its parent.

These policies are loaded with the specific policy configuration associated with application package name in a policy database stored on the device or remotely accessible. The policies may be modified and updated during the application execution if desired. Some policies or any other components within the monitors may need to get access to functionality that is only available from the ANDROID operating system application layer but not from the native code layer such as access to the GUI or the different ANDROID operating system services like the Package Manager Activity Manager and so on. The monitors can use such ANDROID operating system Framework functionality through querying the security system service running in the application layer using transactions as will be explained further later.

As discussed the main monitor and process monitors are processes in the LINUX Operating system layer that are attached to Zygote and any application processes respectively. A tracing system call is used to attach the main monitor and process monitors to their respective target processes. In this embodiment the process trace ptrace system call is used to attach the main monitor to its target process namely the Zygote process and each process monitor to its respective target processes. The target processes become the child of their respective monitor or parent process once the ptrace system call is executed.

In regard to the process monitors the ptrace is configured to trace the target process main thread by default and also the rest of process threads and sub processes in this embodiment. This is preferred for ANDROID operating system applications which are always multi thread applications. By configuring the ptrace to attach to any threads of the main target application process this ensures that the process monitors receive notifications of any system calls each thread might execute.

The policy enforcement mechanism takes place in the policy enforcement point within each monitor. The policy enforcement point enforces the policies by tracing the monitored process system calls and making decisions based on the information that can be extracted from them.

In the case of process monitors the process monitor goes to sleep e.g. invokes waitpid after attaching to the monitored target process. This blocks the process monitor until a system call is invoked from the monitored target process. When a system call is sent by the target process to the kernel the kernel will stop the monitored target process e.g. using SIGSTOP signal and will unblock the process monitor attached to the target process e.g. using SIGCHILD signal . The function will also return the ID of the thread TID that generated the system call as well as some additional process state information that is used for other purposes. At this point the process monitor is configured to retrieve the state of the monitored process registers from where the system call number can be obtained. The thread ID system call number and the state of the process registers are forwarded to the policy decision point that depending on its policies will consider the system call relevant or not. If it is not relevant it will return immediately with no decision to the enforcement point. If it is relevant the policy decision point will analyse the process state and depending on it it may or may not return a decision to the enforcement point e.g. a security action to execute. The decision generation mechanism is explained in further detail later. After the decision point returns the enforcement will continue the monitored process if the decision indicates to do so or implement any other security action indicated by the decision including blocking the system call modifying parameters of the system call or return values requesting user input for implementing user selected security actions or even killing the application process altogether. After the decision is enforced the process monitor goes back to sleep e.g. invokes waitpid waiting for notification of the next system call made by the target monitored process.

Decisions are security actions that have to be executed in order to enforce a set of policies. The policy decision point within each process monitor is the component in charge of the decision generation which takes place every time the policy enforcement point intercepts a system call. In this embodiment each policy decision point contains a set of policies depending on the monitor type and the security system configuration for the monitored application. These policies also known as low level policies in contrast to user defined policies those that are specified in the application layer are defined within the security system itself. A user defined policy can be translated into one or more low level policies and can affect one or more monitors depending on its semantics.

The enforcement point triggers the decision generation mechanism. After intercepting a system call it checks if such call is either entering or exiting and retrieves the state of the registers for the process that generated it. The policy decision point as well as policies have two entry points one for the entering system calls and another for the exiting ones. This is due to that the information that can be retrieved at each point is different so different decisions can be made during each stage. Then the enforcement point forwards to the specific entry point within the decision point the system call number the state of the process registers and the TID that generated such system call this information being referred herein as the process state . The process state is passed to each one of the policies that may or may not return a decision. In one form just the first decision returned by a policy is taken into account and the rest are discarded. In another forms this could be modified by assigning different priorities to each policy. In this embodiment even if a decision has already been generated by one of the policies the process state is still passed to the rest of policies in case they need it to track the process history.

In this embodiment policies are not monolithic components they are made instead of reusable modules that can belong to one or more policies know as action modules. Action modules are associated to a unique system call and extract information from the process state in order to provide information that can be used by the policy to generate a decision. Action modules the same as the decision point and policies themselves provide two entry points one for the entering system calls and another one for those that exit but in contrast to them they are specific for each thread so they don t need the thread identifier except at the time they are built. Each policy specifies a list of action modules that is instantiated for each thread and running within the monitored ANDROID operating system application as well as sub processes in such way so that whenever a policy entry point is invoked if the list of action modules for that thread does not exist it is created and it is removed once the thread or process exits.

When the policy entry point is invoked it will loop over all the actions for the TID that generated the system call that are associated to that specific system call. Should any of these action modules consider the system call invocation is meaningful for it for instance ioctl on some specific device or open on just socket descriptors the policy will check the data gathered by those action modules and generate a decision security action . The decision is then returned to the policy decision point which will decide if should be sent back to the enforcement point or not depending on the other policies results. Finally if the decision point has returned any decision the enforcement point will ensure the decision is made in order to enforce the policy that generated it. This process is shown diagrammatically in .

Overview The security system service is an ANDROID operating system service in the application layer that exposes all the ANDROID operating system Framework functionality to the monitors in the LINUX operating system layer. It runs on start up before any user application. In contrast to normal ANDROID operating system services that provide services to other ANDROID operating system applications or services this service does not expose its functionality through intent action filters or an AIDL interface in this embodiment. Instead the security system service provides its functionality to the process monitors through a communication link or process between the application layer and LINUX operating system layer. In this embodiment the communication between the security system service in the application layer and the process monitors in the LINUX operating system layer occurs via requests on a TCP port i.e. the security system service listens for requires on a TCP port. These requests are known as transactions. Each transaction has a unique ID and may contain zero or more parameters that are set by the process monitor and processed in the service which eventually returns a result back to the process monitor.

Each transaction has a client part that is the process monitor and a server part represented by the security system service. The client part sets the transaction identifier transaction ID and the parameters and sends them through a socket to the security system service. Transactions are synchronous so the process monitor gets blocked waiting until the transaction has been processed. The security system service is configured to wait for requests on the security system service socket. Every time a new transaction is received the security system service retrieves the transaction ID and builds the server part of the transaction which loads the parameters from the socket and is put into a thread pool queue. Once there is an available thread to process the transaction the transaction runs and performs its functionality. It will return and a result will be sent to the requesting process monitor. To finish the process the process monitor receives the transaction response and will unblock continuing its execution. In this embodiment the communication link may use Transport Layer Security TLS for protecting the confidentiality of the communication between the security system service and the process monitors. It will be appreciated that other communication links or mechanisms could be used to enable communication between the security system server and process monitors in other implementations including but not limited to shared memory space or similar.

The security system service operating in the application layer for accessing the services of the ANDROID operating system framework allows the specification of per application policies through the standard ANDROID operating system interface such as an Application for example . Also it allows the process monitors to deal with the peculiar way in which the ANDROID operating system implements IPC calls. The security system service provides to the process monitor an entry point to the upper level of ANDROID operating system services and in doing so the process monitor is able to enforce its policies. These aspects are explained further below.

Referring to an example implementation of the security system showing the functionality of the security system service on device running the ANDROID operating system will be described by way of example. The device has a SKYPE application and MyBank application running in the application layer each having or being mapped to a corresponding LINUX operating system process respectively in the LINUX operating system layer . Attached to each LINUX Operating system process is a corresponding process monitor respectively. Zygote and its attached main monitor are also shown in the LINUX operating system Layer. The security system service is shown running in the application layer as a normal ANDROID service. By way of example a TCP communication link is shown between the process monitor associated with the SKYPE application and the security system service and a similar communication link exists or can be established between any other process monitors and the security system service also.

The process monitor attached to the SKYPE application can use the functionality of the security system service for loading policies specific to the SKYPE application. In particular when the process monitor is configuring itself it retrieves the application package name associated with the process to which it is attached as previously explained and then uses this application identification data to request the security policy or policies for that application from the security system service which has access to the policy database where the policies are stored. The security policies for the applications may be stored in a policy database on the device in memory or alternatively in a remote database on a server or network or other device accessible by the security system service. The security policies may be configured and stored in the policy database in various ways. The policies may be configured via a custom security system application with a GUI that can be launched on the application layer and operated by the user or system administrator automatically set by virtue of the application permissions during application installation retrieved from a network or server operated by a third party or may be configured in any other suitable way.

By way of example the MyBank application is a sensitive application that the user wants to protect. The user does not trust the SKYPE application to call through IPC the MyBank application. The security administrator can define a high level policy such as SKYPE not Auth IPC to MyBank. This policy has to be translated in the low level policy that the process monitor can enforce. For instance for controlling IPC communication between applications a low level policy may be implemented such as IPCPolicies that deny an IPC call between the application represented by the CallingAppPackName and the application in the TargetAppPackName . The policy might be DenyIPCPolicies CallingAppPackName TargetAppPackName Type . This policy takes as argument the package name of the calling application the package name of the target application and a parameter specifying if the target is either an application or a service. For our case when the process monitor attached to SKYPE contacts the security system service to request the SKYPE policies when initialising the security system service will retrieve the relevant policies from the policy database and reply with the parameters specifying the package name for SKYPE for the MyBank app and that MyBank is an application. The process monitor can then load the IPC policy as follows DenyIPCPolicies com.skype.app com.mybank.app APPLICATION .

In this embodiment the other main functionality of the security system service is to help process monitors resolve the application name its attached monitored process is trying to communicate with so that it can then enforce any particular policies in relation to that IPC. In the ANDROID operating system the IPC call mechanism uses a special type of messages for performing the remote method invocation called intents . An intent represents an abstraction of a method invocation and is the main way in which the Binder manages the IPC between different applications. There are two types of intent supported in the ANDROID operating system explicit and implicit intents. Explicit intents define which application is the receiver of the intent. The process monitor can directly capture explicit intents and extract the target application or its package name from the associated system call being executed by the monitored process. Implicit intents are more problematic for the process monitors to deal with. In an implicit intent an application can just specify the action that it wants a target application to execute. Then it is up to the ANDROID operating system framework to find the best matching application to reply to the intent. The ANDROID operating system run time and specifically Activity Manager decides which activity would be the target of the intent.

Activity manager contacts the Package Manager to resolve implicit intents. Package manager is one of the system services which maintain some information about the installed applications and services on the device running the ANDROID operating system.

From the process monitor point of view when its monitored application is executing an IPC system call using an implicit intent the process monitor is able to capture the intent and extract its contents but the extracted information is not enough for evaluating its security policies. An IPC security policy needs as a parameter the target application but implicit intents only provide the description of the target application. Because the Package Manager is a service running in the application layer on top of the ANDROID operating system middleware layer the process monitor cannot access it as the process monitor is running at native code layer or LINUX operating system layer inside the LINUX operating system. However the process monitor is configured to interact and communicate with the security system service running on the application layer via the TCP port and can send a request for information indicative of the target application associated with the implicit intent to the security system service so that it can enforce and relevant security policies in relation to that intent.

For example with reference to let s assume that the MyBank application has a method myPrecious that is invoked for getting some precious stuff and that the SKYPE application wants to send an implicit intent to an application that has the myPrecious method with the description getting some precious stuff . In the ANDROID operating system without the security system installed when the SKYPE application sends the intent through the Binder the Binder will ask the Package Manager which app has the method myPrecious method with the description getting some precious stuff . The Package Manger will reply with the MyBank application . Thus the Binder will send the intent to the MyBank application that will reply to the request giving to the SKYPE application the precious stuff which could lead to security issues. When the security system is installed on the device running the ANDROID operating system the above process changes as explained below to minimise such security risks.

When the security system is installed on the device running the ANDROID operating system such that a process monitor is attached to the SKYPE application it will intercept the system call that is generated when the implicit intent is sent from SKYPE application to the Binder. The process monitor is configured to retrieve the information in the intent but initially the policies in the process monitor can t determine the package name of the target application which is not yet known. The process monitor cannot access the Package Manager in the ANDROID operating system application layer directly but the security system service can as it is a standard ANDROID service running at the application layer on top of the ANDROID operating system middleware layer with a special communication link for the process monitors i.e. the TCP connections. When the process monitor intercepts the system call with the implicit intent it is configured to copy the application description and method and sends it to the security system service through the TCP link with a request for the package name of the target application. The security system service is configured to receive and processes the request and asks the Package Manger to provide the package name of the target application that satisfies the description. The Package Manger will return the com.mybank.app package name to the security system service that will forward it to the process monitor using the same TCP link . Now the process monitor has the package name information and can evaluate and enforce its security policies. In this case the policy described above will be evaluated and since it is a deny policy the action will be denied.

A first example is a method for securing an operating system running on a device comprising a LINUX based kernel and a system architecture defined by a middleware layer between the LINUX operating system layer associated with the kernel and the higher application layer comprising applications. The method comprises monitoring system calls to the kernel mode by a mother process in the LINUX operating system layer to detect the launching of a new process in the LINUX operating system layer corresponding to a new application or part of an application in the application layer and attaching a new monitor process in the LINUX operating system layer to the newly launched process once it is created by the mother process. The monitor process is configured to monitor system calls made to the kernel by the new process and to retrieve and enforce security policies configured for the new process based on the parameters of detected system calls.

A second example is a security system for an operating system running on a device that comprises a LINUX based kernel. The system architecture is defined by a middleware layer between the LINUX operating system layer associated with the kernel and the higher application layer comprising applications. The system comprises a main monitor process running at the LINUX operating system layer which is configured to detect the launch of a new process in the LINUX operating system layer by a mother process the new process corresponding to the launching of a new application or part of an application in the application layer by the user of the device. A process monitor is attached by the main monitor to each new process created by the mother process and each process monitor is configured to monitor the system calls made by its attached process to the kernel. A security system service running at the application layer is provided that is operable to access stored configurable security policies for the applications of the application layer and which communicates with each process monitor in the LINUX operating system layer the security policies corresponding to its attached process. Each process monitor is configured to retrieve and enforce the security policy configured for its attached process based on the parameters of the detected system calls.

A third example is a method of configuring a process monitor attached to a new target process in a security system for an operating system running on a device that comprises a LINUX based kernel. The system architecture is defined by a middleware layer between the LINUX operating system layer associated with the kernel and the higher application layer comprising applications. The method comprises monitoring the specialization process of the target process as it specializes as its intended application extracting application identification data from the specialization process that is indicative of the application or type of application the target process is specializing as retrieving security policies specific to the target process from a policy database based on the extracted application identification data and configuring the process monitor to enforce the retrieved security policies.

A fourth example is a method of linking a security policy stored in a policy database and which is specific to an application in the application layer with a new corresponding process launched in the LINUX operating system layer in a security system for an operating system running on a device that comprises a LINUX based kernel. The system architecture is defined by a middleware layer between the LINUX operating system layer associated with the kernel and the higher application layer comprising the applications. The method comprises monitoring the specialization process in the LINUX operating system layer of the new process as it specializes as its intended application extracting application identification data from the specialization process that is indicative of the application or type of application the target process is specializing as and creating a link between the new process and a security policy from the policy database based on the application identification data.

A fifth example is a method of implementing security policies at the LINUX operating system layer the policies being defined for applications or types of applications in the application layer. The method comprises monitoring the loading and or identification of code used to specialize a new LINUX operating system process to implement its corresponding intended application and linking a security policy for implementing at the LINUX operating system layer to the new LINUX operating system process based on the loaded or identified code.

Embodiments of the security system may be implemented by hardware software firmware middleware microcode or any combination thereof. When implemented in software firmware middleware or microcode the program code or code segments to perform the necessary tasks may be stored in a machine readable medium such as a storage medium or other storage s . A processor may perform the necessary tasks. A code segment may represent a procedure a function a subprogram a program a routine a subroutine a module a software package a class or any combination of instructions data structures or program statements. A code segment may be coupled to another code segment or a hardware circuit by passing and or receiving information data arguments parameters or memory contents. Information arguments parameters data etc. may be passed forwarded or transmitted via any suitable means including memory sharing message passing token passing network transmission etc.

In the foregoing a storage medium may represent one or more devices for storing data including read only memory ROM random access memory RAM magnetic disk storage mediums optical storage mediums flash memory devices and or other machine readable mediums for storing information. The terms machine readable medium and computer readable medium include but are not limited to portable or fixed storage devices optical storage devices and or various other mediums capable of storing containing or carrying instruction s and or data.

The various illustrative logical blocks modules circuits elements and or components described in connection with the examples disclosed herein may be implemented or performed with a general purpose processor a digital signal processor DSP an application specific integrated circuit ASIC a field programmable gate array FPGA or other programmable logic component discrete gate or transistor logic discrete hardware components or any combination thereof designed to perform the functions described herein. A general purpose processor may be a microprocessor but in the alternative the processor may be any conventional processor controller microcontroller circuit and or state machine. A processor may also be implemented as a combination of computing components e.g. a combination of a DSP and a microprocessor a number of microprocessors one or more microprocessors in conjunction with a DSP core or any other such configuration.

The methods or algorithms described in connection with the examples disclosed herein may be embodied directly in hardware in a software module executable by a processor or in a combination of both in the form of processing unit programming instructions or other directions and may be contained in a single device or distributed across multiple devices. A software module may reside in RAM memory flash memory ROM memory EPROM memory EEPROM memory registers hard disk a removable disk a CD ROM or any other form of storage medium known in the art. A storage medium may be coupled to the processor such that the processor can read information from and write information to the storage medium. In the alternative the storage medium may be integral to the processor.

One or more of the components and functions illustrated the figures may be rearranged and or combined into a single component or embodied in several components without departing from the invention. Additional elements or components may also be added without departing from the invention. Additionally the features described herein may be implemented in software hardware or combination thereof.

In its various aspects the invention can be embodied in a computer implemented process a machine such as an electronic device or a general purpose computer or other device that provides a platform on which computer programs can be executed processes performed by these machines or an article of manufacture. Such articles can include a computer program product or digital information product in which a computer readable storage medium containing computer program instructions or computer readable data stored thereon and processes and machines that create and use these articles of manufacture.

The foregoing description of the invention includes preferred forms thereof. Modifications may be made thereto without departing from the scope of the invention as defined by the accompanying claims.

