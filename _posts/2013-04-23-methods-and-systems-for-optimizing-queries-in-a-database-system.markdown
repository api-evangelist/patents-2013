---

title: Methods and systems for optimizing queries in a database system
abstract: Methods and systems for optimizing queries in a multi-tenant store are described. In one embodiment, such a method includes retrieving data from a multi-tenant database system having a relational data store and a non-relational data store, receiving a request specifying data to be retrieved, retrieving one or more locations of the data to be retrieved, generating a database query based on the request, in which the database query specifies a plurality of data elements to be retrieved, the plurality of data elements including one or more data elements residing within the non-relational data store and one or more other data elements residing within the relational data store, generating an optimized database query having an optimized query syntax that is distinct from a query syntax of the database query, and executing the optimized database query against the multi-tenant database system to retrieve the data.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09507822&OS=09507822&RS=09507822
owner: salesforce.com, inc.
number: 09507822
owner_city: San Francisco
owner_country: US
publication_date: 20130423
---
This continuation patent application U.S. patent application Ser. No. 13 868 746 is related to and claims priority to the provisional utility application entitled METHODS AND SYSTEMS FOR PERFORMING CROSS STORE JOINS IN A MULTI TENANT STORE filed on Apr. 19 2010 having an application No. 61 325 709 the entire contents of which are incorporated herein by reference this application is related to and claims priority to the provisional utility application entitled METHODS AND SYSTEMS FOR OPTIMIZING QUERIES IN A MULTI TENANT STORE filed on Apr. 20 2010 having an application No. 61 325 951 the entire contents of which are incorporated herein by reference and this application is further related to and claims priority to the nonprovisional utility application entitled METHODS AND SYSTEMS FOR OPTIMIZING QUERIES IN A MULTI TENANT STORE filed on Dec. 20 2010 having an application Ser. No. 12 973 676 now U.S. Pat. No. 8 447 754 the entire contents of which are incorporated herein by reference.

A portion of the disclosure of this patent document contains material which is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure as it appears in the Patent and Trademark Office patent file or records but otherwise reserves all copyright rights whatsoever.

The subject matter described herein relates generally to the field of computing and more particularly to methods and systems for optimizing queries in a multi tenant store.

The subject matter discussed in the background section should not be assumed to be prior art merely as a result of its mention in the background section. Similarly a problem mentioned in the background section or associated with the subject matter of the background section should not be assumed to have been previously recognized in the prior art. The subject matter in the background section merely represents different approaches which in and of themselves may also correspond to embodiments of the claimed subject matter.

In conventional database systems database users access data resources from one logical or relational database. A user of such a conventional system typically retrieves data from and stores data on the system using the user s own systems. A client device may remotely access one of a many of server systems each of which may then in turn access such a conventional database system. Data retrieval from such conventional database systems may include a client or server issuing a query to the conventional database system which may in response process the request for information received via the query and return information to the requestor relevant to the request. Improving the speed security easy of use for both users and administrators efficiency of system and network resources and accuracy of data stored and retrieved have all been and continue to be the focus and goal of administrators of conventional database systems.

Unfortunately such conventional database systems exhibit many undesirable characteristics such as processing queries and requests relatively slowly e.g. when a large number of users simultaneously make a request of the same conventional database system allow data access to unauthorized persons become increasingly inefficient over time waste network and system resources with overhead that does not contribute directly to the storage and processing of data etc.

Various types of databases are also available such as relational database models and non relational database models each having their own particular benefits and drawbacks. Unfortunately database queries that simultaneously reference information from multiple data stores are highly inefficient and detract from benefits that may otherwise be derived from the implementation of multiple data stores of different types. Moreover database queries that simultaneously reference distinct implementations of diverse database models may be wholly impracticable using previous database query mechanisms as conventional query engines lack the sophistication to communicate with diverse database types.

Described herein are systems devices and methods for optimizing queries in a multi tenant store. In one embodiment such a method includes retrieving data from a multi tenant database system having a relational data store and a non relational data store. For example in such a method a host system for the multi tenant database system receives a request specifying data to be retrieved from the multi tenant database system retrieving based on the request via the host system one or more locations of the data to be retrieved generating at the host system a database query based on the request in which the database query specifies a plurality of data elements to be retrieved the plurality of data elements including one or more data elements residing within the non relational data store and one or more other data elements residing within the relational data store optimizing the database query via a query optimizer to generate an optimized database query having an optimized query syntax that is distinct from a query syntax of the database query and executing the optimized database query against the multi tenant database system to retrieve the data.

Database query logic is made more complex when the requested data set is spread across diverse database structures and when the referenced database system supports multiple tenants or multiple customer organizations as is the case with a multi tenant database system. Such a system greatly simplifies efforts on the part of a customer organization as the a multi tenant database system may be utilized as though it is a service that is accessible via the cloud for example over the Internet without requiring the customer organization to implement any database hardware or functionality themselves. However a hosting entity of the multi tenant database system must cope with greatly increased complexity. As a result of this complexity there are often opportunities to optimize database queries directed toward such a multi tenant database system. Such optimizations may be undertaken by the hosting entity without requiring participation from customer organizations that utilize the multi tenant database system.

In the following description numerous specific details are set forth such as examples of specific systems languages components etc. in order to provide a thorough understanding of the various embodiments. It will be apparent however to one skilled in the art that these specific details need not be employed to practice the disclosed embodiments. In other instances well known materials or methods have not been described in detail in order to avoid unnecessarily obscuring the disclosed embodiments.

In addition to various hardware components depicted in the figures and described herein embodiments further include various operations which are described below. The operations described in accordance with such embodiments may be performed by hardware components or may be embodied in machine executable instructions which may be used to cause a general purpose or special purpose processor programmed with the instructions to perform the operations. Alternatively the operations may be performed by a combination of hardware and software.

Embodiments also relate to a system or apparatus for performing the operations herein. The disclosed system or apparatus may be specially constructed for the required purposes or it may comprise a general purpose computer selectively activated or reconfigured by a computer program stored in the computer. Such a computer program may be stored in a non transitory computer readable storage medium such as but not limited to any type of disk including floppy disks optical disks CD ROMs and magnetic optical disks read only memories ROMs random access memories RAMs EPROMs EEPROMs magnetic or optical cards or any type of media suitable for storing non transitory electronic instructions each coupled to a computer system bus. In one embodiment a computer readable storage medium having instructions stored thereon causes one or more processors within a multi tenant database environment to perform the methods and operations which are described herein. In another embodiment the instructions to perform such methods and operations are stored upon a non transitory computer readable medium for later execution.

The algorithms and displays presented herein are not inherently related to any particular computer or other apparatus nor are embodiments described with reference to any particular programming language. It will be appreciated that a variety of programming languages may be used to implement the teachings of the embodiments as described herein.

In one embodiment the hardware software and logic elements of the multi tenant database system include at least a non relational data store and a relational data store which operate in accordance with the hardware software and logic elements that implement the database functionality and code execution environment within the host system . Host system may further receive requests from one or more of the plurality of customer organizations A C via the network. For example an incoming request may correspond to a request for services or a request to retrieve or store data on behalf of one of the customer organizations A C within the multi tenant database system .

In one embodiment a request is received at host system on behalf of the multi tenant database system . In such an embodiment request specifies data to be retrieved from the multi tenant database system . In some embodiments a distinct web server operating within the host system receives the incoming request via network . For example web server may be responsible for receiving requests from various customer organizations A C via network . Web server may provide a web based interface to an end user client machine originating the request e.g. such as an end user client device located within a customer organization A C the request constituting a request for services from the multi tenant database system operating within a host organization such as host system that provides for example remotely implemented cloud computing services. In some embodiments request specifies data to be written to or updated within multi tenant database system rather than retrieved.

In one embodiment host system retrieves based on the request received one or more locations of the data to be retrieved. In one embodiment a customer schema describes the one or more locations of data to be retrieved in which the customer schema specifies each of the plurality of data elements of the data to be retrieved as residing within either the non relational data store or residing within the relational data store or as being available from both the non relational data store and the relational data store . In one embodiment the host system retrieves the customer schema responsive to receiving the request . Alternatively the host system retrieves the one or more locations of the data to be retrieved from the customer schema . In one embodiment where the request specifies data to be written or updated within the multi tenant database system the host system retrieves one or more locations within either the non relational data store or the relational data store to update data as specified or to write data as specified for example the one or more locations being target locations.

Customer schema may be accessible via for example a global caching layer that provides fast efficient access to various elements of a host system implementing or providing the described multi tenant storage capabilities. In alternative embodiments the one or more locations of data to be retrieved updated or written available provided or retrieved via the customer schema by the host system by an optimizer agent by a query layer of the host system or by other elements of the host system responsible for determining the locations of data to be retrieved from the multi tenant database system that is spread across diverse database implementations such as data having a plurality of data elements residing in the non relational data store and the relational data store as depicted or alternatively data that is to be updated within or written to the non relational data store and or the relational data store .

In one embodiment the host system generates a database query based on the request in which the database query specifies a plurality of data elements to be retrieved the plurality of data elements including one or more data elements residing within the non relational data store and one or more other data elements residing within the relational data store . In a particular embodiment the database query is based further on the retrieved one or more locations of the data to be retrieved updated or written. Such a database query may further be generated or delegated by the host system for generation by a sub system of the host system such as query layer or optimizer agent .

In some embodiments database query includes a plurality of sub queries. In such an embodiment at least one of the plurality of sub queries are directed toward retrieving the one or more data elements residing within the non relational data store from the non relational data store and at least a second one of the plurality of sub queries are directed toward retrieving the one or more other data elements residing within the relational data store from the relational data store . For example depicted by within the expanded view of database query are several sub query strings such as retrieve data element a from the non relational data store e.g. and retrieve data element b from the relational data store e.g. and another sub query string which states select x from y where z reflective of a generic Structured Query Language SQL type query. Such a query may or may not be appropriate for querying the underlying data stores e.g. and depending upon the implementing query language or syntax chosen.

In one embodiment host system optimizes the database query to generate an optimized database query having an optimized query syntax that is distinct from a query syntax of the database query such as the syntax specified by an initial preceding or un optimized database query such as database query .

For example an incoming request e.g. may specify data to be retrieved but may additionally specify a query syntax with which to retrieve the requested data or a query syntax with which to update or write specified data. Such a query syntax may be technically or syntactically capable of retrieving writing or updating the specified data e.g. if executed the query syntax may execute without error and produce the requested data or effectuate the requested update or write operation however the query syntax may nevertheless be capable of optimization. Database queries that have the potential to be optimized may similarly be generated by the host system itself such as database query which may be generated by query layer .

The mere fact that a database query may technically or syntactically execute to produce results without error does not necessarily mean that such a query is as efficient as it potentially can be. For example optimizations may be available to make the query return a result faster return a result with consuming fewer computing resources such as bandwidth processor cycles memory etc. return a result utilizing less cost such as through the use of lower cost commoditized hardware and systems and so forth.

Thus in accordance one embodiment although a first database query may be specified and available for execution an optimized database query is generated having optimized query syntax distinct from the original or previously available database query . Examples of distinct query syntaxes are provided at and discussed below.

In such an embodiment the optimized database query is then executed against the multi tenant database system to retrieve update or write specified data rather than executing an un optimized and or previously available database query . In accordance with one embodiment executing the optimized database query against the multi tenant database system includes referencing data elements stored in both the relational data store and the non relational data store so as to retrieve the requisite data . Alternatively the optimized database query includes referencing one or more target locations to update the specified data or write the specified data to the multi tenant database system .

In one embodiment query layer receives the optimized database query from optimizer agent and then passes the optimized database query to the multi tenant database system . In alternative embodiments optimizer agent passes the optimized database query directly to the multi tenant database system for execution via its underlying hardware software and logic elements as depicted via the dashed arrow directing optimized database query from optimizer agent directly to the multi tenant database system .

In one embodiment database analytics are generated for one or more customer organizations based on data structures and historical database queries corresponding to each of the one or more customer organizations. In one embodiment an analytics engine of the optimizer agent generates the database analytics . In alternative embodiments analytics engine operates externally to optimizer agent and provides database analytics to the optimizer agent .

Database analytics may include specified size thresholds e.g. number of rows amount of data in terms of size e.g. megabytes of data cardinality of data requested etc. . Such analytics may be performed in advance before a request for data is received or on the fly responsive to receiving a request for data.

Database analytics may be based upon for example known statistics and analysis within the host system such as a query cost for a particular database query or for one or more sub queries e.g. from . Such statistics and analysis may be derived from a known pick list quantity for a particular query in which a maximum number of elements is known and thus a maximum or estimated query cost is determinable or is known and available from the optimizer agent or analytics engine .

In one embodiment the optimized database query is generated based on database analytics which are generated or created for the respective customer organization having originated a corresponding request . For example database analytics may be available on a per customer organization basis and may be used for optimizing the original database query . Database analytics on a per customer organization basis may be applicable wherein a particular database table or a particular series of database objects or records are only accessed by one customer. Take for example a listing of sales leads for a particular customer organization s sales team. Such information may be accessible to only a single customer organization and thus analytics performed against such a table may be specific to that single customer organization .

Similarly there may be many customer organizations each of whom have sales leads data stored within the multi tenant database system however each of the sales lead data sets associated with the various customer organizations may have different characteristics such as distinct overall sizes different numbers of records different fields and different storage structures such as being stored within the non relational data store portion or the relational data store portion of the multi tenant database system . Each of these varying characteristics may affect the manner in which a particular query may be optimized. Because each customer organization may have data sets with characteristics distinguishable from other customer organizations having data stored within the same multi tenant database system it may be advantageous to conduct at least a portion of the database analytics on a per customer organization basis.

Although some database analytics which relate to data associated with multiple distinct customer organizations or an entire data store as a whole e.g. or may also be beneficial in some situations in other situations having database analytics that are based on an entire data store as a whole e.g. or or based on multiple distinct customers organizations each having their own varied structures and characteristics may potentially cause potential optimizations to be averaged out or canceled out and thus a potential optimization may be missed altogether. Thus in accordance with certain embodiments one or more database analytics are based on a per customer organization basis.

In one embodiment the query optimization consists of a modification to the order of one or more specified join operations within an un optimized query or a pre existing query. For example in one embodiment an un optimized database query includes a specified order for two or more database join operations . In such an embodiment optimizing the database query includes modifying the specified order for the two or more database join operations within the optimized database query .

In alternative embodiments there are no join operations specified within the un optimized database query and thus optimizing the database query includes modifying the un optimized database query to include at least one database join operation or in some embodiments two or more database join operations and a specified order for the two or more database join operations within the optimized database query . In alternative embodiments specified or implicit join operations within an un optimized database query are negated altogether through alternative query syntax resulting in the optimized database query executing without having to perform a previously specified join.

In one embodiment at least one of the database join operations within the optimized database query includes joining a child table from the non relational data store with a master table from the relational data store .

In some embodiments a join operation includes multiple sub queries. For example in such an embodiment a first sub query is to be executed against the non relational data store and identifies the one or more data elements residing within the non relational data store . In such an embodiment a second sub query is to be executed against the relational data store which then retrieves data elements from the relational data store that are not available from the non relational data store . Such elements may be joined within a new table in either data store e.g. or or joined together in a caching location. In alternative embodiments missing data from one data store is replicated from a source location to a target location. For example sub query may determine a data delta between the first sub query that identifies the one or more data elements residing within the non relational data store and the one or more other data elements residing within the relational data store . In such an embodiment a third sub query may be executed against the relational data store and the non relational data store wherein the third sub query replicates data corresponding to the determined data delta from the relational data store to the non relational data store such as that which is depicted by sub query causing a replication event from relational data store to non relational data store based on the determined data delta .

For example sub query may retrieve the one or more other data elements residing within the relational data store pulling them into for example a temporary table file temporarily caching the data etc. and then such a third sub query may issue an insertion or write command of the retrieved data corresponding to the data delta against the non relational data store causing the data delta data to be written stored or inserted into the non relational data store thus completing the replication and thus further causing the previously unavailable data elements which resided in the relational data store to now be available from the non relational data store . Refer to the dashed line of depicting sub query being executed against both data stores relational data store and non relational data store to replicate the identified data delta from the relational data store to the non relational data store .

Optimized database queries utilizing replication or data synchronization between data stores e.g. and may be derived from a policy to replicate a smaller dataset from its primary location to the location having the larger dataset. For example replicating the one or more data elements that are part of the requested data may be more efficient from a network bandwidth perspective to conduct the replication from the relational data store to the non relational data store than vise versa. Analytics engine may provide such a policy based on previously performed database analytics or based on on the fly database analytics conducted via for example one or more sub queries within an optimized database query or pre queries executed as part of the development of the optimized database query .

Other database optimization decisions may be based upon policies that reflect optimizations to data consistency and resiliency. For example optimized database query may implement one or more sub queries or database query syntax to ensure consistency guarantees. For example replicated data and synchronized data is not necessarily guaranteed to be in sync depending on how the multi tenant database system performs its synchronization algorithms. The optimized database query may reflect an optimization that is more computationally economical or more economical from a bandwidth perspective but does not require a consistency guarantee when the potential for data deviance is an acceptable risk. Alternatively the optimized database query may reflect an optimization that requires a consistency guarantee and thus such an optimization may not emphasize speed or computational efficiency but instead emphasize data guarantees. Such a policy may be triggered by an incoming request from a customer organization or triggered internally based on a policy specified by for example analytics engine .

Thus in accordance with one embodiment optimizing the original database query includes a identifying a first sub query within the original database query directed to a table within relational data store in which the first sub query corresponds to a first portion of data to be retrieved based on an incoming request b identifying a second sub query within the original database query directed to a table in the non relational data store in which the second sub query corresponds to a second portion of the data to be retrieved based on the request c replicating the table within the relational data store to the non relational data store and d generating the optimized database query with one or more sub queries to fetch both the first portion of the data to be retrieved and the second portion of the data to be retrieved from the non relational data store . Stated differently the resultant optimized database query references only the non relational data store for all of its requisite data to be retrieved made possible through the replication event conducted by for example optimizer agent . In some embodiments the replication even is triggered before the original database query is received for example where the original database query is conducted frequently enough for the analytics engine or the optimizer agent to determine that it is economically viable to trigger such a replication event.

In some embodiments the replication is performed in the opposite direction and all data is retrieved from the relational data store instead of the non relational data store . In some embodiments an entire table specified via corresponding FROM clause is replicated while in others only particular columns are replicated or particular records derived from a corresponding WHERE clause are replicated. For example a relevant data set may be replicated between the underlying data stores and so as to negate an otherwise required join operation where data elements from each of the data stores and are being evaluated as part of the original database query . In yet other embodiments a non SQL based syntax is utilized to specify tables or portions of tables for replication. In some embodiments one or more data structures or data sets are replicated for example data in a non relational data store for which there is no associating table structure. For example a list or series of data files may be replicated from a non relational data store and represented within a table of a relational data store as object elements. Such files and objects may instead require searching and parsing various elements as they do not reflect a relational table based format but may nevertheless contain relevant data which can be leveraged to conduct a fulfill a request .

In one embodiment an un optimized database query includes a plurality of sub queries each having a corresponding WHERE clause and optimizing the database query includes analyzing each of the plurality of sub queries based on in memory cached statistics to identify one of the plurality of sub queries as a most efficient sub query of the original database query . Based on the in memory cached statistics the optimized database query is then generated having the one sub query identified as the most efficient sub query as a leading query within the optimized database query . For example un optimized database query may include sub queries similar to sub queries in which sub query is specified as the leading query. In such an embodiment the optimized database query may similarly include sub queries corresponding to those within the original database query but sub query may be identified as the most efficient sub query and thus specified as the leading query as part of the query optimization. In one embodiment the in memory cached statistics are available via analytics engine . In alternative embodiments the in memory cached statistics are available via a global caching layer accessible from the optimizer agent .

In one embodiment the most efficient query among a plurality of sub queries in the un optimized database query is identified based on the one sub query among the plurality of sub queries within the un optimized database query corresponding to a best metric or a best combination of metrics in accordance with the in memory cached statistics. In such an embodiment each metric may be selected from the group comprising a number of rows a number of blocks an average row length Input Output I O utilization processor utilization and execution time. For example a sub query targeting a table or data structure with a small number of elements may result in subsequent sub queries being more efficient as there may be fewer elements to evaluate stemming from the decision to lead with a sub query directed to the smaller table or data structure. Alternatively it may be determined that a larger table organized relationally is more efficient to lead an optimized query than having to search or parse an smaller index or a file which is not organized relationally. Analytics engine may specify such policy determinations and thresholds based on available statistics and analytics.

In one embodiment optimizing the database query includes a identifying a sub query within the un optimized database query that references a parent table within the relational data store as a leading sub query within the un optimized database query b injecting a new join operation to a foreign key index into the leading sub query to the parent table in the relational data store wherein the join operation joins a custom index on a foreign key for the non relational data store and c leading the optimized database query with the sub query to the parent table having the join operation injected therein.

In accordance with one embodiment optimizing the database query includes a identifying within an un optimized database query a sub query to a named table within the relational data store having a WHERE clause to invoke a full table scan b replacing the identified sub query to invoke the full table scan with an optimized sub query to invoke a range scan of an index table associated with the named table c leading the optimized database query with the optimized sub query and d injecting a join operation to the optimized database query wherein the join operation combines indexed column data from the index table with results of the optimized sub query when available and further joins non indexed column data from the named table when indexed columns cover less than all required columns of the named table based on the identified sub query.

Full table scans may provide significant opportunities for optimization especially where an index table already exists for named data table. A full range scan may occur or be invoked by a database query when a table is specified and a WHERE clause specifies a particular matching condition. For example WHERE an employee ID equals 12345 or WHERE salary is less than 50 000.00. If transacted in an un optimized form the query causes the database to consider each and every row within a named table to evaluate whether or not the condition exists. The query has no opportunity to pre terminate until all rows are evaluated a potentially wasteful exercise in large tables e.g. a million row table thus requires a million condition evaluations . Conversely by replacing the sub query with an optimized sub query directed toward an index table the indexing scheme e.g. traversing a b tree etc. may be utilized to complete the same evaluation required by the WHERE clause without having to consider all rows and potentially negating consideration of a vast majority of rows in the named table. Where additionally required column data is present within the index table e.g. because the columns are frequently referenced and thus indexed the additionally required column data may be retrieved from the index table. Where column data is not covered by the index table the originally specified named table may be referenced now requiring only consideration of a known subset of rows or records due to the preceding optimized sub query leading the directed to lead the optimized database query.

In one embodiment an un optimized database query includes a plurality of sub queries within the un optimized database query each having a corresponding WHERE clause to retrieve a specified plurality of data elements and optimizing the database query includes a generating a pre query for two or more of the plurality of sub queries in which each pre query specifies the retrieval of a portion of the respective plurality of data elements for the corresponding sub query b executing each of the pre queries against the multi tenant database system c ranking the executed pre queries on the basis of one or more metrics including Input Output I O utilization for the pre query processor utilization for the pre query and execution time for the pre query and d generating the optimized database query based on the ranking of the executed pre queries.

For example some un optimized database queries will solicit data retrieval or initiate database actions for which sufficient statistics or database analytics are not available via the analytics engine or elsewhere. When a requested un optimized database query is sufficiently large in terms of computational resources execution time bandwidth resources or some other metric it may be more efficient to have the optimizer agent initiate probing pre queries and test queries against the multi tenant database system soliciting a sub set of the required information in order to determine which of various available retrieval or execution schemes are most efficient. Although the pre queries themselves consume time and resource the resources consumed may provide a return e.g. an efficiency improvement or optimization that is greater than the resources required to generate execute and evaluate the results of such pre queries. For example if a requested database query requires searching millions of rows it may very well be advantageous to trigger probing queries on a small subset of the total rows and evaluate which of multiple options most efficiently executes.

In some embodiments a determination whether to conduct pre queries may be made by the optimizer agent based on statistics or database analytics . For example where an un optimized database query is evaluated to require resources below a particular threshold pre queries may be by passed and other optimizations implemented not requiring the pre queries. Such an evaluation may be based on for example a known cardinality or table depth of a specified target table or specified columns in a WHERE clause of the un optimized database query . Other considerations may be based upon a size classification for a particular client organization a corresponding size on disk of a specified table or data structure etc. In some embodiments pre query results are stored cached and referenced in subsequent database requests for which a common pre query result may be referenced without re execution. In one embodiment a known pick list quantity e.g. a known a maximum number of elements for a referenced column or table or relevant sub query is known and thus a maximum or estimated query cost is known and available from the analytics engine or may be determinable via the optimizer agent e.g. through one or more pre queries .

In one embodiment a pre query operates as a filter. For example optimizer agent may generate an execute query logic to retrieve additional detail from the database query to be optimized in search of or to filter which of multiple optimized query statements may be most appropriate or most efficient for the underlying database store. A similar database query may be optimized one way for the non relational data store and yet another way for the relational data store . For example in one embodiment a getSelectiveFilter function or SqlOptimizer.getSelectiveFilter logic module systematically processes multiple SQL based WHERE clauses looking for which one of the multiple available is the best most appropriate or most efficient one to lead an optimized database query . In such an embodiment the identified WHERE clause is selected and used to lead an optimized database query having multiple sub queries. Such an optimization may output extra leading joins and additional directives supported by the underlying data store or within the optimized database inquiry for example instructing the underlying data store or on how to process respond to implement or execute the optimized database query .

In one embodiment a filtering mechanism e.g. getSelectiveFilter may be based on available types of IndexedFilter implementations supported by an underlying data store or . For example basic custom indexes and name indexes may be referenced e.g. search name lookup or more sophisticated query scopes e.g. My Records or index joins may be specified via an optimized database query . Such indexes and query scopes can be implemented on relational database query engines as well as non relational database query engines. In addition to specialized filters and indexes pivot tables may further be utilized as potential query optimizations when supported by the target data store. Whether or not such capabilities are supported by a particular data store or may be tracked and managed by implementing logic of an optimizer agent or alternatively may be discoverable via an analytics engine on behalf of the optimizer agent.

In one embodiment a database store dependent key function mechanism or method employed by a filter mechanism e.g. IndexedFilter implements a getSlowStats or equivalent function to perform a database store dependent pre query to estimate the selectivity of queries. Alternatively a getFastStats or equivalent function may be used in a database store independent fashion when the cardinality of a query can be determined from in memory cached statistics. For example where a picklist histogram is known and available e.g. via analytics engine without having to execute pre queries. Same or equivalently corresponding data structures e.g. where a custom index ndv num distinct values can be used to store statistics regardless of whether the underlying database store is relational or non relational.

In some embodiments various implicit indexes may be presumed to always be present regardless of whether implementation and or optimization query logic is data store dependent e.g. specific to either non relational data store or relational data store . For example a Name field of a custom object may be presumed to always be indexed e.g. such as when targeting a relational Oracle based data store . A SearchNameLookup function or equivalent may be used along with its corresponding implementation in a relational data store whereas in non relational data store a custom index on the Name field may be used to implement equivalent functionality and allow for the above presumption of always being present. In some embodiments utilizing foreign keys an optimizer agent may presume a multi tenant CFKV custom foreign key value table to be indexed when targeting a relational data store whereas when optimizing query logic targeting a non relational data store an implicit custom index may be presumed.

In some embodiments a policy may specify that optimizing query logic uses a selective filter mechanism e.g. getSelectiveFilter by default to lead the optimized database query in all cases via query syntax appropriate for the underlying data store or . Where optimizer agent determines to lead the query with a parent table in a join a join to the foreign key index table may then be injected to support the query lead e.g. CFKV for relational stores or equivalent custom index on a foreign key for non relational data store implementations .

In some embodiments a non relational data store is made to support corresponding or equivalent query operations as a relational data store via an API Application Programming Interface to the respective underlying data stores. For example such an API may be implemented in the query layer or via the hardware software and logic elements of the multi tenant database system . Using such an API non relational database objects can be made to support the same query mechanisms as other objects on an otherwise distinct database structure. In some embodiments the API that implements corresponding or equivalent query operations for distinct data store architectures e.g. and is made available to the customer organizations for example via a public dynamic class of Salesforce.com based objects e.g. SObjects or via com.salesforce.objects for example inheritable from mx.utils.ObjectProxy . In a particular embodiment an API query verb and a Salesforce.com Object Query Language SOQL compatible syntax is made available as an entry point to a query targeting non relational data or data stored in a non relational data store notwithstanding a lack of native non relational data store support for such a query syntax the non compatible syntax is thus transformed via the API or query layer .

In a particular embodiment an API query retrieve verb is directly mapped to a non relational data store s retrieve function internal call thus permitting less parsing and execution sophistication. In other embodiments the API query retrieve verb may be parsed and executed or translated into a format supported by the underlying data store regardless of type.

In certain embodiments an underlying data store cannot be made to implement equivalent or corresponding functionality which is supported by a different type of data store. In such cases the API may map to functionality at an application layer external to the underlying data store or itself in which the Application layer function retrieves data from the underlying data store utilizing supported query logic and then manipulates the data at the application layer to reflect the functionality which is not implementable within the underlying data store or itself. The resulting data may then be placed into a caching layer or written to a temporary location within the data store so that an optimized database query can retrieve the manipulated data for example as part of a sub query that may otherwise require the functionality which is not implementable within the data store itself. In such a way the API appears to a referencing entity as though the requested functionality is supported regardless of whether the non relational data store or the relational data store is targeted.

In accordance with some embodiments optimizer agent may seek to implement data guarantees where data inconsistency may potentially exist. For example in one embodiment optimizing the database query includes a identifying a first sub query to the non relational data store b identifying a second sub query to the relational data store in which the second sub query is a data delta query to an append log of the relational data store for new or updated data elements within the scope of the first sub query to the non relational data store which are not yet flushed from the append log of the relational data store to the non relational data store e.g. determines a data delta between a guaranteed up to date append log and a potentially out of date non relational data store c executing or triggering a flush against the relational data store to flush the new or updated data elements within the append log of the relational data store to the non relational data store and d eliminating the second sub query to the relational data store from the optimized database query . Stated differently where data consistency guarantees are deemed important enough by the optimizer agent for a particular data request the database query may be optimized to ensure that the non relational data store which may ordinarily exhibit some level of acceptable data inconsistency is made to be up to date immediately prior to executing the final optimized database query against the non relational data store . Such situations may arise where information that is permanently stored in a non relational data store is transacted initially and temporarily to a relational data store . In alternative embodiments only the missing elements reflected by the data delta are synchronized or are joined in a temporary cache location.

In accordance with one embodiment executing the optimized database query against the multi tenant database system to retrieve the data requested includes a designating the data to be retrieved as a massive data set based on a comparison of an estimated or actual size of the data to be retrieved against a massive query threshold b breaking up the optimized database query into a plurality of optimized sub queries e.g. each optimized sub query corresponding to a portion of the massive data set c allocating execution of the plurality of optimized sub queries to one work thread processor within a pool of work thread processors in which the one work thread processor to establish a spooling algorithm internal to the one work thread processor to spool cache one or more portions of the massive data set returned to the one work thread processor responsive to execution of one or more of the plurality of optimized sub queries and further in which the spooling algorithm retrieves a re requested portion of the massive data set from the spool cache when available in place of re executing a corresponding optimized sub query to retrieve the re requested portion from the underlying data store e.g. or . Such a technique may be referred to as chunking. 

In such a way a request soliciting a massive data set can be serviced in parts without triggering multiple distinct work thread processors to execute in parallel in an effort to complete execution of the un optimized database query . Such an approach may be especially beneficial where a massive data set is triggered or requested by mistake e.g. the query is broader than it need be or where a retrieving a massive data set in parallel e.g. as quickly as possible could detrimentally impair performance of the multi tenant database system for other customer organizations utilizing the system.

For example a customer organization may initiate a request for data not realizing the size of the resultant data set may be massive. Although total execution time may be increased for the requesting party e.g. one of the customer organizations the total load on the multi tenant database system which is shared by multiple customer organizations may be lessened and thus overall system efficiency may be improved. Moreover if a party is reviewing portions of the data due to the large size of the resultant data set those sub portions may be transmitted more efficiently having been broken up into parts or chunks and re requests for sub portions triggered by for example paging backwards and forward through a data set are made more efficient by being serviced via the spooling algorithm implemented by the one work thread processor responsible for executing the optimized sub queries. In such an embodiment optimizing the database query results in the optimized database query being arranged for serialized execution rather than parallelized execution.

In one embodiment executing the optimized database query against the multi tenant database system to retrieve the data includes a sending the optimized database query to a query layer agent that operates on behalf of the multi tenant database system or operates within the multi tenant database system e.g. such as query layer . In such an embodiment the query layer agent executes a plurality of sub queries constituting the optimized database query against the relational data store and the non relational data store based in part on the customer schema e.g. and based further on an optimized query syntax defined by the plurality of optimized database sub queries .

In one embodiment a query layer agent e.g. executes the plurality of optimized sub queries making up an optimized database query by designating or allocating each of the plurality of optimized sub queries to one distinct work thread processor within a pool of work thread processors in which each work thread processor in the pool executes zero one or a plurality of the plurality of sub queries constituting the optimized database query . In such a way an optimized database query may be parallelized resulting in a more time efficient execution.

Different types of data may be stored by multi tenant database system . For example in one embodiment the one or more data elements residing within the non relational data store correspond to plurality of compressed flat files or a plurality of binary files or a combination of compressed flat files and binary files. Such files may be more efficiently stored via a non relational database store e.g. .

In another embodiment relational data store implements a relational database in accordance with a relational database management system RDBMS in which a plurality of relation tables of the relational database are inter related to each other through one or more overlapping common characteristics for each of two or more relation tables within the relational database thus forming the relationships which are commonly associated with relational type data stores .

In one embodiment the non relational data store implements a distributed structured database having a plurality of underlying hardware storage devices each providing at least a portion of a total storage capacity for the non relational data store . In such an embodiment data elements within the non relational data store are referenceable on the basis of a primary key but are not referenceable on the basis of one or more overlapping common characteristics between two or more relation tables such as is the case with data elements within the relational data store .

In one embodiment the relational data store implements a relational database model selected from among the following an Oracle compatible database implementation an IBM DB2 Enterprise Server compatible relational database implementation a MySQL compatible relational database implementation and a Microsoft SQL Server compatible relational database implementation.

In one embodiment the non relational data store implements a NoSQL non relational database implementation selected from among the following a Vampire compatible non relational database implementation an Apache Cassandra compatible non relational database implementation a BigTable compatible non relational database implementation and an HBase compatible non relational database implementation.

In one embodiment the non relational data store includes a plurality of distributed computing nodes each computing node comprising at least a memory one or more processors and one or more communicatively interfaced hard disk drives. In such an embodiment each of the distributed computing nodes may further include an isolated non relational database instance having functionality to read write and update non relational database transactions without authorization or control from a centralized transaction authority.

In a particular embodiment the relational data store implements a monolithic relational database instance comprising memory and processors that coordinate computing resources with a centralized transaction authority that controls whether updates or changes to the monolithic relational database instance are committed to persistent storage upon persistent storage devices communicatively interfaced to and controlled by the monolithic relational database instance.

In one embodiment system includes a memory and a processor or processors . For example memory may store instructions to be executed and processor s may execute such instructions. System includes bus to transfer transactions and data within system among a plurality of peripheral devices communicably interfaced with bus . System further includes web server for example to receive requests return responses and otherwise interface with remote clients such as client devices located within customer organizations A C.

System is further depicted as having a query layer agent designed to transmit transact execute designate and or allocate optimized data queries and optimized database sub queries against multi tenant database system such as that depicted at element of . In some embodiments query layer agent passes the optimized database queries to the multi tenant database system for execution without specifying how to process optimized sub queries. In other embodiments the query layer agent manages how optimized sub queries are parallelized and or serialized for execution.

System further includes a global caching layer to provide caching services to communicably interfaced devices and systems and in particular provide caching of customer schema data e.g. meta data etc. database analytics database statistics stored pre query results etc such as that which is provided by customer schema and or analytics engine module each of which operate in conjunction with the global caching layer . For example customer schema specifies whether requisite data elements are stored by a relational database or a non relational database implementation within the multi tenant database system or both and may further specify locations within the underlying data stores for one or more data elements that make up a dataset for a corresponding request. Analytics engine module specifies and stores various statistics and database analytics. Information associated with customer schema and analytics engine module may be stored upon a hard drive a persistent data store or other storage location within system .

Distinct within system is hardware based Optimizer Agent which includes statistics processor customer schema processor pre query generator and sub query processor . In accordance with one embodiment statistics processor retrieves database statistics analytics and stored pre query probing query results from the global caching layer or from analytics engine module . Customer schema processor may retrieve the one or more locations of the requested data that is to be retrieved from the underlying data stores based on the request or may retrieve equivalent information from the global caching layer . Pre query generator develops and generates the necessary probing queries or pre queries when necessary to either retrieve sub sets or portions of the requested data from the appropriate underlying data stores when such pre queries are evaluated to be beneficial. Some pre queries may trigger or initiate join operations causing data subsets to be synchronized flushed or replicated from one data store to another so that subsequent sub queries can retrieve an entire requested data set from a lone data store. Such pre queries may rely upon statistics and pre query results available from the analytics engine module . Sub query processor may perform optimization upon individual sub queries to generate an overall optimized database query. Such optimizations may include the introduction of a foreign key injection inserting a join operation re ordering re sequencing underlying sub queries and so forth so as to optimize the resulting database query that is to be executed.

Method begins with processing logic receiving a request at a host system for the multi tenant database system the request specifying data to be retrieved from the multi tenant database system block . At block processing logic retrieves based on the request via the host system one or more locations of the data to be retrieved.

At block processing logic retrieves via the host system a customer schema responsive to receiving the request. For example a customer schema may describe the one or more locations of data to be retrieved the customer schema specifying each of the plurality of data elements of the data as residing within either the non relational data store or residing within the relational data store or as being available from both the non relational data store and the relational data store.

At block processing logic generates at the host system a database query based on the request. For example the database query may specify a plurality of data elements to be retrieved the plurality of data elements including one or more data elements residing within the non relational data store and one or more other data elements residing within the relational data store. The database query may further include a plurality of sub queries. In one embodiment the database query specifies a join operation via one of the sub queries. In some embodiments a database query is specified by or provided within an incoming customer request.

At block processing logic optimizes the database query via a query optimizer to generate an optimized database query having an optimized query syntax that is distinct from a query syntax of the database query. Such query optimizations improve one or more execution characteristics above and beyond that which is provided for via the originally specified database query or an un optimized database query such as execution time consistency guarantees serializing or parallelizing execution based on specified policy etc.

At block processing logic executes the optimized database query against the multi tenant database system to retrieve the data. In accordance with some embodiments the original database query specified or requested for execution is discarded and is not passed to the multi tenant database system for execution thus leaving only the optimized database query to be executed.

At block processing logic generates database analytics for one or more customer organizations based on data structures and historical database queries corresponding to each of the one or more customer organizations. For example statistics and database analytics may be generated on a per customer organization basis. In some embodiments such statistics and analytics are executed prior to receiving a database query which requires them. Alternatively statistics and analytics may be generated on the fly responsive to receiving a database query to be optimized and then used in the database query optimization process. Cross customer organization statistics and analysis may similarly be generated and utilized by a query optimizer.

At block processing logic generates and executes one or more pre queries and utilizes the results of the one or more pre queries in generating the optimized database query. For example an optimizing agent may rank the executed pre queries on the basis of one or more metrics including Input Output I O utilization for the pre query processor utilization for the pre query and or execution time for the pre query and generate the optimized database query based on the ranking of the executed pre queries. Various policies may control the rankings. For example one policy may emphasize reduced I O utilization while another may emphasize reduced processor loads while yet another emphasizes fasted execution times for example by implementing sub queries that may be executed in parallel.

The exemplary computer system includes a processor a main memory e.g. read only memory ROM flash memory dynamic random access memory DRAM such as synchronous DRAM SDRAM or Rambus DRAM RDRAM etc. static memory such as flash memory static random access memory SRAM volatile but high data rate RAM etc. and a secondary memory e.g. a persistent storage device including hard disk drives and persistent multi tenant database implementations which communicate with each other via a bus . Main memory includes customer schema e.g. specifies one or more locations of data or data elements constituting a specified data or data set among two or more diverse data stores such as locations of data elements spread across both a relational data store and a non relational data store and retrievable via a query layer agent or via a hardware based optimizer agent . Hardware based optimizer agent may implement database query optimizations based on statistics and analytics stored within global caching layer or available via an analytics engine. In one embodiment global cache layer resides within memory and implements a system wide accessible global caching layer to provide meta data and other association or correspondence information between multiple data elements of a larger data set such as the type of information provided via customer schema in addition to analytics and statistics. Main memory and its sub elements e.g. and are operable in conjunction with processing logic and processor to perform the methodologies discussed herein.

Processor represents one or more general purpose processing devices such as a microprocessor central processing unit or the like. More particularly the processor may be a complex instruction set computing CISC microprocessor reduced instruction set computing RISC microprocessor very long instruction word VLIW microprocessor processor implementing other instruction sets or processors implementing a combination of instruction sets. Processor may also be one or more special purpose processing devices such as an application specific integrated circuit ASIC a field programmable gate array FPGA a digital signal processor DSP network processor or the like. Processor is configured to execute the processing logic for performing the operations and functionality which is discussed herein.

The computer system may further include a network interface card . The computer system also may include a user interface such as a video display unit a liquid crystal display LCD or a cathode ray tube CRT an alphanumeric input device e.g. a keyboard a cursor control device e.g. a mouse and a signal generation device e.g. an integrated speaker . The computer system may further include peripheral device e.g. wireless or wired communication devices memory devices storage devices audio processing devices video processing devices etc.

The secondary memory may include a non transitory machine readable storage medium or more specifically a non transitory machine accessible storage medium on which is stored one or more sets of instructions e.g. software embodying any one or more of the methodologies or functions described herein. The software may also reside completely or at least partially within the main memory and or within the processor during execution thereof by the computer system the main memory and the processor also constituting machine readable storage media. The software may further be transmitted or received over a network via the network interface card .

The first column of each table labeled query sets forth an original query second column a corresponding optimized query third column and optimization notes for the queries as depicted by query example rows and respectively.

Each query row provides an example of a potential database query optimization in accordance with the described embodiments. For example the various query example rows depict filtering optimizations e.g. an upper bound optimization range scan termination optimizations and negation of a join operation optimization empty byte value optimization in place of an IS NULL function and an example of a sub query optimization implementing evaluation logic within a generated optimized database query e.g. thus negating an otherwise required join operation .

While the subject matter disclosed herein has been described by way of example and in terms of the specific embodiments it is to be understood that the claimed embodiments are not limited to the explicitly enumerated embodiments disclosed. To the contrary the disclosure is intended to cover various modifications and similar arrangements as would be apparent to those skilled in the art. Therefore the scope of the appended claims should be accorded the broadest interpretation so as to encompass all such modifications and similar arrangements. It is to be understood that the above description is intended to be illustrative and not restrictive. Many other embodiments will be apparent to those of skill in the art upon reading and understanding the above description. The scope of the disclosed subject matter is therefore to be determined in reference to the appended claims along with the full scope of equivalents to which such claims are entitled.

