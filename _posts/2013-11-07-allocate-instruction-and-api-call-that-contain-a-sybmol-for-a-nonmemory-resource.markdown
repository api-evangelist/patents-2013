---

title: Allocate instruction and API call that contain a sybmol for a non-memory resource
abstract: A novel allocate instruction and a novel API call are received onto a compiler. The allocate instruction includes a symbol that identifies a non-memory resource instance. The API call is a call to perform an operation on a non-memory resource instance, where the particular instance is indicated by the symbol in the API call. The compiler replaces the API call with a set of API instructions. A linker then allocates a value to be associated with the symbol, where the allocated value is one of a plurality of values, and where each value corresponds to a respective one of the non-memory resource instances. After allocation, the linker generates an amount of executable code, where the API instructions in the code: 1) are for using the allocated value to generate an address of a register in the appropriate non-memory resource instance, and 2) are for accessing the register.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09262136&OS=09262136&RS=09262136
owner: Netronome Systems, Inc.
number: 09262136
owner_city: Santa Clara
owner_country: US
publication_date: 20131107
---
The described embodiments relate generally to linkers and to the allocation of resource instances in the generation of executable code and more particularly to the generation of executable code for multiprocessor systems.

A computer system may have several embedded processors. To program the embedded processors an amount of source code may be written for each processor. The C programming language is often used. The C source code for each processor is compiled by a C compiler into a corresponding amount of object code. The amounts of object code are then converted by a linker into corresponding amounts of executable code. The amount of executable code for a first of the embedded processors is loaded into program memory of the first embedded processor and the amount of executable code for a second of the embedded processors is loaded into program memory of a second embedded processor and so forth. After loading each processor executes its respective amount of executable code.

It may be desired that some memory of the computer system only be accessible and usable by only one of the processors whereas another part of the memory should be accessible and usable by all of the processors. A header file is therefore typically written to accompany the source code. The header file declares arrays of memory resources variables and functions and contains an indication of which parts of code should be able to access each of the declared identifiers. For example if a memory array is to be referred to by a symbol name and if two parts of the code are be able to access the same memory array then the same symbol name set forth in the header file will be used in the two parts of code to refer to the same memory array. If another memory array is only to be accessible by one of the parts of the code then a symbol representing that memory array will only be used in the appropriate part of the code. There are several ways of preparing the code to accomplish this but a header file is typically used to record which parts of the code are to be able to use which declared identifier. The content of the header file is managed by the programmer.

In a first novel aspect a source code symbol can be declared to have a scope level indicative of a level in a hierarchy of scope levels where the scope level indicates a circuit level or a sub circuit level. Location information is supplied to a linker program. The location information indicates where different amounts of the object code are to be loaded into a system. The system may for example be an integrated circuit having islands. The location information may indicate that a first amount of code is to be loaded into program memory in a first island so that the first code can be executed by a first processor on the first island and that a second amount of code is to be loaded into program memory in a second island so that the second code can be executed by a second processor on the second island and so forth. A novel linker program uses the location information and the scope level information of the symbol to uniquify instances of the symbol if necessary to resolve name collisions of symbols having the same scope. If for example the scope level of the symbol is island and if object code for multiple islands includes the same symbol then instances of the symbol appearing in the object code for an island are replaced with a uniquified symbol that does not appear in the object code for any other island. If a symbol has a scope level of global however then no symbol uniquification is performed. The same symbol can appear in the code for all the islands. After the symbol uniquification step the linker performs a resource allocation step. A resource instance is allocated to each symbol. After resource allocation the linker replaces each instance of the symbol in the object code with the address of the allocated resource instance. The resulting executable code is then loaded into the system so that the different amounts of executable code are loaded into the correct places in the system as indicated by the location information.

In a second novel aspect a linker allocates resource instances of a non memory resource. A declare instruction is used to declare a pool of the non memory resource instances. An allocate instruction is then used to instruct the linker to allocate a non memory resource instance from the pool to be associated with a symbol. The symbol is then usable in source code to refer to the corresponding non memory resource instance. At link time the linker program allocates non memory resource instances to symbols in accordance with the allocate instructions. The linker then replaces each instance of the symbol in the object code with the address of the corresponding allocated resource instance thereby generating executable code. Examples of non memory resource instances include hardware ring circuits and hardware event filter circuits.

In a third novel aspect a declare instruction can be used to declare a sub pool of resource instances to be taken from the resource instances of a larger declared pool. In this way a hierarchy of pools and sub pools can be declared using declare instructions. Allocate instructions can then be used to instruct the novel linker to make allocations from a desired pool or a desired sub pool of the hierarchy. Although the three novel aspects are set forth above separately multiple ones of the novel aspects can be provided together in various embodiments. For example hierarchical pools of non memory resources can be declared and then multiple allocations can be made from the pools or sub pools where the allocations have different scopes.

In a fourth novel aspect a first amount of code is received onto a compiler. The first amount of code includes an allocate instruction and an API Application Programming Interface call. The allocate instruction includes a symbol that identifies one of a plurality of non memory resource instances. The API call is a call to perform an operation on one of the non memory resource instances. The API call includes the symbol and the symbol of the API call indicates that the particular non memory resource instance that the API call is to operate on is the very same non memory resource instance of the allocate instruction. After receiving the allocate instruction and the API call the compiler replaces the API call in the first amount of code with a plurality of API instructions. A linker then allocates a value to be associated with the symbol where the value is one of a plurality of values and where each value corresponds to a respective one of the plurality of non memory resource instances. After the allocation operation the linker generates and outputs a second amount of executable code. The executable code includes the API instructions. Eventual execution of the API instructions will cause the allocated value to be used to generate an address of a register where the register is a register in the particular non memory resource instance indicated by the symbol in the API call. After the address of the register has been generated further execution of the executable code will cause the register to be accessed in a way specified by the API call. In one specific example the API call is a call to perform a write to a configuration register of a particular non memory resource instance where the particular non memory resource instance is identified by the symbol. In another specific example the API call is a call to perform a PUT to a particular hardware ring circuit where the particular hardware ring circuit is identified by the symbol. In another specific example the API call is a call to perform a GET from a particular hardware ring circuit where the particular hardware ring circuit is identified by the symbol. In another specific example the API call is a call to write data to an event filter circuit where the particular event filter circuit is identified by the symbol. In another specific example the API call is a call to receive data from an event filter circuit where the particular event filter circuit is identified by the symbol.

Further details and embodiments and techniques are described in the detailed description below. This summary does not purport to define the invention. The invention is defined by the claims.

Reference will now be made in detail to background examples and some embodiments of the invention examples of which are illustrated in the accompanying drawings.

In a first novel aspect a source code symbol can be declared to have a scope level indicative of a level in a hierarchy of scope levels where the scope level indicates a circuit level or a sub circuit level. In one example the source code for the processor in island1 is to include a symbol X2 where this symbol refers to one of the littleitem resources. At the same time the source code for the processor in island2 is to include the same symbol X2 but this symbol as used in this amount of source code is to refer to another of the littleitem resources. The source code for the second processor is nearly identical to the source code for the first processor yet reference to the X2 symbol in the code of the first processor is not to refer to the particular littleitem register used by second processor and reference to the X2 symbol in the code of second processor is not to refer to the particular littleitem register used by the program executing on first processor . In addition to the two littleitem resource instances used by two programs the two instances of the source code are both to use a common single instance of the bigitem resource. An instance of the symbol Y2 appearing in the code for the first processor is to refer to the same bigitem register that an instance of the symbol Y2 appearing in the code for the second processor refers to.

Rather than having to use different symbols to manage manually which of the resource instances as described in the background information section above the new declare instruction is used and a new allocate instruction is used. The new instructions are usable to declare a symbol to have a scope level in a hierarchy of scope levels where the scope levels correspond to circuit and sub circuits within the integrated circuit.

The scope level of island of a symbol in accordance with this embodiment does not just require that the resolved symbol be unique in a particular section of code or be unique in a particular section of code that is to be loaded into a particular part of memory but rather the scope level of island requires that the symbol be unique within an island into which the code that contains the symbol is to be loaded. An island is a particular type of hardware structure. The linker is supplied with location information that indicates the island into which the code code that contains the symbol is to be loaded and more particularly in one example the island and a particular microengine program memory within that island. The linker uses this special type of location information to uniquify the symbol in accordance with the scope level set forth in the allocate instruction.

The header file ME1 ME2.H and the source code files ME1.0 and ME2.0 having the new declare and new allocate instructions are compiled by compiler program thereby generating an amount of object code ME1.O for the processor of island1 and an amount of object code ME2.O for the processor of island2. illustrates the amount of object code for the first processor of island1. illustrates the amount of object code for the second processor of island2. Note that the compiler has replaced each API call appearing in the source code with a set of lower level instructions that cause the desired operation of the API call to be carried out. In the simplified example being described here the API call of was to cause a write of the value 073 into the X2 littleitem resource instance. Accordingly the object code in includes a load instruction to load the value 073 into the resource instance identified by symbol X2. Similarly the API call of has been replaced with a load instruction in the object code of . Although not shown in the declare instructions and the allocate instructions of the source code header file of are present in the two amounts of object code due to the INCLUDE ME1 ME2.H instructions in each of the source code files. The declare and allocate instructions just pass through the compiler as text and appear one for one as text in the object code output of the compiler. In another example the declare and allocate instructions just pass through the compiler in a binary form into the resulting object file.

Next the amounts of object code of along with the declare and allocate instructions as passed through the compiler are supplied to the linker program . The linker is also supplied with location information see that indicates where in the integrated circuit the object code ME1.0 is to be loaded and where in the integrated circuit the object code ME2.0 is to be loaded. In one example the location information is supplied by the programmer using a linker script that is interpreted by the linker program . In another example the location information is supplied by the programmer using a command line interface of a GUI interface see to the linker. In the present example the location information indicates that the object code of ME1.0 is to be loaded into the first island1 and the object code of ME2.0 is to be loaded into the second island2 .

The linker program then builds a symbol table . is a diagram of symbol table . Symbol table has a row for each resource instance on the integrated circuit that can be allocated. In the example of the integrated circuit of there are sixteen resource instances of type littleitem and there are four resource instances of type bigitem. The linker program traverses through the object code of and records into the symbol table the scope level for each symbol encountered. The linker program then processes through the object code in a novel symbol uniquification operation. If a symbol is defined to have a scope level island then all usages of the symbol within code to be executed on an island are to refer to the same resource instance but are to be unique with respect to usages of the symbol appearing in code to be executed on other islands. Accordingly when the linker processes the code and encounters a symbol such as symbol X2 that has a scope level of island the linker uses the island number to modify the X2 symbol so that after uniquification instances of the symbol in the code for the processor of one island will be different from instances of same symbol in the code for the processor of another island. In the example described here a symbol of scope level island appearing in code to be executed on an island is uniquified by adding the island number to the symbol name thereby generating a modified symbol name. For example the symbol X2 of scope level island appearing in object code of for execution by processor of the first island1 is modified by adding the island number 1 to the symbol X2 thereby generating a unique symbol X2 1. All instances of the X2 symbol appearing in the object code of are replaced with the uniquified symbol X2 1. In the same way the symbol X2 appearing in code for the processor of the second island2 is modified by adding the island number 2 to the symbol X2 thereby generating a unique symbol X2 2. All instances of the X2 symbol appearing in the object code of are replaced with the uniquified symbol X2 2. When the linker encounters an instance of the symbol Y2 appearing the lines and of the object code of however the linker recognizes that the scope level of the symbol Y2 is global. The linker therefore does not uniquify instances of the Y2 symbol.

The linker then performs allocation on the modified object code of . As a result of the declare and allocate instructions the resource instance littleitem2 1 is allocated to be associated with the uniquified symbol X2 1. The scope level of the symbol x2 1 is island . This information is recorded in row of the symbol table of .

Similarly another littleitem resource instance littleitem3 2 is allocated to be associated with the uniquified symbol X2 2. The scope level of the symbol x2 1 is island and this information is recorded in row of the symbol table of .

A resource instance of type bigitem is allocated to be associated with the symbol Y2. Due to the symbol Y2 being of global scope only one bigitem is allocated. This allocation is recorded in row of the symbol table of .

Once resource instances have been allocated to all the uniquified symbols the linker program patches each instance of a symbol appearing in the modified object code with the associated value of the symbol. In the example described here the resource instances are memory locations in the integrated circuit. A single memory location is also referred to here as a register. Accordingly the value to be associated is an address in this example. Accordingly the value to be associated is an address in this example. Due to the linker s knowledge of the structure of the integrated circuit the linker is aware of the address of each of these memory locations. The address of a particular memory location is fixed and determined by the hardware of the integrated circuit. In the present example littleitem2 1 has an address of 0x100 littleitem2 2 has an address of 0x200 and bigitem has an address of 0x300. In the patching operation the linker program replaces each instance of the symbol X2 1 with the address 0x100 of the resource instance that has been allocated to symbol X2 1. Similarly the linker program replaces instance of the symbol X2 2 with the address 0x200 of the resource instance that has been allocated to symbol X2 2 and the linker replaces instances of the symbol Y2 with the address 0x300 of the resource instance that has been allocated to symbol Y2. The result of these replacements is an amount of executable code for the processor of island1 and an amount of executable code for the processor of island2. This code is output from the linker as a single file ME1 ME2.EXE. is a diagram of the executable code of the file ME1 ME2.EXE.

Next the loader program is used to load the executable code of into the integrated circuit so that the amount of executable code for processor is loaded into program memory in island1 and the amount of executable code for processor is loaded into program memory in island2.

Although the simplified example set forth above only involves two scope levels of global and island the linker program in another embodiment recognizes four scope levels global island processor and context within a processor. Within an island there are multiple processors. Each of these processors has an associated amount of program memory from which it accesses executable program code. For each amount of object code the location information supplied to the linker program indicates the processor into whose program memory the code is to be loaded and also indicates the island that contains the processor. Accordingly a symbol for example X2 can be uniquified at the processor level by declaring the symbol to have a scope level of processor. In such a case source code for two processors executing code within the same first island can use the same source code symbol X2 to refer to two different resource instances within the first island. Similarly source code for two processors executing code within the same second island can use the same source code symbol X2 to refer to two other different resource instances within the second island. In this way instances of the source code symbol X2 in different amounts of code for different processors refer to resource instances that are unique within the code space for each processor. Alternatively if the symbol X2 had been declared to be of scope island then the multiple source code instances appearing the amounts of program codes of the different processors of the first island would all refer to the same one resource instance. Likewise the multiple source code instances appearing the amounts of program codes of the different processors of the second island would all refer to the same one resource instance but that resource instance would not be the same resource instance used by the processors in the first island. Alternatively if the symbol X2 had been declared to be of scope global then all instances of the symbol X2 would refer to the same one resource instance regardless of where in the integrated circuit the code that contains the instances of symbol X2 are to be loaded.

In a second novel aspect the linker program allocates instances of a non memory resource. A declare instruction in the ME1 ME2.H header file declares a pool to consist of four resource instances which the source code treats as the four hardware ring circuits . A ring here is a non memory hardware communication circuit that includes an amount of logic circuitry in addition to a set of registers. A processor can interact with a ring via its registers. A processor can call an API for rings where an argument of the API call identifies a particular ring and where another argument of the API call indicates the type of ring operation to be performed by the identified ring. In the same way that the API call described above results in the compiler replacing the API call in the source code with a set of machine code instructions to carry out a write to a register specified by the API call the API call here relating to a ring is replaced by the compiler with a set of machine code instructions to carry out the ring operation specified by the API call. Ring operations that the API call can be used to perform include a ring PUT operation and a ring GET operation. Two processors that can communicate with the same ring circuit can use PUT and GET operations to communicate through the ring circuit with one another. If the API call is for a PUT operation then a processor writes a value into a particular interface register of the specified ring circuit and the ring circuit hardware then uses the information in the register to perform the remainder of the PUT operation. If the API call is for a GET operation then the hardware of the ring circuit performs the GET operation and then loads into an interface register the value to be recovered from the ring. The processor then reads the interface register to complete the GET operation. In the declare instruction of the optional field can be used to specify a previously declared pool from which the resource instances being declared to be of pool MAIN POOL are taken. The field of the declare instruction indicates that the name of the pool will be MAIN POOL . The field indicates that the scope level of MAIN POOL is global. The field indicates that four resource instances will make up MAIN POOL.

In addition to the declare instruction the header file ME1 ME2.H also contains one or more allocate instructions for non memory resources. An allocate instruction is an instruction to the linker to allocate a resource instance to be associated with a symbol. In the example allocate instruction of the allocate instruction instructs the linker program to allocate one of the four resource instances of the pool MAIN POOL to be associated with the symbol R1. Field indicates that one resource instance of pool MAIN POOL as indicated by field will be allocated to be associated with the symbol name R1 appearing in field . Field indicates that the scope level of symbol R1 will be island . Similarly the allocate instruction instructs the linker program to allocate another of the four resource instance of the pool MAIN POOL to be associated with the symbol R2. Thereafter in the source code the programmer can refer to ring R1 and R2. At link time the linker will handle allocating an appropriate one of the available resource instances of the pool MAIN POOL to each of the symbols R1 and R2. After the API calls in the source code for the rings have been replaced by machine code instructions the instances of the symbol R1 in the code will be replaced with the base address for ring R1 and the instances of the symbol R2 will be replaced with the base address for ring R2. In the present example the base address for ring RING1 is 0x500 and the base address for ring RING2 is 0x600. The base address for each of RING1 RING2 RING3 and RING4 is fixed and determined by the hardware of the integrated circuit. Note that in the symbol table of the 0x500 base address is present in the row for RING1 and that the 0x600 base address is present in the row for RING2. The API machine code in the object code uses the supplied base address of ring as an offset to calculate the actual addresses of the appropriate interface registers within the ring hardware to be accessed in order to carry out the ring operation being specified. Resource instances of non memory resources can be allocated in this way using the declare and allocate instructions without the user of API calls.

In a more simple case an instance of a non memory resource is allocated to a symbol. Afterward when the linker encounters the symbol in the object code the linker replaces all instances of the symbol with the value address of the instance of the non memory resource. The example of a hardware ring circuit is just an example of one possible type of non memory resource that can be allocated using the novel linker. In another example the integrated circuit includes several event filter circuits. An allocate instruction is usable to allocate one of these event filter circuits with a symbol. In some embodiments after allocation the linker replaces instances of the symbol with the base address of the particular event filter that was allocated thereby generating an amount of executable code. In other embodiments after allocation the linker replaces bits within the object file associated with instances of the symbol with a value associated with a symbol of the particular event filter that was allocated thereby generating an amount of executable code.

In a third novel aspect a hierarchy of pools and sub pools of resource instances are declared and then the linker program makes allocations out of the pools and or the sub pools. illustrates how the header file ME1 ME2.H can be used to declare a pool MAIN POOL and also to declare a sub pool SUB POOL taken from the resource instances in the MAIN POOL. As in the example of declare instruction declares a pool of four resource instances that will be called MAIN POOL. In the example of however a second declare instruction the declares a pool of two resource instances called SUB POOL to be taken from the previously declared MAIN POOL. In a first allocate instruction the linker program is instructed to allocate one of the resource instances of the previously declared pool called SUB POOL to be associated with the symbol R1. That one resource instance is being allocated is indicated by field . That the resource instance is to be taken from SUB POOL is indicated by field . The name of the symbol is indicated by field . In a second allocate instruction the linker program is instructed to allocate another of the rings of the previously declared pool called SUB POOL to be associated with the symbol R2. As indicated by this example a hierarchy of pools is declared and allocations can then be made from pools and or from sub pools of the hierarchy using allocate instructions.

Although certain specific embodiments are described above for instructional purposes the teachings of this patent document have general applicability and are not limited to the specific embodiments described above. Although the compiler linker and loader programs are described above as being stored in program memory in the computer as one example of a processor readable medium the compiler linker and loader can be stored on other processor readable media such as on a magnetic medium such as a hard disc and or on an optical medium such as a CD or DVD and or in a semiconductor memory such as a portable memory stick device . Accordingly various modifications adaptations and combinations of various features of the described embodiments can be practiced without departing from the scope of the invention as set forth in the claims.

