---

title: Functions and associated communication capabilities for a speech analytics component to support agent compliance in a call center
abstract: A command set and associated capabilities are defined for a speech analytics component (“SAC”) in a call center. The speech analytics component is used to monitor speech of an agent and a remote party on a call for the purpose of determining whether the agent is complying with various call center policies or applicable regulations. The command set allows the call handler to instruct the SAC to load a keyword set into memory for future use, apply the keyword set to an indicated call and for an indicated party, to remove use of the keyword set, and to release the keyword set from memory. This allows the SAC to monitor speech as required for a particular context, which is known to the call handler, but not necessarily by the SAC. In this way, efficient use of the SAC processing resource is obtained for various call contexts.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09602665&OS=09602665&RS=09602665
owner: Noble Systems Corporation
number: 09602665
owner_city: Atlanta
owner_country: US
publication_date: 20130816
---
This application is a continuation in part of U.S. non provisional patent application Ser. No. 13 949 467 now U.S. Pat. No. 9 225 833 entitled Management System for Using Speech Analytics To Enhance Contact Center Agent Conformance filed on Jul. 24 2013 the contents of which are incorporated by reference for all it teaches.

The concepts and technologies disclosed herein generally pertain to operation of a speech analytics component used in a contact center for the management of agent compliance with contact center policies.

Speech analytics can be used to monitor speech of parties on a telephone call in a call center. This can be a useful tool for managing agent conformance with call center policies and regulations for various contexts as described in the above identified patent application Management System for Using Speech Analytics To Enhance Contact Center Agent Conformance the contents of which are incorporated by reference. Doing so requires a speech analytics component to monitor speech of the parties and report detection of various words and or phrases in a keyword set. However doing so by the speech analytics component can be processing intensive and scaling a solution to manage an increasing number of potential compliance contexts during a call as well for an increasing number of calls can require increasing processing resources. This in turn may cause increased capital costs to be expended to operate the additional computer servers and resources rendering the application of speech analytics for managing agent conformance to be cost prohibitive. Therefore systems and methods are required to reduce the processing requirements in the speech analytics component when used in a call center to manage agent compliance by using speech recognition.

Various embodiments are disclosed for managing application of keyword sets in a speech analytics component that may be used in one embodiment for managing compliance enforcement in a contact center. In various embodiments commands may be sent from a call handler to a speech analytics component SAC to indicate how certain keyword sets are to be used. This includes a command for applying a specified keyword set on the speech of an indicated party on an indicated call. The SAC may recognize these various commands in order to more efficiently process speech from parties on a call. The call handler may variously direct the SAC as to which keyword sets should be used at what times for a call.

As is discussed in greater detail below the subject matter disclosed herein may be implemented as a computer controlled apparatus a method a computing system or as an article of manufacture such as a tangible non transitory computer readable storage medium. These and various other features will be apparent from the following Detailed Description and the associated drawings.

This Summary is provided to exemplify concepts at a high level form that are further described below in the Detailed Description. This Summary is not intended to identify key or essential features of the claimed subject matter nor is it intended that this Summary be used to limit the scope of the claimed subject matter. Furthermore the claimed subject matter is not limited to implementations that address any or all disadvantages noted in any part of this disclosure.

The present invention is generally directed to functional capabilities associated with a speech analytics component SAC in a call center. The SAC is used to analyze speech in a call between an agent and a remote party as is described in U.S. non provisional patent application Ser. No. 13 949 467 entitled Management System for Using Speech Analytics To Enhance Contact Center Agent Conformance filed on Jul. 24 2013 the contents of which are incorporated by reference for all it teaches. The SAC can report instances of detection of certain phrases or words called keywords in speech of the agent or the remote party.

The SAC can be used to manage agent compliance with various regulations and policies instituted by the call center. For example the SAC can be used to monitor the agent s speech to ensure that the agent does not ever utter curse words. It becomes evident that in various situations the remote party may utter a curse word to the agent but such occurrences do not warrant the agent responding in a similar manner. Thus for the SAC to be useful to managing agent compliance it has to be able to distinguish which party i.e. the remote party or the agent uttered the profanity. Merely knowing that one of the parties uttered a profanity does not aid in managing agent conformance since the agent may not be guilty of violating the policy.

The above example illustrates the need to know the context in which certain words are detected. The context involves all the information necessary to make a useful determination of whether a particular agent has complied with a policy or regulation. In the above example merely determining a profanity was uttered does not provide sufficient contextual information to know whether the policy was followed. However knowing which party uttered the profanity is necessary and allows a determination of whether the agent conformed to a no profanity policy or not.

In many instances the information necessary to determine the context may involve other aspects. For example a particular call may have to be identified or the campaign for which the call is associated with may have to be known. Obviously a policy requiring an agent to thank a called party for a donation does not make sense if the call campaign is for a customer satisfaction survey.

Similarly if the call center handles multiple calls and a corresponding set of agents knowing which agent uttered the profanity is also necessary. Merely knowing that one of several agents uttered the profanity may or may not be sufficient for the purposes of the call center administrator. For example the call center may have a no profanity policy and may determine if any agent violates the policy the administrator may address violations by reminding the entire workforce that profanity is not allowed. Other call centers may have a policy of identifying which agent violated the policy and individually counsel that agent as to the policy.

The context for determining whether a policy is adhered to may involve situations where the agent has to respond in a certain manner to information provided by the agent. For example certain regulations may require an agent to cease attempts in collecting a debt once the remote party has informed the agent that they have filed for bankruptcy. The call center may have as a policy that the agent should then inquire as to that person s lawyer or law firm handling the bankruptcy. As described in the aforementioned patent application entitled Management System for Using Speech Analytics To Enhance Contact Center Agent Conformance the agent s response may be monitored for certain keywords such as lawyer or attorney to ascertain if the agent inquired about the remote party s lawyer. In this context merely being informed by the SAC that a party spoke the word attorney or lawyer is not useful. Furthermore even if the notification merely indicates that the agent spoke one of these words such notification is not instructive. For example the agent could be informed by the remote party that they are a lawyer and the agent could confirm such. In this case knowing the required context in which the agent spoke a keyword involves knowing that the call is 

The above illustrates that the context of a particular compliance situation may be fact specific. The conditions in which compliance with a policy or regulation is adhered to or not can vary by a number of factors. Returning to the above mentioned debt collection example once the called party informs the agent of bankruptcy and the agent is determined to have inquired about the called party s lawyer or attorney there may not be any further need to monitor the call for this particular context again. That is once the agent has been determined as complying with the policy there is no need to continue to monitor the called party for an indication of bankruptcy filing. Further once the agent has inquired of the called party s lawyer there is no need to monitor the agent. Thus if the called party re iterates later in the call that they regret having to have filed for bankruptcy the SAC does not need to start monitoring the agent s speech again to determine if the agent has inquired about the called party s lawyer or attorney. In this case there is no need for the SAC to continuously monitor for keywords after a certain point.

As it can be appreciated from the above example in various contexts the SAC may be expected to monitor a designated party s speech for certain keywords and based on detecting a first keyword from a first party the SAC may be required to then monitor the other party for other keywords. Based on the context it may be necessary to return to the monitoring the original party s speech or not. Those experienced in call center operation will recognize that the possible situations for ascertaining compliance to regulations or policies will vary immensely. Generally it is desirable to avoid the SAC from having to know all these different contextual requirements which can change and which may be difficult to program into the SAC.

One approach for avoiding the SAC from knowing the contextual requirements is to have the SAC monitor speech for all the possible keywords at all times and report all instances when detected. As evident from the above examples this can provide numerous indications of keywords being detected that are not useful. Recall that once the agent has inquired about the called party s attorney that subsequent instances of the agent s use of such key words are no longer required. Furthermore significant processing resources can be expended in the SAC attempting to analyze all the speech for various keywords. Further reporting each instance may not be useful and so the call handler receiving such indications must know when to ignore them. This means that the processing resources in the call handler can also be minimized by avoiding unnecessary processing in the SAC.

Processing speech can be very intensive and as the scale of the call center increases so does the required processing power. Monitoring speech in real time of ten agents may require a given level of processing power and monitoring speech for fifty agents may require proportionately more. As the call center increases to several hundred agents or in some cases over a thousand agents the processing requirements may be significant. Further analyzing speech for keywords when such detection is not required further wastes resources. For example a call center may not need to monitor the remote party s speech for profanity but if it does so then processing resources are being wasted and at some point additional processing resources and management thereof may be required to detect the keywords that are required to be monitored.

The concepts and technologies herein allow the SAC to be informed as to which keyword sets should be applied and when. This avoids the SAC from having to know the context for each call and allows processing resources to be effectively used. This is accomplished by a small set of commands issued to the SAC by the call handling device. The command set directed to the SAC may involve LOAD APPLY REMOVE and RELEASE. The names used are not particularly significant as other names may be applied for commands and the corresponding functions to be performed. In other embodiments not all of these commands are required or additional commands may be defined.

In brief the LOAD command instructs the SAC to retrieve a keyword set from a data store and load it into working memory. The APPLY command instructs the SAC to use a specified keyword set in analyzing speech of an indicated party for a particular call. The REMOVE command instructs the SAC to cease applying a keyword set for analyzing speech and the RELEASE command indicates to the SAC that the keyword set is not required for the immediate future and so the memory can be used for other purposes.

Turning to a state transition diagram is illustrated that can be useful to explain the commands and corresponding functions in the SAC. The states represent combinations of various values of variables and conditions in the SAC at certain points in time and in response to receiving certain commands. The state may be entered upon powering up the system or after receiving a particular command from the call handler over an application programming interface API . The commands are sent from the call handler which may be a dialer or automatic call distributor in various embodiments. The call handler is presumed to be aware of the context for the particular compliance policy or regulation that is relevant and issues the commands to the SAC accordingly. Generally it is preferable to avoid requiring the SAC to know the details of the context that a particular call center regulation applies to.

The commands sent to the SAC will typically result in a response message from the SAC. A positive acknowledgement of a command is referred to herein as a Confirm message whereas a negative acknowledgement of the command is referred to herein as a Reject message. Other labels could be used in other embodiments. The Reject message reflects an exceptional or abnormal condition which will be explained further. In various embodiments these may include information as to why the particular response was sent such as a cause code if the command was not carried out . In most instances operation herein is illustrated by normal operation so that a Confirm message is illustrated in the diagrams. The format of the Confirm message for various situations is similar and hence may not be elaborated upon. Exceptions of which there are many possible that are not detailed herein would result in sending a Reject message.

Turning to the state transition diagram begins with the Null state . This state represents the state that exists in the SAC when first starting. This could be for example the state prior to the SAC receiving a call leg from the call handler. The first command to be received by the SAC is a LOAD command . The figure illustrates this command as LOAD Confirm to reflect the command LOAD and the expected response under normal conditions Confirm . Thus the format is Command Response with a forward slash separating the two. Thus at the very beginning of system startup the SAC receives a LOAD command from the call handler and in response the SAC will load the identified keyword set into its working memory and respond with a Confirm message . As a result the SAC is in the Keyword Set Loaded state .

In the Keyword Set Loaded state the SAC has loaded the keyword set into its working memory and is ready to use the keyword set for analyzing speech once it is commanded to do so. There may be various so called housekeeping details associated with loading the keyword set such as initializing parameters and pointers establishing initial matrix values etc. These functions may take some time and so it may be preferable for the SAC to load the keyword set prior to requiring its use even though the time for these housekeeping functions may take only a fraction of a second. The keyword set may be retrieved from a local data store or a remote data store. Various local networks can be used to retrieve the keyword set from a data store.

At this point the SAC is ready to receive a command to use the loaded keyword set. The SAC may then receive an APPLY command . If so that will move the SAC from the Keyword Set loaded state into the Keyword Set Applied state . In this state the SAC is applying the indicated keyword set for analyzing the speech of one of the parties on a designated call. In other words the speech for the appropriate party is now being analyzed for occurrences of one of the keywords in the indicated keyword set. The SAC will continue to monitor the speech while in this state. It is in this state that the SAC may return various EVENT NOTIFICATION messages to the call handler. The transmittal of EVENT NOTIFICATION messages is not shown in as only depicts the various commands received from the call handler and the responses sent and not the notifications of detected keywords in the keyword set.

In one embodiment the SAC will return to the Keyword Set Loaded state upon receiving a REMOVE command while in the Keyword Set Applied state . Receipt of the REMOVE command effectively terminates applying the keyword set to specific speech as was indicated previously via the APPLY command. The REMOVE command provides the benefit of releasing processing resources from use as those resources are no longer processing the speech for detection of a keyword. Once returned to the Keyword Set Loaded state the keyword set may once again be loaded upon receipt of the APPLY command.

Alternatively once in this Keyword Set Loaded state the SAC may receive a RELEASE message which if confirmed results in the keyword set being potentially erased from working memory or at least allowing the memory occupied it to be released for other uses. The SAC then transitions back to the Null state .

The Null and Keyword Set Loaded states are global states. That is these states apply to any subsequent calls that are established between the call handler and the SAC. The Keyword Set Applied state is call specific. Consequently there could be a plurality of Keyword Set Applied states for a given Keyword Set Loaded State. More specifically once a keyword set is loaded it could be applied to a first call leg and a second call leg etc. This is illustrated in the state diagram of which shows several Keyword Set Applied states and . Each of these could be entered upon the SAC receiving an APPLY command applying the same keyword set but for a different call as indicated by a call reference CR value. Thus the same keyword set can be applied to a call reference 1 call reference 2 and call reference 3 resulting in the three states and . Further movement from each state back to the Keyword Set Loaded state could be independent for each of the various call legs. However all during this time the SAC has a keyword loaded into memory.

The state transition diagram shown in shows common and preferred transitions but another representation of a state transition diagram is shown in . shows various exceptions and other transitions that may exist in other embodiments. Turning to the diagram illustrates a variety of error or exceptional conditions such as when a command is provided with incorrect parameters. For example in the Null state a LOAD command may be received but which identifies an incorrect e.g. non existing keyword set . In this case the LOAD command results not in a Confirmation response but a Reject response . Further the result is that the Null state is maintained. Similarly if in the Keyword Set Loaded state an APPLY message is received that incorrectly identifies a keyword set or call the result also is a Reject response and the state does not change. A similar state transition is defined for the Keyword Set Applied state where an incorrect REMOVE command also results in a Reject response that results in maintaining the same state.

In another variation from a RELEASE command may be received in the Keyword Set Applied state . This represents the situation of the SAC applying a keyword set to speech and then receiving a command from the call handler indicating that the keyword set is no longer needed and the memory space it uses can be reallocated. Thus the RELEASE command may be followed with a Confirm response even though the preferred transition may be to REMOVE the keyword set first transitioning to Keyword Set Loaded state and then to the Null state .

In some embodiments this transition from the Keyword Set Applied state to the Null state may be prohibited since doing so could adversely affect other Keyword Set Applied states that may be pending for the same keyword set. Thus the transition between the Keyword Set Loaded state and the Keyword Set Applied state is call specific whereas the transition from the Keyword Set Loaded state and the Null state is a global transition. It may be restricted to only occurring if there are no other remaining Keyword Set Applied states.

Each of the LOAD APPLY REMOVE and RELEASE commands may have parameters associated with them. The parameters that are indicated may vary according to embodiment. The LOAD command indicates that a particular keyword set is to be loaded and hence it typically identifies the keyword set. In one embodiment the keyword set may be identified by a universal resource identifier URI or universal resource locator URL . The keyword set may be located in the SAC data store a remote data store or on another system and transmitted to the SAC upon request.

In some embodiments the LOAD command may have another parameter indicating a resource for which the keyword set is to be loaded. This could be a particular system server a particular trunk group or a range of call references or call identifiers. Thus when loading a keyword set for the resource the keyword set is only available for within the scope of that resource. In other embodiments such a parameter is not required. If the SAC receiving the LOAD command is unable to identify locate or otherwise cannot load the identified keyword set then a Reject response may be returned and the SAC stays in the Null state.

Similarly in the Keyword Set Loaded State the SAC may receive an APPLY command. This typically indicates the context for which the keyword set is to be applied. In one embodiment the parameters identify the keyword set to be applied a call reference of the call it should be applied to and a party of the call. The name of the keyword set typically is the same name used as in the previous LOAD command. Presumably once the keyword set is loaded and the APPLY command is received referencing the same keyword set there will not be any ambiguity in identifying the keyword set.

The call reference parameter which may also be variously referred to as a call leg identifier call identifier etc. is used to identify which particular instance of voice conversation the keyword set is to be applied to. Various protocols may use different names or labels to identify the voice communication between the call handler and the SAC. Presumably in many embodiments there may be more than one simultaneous voice communication between the SAC and call handler so that some form of identifier is required to distinguish one from the other.

The party indicator indicates whether the agent or the remote party s speech is to be analyzed. In some embodiments this information could be identified by allocating unique call reference values for identifying the agent on a call and the remote party on that same call. However in a preferred embodiment a separate parameter is used to identify which party s speech is analyzed. Although the party indicators are generally referred to as agent and remote party in this description other embodiments may use other names or labels.

In some embodiments the keyword set is applied for each instance of voice communication as needed. Hence an APPLY command may be sent to the SAC for each voice call established between the call handler and the SAC. In other embodiments a parameter may be defined indicating that the keyword set is to be applied for all calls meeting a specific criterion between the call handler and the SAC. For example assume that there may be a maximum of 50 calls for which the keyword set is to be applied and the call handler and the SAC are both configured so that these calls will have a call reference value in the range of 1 50. The parameter in the APPLY command may indicate that the keyword set is to be applied to all current and future calls with a call reference value in the range of 1 50. This would avoid sending individual APPY commands for each call to the SAC. Further since calls would terminate and other calls may be established reusing the same call reference values this approach would avoid having to resend the APPLY command for each new call using a call reference value in the same 1 50 range.

The REMOVE command similarly references a particular keyword set call reference value and potentially indicates a particular party. It is possible that a keyword set may be removed only for one party but not another. For example returning back to the debt collection example where the called party s speech is monitored for an indication of bankruptcy once bankruptcy is detected from the remote party the keyword set applied against the remote party may be removed and a different keyword set is then applied to the agent. Then once the agent s speech is confirmed for asking about the party s lawyer that keyword set applied to the agent can be removed. Alternatively in some embodiments a keyword set may be removed after a certain amount of time. For example if the keyword set is applied to a called party and that party does not indicate they have filed for bankruptcy in the first five minutes of the call that keyword set may be removed from being applied. Thus the REMOVE command may indicate not only the call reference but also the party to which it applies. If the keyword set is only being applied for a particular party then it may be understood that a REMOVE command for that particular call implicitly applies to that particular party. Hence the REMOVE command may not explicitly indicate a party indicator in all embodiments. However if the same keyword set has been applied to both parties then not indicating a party the command pertains to may result in the keyword set being removed for both parties.

The RELEASE command also must indicate which keyword set it applies to. In some embodiments a wildcard parameter can be defined to indicate all keyword sets. In general such wildcard parameters can also be defined for the other messages. Thus a single RELEASE command could be used to terminate use all keyword sets and this would avoid transmitting a plurality of RELEASE messages. Because a RELEASE command indicates that the keyword set is no longer required its use may not be defined in the context of a particular call for a particular party. That is if any party on any call is using the keyword set then the RELEASE command may not be sent. In one embodiment only when all uses of the keyword set are to be terminated should the RELEASE command be sent for an indicated keyword set.

The Confirm messages shown in and may also have parameters which correlate with the particular command they are responding to. For example a Confirm message may reflect the command name and parameters. This allows the call handler to know that the command it sent to the SAC has been acted upon. In some instances the SAC may initiate a Confirm message on its own. For example a call may be established between the call handler and the SAC. The call handler may request via the APPLY command that certain keyword sets are to be applied to either the remote party or the agent as appropriate. During the call the remote party may hang up or the call may be terminated for other reasons. Since the call is terminated and there is no basis for applying a keyword set to either party the state may transition from the Keyword Set Applied state to the Keyword Set Loaded state without any explicit REMOVE message. In some embodiments a Confirm message may be sent from the SAC to the call handler to confirm that it has moved to the Keyword Set Loaded state. Similarly it is possible to move all calls to the Null state if all calls are terminated at once e.g. due to a power failure facility interruption etc. .

An exemplary message flow between a call handler and a SAC is shown in . The messages exchanged pertain to an application where 

Turning to the line diagram illustrates commands sent between the call handler and the SAC . The exchange begins with a LOAD command sent by the call handler which includes names for the two keyword sets that will be used. For sake of illustration and not for limitation the somewhat generic names Keyword Set 1 and Keyword Set 2 are used although the notation used shortens this to Keyword Set 1 2 . Other formats which are more descriptive to the keyword sets may be used. Other embodiments may use a name that facilities retrieval of the keyword set. This command instructs the SAC to retrieve the appropriate keyword sets from their respective storage locations establish the appropriate data structures initialize any associated parameters etc. The SAC responds with a Confirm message which indicates the keyword sets have been loaded.

Next the call handler establishes a call leg to the SAC. This message could have been sent before the LOAD message but in this scenario is it presumed that the call handler knows that it will be handling calls of a certain type and knows that certain compliance regulations are to be managed and therefore instructs the SAC to load the appropriate keyword sets for this type of call before the call leg is established. Any protocol or mechanism known in the art for establishing the call leg can be used in message . The call leg is identified using a call reference label and that value will be used subsequently to identify that call leg as opposed to other call legs. For the sake of simplicity only a single call is referenced in this example.

At this point the SAC has loaded the keyword sets has received a call leg and is now commanded to use a specified keyword set via an APPLY message . This instructs the SAC to use Keyword Set 1 for the specified call leg and for a particular party the called party . The SAC begins to monitor the speech of the called party for an instance of a keyword in the keyword set and confirms the same via the Confirm message .

At some point presuming that the called party utters a keyword in keyword set 1 the SAC returns an EVENT NOTIFICATION message indicating that the called party for the indicated call leg was detected as speaking a specified keyword. In some embodiments the actual keyword detected may be reported while in other embodiments only the fact that a keyword was detected from the keyword set is indicated. In some embodiments the SAC may have been instructed to analyze both the agent s and the called party s speech using the same keyword set and hence it is necessary to indicate which party is associated with the event notification. Hence the EVENT NOTIFICATION message indicates that the called party is the party for which the keyword detection occurred.

The call handler at this point has been informed that the called party has spoken a keyword from keyword set 1 and determines that for this context no further monitoring of the called party s speech is necessary. Hence it instructs the SAC via a REMOVE message to cease monitoring the called party s speech using keyword set 1 for that call leg. The SAC confirms doing so via the Confirm message .

At this point the call handler knows that the agent s speech is to be monitored and instructs the SAC via an APPLY message to monitor the agent s speech using keyword set 2. The SAC confirms this via Confirm message .

Presuming that the agent utters a keyword in keyword set 2 the SAC returns an EVENT NOTIFICATION message to the call handler. The call handler determines for this context that no further monitoring of the agent s speech is necessary and then instructs the SAC via a REMOVE message to cease monitoring the agent s speech. The SAC responds with a Confirm message .

The process involving messages may be repeated for subsequent calls. In other embodiments there may be a number of simultaneous call legs between the call handler and the SAC. It can be appreciated that the call handler may have logic for different contexts that could alter the message flow. For example the call handler could be configured to instruct the SAC to apply a third keyword set for the called party after detecting the agent s response. Or the call handler may not remove a keyword set after initial detection and instead monitor subsequent instances of keywords spoken from the keyword set. Those skilled in the art will recognize that the call handler could be configured to handle a variety of contexts and variously instruct the SAC as to when certain keyword sets should be applied and removed.

For the sake of completeness the example in concludes with a RELEASE message . This message informs the SAC that there is no further need for the keyword sets 1 and 2 and that these keyword sets can be erased from working memory. Note that this command should not be issued if there are other pending calls which are using these keyword sets or if subsequent calls are expected that involve these keyword sets. Thus the RELEASE command may be used less frequently than the REMOVE message as is the case for the LOAD command . Finally the process completes with the SAC returning a Confirm message once keyword sets 1 and 2 have been released from working memory.

The commands discussed above LOAD APPLY REMOVE and RELEASE are presented in a basic form. Additional capabilities can be added to optimize operation. For example a capability can be defined that automatically removes the application of a keyword set after detection of a keyword. This could be accomplished by defining a new message such as APPLY WITH AUTO REMOVE or by defining a parameter in the APPLY message for this function. The parameter would indicate whether the keyword set would be automatically removed after detection of a keyword set. This would eliminate the need to send a REMOVE message after the call handler receives an EVENT NOTIFICATION from the SAC.

Other messages may instruct the SAC to apply two keyword sets simultaneously. This would involve adding parameters to a single APPLY message to be functionally equivalent to sending two APPLY messages. In other embodiments a single message or additional parameters may be defined can be defined that instructs the SAC to apply a first keyword set to a first party and automatically apply a second keyword set to the other party upon detection of the first keyword set of the first party.

Other embodiments may define additional capabilities for applying a first keyword set to an indicated party for all call legs meeting particular criteria. For example a trunk group or set of call reference values may define the criteria so that whenever a call leg is established the SAC will automatically apply an indicated keyword set. For example a simple script or message could be defined that indicates for all calls involving a call reference value between 1 and 100 keyword set 1 should be applied to the called party s speech after the call is set up to the SAC.

Alternatively a standing command could be defined for the SAC to always apply a particular keyword set including for a particular party and for a particular call s . For example certain contexts may require that the agent s speech always be monitored for profanity. One approach is to define a global APPLY command that indicates a keyword set should be applied for all calls so that the agent s speech may be monitored at all times using a specified keyword set. This would avoid having to issue an APPLY message for each call leg being established.

No doubt those skilled in the art will recognize that for certain contexts a repeated pattern for applying and or removing keyword sets can be optimized by defining either new messages and or new parameters. These variations are within the scope of the concepts and technologies presented herein.

In other embodiments the call handler may query the SAC for real time management information. Specifically messages can be defined for the call handler or other device to query the SAC for a level of resource usage. This would allow the call handler to adjust which commands to send to the SAC. For example assume that each of several dozen agents speech is monitored for profanity. Doing so may consume a large percentage of the computing resources in the SAC. Furthermore assume that a large percentage of calls may require monitoring agent compliance in a context that requires monitoring both the agent s speech and the called party s speech. Doing so may further strain the computing resources of the SAC. The call handler may issue a command to query resource usage and then command removal of the application of the profanity keyword set. In some embodiments the nature of the agent workforce may be that profanity is not a problem to monitor or that it is not necessary to monitor this if the call context requires that the processing resources in the SAC should instead be used for more critical compliance monitoring aspects.

It should become apparent to those skilled in the art that the above tools allow the call handler to instruct the SAC to more efficiently apply keyword sets for calls as required by the context. This allows the call handler to instruct the SAC accordingly to handle a diverse range of compliance aspects with a reasonable processing capacity in the SAC. This avoids having to engineer the SAC to have processing resources to handle a peak level of speech processing when in many instances that peak level is not required.

Representative process flows for the various commands identified above are now presented. These describe one potential process flow in the SAC upon receiving a command from the call handler in regard to managing a keyword script. For purposes of brevity the basis operation of the LOAD APPLY REMOVE and RELEASE commands are presented without detailed explanation of the various alternatives extensions and other parameters that may be added on.

The first process flow considered is the LOAD command which loads a keyword set into working memory of the SAC. The keyword set may be initially stored in secondary memory such as disk storage as opposed to main memory or working memory which typically allows faster access. The keyword store may be stored in non volatile memory such as a disk store either local or remote to the SAC. Thus the LOAD command is used to instruct the SAC to retrieve the keyword set and place it into working memory and prepare any other data structures necessary for its use.

The process flow is shown in . The process begins with receiving and parsing the LOAD command in operation . This operation is useful to identify the various parameters such as the keyword set name or address of its location. The identification of the keyword set may occur via various means including by identifying a unique name that can be resolved into a location of the keyword set or a unique path or location of the keyword set. After parsing the keyword set a determination is made whether the keyword set can be located in operation . If not then the process continues to operation where a Reject message is returned which may also indicate the reason why the command could not be accomplished.

Assuming the location is identified in operation the SAC then retrieves the keyword set in operation . Next a determination is made in operation whether the keyword set was successfully retrieved and loaded into main memory. If not then the process continues to operation where a reject message is sent. Otherwise a Confirm message is transmitted to the call handler in operation . At this point the process is completed.

The APPLY command may be the most frequently used command. Typically a keyword set is loaded once but applied many times. In some embodiments a keyword set is applied for each applicable call instance so that an APPLY command may be sent by the call handler to the SAC after each call leg is established to the SAC.

The process shown in begins with the SAC parsing a received APPLY command in operation . The parsing identifies the parameters in the message one of which may be the identifier of the call leg i.e. the call reference. Depending on the protocol used other names for the identifier may be used. A test in operation determines whether the call reference exists e.g. does a corresponding call exist If not then the process proceeds to operation wherein a Reject message is transmitted back to the call handler detailing the error.

Assuming the call reference is identified in operation the process then continues to determine if the identified keyword set has been identified and loaded into memory in operation . Again if it has not then a Reject message is returned in operation . Otherwise the process continues to check for the presence of a party indicator in operation . The party indicator indicates whether the keyword set should be applied to the agent the remote party or both. If this parameter is not present or not recognized then the process continues to operation where a Reject message is transmitted to the call handler.

Otherwise assuming that the keyword call reference and party indicator are all recognized and it is possible to operate on the information the identified keyword set is applied to the indicated party s speech in operation . It is at this point that the SAC is using the keyword set to analyze the speech for purposes of determining whether a match in one of the keywords exists.

The techniques used by the SAC for detecting a keyword in the keyword set can be any of the techniques known by those skilled in the art of speech recognition. The particular techniques used can vary and the concepts and technologies herein can apply to a variety of such techniques.

The application of the keyword set continues until a REMOVE command is received as shown by the test in operation which loops back to operation if not received. Once a REMOVE command is received then the application of the keyword set is terminated see e.g. for details . Note that in other embodiments other exceptional conditions may occur that may terminate the application of the keyword set. These are not shown but those skilled in the art could readily identify such situations in light of the current disclosure. For example if the call leg between the call handler and the SAC were suddenly terminated during operation this could terminate application of the keyword set.

The REMOVE command is used to instruct the SAC to cease application of a keyword set for a particular party on a particular call. This allows the SAC to conserve processing resources and further allows the SAC to avoid returning EVENT NOTIFICATION messages to the call handler which the call handler may not require. Thus avoiding sending unnecessary indications to the call handler also saves processing resources in the call handler.

As noted above ceasing application of a keyword set to a call can occur in various abnormal ways such as terminating the call while the keyword set is being applied. However a normal use case is for the call handler to send a REMOVE command to the SAC. This process flow is illustrated in the flow of .

The process begins with the SAC receiving and parsing a REMOVE command in operation to identify the parameters including the keyword set identifier call reference and party indicator. If any of the call reference keyword set identified or party indicator are not identifiable recognized or present as determined in operations and then a Reject message is transmitted to the call handler in operation .

If all of these parameters are able to be operated upon then analyzing the party s speech using the keyword set is ceased in operation . A Confirm message is transmitted to the call handler reporting this in operation . The process is then completed. Of course the termination of the application of the keyword set could be occur in other ways including terminating the call though this is not shown in .

The RELEASE command is sent to the SAC indicating that the keyword set is no longer required and main memory used for storage of it can be allocated for other purposes. Of course this does not result in erasing any copies of the keyword set in secondary storage which may be used for subsequent re loading. The process is shown in and the process begins with the SAC receiving and parsing the RELEASE command in operation . The parsing identifies the parameters such as the keyword set. In various embodiments specific party indicator and call reference identifiers are not present since the RELEASE command should be used after keyword sets are removed from use. Thus during normal operation keyword sets are not released if there is any instance of it being applied.

A determination is made whether the keyword set identified is currently loaded in operation . If the keyword set has not been loaded or is not recognized or is otherwise cannot be acted upon then the process proceeds to operation where a Reject message is transmitted to the call handler indicating the cause of the error.

Otherwise assuming the keyword set has been loaded a test is made to determine if the keyword set is currently being applied for any pending calls. If so than a Reject may be transmitted to the call handler in operation . In other embodiments the keyword set may automatically be removed from use and the process continues to operation .

Assuming the keyword set can be removed then in operation the keyword set is removed from memory. Data structures associated with the keyword set can also be discarded. A Confirm message is transmitted to the call handler in operation .

As shown in the SAC processing system may include one or more processors that may communicate with other elements within the processing system via a bus . The processor may be implemented as one or more complex programmable logic devices CPLD conventional microprocessors multi core processors digital signal processors DSP system on a chip SOC co processing entities application specific integrated circuits ASIC field programmable gate arrays FPGA programmable logic arrays PLA hardware accelerators integrated circuit processors other circuitry or the like. These or other processing elements may perform the speech analytics related functions of the SAC. These process elements may also perform the processing of the above mentioned commands as well as formulate the response messages to the call handler.

In one embodiment the SAC processing system may also include one or more communications interfaces for communicating data via the local network with various external devices such as the call handler. In other embodiments communication may be via wired optical or wireless networks or a combination thereof . The communication may use a variety of data transmission protocols such as fiber distributed data interface FDDI Ethernet asynchronous transfer mode ATM or frame relay. The communications interfaces may be used for receiving the call legs as well as receiving commands and transmitting responses. A single interface or multiple interfaces may be used. Further the same or different interfaces may be conveyed using a single communication facility or different facilities. For example one interface may be used for receiving call legs and another interface maybe used for commands responses and both could be conveyed as IP based protocols over an Internet facility. In either embodiment similar or different protocols may be used for communicating the voice data and the command data. In one embodiment an Internet Protocol IP based interface for voice such as Session Initiated Protocol SIP may be used for controlling the voice call whereas in other embodiments conventional time division trunks and signaling techniques may be used to convey the voice call legs and signaling.

The input output controller may also communicate with one or more input devices or peripherals using an interface such as but not limited to a keyboard a mouse a touch screen display input microphone pointing device etc. The input output controller may also communicate with output devices or peripherals such as displays printers speakers headsets banner displays etc.

The processor may be configured to execute instructions stored in volatile memory non volatile memory or other forms of non transitory computer readable storage media accessible to the processor . The volatile memory may comprise various types of memory technologies including but not limited to random access memory RAM dynamic random access memory DRAM static random access memory SRAM and other forms well known to those skilled in the art. The non volatile memory may comprise various technologies including but not limited to storage media such as hard disks floppy disks read only memory ROM programmable read only memory PROM electrically erasable read only memory EPROM flash memory and other forms well known to those skilled in the art.

The non volatile memory may store program code and data which also may be loaded into the volatile memory at execution time. Specifically the non volatile memory may store one or more computer program modules such as a command processing module containing instructions for performing the process and or functions associated with the technologies disclosed herein and related data such as keyword sets and or operating system code . In addition the command processing module may generate or access the data in the non volatile memory as well as in the volatile memory . The volatile memory and or non volatile memory may be used to store other information including but not limited to records applications programs scripts source code object code byte code compiled code interpreted code machine code executable instructions or the like. The volatile memory may include keyword sets action sets and other related data to implement the concepts and technologies disclosed herein. These instructions may be executed or processed by for example the processor . These may form a part of or may interact with the command processing module and or data .

In various embodiments the processor upon acting on a LOAD command may copy data in the form of a keyword set from the non volatile or secondary memory into the volatile or primary memory in order to apply the keyword set to a call at the communication interface . The processor acting upon a RELEASE command for an identified keyword set may remove the keyword set stored in the volatile memory to free up that resource for other uses. Of course the keyword set would remain stored in the non volatile memory in case it needed to be re loaded at a later time.

The technologies described herein may be implemented in various ways including as computer program products comprising memory storing instructions causing a processor to perform the operations associated with the above technologies. The logical operations described herein may be implemented as a sequence of computer implemented acts or one or more program modules running on a computing system and or as interconnected machine logic circuits or circuit modules within the computing system. The implementation is a matter of choice dependent on the performance and other requirements of the computing system. Accordingly the logical operations described herein are referred to variously as states operations structural devices acts or modules. These operations structural devices acts and modules may be implemented in software in firmware in special purpose digital logic and any combination thereof. Greater or fewer operations may be performed than shown in the figures and described herein. These operations may also be performed in a different order than those described herein.

The computer program product comprises a tangible non transitory computer readable storage medium storing applications programs program modules scripts source code program code object code byte code compiled code interpreted code machine code executable instructions and or the like also referred to herein as executable instructions instructions for execution program code and or similar terms . Such tangible non transitory computer readable storage media include all the above identified media including volatile and non volatile media but does not include a transitory propagating signal. Non volatile computer readable storage medium may specifically comprise a floppy disk flexible disk hard disk magnetic tape compact disc read only memory CD ROM compact disc compact disc rewritable CD RW digital versatile disc DVD Blu ray disc BD any other non transitory optical medium and or the like. Non volatile computer readable storage medium may also comprise read only memory ROM programmable read only memory PROM erasable programmable read only memory EPROM electrically erasable programmable read only memory EEPROM flash memory and or other technologies known to those skilled in the art.

