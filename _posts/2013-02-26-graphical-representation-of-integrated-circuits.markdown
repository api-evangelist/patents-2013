---

title: Graphical representation of integrated circuits
abstract: A system for graphics generation includes a processor configured to implement a modeling process and a GUI process. The modeling process is configured to generate a first graphics model including a plurality of objects. Each object defines a respective graphical depiction for a respective element of a programmable IC. The modeling process is also configured to serialize objects of the first graphics model according to a first application programming interface (API) definition file to produce a serialized graphics model. The GUI process is configured to, in response to receiving one or more objects of the serialized graphics model, deserialize the one or more objects of the serialized graphics model according to the first API definition file to produce a second graphics model. The GUI process is further configured to render the one or more objects of the second graphics model.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09454630&OS=09454630&RS=09454630
owner: XILINX, INC.
number: 09454630
owner_city: San Jose
owner_country: US
publication_date: 20130226
---
A portion of the disclosure of this patent document contains material that is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure as it appears in the Patent and Trademark Office patent file or records but otherwise reserves all copyright rights whatsoever.

Programmable ICs may be programmed by a user to perform specified logic functions. One type of programmable IC known as a field programmable gate array FPGA typically includes programmable resources that are arranged in an array of programmable tiles including for example input output blocks IOBs configurable logic blocks CLBs dedicated random access memory blocks BRAM multipliers digital signal processing DSPs blocks processors clock managers delay lock loops DLLs bus or network interfaces such as Peripheral Component Interconnect Express PCIe and Ethernet and so forth. Programmable ICs provide flexible hardware solutions that are advantageous for high performance parallel computing in advanced digital communications and video applications.

Programming data used to configure a programmable IC is often very complex. The complexity may be managed by designing circuits at higher levels of abstractions. For instance using a hardware description language HDL circuits can be designed at the gate level the register transfer level RTL and higher logical levels. Circuits may be combined and augmented to form higher level modules. System level integration may rely on reuse of a library of previously created logic blocks including for example adders multipliers filters and other arithmetic and DSP functions from which system designs can be readily constructed.

Computer aided design CAD tools provide a mechanism for users to quickly visualize connect and modify objects of a system level design using a graphical user interface GUI . Using CAD tools circuit designs can be assembled using a graphical user interface translated into a hardware description language e.g. HDL and VHDL and synthesized into hardware configuration data. Some CAD tools used for circuit design also provide a mechanism for simulation and debugging of circuit designs.

Some CAD tools include one or more backend processes that maintain a data representation of the objects and connections of a programmable IC and a separate GUI process that renders objects and connections of the programmable IC for display to a user. Communication of data between the backend processes and the GUI process of a CAD tool can pose a significant challenge. For instance in some CAD systems graphics modeling data for each object to be displayed to a user is individually communicated to from backend processes to a GUI. Such implementations require large amount of graphics modeling data to be communicated to the GUI for display. Furthermore in some implementations backend processes and the GUI may be written in different source languages e.g. C and Java making efficient communication of graphics data more difficult.

A system for graphics generation is provided. The system includes a processor configured to implement a modeling process and a GUI process. The modeling process is configured to generate a first graphics model including a plurality of objects. Each object defines a respective graphical depiction for a respective element of a programmable IC. The modeling process is also configured to serialize objects of the first graphics model according to a first application programming interface API definition file to produce a serialized graphics model. The GUI process is configured to in response to receiving one or more objects of the serialized graphics model deserialize the one or more objects of the serialized graphics model according to the first API definition file to produce a second graphics model. The GUI process is further configured to render the one or more objects of the second graphics model.

A method for graphics generation is also provided. Using a first process on a programmed processor a first graphics model is generated that includes a plurality of objects. Each object defines a respective graphical depiction for a respective element of a programmable IC. Objects of the first graphics model are serialized according to a first API definition file to produce a serialized graphics model. The serialized graphics model is provided to a second process. Using the second process on the programmed processor the one or more objects of the serialized graphics model are deserialized according to the first API definition file to produce a second graphics model. The one or more objects of the second graphics model are rendered using the second process on the programmed processor.

Another method for graphics generation is also provided. Using a first process on a programmed processor a first graphics model is generated that includes a plurality of objects. Each object defines a graphical depiction for a respective element of a programmable IC. Objects of the first graphics model are serialized according to a plurality of protocol buffers defined in an API definition file to produce a serialized graphics model. The serialized graphics model is provided to a second process. Using the second process on the programmed processor the one or more objects of the serialized graphics model are deserialized according to the plurality of protocol buffers to produce a second graphics model. In response to a first input command the second graphics model is used to render a first subset of the elements corresponding to logic components of the programmable IC without rendering a second subset of the elements corresponding to routing resources of the programmable IC. In response to a second input command the second graphics model is used to render the first and second subsets of the elements.

Other embodiments will be recognized from consideration of the Detailed Description and Claims which follow.

Methods and circuits are disclosed for the communication of graphics data between a graphics modeling process and a GUI process of a CAD tool. The graphics modeling process is configured to generate a graphics data model that describes a graphical representation of each object in a programmable IC. The graphics model is serialized according to an application program interface API definition file and communicated to the GUI. The GUI is configured to deserialize objects of the received graphics model according to the API definition file and render the deserialized objects for display. This methodology simplifies runtime communication between the graphics modeling process and the GUI process of the CAD tool. Further communication of the graphics model in serialized form reduces the amount of data that is communicated and improves runtime performance.

In some embodiments serialization and deserialization of the graphics model is performed according to a protocol buffer API definition file e.g. a .proto file . Protocol buffers are a language neutral platform neutral extensible mechanism that may be used to serialize structured data in communications protocols. One or more protocol messages that specify how information is to be structured can be defined. Each protocol message can include a set of name value pairs and each name value pair includes a name and a value type. A value type may be a number e.g. an integer or a floating point a Boolean a string raw bytes and the like. In addition value types can also include other protocol messages. Accordingly protocol buffers enable information to be structured hierarchically.

Once protocol messages are defined the definitions can be run through a protocol buffer compiler to automatically generate data access mechanisms as well as serialization deserialization mechanisms. The serialization deserialization mechanisms are configured to convert a protocol message object e.g. an object instance of the protocol message populated with actual data into a protocol buffer e.g. raw bytes for serialization and to convert the protocol buffer into the protocol message object for deserialization. The data access mechanisms facilitate communication of data using the name value pairs defined by the protocol messages.

The protocol buffer API also helps facilitate communication between processes derived from different programming languages e.g. C C Python and Java . For instance in some implementations the graphics modeling process is compiled from C code and the GUI process is compiled from Java code. The protocol buffer API provides a language neutral bridge to communicate data using serialization and deserialization processes.

Turning now to the figures shows a method for providing a graphical representation of a programmable IC. A graphics modeling process is configured to generate graphics model objects for elements of the programmable IC at block . The graphics model indicates the elements of the programmable IC model to depict graphically including for example tiles logic elements wires switchboxes I O banks clock regions and programmable interconnect points PIPs . The graphics model defines graphical representation features for these elements such as shape dimensions and location. The graphics model may also associate other information with the elements such as layer identification color textual labels and tagging.

The graphics modeling process is configured to serialize the generated graphics model objects of the programmable IC according to an API definition file at block to generate a serialized graphics model . The serialized graphics model is communicated to a GUI process . The GUI process is configured to deserialize the received serialized graphics model according to the API definition file at block . The GUI process is further configured to render the deserialized graphics model objects i.e. generate pixels for of the deserialized objects at block .

As indicated above the API definition file includes a number of elemental objects including for example lines circles arcs triangles polylines continuous lines having multiple line segments etc. Objects for more complex shapes may be defined as macro objects which indicate arrangements of other objects of the API in combination. This hierarchical definition of graphics objects allows elemental objects to be communicated to and arranged by the GUI process to render more complex macro objects as well. For example a graphical macro object might consist of a polygon representing a basic logical element such as a multiplexor along with multiple line segments extending perpendicular to the edges of the polygon representing the terminals or pins where logic nets may attach.

As a first example Example 1 shows an elemental object in a protocol buffer API definition file .proto file for a triangle. The elemental triangle object defines graphical features needed to display a triangle for a set of coordinates indicating corners of the triangle.

As another example Example 2 shows an elemental object in the protocol buffer API definition file for a text label. The elemental text object defines graphical features needed to display an indicated text at a set of coordinates.

Example 3 shows a generic macro object included in the protocol buffer API definition file. The macro object indicates coordinates and various values of the macro object. The macro object also includes reference ID and various values for one or more child objects that are arranged to form the macro object.

In some embodiments the serialized graphics model may include graphics data for multiple representations and or devices. For instance the serialized graphics model may describe graphics for a single programmable IC for a family of devices or include data that is shared across multiple devices. In one implementation a respective graphics file may be created for display of a resource layout of each device and another graphics file is created with graphics data shared e.g. overlaid for all devices of a programmable IC family. For ease of explanation examples are primarily described herein with reference to a single graphics model for a device.

In some embodiments a generated graphics model is configured to describe multiple representations of the circuit design for a programmable IC layout. For example in one implementation the graphics model describes a first set of objects for display in a simpler floorplan view of the circuit and a second set of objects for display in a more complex detailed view of the circuit. In the floorplan view logic elements are displayed but not interconnect resources. In the detailed view all the elements including routing interconnect wires PIPs and switchboxes are displayed. Other combinations of the elements of the circuit design and or programmable IC may be selected to provide additional views.

In addition to communication of the graphics models in some embodiments the graphics modeling and GUI processes of a CAD tool are further configured to communicate other data according to one or more additional API definition files. For instance in some implementations a set of function calls to initiate a number of tasks to be performed by the graphics modeling process may be serialized using an API definition file. In this manner the number of function calls required to be communicated is reduced.

In this example the API definition file includes objects defining three elemental function calls tasks A B and C and two macro function calls tasks D and E . For example if the set of user initiated tasks includes a function call for task A the function call may be serialized by replacing the function call with a corresponding object from the API definition file . As another example if the set of user initiated tasks includes function calls for tasks A B and C the function calls may be serialized by replacing the function calls with a single object in the API definition file corresponding to task D macro.

As yet another example macro function call task E represents a request to execute task D for each object i in a circuit design model. If the set of user initiated tasks includes function calls tasks A B and C to be performed for multiple objects in the circuit design model all of these functions call may replaced with the single object in the API definition file corresponding to the task E macro.

Serialized task requests are communicated from the GUI process to the graphics modeling process . The graphics modeling process is configured to deserialize the serialized tasks at block . The graphics modeling process performs the tasks indicated by the deserialized tasks at block . If the tasks generate any data responses e.g. data requested by a user the data responses are serialized at block . For example a user generated task may request that debugging information for a particular set of signals be displayed. In such case graphical data representing the set of signals would be returned. Serialized response data is communicated to the GUI . In response to receiving serialized response data the GUI deserializes the response data at block . If applicable the GUI uses the deserialized data to update the rendered graphics model at block .

Serialized data may be communicated differently in different implementations. For instance in some implementations serialized data e.g. or is communicated directly between graphics modeling and GUI processes and in the serialized format. However the embodiments are not so limited. For instance in some implementations serialized data e.g. or may be formatted according to a compression and or encryption protocol. In some implementations serialized data is communicated by a foreign function interface FFI . For instance in the example shown in data is communicated between a graphics modeling process and a GUI process using a FFI code generated by the Simplified Wrapper and Interface Generator SWIG . SWIG is a tool for generation of a FFI for communication between C C functions and other languages e.g. Java Python Perl or Tcl .

Java access code for the inter process functions is generated from the API definition file at block . The Java access code is compiled at block . The compiled Java access code is added to the Java subsystem and allows the sub system to communicate data using functions in a Java API library and objects defined in the API definition file . As an example for an implementation using the protocol buffers API Java access code may be generated with the protoc compiler using the command Protoc java out .. 

C access code for the inter process functions is generated from the API definition file at block . The C access code is compiled at block . The compiled C access code is added to the C subsystem and allows the sub system to communicate data using functions in a C API library and objects defined in the API definition file . As an example for an implementation using the protocol buffers API C access code may be generated with the protoc compiler using the command Protoc cpp out .. 

An FFI definition file for inter process functions is generated at block . Wrapper code is generated from the FFI definition file to communicate data e.g. serialized data between the C and Java processes. For instance as indicated above SWIG may be used to generate an FFI to communicate serialized data. SWIG generates wrapper code for a non C process to communicate data with C processes. Java FFI code is generated from the FFI definition file at block . The Java code is compiled at block and linked with the Java subsystem to facilitate communication between the C and Java sub systems.

Processor computing arrangement includes one or more processors a clock signal generator a memory arrangement a storage arrangement and an input output control unit all coupled to a host bus . The arrangement may be implemented with separate components on a circuit board or may be implemented internally within an integrated circuit. When implemented internally within an integrated circuit the processor computing arrangement is otherwise known as a microcontroller.

The architecture of the computing arrangement depends on implementation requirements as would be recognized by those skilled in the art. The processor s may be one or more general purpose processors or a combination of one or more general purpose processors and suitable co processors or one or more specialized processors e.g. RISC CISC pipelined etc. .

The memory arrangement typically includes multiple levels of cache memory and a main memory. The storage arrangement may include local and or remote persistent storage such as provided by magnetic disks not shown flash EPROM or other non volatile data storage. The storage unit may be read or read write capable. Further the memory arrangement and storage arrangement may be combined in a single arrangement.

The processor s executes the software in storage arrangement and or memory arrangement reads data from and stores data to the storage arrangement and or memory arrangement and communicates with external devices through the input output control arrangement . These functions are synchronized by the clock signal generator . The resource of the computing arrangement may be managed by either an operating system not shown or a hardware control unit not shown .

The examples described herein are thought to be applicable to a variety of CAD systems e.g. circuit design mechanical design and architecture . Other aspects and embodiments will be apparent to those skilled in the art from consideration of the specification. For instance although examples may in some cases be described in individual figures it will be appreciated that features from one figure can be combined with features of another figure even though the combination is not explicitly shown or explicitly described as a combination. The examples may be implemented as one or more processors configured to execute software as an application specific integrated circuit ASIC or as a logic on a programmable logic device for example. It is intended that the specification and the illustrated structures and methods be considered as examples only with a true scope of the invention being indicated by the following claims.

