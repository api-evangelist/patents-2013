---

title: Modulated and blended anti-aliasing
abstract: A system, method, and computer program product are provided for anti-aliasing. During a first processing pass of a plurality of graphics primitives, z data is computed for multiple samples of each pixel in an image to generate a multi-sample z buffer. During a second processing pass of the graphics primitives, computed color values corresponding to each pixel in a color buffer that stores one color value for each pixel are accumulated.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09454843&OS=09454843&RS=09454843
owner: NVIDIA Corporation
number: 09454843
owner_city: Santa Clara
owner_country: US
publication_date: 20130205
---
The present invention relates to anti aliasing and more particularly to generating anti aliased images.

Conventional anti aliasing techniques generate a z value and a color value for each sample within a pixel to produce an anti aliased image. In general as the number of samples per pixel increases the quality of the anti aliased image also increases. The per sample color values are combined for each pixel of an image to produce anti aliased color data that is stored in the frame buffer.

The amount of memory needed to store the z and color data to produce the anti aliased image increases based on the number of samples that are used. For example when four samples are used for each pixel the amount of memory needed to store the z and color data is four times the amount of memory needed to store the z and color data when only one sample is used for each pixel. In addition the amount of bandwidth that is needed to transfer the z and color data between the memory and the graphics processor that computes the per sample z and color data also increases. Increased memory and bandwidth consumption may result in decreased graphics processing performance and or increased system cost.

Thus there is a need for addressing the issues of increased storage and increased memory bandwidth and or other issues associated with the prior art.

A system method and computer program product are provided for anti aliasing. During a first processing pass of a plurality of graphics primitives z data is computed for multiple samples of each pixel in an image to generate a multi sample z buffer. During a second processing pass of the graphics primitives computed color values corresponding to each pixel in a color buffer that stores one color value for each pixel are accumulated.

When conventional graphics processors are configured to perform anti aliasing the amount of memory that is allocated to store the color data to produce the anti aliased image increases based on the number of samples that are used. The color data for each sample is written to the multi sample color buffer and then the multi sample color buffer is read to combine the samples for each pixel to produce the anti aliased image. Because the samples are written and then read for each pixel more memory bandwidth is consumed compared with writing a single sample for each pixel to produce an aliased image.

The amount of memory that is allocated to store the color data may be reduced to a single sample for each pixel by using a multi sample stencil buffer to ensure each sample of a pixel is only shaded once and accumulated into the pixel. The color data for each sample is modulated before being accumulated into a corresponding pixel stored in the color buffer. In addition to decreasing the amount of memory used to store the color data the memory bandwidth that is consumed is also reduced compared with using a multi sample color buffer to produce an anti aliased image.

More illustrative information will now be set forth regarding various optional architectures and features with which the foregoing framework may or may not be implemented per the desires of the user. It should be strongly noted that the following information is set forth for illustrative purposes and should not be construed as limiting in any manner. Any of the following features may be optionally incorporated with or without the exclusion of other features described.

When the stencil buffer is used to generate the anti aliased image a multi sample stencil buffer is allocated to store four separate stencil values corresponding to locations A B C and D. In one embodiment the multi sample stencil buffer stores only one bit for each sample. The multi sample stencil buffer may be used to compute only one color value for each sample even when two primitives having equal z values cover the sample.

In contrast with the multi sample z buffer the color buffer only stores a single value for each pixel. Four separate color values may be computed that each correspond to locations A B C and D and the sample color values are modulated before being accumulated into the single value for a pixel. For example when four samples are used each sample color value is scaled by to modulate the sample color value. In general each sample color value is divided by the number of samples per pixel to modulate the sample color value. The modulated sample color values for each pixel are accumulated i.e. summed or added directly into the color buffer to generate the anti aliased color value for the pixel. Neither the sample color values nor the modulated sample color values are stored in a multi sample color buffer. Instead the accumulated color values are transferred directly to the color buffer as the modulated sample color values are computed.

A single accumulated color buffer is allocated to store a single sample for each pixel. The size of the accumulated color buffer does not increase as the number of samples per pixel increases. In contrast a conventional anti aliasing technique may require allocation of a single color buffer to store multiple samples for each pixel or separate color buffers for each sample.

In a first example the z test function is set to less than for the first processing of the graphics primitives and the primitive processing order first to last is primitive primitive primitive and primitive . When the less than z test function is used the z value computed or stored that is less than is written or retained in the multi sample z buffer for the sample location. The first processing need only compute z values for each sample location that is covered by a graphics primitive to generate z data that is stored in the multi sample z buffer.

The first graphics primitive primitive is rasterized and a z value is computed for each sample location that is covered by the primitive . Specifically z values are computed for sample locations A and B of the pixel . The z values are written to the multi sample z buffer for the sample locations A and B of the pixel . The second graphics primitive primitive is rasterized and a z value is computed for each sample location that is covered by the primitive . Specifically z values are computed for sample locations A B and D of the pixel sample locations A and C of the pixel and sample location C of the pixel . The computed z values are compared with the z values stored in the multi sample z buffer for the sample locations that were covered by primitive e.g. sample location A of the pixel . Because the primitive is closer than the primitive and the z test function is set to less than the computed z value is written to the multi sample z buffer for the sample location A of the pixel replacing the z value computed for the primitive . The other z values computed for the primitive are also written to the multi sample z buffer.

The third graphics primitive primitive is rasterized and a z value is computed for each sample location that is covered by the primitive . Specifically z values are computed for sample locations B and D of the pixel and written to the multi sample z buffer. The fourth last graphics primitive primitive is rasterized and a z value is computed for each sample location that is covered by the primitive . Specifically z values are computed for sample locations A and C of the pixel and sample locations A and B of the pixel . The z values computed for the sample locations A and B of the pixel equal the z values that were computed and written to the multi sample z buffer when the primitive was processed. Therefore the z values corresponding to primitive fail the z test for the sample locations A and B of the pixel . The z values corresponding to the primitive pass the z test for the sample locations A and C of the pixel are written to the multi sample z buffer.

After the first processing of the graphics primitives the z test function is set to equal for the second processing pass of the graphics primitives. The stencil function is performed after the z test and is set to fail discard samples if the stencil value stored in the multi sample stencil buffer is non zero. The stencil function is set to pass and then the stencil value is incremented when the stencil value stored in the multi sample stencil buffer is zero. The result is that when two graphics primitives cover the same sample location and have the equal z values the first graphics primitive that is processed will be shaded to contribute a color value for the sample location. In one embodiment the multi sample stencil buffer may be cleared to an initial value of 1 instead of zero and the stencil function is set to pass and then decrement the stencil value stored in the multi sample stencil buffer when the stencil value equals 1 and fail if the stencil value stored in the multi sample stencil buffer equals zero. The multi sample stencil buffer is used to ensure that only a single graphics primitive contributes a color value for each covered sample location of an image.

For the second processing pass of the graphics primitive the color blend function is set to add color values. For example in terms of the OpenGL applications programming interface the blend func GL ADD blend src GL ONE blend dst GL ONE. Adding the color values computed for each sample of a pixel accumulates the samples into a single anti aliased color value for the pixel dst . However before each sample color value is summed with the color value for the pixel the sample color value src is modulated based on the number of samples per pixel i.e. the multi sample mode .

Continuing with the first example during the second processing pass of the graphics primitives the first graphics primitive primitive is rasterized and a z value is computed for each sample location that is covered by the primitive . Specifically z values are computed for sample locations A and B of the pixel . The z value computed for the sample location A fails the z test and the z value computed for the sample location B passes the z test. Because the z data is already stored in the multi sample z buffer it is not necessary to write any z values to the multi sample buffer during the second processing pass of the graphics primitives. The sample location A of the pixel for the primitive is discarded and only the sample location B for the pixel continues to be processed for the primitive .

The multi sample stencil buffer value corresponding to the sample location B for the pixel equals zero the stencil buffer values were initialized to zero so the sample location B for the pixel passes the stencil test. The sample location B for the pixel stored in the multi sample stencil buffer is updated i.e. incremented from a value of zero to 1. Updating the stencil value prevents another graphics primitive that passes the z test from contributing color to the sample location B for the pixel . It is important that only one graphics primitive contribute color to each sample so that the anti aliased color is correct for each pixel and is not oversaturated. A color value is computed for the sample location B of the pixel and the color value is scaled by to compute the modulated color value. The modulated color value is then summed with the color value stored in the accumulated color buffer for pixel . The color value that is stored in the accumulated color buffer for pixel equals the modulated color value because the graphics primitive is the first graphics primitive to shade the pixel i.e. contribute to the accumulated color of the pixel during the second processing pass.

The second graphics primitive primitive is rasterized and a z value is computed for each sample location that is covered by the primitive . Specifically z values are computed for sample locations A B and D of the pixel sample locations A and C of the pixel and sample location C of the pixel . The computed z values are compared with the z values stored in the multi sample z buffer and all of the computed z values pass the z test. Therefore the stencil values for the sample locations A B and D of the pixel sample locations A and C of the pixel and sample location C of the pixel are read from the multi sample stencil buffer and all of the sample locations covered by the primitive pass the stencil test. The stencil values for the sample locations A B and D of the pixel sample locations A and C of the pixel and sample location C of the pixel are updated. The color values are computed for the sample locations A B and D of the pixel sample locations A and C of the pixel and sample location C of the pixel . The computed color values are scaled by to compute the modulated color values.

In one embodiment a single color value is computed for samples within the same pixel and the computed color values are scaled based on the per pixel coverage. For example the computed color value for sample locations A and C of the pixel is scaled by to compute a combined modulated color value because of the 4 sample locations are covered. Similarly the computed color value for the sample locations A B and D of the pixel are scaled by to compute a combined modulated color value because of the 4 sample locations are covered. In another embodiment separate color values are computed for each sample within a pixel and the separate color values are summed together and scaled based on the per pixel covered to compute a combined modulated color value. The combined modulated color value is added to the color value for the pixel stored in the accumulated color buffer. Computing a combined modulated color value may reduce the amount of memory bandwidth that is consumed to write the accumulated color buffer.

Continuing with the first example during the second processing pass of the graphics primitives the third graphics primitive primitive is rasterized and a z value is computed for each sample location that is covered by the primitive . Specifically z values are computed for sample locations B and D of the pixel and written to the multi sample z buffer. The computed z values pass the z test and the multi sample stencil buffer is read for the sample locations B and D of the pixel . The stencil values equal zero so the sample locations B and D of the pixel pass the stencil test. The stencil values for the sample locations B and D of the pixel are updated in the multi sample stencil buffer and color values are computed for the sample locations B and D of the pixel . The computed color values are modulated and added to the color value stored in the accumulated color buffer for the pixel .

The fourth last graphics primitive primitive is rasterized and a z value is computed for each sample location that is covered by the primitive . Specifically z values are computed for sample locations A and C of the pixel and sample locations A and B of the pixel . The z values computed for the sample locations A and B of the pixel equal the z values that were computed and written to the multi sample z buffer when the primitive was processed. Because the z test is set to equal all of the z values computed for the primitive pass the z test. However all the sample locations A and B of the pixel fail the stencil test for the primitive and are discarded. The sample locations A and C of the pixel pass the stencil test and the stencil values for the sample locations A and C of the pixel are updated. The color values are computed for the sample locations A and C of the pixel . The computed color values are modulated and added to the color value stored in the accumulated color buffer for the pixel . Each of primitives and contributes half of the anti aliased color value stored for the pixel .

In a second example the z test function is set to less than or equal for the first processing of the graphics primitives and the primitive processing order first to last is the same as the first example i.e. primitive primitive primitive and primitive .

The first graphics primitive primitive is rasterized and a z value is computed for each sample location that is covered by the primitive . Specifically z values are computed for sample locations A and B of the pixel . The z values are written to the multi sample z buffer for the sample locations A and B of the pixel . The second graphics primitive primitive is rasterized and a z value is computed for each sample location that is covered by the primitive . Specifically z values are computed for sample locations A B and D of the pixel sample locations A and C of the pixel and sample location C of the pixel . The computed z values are compared with the z values stored in the multi sample z buffer for the sample locations that were covered by primitive e.g. sample location A of the pixel . Because the primitive is closer than the primitive and the z test function is set to less than or equal the computed z value is written to the multi sample z buffer for the sample location A of the pixel replacing the z value computed for the primitive . The other z values computed for the primitive are also written to the multi sample z buffer.

The third graphics primitive primitive is rasterized and a z value is computed for each sample location that is covered by the primitive . Specifically z values are computed for sample locations B and D of the pixel and written to the multi sample z buffer. The fourth last graphics primitive primitive is rasterized and a z value is computed for each sample location that is covered by the primitive . Specifically z values are computed for sample locations A and C of the pixel and sample locations A and B of the pixel . The z values computed for the sample locations A and B of the pixel equal the z values that were computed and written to the multi sample z buffer when the primitive was processed. Therefore in contrast with the first example the z values corresponding to primitive pass the z test for the sample locations A and B of the pixel and are written to the multi sample z buffer. The z values corresponding to the primitive also pass the z test for the sample locations A and C of the pixel and are written to the multi sample z buffer.

The z data stored in the multi sample z buffer is the same when the z test function for the first processing is set to less than as when the z test function is set to less than or equal . Therefore the same anti aliased image is produced for the two different z test functions. Furthermore the less than or equal z test function may be used for the second processing pass because only z values that are equal will pass the z test. The first graphics primitive that is processed for a sample location that has a computed z value equal to the corresponding z value stored in the multi sample z buffer will pass the stencil test and continue to be processed. Therefore the order in which the primitives are processed for the second processing pass of the graphics primitives should be consistent over multiple frames to avoid introducing visual artifacts in the anti aliased images. Although the second pass is described as using a multi sample stencil buffer to discard additional samples have equal z values other techniques may be used to discard the additional samples and ensure that only one sample contributes to the anti aliased color value stored for a pixel.

At step graphics primitives are processed a first time to generate z values that are written to the multi sample z buffer. In one embodiment a shader program is executed to compute a z value for each sample location that is covered by a graphics primitive. The computed z value is compared with the value stored in the z buffer for the same sample location and the computed z value overwrites the value stored in the z buffer or is discarded based on application of the z test function. The z test function may be set to less than or less than or equal . The purpose of the first processing pass of the graphics primitives is to generate a multi sample z buffer storing the front most z values for each sample location of the anti aliased image. Therefore only z values need to be computed for each sample location that is covered by a graphics primitive. In other words it is not necessary to compute color values or other attributes during the first processing pass of the graphics primitives.

At step the stencil buffer function is set and the color blend function is set. The stencil buffer function is set to pass for only one of two or more graphics primitives that cover a sample location when tested against the stencil value stored in the multi sample stencil buffer for the sample location. For example the first graphics primitive that is processed for the two or more graphics primitives may pass the stencil test for a particular sample location while one or more other graphics primitives will fail the stencil test for the same sample location. In one embodiment the stencil buffer function is set to discard a sample having a stencil value that is not equal to zero and update the stencil value for a sample having a stencil value that is equal to zero. The color blend function is set to add a modulated sample color or a combined modulated sample color to the color value stored in the accumulated color buffer for the pixel. The stencil function and color blend function may be set prior to the step because the color blend and stencil functions are not used during the first processing pass.

At step the graphics primitives are processed for a second time. At step z testing is performed and if the computed z value fails the z test at step the sample is discarded. Otherwise at step stencil testing is performed and if the stencil value stored in the multi sample stencil buffer for the sample location is not equal to zero at step the sample is discarded. Otherwise at step the stencil value stored in the multi sample stencil buffer for the sample location is updated i.e. incremented.

At step the sample color is scaled based on the number of samples to produce a modulated sample color and the modulated sample color is summed with the color value stored in the accumulated color buffer for the pixel. In one embodiment at step a combined modulated color value is produced for the pixel and the combined modulated color value is summed with the color value stored for the pixel in the accumulated color buffer. If at step another sample location is covered by a graphics primitive the method returns to step . Otherwise the second processing pass of the graphics primitives is complete and the accumulated color buffer stores color values representing the anti aliased image.

For some applications it is acceptable for multiple samples to contribute to the anti aliased color stored for a pixel. Additionally the likelihood of two or more samples having equal z values may be rare. When it is acceptable for multiple samples to contribute to the anti aliased color for a pixel the stencil buffer is not needed to perform anti aliasing.

At step graphics primitives are processed a first time to generate z values that are written to the multi sample z buffer. In one embodiment a shader program is executed to compute a z value for each sample location that is covered by a graphics primitive. The computed z value is compared with the value stored in the z buffer for the same sample location and the computed z value overwrites the value stored in the z buffer or is discarded based on application of the z test function. The z test function may be set to less than or less than or equal . The purpose of the first processing pass of the graphics primitives is to generate a multi sample z buffer storing the front most z values for each sample location of the anti aliased image. Therefore only z values need to be computed for each sample location that is covered by a graphics primitive. In other words it is not necessary to compute color values or other attributes during the first processing pass of the graphics primitives.

At step the color blend function is set to add a modulated sample color or a combined modulated sample color to the color value stored in the accumulated color buffer for the pixel. The color blend function may be set prior to the step because the color blend function is not used during the first processing pass.

At step the graphics primitives are processed for a second time. At step z testing is performed and if the computed z value fails the z test at step the sample is discarded. Otherwise at step the sample color is scaled based on the number of samples to produce a modulated sample color and the modulated sample color is summed with the color value stored in the accumulated color buffer for the pixel. In one embodiment at step a combined modulated color value is produced for the pixel and the combined modulated color value is summed with the color value stored for the pixel in the accumulated color buffer. If at step another sample location is covered by a graphics primitive the method returns to step . Otherwise the second processing pass of the graphics primitives is complete and the accumulated color buffer stores color values representing the anti aliased image.

In one embodiment the PPU includes an input output I O unit configured to transmit and receive communications i.e. commands data etc. from a central processing unit CPU not shown over the system bus . The I O unit may implement a Peripheral Component interconnect Express PCIe interface for communications over a PCIe bus. In alternative embodiments the I O unit may implement other types of well known bus interfaces.

The PPU also includes a host interface unit that decodes the commands and transmits the commands to the grid management unit or other units of the PPU e.g. memory interface as the commands may specify. The host interface unit is configured to route communications between and among the various logical units of the PPU .

In one embodiment a program encoded as a command stream is written to a buffer by the CPU. The buffer is a region in memory e.g. memory or system memory that is accessible i.e. read write by both the CPU and the PPU . The CPU writes the command stream to the buffer and then transmits a pointer to the start of the command stream to the PPU . The host interface unit provides the grid management unit GMU with pointers to one or more streams. The GMU selects one or more streams and is configured to organize the selected streams as a pool of pending grids. The pool of pending grids may include new grids that have not yet been selected for execution and grids that have been partially executed and have been suspended.

A work distribution unit that is coupled between the GMU and the SW manages a pool of active grids selecting and dispatching active grids for execution by the SMs . Pending grids are transferred to the active grid pool by the GMU when a pending grid is eligible to execute i.e. has no unresolved data dependencies. An active grid is transferred to the pending pool when execution of the active grid is blocked by a dependency. When execution of a grid is completed the grid is removed from the active grid pool by the work distribution unit . In addition to receiving grids from the host interface unit and the work distribution unit the GMU also receives grids that are dynamically generated by the SMs during execution of a grid. These dynamically generated grids join the other pending grids in the pending grid pool.

In one embodiment the CPU executes a driver kernel that implements an application programming interface API that enables one or more applications executing on the CPU to schedule operations for execution on the PPU . An application may include instructions i.e. API calls that cause the driver kernel to generate one or more grids for execution. In one embodiment the PPU implements a SIMD Single Instruction Multiple Data architecture where each thread block i.e. warp in a grid is concurrently executed on a different data set by different threads in the thread block. The driver kernel defines thread blocks that are comprised of k related threads such that threads in the same thread block may exchange data through shared memory. In one embodiment a thread block comprises 32 related threads and a grid is an array of one or more thread blocks that execute the same stream and the different thread blocks may exchange data through global memory.

In one embodiment the PPU comprises X SMs X . For example the PPU may include 15 distinct SMs . Each SM is multi threaded and configured to execute a plurality of threads e.g. 32 threads from a particular thread block concurrently. Each of the SMs is connected to a level two L2 cache via a crossbar or other type of interconnect network . A color blend unit is configured to perform blend functions such as the blend function used to accumulate the modulated sample color values and combined modulated sample values into the color buffer that may be stored in the memory and cached in the L2 cache . The color blend unit may also be configured to modulate the sample color values for each pixel by setting the alpha value srcAlpha to the number of samples per pixel to generate a modulated sample color value or setting the alpha value to the per pixel coverage to generate a combined modulated sample color value. For example in terms of the OpenGL applications programming interface the blend func GL ADD blend src GL ALPHA blend dst GL ONE. The sample color value src is scaled by the alpha value and summed with the color value that is stored for the pixel dst .

The L2 cache is connected to one or more memory interfaces . Memory interfaces implement 16 32 64 128 bit data buses or the like for high speed data transfer. In one embodiment the PPU comprises U memory interfaces U where each memory interface U is connected to a corresponding memory device U . For example PPU may be connected to up to 6 memory devices such as graphics double data rate version 5 synchronous dynamic random access memory GDDR5 SDRAM .

In one embodiment the PPU implements a multi level memory hierarchy. The memory is located off chip in SDRAM coupled to the PPU . Data from the memory may be fetched and stored in the L2 cache which is located on chip and is shared between the various SMs . In one embodiment each of the SMs also implements an L1 cache. The L1 cache is private memory that is dedicated to a particular SM . Each of the L1 caches is coupled to the shared L2 cache . Data from the L2 cache may be fetched and stored in each of the L1 caches for processing in the functional units of the SMs .

In one embodiment the PPU comprises a graphics processing unit GPU . The PPD is configured to receive commands that specify shader programs for processing graphics data. Graphics data may be defined as a set of primitives such as points lines triangles quads triangle strips and the like. Typically a primitive includes data that specifies a number of vertices for the primitive e.g. in a model space coordinate system as well as attributes associated with each vertex of the primitive. The PPU can be configured to process the graphics primitives to generate a frame buffer i.e. pixel data for each of the pixels of the display . The driver kernel implements a graphics processing pipeline such as the graphics processing pipeline defined by the OpenGL API.

An application writes model data for a scene i.e. a collection of vertices and attributes to memory. The model data defines each of the objects that may be visible on a display. The application then makes an API call to the driver kernel that requests the model data to be rendered and displayed. The driver kernel reads the model data and writes commands to the buffer to perform one or more operations to process the model data. The commands may encode different shader programs including one or more of a vertex shader hull shader geometry shader pixel shader etc.

For example the GMU may configure one or more SMs to execute a vertex shade program that processes a number of vertices defined by the model data. In one embodiment the EMU may configure different SMs to execute different shader programs concurrently. For example a first subset of SMs may be configured to execute a vertex shader program while a second subset of SMs may be configured to execute a pixel shader program. The first subset of SMs processes vertex data to produce processed vertex data and writes the processed vertex data to the L2 cache and or the memory . After the processed vertex data is rasterized i.e. transformed from three dimensional data into two dimensional data in screen space to produce fragment data the second subset of SMs executes a pixel shader to produce processed fragment data which is then blended with other processed fragment data and written to the frame buffer in memory . The vertex shader program and pixel shader program may execute concurrently processing different data from the same scene in a pipelined fashion until all of the model data for the scene has been rendered to the frame buffer. Then the contents of the frame buffer are transmitted to a display controller for display on a display device.

A pixel shader program may be configured to generate anti aliased images according to the techniques described in conjunction with when executed by one or more SMs . The multi sample z buffer multi sample stencil buffer and accumulated color buffer may be stored in the memory . In addition to reducing the amount of memory allocated for storing color data when the two pass technique is used to generate the anti aliased image the bandwidth that is consumed to generate the accumulated color buffer is reduced compared with generating a multi sample color buffer. Reducing the amount of space needed for storing the color buffer and reducing the memory bandwidth that is consumed may improve processing performance of the PPU when anti aliased images are generated.

The PPU may be included in a desktop computer a laptop computer a tablet computer a smart phone e.g. a wireless hand held device personal digital assistant PDA a digital camera a hand held electronic device and the like. In one embodiment the PPU is embodied on a single semiconductor substrate. In another embodiment the PPU is included in a system on a chip SoC along with one or more other logic units such as a reduced instruction set computer RISC CPU a memory management unit MMU a digital to analog converter DAC and the like.

In one embodiment the PPU may be included on a graphics card that includes one or more memory devices such as GDDR5 SDRAM. The graphics card may be configured to interface with a Pete slot on a motherboard of a desktop computer that includes e.g. a northbridge chipset and a southbridge chipset. In yet another embodiment the PPD may be an integrated graphics processing unit iGPU included in the chipset i.e. Northbridge of the motherboard.

As described above the work distribution unit dispatches active grids for execution on one or more SMs of the PPU . The scheduler unit receives the grids from the work distribution unit and manages instruction scheduling for one or more thread blocks of each active grid. The scheduler unit schedules threads for execution in groups of parallel threads where each group is called a warp. In one embodiment each warp includes 32 threads. The scheduler unit may manage a plurality of different thread blocks allocating the thread blocks to warps for execution and then scheduling instructions from the plurality of different warps on the various functional units i.e. cores DPUs SFUs and Us during each clock cycle.

In one embodiment each scheduler unit includes one or more instruction dispatch units . Each dispatch unit is configured to transmit instructions to one or more of the functional units. In the embodiment shown in the scheduler unit includes two dispatch units that enable two different instructions from the same warp to be dispatched during each clock cycle. In alternative embodiments each scheduler unit may include a single dispatch unit or additional dispatch units .

Each SM includes a register file that provides a set of registers for the functional units of the SM . In one embodiment the register file is divided between each of the functional units such that each functional unit is allocated a dedicated portion of the register file . In another embodiment the register file is divided between the different warps being executed by the SM . The register file provides temporary storage for operands connected to the data paths of the functional units.

Each SM comprises L processing cores . In one embodiment the SM includes a large number e.g. 192 etc. of distinct processing cores . Each core is a fully pipelined single precision processing unit that includes a floating point arithmetic logic unit and an integer arithmetic logic unit. In one embodiment the floating point arithmetic logic units implement the IEEE 754 2008 standard for floating point arithmetic. Each SM also comprises M DPUs that implement double precision floating point arithmetic N SFUs that perform special functions e.g. copy rectangle pixel blending operations and the like and P LSUs that implement load and store operations between the shared memory L1 cache and the register file . In one embodiment the SM includes 64 DPUs 32 SFUs and 32 LSUs .

Each SM includes an interconnect network that connects each of the functional units to the register file and the shared memory L1 cache . In one embodiment the interconnect network is a crossbar that can be configured to connect any of the functional units to any of the registers in the register file or the memory locations in shared memory L1 cache .

In one embodiment the SM is implemented within a GPU. In such an embodiment the SM comprises J texture units . The texture units are configured to load texture maps i.e. a 2D array of texels from the memory and sample the texture maps to produce sampled texture values for use in shader programs. The texture units implement texture operations such as anti aliasing operations using mip maps i.e. texture maps of varying levels of detail . In one embodiment the SM includes 16 texture units .

The PPU described above may be configured to perform highly parallel computations much faster than conventional CPUs. Parallel computing has advantages in graphics processing data compression biometrics stream processing algorithms and the like.

The system also includes input devices a graphics processor and a display i.e. a conventional CRT cathode ray tube LCD liquid crystal display LED light emitting diode plasma display or the like. User input may be received from the input devices e.g. keyboard mouse touchpad microphone and the like. In one embodiment the graphics processor may include a plurality of shader modules a rasterization module etc. Each of the foregoing modules may even be situated on a single semiconductor platform to form a graphics processing unit GPU .

In the present description a single semiconductor platform may refer to a sole unitary semiconductor based integrated circuit or chip. It should be noted that the term single semiconductor platform may also refer to multi chip modules with increased connectivity which simulate on chip operation and make substantial improvements over utilizing a conventional central processing unit CPU and bus implementation. Of course the various modules may also be situated separately or in various combinations of semiconductor platforms per the desires of the user.

The system may also include a secondary storage . The secondary storage includes for example a hard disk drive and or a removable storage drive representing a floppy disk drive a magnetic tape drive a compact disk drive digital versatile disk DVD drive recording device universal serial bus USB flash memory. The removable storage drive reads from and or writes to a removable storage unit in a well known manner.

Computer programs or computer control logic algorithms may be stored in the main memory and or the secondary storage . Such computer programs when executed enable the system to perform various functions. For example a compiler program that is configured to examiner a shader program and enable or disable attribute buffer combining may be stored in the main memory . The compiler program may be executed by the central processor or the graphics processor . The main memory the storage and or any other storage are possible examples of computer readable media.

In one embodiment the architecture and or functionality of the various previous figures may be implemented in the context of the central processor the graphics processor an integrated circuit not shown that is capable of at least a portion of the capabilities of both the central processor and the graphics processor a chipset i.e. a group of integrated circuits designed to work and sold as a unit for performing related functions etc. and or any other integrated circuit for that matter.

Still yet the architecture and or functionality of the various previous figures may be implemented in the context of a general computer system a circuit hoard system a game console system dedicated for entertainment purposes an application specific system and or any other desired system. For example the system may take the form of a desktop computer laptop computer server workstation game consoles embedded system and or any other type of logic. Still yet the system may take the form of various other devices including but not limited to a personal digital assistant PDA device a mobile phone device a television etc.

Further while not shown the system may be coupled to a network e.g. a telecommunications network local area network LAN wireless network wide area network WAN such as the Internet peer to peer network cable network or the like for communication purposes.

While various embodiments have been described above it should be understood that they have been presented by way of example only and not limitation. Thus the breadth and scope of a preferred embodiment should not be limited by any of the above described exemplary embodiments but should be defined only in accordance with the following claims and their equivalents.

