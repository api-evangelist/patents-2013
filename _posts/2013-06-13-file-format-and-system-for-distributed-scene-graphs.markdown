---

title: File format and system for distributed scene graphs
abstract: A method, apparatus, system, and computer program product provide the ability to utilize a distributed scene graph. A database of hashes and corresponding location identifiers (for asset locations) is maintained. An export of a scene (including scene assets) is initiated and hash values for the scene assets are computed. If the hash value is not in the database, it is added to the database. If the hash value is in the database, the corresponding location identifier is used to identify the location of the scene asset. The hash value and corresponding location identifier are stored in a scene graph file that is traversed. During the traversal, for each hash value in the scene graph file, the scene asset is retrieved from the location identified in the scene graph file and processed.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09508114&OS=09508114&RS=09508114
owner: Autodesk, Inc.
number: 09508114
owner_city: San Rafael
owner_country: US
publication_date: 20130613
---
The present invention relates generally to cloud computing and in particular to a method apparatus and article of manufacture for a file format that enables cloud computing with both low data space and low bandwidth consumption.

Computing at in the cloud can be very data intensive. Assets used during computation must be present on the computers where computation is performed. In many cases these assets are present on a user client machine and have to be packaged and sent to one or more locations in the cloud. Over time various problems occur. One problem is that very large amounts of data bandwidth are required to send this data into a permanent storage location in the cloud and additionally to send that data to the computing machines when it is required for computation. A second problem is the size of data stored on the cloud. Over time this data may include many duplicates wasting precious space. A third problem is that standard assets uploaded for prior computation cannot be easily upgraded when improvements to those standard assets are available. To better understand the problems of the prior art a description of assets and cloud computing may be useful.

As used herein an asset refers to an object shape image video clip media content audio clip audio video clip etc. Assets are commonly used in a variety of applications including image processing and video editing systems. When editing graphics etc. a scene graph is commonly utilized. In this regard a scene graph is typically used for 2D and or 3D graphics image synthesis e.g. rendering either offline high quality rendering or fast interactive rendering for real time scene editing walkthroughs animation generation and games . A scene graph is a general data structure that arranges the logical and often but not necessarily spatial representation of a graphical scene. A scene graph is often a collection of nodes in a graph. A node may have many children and also multiple parents with the effect of a parent applied to all its child nodes. In the context of scene graphs the graphs may be directed acyclic graphs DAGs . In a DAG when a graph edge is followed the edge only goes one direction and a traversal can follow any number of edges and never reach the current node again acyclic .

In a scene graph also referred to as a process graph tree a root node defines a rendering of a particular view of a scene. For a given scene there may be hundreds of views which is equivalent to hundreds of root nodes. For example there may exist a hundred scene graphs of the same box with each scene graph presenting a different view of the box e.g. different angles or objects e.g. a ball inside of the box . Each root node defines everything that would be seen once the scene graph is fully processed.

To process a scene graph i.e. to render a scene the graph is traversed e.g. beginning with the root node and traversing each child node . To improve the rendering time it may be desirable to perform all or some parts of the rendering using multiple computers processors available in the cloud referred to as compute nodes . Thus with cloud computing the rendering is not being performed locally where the data originates from. Consequently the data assets need to be transmitted uploaded from the client to the compute node where the rendering is performed. However the translation and serialization of all assets every time is expensive both in terms of computation and infrastructure . Further bandwidth requirements may be prohibitively high for all the data to be transmitted to the cloud. Thus it is undesirable to rely on data transmitted from a client e.g. due to limited bandwidth processing capabilities infrastructure etc. .

In addition because users may re render data from the cloud the data may be reused so it must be stored at the cloud. Storing all of the data in the cloud is expensive in terms of processing and infrastructure required . Further over time some data may be duplicated millions of times in storage. Also even if stored in the cloud the data must again be transferred from cloud storage to compute nodes requiring even more bandwidth. At the renderer the same data e.g. texture mesh etc. may be read multiple times and multiple copies may persist throughout rendering requiring more memory.

In view of the above it is desirable to attempt to reduce the amount of data that is stored as well as to reduce the amount of data that needs to be transferred to the compute node.

Embodiments of the invention overcome the problems of the prior art by utilizing a distributed file format. Assets of a scene are placed into a scene graph file and a de duplicated e.g. using a unique hash representation of the asset to reduce data size. Such assets can be references from any scene graph file defined by other files in the same format . Further at scene graph traversal time assets from multiple files can be utilized to define a scene.

In the following description reference is made to the accompanying drawings which form a part hereof and which is shown by way of illustration several embodiments of the present invention. It is understood that other embodiments may be utilized and structural changes may be made without departing from the scope of the present invention.

In one embodiment the computer operates by the general purpose processor A performing instructions defined by the computer program under control of an operating system . The computer program and or the operating system may be stored in the memory and may interface with the user and or other devices to accept input and commands and based on such input and commands and the instructions defined by the computer program and operating system to provide output and results.

Output results may be presented on the display or provided to another device for presentation or further processing or action. In one embodiment the display comprises a liquid crystal display LCD having a plurality of separately addressable liquid crystals. Alternatively the display may comprise a light emitting diode LED display having clusters of red green and blue diodes driven together to form full color pixels. Each liquid crystal or pixel of the display changes to an opaque or translucent state to form a part of the image on the display in response to the data or information generated by the processor from the application of the instructions of the computer program and or operating system to the input and commands. The image may be provided through a graphical user interface GUI module . Although the GUI module is depicted as a separate module the instructions performing the GUI functions can be resident or distributed in the operating system the computer program or implemented with special purpose memory and processors.

In one or more embodiments the display is integrated with into the computer and comprises a multi touch device having a touch sensing surface e.g. track pod or touch screen with the ability to recognize the presence of two or more points of contact with the surface. Examples of multi touch devices include mobile devices e.g. iPhone Nexus S Droid devices etc. tablet computers e.g. iPad HP Touchpad portable handheld game music video player console devices e.g. iPod Touch MP3 players Nintendo 3DS PlayStation Portable etc. touch tables and walls e.g. where an image is projected through acrylic and or glass and the image is then backlit with LEDs .

Some or all of the operations performed by the computer according to the computer program instructions may be implemented in a special purpose processor B. In this embodiment the some or all of the computer program instructions may be implemented via firmware instructions stored in a read only memory ROM a programmable read only memory PROM or flash memory within the special purpose processor B or in memory . The special purpose processor B may also be hardwired through circuit design to perform some or all of the operations to implement the present invention. Further the special purpose processor B may be a hybrid processor which includes dedicated circuitry for performing a subset of functions and other circuits for performing more general functions such as responding to computer program instructions. In one embodiment the special purpose processor is an application specific integrated circuit ASIC .

The computer may also implement a compiler that allows an application program written in a programming language such as COBOL Pascal C FORTRAN or other language to be translated into processor readable code. Alternatively the compiler may be an interpreter that executes instructions source code directly translates source code into an intermediate representation that is executed or that executes stored precompiled code. Such source code may be written in a variety of programming languages such as Java Perl Basic etc. After completion the application or computer program accesses and manipulates data accepted from I O devices and stored in the memory of the computer using the relationships and logic that were generated using the compiler .

The computer also optionally comprises an external communication device such as a modem satellite link Ethernet card or other device for accepting input from and providing output to other computers .

In one embodiment instructions implementing the operating system the computer program and the compiler are tangibly embodied in a non transient computer readable medium e.g. data storage device which could include one or more fixed or removable data storage devices such as a zip drive floppy disc drive hard drive CD ROM drive tape drive etc. Further the operating system and the computer program are comprised of computer program instructions which when accessed read and executed by the computer cause the computer to perform the steps necessary to implement and or use the present invention or to load the program of instructions into a memory thus creating a special purpose data structure causing the computer to operate as a specially programmed computer executing the method steps described herein. Computer program and or operating instructions may also be tangibly embodied in memory and or data communications devices thereby making a computer program product or article of manufacture according to the invention. As such the terms article of manufacture program storage device and computer program product as used herein are intended to encompass a computer program accessible from any computer readable device or media.

Of course those skilled in the art will recognize that any combination of the above components or any number of different components peripherals and other devices may be used with the computer .

A network such as the Internet connects clients to server computers compute nodes . Network may utilize ethernet coaxial cable wireless communications radio frequency RF etc. to connect and provide the communication between clients and servers compute nodes . Clients may execute a client application or web browser and communicate with server computers compute nodes executing web servers . Such a web browser is typically a program such as MICROSOFT INTERNET EXPLORER MOZILLA FIREFOX OPERA APPLE SAFARI GOOGLE CHROME etc. Further the software executing on clients may be downloaded from server computer compute node to client computers and installed as a plug in or ACTIVEX control of a web browser. Accordingly clients may utilize ACTIVEX components component object model COM or distributed COM DCOM components to provide a user interface on a display of client . The web server is typically a program such as MICROSOFT S INTERNET INFORMATION SERVER .

Web server may be a compute node or other processor configured to performing the operations processing rendering required to perform a cloud computing operation. Further web server may host an Active Server Page ASP or Internet Server Application Programming Interface ISAPI application which may be executing scripts. The scripts invoke objects that execute business logic referred to as business objects . The business objects then manipulate data in database through a database management system DBMS . Alternatively database may be part of or connected directly to client instead of communicating obtaining the information from database across network . When a developer encapsulates the business functionality into objects the system may be referred to as a component object model COM system. Accordingly the scripts executing on web server and or application invoke COM objects that implement the business logic. Further server compute node may utilize MICROSOFT S Transaction Server MTS to access required data stored in database via an interface such as ADO Active Data Objects OLE DB Object Linking and Embedding DataBase or ODBC Open DataBase Connectivity .

Generally these components all comprise logic and or data that is embodied in or retrievable from device medium signal or carrier e.g. a data storage device a data communications device a remote computer or device coupled to the computer via a network or via another data communications device etc. Moreover this logic and or data when read executed and or interpreted results in the steps necessary to implement and or use the present invention being performed.

Although the terms user computer client computer and or server computer compute node are referred to herein it is understood that such computers and may be interchangeable and may further include thin client devices with limited or full processing capabilities portable devices such as cell phones notebook computers pocket computers multi touch devices and or any other devices with suitable processing communication and input output capability.

Of course those skilled in the art will recognize that any combination of the above components or any number of different components peripherals and other devices may be used with computers and .

Embodiments of the invention are implemented as a software application on a client or server computer compute node . Further as described above the client or server computer compute node may comprise a thin client device or a portable device that has a multi touch based display.

To mitigate the problems of the prior art scene data assets may be stored as close to a compute node as possible. In some cases scene data assets may be stored on the compute node and in other cases scene data assets may be stored on the cloud so that the data asset does not need to be transmitted uploaded from the client twice. If stored on the cloud the data asset may be stored on a network attached storage NAS device memory or storage facility ies accessible on from the cloud. In this regard data may be stored in virtualized pools of storage that may be hosted by third parties e.g. operating large data centers and expose the storage as pools that can themselves be used to store files or data objects. Thus data assets may span across multiple servers and may be accessible via an application programming interface API a cloud storage gateway or through a web based user interface. Further embodiments of the invention may utilize multiple tiers in a cloud while storing the data asset in the tier closest to a compute node.

To enable the distributed scene graph system there are two components 1 the storage processing of a data asset and 2 the traversal of a scene graph containing that references the data asset. In accordance with embodiments of the invention once a data asset has been stored processed indexed a database used during such storing processing indexing in addition to other components is no longer needed e.g. during the traversal . To better understand the invention each of the two components will be described in further detail.

As described above scene data assets may be stored as close to computation nodes as possible e.g. the scene data assets may live in cloud storage and may be cached or staged at the compute node . Alternatively the location where the scene asset is stored may be located closer to a compute node than to a computer where the scene graph file is stored. To minimize the bandwidth reduce the file size and to streamline processing embodiments of the invention may utilize a particular format and system for storing a scene graph.

At step a user initiates the storage export of a scene graph. In this regard when a user opts to store a scene including the assets data of a scene the system may attempt to export the scene graph to create a distributed scene graph.

At step a hash of each asset in the scene graph is computed. Thus a unique hash ID e.g. a well distributed large hash such as 256 bit is assigned to each and every asset. The hash ID may be determined based on one or more hash functions e.g. MD5 which run over bits of a certain piece of data and compute a hash based thereon. In one or more embodiments it need not be a cryptographic hash function because malicious activity is not expected.

At step the database of hashes is queried based on the computed hash IDs. The query determines whether the hash exists in the database.

If the database does not contain the hash the asset is stored at exported to an accessible location at step . Such a location may be on the cloud local storage within a local network such that users on the local network can access the asset etc. In this regard the storage location may be required to be at least in the cloud otherwise future translations that access this asset may not be able to reference it. Although the asset may live in various locations in a cloud hierarchy there should be one or more definitive locations where the asset lives and where it is accessible to any consumer of the scene graph e.g. the renderer . At step a new entry is stored in the database. In other words if the hash was not previously listed in the hash database an entry is added to the database with the hash ID and a corresponding location where the asset is stored.

If at step it is determined that the database contains the hash ID a link to the location of the asset is returned at step and the link is used instead of the asset in the stored exported scene graph.

In view of the above once the hashes have been computed i.e. at step instead of placing an asset itself into a scene file the asset is replaced with a hash and the location of the asset. By utilizing hashes instead of the assets themselves the scene file size is reduced. Thereafter at scene compute time see further description below the assets may be retrieved based on the hash and URI URL. However such assets data may be located locally or at a location that is close to the compute machine thereby potentially avoiding limited bandwidth issues . In addition when storing small files the duplication of data is reduced thereby decreasing the amount of storage needed .

As an example a user entity may define a library of assets that define different materials e.g. with various parameters textures etc. . A hash database may include hash IDs for all of the materials in the library along with location information to the library that is maintained on a server in the cloud. When a user performs an export of a scene that contains a chair a hash of the chair is computed at step . A remote query of the hash database is conducted at step and returns a link to the exporter at step . The exporter then knows to link to that asset based on the location information. If the query fails a new entry is inserted in the database at step and identifies the asset via the hash ID and location of the asset that is currently being exported.

In view of the above once saved exported the scene graph is reduced to a list of hashes and locations identifying where an asset may be retrieved from.

The file format for a scene graph consist of two components 1 an archive layer and 2 a metadata and scene graph layer. However embodiments of the invention are not limited to such a file format.

The archive layer is used to store all binary data. illustrates a potential format for the archive layer in accordance with one or more embodiments of the invention. As illustrated a header may include a table of contents offset that points to contains the offset information for where the table of contents begins in the archive. The table of content includes the offset information e.g. an offset from the beginning of the file and or a pointer link for where each piece of binary data resides in the archive as well as the offset for the blocks index content. The binary content is stored at the locations identified by the offset in the table of contents . For example within the binary content portion of the archive binary data C content may be an arbitrary binary buffer or disk file that has been serialized binary data B content may be texture file content and binary content A may be geometry mesh data.

Accordingly the table of content identifies the locations of the portion of the scene graph that lives in the current file. The format for the table of content may be XML extensible markup language with elements that reference other XML elements in the document with some references to binary data . Such a format enables the ability for a scene graph to only download the section of the file that contains the relevant asset. For example if scene graph traversal of Scene A in File A identifies an asset that resides in File B the entire File B does not need to be downloaded. Instead using the table of content the system can identify the location of the particular asset from within File B and retrieve it as necessary.

Thus the components or the archive layer are the binary assets scene graph metadata and the table of contents. The table of contents identifies where all of the information in the archive layer is stored and is loaded first. Each table of content entry may identify the name of the asset information regarding the compressed size the uncompressed size and the byte offset location.

As described above the archive layer is similar to a ZIP archive and multiple different types of compression may be used e.g. ZLIB compression . Compression may also be disabled based on the file extension e.g. by specifying the MIME multipurpose internet mail extensions type ZLIB compression on a JPEG joint photographic experts group file has no real benefit .

In addition the archive layer that contains the binary data may automatically de duplicate the data. In this regard if two meshes are added that are binary identical the hash computation will be the same and only one of the meshes is stored. Nonetheless if desired embodiments of the invention can be configured to create multiple named references to the same data or to return a name if the data already exists in the archive. Further the archive layer may be read via memory mapping of files and it is possible to create a network based reader for the archive layer so that only needed assets are downloaded see further details below . Thus each binary data has a hash that is unique with very high probability allowing for de duplication and asset aggregation and management.

The metadata scene graph layer of the file format may consist of a compressed XML extensible markup language shallow graph. For example the XML graph tree may only be two layers deep where graph node connections form a directed acyclic or cyclic graph via named links that can refer to other nodes or to binary data within the archive . All strings may be de duplicated and replaced by a base 64 integer to save space. Each file may have a metadata section with a legend describing the string to integer mapping. The compressed XML may be stored as a further compressed binary in the archive layer.

In addition to the above the file scene graph may be composed distributed across several files. In such a distributed file libraries of materials environments and other assets may be hosted in the cloud instead of being packed in with the main or root file. Further the assets can live on the compute nodes vastly reducing bandwidth requirements.

The file contents digest is a digest of the contents of the file. The digest contains name hash mappings and limited metadata about the assets. The digest can be used to determine if a remote file contains any of the assets needed in a scene graph. Thus the use of a digest may reduce the number of assets written into the main scene file.

In view of the file format described above it may be noted that it is not necessary to know that the scene graph node data is in XML or other format in the file. In this regard the in memory representation consist of blocks of names mapped to parameters. Further binaries may be added directly to the file e.g. the archive layer of the file thereby allowing a scene graph to link to it later. Alternatively whenever a link to a binary is added the binary may be automatically inserted into the file. Such links may be of the form location block name where if the location is an empty string it refers to the current file i.e. the asset s location is not located remotely . Two blocks of the same name may not be allowed within the same package but the same block name may exist multiple times in a scene graph in multiple packages. In addition within a lock it may be allowed to have multiple parameters with the same name.

Loading a file formatted stored exported as described above will result in a scene graph. In addition before traversal the scene graph can be updated. For example it is possible to alias blocks e.g. a block named Ceramic01 may be aliased to a new block MyMaterial . Further it is possible to alias entire packages such that if a link is encountered the correct file identified in the link can be utilized e.g. if a link proteinlib Ceramic01 is encountered the correct file represented by the location proteinlib can be used . In addition as described above if the location is null not specified a block within the current package file is utilized by default e.g. in location block name if location the location is assumed to be within the current package file .

A traverser object application may be used to facilitate traversal by maintaining state regarding which package the traversal is in at any time. In this regard the current package may not be the package that the traversal began with e.g. the location was followed to retrieve a new package file . The traverse object keeps track of where the processing is during the traversal.

At step the main first primary scene graph file is obtained. In other words the scene graph file to be traversed is created acquired.

At step callbacks for the various block types are registered. In this regard all blocks are associated with a type e.g. materials geometries meshes etc. . At step a callback i.e. an application function is registered associated with all known block types as well as an unhandled callback function to handle unknown blocks if encountered during a traversal.

At step any locations and or blocks may be aliased as needed necessary. Thus any locations references in the main scene graph file may be aliased to concrete local files or to files across the network this may include aliasing locations references in other files visited during a traversal . Any blocks that may need to be replaced may also be aliased e.g. all instances of a plastic tile material may be replaced with a ceramic tile material e.g. if now plastic tile material is available . Step may also include the addition modification of any blocks in order to change the scene graph.

Steps and illustrate what happens during a traversal e.g. once the traverse has been called on a block . As described above each block has is associated with a particular type. At step when a block is visited the callback function associated with its type is called with the block and the current traverser.

At step the callback function reads any parameters necessary and follows the links through the traverser object. Thus in the scene graph as one object may point to another object each link is followed and the appropriate callback function is called depending on the block type at each node. As described above the traverser may carry contextual state that can be passed down through traversal e.g. a transformation matrix .

The processing traversal begins with the main scene graph file at the top group node and follows the appropriate arrows. If one follows the steeldoor identifier the traversal proceeds to the geometry node . A link i.e. BOBSMETALS STEEL is traversed to the location of the material i.e. the material node which is in the BOBSMETALS file . The material has a few bitmaps and a specular bitmap and a bump bitmap . The specular bitmap links to the JPG file i.e. FLECKS.JPG that is located within the BOBSMETALS file . The bump bitmap links to the PNG file located in the protein library . Returning back to the main file the mesh links to a binary set of data i.e. DOORMESH.BIN that lives in the same main file .

During the scene traversal the compute rendering system node will pull all of the assets needed for rendering. To pull all of the assets there is no need to use the hash database as the URLs locations of the files were stored in the appropriate files e.g. MAIN BOBSMETALS and PROTEINLIBRARY when the files were written exported saved. In this regard only during the writing time does the hash database need to be accessed. If desired for example if assets might be updated the hash can be stored in the package of assets instead and the URL can be retrieved from the database server at traversal time. In this regard an asset may be referred to by the package either by URL or by hash. If referred to by the URL no access to the database is required during traversal. However if referred to by hash the asset may be modified over time but requires access to a database to determine the location of the asset.

In addition to the above a rendering of a scene may also trigger the scene to be exported saved. Accordingly when a user desires to render a scene e.g. by selecting a render option button an additional export of the scene may occur. Some of the scene assets may not be stored in the cloud while other scene assets may merely be references to data already stored in the cloud. When a scene is rendered export the file is built and sent off to the cloud for a rendering e.g. a renderer rendering farm may be executed on a different machine group of machines than the machine that is performing the scene graph traversal. The user may be unaware where which machine is performing the rendering. Instead the user may simply receive an image back. Further the user likely has no awareness knowledge that the hashing or a database look up is being performed.

As another example suppose a user exports saves Scene A that is a park with a chair in it. All assets in the park may live in the cloud. If another scene is rendered that contains the same chair when the scene is exported the system checks the database for the location of the chair. Thereafter during scene graph traversal the data for the chair is downloaded from cloud storage.

More specifically when Scene A is exported a database s consulted about every asset in the scene ground chair etc. . The system determines that the chair is not in the database and stores Scene A s file at location A in the cloud. The system further informs stores information in the database indicating that the chair can be found in file A in the cloud.

When Scene B e.g. that contains an interior that also has the chair is stored exported the hash for the chair is computed and the database is queried to determine the chair location. The query indicates that the chair is in File A in cloud storage. Accordingly in File B only a link to the chair is stored and not the asset itself .

When traversing Scene B the chair will be downloaded from File A and Location A based on the link URL stored in File B.

This concludes the description of the preferred embodiment of the invention. The following describes some alternative embodiments for accomplishing the present invention. For example any type of computer such as a mainframe minicomputer or personal computer or computer configuration such as a timesharing mainframe local area network or standalone personal computer could be used with the present invention.

In summary embodiments of the invention provide a scene graph format system that is fast to write small and fast to read. Further such a system may be intended for write once or few and a read many model. The system helps to reduce duplication of data and makes it possible to store frequently used data near a compute node computer.

More specifically embodiments of the invention provide a distributed file format that solves problems at several levels. First assets placed into a file are de duplicated to reduce data size on a per package basis e.g. by utilizing a hash to determine if an asset is a duplication of another asset .

Second assets in other files in this format can be referenced from any scene graph defined by other files in the same format. Thereafter at scene graph traversal time assets from multiple files can be utilized to define the scene. This can save bandwidth in two ways a the format can be designed to seek to and fetch only the portions of files necessary and b commonly used assets can be combined into files that are maintained with better locality to the compute nodes.

Third assets present in the file format are associated with a unique hash. This allows a larger system to agglomerate commonly used assets into asset libraries and allows new files of this format to be built with references into theses asset libraries thereby reducing bandwidth and storage requirements.

Fourth assets in the scene graph defined in a file of this format are referenced by package name and asset name. Such a package need not be embedded at a physical location but can be something that is set at a later time. This enables for example the replacement of an entire set of standard materials by changing the physical file location for a given package name. Additionally allowing naming overrides for asset names provides the ability to easily change the scene graph structure.

The foregoing description of the preferred embodiment of the invention has been presented for the purposes of illustration and description. It is not intended to be exhaustive or to limit the invention to the precise form disclosed. Many modifications and variations are possible in light of the above teaching. It is intended that the scope of the invention be limited not by this detailed description but rather by the claims appended hereto.

