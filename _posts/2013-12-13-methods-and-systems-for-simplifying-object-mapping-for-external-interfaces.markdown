---

title: Methods and systems for simplifying object mapping for external interfaces
abstract: Methods and systems for simplifying object mapping for external interfaces. At least two client requests for action may be received from an external interface wherein each client request may be evaluated sequentially or concurrently in a governed and non-blocking technique. Each client request may be associated to a logical object in order to minimize a representational gap between the client request and a physical object using the logical object. Each query request may be responded to using the object relational mapping in order to simplify the external interface by minimizing the representational gap between the external interface and the physical object using the logical object.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08983984&OS=08983984&RS=08983984
owner: Catavolt, Inc.
number: 08983984
owner_city: Alpharetta
owner_country: US
publication_date: 20131213
---
This application is related to and claims the benefit of U.S. Provisional Application 61 736 882 filed Dec. 13 2012. This application is also a continuation in part of U.S. patent application Ser. No. 13 830 667 filed Mar. 14 2013 which is a continuation of U.S. patent application Ser. No. 12 829 680 filed Jul. 2 2010 now U.S. Pat. No. 8 423 561 Issued Apr. 16 2013 which in turn claims the benefit of U.S. Provisional Application No. 61 222 557 filed Jul. 2 2009. All of the foregoing are incorporated by reference in their entireties.

Contemporary web service approaches may be based on request response protocols that send and receive documents for example third party scripts. Third party scripts may commit security and or resource violations. Systems and methods described herein may enable the safe execution of programs such as third party scripts. Systems and methods described herein may provide rich interactions based on entity schemas. A lightweight scripting system may allow entity interactions to be composed remotely and then distributed across participating back ends. Each participating back end may implement the scripting system. Original architecture and design may be provided so that a systems programmer can create a compatible scripting system in any application programming language.

The lightweight scripting system may be conversational so that requesters may be able to preserve session state between calls to the scripting engine. The lightweight scripting system may be composable so that it may support programming in the small abstractions that allow for sub procedures looping and building of expressions from other expressions. The lightweight scripting system may be multi tenant friendly so that it may be fair to Software as a Service SaaS environments that house multiple tenants. A tenant may not be able to prevent another tenant from its fair share of resources. The lightweight scripting system may be highly scalable so that it may be sealable to new heights compared to typical enterprise architectures e.g. 100 000 s of concurrent users per process instead of the typical 1 000s of users . The lightweight scripting system may be very low risk so that it may help ensure the basic tenets of security which are confidentiality integrity and availability.

The systems and methods described herein may comprise one or more computers. A computer may be any programmable machine capable of performing arithmetic and or logical operations. In some embodiments computers may comprise processors memories data storage devices and or other commonly known or novel circuits and or components. These components may be connected physically or through network or wireless links. Computers may also comprise software which may direct the operations of the aforementioned components. Computers may be referred to with terms that are commonly used by those of ordinary skill in the relevant arts such as servers PCs mobile devices communication devices and other terms. Computers may facilitate communications between users may provide databases may perform analysis and or transformation of data and or perform other functions it will be understood by those of ordinary skill that those terms used herein are interchangeable and any computer capable of performing the described functions may be used. For example though the terms database and server may appear in the following specification the disclosed embodiments may not necessarily be limited to databases and or servers.

Computers may be linked to one another via a network or networks. A network may be any plurality of completely or partially interconnected computers wherein some or all of the computers are able to communicate with one another. It will be understood by those of ordinary skill that connections between computers may be wired in some cases i.e. via Ethernet coaxial optical or other wired connection or may be wireless i.e. via Wi Fi WiMax cellular satellite or other wireless connection . Connections between computers may use any protocols including connection oriented protocols such as TCP or connectionless protocols such as UDP. Any connection through which at least two computers may exchange data may be the basis of a network.

The scripting systems and methods described herein may introduce an ADL as a lightweight scripting language and the ADL application as an execution environment for the language. Implementations discussions and examples presented herein may be based on the Scala programming language the Java Virtual Machine JVM the Akka model of actors and the libraries of the respective frameworks although ADL and the ADL application described herein may be used with other languages models libraries etc.

ADL may be a compact infinitely composable scripting language. ADL may be based on symbolic expressions s expressions which are the foundation of languages like Lisp and Scheme. The atoms lists and procedures of ADL may be as follows 

Data and programs may be specified equivalently as lists of words numbers or other lists separated by whitespace and surrounded by parentheses.

An abbreviated notation may be used to represent lists in s expressions so that x y z stands for x . y . z. nil 

The following convenience functions may determine whether an s expression is a list or an empty list respectively.

An association may be a pair where the first value may be an atom and the second value may be an atom or another s expr.

An association list or a list may be a data structure used frequently in ADL. An a list may be a list of pairs conses each pair may be an association. The head of a pair may be called the key and the tail may be called the datum.

A typed list or t list may be used to convert object instances between ADL and the JVM. The first element may be a capitalized symbol and the remaining elements may be one or more s expressions.

The elements of ADL may be immutable. Procedures may create new expressions from other expressions but all strings numbers symbols and lists may be immutable.

An s expression may be classically defined as an atom or an expression of the form x . y where x and v are s expressions. The second recursive part of the definition may represent an ordered pair so that s expressions are effectively binary trees. ADL may use an abbreviated notation like most modern s expression notations to represent lists in s expressions so that

The ADL application may be a non blocking design. The requester may submit an ADL expression e.g. an ADL script to be evaluated and an environment of procedures and variables and a continuation call for when the result is ready. This approach may allow processing to be suspended until sub processing is completed which may also be suspended until some external event is achieved.

In the evaluator module may receive data to be evaluated step of . The data may be a request comprising one or more s expressions. In the evaluator module may schedule an initial s expression from the data. In the evaluator module may determine whether there are presently any s expressions scheduled for execution by the scheduler module . If not in the process may complete with a final result step of and in the process may end.

Otherwise in the evaluator module may get the next s expression from the data. In the evaluator module may pass this s expression to the governor module . The governor module may check execution to prevent any individual session from abusing resources of the ADL application to ensure that security or resource violations do not occur. If the governor module detects a violation for example because execution would exceed specified security or resource constraints it may notify the evaluator module and in the evaluator module may complete processing of the s expression with a violation error return and the process may exit . If there is no error in the evaluator module may determine whether there are any more s expressions to evaluate. If so in the evaluator module may get the next s expression from the scheduler module . If not in the process may complete with a final result step of and in the process may end.

If the governor module does not detect a violation in the evaluator module may analyze the s expression to determine whether it can be calculated locally by the ADL application in the session environment . If it can in the evaluator module may complete processing of the s expression with a request for execution by the session environment which may then process the s expression. In the evaluator module may determine whether there are any more s expressions to evaluate. If so in the evaluator module may get the next s expression from the scheduler module . If not in the process may complete with a final result step of and in the process may end.

If the s expression will not be processed in the session environment in the evaluator module may analyze the s expression to determine whether it can be calculated externally after a dialog request. If so in the evaluator module may complete processing of the s expression with a call to a dialog system step of . In the evaluator module may determine whether there are any more s expressions to evaluate. If so in the evaluator module may get the next s expression from the scheduler module . If not in the process may complete with a final result step of and in the process may end.

It the s expression will not be processed by the dialog system in the evaluator module may analyze the s expression to determine whether it is a primitive request that can be executed by the evaluator module itself. If so in the evaluator module may complete processing of the s expression and return a primitive result. In the evaluator module may determine whether there are any more s expressions to evaluate. If so in the evaluator module may get the next s expression from the scheduler module . If not in the process may complete with a final result step of and in the process may end.

If the s expression will not be processed by the evaluator module in the evaluator module may analyze the s expression to determine whether it is a complex request that should be executed by external resources. If so in the evaluator module may pass the contents of the s expression to the scheduler module for scheduling. In the evaluator module may determine whether there are any more s expressions to evaluate. If so in the evaluator module may get the next s expression from the scheduler module . If not in the process may complete with a final result step of and in the process may end.

The process may thus allow multiple client requests to be performed using the ADL application before a result is returned. The following example script may be executed according to this process .

The following example is a simple read of name phoneNumber and emailAddress from the entity identified as com.catavolt.mk.test.case002.domain.Customer. The data to be read enters the ADL application at step of and a result is provided at step in . The example illustrates a number of features the script is conversational and resumes an existing session based on a cryptographic hash of a session key a procedure is composed using begin of three other procedures createEditorModel openEditorModel and readEditorModel session state is conditionally defined and maintained using the procedures if not defined and define a request number field rqsNr is computed each time the script is run and finally the script ends with a list literal that contains the request number and the read result. The last expression of a script determines the result so the list literal of the example is returned to the caller through a continuation every time the script is evaluated.

The ADL application may be implemented as an actor in Scala using the Akka framework. The design may take advantage of the built in and highly scalable Akka runtime for asynchronous processing. The following code snippet is an example Machine class illustrating method signatures which may be involved in a non blocking evaluator module .

The runEval method may be the entry point to the recursive evaluation process. It may receive an expression environment and continuation that correspond to the main entry point step of . The implementation may set up a continuation object that may be used to complete the process with either a success or a failure.

The eval method may be the main program loop i.e. of and may run repeatedly until all expressions and sub expressions are evaluated or until an exception halts the process. The eval method may reveal the simplistic power of s expressions and the ADL language. The entire language may be built upon types of String Decimal Boolean Sym and List.

The evalProc method may be used to invoke procedures which may be the only higher level expression supported all other expressions may be atoms. The system of evaluation may be applicative order. The first element of the list may evaluate to a procedure defined by the language. The remaining list elements the tail may be evaluated and may all be defined after evaluation. The procedure associated with the first element may then be applied to the arguments from the remaining list elements.

The evalArgs method may be used to evaluate arguments before they are applied within the evalProc method described above. Each argument may be evaluated individually and asynchronously if it involves a sub expression. Finally when all arguments are known the continuation may be called to apply the procedure to these arguments.

The scheduler module in the Machine class described above may be built on the Akka framework. The scheduling details that determine when a procedure will run and on what thread the procedure will run may be determined by the Akka runtime. In order to use the Akka scheduling the ADL application may implement the receive method to handle the asynchronous processing.

Expressions may be submitted for scheduling through an actor send method. The eval method shown above may use the self CallProc list pEnv pCont statement to schedule an asynchronous evaluation of a sub expression.

The ADL application may be activated by the scheduler module by invoking its receive method. One embodiment of a basic receive method is shown below. The two messages which may be essential to the operation of the ADL application are Eval and CallProc.

The governor module may contain the necessary protocol to ensure that maximum allowances are not exceeded for at least the following metrics elapsed running time call depth number of calls number of object references and size allocations.

Procedure calls may be checked with the governor module at the entry points and exit points using enterProc and exitProc as shown above in the sample code for evalProc . The governor module may use these calls to track the elapsed running time number of calls and call depth. The enterProc and exitProc procedures may make calls to incRef and decRef so that object references and size allocations may be tracked as arguments move in and out of scope with expressions. The concur procedure as defined above may dispatch work concurrently. In this ease the call depth tracking may suffice for call width tracking as well.

The methods incRef and decRef may be called any time an object is held or released respectively through a reference. This may allow the governor module to track the number of object references and size allocations. There may be at least three scenarios where reference counting need to occur when arguments are passed to a sub expression when a cons procedure creates a pair and when a value is held by the Env object.

The only output available to ADL scripts may be a simple print in procedure for system logging and debugging. This procedure may route its output through the governor module to ensure that the maximum log output for a session is not exceeded. The printStatus method may be an internal method used for debugging and may not be available to ADL scripts during execution.

The simplicity of s expressions and the recursive nature of evaluating expressions may make it easier to reason about reference counting. is a general definition of s expressions according to an embodiment of the invention. This definition may indicate that all expressions other than atoms may be evaluated recursively. This one point may be used to reason about governance in terms of expressions. For example the elements of expressions may be atoms and expressions. The elements of expressions may be immutable. Elements may be referenced in nested expressions so elements passed to nested expressions may be actively counted and uncounted as they move in and out of scope. The cons operator may create a reference to the tail element that may need to be counted. A head element that is no longer referenced may need to uncount its tail reference. Elements bound to the Env object may have acquired a new reference and may need to be counted. Likewise an element unbound from the Env object may have lost a reference and may need to be uncounted. An element that is no longer referenced may be eligible to have its memory reclaimed. In the reference implementation and implementations based on the JVM that may mean the object is left for garbage collection. An expression that is evaluated and not used may leave an element that is not referenced. The element may be eligible to have its memory reclaimed.

According to the reasoning based on the definition some interesting scenarios may be realized. For example a variable n may be changed. The previous value stored at n may be unbound from the Env object and may be uncounted. The new value at n may be bound and counted. See element a of for an example.

In another example a complex expression may be evaluated. The begin procedure may cause an expression to be bound to the Env object under the factorial symbol. The nested expressions under define may be counted and may remain as active references because they were bound transitively through the Env object. The actual call factorial may not be used therefore its result may no longer be referenced and may be eligible to have its memory reclaimed. See element b of for an example.

In another example a computation may be made. During computation the operator and integer objects may have been active and referenced. At completion however the final result and all intermediate results may no longer be referenced and may be eligible to have their memory reclaimed. See element c of for an example.

The ADL application may be implemented in process if the application server has a structured web services API or it can be implemented out of process as a services broker.

In either scenario conversational applications may be supported through the notion of a session. Each session may have its own ADL environment that may preserve state between process to process invocations. An invocation may look up the session environment and then may pass it through on the eval expr env cont call shown in . All processing within an ADL application may be isolated to its environment therefore the session may be isolated to its session environment . When the result is ready the continuation callback may be invoked to complete processing.

While various embodiments have been described above it should be understood that they have been presented by way of example and not limitation. It will be apparent to persons skilled in the relevant art s that various changes in form and detail may be made therein without departing from the spirit and scope. In fact after reading the above description it will be apparent to one skilled in the relevant art s how to implement alternative embodiments. Thus the present embodiments should not be limited by any of the above described embodiments.

In addition it should be understood that any figures which highlight the functionality and advantages are presented for example purposes only. The disclosed methodology and system are each sufficiently flexible and configurable such that they may be utilized in ways other than that shown.

Further the purpose of any Abstract of the Disclosure is to enable the U.S. Patent and Trademark Office and the public generally and especially the scientists engineers and practitioners in the art who are not familiar with patent or legal terms or phraseology to determine quickly from a cursory inspection the nature and essence of the technical disclosure of the application. An Abstract of the Disclosure is not intended to be limiting as to the scope of the present invention in any way.

Although the term at least one may often be used in the specification claims and drawings the terms a an the said etc. also signify at least one or the at least one in the specification claims and drawings.

Additionally the terms including comprising or similar terms in the specification claims and drawings should be interpreted as meaning including but not limited to. 

Finally it is the applicant s intent that only claims that include the express language means for or step for be interpreted under 35 U.S.C. 212 paragraph 6. Claims that do not expressly include the phrase means for or step for are not to be interpreted under 35 U.S.C. 212 paragraph 6.

