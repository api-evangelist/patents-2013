---

title: Application programming interface for providing native and non-native display utility
abstract: Methods for controlling complementary dual displays for use with an electronic device are presented including: receiving an input for display on a non-native display, where the input includes a native user interface (UI) input and a non-native UI input, and where the non-native display is a bistable, low frame rate display; if the input is the native UI input, sending the first native UI input to a corresponding application, processing the native UI input by the corresponding application, calling a non-native API for forwarding the processed native UI input to a non-native display driver, and sending a non-native display signal to the non-native display; receiving another native UI input for display on a native display, where the native display is a refresh-based, high frame rate display; and sending the other native UI input to the corresponding application.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08566848&OS=08566848&RS=08566848
owner: Quickbiz Holdings Limited
number: 08566848
owner_city: Apia
owner_country: WS
publication_date: 20130115
---
This application is a continuation of U.S. patent application Ser. No. 13 073 846 filed on Mar. 28 2011 which is a continuation of U.S. patent application Ser. No. 12 033 608 filed on Feb. 19 2008 which claims the benefit of U.S. Provisional Application No. 60 997 255 filed on Oct. 1 2007 each of which is hereby incorporated by reference in its entirety.

LCD based electronic devices such as Ultra Mobile PC UMPC laptops PCs personal digital assistants PDAs cellular phones portable digital media players and the like are becoming ubiquitous in modern technological societies. These devices offer specialized functionality in form factors small enough to carry in a pocket or some other small carrying bag. At least one reason why these types of devices are so popular is because display technology which provides a convenient user interface has advanced to a point where relatively small form factors are efficient and inexpensive. Indeed even the most inexpensive portable electronic devices now include high frame rate color displays. However conventional displays are not without some disadvantages.

Typically a PDA may include a refresh based high frequency REHF display for displaying user selected information. One example of an REHF display is a liquid crystal display LCD . LCDs have many desirable characteristics including high frame rates which provide for a satisfying visual experience when rapidly switching between screens or when scrolling across a screen. However typical displays having high screen refresh rates may suffer from poor readability because backlights which are required in those displays may be adversely affected by ambient lighting conditions. Eye strain is commonly reported by users and has been documented in some medical literature. Users of UMPCs or PDAs are familiar with the poor readability of LCDs under bright light or direct sunlight. In some examples shading the screen or moving to a darker environment may be necessary to read an LCD. In other examples LCD cannot offer high quality image such as EPD which has close to 300 dpi today.

In order to overcome the shortcomings of an LCD bistable low frequency BILF displays may be utilized instead of an LCD. One example of a BILF display is an electronic paper display EPD . EPDs utilize a material called electronic ink and are commercially available under the trade name E INK . EPDs are ideally suited for flexible display applications due to their thin form factor and inherent flexibility. EPDs provide an image stable reflective display technology that uses ultra low power but is easily read under any lighting condition including direct sunlight. In addition EPDs provide a bistable display and unlike LCDs an image on an EPD looks the same from all viewing angles. Further EPDs will not distort when touched or flexed making EPDs the ideal display medium for flexible displays and portable devices. EPDs however cannot in many examples completely replace LCDs. At least one reason is because EPDs typically have a low frame rate. As noted above conventional LCDs are typically configured with high frame rates which may serve to enhance a user s viewing experience especially when rapidly scrolling through multiple displays. In addition using a mouse requires high frame rates so that the mouse pointer appears to have smooth movement across a screen. Furthermore a majority of reading content is currently created for viewing with an REHF display application such as an LCD application while few applications are written for BILF displays such as an EPD. This trend is likely to continue. It may therefore be advantageous to easily display the output of existing REHF display applications on BILF displays such as an EPD.

Unfortunately Conventional operating system windows managers are typically configure to manage only multiple LCD task windows across multiple LCD displays. Thus conventional solutions for REHF based LCD applications on conventional platforms can not generally benefit from the use of multiple BILF and REHF displays. As such application programming interfaces for providing native and non native display utility are presented herein. Background Information

The present invention will now be described in detail with reference to a few embodiments thereof as illustrated in the accompanying drawings. In the following description numerous specific details are set forth in order to provide a thorough understanding of the present invention. It will be apparent however to one skilled in the art that the present invention may be practiced without some or all of these specific details. In other instances well known process steps and or structures have not been described in detail in order to not unnecessarily obscure the present invention.

Various embodiments are described herein below including methods and techniques. It should be kept in mind that the invention might also cover articles of manufacture that includes a computer readable medium on which computer readable instructions for carrying out embodiments of the inventive technique are stored. The computer readable medium may include for example semiconductor magnetic opto magnetic optical or other forms of computer readable medium for storing computer readable code. Further the invention may also cover apparatuses for practicing embodiments of the invention. Such apparatus may include circuits dedicated and or programmable to carry out tasks pertaining to embodiments of the invention. Examples of such apparatus include a general purpose computer and or a dedicated computing device when appropriately programmed and may include a combination of a computer computing device and dedicated programmable circuits adapted for the various tasks pertaining to embodiments of the invention.

Operating system framework processes data communications and communicates the results of the processing to native display driver which may drive any number of native displays. In some embodiments a native display driver may include a WINDOWS driver a WINDOWS CE driver a WINDOWS mobile driver an APPLE iphone driver An APPLE OS X driver a Linux driver a UNIX driver and a UNIX derivative driver. Operating system framework may be configured to provide any number of system resources without departing from the present invention. In some embodiments a framework may include a WINDOWS framework a WINDOWS CE framework a WINDOWS mobile framework an APPLE iphone framework An APPLE OS X framework a Linux framework a UNIX framework and a UNIX derivative framework. Native display driver may then send a native display signal to native display. A resulting graphical user interface may then be displayed on native display. In some embodiments a native display may be a refresh based high frequency REHF display such as an LCD display a CRT display and LED display a PLED display an OLED display and a plasma display.

Heterogeneous display hardware design can deliver many new classes of non native i.e. EPD usage models including 1 the capability to extend or migrate an native display based applications to a non native display for better reading experience where a user may also browse the pages on a non native display without changing the application and 2 the ability to create dual display aware applications that can take advantages of the unique benefits of both native and non native displays at the same time. As illustrated here non native API may be configured to be responsive to programmatic instructions between application and operating system framework . In turn operating system framework processes programmatic instructions and communicates the results of the instructions to non native display driver which may drive any number of non native displays by sending a non native display signal. In some embodiments non native display driver may also be configured as part of a non native display sub system that contains a non native windows management system along with a non native UI input system in addition to the non native display driver. In some embodiments a non native display may be a bistable low frequency BILF display such as an electronic paper display EPD . In addition non native user interface may be utilized to provide navigation control corresponding with applications being displayed on non native display.

As may be appreciated BILF displays may not be particularly well suited to navigation through a graphical user interface GUI . One reason for this is because the refresh rate may be too slow to provide an efficient and effective user experience. However continually transferring GUIs between a BILF and REHF to accomplish all navigation tasks may also detract from a user experience. Thus at least some navigation capabilities may be desirable. Non native user interface may include non native user interface driver which may communicate with application via non native API through a communication mechanism such as a command an API call a callback function call a pipe a signal a message a shared memory a semaphore a mutex a critical section an event a socket a clipboard a message a message queue or any other communication mechanism known in the art without departing from the present invention. Thus when application initiates contact with non native driver via non native API a communication mechanism is configured for non native driver and application . Once a communication mechanism is configured non native driver and application may communicate with one another. For the purpose of description API call and callback is used to explain the communication mechanism between the application and non native driver.

At a next step a corresponding application processes the native UI input. The corresponding application may process the native UI input in any manner known in the art without departing from the present invention. Returning to a step if the method determines at a step that a UI input is a non native UI input the method proceeds to a step to send the non native UI input to a non native UI driver. Typically the non native UI input is handled by the OS. In some embodiments a non native UI input may be utilized to provide some navigation capability of a corresponding application. For example a button or toggle switch may be located on a non native display to provide user input. As may be appreciated bistable displays as contemplated herein are not generally suitable for dynamic GUI input. At least one reason for this characteristic is because refresh rates are typically low i.e. 1 to 15 frames per second fps . Thus unacceptable latency when utilizing a GUI may be introduced and may not provide a satisfactory user experience. Non native UI inputs may be utilized to overcome this deficiency. At a next step a corresponding application is invoked by a callback function. Typically a callback function is handled by the OS. As noted above a callback is executable code that is passed as an argument to other code or application. Callback allows a lower level software layer to call a subroutine or function defined in a higher level layer. At a next step a corresponding application executes a callback function.

At a next step the method calls a non native API embodiment. An API is defined at source code level and provides a level of abstraction between the application and the kernel or other privileged utilities to ensure the portability of the code. A non native API in accordance with embodiments described herein may be utilized to provide application compatibility with non native displays. In some embodiments a non native display may include a bistable low frame rate display. In some embodiments non native displays may include an electronic paper display EPD . In some embodiments an EPD may be configured to refresh at a rate up to approximately 15 fps. At a next step the method forwards the result of the processing of the non native input to a non native display driver. In embodiments the result may be data a data pointer or a command. At a next step a non native signal is sent to a non native display in accordance with all non native display requirements whereupon the non native signal is displayed on a non native display at a step . The method then ends.

It may be appreciated that any number of corresponding applications may be utilized with embodiments described herein. In some embodiments inputs may be received from one or more applications. Furthermore embodiments provided herein may be utilized for enabling complementary dual display utility. For example a non native display and a native display may be utilized in concert without restriction. In some embodiments a native display is a refreshed based high frame rate display. In some embodiments native displays may include an LCD display a CRT display and LED display a PLED display an OLED display and a plasma display. In some embodiments a native display may be configured to refresh at a rate of approximately 15 to 120 fps. Some embodiments disclosed native displays are intended to function simultaneously with non native displays without limitation. Native UI inputs may be handled conventionally by a native API to function in concert with non native UI inputs.

The following is a list of non native API functions for providing dual display capability for embodiments described herein. The list is not intended to be exhaustive or self limiting in any fashion. Additionally the nomenclature utilized for the functions described is arbitrary and not intended to be limiting in any fashion. Functionality for each term is also included but the manner in which that functionality is accomplished is not limited in any manner in embodiments described herein.

Initialize This function operates to initialize a non native display driver. A non native display driver includes window management capability.

GetDisplayConfig This function operates to GET a current system s complementary display configuration parameters including number of complementary display parameters resolution parameters screen size DPI parameters greyscale color parameters and bit depth parameters.

AllocateEPDWindow This function operates to allocate the following a non native display window from a non native display driver a display number a non native window size fullscreen a support unsupport dynamic non native window size change a support unsupport content synchronization with other applications a minimal non native window size a non native window name and a use auto update or a use manual update.

ChangeWindow This function operates to change a window size or move a window to another display i.e. between native and non native displays or any combination thereof .

SetSyncContent This function operates to synchronize content from different application windows on a non native display.

UpdateWindow This function operates to call a non native display driver to update a non native display window.

PrintScreen This function operates to print a screen displayed on a native display to a non native display.

In addition to the above API functions a non native API may include callbacks. As noted above a callback is executable code that is passed as an argument to other code or application. Callback allows a lower level software layer to call a subroutine or function defined in a higher level layer. As above the following is a list of non native API callbacks for providing dual display capability for embodiments described herein. The list is not intended to be exhaustive or self limiting in any fashion. Additionally the nomenclature utilized for the functions described is arbitrary and not intended to be limiting in any fashion. Functionality for each term is also included but the manner in which that functionality is accomplished is not limited in any manner in embodiments described herein.

OnEPDKeyDown This callback operates to handle non native UI key events. In some embodiments key events include Page Up Page Down Switch Window Size Up Size Down Full screen Partial screen.

OnEPDWindowChange This function operates to handle window allocation on non native displays. For example an application may allocate a new window on a non native display when a user engages a Full Partial screen key thus changing the non native display window.

OnEPDSyncChange This function operates to handle window updates. For example if an application s window supports content synchronization then the application may need to update window content after a synchronization event occurs.

OnEPDOrientChange This function operates to update a non native window when a non native display changes orientation.

A number of use examples are provided for further understanding and clarifying of embodiments of the present invention and are not intended to be limiting in any manner. is an illustrative flowchart of a use case for utilizing multiple applications with a non native display in accordance with embodiments of the present invention. In particular program A operates to display a window on a non native display whereupon program B adds a new window on the non native display. At a first step program A connects with a non native display driver and calls function Initialize to initialize the non native display driver. At a next step program A calls GetDisplayConfig to gather all current non native display configurations. Window allocation is handled at a next step by calling AllocateEPDWindow . In this example dynamic change for the window is supported. At a next step a window update may be made when program A calls UpdateWindow At this point in time a user may wish to utilize a non native UI by pressing an event key such as a page down key at a step . The user input driver triggers OnEPDKeyDown which is a callback function. Once this event is processed UpdateWindow is called at a step to refresh the non native display window.

A second program program B may then connect with the non native display driver and call function Initialize to initialize the non native display driver at a step . At a next step program B calls GetDisplayConfig to gather all current non native display configurations. Window allocation is handled at a next step by calling AllocateEPDWindow . In this example program B requests a partial window. At this point program B s window request triggers OnEPDWindowChange which is a callback function. This allows program A s window to change. Thus at a next step program A calls UpdateWindow to refresh its non native display window. Subsequently at a next step program B calls UpdateWindow to refresh its non native display window. The method then ends. In this manner illustrates one example of how two programs e.g. Program A and B may share a non native display screen having two separate windows through the use of the non native APIs and Callbacks described.

B however detailed steps are not repeated here. The method then ends. In this manner any number of applications may print a screen from a native display to a non native display.

Furthermore a program may toggle a window of the program or a frame of a window of the program from a native display to a non native display. A frame in the case of a HTML browser program allows an author to divide a browser window into multiple rectangular regions. Multiple documents may be displayed in a single window each within its own frame. Graphical browsers allow these frames to be scrolled independently of each other and links may update a document displayed in one frame without affecting the others. Therefore a frame is like a rectangular region inside a window for a browser program or any other program. The following two examples illustrate toggle window and toggle frame .

Application A originally utilizes multiple windows on one or more native displays. In order to utilize a non native display application A changes its implement of creating and updating one of the windows previously displayed on a native display. Application A connects with a non native display driver acquires a new non native display window by a call such as AllocateEPDWindows draws the original window s content to the new non native window and then calls UpdateWindow to update the non native window s content to the non native display. All remaining original windows may still be displayed on native display and may receive user input. This method of migrating an application is referred to as toggle window. The method described here is typically used by a dual display aware program that is written to access both the native and non native displays at the same time.

Application B originally utilizes multiple frames regions inside a window in a window on a native display. In this example one frame may contain an independently scrollable text content that can be easily displayed on a single display thus requiring scrolling or some other method such as Page Down button for access. In order to utilize a non native display application B connects with a non native display driver acquires a new non native display window by calling AllocateEPDWindows draws its frame s content to a non native window and calls UpdateWindow to update non native window content to a non native display. A non native pagedown input command may be invoked by a non native UI and sent to application B through a non native API. Application B then processes the non native pagedown input command updates its non native window content. Application B s frame content may continue to show or hide on native display. That is the application may continue to receive user input. This method of migrating applications is referred to as toggle frame. 

The above toggle window and toggle frame examples describe applications that are dual display aware when they are written. For legacy LCD only applications that have not been migrated to non native displays a method for migrating applications referred to as toggle screen may be useful to provide non native display without a need for utilizing any additional programmatic code above the OS framework. is an illustrative flowchart of a use case for utilizing an application with native and non native displays in accordance with embodiments of the present invention. In particular this example demonstrates the use of toggle screen in embodiments provided. will be discussed in connection with which is an illustrative representation of a native and non native display subsystem for utilizing a native display and a non native display in accordance with embodiments of the present invention. In particular illustrates one extension of . As illustrated applications may be running on a conventional operating system framework . Applications may be in cooperative communication with native API . Applications may not be aware of the existence of non native display or of non native display driver . As illustrated native display driver may handle communication with non native display driver .

As noted above non native displays may not be well suited for navigating an application due to latency issues. Toggling allows a user to easily migrate an application between a non native display and a native display so that navigation may proceed on the most appropriate platform. Returning to at a first step program A i.e. applications is started on a native display such as native display . In embodiments programs may display content on a native display utilizing any graphical user interface such as a window or frame without limitation. To toggle ToggleScreen may be triggered at a step . To toggle a native display driver may send display data and command data generated by applications program A to non native display driver . Non native display driver may operate to first extend applications program A native display window to a non native display window resolution and then display the non native display window on non native display . In embodiments programs may display content on a non native display utilizing any graphical user interface such as a window or frame without limitation. Returning to at a next step any number of non native display operations may occur such as scroll page down page up etc. When a user desires to migrate applications program A back to a native display the method triggers ToggleScreen at a step . The method then ends. Native display driver stops sending display data and command data to non native display driver and continues to draw content on native display .

It may be noted that printing an application to a non native display as described for is different than toggling an application to a non native display as described for . In printing a window is displayed on a non native display but functionality of the application remains with a native display. This may be useful in situations where a user desired to keep a high resolution screen shot of a reading program while continuing to navigate the application. Toggling on the other hand migrates the application to the non native display. Thus if additional navigation is needed other than what is provided by non native UI inputs the application must be migrated back to a native display.

It may be appreciated that additional features may be incorporated into use models described herein. Any combination of these features may be utilized without departing from the present invention.

In embodiments in order to conserve battery power while utilizing a non native display a user may use an additional UI which may in some embodiments be a non native UI to turn the native display on and off. Turning a native display off during non native display use may reduce power consumption due to the backlight of a native display. When the native display is turned off the system may be further configured to enter a standby power saving mode much like a phone device. In standby mode a system would typically wake up in order to update the non native display when content has been changed e.g. by a page change when reading a book . When a user turns the native display on the systems may be configured to enter dual display mode operation again.

In embodiments to facilitate public viewing of native and non native display content through a projector a user may use an additional UI to select whether to project content from either native or non native displays to a video out port of the device. Traditionally video output was limited to native display content.

In embodiments a system utilizing a non native display windows manger with a non native display driver as described herein may support multiple windows of the same program or different programs on one or more non native display screens. An additional UI may provide functionality which allows a user to select an active window from a list of non native display windows working under the operating system and display the updated content on the non native display. Furthermore the additional UI may provide functionality which allows a user to change the size of window from a partial screen size to a full screen size and vice versa . Thus resizing functionality may be provided. These features may be beneficial for users viewing content across multiple windows on a non native display without requiring them to turn on the native display to navigate content.

While this invention has been described in terms of several embodiments there are alterations permutations and equivalents which fall within the scope of this invention. It should also be noted that there are many alternative ways of implementing the methods and apparatuses of the present invention. Furthermore unless explicitly stated any method embodiments described herein are not constrained to a particular order or sequence. Further the Abstract is provided herein for convenience and should not be employed to construe or limit the overall invention which is expressed in the claims. It is therefore intended that the following appended claims be interpreted as including all such alterations permutations and equivalents as fall within the true spirit and scope of the present invention.

