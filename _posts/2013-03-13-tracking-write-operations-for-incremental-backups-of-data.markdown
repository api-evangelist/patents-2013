---

title: Tracking write operations for incremental backups of data
abstract: Approaches are described for tracking write operations in an operating system environment which can be used to perform incremental backups of data. In particular, the approaches described herein enable a driver to begin tracking write operations being performed on a volume device (or snapshot of a volume) without having to reboot the system and without causing interruption to operations being performed on the volume. The tracking is enabled by applying a patch to a driver provided by the operating system to replace an original write handler of the driver with an alternate write handler. This alternate handler is used to track the sequence of write operations performed on a snapshot of the volume device. An active bitmap is maintained for recording changed blocks resulting from the write operations. Tins active bitmap can subsequently be used to perform an incremental backup of the volume device based on the snapshot.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09195670&OS=09195670&RS=09195670
owner: EMC Corporation
number: 09195670
owner_city: Hopkinton
owner_country: US
publication_date: 20130313
---
The various embodiments described herein relate generally to backing up and or copying data on computing devices and in particular to tracking writes and other operations within an operating system environment in order to perform incremental backups.

Conventionally computing devices include at least one operating system OS that manages hardware and provides various services for applications running on the computing device to allow these applications to access the hardware. Some applications are designed to perform backups by periodically copying data from a source drive or volume to a specified destination. These backup applications typically need to interact with the operating system of the device in order to perform the backups. Such interactions with the OS often require the backup application to register one or more drivers with the operating system.

In some cases the installation of the drivers requires a reboot of the system before they are able to perform their intended function correctly. However the processes involved in rebooting the system usually require a significant downtime of the device which can be undesirable especially for production servers that may be hosting mission critical applications and workloads.

In the following description various embodiments will be illustrated by way of example and not by way of limitation in the figures of the accompanying drawings. References to various embodiments in this disclosure are not necessarily to the same embodiment and such references mean at least one. While specific implementations and other details are discussed it is to be understood that this is done for illustrative purposes only. A person skilled in the relevant art will recognize that other components and configurations may be used without departing from the scope and spirit of the claimed subject matter.

Systems and methods in accordance with various embodiments described in this disclosure enable the tracking of write operations and other input output I O operations in an operating system environment which can be used to perform incremental backups of data. In particular the approaches described herein enable a driver to begin tracking write operations being performed on a volume device for snapshot of a volume without having to reboot the machine and without causing interruption to the various operations being performed on the volume.

In various embodiments the method includes accessing a driver of an operating system on a computer such as a driver that is responsible for creating snapshots of a volume device. A patch is applied to the driver to replace an original write handler of the driver with an alternate write handler. Similarly the patch replaces an original control handler with an alternate control handler. These alternate handlers are used to track the sequence of write operations performed on the snapshot of the volume device. The method also maintains an active bitmap that records the changed blocks resulting from the write operations. This active bitmap can subsequently be used to perform an incremental backup copy of the volume device based on the snapshot.

In certain operating systems such as Microsoft Windows based operating systems many types of resources are represented as devices. These devices may be physical devices or logical devices. For example a hard disk is an example of a physical device and this physical device may have several logical devices on it created by the system. A logical device created by the operating system on top of the physical device is often referred to as a volume . A volume may thus represent a partition of the physical disk drive.

When a backup application e.g. host based incremental backup application wishes to perform a backup of a particular volume the backup application first sends a request to a volume snapshot service VSS provided by the operating system requesting the VSS to produce a snapshot of the volume . This snapshot represents the state of the volume at a particular point in time e.g. the point in time at which the request was submitted . In response to receiving the request the VSS causes the snapshot to be created and provides the snapshot to the backup application which can in turn use the snapshot to perform a block level backup operation.

In various embodiments the backup application may need to perform incremental backups such as by periodically synchronizing any changes that were made to the volume since the last backup operation. In order to enable such incremental backups the backup application continuously tracks write operations and or other I O operations and maintains a changed block bitmap that records all of the write operations performed on the volume since the last backup. This bitmap may then be used to perform the subsequent backup.

In some embodiments such write tracking may be accomplished by registering an upper filter driver to the volume class device. For example the Windows operating system includes a framework which exposes a functional driver for each particular device e.g. volume . The functional driver is usually responsible for performing all of the input output I O operations that are received to the device among performing various other functions. Each device that the OS exposes may have a corresponding function driver. The operating system also gives the application developers e.g. driver writers the ability to extend those function drivers with their own custom logic. For example if a developer wants to intercept an I O operation directed to a volume device the developer can write a filter driver for that function driver and register that filter driver with the OS.

Once registered the filter driver e.g. write tracking driver can monitor write operations and maintain a bitmap of blocks that have changed since a particular point in time. However this approach of registering the filter driver would normally require the system to be rebooted for the filter driver to successfully attach to the volume device stacks that were already built prior to registering the filter. For example after registering the driver on a running machine if the system was not rebooted the OS would attach the filter driver only against those volumes that come up after it was registered successfully. This means that if there were three volumes C volume D volume and E volume on the system before registering the filter then there would be no instance of the filter driver on these three volumes. However any new volume that is brought up after the filter is registered would get an instance of the filter driver. This happens because all registered upper lower filter drivers are added to the stack at the time when the stack is built which usually happens at boot time.

One option in the above example would be to attach an instance of the filter driver on some of the volumes e.g. D volume and E volume after registering the filter and while the system is up and running by bringing the underlying disk for these volumes offline and then back online. The act of taking disks offline and then online would effectively amount to a rebuild of the device stacks for the corresponding volumes hosted on such disks i.e. D volume and E volume similarly to what occurs during system reboot. However the C volume in Windows is the machine s boot volume and it hosts the system pagefile. Generally the operating system will not allow the user to take offline a disk with a pagefile and thus the only way to rebuild the volume device stack for the system s boot volume may be to reboot the machine itself. Furthermore the process of taking disks offline and then back online is similar to rebooting the machine from an application s perspective. Hence the use of such an upper filter driver usually requires downtime of a production server which could be hosting mission critical applications and workloads.

In various embodiments in order to avoid having to reboot the system various embodiments described herein apply a patch to a driver involved in creating snapshots of the volume . The patch replaces the original handlers of the driver with a set of alternate handlers that can begin tracking write operations and maintaining a bitmap of blocks that have changed since a particular point in time. This can all be done while the system is running and without interruption to the various operations performed on the volume.

In accordance with various embodiments described herein in order to track write operations on a volume without rebooting the operating system a patch may be applied to a particular driver . This driver may be the filter driver responsible for creating volume snapshots e.g. driver volsnap.sys in Windows . The patch may be applied by invoking an application programming interface API to find the volume snapshot driver by name and replacing the entry points in the dispatch table. In particular the patch replaces the original write handler of the driver with an alternate write handler . In addition the original control handler of the volume snapshot driver may be replaced with an alternate control handler . Any I O flowing through the volume stack will then invoke one of these alternate handlers. The alternate handlers will be responsible for tracking write operations and other signals that will be used for incremental backups.

In one embodiment the patch may be applied by a change block tracking CBT driver that is dynamically loaded into memory when installing the backup application. Once the CBT driver is loaded and before replacing the original write handler of the driver the system can save the original write handier as a global variable . Similarly the original control handler may be saved as a global variable. Once replaced the alternate write handler tracks write operations flowing through the volume stack.

In one embodiment to track each write operation the alternate handler records the offset on the volume and the length of the write operation. The length and the offset constitute the changed block and this changed block may be recorded in a bitmap. More specifically in Windows based embodiments once the patch has been applied the CBT driver starts receiving write IRPs e.g. IRP MJ WRITE and control IRPs e.g. IRP MJ DEVICE CONTROL for all registered volumes on the system via the patched write handler e.g. IRP MJ WRITE and patched control handler IRP MJ DEVICE CONTROL . Once the write operation or other I O has been recorded the alternate write handler calls the original write handler that was saved under the global variables . Similarly the alternate control handler calls the original control handler saved in the global variables . This allows the system to function in the same manner as before applying the patch with the added functionality of tracking write operations.

While the alternate patched handlers are executing the CBT driver can maintain a global IRP entry count that is incremented decremented on entry exit respectively to the alternate write handler and alternate control handler . When changed block tracking is no longer needed and or needs to be stopped the patch can be replaced with the original handlers . Driver unload routines and or other control handlers e.g. the WT UNPATCH IOCTL handler can restore the original saved handlers atomically and wait for the global IRP entry count to drop to zero before returning from the unload routine. This can ensure that the CBT driver is not unloaded from memory while the alternate handlers are executing.

In at least some embodiments the driver that is selected to be patched with the alternate handlers is the volume snapshot service driver that is responsible for creating snapshots of volumes and for performing certain I O operations on those snapshots. This driver may be selected in order to ensure that the CBT driver is in the path to writes as they flow down the volume device stack and at the same time ensures that flush and hold writes are received. Flush and hold writes are required for switching the incremental bitmap. In Windows the flush and hold writes e.g. IOCTL VOLSNAP FLUSH AND HOLD WRITES do not go beyond the volume snapshot driver e.g. volsnap.sys . Furthermore snapshots are named device objects and are directly created by the volume snapshot driver e.g. volsnap.sys . By patching the write handler of this particular driver it can be ensured that the write operations happening on the snapshot device would be monitored.

In various embodiments once the dispatch table of volume snapshot driver is patched the CBT driver starts receiving write and device control IRPs for all devices created by volume snapshot driver e.g. volsnap.sys . Snapshots created by the volume snapshot driver are named device objects. Their names may be prefixed with a character string e.g. HardDiskShadowCopy . After the patch has been applied the driver marks each device object that it detects via either of its alternate write or control handlers in a simple linked list. Before adding a device object to the list it queries the operating system if the corresponding device object has a name. In the volume device stack the filter device objects created by volume snapshot driver are not named while their counterparts in the snapshot device stack are named as mentioned above. By invoking an API to query the name of the device object e.g. ObQueryNameString against the target device object and then matching the output buffer for the signature character string e.g. HardDiskShadowCopy the driver is able to detect if the device object is for a snapshot device. Once detected the driver marks it as a snapshot device and maintains a separate bitmap for tracking writes to it.

The processes for maintaining the bitmap will be described in further detail below with reference to and . In one embodiment only those snapshots which are created under the context of the backup applications are marked for tracking write operations.

The various write operations tracked by the alternate write handler may be the result of application writers attempting to alter the snapshot in order to make the snapshot data application consistent. The write operations may also include operations originating in the event of the backup application s writer deleting excluding files from the snapshot. The ability to delete files from the snapshot will be described in further detail below with reference to .

It should be noted that the various embodiments described throughout this disclosure may alternatively be implemented in a virtualized environment where the operating system is installed on a virtual machine on the computing device rather than directly on the hardware of the device. As known in the art virtual machines may be hosted by using a hypervisor or virtual machine manager VMM on the computing device and each virtual machine may include its own operating system along with the kernel drivers and other components. The tracking of write operations described throughout this disclosure can be utilized in the operating system installed in the virtual machine as well as directly installed on the physical hardware on the computing device.

As shown in to create a first backup the backup application initiates a create snapshot request to the VSS service . The VSS service then issues a first flush and hold write control operation e.g. FLUSH AND HOLD WRITE . This control operation is detected via the alternate control handler of the volume snapshot driver . Once the control code is detected an active bitmap is initialized. The flush and hold write control code signifies a point in time where I O operations on the volume are suspended. Once the first flush and hold write control operation is detected and the active bitmap is initialized the write handler starts tracking writes. From that point on the system is maintaining the active bitmap which is tracking writes that are occurring since the last flush and hold write control signal. Also as a result of the first flush and hold write there has been a resulting snapshot captured of the volume.

The active bitmap will continue to record the changed blocks caused by the write operations occurring on the volume until the next control signal is received to the volume snapshot driver . The next control signal will be issued upon the next time that the incremental backup needs to be performed. For example if the next incremental backup will be performed in two days then for the time interval of two days the alternate write handler will continuously track write operations performed on the volume. At the end of that time interval the backup application once again initiates a VSS snapshot request. This request once again initiates a flush and hold write control signal that is transmitted down the volume device stack. Once this control signal is detected by the alternate control handler the control handler can perform two actions. Specifically upon receiving the next control signal and determining that there is an active bitmap that already exists the control handler 1 suspends tracking writes on the active bitmap i.e. the bitmap that was initialized in the first control signal and 2 initializes a new active bitmap and marks it as the currently active bitmap.

Thus any writes occurring after the second flush and hold write control signal would go into the new active bitmap . The bitmap which is no longer active after the control operation represents the changes that have happened since the snapshot was created with the control operation e.g. changes that have occurred over the last two days in the above example . Thus bitmap represents all the changes writes that have been made from the first control code to the second control code that caused the bitmap to be stopped. This bitmap can then be used to perform the incremental backup.

At the time of providing the snapshot to the application the VSS may perform some write operations to the snapshot volume in order to ensure that the snapshot volume is consistent with the physical volume . In some embodiments it is important that these write operations are captured in the bitmaps. Thus as shown in the illustrated embodiment the active bitmap and the active bitmap are merged to get a master bitmap which would be the correct and up to date bitmap. The bitmaps can be merged by performing a logical AND of the two bitmaps and to produce the master bitmap . This master bitmap is used by the backup application to maintain consistent backup.

In some embodiments the master bitmap may also be used to allow the user application to specify an exclude list of files that should not be included in the backup. In many cases not all files included in the snapshot of the volume need to be backed up and the backup application may specify the files that should be excluded. For example the application may specify that the backup should not include a file pagefile.sys . In this example the application would take the first fill snapshot and then during small window of time when the snapshot is capable of being written to the backup application executes a delete on pagefile.sys or other specified exclude file which resides in the snapshot volume . This window of time is used to allow both the operating system and the application to make the snapshot consistent with the volume device . This time window can be taken advantage of in order to issue the delete operations to delete the file from the snapshot . It should be noted that the file should not be excluded from the volume device but only from the snapshot .

In various embodiments the delete operation i.e. I O operation is also tracked by using the alternate handlers . Furthermore as a result of merging the active bitmaps the I O delete operation becomes part of the merged master bitmap and therefore the causes the backup copy to exclude the specified files .

In operation a filter driver associated with a snapshot of a volume is accessed on an operating system. The fitter driver can be a volume snapshot driver that is operable to create a snapshot of a volume on the computer and to perform input and output I O operations on the snapshot. The accessing may be performed via an application programming interface API provided by the operating system. Specifically a change block tracking CBT driver of the backup application may be dynamically loaded into memory and this CBT driver may invoke the API operation to access the volume snapshot driver.

In operation a patch is applied to the volume snapshot driver. The patch is configured to replace the original write handler of the volume snapshot driver with an alternate write handler. In addition the patch may be configured to replace the original control handler with an alternate control handler. The use of the alternate write handler enables the tracking write operations performed on the snapshot as illustrated in operation .

In operation the CBT driver maintains an active bitmap that records the sequence of write operations performed on the snapshot over a time interval. For example the active bitmap may store the changed blocks i.e. the offset and length of each write operation performed on the snapshot . In operation an incremental backup of the volume is performed by the backup application based on the snapshot and based on the active bitmap that records the sequence of write operations performed over the time interval.

In operation in response to detecting the control signal a first active changed block bitmap is initialized. The flush and hold write control code signifies a point in time where I O operations on the volume are suspended. Once the active changed block bitmap is initialized the write handler starts tracking write operations on the snapshot. The changed blocks caused by the write operations are recorded by updating the active bitmap as shown in operation .

The active bitmap will continue to record the write operations occurring on the volume until the next control signal is received to the volume snapshot driver. In operation the next flush and hold write control signal is received to the volume snapshot driver. This next control signal was issued as a result of the backup application initializing the next incremental backup.

Upon receiving the next control signal and determining that there is an active bitmap that already exists the updating of the active bitmap is suspended as shown in operation . Thus the alternate write handler no longer updates the active bitmap and the active bitmap is frozen. In addition a new active bitmap is initialized operation for recording the write operations that occur subsequent to the control signal. This new bitmap is marked as the currently active bitmap. In operation the new active bitmap is updated when tracking write operations received after the second flush and hold write control signal.

Each computing device typically will include an operating system that provides executable program instructions for the general administration and operation of that device and typically will include computer readable medium storing instructions that when executed by a processor of the server allow the computing device to perform its intended functions. Suitable implementations for the operating system and general functionality of the servers are known or commercially available and are readily implemented by persons having ordinary skill in the art particularly in light of the disclosure herein.

Various embodiments discussed or suggested herein can be implemented in a wide variety of operating environments which in some cases can include one or more user computers computing devices or processing devices which can be used to operate any of a number of applications. User or client devices can include any of a number of general purpose personal computers such as desktop or laptop computers running a standard operating system as well as cellular wireless and handheld devices running mobile software and capable of supporting a number of networking and messaging protocols. Such a system also can include a number of workstations running any of a variety of commercially available operating systems and other known applications for purposes such as development and database management. These devices also can include other electronic devices such as dummy terminals thin clients gaming systems and other devices capable of communicating via a network.

Most embodiments utilize at least one network that would be familiar to those skilled in the art for supporting communications using any of a variety of commercially available protocols such as TCP IP OSI FTP UPnP NFS CIFS and AppleTalk. The network can be for example a local area network a wide area network a virtual private network the Internet an intranet an extranet a public switched telephone network an infrared network a wireless network and any combination thereof.

In embodiments where the computing device includes a Web server the Web server can run any of a variety of server or mid tier applications including HTTP servers FTP servers CGI servers data servers Java servers and business application servers. The server s also may be capable of executing programs or scripts in response requests from user devices such as by executing one or more Web applications that may be implemented as one or more scripts or programs written in any programming language such as Java C C or C or any scripting language such as Perl Python or TCL as well as combinations thereof. The server s may also include database servers including without limitation those commercially available from Oracle Microsoft Sybase and IBM .

The environment can include a variety of data stores and other memory and storage media as discussed above. These can reside in a variety of locations such as on a storage medium local to and or resident in one or more of the computers or remote from any or all of the computers across the network. In a particular set of embodiments the information may reside in a storage area network SAN familiar to those skilled in the art. Similarly any necessary files for performing the functions attributed to the computers servers or other network devices may be stored locally and or remotely as appropriate. Where a system includes computerized devices each such device can include hardware elements that may be electrically coupled via a bus the elements including for example at least one central processing unit CPU at least one input device e.g. a mouse keyboard controller touch screen or keypad and at least one output device e.g. a display device printer or speaker . Such a system may also include one or more storage devices such as disk drives optical storage devices and solid state storage devices such as random access memory RAM or read only memory ROM as well as removable media devices memory cards flash cards etc.

Such devices also can include a computer readable storage media reader a communications device e.g. a modem a network card wireless or wired an infrared communication device etc. and working memory as described above. The computer readable storage media reader can be connected with or configured to receive a computer readable storage medium representing remote local fixed and or removable storage devices as well as storage media for temporarily and or more permanently containing storing transmitting and retrieving computer readable information. The system and various devices also typically will include a number of software applications modules services or other elements located within at least one working memory device including an operating system and application programs such as a client application or Web browser. It should be appreciated that alternate embodiments may have numerous variations from that described above. For example customized hardware might also be used and or particular elements might be implemented in hardware software including portable software such as applets or both. Further connection to other computing devices such as network input output devices may be employed.

Storage media and computer readable media for containing code or portions of code can include any appropriate media known or used in the art including storage media and communication media such as but not limited to volatile and non volatile removable and non removable media implemented in any method or technology for storage and or transmission of information such as computer readable instructions data structures program modules or other data including RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disk DVD or other optical storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can be accessed by a system device. Based on the disclosure and teachings provided herein a person of ordinary skill in the art will appreciate other ways and or methods to implement the various embodiments.

The specification and drawings are accordingly to be regarded in an illustrative rather than a restrictive sense. It will however be evident that various modifications and changes may be made thereunto without departing from the broader spirit and scope of the invention as set forth in the claims.

