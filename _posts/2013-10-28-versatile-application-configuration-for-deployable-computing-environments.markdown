---

title: Versatile application configuration for deployable computing environments
abstract: Within a computing environment, an application may run in a variety of contexts, e.g., as a natively executable application, as a client-side interpretable application embedded in a web browser, or as a server-side application that communicates with the user through a web interface presented on a device. The application may also access resources of the computing environment stored on multiple devices. The configuration of the application to operate equivalently in these diverse environments may be facilitated by representing the application within an object hierarchy representing the computing environment. The application may be configured to operate on the objects of the object hierarchy regardless of the location of the stored objects, to execute on any device, and to execute upon a standard set of application programming interfaces. The configuration of the application in this manner promotes the versatility of the application in operating equivalently in different programming contexts.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09332063&OS=09332063&RS=09332063
owner: Microsoft Technology Licensing, LLC
number: 09332063
owner_city: Redmond
owner_country: US
publication_date: 20131028
---
This patent application claims the benefit for priority under 35 U.S.C. 120 of U.S. patent application Ser. No. 12 052 534 Versatile Application Configuration for Deployable Computing Environments filed on Mar. 20 2008 which is incorporated by reference as if fully rewritten herein.

Many computing environments comprise a large and diverse set of objects managed by a set of object systems. For example a computing environment may comprise a set of files managed by a file system one or more databases managed by a database system a set of executable binaries representing applications and managed by an assembly cache a set of user profiles managed by a user profile component of an operating system and various data caches managed by data caching components such as a set of copied items managed by a copy buffer of the operating system a set of undo actions managed by an undo component of the operating system and a set of most recently used items managed by an item usage tracking component of the operating system. Moreover such objects may be exchanged among a plurality of devices operated by one or more users and according to one or more operations e.g. an object synchronization operation that merges two object sets and an object mirroring operation that adjusts a target object set to match a source object set. In this manner the objects are loosely organized through a set of object systems and aggregated to represent the computing environment.

The applications available within contemporary computing environments are typically devised and presented to the user according to many contexts. A locally deployed application typically operates on a local device and often utilizes one or more application programming interfaces for functions such as graphics rendering memory access window management and network communication with remote resources. A server side web application typically operates on a remote resource such as a remote webserver and communicates with a user of a local device through a client interface such as a web browser. A client side web deployed application is typically stored as a set of resources on a remote server sent to a local device upon request and executed on the device. Such client side web deployed applications may run within a web browser or may be configured to run as a locally deployed application for instance a Java or XAML application may be sent to a device locally compiled or interpreted and executed similarly to other locally deployed applications. Some applications have features of multiple contexts for instance an email service suite may have a server side portion that receives mail and filters spam and may offer users a choice between a locally deployed email application and a webmail interface to the mailbox that operates in a browser. Thus a typical computing environment often manifests as an aggregation of applications presented according to various contexts each of which may have a particular set of conventions. For instance an application state of a web application may be bookmarkable while a locally deployed application may not offer such functionality and a locally deployed application may have greater access to local resources such as a local file system than a web application constrained by browser and network based security processes.

This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key factors or essential features of the claimed subject matter nor is it intended to be used to limit the scope of the claimed subject matter.

The organization of objects within a computing system as a disjointed loosely aggregated set of object systems may create several problems. For example it may be difficult to present a consistent computing environment to the user through various devices especially if the devices vary in capabilities e.g. a high performance personal workstation a browser based public terminal and a low performance cellphone device. As another example applying services to the objects such as synchronization and backup may involve interfacing with each object system to affect the objects managed thereby and such interfacing may vary among object systems. As a third example relating a diverse set of objects such as all of the objects comprising an application may be difficult due to the incomplete cooperation of the managing object systems.

An alternative technique for representing the objects comprising the computing environment involves organizing the objects in an object hierarchy which may be hosted by a computing environment host. If the objects are represented in a uniform manner and managed in a consistent way by an object system a set of services may be devised to apply to all of the objects of the computing environment. Moreover the object hierarchy may be delivered to various devices to represent the same computing environment including the same user profiles applications data files etc. and each device may render the computing environment in a consistent manner but customized based on the capabilities of the device e.g. a hard keyboard interface for receiving data entry from a keyboard device attached to a workstation and a touchscreen software keyboard interface for receiving data entry from a cellphone device. 

This computing environment may be rendered in several ways. A first device comprising a locally stored object hierarchy may render the entire computing environment. A second device may have access to a portion of a remotely stored object hierarchy and may be permitted to receive and process applications of the computing environment as a client side web deployed application. A third device may be granted access to the entire computing environment through a web browser and the applications may execute on the computing environment host while communicating with the user through the web browser of the third device. Thus an application represented in the computing environment may have to operate in many contexts such as a locally deployed application and a server side web based application.

However it may be difficult to configure the application to run in various contexts. As one example an application may feature an interface that is specially devised to run in one context such as a client side script executing in a web browser that may be difficult to present in another context such as a locally deployed application. As another example an application may have difficulty accessing a resource over a network connection e.g. a locally deployed resource that depends on locally deployed application programming interfaces or assemblies in an assembly cache may be unable to operate in the comparative isolation of a web browser. As a result many contemporary applications are configured only to run in one context or are presented with several single context versions e.g. a first version configured to operate as a locally deployed application a second version configured to operate as a client side web application that executes in a web browser or as a locally deployed application and a third version configured to operate as a server side web application that communicates with the user through a web browser. 

Presented herein are techniques for configuring an application to run in multiple contexts such as e.g. a locally deployed application a web deployed client side application operating in a browser and a server side application that communicates with a user through a web browser. This contextual versatility may be achieved by configuring the application to operate predominantly on objects of the deployable object hierarchy which may be accessible to the application in a similar form regardless of whether it is available on the same device or remotely accessed. As one example of this versatility the application may reference the objects of the object hierarchy according to a common addressing model and the associations may be configured for different contexts simply by updating the addresses to local or remote references. The application may also be serviced by an application runtime that provides access to a uniform application programming interface regardless of whether the application is executing as a locally deployed application as a client side web deployed application executing in a web browser or as a locally deployed application or as a server side web application with a web browser user interface. An application devised to support such versatility may be included in the object hierarchy and may be diversely configured to match the manner in which the computing environment is rendered on a particular device.

To the accomplishment of the foregoing and related ends the following description and annexed drawings set forth certain illustrative aspects and implementations. These are indicative of but a few of the various ways in which one or more aspects may be employed. Other aspects advantages and novel features of the disclosure will become apparent from the following detailed description when considered in conjunction with the annexed drawings.

The claimed subject matter is now described with reference to the drawings wherein like reference numerals are used to refer to like elements throughout. In the following description for purposes of explanation numerous specific details are set forth in order to provide a thorough understanding of the claimed subject matter. It may be evident however that the claimed subject matter may be practiced without these specific details. In other instances well known structures and devices are shown in block diagram form in order to facilitate describing the claimed subject matter.

Modern computer systems comprise a large number and variety of objects. Many computer systems feature a file store containing both the files for configuring the computer system including executables class libraries configuration information sets and resources and user files generated or received by one or more users. Many computer systems also comprise a wide range of configuration information comprising the computer system hardware and software including the hardware and devices of the computer system the operating system the shell user interface and the configuration of the applications available within the shell user interface. Various user profiles and accounts may also exist the former comprising information describing a particular user or user class name shell user interface preferences home directory etc. and the latter comprising information describing the privileges of the user or class file ownership read write privileges access to various devices etc. Protected security information such as passwords certificates public private key pairs and access control lists may be stored in a security object over which the operating system may exert regulated access. One or more data caches may exist such as browser caches and histories recent entries in application or browser textboxes and recently used file and object lists. Various applications may create application or task specific archives such as an email archive containing various folders and messages and a shared address book containing contact information received from various sources by various system users and organized in user defined groups. Finally the computer system may be configured to exchange particular sets of information with other computers users and devices such as objects to be synchronized and object sets to which access may be granted with various conditions read write privileges ownership quotas etc. Such object types are typically managed by various management systems e.g. a file system a system registry store a user account management system and an email system within the computer system in an ad hoc manner with little consistency or standardization of access methods or object organization.

The organization of objects within a computing system as a disjointed loosely aggregated set of object systems may create several problems. As a first example rendering and maintaining a consistent computing environment comprising a consistent set of objects such as files applications user profiles application configuration data caches etc. may be very difficult especially among devices of varying capabilities such as a personal workstation a public terminal and a cellphone device. As a second example applying services to the objects may be complicated by the storage of diverse objects in multiple object systems. For instance locating objects matching a particular description such as objects last modified within a particular time span may involve querying for matching files through one or more file systems matching database records through a database system matching registry keys through a system registry matching applications through an assembly cache matching data cache items through various data caches etc. Because such object systems often store the associated objects in non standard ways such as with parameters specific to the nature of the objects e.g. examining file records through a file system journal and examining database records through a data specific timestamp applying an operation to each the various object systems may be difficult. As a third example because each object system is configured to manage a particular kind of object relating and mixing the types of objects may be difficult. For instance an application may comprise an executable binary stored in an assembly cache some configuration information stored in a system registry supplemental files such as dictionaries for various languages stored in a file system and events such as recently edited documents stored in data caches. It may be difficult to represent an association of these object types in various systems and to manipulate all such objects together e.g. deleting all such objects in order to uninstall the application. As a fourth example the object set of the computer system may be distributed across several devices and providing consistent access to the object sets may be complicated by the various configurations of the devices the network capabilities of each device and incompatibilities in the wire formats used by each device for exchanging data e.g. a first device may be configured to exchange data according to an XML schema and a second device may be configured to exchange data according to JSON. 

An alternative approach may be devised wherein the computing environment is represented in a manner that may be delivered to devices for rendering according to the capabilities of the device. The representation comprises a set of objects organized according to an object hierarchy and represented according to a common grammar. The objects include the data objects of the computer system such as the user files and data created by the user. The objects also include the executable binaries and class libraries comprising the operating system components such as the shell and the applications offered therein. The object also include the information specifying the user interface of a computing environment including shell preferences e.g. visual themes application launch menu and double click threshold user accounts and privileges security information e.g. passwords security tokens and certificates application binaries and configuration information user data and metadata e.g. file sharing information and data caches e.g. most recently used file lists and browser history. Despite the various nature and uses of these objects the objects are represented in a common manner in the object hierarchy and may be arbitrarily organized in the hierarchy. Thus in contrast with former systems comprising a set of isolated data stores each containing one type of object e.g. a file system containing files a registry containing configuration information and a data cache containing the browser history the object hierarchy in this approach organizes all such objects in a common manner in the object hierarchy.

A computing environment represented in this manner may be delivered to any device and rendered in a manner suitable for the capabilities of the device. For instance a workstation may render the information as a robust and general purpose computing environment while a public workstation may render a different computing environment experience through a web browser e.g. as a virtual machine that may be discarded at the end of the user s session and a cellphone may provide a leaner interface with quicker access to cellphone related information e.g. contacts calendar and navigation data. Moreover updates to the information set e.g. preference changes and updates to data files contained therein may be applied to the canonical source of the information set and thereby propagated to all other devices to which the information set is delivered. Also the devices sharing the computing environment may be integrated through the shared information set such that one device may interact with others that are identified in the information set e.g. data stored on a first device may be accessed by a second device and a first device may be controlled by a second device through a communications conduit. The information set may therefore identify the collection of devices that share the computing environment along with the roles capabilities and resources of each device to provide an integrated computing experience across a potentially large number and variety of devices.

However the representation of the computing environment as an object hierarchy may create difficulties in executing applications since the computing environment may execute in different contexts. For example a high performance device such as a notebook computer may render a full featured representation of the computing environment and an application operating therein may execute directly on the notebook computer and may access the resources and data objects stored locally on the notebook computer. By contrast a low power cellphone device may render a stripped down version of the computing environment and an application operating therein may execute as a web deployed client side context and may execute either as a native application within the computing environment or within a web browser provided in the computing environment. Moreover the low power cellphone device may contain only a portion of the object hierarchy and the application may have to access some objects of the object hierarchy locally and other portions through the computing environment host or another device. As a third example a public workstation may render a strictly web based version of the computing environment through a web browser an application operating therein may execute wholly or largely on the computing environment host and the objects of the object hierarchy stored therein and may communicate with the user only through a thin client interface presented by a web browser.

As a result of the contextual differences in which such applications may operate the applications may exhibit different behaviors in different contexts. As a first example a web browser that hosts a server side web application or a web deployed client side application often has certain navigation properties such as a navigation paradigm based on hyperlinks an availability of forward back and home commands and an ability to bookmark a page in order to store a state of the application. A user may also be accustomed to a delay between page loads as this is a common navigation behavior among websites. By contrast an application executing natively in a graphical computing environment such as a windowing system may exhibit a different navigation paradigm based on hierarchically organized dialog boxes accessible through a menu system and users may be less tolerant of delays during transitions between application states. The user may not expect to find a bookmarking system in a natively running application and may instead rely on saving and loading data objects to capture and restore the state of an application. As a second example a web browser based application often exhibits certain visual properties such as a common inline arrangement of text and a common vertical scrolling component while an application executing natively in the windowing environment more often organizes controls in tab pages or child dialog windows and relies less on scrolling within dialogs. A web browser based application may also rely on lower performance computational processes such as graphics effects as compared with higher performance applications executing natively within the computing environment.

In addition web browser based applications may exhibit different performance properties than a natively executing application. As a first example a natively executing operation may run well whether or not the device can communicate with the computing environment host or even if the device is not connected to a network however it may be considerably more difficult to configure a web application for equivalent online and offline execution. As a second example many web browser based applications operate in a comparatively isolated context with restricted access to many local system resources such as local storage the system registry and user profile information while natively executing applications have less restricted access. This restriction may pertain to the location of the object hierarchy for example if a portion of the object hierarchy is stored on the device where the application is executing a natively running application may be freely able to access the objects thereof but a web browser based version of the application may be unable to access the objects. Similarly a natively running application may be able to consume a greater amount of system resources such as local storage and computation than a web browser based application which may be resource restricted for security and performance motivations. Conversely a web browser based application may be more readily implemented in a platform independent manner than an application to be natively executed which may depend more closely on a set of application programming interfaces exposed by a particular operating system. Also a server side web based application may be more closely trusted by the hosting server and may be granted more service privileges to the hosting server than a client side application to which the server may attribute a lower scope of access. As a third example an application may have different expectations with regard to a locally stored object hierarchy e.g. if the application is executing on the computing environment host or on a device to which the object hierarchy is available than with regard to a remotely stored object hierarchy that is accessed over a network e.g. an application running on a device and accessing a portion of the object hierarch on the computing environment host or a server side web application attempting to interact with a portion of an object hierarchy stored on a device. For instance rapid access to a high bandwidth object such as a high definition video may be readily achieved if stored in a locally accessible object hierarchy but may be inadequately accessible for objects in a remotely stored object hierarchy.

Due to these many factors application developers infrequently develop applications that may be equivalently executed in a variety of contexts. Instead developers often target a particular context such as a natively executing application and design the resources of the computing environment with respect to that context. On occasion a developer may choose to develop several versions of an application each designed for a particular context e.g. an email client developer may design both a natively executing email client version that is adapted to utilize a local email store and a web based email client version such as a webmail client that is adapted to access email through an email server and to communicate through a web browser interface. This approach often capitalizes on the differences among platforms such as by utilizing a dialog driven interface for a local application and hyperlinks for the webmail interface and by implementing a search function via a server based index for the webmail application but through an ad hoc search on a locally executing version.

It may be appreciated that these complexities arise at least in part from the difficulty in configuring an application to operate in a context independent manner as a native application or as a browser with equivalent access to an object hierarchy stored locally or remotely and while executing on a device or on a remote server such as a computing environment host. In conventional computer systems it may be difficult for an application to interface with certain types of objects such as a file system the user profile for the current user a system registry and various types of system caches in a platform independent manner. Moreover the application may have to make provisions for accessing resources locally or remotely e.g. locally hosted objects might be accessible through a file system while remotely hosted objects might involve a request via a URL serialization network transport and deserialization.

However several of these considerations may be addressed by or compatible with the representation of the computing environment as an object hierarchy. A versatile configuration of the application may promote the portability of the application and an equivalent execution and presentation in any contextual rendering of the computing environment such as the various application contexts illustrated in .

As a first aspect of these techniques a device and a computing environment host may handle the task and details of enabling access to the object hierarchy. Rather than attempting to access diverse types of resources files user profiles system registries data caches etc. that may be stored on different devices and organized in platform specific manners the application may simply operate on objects within the object hierarchy. The task of identifying the location of an accessed object and of securing the requested access may be relegated to the components of the computing mesh. In addition to alleviating the application of the platform and location specific properties of the accessed objects this technique may present other advantages. For example the device and or the computing environment host may analyze accesses to the object hierarchy stored in various locations and may transparently improve the performance of such accesses by the application through caching and preloading. The device and computing environment may also handle the task of directing the object accesses to the locations on which the accessed portions of the object hierarchy are stored. Thus the application may be designed simply to access the objects of the object hierarchy regardless of location and the computing mesh may properly route the requests even if portions of the object hierarchy are relocated during use.

As a second aspect of these techniques instead of being configured to execute in a platform and context dependent manner the application may be configured to operate through a set of application programming interfaces that is equivalently implemented in various contexts such as a native application a web browser hosting a client side web deployed application a server executing a server side application and a web browser hosting a client web interface to a server side application. Thus the application may simply be inserted into the object hierarchy and may operate within the programmatic capabilities of the object hierarchy. The various devices and contexts embedded therein may be configured to provide a common platform that fulfills application programming interface invocations in an equivalent manner but within various contexts. For instance the application may operate upon a common application runtime that is equivalently implemented for each context and which achieves an equivalent execution behavior regardless of the operating context of the application. Again in addition to alleviating the application of the platform specific programming configuration this technique may present additional advantages. For instance the device and computing environment host may also cooperate to distribute the processing workload of the application in an efficient manner.

The techniques described herein may be implemented with variations in many aspects and some variations may present additional advantages and or reduce disadvantages with respect to other variations of these and other techniques. These variations may be included in various embodiments such as the exemplary method of and the exemplary system of and may be compatible with other such variations to present several such additional advantages and or reduced disadvantages. Those of ordinary skill in the art may therefore devise many such embodiments in accordance with the techniques discussed herein.

A first aspect that may vary among implementations of these techniques relates to the contexts in which the application may be configured to operate as discussed herein. Such applications may be configured to in any of the contexts illustrated in . As a first example the application may be configured to execute natively such as the native application configured to execute on the workstation in or upon an application runtime configured to access the object hierarchy such as may be provided by the operating system or by a web browser. As a second example the application may be configured to access the objects of a locally stored object hierarchy available at a local address or to access the objects of a remotely stored object hierarchy available at a remote address. As a third example the application may be configured to execute on a computing environment host configured to store the object hierarchy such as the first application instance in that is configured to operate on the computing environment host storing the first object hierarchy portion or the third application instance configured to operate on the notebook computer that also stores the second object hierarchy portion . Alternatively the application may also be configured to access an object hierarchy stored on a first device and to execute on a second device such as the second application instance and the fourth application instance in .

A second aspect that may vary among implementations of these techniques relates to the form of the application. As a first example the application may be included in the object hierarchy as one or more source code documents which may be compiled on a device prior to execution or as an interpretable script which may be interpretively executed on the device. This example may be advantageous by enabling many devices and platforms that can compile the source code or interpret the script to execute the application. This example may also be advantageous by allowing the device greater latitude to examine the source code or script e.g. to examine the application for incompatible problematic or potentially malicious code. As a second example the application may be included as a partially compiled binary such as a compiler parse tree. This example may be advantageous by reducing the compilation burden on the device while still permitting the device to compile the partially compiled binary into a platform specific executable binary. As a third example the application may be wholly compiled into a wholly compiled executable binary that is ready to execute on the device. This example may be advantageous where the device is low powered and is not easily capable of including a compiler or where the application is large and is not amenable to compilation on the device. The wholly compiled executable binary may only run on a subset of platforms however the object hierarchy may be configured to include a set of executable binaries for an application that are respectively compiled for a targeted platform. Those of ordinary skill in the art may be able to include the application in the object hierarchy in many forms while implementing the techniques discussed herein.

A third aspect that may vary among implementations of these techniques relates to the representation of the application in the object hierarchy. In accordance with the second aspect the form in which the application is included in the object hierarchy may result in a binary object a text based object or a hybrid thereof. These basic formats may then be represented in the object hierarchy in many ways. As a first example the object may be included as an atomic data unit such as a source code object encoded in the object hierarchy as plaintext or a binary object encoded in the object hierarchy through a binary serializing algorithm e.g. Uuencode or MIME. As a second example the application may be represented in the object hierarchy as a set of individual data units such as code modules partially or wholly compiled binaries a series of imperative instructions or declarative statements a series of class definitions etc. These sets of individual data units of the object may be semantically organized in many such ways but the representation of the application in the object hierarchy may be organized according to a content and semantic independent representation that simply reflects the relationships among the data units. Thus a representation grammar may be devised for representing various organizational relationships among the data units e.g. a first data unit as a container of a second data unit or of a series of such data units. Moreover the representation grammar may be recursively defined to permit deeper hierarchies of relationships e.g. a series of one or more series of data items. Based on this recursable base representation format the resources comprising the application may be stored in the object hierarchy in a well organized but content independent manner. As a third example the representation of the application may be expressed according to a data interchange format chosen as an organizational syntax for the object hierarchy such as JSON Atom or XML. Thus embodiments of these techniques may include a deployment of the object hierarchy or a portion of the object hierarchy that contains the application to at least one device wherein the application is represented in the object hierarchy according to a data interchange format. Those of ordinary skill in the art may be able to devise many representations of the application regardless of its form within the object hierarchy while implementing the techniques discussed herein.

A fourth aspect that may vary among implementations of these techniques relates to the addressing of the objects in the object hierarchy by the application. As discussed herein the contextual versatility of the application may be improved by applying the application to the objects of an object hierarchy instead of to the various types and locations of resources in the disjointed organization of a conventional computing environment e.g. particular files in a file system and particular registry keys in a system registry. If the application references an object at a particular address within the object hierarchy the platform on which the application executes e.g. the rendered computing environment hosting a natively executing application an application runtime that is servicing the application such as within a web browser application and or the computing environment host on which a server side application is executing may resolve the address to the current location of the object.

In this exemplary scenario the application contains a first object reference to a photo in a photo store that happens to be stored in the second object hierarchy portion a second object reference to the name of the local user stored in the user profile that happens to be stored in the first object hierarchy portion and a third object reference to contact information for an individual named John Lee that happens to be stored in the third object hierarchy portion . However in this exemplary scenario the application does not directly address the devices on which the referenced objects are stored. Rather the application addresses the objects of the computing environment according to the address of the object within the object hierarchy beginning with the root of the object hierarchy. The references may be redirected to the device currently storing the portion of the object hierarchy containing the referenced object. In this exemplary scenario the application communicates with the computing environment host and the devices through an application platform which may comprise e.g. an application runtime configured to service and facilitate the application . This application platform contains a routing table which may contribute to a completion of the object reference by prepending a base address for the device storing the referenced portion of the object hierarchy. Thus the object hierarchy may have a base address and respective objects of the object hierarchy may be available at an object address relative to the base address. The application may then be configured to access the objects of the object hierarchy according to the object address relative to the base address. For instance the first object reference is evaluated by the application platform according to the routing table which indicates that references to objects in the object hierarchy beginning with Photos are to be routed to the notebook computer . Accordingly the relative address of the first object reference Photos Photo1 is prepended with a reference to the base address of the notebook computer http notebook to produce an absolute address http notebook Photos Photo1 .

The addressing model illustrated in the exemplary scenario of may have several advantages. As a first example the addressing scenario illustrated in is an application of a Uniform Resource Identifier URI hierarchical addressing model which is well understood and widely supported e.g. as in the addressing of resources on the World Wide Web. As a second example the and in furtherance of the versatility of the application this referencing may obscure the location of the represented objects form the application . Thus the application may reference objects stored on the notebook computer according to the relative address of the object e.g. Photos Photo1 regardless of whether the application is also executing on the notebook computer or on another device such as the cellphone device . The application platform may therefore determine how the relative address is to be completed. For instance if the application is executing on the notebook computer the address may be completed with an internal base address e.g. http localhost whereas if the application is executing on the cellphone device the address may be completed with a network specific base address for the notebook computer e.g. an IP address such as http 16.235.147.6 . Moreover the application may successfully access portions of the object hierarchy even if it is relocated during the accessing e.g. if a portion of the object hierarchy is moved from a first device to a second device the references to the address within the application may remain unchanged but the routing table of the application platform may be updated to reflect the new location of the object hierarchy portion. Those of ordinary skill in the art may be able to devise many addressing models with various advantages with respect to the techniques discussed herein.

A fifth aspect that may vary among implementations of these techniques relates to the nature of the interaction between the application and the object hierarchy through one or both of a computing environment host and an application runtime. The object hierarchy may be exposed to the application as a large data structure and the application may access the objects of the object hierarchy through object level operators such as Create Read Update and Delete objects pertaining to common object operations. As a first example the object hierarchy may be exposed through a File Transfer Protocol FTP model wherein the application may navigate the object hierarchy in a file structure manner and may read write and update objects. As a second example the computing environment host may offer a web service or other remote invocation method to exchange data comprising the objects of the object hierarchy. As a third example the object hierarchy may be exposed through an HTTP interface and updates to the objects may be made through the standard HTTP verbs POST GET PUT and DELETE. This access technique may be advantageous in at least three aspects. First communicating through an HTTP interface may involve a standardized well understood and widely supported communications protocol. Second an HTTP interface may be particularly compatible with resources addressed as illustrated in i.e. according to a URI addressing model. Third these accessing and addressing techniques may be combined with some other principles such as a stateless transaction model to model the object hierarchy accessing according to a representational state transfer RESTful interface. However those of ordinary skill in the art may be able to devise many object hierarchy interfaces and to configure applications to utilize such interfaces while implementing the techniques discussed herein.

In view of the foregoing aspects illustrates an exemplary configuration of an application to access the objects of an object hierarchy. In this scenario the application may be instantiated either as a server side application that executes on the computing environment host and communicates with the user through a web interface displayed on a notebook computer or as a locally deployed application that executes on the notebook computer and accesses locally stored resources.

In the first exemplary configuration the application is represented in an object hierarchy on the computing environment host as an application binary and an application resource . These objects are provided relative addresses in this scenario URIs within the object hierarchy . An application instance may be invoked that operates on the computing environment host . The application instance may contain a base address reference that directs the references of the application such as to the application resource to the local device i.e. the computing environment host . The application instance may also communicate with the user through a device such as an application web interface rendered on a notebook computer . The application web interface may also include an application resource reference and may access the application resource through its address within the object hierarchy. However because the application web interface also contains a base address reference pointing to the computing environment host on which the application instance is executing the application resource reference is properly directed to the computing environment host . Thus the application may operate in a server side configuration and references may be properly resolved between the device and the computing environment host through the addressing model.

In the second exemplary configuration the application is again represented in an object hierarchy on the computing environment host as an application binary and an application resource . However this application instance is invoked as a locally deployed application that executes on the notebook computer . This context may be achieved by deploying the application binary and the application resource to the notebook computer e.g. by representing these resources in the object hierarchy and deploying at least this portion of the object hierarchy to the notebook computer . Moreover the application may be configured to access the locally deployed objects instead of the objects stored in the object hierarchy on the computing environment host . This configuration may be achieved simply by updating the base address stored by the locally deployed application instance . The locally deployed application instance still contains an application resource reference to the application resource . However this application resource reference remains the same as it continues to reference the application resource correctly according to its address within the object hierarchy . The correct routing of the application resource reference to the locally deployed version of the application resource is achieved through the altered base address stored in the locally deployed application . However the locally deployed application instance might also access resources that are not locally deployed by redirection of such requests to the computing environment host e.g. through the use of a routing table such as illustrated in .

It may be appreciated by comparison of the first exemplary scenario and the second exemplary scenario of that the application may therefore execute in various contexts and references to resources may be properly routed to various deployments of the objects of the object hierarchy simply by updating a base address that is prepended to the address of the object. This reconfiguration may promote the versatility of the application in executing in a variety of contexts and irrespective of the deployment of the objects in the object hierarchy. For example the application may be readily configurable for operation as a natively deployed application or as a client side application in a web browser or as a server side application that communicates with the user via a web interface rendered on a device. The application may also be readily configured for either online access accessing objects stored on an accessible remote server or offline access accessing a local snapshot of the objects stored locally and comprising locally hosted application binaries and resources. 

Still another embodiment involves a computer readable medium comprising processor executable instructions configured to apply the techniques presented herein. An exemplary computer readable medium that may be devised in these ways is illustrated in wherein the implementation comprises a computer readable medium e.g. a CD R DVD R or a platter of a hard disk drive on which is encoded computer readable data . This computer readable data in turn comprises a set of computer instructions configured to operate according to the principles set forth herein. In one such embodiment the processor executable instructions may be configured to perform a method of configuring an application to operate within a computing environment such as the exemplary method of . In another such embodiment the processor executable instructions may be configured to implement a system for executing an application represented in an object hierarchy representing a computing environment such as the exemplary system of . Many such computer readable media may be devised by those of ordinary skill in the art that are configured to operate in accordance with the techniques presented herein.

Although the subject matter has been described in language specific to structural features and or methodological acts it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the specific features or acts described above. Rather the specific features and acts described above are disclosed as example forms of implementing the claims.

As used in this application the terms component module system interface and the like are generally intended to refer to a computer related entity either hardware a combination of hardware and software software or software in execution. For example a component may be but is not limited to being a process running on a processor a processor an object an executable a thread of execution a program and or a computer. By way of illustration both an application running on a controller and the controller can be a component. One or more components may reside within a process and or thread of execution and a component may be localized on one computer and or distributed between two or more computers.

Furthermore the claimed subject matter may be implemented as a method apparatus or article of manufacture using standard programming and or engineering techniques to produce software firmware hardware or any combination thereof to control a computer to implement the disclosed subject matter. The term article of manufacture as used herein is intended to encompass a computer program accessible from any computer readable device carrier or media. Of course those skilled in the art will recognize many modifications may be made to this configuration without departing from the scope or spirit of the claimed subject matter.

Although not required embodiments are described in the general context of computer readable instructions being executed by one or more computing devices. Computer readable instructions may be distributed via computer readable media discussed below . Computer readable instructions may be implemented as program modules such as functions objects Application Programming Interfaces APIs data structures and the like that perform particular tasks or implement particular abstract data types. Typically the functionality of the computer readable instructions may be combined or distributed as desired in various environments.

In other embodiments device may include additional features and or functionality. For example device may also include additional storage e.g. removable and or non removable including but not limited to magnetic storage optical storage and the like. Such additional storage is illustrated in by storage . In one embodiment computer readable instructions to implement one or more embodiments provided herein may be in storage . Storage may also store other computer readable instructions to implement an operating system an application program and the like. Computer readable instructions may be loaded in memory for execution by processing unit for example.

The term computer readable media as used herein includes computer storage media. Computer storage media includes volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions or other data. Memory and storage are examples of computer storage media. Computer storage media includes but is not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM Digital Versatile Disks DVDs or other optical storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can be accessed by device . Any such computer storage media may be part of device .

Device may also include communication connection s that allows device to communicate with other devices. Communication connection s may include but is not limited to a modem a Network Interface Card NIC an integrated network interface a radio frequency transmitter receiver an infrared port a USB connection or other interfaces for connecting computing device to other computing devices. Communication connection s may include a wired connection or a wireless connection. Communication connection s may transmit and or receive communication media.

The term computer readable media may include communication media. Communication media typically embodies computer readable instructions or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term modulated data signal may include a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal.

Device may include input device s such as keyboard mouse pen voice input device touch input device infrared cameras video input devices and or any other input device. Output device s such as one or more displays speakers printers and or any other output device may also be included in device . Input device s and output device s may be connected to device via a wired connection wireless connection or any combination thereof. In one embodiment an input device or an output device from another computing device may be used as input device s or output device s for computing device .

Components of computing device may be connected by various interconnects such as a bus. Such interconnects may include a Peripheral Component Interconnect PCI such as PCI Express a Universal Serial Bus USB firewire IEEE 1394 an optical bus structure and the like. In another embodiment components of computing device may be interconnected by a network. For example memory may be comprised of multiple physical memory units located in different physical locations interconnected by a network.

Those skilled in the art will realize that storage devices utilized to store computer readable instructions may be distributed across a network. For example a computing device accessible via network may store computer readable instructions to implement one or more embodiments provided herein. Computing device may access computing device and download a part or all of the computer readable instructions for execution. Alternatively computing device may download pieces of the computer readable instructions as needed or some instructions may be executed at computing device and some at computing device .

Various operations of embodiments are provided herein. In one embodiment one or more of the operations described may constitute computer readable instructions stored on one or more computer readable media which if executed by a computing device will cause the computing device to perform the operations described. The order in which some or all of the operations are described should not be construed as to imply that these operations are necessarily order dependent. Alternative ordering will be appreciated by one skilled in the art having the benefit of this description. Further it will be understood that not all operations are necessarily present in each embodiment provided herein.

Moreover the word exemplary is used herein to mean serving as an example instance or illustration. Any aspect or design described herein as exemplary is not necessarily to be construed as advantageous over other aspects or designs. Rather use of the word exemplary is intended to present concepts in a concrete fashion. As used in this application the term or is intended to mean an inclusive or rather than an exclusive or . That is unless specified otherwise or clear from context X employs A or B is intended to mean any of the natural inclusive permutations. That is if X employs A X employs B or X employs both A and B then X employs A or B is satisfied under any of the foregoing instances. In addition the articles a and an as used in this application and the appended claims may generally be construed to mean one or more unless specified otherwise or clear from context to be directed to a singular form.

Also although the disclosure has been shown and described with respect to one or more implementations equivalent alterations and modifications will occur to others skilled in the art based upon a reading and understanding of this specification and the annexed drawings. The disclosure includes all such modifications and alterations and is limited only by the scope of the following claims. In particular regard to the various functions performed by the above described components e.g. elements resources etc. the terms used to describe such components are intended to correspond unless otherwise indicated to any component which performs the specified function of the described component e.g. that is functionally equivalent even though not structurally equivalent to the disclosed structure which performs the function in the herein illustrated exemplary implementations of the disclosure. In addition while a particular feature of the disclosure may have been disclosed with respect to only one of several implementations such feature may be combined with one or more other features of the other implementations as may be desired and advantageous for any given or particular application. Furthermore to the extent that the terms includes having has with or variants thereof are used in either the detailed description or the claims such terms are intended to be inclusive in a manner similar to the term comprising. 

