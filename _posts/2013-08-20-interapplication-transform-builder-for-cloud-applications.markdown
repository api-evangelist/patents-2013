---

title: Inter-application transform builder for cloud applications
abstract: A method, system, and computer program product for customization of flows between software applications. A system implementation commences by associating a first application with a first graphical object descriptor, and by associating a second application with a second graphical object descriptor. A graphical user interface such as an integrated development environment is used to drag/drop the graphical object descriptors and other graphical objects to form logical connections between the first graphical object descriptor and the second graphical object descriptor. The installation of an application is modified (e.g., using a patch), which modification is performed based at least in part on the logical connections. The logical connections between the applications handles inter-application communication such that upon executing the modified first application at least some outputs from the modified first application are processed using the logical connection to produce modified first application results which are in turn received by the second application.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09411562&OS=09411562&RS=09411562
owner: Oracle International Corporation
number: 09411562
owner_city: Redwood Shores
owner_country: US
publication_date: 20130820
---
The disclosure relates to the field of automating customization of flows between software applications and more particularly to techniques for automating inter application transforms used between multiple cloud borne applications.

Cloud based application delivery has become popular. Software application offerings by vendors including cloud vendors span a wide spectrum of disciplines and uses. A single cloud deployment might host many diverse applications such as business applications consumer applications data mining applications etc. and cloud vendors are often customer driven to support customization of such applications. In some cases a software application provider may offer rudimentary integration between one of their application titles and another one of their application titles. For example a data mining tool might write the results of a data mining operation to a database or file and a list maker tool might read data from that database or file. In some cases providers pre specify permitted e.g. pre tested inter application I O parameters.

Many customers users of the many diverse applications need to customize the application and or provide add on customerization of the vended applications. However adding an add on or other type of customerization to the vended applications often defeats the aforementioned offered rudimentary integration. This situation introduces several problems such as 1 if the practices suggested by the software vendors are followed the customers users cannot seize full benefit of the software titles in combination 2 even if a customer user can seize benefit from the aforementioned offered rudimentary integration the customers users are at the mercy of the software vendor s release schedule and 3 customer users cannot easily seize benefit from integration between software titles provided by different vendors.

One legacy approach has been to employ consultants who write custom code to implement customer specified integration between such applications. However this approach has many drawbacks including 1 even if a customer user can seize benefit from the custom code the customers users are at the mercy of changes rolled out by the software vendors and 2 the rate at which software vendors release code updates has increased dramatically thus commensurately exploding the costs incurred to employ consultants to maintain custom code.

What s needed are techniques to facilitate high function inter application integration without requiring consultants to develop custom code and without requiring revisions to customerized e.g. consultant developed code at each release of the constituent applications.

The present disclosure provides an improved method system and computer program product suited to address the aforementioned issues with legacy approaches. More specifically the present disclosure provides a detailed description of techniques used in methods systems and computer program products for an inter application transform builder for cloud applications.

A system implementation commences by associating a first application with a first graphical object descriptor and by associating a second application with a second graphical object descriptor. A graphical user interface such as an integrated development environment is used to drag and drop the graphical object descriptors and other graphical objects to form logical connections between the first graphical object descriptor and the second graphical object descriptor. The installation of an application is modified e.g. using a patch or update which modification is performed based at least in part on the logical connections. The logical connections between the applications handles inter application communication such that upon executing the modified first application at least some outputs from the modified first application are processed using the logical connection to produce modified first application results which are in turn received by the second application.

Further details of aspects objectives and advantages of the disclosure are described below and in the detailed description drawings and claims. Both the foregoing general description of the background and the following detailed description are exemplary and explanatory and are not intended to be limiting as to the scope of the claims.

Some embodiments of the present disclosure address the problem of building and maintaining inter application transforms and some embodiments are directed to an improved approach for implementing inter application transform builders for cloud applications. More particularly disclosed herein and in the accompanying figures are exemplary environments methods and systems for implementing an inter application transform builder for cloud applications.

Cloud based software application offerings by vendors including cloud vendors span a wide spectrum of disciplines and uses. A single cloud deployment might host many diverse applications such as business applications consumer applications data mining applications etc. and cloud vendors are often customer driven to support customization of such applications. In some cases a software application provider may offer rudimentary integration between one of their application titles and another one of their application titles. For example a data mining tool might write the results of a data mining operation to a database or file and a list maker tool might read data from that database or file. In some cases providers pre specify permitted e.g. pre tested inter application I O parameters.

In some of the herein disclosed embodiments acts constituent to building custom applications are made available to the customer as drag and drop controls to the developer s integrated design environment IDE . For example consider a customer who has purchased a human resources management application App1 and two software applications e.g. App2 and App3 from second and third independent vendors. Strictly as an example and illustration consider that the first application App2 is a talent scout application that looks for potential candidates to match a job specification and the second application App3 is a general purpose scheduling application that could be used to schedule and conduct interviews.

As can be appreciated App1 could interface with App2 and App1 could interface with App3 and App2 could interface with App3. Yet since each of the software titles are sourced from different vendors this scenario presents a need for multiple inter application communication paths and related components. Even modest integration efforts might need to draw in consultants from the outset of any integration effort. Cloud vendors and customers alike are in need of techniques to facilitate high function inter application integration without requiring consultants to develop and maintain so many components.

Some of the terms used in this description are defined below for easy reference. The presented terms and their respective definitions are not rigidly restricted to these definitions a term may be further defined by the term s use within this disclosure.

Reference is now made in detail to certain embodiments. The disclosed embodiments are not intended to be limiting of the claims.

As shown cloud infrastructure comprises a plurality of computing machines e.g. host H host H host H etc. configured for communication over a communication path to a database engine and a cloud server . The cloud infrastructure can be configured by an administrator and or by a user . Further a user can access and configure the cloud server via a graphical user interface and or an integrated development environment e.g. IDE . Such a user or an administrator might also configure e.g. initially configure and or maintain storage which contains an executable instance E. Such an executable instance comprises an instance image copy of any number of applications e.g. App1 App2 etc. and an executable instance image copy of any number of transforms which transforms serve to provide custom functions between applications. Storage might also contain an initial copy of site information data.

Any host e.g. host H host H host H etc. can host software applications application transforms and can execute any sorts of software processes. Any host can communicate with any other host can communicate with the database engine and can communicate with cloud server . The processes can be run on bare metal or can be run under an operating system or hypervisor. In exemplary embodiments any transform e.g. a running instance of transforms that runs on a host can communicate with the cloud server . Various particular functions of the transforms running on each host are discussed below in and elsewhere in this disclosure.

The database engine serves as a repository for data which data can be stored e.g. using storage device and be accessed as a relational database relation or as a file e.g. in a file system or as a memory resident data structure. As shown database engine comprises tenant application inventory list and occurrences of application interfacing data e.g. application interfacing details application interfacing details application interfacing details etc. .

In the particular embodiment of any occurrences of transforms can access the cloud infrastructure via communication path and or can access more distal points e.g. over a WAN . Exemplary communication facilities serve to provide input to and receive outputs from transforms. Such communication facilities see conduit as introduced in can perform at least the following functions 

As shown an integration builder tool serves to form an integrated development environment e.g. IDE comprising a GUI a text interface and any number of instances of a plug in . The integration builder tool further cooperates with a dependency manager tool and an integration deployer tool . The aforementioned suite of tools can be combined to implement various portions of an inter application transform builder for cloud applications.

The communication facilities provide intra host communication and inter host communication by and between any host within a cloud server using any protocol e.g. HTTP SOAP web services REST socket interactions etc. . In exemplary deployments such protocols are supported by the cloud vendor however it is possible that certain communications between the cloud server and agents can be performed using custom protocols. In some situations the communication facilities provide communication to from any destination beyond the periphery of the cloud server using any protocol e.g. TCP IP UDP HTTP ATM etc. .

The heretofore described communication facilities provide a conduit for communication between applications. In some cases a communication conduit is provided by a software vendor in the form of an application programming interface API that serves to move data in and out of a supported application. Some vendors may provide multiple applications and may provide compatibility between such applications via an API input interface that is compatible with another application s API output interface. Using such compatible API interfaces multiple applications can be integrated to the extent provided by the APIs. Such compatible API interfaces support a conduit based integration flow which is now briefly reviewed see below as a foundation from which to advance the discussion of the herein disclosed transform based integration flows.

As shown App1 communicates with App2 over a software implemented path e.g. conduit A1A2 . And App2 communicates with App1 over a software implemented path e.g. conduit A2A1 . The software implemented paths can be implemented in code and might be stored in a file system or other storage facility e.g. storage . Such code might be embodied as a routine or a class or a method etc. and can be stored in a format accessible by an IDE. As shown the code is stored as conduit A1A2 code and as conduit A2A1 code .

Embodiments that follow the conduit based integration flow of can be used to integrate applications using only their input output configurations e.g. as provided in an API . In some cases data output from one application might need to be manipulated before providing the manipulated data as input to a second application. In such cases a transform based integration flow can be employed.

As shown data from App1 talent scout is received by one of the transforms before being sent to App2 scheduler . The transforms use metadata to customize the transformation s . An example of such metadata is provided in Table 1 and a discussion of uses follows.

As shown in Table 1 the CustomApp element provides metadata pertaining to APIs e.g. see lines 10 through 17 as well as metadata beyond describing APIs e.g. see lines 2 through 9 and such metadata can be used by transforms. For example lines 6 and 7 offer protocols and a transform might select to use either a Web Service protocol or a REST protocol depending on integration considerations.

As can be appreciated metadata can be used to describe aspects of transforms and the metadata can be saved as stored transforms into a persistent storage repository e.g. storage . More particularly metadata can be used to describe choices of transforms which choices might be selected at runtime when data is received from or sent to another application. Further metadata corresponding to a conduit e.g. conduit A1T conduit TA2 conduit A2T conduit TA1 etc. can be saved as stored transforms into a persistent storage repository

The embodiment of depicts a portion of a cloud environment within which cloud environment a widget based graphical user interface use model can be practiced for building cloud applications. The shown IDE or components thereto are provided by the cloud vendor. The shown IDE or components thereto can connect to a cloud server and functions within the cloud server serve to identify the applications that the customer has purchased or otherwise has access to. For each application available the IDE retrieves any published control widgets as code or metadata e.g. an XML file from persistent storage accessible to the cloud infrastructure. Such widgets might be provided by the software application vendors.

In this example the control widgets include a widget for TS a control widget for SCH a control widget for HRM and a control widget for Mail . The control widgets can be accessed and cached by the IDE or they can be updated on demand or automatically in accordance with a rule or rules and or in any manner as per a user configuration. Strictly as one example the controls offer the following options for developers 

For illustrative purposes the functions of a sample application can be outlined in the following five steps 

Continuing this example the five step sample can be built using the widget based graphical user interface 3A00 by dragging a graphical object descriptor e.g. graphical widget TS from widget pane to the build desktop . In doing so a control object descriptor e.g. the control widget corresponding to the graphical widget is retrieved and parsed. Table 3 gives an example of a control widget for TS as codified in XML.

Next step 3 is implemented by dragging the graphical widget SCH from widget pane to the build desktop . In doing so the control widget corresponding to the graphical widget is retrieved e.g. using a plug in and the control widget is parsed. In some situations a dragged widget can be dropped onto build desktop in general proximity to another widget that already appears on the build desktop. Two proximal widgets can be logically connected in a source to target a relationship when the sense of the request of the target widget as determined by parsing the target widget is deemed to be structurally similar to the response of the source widget as determined by parsing the source widget . Also if a transformer is involved then the response of the first widget is to match the input to the transformer and the output of the transformer is to match the request of the target widget. A request of a widget and a response of a widget are deemed to be structurally similar if they contain the same data structures or data types though the names can be different .

The function to find out available interviewers of the sample application pertaining to step 3 is specified in the API calls given in line 10 through line 58 of Table 4.

The remaining steps of the sample application are implemented by repeating the drag and drop operations. In some cases a step might demand calls to procedures to transform data elements from one application to another. For example the candidate XML element can be translated to XML element party in order to conform to the input format used by Scheduler . This can be accomplished in a variety of ways possibly including use of XSLT.

In some embodiments graphical screen devices e.g. buttons might be provided in the GUI . As shown the GUI includes buttons labeled Populate Update Save Deploy APIs and API Editor . The Populate button might offer the user a choice of locations from which to populate the graphical widgets showing in widget pane . The Update button might update all graphical widgets and control widgets found in the current context of GUI . A Save Deploy button might store the sample integrated application into executable instance E and might further communicate with cloud server processes e.g. integration deployer tool dependency manager tool integration builder tool etc. to deploy the integrated application to the cloud infrastructure after tallying the dependencies of the flow of the integrated application. In some cases a flow corresponding to the juxtaposition and connections of the graphic widgets in the build desktop e.g. logical connection logical connection etc. are saved as a flow e.g. saved in storage . Such a flow can be retrieved by an integration builder tool . The integration builder tool can apply a mapping to retrieve the control widget corresponding to a graphical widget and organize the control widgets to provide conduits and transforms e.g. as discussed in .

The APIs button and the API Editor buttons serve to bring up API information in a GUI. Such a GUI is briefly discussed below.

As shown the GUI comprises an API reading pane and an API editing window . A list of APIs pertinent to the current context is displayed within an API reading pane possibly in a scrolling region. A selected one of the APIs pertinent to the current context e.g. selected from the API reading pane is displayed for editing in the API editing window .

Using the text based graphical user interface use model 3B00 or the widget based graphical user interface 3A00 either singly or in combination an integrated application can be developed. Then the integrated application can be saved to storage e.g. storage and deployed to the cloud infrastructure.

Returning to the discussion of the integration deployer tool serves to load the sample application to the cloud. In doing so the integration deployer tool constructs the needed conduit and transforms see and using the control widget descriptions. More specifically the integration deployer tool fills in the runtime details of the newly integrated application in order for the integrated application to execute in the cloud.

A base application e.g. App1 App2 might be updated by the software vendor. Such an update might not necessarily need to affect the sample application. As an example suppose that some few weeks after the deployment of the sample application the Mail application is enhanced to begin using SSL for mail transport. In this case the integrated application can be automatically redeployed by merely adding SSL credentials and details to the Mail section of all referencing applications.

In exemplary embodiments the determination of referencing applications can be performed by a dependency manager tool . Continuing with the example of adding SSL all referencing applications can be updated by merely adding SSL credentials and details to the Mail section of the Mail control widget. Further the dependency manager tool maintains inventory of applications that use a given a custom application. As depicted in a dependency manager tool runs on a cloud server. The dependency manager tool can be run as a background process that continuously monitors changes to the cloud infrastructure.

In a case such as earlier described a base application e.g. App1 App2 might be updated by the software vendor. Then using the interconnection of a second application to the base application the dependency manager tool fills in the runtime details of the application interconnections and interrelationships in order for it to successfully execute in the cloud. Strictly as an example if the Mail application enforces SSL for mail transport the application is automatically redeployed by the dependency manager by adding SSL credentials and details to the Mail section of all referencing applications. Further the dependency manager maintains inventory of applications that use a given application.

As shown a dependency manager tool is a process executing within a cloud server . The depicted dependency manager tool is partitioned into a change detection engine and a change merge engine . The change detection engine and change merge engine can cooperate so as to detect changes found across two or more versions of data comprising application interfacing details. For example application interfacing details might be compared against application interfacing details . In the event that changes are detected then a change merge engine can be employed to merge changes into an output data element such as application interfacing details .

The cloud server might also comprise an integration deployer tool which can interoperate cooperatively with other elements of the system. For example integration deployer tool can be configured to manage the relationships between an integrated application and its constituent application components.

As earlier indicated the rate at which software vendors release patches and or code updates has increased dramatically thus a process in the cloud e.g. within cloud server can serve to perform a periodic assessment of additions to the application inventory list and or changes to the application interfacing details. In some cases detected changes can be automatically applied in other cases detected changes can precipitate manual intervention.

As shown the integration deployer retrieves a tenant application inventory list from some moment in time T0 e.g. see tenant application inventory list and update the list to create an updated version e.g. tenant application inventory list .

As shown system comprises at least one processor and at least one memory the memory serving to store program instructions corresponding to the operations of the system. As shown an operation can be implemented in whole or in part using program instructions accessible by a module. The modules are connected to a communication path and any operation can communicate with other operations over communication path . The modules of the system can individually or in combination perform method operations within system . Any operations performed within system may be performed in any order unless as may be specified in the claims. The embodiment of implements a portion of a computer system shown as system comprising a computer processor to execute a set of program code instructions see module and modules for accessing memory to hold program code instructions to perform storing a first graphical object descriptor the first graphical object descriptor to identify at least one first application see module storing a first control object descriptor associated with the first graphical object descriptor the first control object descriptor to identify at least one interface to the first application see module storing a second graphical object descriptor the second graphical object descriptor to identify at least one second application see module storing a second control object descriptor associated with the second graphical object descriptor the second control object descriptor to identify at least one interface to the second application see module executing the first application and the second application on a computer at a first time wherein at least some outputs from the first application are processed using the first control object descriptor to produce first application results and at least some of the first application results are received by the second application see module . Some embodiments proceed to modify a behavior of the first application then executing the modified first application and the second application at a second time wherein at least some outputs from the modified first application are processed using the first control object descriptor to produce modified first application results and wherein at least some of the modified first application results are received by the second application.

According to one embodiment of the disclosure computer system performs specific operations by processor executing one or more sequences of one or more instructions contained in system memory . Such instructions may be read into system memory from another computer readable usable medium such as a static storage device or a disk drive . In alternative embodiments hard wired circuitry may be used in place of or in combination with software instructions to implement the disclosure. Thus embodiments of the disclosure are not limited to any specific combination of hardware circuitry and or software. In one embodiment the term logic shall mean any combination of software or hardware that is used to implement all or part of the disclosure.

The term computer readable medium or computer usable medium as used herein refers to any medium that participates in providing instructions to processor for execution. Such a medium may take many forms including but not limited to non volatile media and volatile media. Non volatile media includes for example optical or magnetic disks such as disk drive . Volatile media includes dynamic memory such as system memory .

Common forms of computer readable media includes for example floppy disk flexible disk hard disk magnetic tape or any other magnetic medium CD ROM or any other optical medium punch cards paper tape or any other physical medium with patterns of holes RAM PROM EPROM FLASH EPROM or any other memory chip or cartridge or any other non transitory medium from which a computer can read data.

In an embodiment of the disclosure execution of the sequences of instructions to practice the disclosure is performed by a single instance of the computer system . According to certain embodiments of the disclosure two or more computer systems coupled by a communications link e.g. LAN PTSN or wireless network may perform the sequence of instructions required to practice the disclosure in coordination with one another.

Computer system may transmit and receive messages data and instructions including programs e.g. application code through communications link and communication interface . Received program code may be executed by processor as it is received and or stored in disk drive or other non volatile storage for later execution. Computer system may communicate through a data interface to a database on an external data repository . A module as used herein can be implemented using any mix of any portions of the system memory and any extent of hard wired circuitry including hard wired circuitry embodied as a processor .

In the foregoing specification the disclosure has been described with reference to specific embodiments thereof. It will however be evident that various modifications and changes may be made thereto without departing from the broader spirit and scope of the disclosure. For example the above described process flows are described with reference to a particular ordering of process actions. However the ordering of many of the described process actions may be changed without affecting the scope or operation of the disclosure. The specification and drawings are accordingly to be regarded in an illustrative sense rather than restrictive sense.

