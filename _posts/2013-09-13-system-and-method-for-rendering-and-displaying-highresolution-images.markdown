---

title: System and method for rendering and displaying high-resolution images
abstract: One embodiment of the present invention sets forth a technique for displaying high-resolution images using multiple graphics processing units (GPUs). The graphics driver is configured to present one virtual display device, simulating a high-resolution mosaic display surface, to the operating system and the application programs. The graphics driver is also configured to partition the display surface amongst the GPUs and transmit commands and data to the local memory associated with the first GPU. A video bridge automatically broadcasts this information to the local memories associated with the remaining GPUs. Each GPU renders and displays only the partition of the display surface assigned to that particular GPU, and the GPUs are synchronized to ensure the continuity of the displayed images. This technique allows the system to display higher resolution images than the system hardware would otherwise support, transparently to the operating system and the application programs.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08854380&OS=08854380&RS=08854380
owner: NVIDIA Corporation
number: 08854380
owner_city: Santa Clara
owner_country: US
publication_date: 20130913
---
This application is a continuation application of United States application titled SYSTEM AND METHOD FOR RENDERING AND DISPLAYING HIGH RESOLUTION IMAGES filed on Dec. 6 2008 and having Ser. No. 11 952 089 now U.S. Pat. No. 8 537 166 which is hereby incorporated herein by reference.

The present invention relates generally to the field of graphics processing and more specifically to a system and method for rendering and displaying high resolution images.

A typical computing system includes a central processing unit CPU an input device a system memory one or more graphics processing units GPUs and one or more display devices. A variety of software application programs may run on the computing system. The CPU usually executes the overall structure of the software application program and configures the GPUs to perform specific tasks in the graphics pipeline the collection of processing steps performed to transform 3 D scenes into 2 D images . Components within the GPUs then transmit the 2 D images through video connectors and video cables to drive the display devices. For example a scanout unit within a GPU may transmit images through a digital video interface DVI connector and a video cable to drive a liquid crystal display LCD .

Each display device has a maximum resolution that determines the maximum number of pixels in each dimension that the display device may display. Similarly each video connector has a maximum bandwidth that determines the maximum number of pixels that the video connector may transmit at a given frequency. Typically each GPU may drive at most two video connectors. To accommodate these hardware limitations some computing systems are configured to display high resolution images using multiple GPUs to transmit different portions of the images through multiple video connectors to one or more display devices. For example a computing system may include four GPUs four video connectors and four display devices that are arranged in close proximity to create the illusion of a single high resolution display surface. In such a computing system each of the four GPUs may be configured to transmit one quadrant of each rendered image frame through one of the video connectors to a corresponding display device.

However current systems are not well equipped to send high resolution images across multiple GPUs. For example in one approach the operating system and the application programs are configured to interact with each GPU separately. An application program may determine the appropriate visible pixels for each GPU and transmit graphics calls and graphics data to each of the GPUs. One drawback to this approach however is that each application program needs to be written specifically to handle multiple GPUs. Furthermore in such an approach the number of graphics calls and data that each application program transmits is proportional to the number of GPUs. Transmitting this quantity of data may reduce the performance of the computing system. In addition since the operating system perceives multiple independent GPUs the operating system may make assumptions that do not reflect the optimal behavior for the entire display surface. For example if a user maximizes a graphical window then the operating system may resize the window to fill only a single display device attached to one of the GPUs not all of the display devices.

In another approach the graphics driver may be configured to receive a single stream of graphics calls and data from each application generate the appropriate graphics commands for each of the GPUs and transmit the graphics commands and data to each of the GPUs. This solution eliminates the need for application programs to directly interact with the multiple GPUs. However although the quantity of graphics commands and data that each application program transmits is reduced the quantity of graphics commands and data that the graphics driver transmits is still proportional to the number of GPUs. Therefore the efficiency of the computing system may still be reduced. Furthermore this solution does not address the sub optimal behavior of the operating system relative to the display surface.

As the foregoing illustrates what is needed in the art is a more flexible and efficient technique for rendering and displaying high resolution images.

One embodiment of the present invention sets forth a method for rendering and displaying high resolution images. The method includes the steps of creating a mosaic display surface representing two or more physical display elements conveying a resolution of the mosaic display surface to an operating system in response to an operating system query partitioning the mosaic display surface among two or more processing units and configuring each of the two or more processing units to process graphics commands such that each processing unit renders and displays a different portion of a graphics image where each portion of the graphics image corresponds to a different partition of the mosaic display surface.

One advantage of the disclosed method is that since application programs perceive only a single high resolution virtual display device all application programs even those that do not support multiple display devices may create images that fully occupy all of the display devices. In addition since the operating system perceives only a single high resolution virtual display device the windowing behavior of the operating system is optimized for the corresponding mosaic display surface.

As shown the CPU connects to the input devices the system memory and the graphics processing system via the system bus . In alternate embodiments the system memory may connect directly to the CPU . The CPU receives user input from the input devices executes programming instructions stored in the system memory operates on data stored in the system memory and configures the graphics processing system to perform specific tasks in the graphics pipeline. The system memory typically includes dynamic random access memory DRAM used to store programming instructions and data for processing by the CPU and the graphics processing system . The graphics processing system receives instructions transmitted by the CPU and processes the instructions in order to render and display graphics images on the display devices .

The system memory includes an operating system one or more application programs an application programming interface API and a graphics driver . The operating system is typically the master control program of the computing system . Among other things the operating system manages the resources of the computing system such as the system memory and forms a software platform on top of which the application program s may run. The application program generates calls to the API in order to produce a desired set of results typically in the form of a sequence of graphics images. The application program also transmits one or more high level shading programs to the API for processing within the graphics driver . The high level shading programs are typically source code text of high level programming instructions that are designed to operate on components within the graphics processing system . The API functionality is typically implemented within the graphics driver . The graphics driver is configured to translate the high level shading programs into machine code shading programs that execute on components within the graphics processing system .

The graphics processing system executes commands transmitted by the graphics driver in order to render graphics data and images. Subsequently the graphics processing system may display certain graphics images on the display devices that are connected to the graphics processing system via the video cables . Each display device is an output device capable of emitting a visual image corresponding to an input graphics image. For example each display device may be built using a liquid crystal display LCD a cathode ray tube CRT monitor or any other suitable display system.

As shown in detail for the graphics processing subsystem each graphics processing subsystem includes a local memory a graphics processing unit GPU and a video connector . In alternative embodiments each graphics processing subsystem may include any number of GPUs and any number of video connectors . Each graphics processing subsystem may be provided with any amount of local memory including none. Further each GPU may use both the local memory in the corresponding graphics processing subsystem and the system memory in any combination for memory operations.

As shown in detail for the GPU each GPU includes a scanout unit SU . Within each graphics processing subsystem the SU is configured to scan graphical images from the local memory and then transmit these graphics images through one or more video connectors . Also within each graphics processing subsystem each SU may transmit digital or analog graphics images from the local memory directly through one or more video connectors . The video connectors in each graphics processing subsystem may convey the graphics images to the set of display devices that are attached to the particular graphics processing subsystem via a subset of the video cables . For example a SU may transmit digital graphics images from a local memory through a digital video interface DVI connector and a digital video cable to an LCD.

Each video connector may be any connector such as a DVI connector or a video graphics array VGA connector capable of passing graphics image through one or more of the video cables to one or more of the display devices . In some embodiments each video connector may attach to more than one display device . Similarly any subset of the video connectors in the graphics processing system may attach to a single display device . For example four video connectors may connect four graphics processing subsystems via four video cables to a sixty four inch LCD which includes four DVI inputs.

As described in greater detail herein to render and display high resolution images the graphics driver may create a high resolution mosaic display surface that is driven by multiple GPUs . The graphics driver may partition the mosaic display surface amongst the GPUs and then configure each GPU to render and display only the portion of a particular graphics image included in the partition of the mosaic display surface assigned to that specific GPU . The mosaic display surface may include the display surfaces of the display devices organized in any technically feasible fashion. For example the display devices may be arranged in close proximity to simulate the high resolution mosaic display surface. In alternate embodiments the mosaic display surface may include the display surfaces associated with any display elements such as the video connectors . Further the graphics driver may determine the distribution of the display surface amongst the GPUs and the resolution of the mosaic display surface in any technically feasible fashion. For example a graphical interface not shown may be used to assign a specific partition of the mosaic display surface to a particular GPU . In some embodiments the graphics driver may be configured to assign non overlapping partitions to each of the GPUs . In such a configuration the graphics driver may sum the resolutions of the display devices to obtain the resolution of the mosaic display surface. In other embodiments the graphics driver may be configured to assign slightly overlapping partitions to each of the GPUs thereby smoothing the visual transition between adjacent display devices . In such a configuration the graphics driver may subtract the overlapped pixels from the sum of the resolutions of the display devices to obtain the resolution of the mosaic display surface. In other embodiments the graphics driver may also factor in distortion in how it apportions a mosaic display surface across multiple GPUs.

Referring back now to before the CPU configures the graphics processing system to render and display graphics images the operating system may determine the number and resolution of the display devices driven by the graphics processing system . The operating system may obtain this information by querying the graphics driver and subsequently relays this information to the application programs . The graphics driver is specifically configured to inform the operating system that the graphics processing system is connected to a single virtual display device with a resolution corresponding to the resolution of the mosaic display surface rather than being connected to multiple separate display devices as is done in prior art approaches. Configuring the graphics driver in this fashion enables the operating system and the application programs to fully utilize the entire mosaic display surface while remaining unaware of the physical implementation of the mosaic display surface i.e. the number of display devices making up the mosaic display surface .

Since the built in behavior of an operating system is typically optimized for a single display device and the operating system perceives only a single virtual display device the behavior of the operating system is optimized to target the mosaic display surface . For example if a user maximizes a graphics window then the operating system may resize the graphics window to fill the single virtual display device thereby filling all of the display devices included in the mosaic display surface . Similarly graphics calls emitted by the application programs may automatically target the entire mosaic display surface . Therefore the functionality of the graphics driver in presenting only the mosaic display surface to the operating system enables the operating system to behave in an optimized manner.

The graphics driver may communicate with the graphics processing system using a stream of commands called a push buffer. The graphics driver may use the push buffer to partition the mosaic display surface amongst the GPUs . For example the graphics driver may insert a set device mask command into the push buffer to assign subsequent commands to a particular GPU . If a particular GPU is not the target of a set device mask command then the GPU will ignore subsequent commands in the push buffer until another set device mask command targets that particular GPU . After inserting a set device mask command into the push buffer to select a single GPU the graphics driver may assign a specific partition of the mosaic display surface to be rendered by that particular GPU and displayed by the SU in that particular GPU by inserting a set clip rectangle command into the push buffer. In this fashion the graphics driver may insert set device mask and set clip rectangle commands into the push buffer to configure each of the GPUs to render and display only the specific partition of the mosaic display surface that is assigned to that particular GPU .

The graphics driver may also use the push buffer to configure the graphics processing system to implement the graphics calls from the application programs not shown in . After initializing the rendering and display partitions the graphics driver may insert a final set device mask command and a subsequent everyone command into the push buffer. These two commands configure all of the GPUs to execute all subsequent commands in the push buffer. The graphics driver may then configure the push buffer to implement the set of graphics commands corresponding to the graphics calls from the application programs . Again the applications programs are aware of only a single mosaic display surface and therefore the applications programs may emit graphics calls that target the entire mosaic display surface . However since the graphics driver has partitioned the mosaic display surface amongst the GPUs each of the GPUs may process the same push buffer rendering and displaying only the partition of the mosaic display surface assigned to that particular GPU . In alternate embodiments the graphics driver may communicate with the graphics processing system in any technically feasible manner such as inserting different commands into the push buffer or employing a communication technique other than a push buffer.

Referring back now to the video bridge may be configured to synchronize the scan out and frame flipping of the SUs in the graphics processing system . This synchronization may avoid flickering and tearing the graphics images displayed on the display devices . The video bridge may accomplish this synchronization in any technically feasible fashion. For example the video bridge may be configured to transmit a horizontal synchronization signal a vertical synchronization signal and a frame swap signal to coordinate the SUs . In other embodiments the video bridge may be replaced with core logic that is configured to provide similar functionality. The core logic may be included in a chip set disposed between the CPU and the graphics processing subsystems .

Within each graphics processing subsystem the display buffer stores data for at least one two dimensional surface that may be used to drive the display device that is attached to the graphics processing subsystem . Furthermore each display buffer may include more than one two dimensional surface so that each GPU can render to one two dimensional surface while another two dimensional surface is used to drive the attached display device . The graphics driver may allocate enough memory to store the entire mosaic display surface in each of the display buffers . However within each graphics processing subsystem as detailed above each GPU may be configured to render only the partition of the mosaic display surface that is assigned to the particular GPU . Similarly the SU included in each GPU is configured to display only the partition of the mosaic display surface that is assigned to that particular GPU .

As detailed above in conjunction with the graphics driver may communicate with the graphics processing system using the push buffers . Within each graphics processing subsystem the GPU may be configured to process graphics commands in the push buffer included in the local memory . For example within the graphics processing subsystem the GPU may be configured to process graphics commands in the push buffer included in the local memory . Similarly within the graphics processing subsystem the GPU may be configured to process graphics commands in the push buffer included in the local memory . The graphics driver may store in the storage buffers other graphic data received from the application programs and used by GPUs .

The video bridge may be configured to minimize the quantity of graphics commands and graphics data transmitted from the graphics driver to the graphics processing system via the system bus using a technique known as broadcast mode. In broadcast mode the video bridge may be configured such that any information that the graphics driver writes to the local memory associated with the first GPU is automatically reflected in the local memories through N associated with the remaining GPUs through N . As detailed below these memory copies are accomplished in hardware and bypass the system bus . Advantageously only one set of graphics commands and graphics data is transmitted via the system bus thereby reducing the amount of information that has to flow through the system bus . For example the graphics driver may write graphics commands to the push buffer . With broadcast mode these graphics commands will automatically be reflected in the remaining push buffers through N. Similarly the graphics driver may write graphics data received from the application programs to the storage buffers . Again in broadcast mode this graphics data will automatically be reflected in the remaining storage buffers through N. However data written by components within each graphics processing subsystem such as data written from the GPU to the display buffer is not replicated amongst the other graphics processing subsystems .

The broadcast mode may be implemented in any technically feasible fashion. For example the graphics driver may program values e.g. addresses stored in remap registers and translation registers in the video bridge . The values in the remap registers may include addresses which define broadcast regions within the local memory such as the push buffer and the storage buffers . Similarly the values in the translation registers may include the base addresses of the corresponding regions in the local memories through N such as the push buffers through N and the storage buffers through N. Upon receiving a write access the video bridge is configured to evaluate the address associated with the write access in conjunction with the remap registers to determine if the access is within the broadcast regions. If the write access is within the broadcast regions then the video bridge uses the translation registers to determine the corresponding broadcast addresses. Subsequently the video bridge transmits the data associated with the write access to the address associated with the write access and also to any corresponding broadcast addresses. Therefore a single write access may be broadcast to write to each local memory thereby using less system bandwidth compared with separately writing to each local memory .

Again in alternative embodiments the video bridge may be replaced with core logic that is configured to provide similar functionality. The core logic may be included in a chip set disposed between the CPU and the graphics processing subsystems . Furthermore in other embodiments the video bridge may not be configured to implement the broadcast mode and the graphics driver may write the push buffer to each of the local memories .

As shown the method begins at step where the graphics driver creates a high resolution mosaic display surface and determines the resolution of the mosaic display surface. As detailed above in conjunction with the graphics driver may determine the resolution of the mosaic display surface using the resolutions of the display devices connected to the graphics processing system . In step the operating system queries the graphics driver to determine the number and resolution of the display devices connected to the graphics processing system . Since the graphics driver is configured to render and display images on the mosaic display surface the graphics driver conveys to the operating system that the graphics processing system includes a single virtual display device which has a resolution corresponding to the resolution of the mosaic display surface. The graphics driver does not convey any information about the physical display devices to the operating system . Thereafter the operating system behaves as though there is only a single high resolution virtual display device attached to the graphics processing system . In step the operating system conveys the display information received from the graphics driver in step to the application programs . Again the application programs subsequently behave as though there is only a single high resolution virtual display device attached to the graphics processing system . In step the graphics driver allocates enough storage space in each of the display buffers to contain the entire mosaic display surface.

In step the graphics driver partitions the mosaic display surface amongst the GPUs . Further the graphics driver configures each GPU to render and display only the partition of the mosaic display surface assigned to that particular GPU . The graphics driver may configure the GPUs in any technically feasible fashion. Note that a series of method steps that may be used to accomplish step is described in greater detail below in steps of . In step the graphic driver configures each GPU to process all subsequent graphics commands. Although each GPU may process the same graphics commands each GPU will render and display only the partition of the mosaic display surface assigned to that particular GPU in step . Again this step may be accomplished in any technically feasible fashion. For example one way to accomplish this step is described in step of .

In step each application program emits a single graphics stream including both graphics calls and graphics data. Advantageously each application program may emit graphics calls that target the entire mosaic display surface. In step the graphics driver processes the graphics calls generates corresponding graphics commands and writes the graphics commands and the graphics data to the local memory associated with the GPU . The GPU then executes the graphics commands and operates on the graphics data in the local memory . Again this step may be accomplished in any technically feasible fashion. For example one way to accomplish this step is described in step of . In step the video bridge broadcasts the graphics commands and data written by the graphics driver to the local memory to the local memories through N associated with the GPUs through N. The GPUs through N then execute the graphics commands and operate on the graphics data in their corresponding local memories through N. In step the video bridge synchronizes the SUs horizontally vertically and by frame to ensure continuity of the images displayed on the display devices included in the mosaic display surface.

As shown the method begins at step where the graphics driver creates the push buffer . In step the graphics driver sets a current GPU index to one. In step the graphics driver inserts a set device mask command followed by the GPU index into the push buffer . As detailed above in conjunction with this pair of commands configures the GPU associated with the GPU index in this case one to execute the subsequent commands in the push buffer . This pair of commands also configures the other GPUs to ignore the commands in the push buffer until a new set device mask command is encountered. In step the graphics driver inserts a set clip rectangle and coordinates specifying the rectangular boundary of the partition of the mosaic display surface that is assigned to the GPU associated with the GPU index into the push buffer . This command configures the single GPU associated with the GPU index to render and display only the portions of graphics images that are included within the partition specified by the coordinates. At step the graphics driver compares the GPU index to the total number of GPUs included in the graphics processing system . If the graphics driver determines that the GPU index is smaller than the total number of GPUs included in the graphics processing system then the method proceeds to step where the graphics driver increments the GPU index and the method returns to step . The method continues in this fashion looping through steps until each of the GPUs has been configured to display and render a specific portion of the mosaic display surface.

At step if the graphics driver determines that the GPU index equals the total number of GPUs included in the graphics processing system then the method proceeds to step . In step the graphics driver inserts a set device mask command followed by everyone into the push buffer . As detailed above in conjunction with this pair of commands configures all the GPUs to execute all subsequent commands in the push buffer . In step the graphics driver processes graphics calls received from the application programs and inserts a set of corresponding graphics commands into the push buffer . Advantageously each GPU may process the same push buffer rendering and displaying only the partition of the mosaic display surface assigned to that particular GPU .

In sum high resolution images may be efficiently rendered and displayed by creating a high resolution mosaic display surface and partitioning the display surface amongst multiple GPUs. In one embodiment the computing system includes a single graphics driver multiple GPUs a video bridge and one or more display devices arranged to depict a single high resolution mosaic display surface. In operation the graphics driver presents only one virtual display device simulating the mosaic display surface to the operating system and consequently to the applications programs. However unknown to the operating system and the applications programs the graphics driver inserts initialization commands into the push buffer to partition the mosaic display surface amongst the various GPUs. As the application programs generate graphics calls targeted to the mosaic display surface the graphics driver inserts a set of corresponding graphics commands into the push buffer. The graphics driver is configured to write the push buffer and the associated graphics data only once into the local memory associated with the first GPU. The video bridge is configured such that any data the graphics driver writes to the local memory associated with the first GPU is automatically reflected in the local memories associated with the remaining GPUs a configuration known as broadcast mode. Each GPU processes their local copy of the same push buffer rendering and displaying only the partition of the display surface assigned to that particular GPU via the corresponding graphics commands. The video bridge synchronizes the GPUs horizontally vertically and by frame to ensure the continuity of the displayed images.

Advantageously since the application programs perceive only a single high resolution virtual display device all application programs even those that do not support multiple display devices may create images that fully occupy all of the display devices. Furthermore because of the broadcast mode functionality the amount of graphics information transmitted by the applications programs and the graphics driver over the system bus does not increase as additional GPUs are added. Therefore additional display resolution may be added to the computing system without impacting the overall performance of the computing system. Finally since the operating system perceives only a single high resolution virtual display device the windowing behavior of the operating system is optimized for the corresponding mosaic display surface. For example if a user maximizes a graphical window then the operating system will resize the window to fill all of the display devices included in the mosaic display surface.

While the forgoing is directed to embodiments of the present invention other and further embodiments of the invention may be devised without departing from the basic scope thereof. For example aspects of the present invention may be implemented in hardware or software or in a combination of hardware and software. One embodiment of the invention may be implemented as a program product for use with a computer system. The program s of the program product define functions of the embodiments including the methods described herein and can be contained on a variety of computer readable storage media. Illustrative computer readable storage media include but are not limited to i non writable storage media e.g. read only memory devices within a computer such as CD ROM disks readable by a CD ROM drive flash memory ROM chips or any type of solid state non volatile semiconductor memory on which information is permanently stored and ii writable storage media e.g. floppy disks within a diskette drive or hard disk drive or any type of solid state random access semiconductor memory on which alterable information is stored. Such computer readable storage media when carrying computer readable instructions that direct the functions of the present invention are embodiments of the present invention. Therefore the scope of the present invention is determined by the claims that follow.

