---

title: Secure key access with one-time programmable memory and applications thereof
abstract: A device includes a key store memory that stores one or more cryptographic keys. A rule set memory stores a set of rules for accessing the cryptographic keys. A key store arbitration module grants access to the cryptographic keys in accordance with the set of rules. The device can be used in conjunction with a key ladder. The device can include a one-time programmable memory and a load module that transfers the cryptographic keys from the one one-time programmable memory to the key store memory and the set of rules to the rule set memory. A validation module can validate the cryptographic keys and the set of rules stored in the key store and rule set memories, based on a signature defined by a signature rule.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09317449&OS=09317449&RS=09317449
owner: ViXS Systems, Inc.
number: 09317449
owner_city: Toronto
owner_country: CA
publication_date: 20131008
---
The present U.S. Utility Patent Application claims priority pursuant to 35 U.S.C. 120 as a continuation to the following U.S. Utility Patent Application which is hereby incorporated herein by reference in its entirety and made part of the present U.S. Utility Patent Application for all purposes 

This invention relates to generally devices that include memory and more particularly to securing access to the memory within the device.

The desire to keep video content of DVD s and or other copyrighted or proprietary information that is stored in a digital format secure from unauthorized use e.g. unauthorized copying distribution etc. is driven by a sector of the population that places little to no value on the intellectual properties rights of others. As such the battle between creating security systems for digital information and the hackers that attempt to break them continues.

This battle is intensifying with the integration of electronic device features being implemented on a single device e.g. computer with DVD functionality and is further intensified by video processing hardware being implemented as stand alone system on a chip SOC devices. In many instances the video processing hardware SOC uses an operating system that allows end users to write their own applications which means that the user s application may share the same processors and memory space as the security system. This makes the security operations vulnerable. To reduce the vulnerability video processing hardware needs to be constrained to performing only specific intended types of cryptographic operations.

In addition video processing devices which include the video processing hardware SOC are embedded with licensed secret keys for compliance with one or more of a plurality of video application standards e.g. BD DTCP CPRM Cable Card etc. . Typically such a video application standard includes a revocation mechanism whereby if a secret key value is made public the security functions of the compromised devices are revoked and the devices are rendered inoperable. As such it is highly desirable that the secret keys are stored in such a way that they are not accessible to the firmware of the device in order to avoid revocation . This is typically done by storing the secret keys in a one time programmable OTP memory.

While using OTP memory has become a primary mechanism for storing secret keys within video processing devices it is not a failsafe approach. For example a security issue arises when multiple cryptographic clients e.g. a hardware block that performs a specific cryptographic algorithm such as RSA TSD ECC DMA etc. . . . may issue read or write requests to the OTP memory asynchronously and that the requests are not atomic. In addition as a result of granularity associated with OTP memory large key values are partitioned into smaller blocks which have special read write rules that are imposed on every block. Thus it becomes necessary to associate a macro level restriction on cryptographic clients down to every micro level block access performed by the client.

As a specific example the RSA algorithm can perform a 2048 bit RSA operation which requires 32 reads of 64 bit blocks from the key store to assemble the exponent. If a key is intended to be used as a 2048 bit exponent then every 64 bit block read must be associated with the intended purpose of the key i.e. blocks have to have an attribute indicating which cryptographic client is permitted to access a particular block associated with a larger key.

Another security problem is that cryptographic strength often relies on using large keys e.g. up to 2048 bits for RSA or 256 bit for some AES modes . However if the large key is used one 64 bit block at a time by a weaker cryptographic client then large keys may be attacked 64 bits or less a time. Yet another way to attack large keys is to overwrite portions of the key with 0 s and then perform the intended operations but with the remainder of the weakened key. Every time a portion of the key is decimated in this way the remainder can be determined because portions of the key are now known.

Still further some cryptographic clients have the ability to perform operation at various levels of strength for example the RSA can be configured for variable size modulus or 3DES can be degraded into a DES operation. This can be exploited by a hacker to perform weaker operations and thereby attack large keys with degraded operations. Even further some cryptographic clients use control words CWs and initial vectors IVs within the security operations. The integrity of a security system may be attacked by using a CW as an IV in an operation where the clear text and the CW are known which could be used to reveal the CW value.

Another important aspect of maintaining the integrity of cryptographic operations is controlling the destination of the cryptographic operation results. For example content exported from the SOC poses a far greater risk than content which is retained within the SOC. Yet another mode of attack involves using a key a CW or an IV to decrypt content instead of encrypting the content. For example the intention may be to encrypt content however a hacker may use a key store value to decrypt the content.

In addition to the threat of hackers the security of the secure content information is at risk from unauthorized public disclosure. For example if a disgruntled employee posts the algorithm and location of the keys on the Internet the security of the algorithm is lost. As such the risk to security systems is not just from outsider breaking the security of the algorithm but also from an insider intentionally compromising the integrity of the security system.

Therefore a need exists for a security device architecture that at least partially overcomes one or more of the above mentioned security issues.

The processing module may be a single processing device or a plurality of processing devices. Such a processing device may be a microprocessor micro controller digital signal processor microcomputer central processing unit field programmable gate array programmable logic device state machine logic circuitry analog circuitry digital circuitry and or any device that manipulates signals analog and or digital based on hard coding of the circuitry and or operational instructions. The processing module may have an associated memory and or memory element which may be a single memory device a plurality of memory devices and or embedded circuitry of the processing module. Such a memory device may be a read only memory random access memory volatile memory non volatile memory static memory dynamic memory flash memory cache memory and or any device that stores digital information. Note that when the processing module implements one or more of its functions via a state machine analog circuitry digital circuitry and or logic circuitry the memory and or memory element storing the corresponding operational instructions may be embedded within or external to the circuitry comprising the state machine analog circuitry digital circuitry and or logic circuitry. Further note that the memory element stores and the processing module executes hard coded and or operational instructions corresponding to at least some of the steps and or functions illustrated in .

In an example of operation one or more of the IO interfaces receives an instruction to display a video file. The video file may be from a DVD stored in the hard disk and or flash memory received from a satellite receiver received from a cable set top box and or any other source of video content data. Note that the one or more of the IO interfaces and or may receive the video file. The video file is encrypted using a particular encryption program and one or more cryptographic keys as prescribed by one or more video standards.

In this example the processing module coordinates the retrieval of the video file from the main memory the hard disk and or flash memory the IO interface and or and or other source. The encrypted video file may include video data audio data video graphics data and or any other type of data requiring security. The processing module evokes a cryptographic client algorithm e.g. RSA DES etc. and retrieves a cryptographic key from a secure memory location e.g. a privileged memory . The secure memory location will be described below with reference to one or more of .

The processing module decrypts the encrypted data using the cryptographic client algorithm and the cryptographic key to produce decrypted data. The decrypted data is provided the graphics processing module . The video graphics processing module may be a video graphics card a video graphics engine a video graphics processor a combination thereof and or any other device for rendering video data. In this example the graphics processing module converts the decrypted data into video data and stores it in the graphics memory for subsequent display.

The video graphics display device has three classes of memory access. The most secure class allows access to the system memory e.g. main memory and or the hard disk and or flash memory and to IO devices via the IO interfaces and allows access to the graphics memory e.g. frame buffer and allows access to the secure memory location. The next level of secure access allows access to the system memory and to IO devices via the IO interfaces and . The third access level allows access to system memory.

The privileged memory section may be implemented using one or more one time programmable OTP memories RAM and or ROM. The OTP memory may be used to store a default set of the cryptographic keys and a rule set section . The key store section stores one or more cryptographic keys for one or more of the cryptographic clients in an OTP memory RAM and or ROM. The key store section may include memory blocks where one or more blocks store a cryptographic key. The rule set section stores rules for accessing the key store section . The various rules will be described in greater detail with reference to at least some of .

The device of also includes an arbitration module which may be part of the operation system stored in the privileged memory and or a separate module e.g. a stand alone state machine a stand alone processor etc. . Regardless of its location the arbitration module coordinates access to the key store section based on the rule set. In this manner access requests must come from authorized firmware components e.g. real cryptographic clients and the request must be in a specific manner based on the identity of the requestor as delineated in the rule set. If either fails e.g. unauthorized requestor e.g. firmware being manipulated by a hacker or invalid request manner the arbitration module will deny the request ignore the request or provide random data in response to the request.

With such an embodiment the security of a hardware system and the flexibility of a software system are substantially achieved. For instance by utilizing a single OTP to store permanent rules for accessing the keys the vulnerability of a software system is substantially avoided and the inflexibility of a hardware system which uses hard wired single function for a single standard is also substantially avoided.

If however at step the request is determined to be valid the method continues at step where the arbitration module interprets the request for access to the cryptographic key to produce an interpreted request. This will be described in greater detail with reference to . The method continues at step where the arbitration module accesses the rule set memory based on the interpreted request to retrieve a rule of the set of rules. An example of a rule will be described with reference to .

The method continues at step where the arbitration module grants access to the cryptographic key in accordance with the rule. Note that the rule set may indicate that the access is not to be granted as such in accordance with the rule includes denying the request ignoring the request or providing random data. The method continues at step where when access to the cryptographic key is granted the cryptographic client executes a cryptographic function regarding at least a portion of the cryptographic key to produce a cryptographic result.

The source section indicates an initiator of the cryptographic result and the destination section indicates where the cryptographic result will be sent. The valid sources and destinations include the system main memory the key store section the IO registers and or the graphics memory. The cryptographic algorithm being used may be identified as ANY NONE AES DES 3DES Multi 2 DVB C2 CSS MDMI HDCP 1394 M6 RSA ECC and or Register.

In an embodiment an adjacent rule may be used. For instance when a particular client initiates an encryption operation the Rule Store determines what Key blocks in the Key Store can be accessed. By the improvement a further bit is included in the Rules whereby when the Rule is implemented it determines the order in which the Key Store blocks may be accessed. More restrictively a particular sequence of blocks is prescribed. Less restrictively groups of Key Store blocks are accessed in a prescribed order.

In an embodiment the rule store section contains bit masks associated to Key Store blocks. The Bit Mapping for rules is as follows 

In this embodiment a rule is a group of bits e.g. 16 which dictates how a corresponding block e.g. 64 bits in the key store may be accessed. By default since all bits in the OTP default to 0 the blocks that have un initialized rules provide unlimited access i.e. no restrictions .

With respect to an adjacent rule it provides certain cryptographic clients the ability to write the result of a cryptographic operation back into the key store . This is may be useful in cases where the security system makes use of key ladders e.g. a structure where a key is used to decrypt an encrypted key the resulting decrypted key may then be used in a subsequent key ladder step or it may be used to decrypt content and where the key is used to decrypt content is itself the end product of several cryptographic operations. In this context the adjacent rule is used to enforce a particular order to be adhered to when deriving the key i.e. the 1key must be adjacent to step 1 which must be adjacent to step 2 etc. . . . where the last step of the ladder culminates with the key intended to decrypt content. Note that the adjacent rule field more than 1 bit to indicate a range of adjacent locations e.g. 5 bits to provide 32 adjacent locations . For example instead of the result or an operation being permitted to be written to just the next i.e. adjacent location the rule has extra bits allocated that define the permission to write the result to the next N blocks i.e. a plurality of adjacent locations . This adds flexibility when dealing with a multi stream system where multiple end keys are calculated using the same ladder.

If the request is valid the method continues at step where the arbitration module provides at least a portion of the cryptographic key to the cryptographic client. For example the key may be stored in multiple blocks and the arbitration module provides some or all of the blocks the cryptographic client in response to one request. The method continues at step where the cryptographic client executes the cryptographic algorithm utilizing the at least a portion of the cryptographic key on content data to produce encrypted data or decrypted data. Note that in an embodiment even though a cryptographic client may make multiple requests and get portions of the key it typically will use the entire key for a cryptographic operation.

If however the request is valid the method continues at step where the arbitration module provides access to a block of memory in the key store memory for the at least a portion of the cryptographic key for the cryptographic client. The method continues at step where the cryptographic client executes the cryptographic function to write the at least a portion of the cryptographic key into the block of memory.

The method branches at step depending on whether the type of cryptographic algorithm is in a class type of a plurality of class types. If not the method continues at step where the request is denied. If however the type is in a class the method continues at step where the arbitration module establishes a bit boundary corresponding to the class type for accessing the cryptographic key. For example If Algorithm ANY DES DVB C2 CSS M6 Multi 2 HDCP Register then the Key Store may be accessed on a 64 bit boundary If Algorithm AES 3DES ECC then the Key Store may be accessed on a 128 bit boundary If Algorithm RSA then the Key Store may be accessed on a 1024 bit boundary and If Algorithm NONE then the Key store may be not be accessed on any boundary.

There is an OTP programming Interface which corresponds to a set of registers which permit reading or write 64 bits at a time into a specific OTP block. For every block there are 2 bits of associated OTP memory i.e. the Read Lock Out Bits 0 . . . 255 and the Write Lock Out Bits 0 . . . 255. These bits default to 0 factory default and may be programmed one time to 1. Once the bit is set to 1 it may never be re programmed to a 0. When the corresponding read lock out bit is set form a 0 to a 1 then the associated 64 bit OTP block may never be read via the register interface. When the corresponding write lock out bit is set form a 0 to a 1 then the associated 64 bit OTP block may never be written via the register interface.

This is a fundamental interlock required to secure secret values into the hardware device. There are a few scenarios 

During the initial writing the cryptographic key to the key store memory at step from the OTP the copy may utilize an obfuscation function. For example blocks of 64 bits i.e. Block j which are to be written to the OTP i.e. OTP i are obfuscated using a function comprising symmetric binary operators OP n and a re mapping function i.e. j i j . The obfuscation function h may be defined as follows OTP OP Block 

The corresponding reverse obfuscation function h implemented between the OTP and the Key Store uses the following obfuscation function. KeyStore OTP OP Note that h is a j op j i mapping and h is a i op j j mapping which means that the bit ordering in the Block and the HKB are different i.e. if a hacker had access to the Block value and the HKB value then the bit ordering would not correspond.

An obfuscation key block may be a 64 bit pattern written into one or more blocks of the OTP. The obfuscation key block may default to 0x0 . . . 0 and may be programmed uniquely per chip or uniquely per customer or uniquely per product or may default to 0x0 . . . 0. In addition the obfuscation key block should have a similar number of 0 s as 1 s 10 i.e. non trivial value to ensure secure obfuscation.

The obfuscation functions may be used to secure the key store loading stage of secure key deployment. It allows for a secure way to embed keys in to OTP memory. This provides an important operational security mechanism which secures cryptographic values within the OTP and provides some security in the factory environment.

The privileged memory section which may be implemented using one or more one time programmable memories includes a privileged data section and a rule set section . The privileged data section stores data that is of a privileged nature and should not be accessible to a user of the device or to a hacker. Such data includes one or more cryptographic keys for one or more of the cryptographic clients other device security features etc. The privileged data section may include memory blocks where one or more blocks store a privileged data element. The rule set section stores rules for accessing the privileged data section .

The device of also includes an arbitration module which may be part of the operation system stored in the privileged memory and or a separate module e.g. a stand alone state machine a stand alone processor etc. . Regardless of its location the arbitration module coordinates access to the privileged data section based on the rule set. In this manner access requests must come from authorized firmware components e.g. real cryptographic clients operating system firmware functions other device security functions etc. and the request must be in a specific manner based on the identity of the requestor as delineated in the rule set. If either fails e.g. unauthorized requestor e.g. firmware being manipulated by a hacker or invalid request manner the arbitration module will deny the request ignore the request or provide random data in response to the request.

The method continues at step where the arbitration module determines whether the request is valid. This may be done by accessing the rule set based on the requestor and the type of request e.g. read privileged data and or to write privileged data . In addition the arbitration module may verify the format of the request to insure that includes a read write indication an address of the at least a portion of the privileged data and an indication regarding use of the privileged data. If any of these checks fail the request is invalid and the method proceeds to step via step where the request fails. If however the request is valid the method continues at step where the arbitration module interprets the request to produce an interpreted request. The interpretation will be described in greater detail with reference to . The method continues at step where the arbitration module grants access to the at least a portion of the privileged data in accordance with the rule.

A further embodiment may include an additional multi bit field for encrypt decrypt that specifies whether a cryptographic client is required to perform an encrypt or decrypt operation e.g. ANY 00 Encrypt 10 Decrypt 01 NONE 11 . A least constraining state is the 00 un programmed state and a most constraining state is 11 None .

Another embodiment may include increasing the size of the read and write algorithm field from 4 bits to 6 bits to specify 64 different algorithms which allows for many more algorithms to be added.

In another embodiment a skip function may be used to reduce the number of one time programming OTP steps required to populate the Key Store by loading one root key into the Key Store and then having the keys for other sections of the key ladder calculated from the root rather than having them all loaded during successive steps of the OTP process. In this way certain OTP steps are obviated.

In yet another embodiment a repeat function may be used to avoid redundancy. For instance the OTP block includes an indicator stored with certain of the Rules in the Rule Store to indicate whether that Rule is to be repeated to load it in other locations in the Key Store ladder. Once again this obviates the requirement of having an OTP step for every location in the Key Store ladder.

In a further embodiment an Encrypt Decrypt rule may be used. In particular a pair of bits are added to each Rule which signify that the client can encrypt and decrypt 00 that the client can do one of encrypt and decrypt 1 0 and 0 1 and that the client can copy but not encrypt or decrypt the result to another location in the Key Store.

In an additional embodiment the adjacency constraint can be expanded to define additional types such as CW Key IV Data Any None or other types.

In yet a further embodiment the type constraint can be expanded to define a range of adjacency not just the immediate next.

In the example shown an application utility or other software supplies encrypted key and encrypted codeword that are decrypted in the key ladder based on private exponent to generate codeword . The codeword is used in this example to descramble an encrypted audio video A V data such as from a transport stream de multiplexor TSD in digital video broadcast module to generate audio video data that can be written to a frame buffer memory.

In operation key store memory stores cryptographic keys of the key ladder. This can include prestored keys such as private exponent used by RSA module to extract key from encrypted key . In addition key store such as key store can store key and codeword generated in AES module by decrypting encrypted codeword based on key . Rule set memory such as rule set stores a set of rules for accessing the cryptographic keys of key store used in conjunction with the key ladder. Key store arbitration module such as arbitration module operates based on the rules in rules set memory to control access to key store memory . In particular arbitration module allows reading and writing the keys stored in key store memory only in accordance with the set of rules. Examples of such rules are set forth in conjunction with and otherwise while specific examples are presented below.

In a particular embodiment there is a different set of rules constraints for each of the three portions of the key store memory which dictate how values in that portion may be used. The definition of the ladder is based on rules which are hard coded into one time programmable memory OTP rather than being hard wired into a chip. These constraints enforce the specific sequence of operations which is equivalent to the security provided by a hard wired key ladder.

For instance private exponent portion of key store memory has constraints which enforce the value to be loaded from OTP Write Rule OTP the value may only be used by the RSA module Read Rule RSA the value may only be used as a Key Type Key the RSA operation must read a value E Key from the frame buffer Source FB and the result of the RSA calculation Key E Key EXP mod n must be written to the key store memory dest KS the RSA operation is a Decryption i.e. E D D the location of Key must be adjacent to the location of private exponent adjacent 1 .

Similarly the key portion of key store memory has constraints which enforce the value to be the result of an operation of RSA module Write Rule RSA the value may only be used by the AES module Read Rule AES the value may only be used as a Key Type Key the AES operation must read a value E CW from the frame buffer Source FB and the result of the AES calculation i.e. CW AES E CW Key must be written to the key store memory dest KS the AES operation must be a Decryption i.e. E D D the location of codeword must be adjacent to the location of key adjacent 1 .

In addition the codeword portion of the key store memory has constraints which enforce the value to be the result of an operation of AES module Write Rule AES the value may only be used by the DVB module Read Rule DVB the value may only be used as a Key Type Key the DVB operation must decrypt content received from an device i.e. source I O and the resulting decrypted content must be written to the frame buffer dest FB the DVB operation must be a Decryption i.e. E D D the CW may not be used to derive any further key store locations adjacent NONE .

The rules can also have fields which allow for de compression of rule set and key values when loading the rule set memory and key store memory . These constraints are referred to as the SKIP and REPEAT fields and generally permit 1 N mapping of OTP storage to key store memory and rule set memory . This allows for more optimum use of OTP . Examples of such fields are presented below 

As previously discussed device includes OTP for storing the prestored key or keys and the set of rules. Load module controls the loading of key store memory with the prestored key or keys and the rule set memory with the set of rules. In an embodiment of the present invention the set of rules includes a signature rule that defines at signature corresponding to at least one of the set of rules and the at least one cryptographic key. The validation module validates based on the signature the loading of the prestored keys in the key store memory and or the loading of the rule set memory . Further details regarding this aspect of the invention will be discussed in conjunction with that follow.

While shown in conjunction with descrambling of broadcast A V data the key ladder shown could likewise be used for encrypting or decrypting other media data multimedia data or other data to be protected. In particular nearly all CA and DRM systems may be expressed as a key ladder i.e. they may have more or less stages and or may use different specific algorithms . The reason for this is that such security systems are based on a root of trust philosophy where trust is propagated though various stages from most trusted to less trusted. A key ladder is a natural extension of standard cryptographic philosophy. There are proprietary systems which operate with Smart Cards or Cable Cards and use secret algorithms and undocumented protocols and are usually associated with set top boxes distributed by Broadcasters where the CA system is used to control access to only valid customers. On the other hand DRM systems are generally based on published standards like AACS DTCP CPRM etc. These systems use standard published algorithms and licensed device keys and are usually associated with consumer electronics devices like players or networked devices which are distributed as retail devices. One thing CA and DRM systems have in common is that they can both be expressed as a key ladder i.e. they have a root key usually stored in Non Volatile Memory which is used to cryptographically qualify derived intermediate keys which are then used to qualify final keys which are used to de scramble A V content.

An obvious point of attack is the storage of rules and keys. Procedures are put in place to protect against hackers modifying or adding rules or keys. During the loading process load module reads the OTP and determines the number of rules M extracts the signature from the signature rule and then copies the rule set into the rule set memory . Along with the rules the load module will also determine the number of prestored keys N and load the prestored keys into the key store memory . When complete the load module will report the number of rules M and keys N which have been loaded to software . After the loading is complete the validation module will receive the signature value from the load module and perform a hardware hash check. For example the load module can evaluate the signature of the key store memory and the rule store memory and compare it against the signature embedded within the signature rule. If the two signatures do not match the validation module can take action to disable access to the keys and the rule set e.g. erase the key store memory and the rule set memory .

If the keys and rule set are validated the validation module will also make the signature value available to a software function to perform a software hash check. The software function can be a separate utility or embedded in the operating system an application or in other software. Software can be implemented as a process on a single SOC that includes the other components presented in conjunction with or can run on another device. Software reads the signature calculated by the load module the number of rules M and number of keys N and uses this information to construct a message digest and perform a asymmetric signature of the contents of the key store memory and rule set memory . For example an RSA based signature check may be defined as 

This mechanism allows a trusted authority to define correct signature and number of rules and keys have been processed i.e. to prevent hackers from altering or adding rules or keys . If this second signature check fails then the software takes action to disable the system. Note there are various possible hash functions and various possible asymmetrical functions which may be used.

The device architecture of the present invention also provides the option to implement multiple CA and DRM systems on the same system on a chip SOC . This is an important distinction where a customer could field a system containing a single SOC which is provisioned with keys and key ladders which implement more than one CA or DRM system. This provides the customer with a remarkable economy and flexibility since the CA DRM systems can share resources and co exist at the same time.

It is common in the CA industry to have breaches of security. The typical response in this situation in prior art removable CA systems is to distribute new smart cards or cable cards to customers. These removable CA systems typically implement a new key ladder or contain new keys. In the system of the present invention an End of Rules rule can be implemented that defines un programmed space in the rule and key areas of the OTP . In the case of a security breach it is feasible to download new rules and new keys to update the OTP of previously fielded SOC chips in effect downloading a new CA or DRM system to previously fielded systems. This provides the customer with a remarkable economy and flexibility since the CA DRM systems can be renewed without a large expense. The Renewed CA or DRM system may be downloaded to fielded products via various communication channels for example Cable Satellite Terrestrial RF links the Internet or via media such as DVD s and BD disks .

It is also common to selectively disable fielded products usually because they have been identified as being used by hackers this is referred to as revocation. Since the architecture of the present invention is based on the contents of OTP and these contents can be used to record unique chip ID s. It is possible to identify and disable individual SOC devices. The hard coded key ladder approach provides new methods for revoking devices i.e.

In effect since the architecture of the present invention support renewability this creates new and flexible methods for revoking SOC s.

In optional step the number of rules in the set of rules is determined along with the number of cryptographic keys. The first signature and the number of rules in the set of rules stored in the rule set memory and the number of cryptographic keys stored in the key store memory are passed for further validation such as a second security check.

In an embodiment of the present invention step includes determining a second signature based on the set of rules stored in the rule set memory and the at least one cryptographic key stored in the key store memory comparing the first signature to the second signature and determining the failed validation when the second signature does not match the first signature.

As may be used herein the terms substantially and approximately provides an industry accepted tolerance for its corresponding term and or relativity between items. Such an industry accepted tolerance ranges from less than one percent to fifty percent and corresponds to but is not limited to component values integrated circuit process variations temperature variations rise and fall times and or thermal noise. Such relativity between items ranges from a difference of a few percent to magnitude differences. As may also be used herein the term s coupled to and or coupling includes direct coupling between items and or indirect coupling between items via an intervening item e.g. an item includes but is not limited to a component an element a circuit and or a module where for indirect coupling the intervening item does not modify the information of a signal but may adjust its current level voltage level and or power level. As may further be used herein inferred coupling i.e. where one element is coupled to another element by inference includes direct and indirect coupling between two items in the same manner as coupled to . As may even further be used herein the term operable to indicates that an item includes one or more of power connections input s output s etc. to perform when activated one or more its corresponding functions and may further include inferred coupling to one or more other items. As may still further be used herein the term associated with includes direct and or indirect coupling of separate items and or one item being embedded within another item. As may be used herein the term compares favorably indicates that a comparison between two or more items signals etc. provides a desired relationship. For example when the desired relationship is that signal has a greater magnitude than signal a favorable comparison may be achieved when the magnitude of signal is greater than that of signal or when the magnitude of signal is less than that of signal .

The present invention has also been described above with the aid of method steps illustrating the performance of specified functions and relationships thereof. The boundaries and sequence of these functional building blocks and method steps have been arbitrarily defined herein for convenience of description. Alternate boundaries and sequences can be defined so long as the specified functions and relationships are appropriately performed. Any such alternate boundaries or sequences are thus within the scope and spirit of the claimed invention.

The present invention has been described above with the aid of functional building blocks illustrating the performance of certain significant functions. The boundaries of these functional building blocks have been arbitrarily defined for convenience of description. Alternate boundaries could be defined as long as the certain significant functions are appropriately performed. Similarly flow diagram blocks may also have been arbitrarily defined herein to illustrate certain significant functionality. To the extent used the flow diagram block boundaries and sequence could have been defined otherwise and still perform the certain significant functionality. Such alternate definitions of both functional building blocks and flow diagram blocks and sequences are thus within the scope and spirit of the claimed invention. One of average skill in the art will also recognize that the functional building blocks and other illustrative blocks modules and components herein can be implemented as illustrated or by discrete components application specific integrated circuits processors executing appropriate software and the like or any combination thereof.

