---

title: Predictive pre-decoding of encoded media item
abstract: Displaying a plurality of encoded media items on a device includes: detecting that a first scrolling action has been completed; determining a predicted next encoded media item to be displayed; obtaining the predicted next encoded media item from a first memory; pre-decoding the predicted next encoded media item to generate a pre-decoded media item; storing the pre-decoded media item in a second memory, the second memory having lower latency than the first memory; receiving an indication that a second scrolling action has begun; and in response to the second scrolling action, displaying the pre-decoded media item via a display interface.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09377940&OS=09377940&RS=09377940
owner: Facebook, Inc.
number: 09377940
owner_city: Menlo Park
owner_country: US
publication_date: 20130228
---
Mobile devices such as smartphones have become ubiquitous. Popular applications such as Instagram allow users to share and view photos via their mobile devices. Users often want to view a large number of photos on their devices quickly by scrolling through the images. However mobile devices currently tend to have limited amounts of memory which can lead to performance issues. When a user attempts to view tens or even hundreds of photos using a mobile device the processing time required can prevent photos from being displayed instantaneously. For example on Android operating system based smartphones the operating system will only maintain a few most recently accessed images in memory and evict older image bitmaps from memory as a part of the memory management scheme. The evicted bitmaps would need to be reprocessed and loaded back into memory when needed resulting in a jittery display of images when the user scrolls through the images. Better management and display of images is needed to provide a more satisfying user experience when scrolling through photos.

The invention can be implemented in numerous ways including as a process an apparatus a system a composition of matter a computer program product embodied on a computer readable storage medium and or a processor such as a processor configured to execute instructions stored on and or provided by a memory coupled to the processor. In this specification these implementations or any other form that the invention may take may be referred to as techniques. In general the order of the steps of disclosed processes may be altered within the scope of the invention. Unless stated otherwise a component such as a processor or a memory described as being configured to perform a task may be implemented as a general component that is temporarily configured to perform the task at a given time or a specific component that is manufactured to perform the task. As used herein the term processor refers to one or more devices circuits and or processing cores configured to process data such as computer program instructions.

A detailed description of one or more embodiments of the invention is provided below along with accompanying figures that illustrate the principles of the invention. The invention is described in connection with such embodiments but the invention is not limited to any embodiment. The scope of the invention is limited only by the claims and the invention encompasses numerous alternatives modifications and equivalents. Numerous specific details are set forth in the following description in order to provide a thorough understanding of the invention. These details are provided for the purpose of example and the invention may be practiced according to the claims without some or all of these specific details. For the purpose of clarity technical material that is known in the technical fields related to the invention has not been described in detail so that the invention is not unnecessarily obscured.

Displaying a plurality of encoded media items on a device is disclosed. The encoded media items can be for example image files in Joint Photographic Experts Group JPEG or other compressed formats. In some embodiments the encoded media items are decoded and displayed when the user makes a request for a scrolling action. When the scrolling action stops a predicted next encoded media item to be displayed is determined. The predicted next encoded media item is fetched from a first memory component such as a disk a secure digital SD card a flash drive or the like. The predicted next encoded media item is pre decoded e.g. from JPEG into bitmap and the decoded media item is stored in a second memory component such as random access memory RAM . When an indication that a second scrolling action has begun is received the decoded media item is displayed. Because the pre decoded data is stored in the second lower latency memory displaying the decoded media item in response to the second scrolling action does not incur significant processing overhead and results in smooth display of the items and a pleasing user experience.

Processor is coupled bi directionally with memory which can include for example one or more random access memories RAM and or one or more read only memories ROM . As is well known in the art memory can be used as a general storage area a temporary e.g. scratch pad memory and or a cache memory. Memory can also be used to store input data and processed data as well as to store programming instructions and data in the form of data objects and text objects in addition to other data and instructions for processes operating on processor . Also as is well known in the art memory typically includes basic operating instructions program code data and objects used by the processor to perform its functions e.g. programmed instructions . For example memory can include any suitable computer readable storage media described below depending on whether for example data access needs to be bi directional or uni directional. For example processor can also directly and very rapidly retrieve and store frequently needed data in a cache memory included in memory .

A removable mass storage device provides additional data storage capacity for the computer system and is optionally coupled either bi directionally read write or uni directionally read only to processor . A fixed mass storage can also for example provide additional data storage capacity. For example storage devices and or can include computer readable media such as magnetic tape flash memory PC CARDS portable mass storage devices such as hard drives e.g. magnetic optical or solid state drives holographic storage devices and other storage devices. Mass storages and or generally store additional programming instructions data and the like that typically are not in active use by the processor . It will be appreciated that the information retained within mass storages and can be incorporated if needed in standard fashion as part of memory e.g. RAM as virtual memory.

In addition to providing processor access to storage subsystems bus can be used to provide access to other subsystems and devices as well. As shown these can include a display a network interface an input output I O device interface an image processing device as well as other subsystems and devices. For example image processing device can include a camera a scanner etc. I O device interface can include a device interface for interacting with a touchscreen e.g. a capacitive touch sensitive screen that supports gesture interpretation a microphone a sound card a speaker a keyboard a pointing device e.g. a mouse a stylus a human finger a Global Positioning System GPS receiver an accelerometer and or any other appropriate device interface for interacting with system . Multiple I O device interfaces can be used in conjunction with computer system . The I O device interface can include general and customized interfaces that allow the processor to send and more typically receive data from other devices such as keyboards pointing devices microphones touchscreens transducer card readers tape readers voice or handwriting recognizers biometrics readers cameras portable mass storage devices and other computers.

The network interface allows processor to be coupled to another computer computer network or telecommunications network using a network connection as shown. For example through the network interface the processor can receive information e.g. data objects or program instructions from another network or output information to another network in the course of performing method process steps. Information often represented as a sequence of instructions to be executed on a processor can be received from and outputted to another network. An interface card or similar device and appropriate software implemented by e.g. executed performed on processor can be used to connect the computer system to an external network and transfer data according to standard protocols. For example various process embodiments disclosed herein can be executed on processor or can be performed across a network such as the Internet intranet networks or local area networks in conjunction with a remote processor that shares a portion of the processing. Additional mass storage devices not shown can also be connected to processor through network interface .

In addition various embodiments disclosed herein further relate to computer storage products with a computer readable medium that includes program code for performing various computer implemented operations. The computer readable medium includes any data storage device that can store data which can thereafter be read by a computer system. Examples of computer readable media include but are not limited to magnetic media such as disks and magnetic tape optical media such as CD ROM disks magneto optical media such as optical disks and specially configured hardware devices such as application specific integrated circuits ASICs programmable logic devices PLDs and ROM and RAM devices. Examples of program code include both machine code as produced for example by a compiler or files containing higher level code e.g. script that can be executed using an interpreter.

The computer system shown in is but an example of a computer system suitable for use with the various embodiments disclosed herein. Other computer systems suitable for such use can include additional or fewer subsystems. In some computer systems subsystems can share components e.g. for touchscreen based devices such as smart phones tablets etc. I O device interface and display share the touch sensitive screen component which both detects user inputs and displays outputs to the user . In addition bus is illustrative of any interconnection scheme serving to link the subsystems. Other computer architectures having different configurations of subsystems can also be utilized.

In the example shown encoded media items e.g. images are stored on first memory . These media items may be downloaded from a server or other designated storage location. The media items can be encoded in a variety of formats for purposes of compression security etc. For example the media items can be in a compressed format such as Joint Photographic Experts Group JPEG files. In some embodiments a set of media items referred to as a feed to be downloaded are specified using JavaScript Object Notation JSON . The JSON file lists the items in the order they are stored on the server with universal resource locators URLs linked to the locations of the items. When the user wishes to view a feed on his device the image viewing application sends a request to the server which sends the JSON file to the application. The application creates queues to retrieve the encoded media items from the locations listed in the URLs and stores them on the first memory.

Second memory is divided into an application heap e.g. Java heap in Android based devices and a system heap e.g. native heap in Android based devices . In some embodiments the operating system heap provides facilities for managing the second memory. For example for Android enabled devices Anonymous Shared Memory ashmem and related application programming interfaces APIs are used by the operating system to manage shared memory on the system heap.

When the application needs to display a media item an API call is made. The API call is allowed to access application heap . If the decoded form of the media item e.g. the bitmap image data is already available in system heap it is copied from system heap into application heap and displayed according to the API call. If however the decoded form is not yet available in system heap the corresponding encoded media item e.g. the JPEG file is retrieved from first memory decoded and stored in system heap transferred to application heap and displayed. Since the size of the system heap tends to be small and can only store a small number of bitmaps in its cache the operating system can evict any bitmap that has not been recently used from system heap to make room for new bitmaps. If an evicted bitmap is needed again its corresponding JPEG file would need to be reloaded from first memory and decompressed again. Thus when the user is scrolling through the images there can be a time lag in displaying the images due to the time required for loading and decompression causing the user to be unable to view the image instantaneously. The delayed display of the image also referred to as stutter results in a poor user experience.

To improve the user experience of scrolling and viewing media items an image warming technique is employed where a prediction of which media item will be displayed next is made and the predicted item is pre decoded so that it is available in the system heap before the user requests it. is an embodiment of a process for displaying a plurality of encoded media items on a device. Process can be implemented on a device such as device . Preferably process is performed by the User Interface UI thread to ensure that decoding and displaying of the next media item is completed before other actions are allowed to proceed.

At it is detected that a first scrolling action has been completed. In some embodiments the user performs a scrolling action by swiping a finger across the touch sensitive screen. The UI thread detects that the scrolling action has been completed when it is detected that the user s finger is lifted from the screen. Images are displayed based on the sequence in which they are stored at the original storage location e.g. the server . Standard APIs control which images are displayed in response to the first scrolling action according to the distance and speed of the swipe. For example when the user scrolls down the images are displayed in the same order as they are stored when the user scrolls up the images are displayed in the reverse order as they are stored. The user may also scroll diagonally to navigate a two dimensional layout of the images.

At a predicted next encoded media item to be displayed is determined. In some embodiments the prediction depends on the direction of the first scrolling action. Based on the current position i.e. the position of the media item at which scrolling stopped the next media item in the direction of the first scrolling action is the predicted next item to be displayed.

At the predicted next encoded media item is obtained from a first memory. For example referring to the JPEG image that corresponds to the predicted next encoded media item is obtained from memory . In cases where multiple predicted next encoded media items are determined these items are obtained from the first memory.

At the predicted next encoded media item is pre decoded i.e. decoded before any request to display the item is received to generate a pre decoded media item. For example the retrieved JPEG image is uncompressed into a bitmap image.

At the pre decoded media item is stored in a second memory. For example referring to the bitmap image is stored in memory .

At an indication that a second scrolling action has begun is received. In some embodiments the indication corresponds to an event that is initiated upon the start of the second scrolling action.

At it is determined if the next item to be displayed in response to the second scrolling action matches the predicted next item. If so at the pre decoded media item that is stored in the second memory is retrieved and displayed in response to the second scrolling action otherwise at the next item to be displayed which is not necessarily pre decoded in response to the second scrolling action is determined and displayed.

Although the above process describes predicting a single next item in some embodiments multiple predicted next encoded media items to be displayed are determined retrieved decoded and displayed.

At the position of the last media item that was decoded and displayed in response to the first scrolling action is determined.

It is assumed that when a user scrolls to view the media items he will often scroll in the same direction as he has been. At based on the position of the last decoded item and the display layout and following the direction of the first scrolling action the position s of the next M media item s is are determined. Assume that the position of the last media item is N then the positions of the next M media items are N 1 . . . N M. The value of M is an integer greater or equal to 1. The next M media items can be the predicted next encoded media items if 400 is used to implement step or the next M media items to be displayed if 400 is used to implement step .

The value of M is configurable. In some embodiments the value of M is determined empirically or based on system memory availability in some embodiments. While a high M is desirable for buffering a greater number of bitmap images in memory cache and minimizing delays in displaying the images too high an M can cause recently displayed media items to be evicted from memory cache leading to display stutter should the user reverse scrolling direction. Thus in some embodiments the value of M is chosen such that the probability of the last decoded and displayed image to be evicted from memory cache or equivalently the probability of encountering display stutter when scrolling direction is reversed is below some threshold. In the following discussion it is assumed that M 1 although other values of M can be used.

Process is further explained in connection with . are diagrams illustrating the determination of the predicted next encoded media item. In this example images are sequentially numbered in the same order in which they are stored at the server. In images and are displayed on screen in a column and images and are currently not displayed but shown in dashed boxes to indicate their relative positions . If the direction of the first scrolling action is up as illustrated by arrow then in step the location of the last item that was decoded in response to the first scrolling action is determined to be 4. In step based on the position of the last decoded item and the vertical display layout and following the direction of the first scrolling action the position of the predicted next encoded media item is image . If the direction of the first scrolling action is down as illustrated by arrow the predicted next encoded media item is image . In images and are displayed on screen in a row. Similarly the direction of the first scrolling action is to the left as illustrated by arrow the predicted next encoded media item is image . If the direction of the first scrolling action is to the right as illustrated by arrow the predicted next encoded media item is image .

Other display schemes are possible and the determination of the last item that was decoded and displayed can depend on the direction of the user scrolling action. For example the images can also be displayed in a two dimensional grid as shown in . In this example images and are currently displayed on screen while the rest of the images represented using dashed boxes are not displayed. A mapping of specific image positions and the direction of the user scrolling action is used to determine which image is deemed to be the last decoded item. For example if the user scrolls in the direction according to arrow the last item that was decoded is deemed to be image and the predicted next encoded media item is image . If the user scrolls in the opposite direction as arrow the last item that was decoded is deemed to be item and the predicted next encoded media item is image .

If it is assumed that M 1 then at it is determined whether the predicted next encoded media item has already been decoded. In some embodiments the determination is made by checking whether a Bitmap object associated with the predicted next encoded media item already exists in the system heap. If decoding has taken place e.g. the user has already scrolled through viewed the predicted next encoded media item there is no need to decode the item again and the process proceeds to step .

If decoding has not taken place the predicted next encoded media item is decoded. Specifically at a Bitmap object corresponding to the predicted next encoded media item is created based on the Bitmap class provided by the programming framework for the device e.g. Java for Android . The Bitmap class provides various attributes and methods associated with the behaviors and states of a Bitmap object. According to existing APIs and the Bitmap class definition provided by Android platform when a Bitmap object is created it is stored in a system heap and is managed by ashmem. The Bitmap object includes the actual decoded bitmap image data as one of its attributes. However there is no guarantee that the actual bitmap image data is inflated within the Bitmap object i.e. no guarantee that the actual bitmap data has been generated and is stored in cache memory on the system heap only that when the actual bitmap image data is needed e.g. as requested by another API call it will be made available. In other words the Bitmap class does not necessarily decode the JPEG files into actual bitmap image data as soon as the Bitmap object is created but may perform the decoding process and generate the actual bitmap image data later on an as needed basis. This artifact of Bitmap implementation can result in stutter when the predicted next encoded media item needs to be displayed since some time is needed to generate the actual bitmap image data. To address this issue at a function call is invoked to ensure that the actual decoded bitmap image data is generated and stored in cache. Any function call that generates the actual decoded bitmap image data can be used including those for which the generation of the actual decoded bitmap image data is incidental to the functions main purpose. For example a function call to obtain the entire decoded bitmap can be used however the return value e.g. the entire bitmap is returned to the application heap and would occupy valuable application heap space before the bitmap is needed. Thus preferably the function call should return a minimal amount of data. An example of such a function call is Bitmap.GetPixel which requests the value of a single pixel in the Bitmap object by decoding the actual bitmap image data and loading it into cache memory in the system heap. When another function call is invoked for displaying the bitmap image in response to a second scrolling action there is a cache hit and the bitmap image data is provided to the function call without delay. The result of the function call is returned to the application heap which has very limited memory. By getting the value of just one pixel a minimal amount of space is taken up in the application heap.

Process is further explained in connection with . illustrate example data structures that appear in different parts of the memory during the scrolling process. The memory layout is similar to what is shown in . Initially as shown in encoded media items specifically JPEG files numbered are downloaded from the server onto first memory . The number of files is for purposes of illustration only and a different number of files can be present in other embodiments. Once the user begins the first scrolling action Bitmap objects are created in second memory specifically in system heap . In this example as shown in Bitmap objects corresponding to JPEG files are created. It is determined that item is the last decoded item in response to the scrolling action. In this example the system heap only has enough space to store three decoded bitmap images. Thus only Bitmap objects have corresponding decoded bitmap image data in the system heap and the bitmap image data corresponding to Bitmap object has been evicted and no longer exists in the system heap. shows that upon determining that item is the predicted next encoded media item to be displayed and that item has not yet been decoded step a Bitmap object corresponding to item is created in system heap step . At this point JPEG file has not yet been decoded and the actual decoded bitmap image data is not yet available in the system heap. Next a GetPixel call is made on Bitmap object step . As shown in at this point JPEG file is decoded and the corresponding actual decoded bitmap image data is created in system cache. The decoded bitmap image data for Bitmap object however is evicted from memory to make room for the bitmap of Bitmap object .

Predictive pre decoding of encoded media items has been disclosed. Although the embodiments described above use JPEG files for purposes of illustration the technique is also applicable to other encoded media item types. For example the encoded media items can include compressed video files e.g. Moving Picture Experts Group MPEG files for which selected frames are used to represent the media items and displayed to the user.

Although the foregoing embodiments have been described in some detail for purposes of clarity of understanding the invention is not limited to the details provided. There are many alternative ways of implementing the invention. The disclosed embodiments are illustrative and not restrictive.

