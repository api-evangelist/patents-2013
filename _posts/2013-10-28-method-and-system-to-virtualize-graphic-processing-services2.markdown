---

title: Method and system to virtualize graphic processing services
abstract: Methods and systems configured to virtualize graphic processing services in a virtual machine environment are disclosed. A virtual machine monitor (VMM) may be configured to maintain a virtual machine (VM) based on a host operating system (OS) executing in the system. The VM may contain a virtualized graphics library (vGLib) configured to support a graphic command from an application executing in the VM. The host OS may contain a graphics library (GLib) configured to support the graphic command and utilize a graphics processing unit (GPU) in the system to process the graphic command. Upon receiving the graphic command from the application, the vGLib may be configured to allocate a memory section in the VM to store the graphic command. And the VMM may be further configured to share access to the memory section with the host OS, thereby allowing the host OS to retrieve the graphic command from the memory section and deliver the graphic command to the GLib for processing.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09582849&OS=09582849&RS=09582849
owner: VMware, Inc.
number: 09582849
owner_city: Palo Alto
owner_country: US
publication_date: 20131028
---
OpenGL ES Open Graphics Language for Embedded System is a cross platform API for rendering 2D and 3D graphics on an embedded system. For a system that is equipped with an OpenGL ES compatible graphics processing unit GPU a graphic application may take advantage of the GPU acceleration by using OpenGL ES commands to perform its graphic tasks. For a system that does not have a GPU the graphic application may be forced to utilize the central processing unit CPU to process these OpenGL ES commands. As a result the performance of a graphic application in a system that contains a GPU is generally faster than in a system that does not contain a GPU. In addition OpenGL ES 2.0 standard may require mandatory GPU support. Thus a graphic application that is programmed based on the OpenGL ES 2.0 standard may not be executable in an embedded system that does not have a GPU.

A virtual machine VM may be configured to simulate an embedded system that supports an OpenGL ES application. An OpenGL ES application executing in the VM may issue OpenGL ES commands to the VM. However the VM which is a software emulating a physical machine may not have a direct access to a GPU. In this case the VM may provide OpenGL ES supports based on software implementations. Still the software implemented OpenGL ES supports may require a lot of CPU throughputs which may slow down the application s performance in the VM significantly. Alternatively the VM may be implemented with a virtualized GPU or have a virtualized GPU driver which can interface with a physical GPU. However these solutions may not be flexible as the VM may have to support different GPUs for different embedded systems.

Methods and systems configured to virtualize graphic processing services in a virtual machine environment are disclosed. A virtual machine monitor VMM may be configured to maintain a virtual machine VM based on a host operating system OS executing in the system. The VM may contain a virtualized graphics library vGLib configured to support a graphic command from an application executing in the VM. The host OS may contain a graphics library GLib configured to support the graphic command and utilize a graphics processing unit GPU in the system to process the graphic command. Upon receiving the graphic command from the application the vGLib may be configured to allocate a memory section in the VM to store the graphic command. And the VMM may be further configured to share access to the memory section with the host OS thereby allowing the host OS to retrieve the graphic command from the memory section and deliver the graphic command to the Glib for processing.

In the following detailed description reference is made to the accompanying drawings which form a part hereof. In the drawings similar symbols typically identify similar components unless context dictates otherwise. The illustrative embodiments described in the detailed description drawings and claims are not meant to be limiting. Other embodiments may be utilized and other changes may be made without departing from the spirit or scope of the subject matter presented here. It will be readily understood that the aspects of the present disclosure as generally described herein and illustrated in the Figures can be arranged substituted combined and designed in a wide variety of different configurations all of which are explicitly contemplated herein.

In one embodiment the CPU may be a general purpose processor configured to perform basic arithmetical logical and input output operations for the computer system . The GPU may be a specialized processor configured to accelerate the creation and processing of graphic images intended for output to the display device . The GPU may be configured to render graphic images regardless whether the computer system contains a display device or not. The GPU may also be configured to utilize one or more frame buffers which may be memory storages provided by the physical memory to store or retrieve image frames. Compared to the CPU the GPU may be more efficient in manipulating large quantity of graphics data and performing parallel processing.

In one embodiment a host machine execution space may be implemented based on the physical hardware platform . The host machine execution space may include without limitation a host operating system OS and one or more host applications . In other words the host OS may be installed on the top of the physical hardware platform and the host applications may be executing in the host OS . The host OS may be a desktop operating system such as without limitation WINDOWS Apple OS Linux Solaris x86 NetWare FreeBSD . The host OS may also be a mobile operating system such as without limitation Android iOS Blackberry OS WINDOWS PHONE . For example when the computer system is a mobile smartphone the host OS may be a mobile OS installed in the mobile smartphone and the host application may be a mobile application designed for executing in the mobile OS.

In one embodiment a virtualization machine monitor VMM or a hypervisor may be implemented based on the host machine execution space . The VMM may be configured to support a guest machine execution space within which one or more virtual machines may be concurrently instantiated and executed. In other words the VMM may support multiple virtual machines each of which may be installed with a common or different instance of operating system. A virtual machine VM may be an abstraction or a virtualization of an actual physical computer system. As shown in the VMM may create a VM in the guest machine execution space and install an operating system OS in the VM to execute and support one or more applications . In one embodiment the host OS and the guest OS may be Android OS . In this configuration the host OS may provide a personal environment for personalized applications while the guest OS may be configured as a corporate environment capable of secure management of the guest applications .

In one embodiment the VM which may be referred to as a guest guest machine or guest system may rely on the hardware and software supports provided by the physical hardware platform as well as the OS . Thus throughout the present disclosure the physical hardware platform and or the OS may be referred to as the host host machine or host system. For example the machine execution space the VM resides may be referred to as the guest machine execution space the OS as the guest OS and the application as the guest application accordingly. Likewise the machine execution space may be referred to as the host machine execution space the OS as the host OS and the application as the host application accordingly.

It should be recognized that the various terms layers and categorizations used to describe the virtualization components in may be referred to differently without departing from their functionalities or the spirit and scope of the present disclosure. For example the VMM may be designed as a part of the host machine execution space . In this case the VMM may be a specific type of application executing in the host OS . Alternatively the VMM may be deemed as a part of the guest machine execution space . The details of the VMM are further described below.

In one embodiment the host OS may be configured with a graphics library GLib a GPU driver a virtual machine VM kernel module and VM support services . The GPU driver may be a device driver or device interface that serves as an interface to the GPU . The GLib may be a programming library with optimized functions that can perform graphic rendering operations. Specifically the GLib may be configured to utilize the GPU driver to take advantage of the hardware acceleration capabilities of the GPU . For example the GLib may support OpenGL Open Graphics Library which is a cross language multi platform application programming interface API for rendering 2D and 3D graphic images. The GLib may also support OpenGL ES Open GL Embedded System DirectX or other computer graphics programming standards. Thus a host application may utilize an OpenGL compatible graphic command to interface with the GLib .

In one embodiment the VM kernel module may be a module installed in the kernel of the host OS . The VM support services may contain interfaces that allow the VMM to interact with the VM kernel module . In other words the VM kernel module may be deemed a kernel extension of the VMM and the VM support services may be deemed an extension of the VMM that belongs to the host machine execution space . The VM kernel module may be configured to support multiple VMM s each supporting a specific guest machine execution space . The VM support services may be configured to provide a communication link between the guest OS and the host machine execution space . Further the VM support services may contain a render manager configured to manage the rendering operations in the host machine execution space . The VM support services may also be configured to invoke the GLib .

In one embodiment the guest OS may be configured with a virtualized graphics library vGLib and a virtual GPU driver . The vGLib may be a virtualized version of the GLib meaning that a graphic command that is supported by the GLib may also be supported by the vGLib . The virtual GPU driver may be configured to provide virtualized GPU supports to the vGLib . In one embodiment the vGLib may serve as an interface to the GLib . Specifically the vGLib may transmit a GPU related graphic command originated from the graphic application or the guest OS to the virtual GPU driver which may simulate a device driver that interfaces with a GPU and forward the GPU related graphic command to the GLib . The vGLib may also contain functions to manage graphic contexts associated with the guest application . However the vGLib may not contain some of the graphic processing functions and may not be able to directly interface with the GPU . In other words the vGLib itself does not contain some or all of the functionalities of the GLib with respect to graphic processing and may not interface with the GPU without the GLib . Optionally the vGLib may support extended commands that are not supported by the GLib . In this case the vGLib may implement the functionalities that are associated with the extended commands.

In one embodiment a single guest application may be deployed to multiple computer systems that have different GPU s. These computer systems may contain respective GPU drivers and GLib s that support the different GPU s. However these GLib s may provide standardized APIs which are compatible with the interfaces provided by the vGLib . As a result when a VM with a vGLib is deployed to each of these computer systems the vGLib may be able to directly interface with the GLib s in these computer systems regardless of the type of GPU s these computer systems have. Thus a common guest application in the VM may be able to utilize the different GPU s via the vGLib even when the VM does not provide a virtualized GPU. The details of the vGLib and the GLib are further described below.

In one example the guest application may be a graphic application configured to generate a graphic image displayable on the display device . To accomplish this the guest application may issue one or more OpenGL ES compatible graphic commands to the vGLib for the drawing and manipulating of the graphic image. Upon receiving the one or more OpenGL ES graphic commands the vGLib may deliver the graphic command s to the GLib which is configured to utilize the GPU for hardware acceleration. In one embodiment the VMM may facilitate the delivery of the graphic command s by conducting TCP IP like communications between the guest OS and the host OS . Alternatively the VMM may utilize shared memory for the delivery of the graphic command s and graphic data in order to limit the number of data copying. Further the vGLib and the VMM may reduce the amount of frame buffer usages in the guest OS in order to improve the performance of the vGLib in the guest OS . The details of these improvements are further described below.

In one embodiment a graphic application which may be similar to the guest application of may transmit a graphic command to the vGLib . The graphic command may be an instruction to perform a specific graphic operation associated with a graphic image. The graphic command may also contain parameters and or image data associated with the graphic image. The graphic command may be compatible with a graphics library standard and may be designed to take advantage of the GPU s processing capability. For example the graphic command may be an OpenGL ES command to draw a graphic shape on the display device . If the vGLib cannot fully process the OpenGL ES command it may forward the OpenGL ES graphic command to the GLib for further processing.

In one embodiment the vGLib may utilize the VMM to forward the graphic command to the GLib . In one approach the vGLib may first send the graphic command to the VMM which may then deliver the graphic command to the host OS using a network communication mechanism e.g. TCP IP . Such an approach may require the transmitting of a copy of the graphic command and or the image data associated with the graphic command from the guest OS to the host OS . Therefore when the image data e.g. texture image associated with the graphic command is large making a copy of the image data plus the transmitting of the copy of the image data through the various modules in the VM VMM and host OS may take a lot of system time and resources. In another approach the VMM may utilize a shared memory mechanism to implement communications between the guest OS and the host OS . Specifically VMM may share a section of the memory used by the guest OS with the host OS so the vGLib may store the graphic command and its associated parameters to and the host OS may retrieve the graphic command and its parameters from the shared memory section. The VMM may also utilize the shared memory section for exchanging large image data between the guest OS and the host OS .

In one embodiment the vGLib may instruct a memory allocator to allocate a section of memory in the memory space in order to store graphic commands and or image data in the allocated section of memory. The memory space may be based on the physical memory in the computer system e.g. computer system of . In the guest OS with the proper authorizations and privileges the graphic application and or the vGLib may access the allocated section of the memory utilizing a guest memory address. Afterward the VMM may instruct the VM kernel module to map the section of memory for the host OS . Mapping the section of memory allows the host OS to have access to the same section of memory in the host OS using a host memory address different from the guest memory address . After the host OS finished accessing the section of memory the VMM may instruct the VM kernel module to un map the section of memory thereby removing the host OS s access to the section of memory. Thus the guest OS and the host OS may utilize the memory space to share transmit information.

In one embodiment via the memory allocator the vGLib may allocate a command buffer in the memory space for storing graphic commands associated with a corresponding graphic context. For a specific graphic application that utilizes the vGLib the vGLib may construct a corresponding graphic context in the guest OS to manage the graphic data and states associated with the specific graphic application in the guest OS . The graphic context may be deemed a resource management container that stores data and states associated with the rendering and displaying of graphic data by the graphic application . For example the graphic context may be an OpenGL ES Context which may further contain references to buffers textures shaders and other data structures. When there are multiple graphic applications executing in the guest OS the vGLib may maintain for each of the graphic applications a corresponding instance of graphic context. Further when the vGLib forwards the graphic commands from a specific graphic application to the GLib the GLib may construct a corresponding graphic context in the host OS for the processing of the graphic commands of the specific graphic application .

In one embodiment the vGLib may utilize the memory allocator to allocate a specific command buffer for each graphic context it maintains. When multiple threads of a graphic application share a common graphic context then the vGLib may allocate a single command buffer shared by the multiple threads for storing their graphic commands. On the other hand when each of the multiple threads of the graphic application maintains its own copy of graphic context then the vGLib may allocate a specific command buffer for each graphic context corresponding to a specific thread of the graphic application . Further each command buffer may have a configurable size which may be increased on demand for storing a specific number of graphic commands. After a preconfigured period of time or once the command buffer becomes full the vGLib may inform the virtual GPU driver that the command buffer is available for access by the host OS .

In one embodiment the vGLib may utilize the virtual GPU driver the VMM a render manager in the host OS and a VM kernel module in the host OS to facilitate the sharing of the data in the memory space and or the transmitting of data using the memory space . Specifically the vGLib may invoke the virtual GPU driver to start the above memory sharing and data transmission process. The virtual GPU driver may be a stream virtualized driver a module installed in the kernel of the guest OS configured to communicate with the VMM . Upon receiving an invocation from the vGLib the virtual GPU driver may make a hyper call to the VMM . The hyper call may request for the sharing of the command buffer and the notifying of the host OS for processing the graphic commands in the command buffer .

In one embodiment once received the hyper call from the virtual GPU driver the VMM may utilize the VM kernel module in the host OS to perform a mapping of the memory space for the host OS . During the mapping process the VM kernel module may generate for the host OS a memory pointer that can be used to locate the command buffer in the memory space . After the mapping process the host OS as well as the host applications executing in the host OS may access the command buffer using the memory pointer. Based on the hyper call the VMM may utilize the VM kernel module to generate and transmit an event which may include the mapped memory pointer to the render manager in the host OS informing the availability of the command buffer for processing.

In one embodiment the render manager may be a host application similar to the host application of executing based on the host OS . The render manager may act as a daemon continuously listening to various events transmitted from the VMM . The VMM may first deliver the event to the VM kernel module . Afterward the VM kernel module may push the event to the render manager or the render manager may pull the event from the VM kernel module . Upon receiving a specific event the render manager may instantiate or activate a render thread to handle the event. In one embodiment the render manager may assign a specific render thread to process a specific command buffer . In this case each render thread may manage a specific graphic context associated with the specific command buffer .

In one embodiment a render thread may be a process or a thread of a process dedicated to retrieve graphic commands from the command buffer and interface with the GLib on behalf of the graphic application . In other words the render thread may extract one graphic command from the command buffer transmit the graphic command originated from the graphic application to the GLib and optionally receive for the graphic application a graphic result from the processing of the graphic command by the GLib . Further the render thread may maintain a dedicated operating environment e.g. a graphic context in its memory space for the graphic application in order to keep track of the various states of the graphic objects or store temporary variables associated with the graphic command.

In one embodiment upon receiving the event the render thread may process the event by extracting a memory pointer from the event. The render thread may then utilize the memory pointer to locate the command buffer in the memory space . For each graphic command extracted from the command buffer the render thread may optionally retrieve from the memory space the parameters and image data that are associated with the graphic command. Afterward the render thread may invoke a specific API in the GLib that is associated with the graphic command and pass the parameters and image data associated with the graphic command to the API. For a graphic command that can take advantage of the GPU the GLib may utilize the GPU driver to interact with the GPU . The GPU may perform graphical manipulations based on the graphic command and return graphic result from the graphical manipulations to the GLib via the GPU driver . For another graphic command that requires displaying a graphic image the GLib may perform its underlying mechanisms to show the graphic image in the display device .

In one embodiment the graphic application may issue a graphic command requesting for a specific piece of information related to a graphic object. Subsequently the graphic application may continue its logics based on the specific piece of information. For example the graphic command may be an OpenGL ES command seeking a transformed vertex s current position. Afterward the graphic application may perform a subsequent operation to move the vertex to a new position. In this case the vGLib may store the graphic command in the command buffer and without waiting for the command buffer to be full utilize the above mechanism to inform the GLib to process the graphic command. The GLib may transmit the OpenGL ES command to the GPU which in turn may calculate a current position and return the position as a graphic result to the GLib . Afterward the GLib may return the graphic result to the graphical application using the memory sharing mechanism as described above.

Specifically the GLib may deliver the graphic result as a response to the invocation to the render thread . The render thread may then locate a result space in the memory space that is associated with the command buffer and store the received graphic result into the result space . Optionally the render thread may associate the graphic result stored to the result space with the specific graphic command in the command buffer the graphic result is generated from. Alternatively each command buffer may be associated with one result space for storing graphic result associated with the graphic command that is currently being selected from the command buffer for processing. After completed the processing of one graphic command the render thread may select a subsequent graphic command in the command buffer for processing.

In one embodiment the guest OS may allocate the result space in the memory space similar to the allocating of the command buffer in the memory space . Alternatively the render thread or another module executing in the host OS may be configured to allocate the result space in the memory space and inform the vGLib or the VMM to map the address of the result space for the guest OS . Afterward the vGLib may be able to access the memory space to retrieve the graphic result from the result space that corresponds to the graphic command it previously stored in the command buffer . Further the vGLib may return the graphic result as a response to the graphic application . Thus throughout the above process the VMM does not need to transmit a copy of the graphic command with its associated parameters and image data to the host OS . Similarly the host OS does not need to copy the graphic result back to the guest OS . By using the memory sharing mechanism the performance of the data communications between the guest OS and the host OS may be greatly improved.

In one embodiment the graphic application may issue a graphic command that involves a large sized graphic data. For example the graphic command may be an OpenGL ES glTextImage2D command having a large 2D texture image as a parameter. In this case the graphic application may allocate and store the large sized graphic data as a data object in the memory space . Similar to the process disclosed above upon receiving this specific graphic command from the graphic application the vGLib may store the graphic command to the command buffer and associate the data object that is already allocated by the graphic application in the memory space with the graphic command. Afterward the vGLib may interact with the VMM to trigger the sharing of the command buffer and the data object with the host OS and the processing of the graphic commands in the command buffer .

In one embodiment similar to the memory mapping process described above the VM kernel module may generate a first memory pointer for the command buffer and a second memory pointer for the data object . The VM kernel module may then create an event containing the first memory pointer and the second memory pointer and deliver the event to the render manager . Subsequently the render manager may assign a render thread to process the event. The render thread may utilize the first memory pointer to locate the command buffer and the second memory pointer to locate the data object in the memory space . Afterward the render thread may then invoke the corresponding API e.g. glTextImage2D in the GLib that is associated with the graphic command and use the second memory pointer as a parameter for the API. The GLib may access the data object based on the second memory pointer and perform hardware acceleration using the GPU . Thus the vGLib may deliver a large sized graphic data to the GLib without making or transmitting a copy of the large sized graphic data for the host OS .

In one embodiment since one command buffer is associated with a single graphic context and the single graphic context cannot be shared between multiple graphic applications this command buffer may not be shared among the multiple graphic applications either. As a result the order of the graphic commands in this command buffer may represent the order the graphic application issues these graphic commands. And the GLib may sequentially process these graphic commands in this command buffer . When there are multiple graphic applications executing in the guest OS the render manager may have multiple command buffers to process. In this case the render manager may prioritize the processing of these command buffers based on priority values.

In one embodiment the guest OS may assign different priority values to these multiple graphic applications . The vGLib may generate a guest priority value for the graphic commands received from a specific graphic application based on the graphic application s OS assigned priority value. Afterward the vGLib may associate this guest priority value with the command buffer that stores these graphic commands. Specifically the vGLib may generate and or associate the guest priority value during the creation of the graphic context for the graphic application . Thus where there are multiple graphic applications the command buffers in the memory space may have corresponding guest priority values. 

In one embodiment the render manager may evaluate the guest priority values associated with the multiple command buffers and convert these guest priority values to corresponding host priority values. The render manager may generate the host priority values by preserving the priority hierarchy presented in the guest priority values. Alternatively the render thread may generate the host priority values that represent the priority of the multiple graphic applications from the host OS s perspective. Afterward the render manager may associate the host priority values to the command buffers and assign render threads to process those command buffers that have high host priority values before assigning render threads to process command buffers that have low host priority values. 

In one embodiment the virtual GPU driver the VMM and or the VM kernel module may implement and maintain a cache mechanism to further reduce the costs of mapping and de mapping the shared objects e.g. command buffers result space data objects in the memory space . Since mapping the shared objects may have a non negligible cost to reduce these costs the VMM may cache the mapped shared objects after the render manager finished processing them. In this case even when the guest OS requests the VMM to un map these shared objects the VMM may keep these shared objects in the memory space mapped for a specific period. Thus in case the vGLib requests the VMM to re map a specific shared object that is previously mapped and unmapped the VMM may simply use the cached remain mapped shared object without request the VM kernel module to perform additional memory mapping operations. If after the specific period the VMM does not receive additional request to map the shared object then the VMM may instruct the VM kernel module to un map the shared object for the host OS . Such an approach may improve the performance of the graphic application when it performs certain operations e.g. scrolling . In one embodiment the virtual GPU driver may also perform periodical cleanup of the command buffers the result space and or the data objects that are already allocated in the memory space .

In one embodiment the vGLib may be configured to simulate the functionalities of the GLib in order to fully support the graphic application which is designed to interface with the GLib . For a host application not shown in executing in the host OS and interacting with the GLib the GLib may construct a graphic context to support the graphic rendering operations associated with the host application s graphic commands. Further the GLib may utilize a native platform graphics interface e.g. EGL to interact with the host OS s native window system. The native platform graphics interface may handle management of the graphics context and provide mechanisms for creating a drawing surface . The drawing surface may be a window or a pixel map on which the GLib may draw or render graphic images and may be tightly coupled with the host OS s native window system. In other words the GLib may construct a graphic context and its associated drawing surface for each host application that interacts with the GLib .

In one embodiment the GLib may associate the drawing surface with a front buffer and a back buffer not shown in supplied by the host OS . The front buffer and the back buffer may also be referred to as the OS allocated buffers. Each of the front buffer and the back buffer may be deemed a frame buffer containing a set of pixels arranged in a two dimensional array. The front buffer may be linked with a display device meaning the pixels in the front buffer are currently being displayed on the display device. In the meantime the GLib may render another image fill the back buffer with the rendered image and swap the back buffer with the front buffer. Once the front buffer and the back buffer are swapped the image in the back buffer may be displayed on the display device and the GLib may then utilize the front buffer for rendering a subsequent image.

In one embodiment to be compatible with the GLib the vGLib L may similarly construct a graphic context to support the graphic commands from the graphic application . The graphic context may correspond to the graphic context which is constructed by the GLib to process these graphic commands of the graphic application in the host OS . Further as the GLib may create a drawing surface during the processing of these graphic commands the vGLib may create in the guest OS a drawing surface that corresponds to the drawing surface in order to provide functionalities that are compatible with the GLib . In addition similar to the GLib the vGLib may allocate a front buffer and a back buffer and associate the front buffer and the back buffer with the drawing surface . In other words the vGLib may manage the graphic context and the drawing surface in similar fashions as the GLib managing the graphic context and the drawing surface .

In one embodiment after establishing the graphic context and the drawing surface for the graphic application the vGLib may associate the graphic context with a command buffer allocated to store graphic commands received from the graphic application . The vGLib may then utilize the above described memory sharing mechanism to forward the command buffer to the host OS . For illustrative purpose the command buffer is shown as the command buffer from the perspective of the host OS even though these two command buffers and may in reality be a single copy of data in the memory space .

In one embodiment the vGLib may receive a graphic command from the graphic application to interact with the OS allocated frame buffers e.g. the front buffer and the back buffer . For example the graphic command may instruct the vGLib to display the image stored in the front buffer or use the back buffer to render a new image. The graphic command may also request for the swapping of the front buffer and the back buffer . To fully support this graphic command the vGLib may allocate in the guest OS s memory space the front buffer and the back buffer . However since the front buffer and the back buffer are not integrated with a physical display device when the graphic command is forwarded to the GLib the GLib may utilize the front buffer and the back buffer that are supported by the host OS to perform the actual functions associated with the graphic command . As a result the front buffer and the back buffer that are allocated in the guest OS may be wasteful.

In one embodiment for the graphic command that involves OS allocated frame buffers the vGLib may ignore the allocating of the front buffer and the back buffer in the guest OS . Instead the vGLib may update adjust the graphic command to utilize user created frame buffers e.g. frame buffer objects in lieu of the OS allocated frame buffers. For example when the vGLib detects that the graphic command is associated with an OS allocated frame buffer operation the vGLib may ignore the creation and the manipulation of the OS allocated frame buffers. Such an approach may ensure that the front buffer and the back buffer are not unnecessarily allocated in the guest OS s memory space. For similar reasons the vGLib may also ignore the constructing of the drawing surface in the guest OS .

In one embodiment the vGLib may alter the graphic command to use user created frame buffers rather than the OS allocated frame buffers. Specifically the vGLib may remove the referencing of the OS allocated frame buffers in the graphic command and generate additional graphic commands that manipulate user created frame buffers instead. For example the GLib may utilize a frame buffer object as the user created frame buffer. When the GLib receives a graphic command to create and bind a new frame buffer object the GLib may allocate in the host OS a front texture and a back texture that are associated with the frame buffer object . Afterward the GLib may manipulate the frame buffer object in a similar fashion as the manipulating of the OS allocated frame buffers. In other words the GLib may direct the rendering outputs to the frame buffer object which in turn may cause the rendering outputs to be stored in the back texture . Further the GLib may redirect the data stored in the back texture to the OS allocated back buffer by performing another rendering operation on the frame buffer object thereby allowing the host OS to display the image contained in the OS allocated back buffer to a physical display device.

In one embodiment the vGLib may insert the additional graphic commands that utilize the user created frame buffer either before and or after the graphic command in the command buffer . Once the command buffer is shared with the host OS the GLib may process the additional graphic commands along with the graphic command and construct an actual frame buffer object in the host OS . The GLib may then allocate a front texture and a back texture in the host OS and set the frame buffer object s rendering target to the back texture . Since the GLib no longer uses the OS allocated frame buffers in the host OS there is no need for the vGLib to maintain the corresponding front buffer and back buffer in the guest OS . As a result the vGLib s memory usage may be reduced and vGLib s overheads in allocating and de allocating the front buffer and the back buffer may also be lowered.

In one embodiment rather than altering the graphic command the vGLib may simply ignore the operations in the graphic command that involve the creation and or the manipulation of the OS allocated frame buffers and rely on the GLib to implement the user created frame buffers. In this case the vGLib may store the graphic command to the command buffer without creating any additional graphic commands. Upon receiving the graphic command the GLib may detect whether the graphic command utilizes the OS allocated frame buffers and ignore these operations that involve the OS allocated frame buffers. Afterward the GLib may perform additional operations that utilize the user created frame buffers instead. Similar to the processes described above the GLib may construct a frame buffer object for the graphic command utilize the frame buffer object to render outputs to the back texture and redirecting the back texture to the OS allocated back buffer.

One skilled in the art will appreciate that for this and other processes and methods disclosed herein the functions performed in the processes and methods may be implemented in differing order. Furthermore the outlined steps and operations are only provided as examples and some of the steps and operations may be optional combined into fewer steps and operations or expanded into additional steps and operations without detracting from the essence of the disclosed embodiments. Moreover one or more of the outlined steps and operations may be performed in parallel.

At block a virtual machine monitor VMM may be configured to maintain a virtual machine VM based on a host operating system OS executing in the system. The VM may contain a virtualized graphics library vGLib configured to support a graphic command from an application executing in the VM. The host OS may contain a graphics library GLib configured to support the graphic command and utilize a graphics processing unit GPU in the system to process the graphic command. In one embodiment the vGLib is configured to support all graphic commands that are supported by the GLib. In another embodiment the host OS may be an Android OS. The GLib may be an OpenGL ES compatible library. The vGLib may be a virtualized OpenGL ES compatible library. And the graphic command may be an OpenGL compatible command.

At block upon receiving the graphic command from the application the vGLib may be configured to allocate a memory section in the VM to store the graphic command. Specifically the vGLib may allocate a command buffer as the memory section to store the graphic command without making a copy of the graphic command or transmitting the copy of the graphic command to the VMM. In one embodiment the vGLib may store a plurality of graphic commands to the command buffer. The vGLib may also store parameters and image data associated with the graphic command in the memory section along with the command buffer. Thus the memory section may be a command buffer and or any parameters and image data associated with one or more graphic commands in the command buffer. Further the vGLib may associate the command buffer with a corresponding priority value.

At block the VMM may share access to the memory section with the host OS. Before the sharing the host OS may not be allowed to access the memory action. After sharing the host OS may be allowed to retrieve the graphic command from the command buffer in the memory section and deliver the graphic command to the GLib for processing. In one embodiment upon a determination that the command buffer is full the VMM may generate a memory pointer configured to address the command buffer in the host OS. Afterward the VMM may transmit an event with the memory pointer to the host OS. In one embodiment the host OS may be configured with a render manager for listening to the event and retrieving the memory pointer upon receiving the event. Afterward the render manager of the host OS may deliver the memory pointer to the GLib to access the command buffer and process the graphic command contained therein.

At block the render manager of the host OS may be configured to retrieve the graphic command from the command buffer. The render manager may then invoke the GLib which may process the graphic command using the GPU. In one embodiment the render manager may also retrieve image data associated with the graphic command from the shared memory section and pass the image data along with the graphic command to the GLib. In another embodiment for multiple command buffers in the memory section that are associated with different priority values the render manager may process the multiple command buffers based on their corresponding priority values.

At block the GLib may generate a graphic result based on the processing of the graphic command using the GPU. Afterward the render manager may store the graphic result in the memory section. At block the vGLib may retrieve the graphic result from the memory section and return the graphic result to the application as a response to the graphic command.

At block upon a determination that the graphic command involves accessing an OS allocated frame buffer e.g. a front buffer or a back buffer in the VM the vGLib may ignore allocating memory of the VM to the OS allocated frame buffer. In one embodiment the GLib may also ignore the utilizing of the OS allocated frame buffer in the host OS for processing the graphic command.

At block upon receiving the graphic command the GLib may create a frame buffer object for the processing of the graphic command thereby allowing a GPU to draw using front back texture which is associated with a guest OS front back buffer. Specifically the GLib may utilize the frame buffer object as a rendering target to process the graphic command. In one embodiment the GLib may first use the frame buffer object to allocate a color buffer having a back texture and a front texture in the host OS. The back texture may be associated with a back buffer in the host OS and the front texture may be associated with a front buffer in the host OS. Afterward the GLib may perform a rendering operation based on the frame buffer object and direct output of the rendering operation to the back texture. Optionally the GLib may swap the front texture with the back texture using the GPU allowing the rendered output to be displayed via the front buffer to the physical display device.

Thus systems and methods for virtualize graphic processing services in a virtual machine environment have been disclosed. The various embodiments described herein may employ various computer implemented operations involving data stored in computer systems. For example these operations may require physical manipulation of physical quantities usually though not necessarily these quantities may take the form of electrical or magnetic signals where they or representations of them are capable of being stored transferred combined compared or otherwise manipulated. Further such manipulations are often referred to in terms such as producing identifying determining or comparing. Any operations described herein that form part of one or more embodiments of the disclosure may be useful machine operations. In addition one or more embodiments of the disclosure also relate to a device or an apparatus for performing these operations. The apparatus may be specially constructed for specific required purposes or it may be a general purpose computer selectively activated or configured by a computer program stored in the computer. In particular various general purpose machines may be used with computer programs written in accordance with the teachings herein or it may be more convenient to construct a more specialized apparatus to perform the required operations.

The various embodiments described herein may be practiced with other computer system configurations including hand held devices microprocessor systems microprocessor based or programmable consumer electronics minicomputers mainframe computers and the like.

One or more embodiments of the present disclosure may be implemented as one or more computer programs or as one or more computer program modules embodied in one or more computer readable media. The term non transitory computer readable storage medium refers to any data storage device that can store data which can thereafter be input to a computer system computer readable media may be based on any existing or subsequently developed technology for embodying computer programs in a manner that enables them to be read by a computer. Examples of a computer readable medium include a hard drive network attached storage NAS read only memory random access memory e.g. a flash memory device a CD Compact Discs CD ROM a CD R or a CD RW a DVD Digital Versatile Disc a magnetic tape and other optical and non optical data storage devices. The computer readable medium can also be distributed over a network coupled computer system so that the computer readable code is stored and executed in a distributed fashion.

Although one or more embodiments of the present disclosure have been described in some detail for clarity of understanding it will be apparent that certain changes and modifications may be made within the scope of the claims. Accordingly the described embodiments are to be considered as illustrative and not restrictive and the scope of the claims is not to be limited to details given herein but may be modified within the scope and equivalents of the claims. In the claims elements and or steps do not imply any particular order of operation unless explicitly stated in the claims.

Plural instances may be provided for components operations or structures described herein as a single instance. Finally boundaries between various components operations and data stores are somewhat arbitrary and particular operations are illustrated in the context of specific illustrative configurations. Other allocations of functionality are envisioned and may fall within the scope of the disclosure s . In general structures and functionality presented as separate components in exemplary configurations may be implemented as a combined structure or component. Similarly structures and functionality presented as a single component may be implemented as separate components. These and other variations modifications additions and improvements may fall within the scope of the appended claims s .

In addition while described virtualization methods have generally assumed that virtual machines present interfaces consistent with a particular hardware system persons of ordinary skill in the art will recognize that the methods described may be used in conjunction with virtualizations that do not correspond directly to any particular hardware system. Virtualization systems in accordance with the various embodiments implemented as hosted embodiments non hosted embodiments or as embodiments that tend to blur distinctions between the two are all envisioned. Furthermore various virtualization operations may be wholly or partially implemented in hardware. For example a hardware implementation may employ a look up table for modification of storage access requests to secure non disk data.

Many variations modifications additions and improvements are possible regardless of the degree of virtualization. The virtualization software can therefore include components of a host console or guest operating system that performs virtualization functions. Plural instances may be provided for components operations or structures described herein as a single instance. Finally boundaries between various components operations and data stores are somewhat arbitrary and particular operations are illustrated in the context of specific illustrative configurations. Other allocations of functionality are envisioned and may fall within the scope of the disclosure s . In general structures and functionality presented as separate components in exemplary configurations may be implemented as a combined structure or component. Similarly structures and functionality presented as a single component may be implemented as separate components. These and other variations modifications additions and improvements may fall within the scope of the appended claims s .

