---

title: System and method of skinning themes
abstract: A mobile communication device and non-transitory computer readable memory is provided. A processor executes instructions to provide a parser for parsing at least one skinning theme document into a template describing rendering characteristics of a graphical interface, the skinning theme document identifying at least one data element. The instructions also provide an interaction interface for receiving from data from at least one application associated with one or more of the at least one data element. A renderer is provided for rendering the received data on a display in accordance with the template as the graphical interface wherein the graphical interface presents one or more data elements of the at least one application that is rendered.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09542065&OS=09542065&RS=09542065
owner: BlackBerry Limited
number: 09542065
owner_city: Waterloo
owner_country: US
publication_date: 20130730
---
This application is a continuation of application Ser. No. 12 950 439 filed on Nov. 19 2010 now allowed which is a continuation of non provisional application Ser. No. 11 748 751 filed May 15 2007 issued as U.S. Pat. No. 7 840 901 on Nov. 23 2010 which claims the benefit of U.S. Provisional Application No. 60 800 416 filed May 16 2006 the contents of which are both hereby incorporated by reference.

The present patent disclosure relates generally to a communications system for providing communications to a plurality of devices and specifically to a system and method of skinning themes.

A portion of the disclosure of this patent document contains material which is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure as it appears in the Patent and Trademark Office patent files or records but otherwise reserves all copyrights whatsoever.

Scalable Vector Graphics SVG is an extensible markup language XML markup for describing two dimensional vector graphics. An application may use an SVG file to represent its user interface UI . This SVG file can be referred to as the application s skin . Basic graphical UI requirements include the fact that an application must be able to graphically represent its status and react to input from the graphical user interface. The application should be able to 

Traditional application graphical user interfaces are hard coded along with the application logic. That is the look and behavior of the user interface is programmed with the application logic in a program like Java or C and embedded along with the application.

In accordance with an aspect of the present disclosure there is provided a mobile communication device comprising a display a processor coupled to the display and a memory coupled to the processor containing instructions which when executed by the processor provide at least one application at least one skinning theme document and a media engine comprising a parser for parsing the at least one skinning theme document into a template describing rendering characteristics of a graphical interface the skinning theme document identifying at least one data element an interaction interface for receiving from data from the at least one application associated with one or more of the at least one data element and a renderer for rendering the received data in accordance with the template as the graphical interface wherein the graphical interface presents one or more data elements of the at least one application that is rendered.

In accordance with another aspect of the present disclosure there is provided a non transitory computer readable memory containing instructions which when executed by a processor of a mobile communication device cause the processor to provide a parser for parsing at least one skinning theme document into a template describing rendering characteristics of a graphical interface the skinning theme document identifying at least one data element an interaction interface for receiving from data from at least one application associated with one or more of the at least one data element and a renderer for rendering the received data on a display in accordance with the template as the graphical interface wherein the graphical interface presents one or more data elements of the at least one application that is rendered.

A goal of skinning is to separate the presentation GUI of the application from the business logic functionality and allow the GUI to be defined through some external file which can be created and late bound to application code. In order to allow this late binding there must be a common understanding or contract between the application logic and the skin. An interface must be defined that the application can interface with to control the UI and a skin must be created that satisfies this interface.

The present disclosure provides a skinning themes document for skinning themes for an application. The skinning themes document comprises at least one data element representing data generated by an application and at least one custom event representing events generated by the application. The interface that allows for the late binding of the GUI defined by the skinning theme document to the application information that is the data elements and the custom events is provided by a media engine.

Embodiments of the present patent disclosure will now be described with reference to various examples of how the embodiments can best be made and used. For convenience like reference numerals are used throughout the description and several views of the drawings to indicate like or corresponding parts wherein the various elements are not necessarily drawn to scale.

One approach to skinning is to define a scalable vector graphics SVG document which acts as a template file for the user interface for the application. More specifically in order to satisfy both requirements of reacting to user input and graphically reflecting the application status a mechanism for implementing a contract between an SVG template document and application code is developed. In one embodiment the application is responsible for handling user input and the media engine is responsible for defining and displaying the graphical interface . To graphically reflect the application status the application code defines a set of data elements and custom events that represent specific data and events that are generated by the application . A data element is some information that the application manipulates or modifies and can be presented on the graphical interface . A data element is assigned a name which is a string. A custom event is some event of significance that occurs in the application s business logic which may need to be reflected in the graphical user interface . Similar to data elements custom events are assigned a name which is a string. It is not the responsibility of the application to define what user interface changes occur as a result of these events or how to display the information of data elements . The application s responsibility is to inform the media engine whenever it needs to update the information associated data elements and when custom events occur.

In one embodiment the template file defines the custom events and data elements that are displayed in the graphical interface. The application code determines what application data elements or custom events which may include user input events to bind to the data elements and events defined in the graphical interface.

A skinning themes document is written for an application using the names of the data elements and the names of the custom events. The skinning theme document or template file describes how to display the information associated with the data elements and custom events.

The media engine acts as an interface between the application and the graphical interface template file. The application notifies the media engine of updates to data elements and the occurrence of custom events. The media engine uses the skin template file to define how to display this information on the display . Using the skin document as a template the media engine or more particularly the renderer of the media engine renders the graphical interface to the display .

The media engine uses the template file for describing how to render a graphical interface . The media engine may use a parser to parse the template information form the template file and store it in a template that is accessible to the media engine . If the template file describes the graphical interface using a markup language then the parser would be able to read the markup language and store the template information in the template . For example if the template file defines the graphical interface in SVG then an SVG parser would read the template information in the SVG file and store the parsed information in a template . The parser may be referred to as a transcoder since it translates the template file code into code representing the template . The template holds the template information in a form expected by the media engine and the renderer . As previously described the template is not required. It is possible for the parser to provide the template information directly to the media engine or the renderer .

The media engine described above is not involved in the processing of user input. It receives a template file defining a graphical interface and notifications from an application regarding data elements and custom events. In the above example an application would be responsible for handling user input. This may be accomplished by interacting with functionality provided by an input device driver with operating system functionality or other methods as may be known.

An application may notify the event engine that it wishes to be informed when ever a user input occurs. This notification can be achieved by an API call to the content interaction APIs of the media engine . The content interaction APIs would include additional calls for providing the user input control to an application . The call should include information the event engine can use to notify the application . This information can include the application identifier the function that the event engine is to call when an event occurs. The call may also indicate the types of user input events the application is interested in. For instance an application may only wish to be notified of input from a scroll wheel or from a keyboard or pointing device etc. When ever a user input event occurs the event engine checks to see if any applications are to be notified and if there are any it sends a notification of the event.

An application does not necessarily need to notify the event engine that it wishes to receive notification of input events. Alternatively the application may poll the event engine to determine if an event has occurred and if one has to receive it. The application would make a call to a content interaction API querying or requesting an user input event.

As described above an application in accordance with the present disclosure may obtain user input in various ways. The above description can also apply to not only user input events but also to system events or other generated events. For example an application may register with the event engine through the content interaction APIs to receive notification each time the display is refreshed.

In addition to the event handling described above the event engine may also act as a controller of the media engine . The event engine may control the times at which a graphical interface is refreshed. This can be accomplished through the use of an event engine timer that fires an event at a certain frequency. When ever the event fires the event engine can access the template and provide the template information to the renderer along with the values of data elements and information regarding the occurrence of events. The renderer then uses this information to render a graphical interface to the display .

As described in the above paragraph the media engine or more particularly the event engine stores the template information separately from the data element and event information. It may be desirable to store all the information in the template . When a notification of a change to data elements arrives via the content interaction APIs the event engine may store this information in the template . In this manner the renderer only needs reference to the template object to render the graphical interface . This can be achieved by in various ways. For example the event engine may pass a copy of the template information to the renderer it may pass a reference to the template to the renderer . Alternatively the renderer may be designed to access a template located in a specific location. The event engine would be responsible for ensuring that the proper template is located in the location. This method can be used advantageously as the media engine may have numerous templates that the event engine keeps updated with the application data element information and event information. The event engine can then be used to switch graphical interfaces by updating the specific location with the desired template.

The above description has described various calls that can be made to the content interaction APIs . Below is a listing of possible API calls that the media engine should support. It must support at a minimum the update data call. Without this support the application cannot pass information to the media engine to display.

The above calls and descriptions are just an example those skilled in the area will recognize that more or fewer calls can be included with different parameters and return values while maintaining the functionality of the media engine 

Data elements may be passed to the media engine as a string that can vary in length. The varying length of the string presents problems when laying out a graphical interface . If the string is too long it may overlay other parts of the graphical interface . If the text is too short other elements may not align properly. In the above examples of media engine although providing for flexibility of the specification of the graphical interface no easy way of dynamically handling the size of data elements was described. Either the media engine must make some predetermined decision on how to handle the length of strings such as truncating all strings that are too long. All though this works well the layout manager provides even greater flexibility to the media engines by providing a way of specifying how to handle the dynamic display of data elements. This allows a graphical interface designer to describe how data elements are to be handled by including layout manager control information in the template file. As an example the template and layout manager may be used to specify that a data element is to be 10 characters long and that if the data element provided to the media engine is longer than 10 characters that it should be truncated to 5 characters long and the string . . . appended to the end of the string. As another example a graphical interface designer may wish to have the characters of a particular data element appear as all upper case characters. This can be specified in the template file. The layout manager would receive the data element string and modify it as determined by the template in this case changing all of the characters to upper case. This manipulation of the data element is performed by the layout manager . The layout manager may be controlled by including in the template or the template file directions to the layout manager specifying how the length of a data element should be modified. The renderer will then display the sting as prepared by the layout manager . The layout manager allows for the text style of data elements to be specified and dynamically controlled.

As shown schematically in the layout manager may alter the data elements according to the dynamic layout described in the template and these changes may be stored directly in the template . The renderer then uses the template in the same manner as previously described. Alternatively the data elements may be stored in the template or separate from the template as provided from the application . The layout manager may alter the data elements as they are provided to the renderer . The layout manager may modify display characteristics of the element such as its placement size visibility etc. In this manner the renderer receives the data elements as string describing the data element as provided by the application and modified by the layout manager in such a manner as described in the template .

The layout manager may be used to control the display of elements other than text elements. A layout manager may be used to dynamically control the display characteristics of graphical information as well. A graphical interface designer may wish to display a graphic or image in a certain location only if there is no text that would be covered by its placement. The layout manager can be used to provide a means of controlling the display of the element. For example if graphical interface describes that an icon is to be displayed in a location free of text the icon element can be passed to the layout manager along with layout manager control information specifying the layout requirements. The layout manager may then dynamically alter the display information of the element in the template prior to the element being rendered. The layout manager may alter the coordinates specifying the placement of the icon or it may determine that there is no space available on the graphical interface and so the icon should not be displayed. The modified element with the dynamic display characteristics can then be passed to the renderer for rendering to the graphical interface .

The layout manager can provide a means of manipulating data elements prior being rendered by the renderer as well as providing a means of dynamically controlling the display characteristic of elements that the renderer may not be able to render appropriately. The template can specify information for controlling the layout manager .

The example application notifies the media engine of any changes to the value of a data element using the media engine API call named update data element . The update date element expects a string identifying the ID of a data element. This is chosen to be the same as the name of the application data element. This is not a requirement of the system but rather is an easy way to ensure consistency when updating data elements. The string for data element ID representing an element in an array of data elements may be constructed by appending the array name with the index number of the particular element. The update data elements also expects a value representing the updated value of the data element . An example definition of the API used for notifying the media engine of updates to data elements is 

The update data element defined above returns an integer that may be used for error detection. It may be used to detect various conditions such as if the data element could not be located or if the value could not be changed or if the value was updated properly etc. The call expects a string representing the ID of a data element . This ID is the string that the template file uses to describe how to display the data element . It could alternatively be another type such as an integer as long as the template file used the same type for identifying the data elements . The value of the data element is defined as a string again this could be changed to another type as long as the template file described how to display the type.

The example application notifies the media engine of the occurrence of any custom events using a media engine API call named notify custom event . The notify custom event call expects a string identifying the ID of a custom event. The string could be replaced by an integer or other type as long as the template file uses the same type for identifying the events. An example of the API used for notifying the media engine of the occurrence of events is 

The notify custom element defined above returns an integer that may be used for error detection. The call expects a string representing the ID of a custom event. This ID is the string that the template file uses to identify the event. It could alternatively be another type such as an integer as long as the template file used the same type for identifying the event.

The example application of does not include any code that controls how or when the information is displayed. It contains code to control user input notify the media engine of updates to date elements and of the occurrence of events. The media engine uses the template to determine how to render the information to the display.

A template file for specifying a graphical interface to the example program can be created using a markup language. Below is an example of a possible template file that describes how to display the example application information.

The above shows an exert from a template file that could be used with the example application. It defines a element with an ID of data int . This is the same ID that the application sends to the media engine . The element specifies how to format and position the text on the display . The exert also defines two elements. These elements are used to change the way the renderer renders the information based on application events. When a Big Int custom event arrives at the media engine from the example application the fill colour of the data int element is changed to green. The set element also defines when to stop using the associated characteristics in the above case this is when the custom event Small Int is received at the media engine . The second set element describes the display properties of data int when the custom event Small Int is received. It describes setting the elements fill colour to red.

The above template only describes displaying one data element for the example application that defines two data elements . The application data element data str is not displayed. The media engine can discard or disregard any updates of this data element it receives from the example application .

Another possible template file describing a different graphical interface for the same example application is 

The above example graphical interface describes the position of both data elements of the example application . This interface does not make use of the custom events sent from the example application . The media engine may discard or disregard the notification of custom events from the example application .

The media engine may also present an error on the screen. One option to do this is shown. The application exits in response to the error . The media engine loads and parses an error template from the library . This error template file may be a standard graphical interface describing only static objects that is no application data elements or application custom events. The template is passed to the renderer which then renders the template to the display . The media engine determines that the application has exited and ends the processing at step .

If the template file is found it is passed to the parser which parses the template file and stores the template information in a template . The media engine then waits to receive updates to data elements or notification of custom events . When a data element update or custom event notification arrives the ID is checked . If the data element or event ID is found in the template the processing continues to step . If the ID is not found in the template then processing returns to step effectively discarding the update or notification. The updated information or notification information is used to update the template . In this case the media engine stores the information in the template . It may be desirable to store the data element and event information apart from the template . In this case instead of updating the template the media engine would store the information. If the media engine stores all the information received from an application the step of checking the template for the IDs may be skipped. Alternatively the IDs may not need to be checked if the media engine only receives data elements or events for IDs used by the template . This may be used to allow the switching of graphical interfaces without requiring the application to communicate all of the information again. The media engine determines if the graphical interface should be updated . If it is not to be updated processing returns to step . If it is to be updated the template is passed to the renderer . As previously disclosed other options exist for passing the display information to the renderer . After the information is passed to the renderer the media engine determines if the application has exited if it has not processing returns to step . If the application has exited then the processing ends .

A skinning system comprises a media engine for rendering an SVG document on a device . The media engine includes a skinning API or a content interaction API . The skinning system also includes an SVG language document and an SVG transcoder or parser . A content developer uses the SVG language and the SVG transcoder to create a skinning document as the template file. An application developer uses the media engine and skinning API . A device application such as a home screen application uses the media engine and skinning API for its skin or graphical interface .

Examples of components of a skinning system in an embodiment of the present disclosure are now described. A skin for a home screen application is described in order to describe the structure of the template file. The examples used to illustrate the format of the template document along with the functionality of the media engine.

A Today style home screen consolidates application and system information and into a single view. This information will be organized according to the theme designer s layout specified in a home screen SVG file.

The set of applications and associated data is determined by the elements of an SVG file that is incorporated into the theme. Preferably user configuration of the fixed set of applications that are represented on the Today style home screen include the following

The home screen supports the ability to incorporate special data elements into the skin file. A data element is a place holder in the skin for user data or system information. This will allow the skin designer to specify a template of the home screen while allowing application to fill in the contents with the appropriate information. Data elements for specific applications are defined within each sub feature. The skin designer can control the appearance and behavior of the data elements through any supported SVG syntax. The set of data elements that the home screen designer can incorporate into the skin is collectively referred to as the data palette . Example data elements include 

The home screen SVG layout will allow the creation of user selectable hotspots. For example the skin designer may create a hotspot that highlights the row containing the last new received email labels . The user may focus on this hotspot by rolling the trackwheel. The SVG syntax allows the home screen designer to specify an action associated with focus in focus out and activate I.e. clicking the thumbwheel . The navigation order is the order that the hotspots are defined in the SVG. An example of an SVG hotspot includes 

In the above example a hotspot is provided that has a focusin and activate action. The focusin translates the caret image to the correct location. The element will open the message that corresponds to the email1 data element.

Layout presents a challenge when implementing a home screen that incorporates text that can have varying length. Examples of such strings include email subject sender calendar subject location etc. A layout manager is used to handle the dynamic length of the data elements that are populating the home screen template.

Unfortunately SVG does not provide this ability natively. An extension to the language is provided that allows the specification of how data elements are laid out with respect to each other. In the Today style view the requirements call for a column wise layout of data elements. For example the requirements for calendar integration state

Preferably each element has independently themed text styles. The time and subject fields will be left aligned into a column. The subject field will be given a maximum width and the location field will immediately follow the subject field.

The above involves the home screen providing a column wise layout manager where each column specifies an available maximum space and a rule for truncating the string if it is too long to fit within that space. If a field has a display attribute that is set to none it will not occupy any space for the purposes of laying out subsequent text elements. The home screen skin has the ability to specify a layout manager that controls the position of data elements within the skin. For example a element may specify a layout rule and references elements within the skin file. For example 

The home screen provides the ability to refer to application descriptions within the home screen SVG file using the element or element. These are different ways to specify an application name. The method is generally better because it can leverage the SVG syntax and features. The method is legacy. The application is identified by specifying its module name and entry point as the value of the id parameter of the xlink href attribute. An application description is referenced by prefixing the xlink href attribute with the string x object EntryDescription . The application description will be retrieved from the ApplicationEntry class. An example of an application description for Phone application includes 

An alternate representation using a data element for the application description called calendar app is 

The above example specifies an image that is the focused state of messages application description. Note that the animations will toggle the visibility attribute of the element when it receives and looses focus.

Below is an example of a summary table of the xlink href url parameters for EntryDescription. This summary table applies to the method for specifying application descriptions. The element supports all the attributes of SVG. The mechanism supports an overlapping set but there can be some attributes that are supported by that are not supported by I.e. showInfo in one implementation.

The home screen provides the ability to refer to application icons within the home screen SVG file using the element. An application icon is referenced by prefixing the xlink href attribute with the string x object EntryIcon . The application is identified by specifying it s module name and entry point as the value of the id parameter of the xlink href attribute. The icon will be retrieved from the RibbonIconField class in one implementation SVG can refer to an application icon that is provided by the skin hard coded or can refer to an icon that is provided by the application it s self. The x object EntryIcon xlink href attribute provides the mechanism for referring to an application icon that is provided by the application. The non x object mechanism refers to an image file directly i.e. xlink href messageIcon.png .

Application icons may have a focused and unfocused representation. This is specified by the presence of the focus parameter of the xlink href attribute. For example 

An EntryIcon which does not include to focus parameter will be rendered in the unfocused state. For example 

Preferably it is the responsibility of the SVG to define animations I.e. using or elements which toggle the visibility of the focused and unfocused icon representations. Visibility opacity and x y location are attributes of this kind of foreign object element that are animatable through SVG.

Every application will have a minimum default visual representation that is used for that application. In addition to this representation some applications will define alternative representations for use in specific situations such as the home screen or in banners for example. For Messages at a minimum it provides an icon and a name. This default representation is used in icon themes using the icon grid layout and in an applications list such as the BlackBerry Applications List . In one theme Messages can be represented on the home screen along with a count. In the banner it provides a smaller envelope and a count but no name. In another theme s skin it can provide a list of the most recent new emails. These additional representations are defined above and beyond the minimum default representation of an icon and a name. Elements of the default representation can be defined by the theme or as resources within the application itself. An example of elements of the default representation are as follows 

There are different ways of specifying an unread count in the home screen SVG syntax. In one method Method 1 a foreignOject mechanism is used 

Method 1 allows the home screen to embed an unread count for email. Associating an application entry with an unread count would prohibit the unread count from being associated with an EntryDescription or EntryIcon which is an open slot . method 1 from being used in a slot type home screen design. A slot design refers to the ability to specify application placeholders that are dynamically populated based on the order of applications in an applications list such as the Blackberry Applications List .

Method 2 can optionally specify a showinfo parameter which will render extra info if such info is provided by the application see 3.12.1.6 . The extra info that an application provides is not under control of the theme or SVG skin. This extra info is typically an unread or new count. If the showinfo parameter is specified the info will be displayed immediately to the right of the description.

For example Messages 1 If the unread count is 0 the count and braces will not be displayed. In some circumstances the fact that the unread count is displayed next to the name may be configurable by the user via some option. For example the configuration of feature 3.10 new message status options will determine whether or not the count is displayed as well as its meaning I.e. new vs. unread .

Another possible approach to integrating unread counts into the skin through the use of and elements with known IDs i.e. data elements. This may be a superior approach because it will give more control to the home screen skin over how the unread counts are rendered. It would also allow the counts to be animated. For example 

This is a Non foreign object way of specifying application names and unread count using only data elements I.e. id messagesName and id messagesInfo and leverages the syntax and features of SVG. In the above example the ids messagesName and messagesInfo would be recognized by the home screen application and the appropriate info would be substituted into the skin.

The home screen skin may reference an application in the applications list i.e. Blackberry Applications List by specifying its numerical order in the list starting at 0 which is the first element in the list. For example 

In this case id slot0 specifies that the skin is referencing the first application in the applications list.

The home screen will allow the skin designer to integrate items from the applications list into the home screen layout. The skin designer will be able to specify the location of the menu item slots and their position within the navigation order of the screen. The applications that occupy these slots will be configurable by the user. For applications that extend the default representation the default extensions will also be shown.

This feature provides the ability to integrate calendar information into a home screen SVG skin. illustrate in screenshots examples of calendar integration into a home screen skin in accordance with an embodiment of the present disclosure.

The data elements for calendar will reference calendar events according to their ordinal position in a list sorted by the following criteria 

The skin is updated whenever the list is modified. The list is updated when any of the following actions occur 

The following table describes the data elements related to calendar which may be incorporated into the home screen SVG skin. Descriptions of the columns are as follows 

The home screen SVG syntax will provide the ability to launch the nth calendar item in the Calendar Event through the element. For example 

The above example opens the first calendar event in the calendar event list. The home screen SVG syntax provides the ability to launch the calendar application through the element For example 

The home screen skin has the ability trigger animations on custom events related to the data elements described in the data palette. This may be used to trigger animation effects when information status is updated. Below is a table that describes an example of custom events for calendar 

The following SVG illustrates how to achieve a fade out and fade in effect before and after the data is updated for the calendar1 event 

Preferably there is also a mechanism of getting the skin into the correct state if the device was off for some reason when the event was supposed to happen.

Calendar status will include the ability to represent 1 n of upcoming calendar events for the current day. Clicking on these events will open them or bring up a context sensitive menu if requirement 10 is supported. These events will include 

Each element will have independently themed text styles. The time and subject fields will be left aligned into a column. The subject field will be given a maximum width and the location field will immediately follow the subject field.

Preferably calendar events will be removed from the list when the meeting ends. The exception will be all day events which will be removed 1 hour before the start of the meeting that will bump it off the list.

The home screen SVG supports the integration of an icon and text representation for an application. This is accomplished by specifying an EntryIcon and EntryDescription . The EntryIcon and EntryDescription for phone will display alternate representations depending on whether or not there are new missed calls. If there are new missed calls the EntryDescription will display Missed Calls whereas if there are no new missed calls it will display Phone. The EntryIcon will display a different icon depending on whether there are missed calls or not.

The home screen SVG syntax also provides the ability to launch the phone application directly through the element. For example 

This is related to requirement a noted above i.e. that the application should be able to react to user input from the GUI. This ability allows an application to register for events that are generated by clicking on an SVG element. The application registers itself with the Media Engine API as a MediaListener. When an event is generated by the element a notification is made to the registered MediaListener implementation. The implementation receives a notification that includes the xlink href URI which the code can use to determine which element was clicked and take appropriate action.

Another example of a mechanism for SVG to register for notifications does not use the element. The application listens for activate events on the element directly rather than elements which are triggered off of activate events. As long as the element is focusable the activate event will be generated. A focusable element is one that has an infocus outfocus or activate defined for the element. For example 

Specifying a Launch Phone action that is tied to an arbitrary key event The home screen will provide the ability to define an entry point which is tied to an access key. For example 

In the example foo is the name of the element which must be in focus in order to trigger the loadScene event. accessKey send is the key event upon which to trigger or begin the action. The example essentially says launch the phone application when the element named foo is in focus and the send key is pressed. 

Specifying a Launch Phone action with an optional dial number parameter The phone application entry point will be able to accept a parameter which is a command to dial followed by the number to dial. For example 

In the example command dial is the action that is passed to the phone application when the loadScene action begins. The home screen application should substitute the appropriate number into before passing to the phone application since the term missedcalls1 is a home screen construct unknown to the phone application. The example says launch phone application and dial the number matching when the element named foo is in focus and the send key event is pressed

Specifying a Launch Call Log Entry Context Menu action The home screen SVG syntax will provide the ability to launch a popup menu for a call log entry corresponding to a missed call data element. This behavior can be specified through the element in the home screen SVG file. For example 

The home screen SVG syntax will provide the ability to define a element which opens a message associated with a data element. SVG syntax for opening a message 

The home screen SVG syntax provides the ability to define a element which opens the combined sms and mms inbox. It will do this by specifying the module name and entry point name. SVG syntax for opening the messages application 

The count associated with the combined SMS and MMS entry point is configurable via the message status options screen. The text style and enclosing braces is configurable in the home screen SVG.

The Home Screen SVG skin file may specify slots for applications as described. A themeable area is rendered at the top of Organize Applications screen that indicates how many slots are available and which applications occupy them. This area has a title called Home Screen . The size of the area depends on the number of slots available in the home screen skin. The user may move applications in and out of this area through the normal move operation in Organize Applications. Slots which are assigned to fixed applications in the home screen skin do not appear in the list. Preferably care is taken by the theme developer not to prioritize applications that are assigned to fixed slots in such a way as they would also occupy a position in the Home Screen area. For example if Messages occupies a fixed position on the home screen the theme should set the position of messages so that it does not occupy any of the free slots. This prevents messages from appearing twice on the home screen.

The applications which occupy positions in the Home Screen area also occupy the top positions in the applications list popup. Applications which occupy slots in the home screen should also be accessible from the applications list because this popup can be launched from within any application via a convenience key mapping.

Preferably an application which is hidden is not moveable to a position in the Home Screen area of Organize Applications. This is to prevent hidden applications from occupying a slot on the home screen. Likewise applications which occupy a position in the Home Screen area of Organize Applications are not hideable.

If the home screen skin contains configurable application slots as described these are configured through the organize applications screen. The contents of the home screen application slots are based on the items at the top of the application menu order. If there are 5 slots then the 5 applications at the top of the list would be populated into these slots. The organize applications screen indicates how many of the applications appear on the home screen by drawing a themeable region underneath the icons that fill the available slots. This region has a read only label at the top that says Home Screen . So if a skin has 2 slots the top 2 icons appear over this region. If it has 5 slots then the top 5 appear over this region.

Handheld device will normally incorporate a communication subsystem which includes a receiver a transmitter and associated components such as one or more preferably embedded or internal antenna elements and local oscillators LOs and a processing module such as a digital signal processor DSP . As will be apparent to those skilled in field of communications particular design of communication subsystem depends on the communication network in which handheld device is intended to operate.

Handheld device may send and receive communication signals over the network after required network registration or activation procedures have been completed. Signals received by antenna through the network are input to receiver which may perform such common receiver functions as signal amplification frequency down conversion filtering channel selection and analog to digital A D conversion. A D conversion of a received signal allows more complex communication functions such as demodulation and decoding to be performed in DSP . In a similar manner signals to be transmitted are processed including modulation and encoding for example by DSP . These DSP processed signals are input to transmitter for digital to analog D A conversion frequency up conversion filtering amplification and transmission over communication network via antenna . DSP not only processes communication signals but also provides for receiver and transmitter control. For example the gains applied to communication signals in receiver and transmitter may be adaptively controlled through automatic gain control algorithms implemented in DSP .

Network access is associated with a subscriber or user of handheld device and therefore handheld device comprises a memory module memory module card or a Removable User Identity Module R UIM to be inserted in or connected to an interface in order to operate in the network. Alternatively memory module may be a non volatile memory that is programmed with configuration data by a service provider so that mobile station may operate in the network. Since handheld device is a mobile battery powered device it also includes a battery interface for receiving one or more rechargeable batteries . Such a battery provides electrical power to most if not all electrical circuitry in handheld device and battery interface provides for a mechanical and electrical connection for it. The battery interface is coupled to a regulator that provides power V to all of the circuitry.

Handheld device includes a microprocessor that controls overall operation of mobile station . Communication functions including at least data and voice communications are performed through communication subsystem . Microprocessor also interacts with additional device subsystems such as a display a flash memory a random access memory RAM auxiliary input output I O subsystems a serial port a keyboard a speaker a microphone a short range communications subsystem and any other device subsystems generally designated at . Some of the subsystems shown perform communication related functions whereas other subsystems may provide resident or on device functions. Notably some subsystems such as keyboard and display for example may be used for both communication related functions such as entering a text message for transmission over a communication network and device resident functions such as a calculator or task list. Operating system software used by microprocessor is preferably stored in a persistent store such as flash memory which may alternatively be a read only memory ROM or similar storage element not shown . Those skilled in the art will appreciate that the operating system specific device applications or parts thereof may be temporarily loaded into a volatile store such as RAM .

Microprocessor in addition to its operating system functions preferably enables execution of software applications on handheld device . A predetermined set of applications that control basic device operations including at least data and voice communication applications will normally be installed on handheld device during its manufacture. A preferred application that may be loaded onto handheld device may be a personal information manager PIM application having the ability to organize and manage data items relating to a user such as but not limited to e mail calendar events voice mails appointments and task items. Naturally one or more memory stores are available on handheld device and memory module to facilitate storage of PIM data items and other information.

The PIM application preferably has the ability to send and receive data items via the wireless network. In a preferred embodiment PIM data items are seamlessly integrated synchronized and updated via the wireless network with the mobile station user s corresponding data items stored and or associated with a host computer system thereby creating a mirrored host computer on handheld device with respect to such items. This is especially advantageous where the host computer system is the mobile station user s office or enterprise computer system. Additional applications may also be loaded onto handheld device through network an auxiliary I O subsystem serial port short range communications subsystem or any other suitable subsystem and installed by a user in RAM or preferably a non volatile store not shown for execution by microprocessor . Such flexibility in application installation increases the functionality of handheld device and may provide enhanced on device functions communication related functions or both. For example secure communication applications may enable electronic commerce functions and other such financial transactions to be performed using handheld device .

In a data communication mode a received signal such as a text message an e mail message or web page download will be processed by communication subsystem and input to microprocessor . Microprocessor will preferably further process the signal for output to display or alternatively to auxiliary I O device . A user of handheld device may also compose data items such as e mail messages for example using keyboard in conjunction with display and possibly auxiliary I O device . Keyboard is preferably a complete alphanumeric keyboard and or telephone type keypad. These composed items may be transmitted over a communication network through communication subsystem .

For voice communications the overall operation of handheld device is substantially similar except that the received signals would be output to speaker and signals for transmission would be generated by microphone . Alternative voice or audio I O subsystems such as a voice message recording subsystem may also be implemented. Although voice or audio signal output is preferably accomplished primarily through speaker display may also be used to provide an indication of the identity of a calling party duration of a voice call or other voice call related information as some examples.

Serial port in is normally implemented in a personal digital assistant PDA type communication device for which synchronization with a user s desktop computer as a desirable albeit optional component. Serial port enables a user to set preferences through an external device or software application and extends the capabilities of handheld device by providing for information or software downloads to handheld device other than through a wireless communication network. The alternate download path may for example be used to load an encryption key onto handheld device through a direct and thus reliable and trusted connection to thereby provide secure device communication.

Short range communications subsystem is an additional optional component that provides for communication between handheld device and different systems or devices which need not necessarily be similar devices. For example subsystem may include an infrared device and associated circuits and components or a Bluetooth communication module to provide for communication with similarly enabled systems and devices. Bluetooth is a registered trademark of Bluetooth SIG Inc.

Handheld device may be configured such as via software instructions and data to provide the home screen integrated presentation of information in a GUI as described above.

The system and methods according to the present patent disclosure may be implemented by any hardware software or a combination of hardware and software having the above described functions. The software code either in its entirety or a part thereof may be stored in a computer readable memory. Further a computer data signal representing the software code which may be embedded in a carrier wave may be transmitted via a communication network. Such a computer readable memory and a computer data signal are also within the scope of the present patent disclosure as well as the hardware software and the combination thereof.

While particular embodiments of the present patent disclosure have been shown and described changes and modifications may be made to such embodiments without departing from the true scope of the patent disclosure.

