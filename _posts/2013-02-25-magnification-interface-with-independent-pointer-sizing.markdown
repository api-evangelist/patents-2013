---

title: Magnification interface with independent pointer sizing
abstract: A computer program for rendering a magnified graphic user interface (GUI) establishes an initial magnification level for the graphic user interface and the pointing indicia. The GUI and the pointing indicia are magnified in synchronization until the magnification convergence point is reached. At magnification levels above the convergence point, magnification of the GUI and the pointing indicia becomes decoupled, and only GUI is magnified while the pointing indicia remain at the convergence magnification level. If the GUI magnification level falls below the convergence point, the magnification of GUI and the pointing indicia is recoupled and magnification becomes synchronized. Floor and ceiling magnification values for the pointing indicia may also be established.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09235314&OS=09235314&RS=09235314
owner: Freedom Scientific, Inc.
number: 09235314
owner_city: St. Petersburg
owner_country: US
publication_date: 20130225
---
This application is a divisional application of a U.S. Non Provisional patent application Ser. No. 12 828 735 entitled Magnification Interface with Independent Pointer Sizing filed on Jul. 1 2010 which further claims priority to U.S. Provisional Patent Application No. 61 222 714 filed on Jul. 2 2009.

This invention relates to low vision assistive software and more particularly to a magnification application for a graphic user interface GUI .

Low vision individuals often require magnification of computer screen interfaces to discern text and images. Magnification systems may be built into the operating system itself or may comprise feature rich third party products such as those sold under the MAGIC brand manufactured by Freedom Scientific Inc. based in St. Petersburg Fla.

A deficiency in the current state of the art is the over magnification of the pointing indicia. Low vision users are often limited in the magnification they can impose because the pointing indicia are magnified in step with the entire GUI. Thus at high magnification levels i.e. exceeding 16 fold pointing indicia become so large they obscure much of the GUI itself.

Another deficiency exists in the current state of the art wherein low vision users depending on the application and their own preferences may desire a larger or smaller cursor or caret to enhance productivity. For example a low vision user might desire a mouse pointer for a spreadsheet application to be magnified to 2 fold while the same mouse pointer in a word processing application is easier to use at 4 fold magnification.

An embodiment of the present invention includes a method of rendering a magnified GUI including the steps of establishing a first magnification level for the GUI. The GUI includes the desktop and software applications that execute within the operating system. A second magnification level is established for pointing indicia. The pointing indicia may be a cursor or a caret. A cursor is the graphical image that represents the mouse and its movements. It can take many shapes including but not limited to an arrow for pointing a hand an hourglass or an I shaped text selector. The caret on the other hand is the blinking indicia that is used to enter text.

The magnified GUI is displayed at the first magnification level. Application program interface messaging for the operating system is monitored and calls for a system pointer identifier such as a system pointer handle are intercepted. Alternately or in conjunction with API intercepts the magnification program may poll the operating system for current mouse pointer information including but not limited to its position and shape. Instead of merely displaying the pointing indicia at the magnification level of the GUI the pointing indicia is scaled instead to the second magnification level and subsequently displayed.

To load mouse pointers in a MICROSOFT WINDOWS environment in which the invention may be used applications call the LoadCursor API function 

If hInstance is NULL then lpCursorName contains an identifier representing one of the standard system cursors. These values may include 

If hInstance is not NULL then lpCursorName contains either a numeric or string identifier representing a graphic image contained in the application s resources. LoadCursor returns a numeric handle to the cursor that was loaded. The foreground application selects the active cursor by calling the SetCursor function. This function takes one of the HCURSOR handles previously created by LoadCursor. By intercepting both of these functions it is possible to keep track of the active cursor being used by an application. By intercepting the SetForegroundWindow function it is possible to determine which application is in the foreground and hence track which application s cursor is active system wide.

An alternative method of obtaining the pointer shape under MICROSOFT WINDOWS includes the step of intercepting the drvSetPointerShape value between operating system and display device driver. Using drvSetPointerShape value is most appropriate for the fifteen 15 predefined non obsolete cursor types available in the MICROSOFT WINDOWS application programming interface specification.

In an embodiment of the invention the second magnification level is static. The GUI may be scaled to any magnification but the size of the pointing indicia remains the same.

In yet another embodiment of the invention the second magnification level is preselected according to at least one or more software applications in focus. For example a mouse cursor may be magnified to 4 fold for a word processor application but only magnified 2 fold by a spreadsheet application. The present invention intercepts API messaging to automatically switch second magnification levels based on the application in the foreground or in focus.

The second magnification level may be user modifiable independently of the first magnification level. For example a user may hold down a key combination while moving a mouse wheel to scale the magnification level of the GUI without affecting the magnification level of the pointing indicia. Alternatively a different key combination may invoke magnification only for the pointing indicia. Yet another key combination may re synchronize the GUI and pointing indicia magnification levels. Separate magnifications levels for cursors and carets may also be established.

Another embodiment of the invention intelligently applies a convergence value to optimize the relative magnification of the GUI and pointing indicia. The embodiment includes the steps of magnifying in synchronization both a background GUI and a foreground pointing indicia establishing a magnification convergence value responsive to a magnification level of the GUI exceeding the convergence value decoupling synchronization and displaying the pointing indicia magnified at a lesser relative factor than the GUI magnification level and responsive to a magnification level of the GUI below or equal to the convergence value re coupling synchronization and displaying the pointing indicia magnified at a factor relative to the GUI magnification level.

The synchronization may be achieved by a linear logarithmic or step graph relationship. The convergence value may be derived from a number of factors including the magnification level of the pointing indicia. However an alternate method is to derive the convergence value from a ratio of pointing indicia surface area against GUI surface area. This may be particularly useful as initial pointer size at 1 fold magnification of the GUI may be highly variable i.e. 0.5 1.0 2.0 4.0 etc. . . . .

An embodiment of the invention may include having separate convergence values for cursors and carets. Steps to this embodiment include providing a first convergence value for a cursor and a second convergence value for a caret magnifying the cursor in accordance with the first convergence value and magnifying the caret in accordance with the second convergence value.

A user selectable pointing indicia magnification adjustment may be provided to decouple the synchronization whereby the pointing indicia is magnified independently of the magnification level of the GUI background and the independently magnified pointing indicia is displayed to the user. The user selectable pointing indicia magnification adjustment may include voice commands keystrokes mouse events or the like.

In yet another embodiment of the invention a user may wish to occasionally override the automatic convergence feature of the invention. Responsive to a first user initiated event or adjustment synchronization is decoupled to display the pointing indicia to a user selectable level magnification level. Responsive to a second user initiated event synchronization is re coupled to display the pointing indicia according to the convergence value.

In yet another embodiment of the invention erratic pointer movement following a period of pointer inactivity temporarily scales the pointing indicia from a first to a second magnification level allowing the user to identify the location of the pointing indicia. The pointing indicia is then returned to the first magnification level. Erratic pointer movements are detected by monitoring mouse events for speed and direction of the pointer.

An embodiment of the invention may include one or more computer readable media having computer executable instructions for performing a method of running a software program on a computer the computer operating under an operating system the method including issuing instructions from the software program which include establishing a first magnification level for the GUI establishing a second magnification level for a pointing indicia displaying the magnified GUI at the first magnification level receiving pointer related information either by monitoring application program interface messaging polling for current information or a combination of both scaling the pointing indicia to the second magnification level and displaying the pointing indicia.

To illustrate an advantage of the present invention show a 1 to 1 magnification level between GUI and mouse cursor as would be seen in the current state of the art. In GUI is magnified 2 fold and mouse cursor is similarly magnified to 2 along with objects in GUI such as text and button control . In GUI is magnified 4 fold and mouse cursor is also magnified to 4 . At 4 fold magnification button control and text can no longer be entirely displayed within the magnified desktop area of GUI . In GUI is magnified 8 fold and mouse cursor is also magnified to 8 . In GUI is magnified 16 fold and mouse cursor is also magnified to 16 . In GUI is magnified 32 fold and mouse cursor is also magnified to 32 . At this level of magnification mouse cursor provides questionable utility for the low vision user. In most positions mouse cursor itself cannot be entirely displayed on GUI desktop and obscures other objects on the desktop. Thus when mouse cursor and GUI are always magnified in 1 to 1 synchronization less than desirable results may occur. However in GUI is magnified 32 fold but mouse cursor is only magnified to 16 . At 16 magnification mouse cursor maintains a higher level of utility to the user while the user may still have GUI magnified to a very high level. Bifurcating the relative magnification of the pointing indicia mouse cursor and GUI enables low vision users have meaningful tools to both comprehend the content of GUI at various magnification levels as well as control it via mouse cursor .

In GUI magnification increases from 1 fold to 36 fold and above. Pointer indicia is magnified in step at a 1 to 1 relationship until GUI magnification increases beyond 16 fold. At that point pointer indicia reaches its ceiling value of 16 and no longer is magnified. Hence the prior synchronization between GUI and pointer indicia magnification is decoupled. However as GUI magnification drops back to 16 fold pointer indicia and GUI synchronization is re coupled to a 1 to 1 relationship. This relationship correlates with the illustrations in and .

An alternative embodiment of the invention is shown in wherein regardless of GUI magnification pointer indicia is always magnified at 4 . This is static magnification of the pointer indicia.

In pointer indicia and GUI magnification are synchronized in a 1 to 1 relationship up to a 4 fold magnification. After 4 fold magnification pointer indicia and GUI utilize a second synchronization scheme wherein pointer indicia is magnified in a 1 to 2 relationship with GUI. For example when GUI is magnified 8 fold pointer indicia is magnified to 4 . When GUI is magnified to 16 fold pointer indicia is magnified to 8 . However beyond 16 fold GUI magnification pointer indicia remains at 8 magnification its ceiling value .

In pointer indicia is magnified at 0.5 while GUI is at 1 fold magnification. Synchronization in this example is at a 2 to 1 relationship between GUI and pointer indicia. When GUI is at 2 fold magnification pointer indicia is at 1 . When GUI is at 4 fold magnification pointer indicia is at 2 . When GUI is at 8 fold magnification pointer indicia is at 4 . At GUI magnification levels beyond 8 fold synchronization is decoupled and pointer indicia remains at its ceiling value of 4 .

In two synchronization schemes are provided 1 a first for a mouse cursor solid line and 2 a second for a caret. Caret magnification remains indefinitely synchronized with GUI magnification. This might be preferable when editing highly enlarged text. However the mouse cursor is synchronized on a reduced magnification relationship with respect to GUI until its ceiling value is reached at 16 fold GUI magnification. It should be noted that a floor value may also be imposed against pointing indicia whereby magnification level of the pointing indicia is not reduced even though GUI magnification level is lowered.

In distinct synchronization schemes for mouse cursor versus caret are shown against GUI magnification . Mouse cursor hits a ceiling at 4 fold magnification while caret hits a ceiling at 16 fold GUI magnification.

Pointing indicia magnification levels according to the invention may be overridden by user events. For example holding down one or more keys on the keyboard and scrolling a mouse wheel may zoom in and out the mouse cursor while keeping the magnification level of the GUI constant. Holding down an alternate set of keys and scrolling the mouse wheel may zoom in and out the GUI while keeping the mouse cursor at the same magnification. Yet another keystroke or keystroke combination may decouple or re couple the pointing indicia and GUI magnification synchronization.

In yet another embodiment of the invention erratic mouse movements following a period of mouse inactivity act to temporarily magnify the mouse cursor so that it can be easily located by the low vision user. Erratic movement may include but are not limited to rapid side to side movement and circular movement. In mouse cursor displayed on GUI is moved in circular motion after a period of mouse inactivity. Magnification is applied to display enlarged mouse cursor for a three second interval before magnification is released to again display mouse cursor at its previous magnification level.

In mouse cursor displayed on GUI is moved in a zigzag motion after a period of mouse inactivity. Magnification is applied to display enlarged mouse cursor for a three second interval before magnification is released to again display mouse cursor at its previous magnification level.

In different synchronization schemes for caret and mouse cursor are shown. GUI is 2 fold magnified. Cursor is likewise magnified at 2 while mouse cursor is magnified at 4 .

A monitoring application or worker thread notifies a mouse handling subsystem of the screen magnification change. The pointer subsystem may calculate the mouse cursor magnification based on the following metrics and processes A Compute the base mouse cursor size relative to unmagnified system metrics. For example the user selects 150 base mouse cursor scale. The base size of the mouse cursor would be 1.50 32 pixels 48 48 pixels in size. B Compute the convergence point size. In the case of a 1024 768 display size and assuming a maximum convergence scale of 33 of minor dimension 768 pixels then the maximum mouse size is 768 3 256 pixels. The convergence magnification is the screen magnification level at which the mouse cursor stops scaling. In this example the default value of 16 magnification is presumed. That means that at 16 magnification and for any magnification level beyond 16 the mouse cursor will be contained within a 256 256 pixel bounding box. C Linearly interpolate the per magnification level pixel modifier the amount that the mouse cursor bounding box grows for each magnification level between 1 unmagnified and 16 convergence magnification . The general formula is Max size computed base size number of magnification levels beyond 1 . In the previous example it is 256 48 15 or 13.866 pixels. So for every magnification level beyond 1 an additional 14 pixels are added to each dimension of the mouse cursor bounding box. D Add a multiple of the magnification level pixel modifier and the magnification level beyond 1 to the computed base mouse metric 48 48 . If in this example the GUI is set to 5 magnification then the mouse cursor would occupy the following bounding box 48 4 13.866 approximately 103 pixels which is quite different from and more usable than the 160 160 pixels it would have occupied had the mouse cursor scaling been bounded 1 1 to that of the desktop 32 5 160 .

For any mouse event from the system intercepted by the magnification display driver or for any desktop rendering event that could involve the mouse cursor the magnification engine tells the pointer subsystem to draw itself. The pointer subsystem queries the system for the current mouse cursor by handle or other identifier . The pointer subsystem tries to find a cached vector sourced substitute. If it finds one it sets it to be the current internal mouse cursor. If it fails to find one it copies edge smoothes and caches a scaled version of the mouse cursor that is currently the active one and associates it by handle or other identifier for future use in a separate lookup table. It sets this newly created and cached raster sourced image as the current internal mouse cursor.

The pointer subsystem renders the current internal mouse cursor to an off screen image at a preselected location. That image is ultimately rendered by the magnification subsystem onto the display driver surface.

When a user purposely manipulates the mouse cursor scale independently from the screen magnification the user can manipulate 1 the mouse cursor base scale which would have the result of increasing the final mouse cursor size according to some inverse of the magnification level between 1 and the convergence magnification. Once the user is at the convergence level using this method the user could only decrease the mouse cursor size. The magnitude of the mouse cursor s size change at 1 is significantly more that it would be at 14 . This relationship is shown in . 2 A multiple which may be derived from either a fixed linear logarithmic or other mechanism that is based on mouse cursor and or desktop magnification all which may or may not be allowed to exceed the convergence maximum size.

Cursors and carets may be independently configured. The monitoring application intercepts or polls the operating system for the type of pointer deployed i.e. cursor or caret and the pointer subsystem renders cursor according to a cursor configuration or the caret according to a caret configuration. The configuration for cursor and carets may be controlled by the magnification engine automatically and or set by the user. The magnification engine includes one or more display dialog boxes for individually adjusting cursor and caret settings along with other magnification preferences . These settings are stored in user configuration files such as a registration INI file XML file or the like for later retrieval and use.

An alternative embodiment of the invention is shown in the steps include establishing a first GUI magnification level establishing a second magnification level for pointing indicia . Second magnification level is selected from magnification scheme array including static pointer magnification pointer magnification ceiling pointer magnification floor and direct user adjustment . Magnification scheme array comprises a collection of object properties and settings for the various possible magnification possibilities. The object properties are typically stored on magnetic mediums such as a local hard drive for later recall. The object properties may be saved in various formats including but not limited to system registration INI XML database and the like. The user may switch from one magnification scheme to another responsive to conditions such as an application changing focus. The user may also switch schemes based on user input such as a keystroke or mouse event. Second magnification level may also be calculated based on the surface area of the intercepted system pointer that would cover GUI. For example second magnification level for a pointing indicia may be calculated so that the pointing indicia overlays twenty 20 percent of the entire GUI surface area of the display. For example a desktop that is 680 480 pixels has an area of 307 200 square pixels. A pointer magnified to utilize 61 440 pixels would constitute twenty percent of the total desktop area and thus be considered a ceiling value to the pointer size. In yet another embodiment of the invention the convergence point is calculated based on a percentage of screen area according to the minor screen dimension. By using the minor screen dimension the convergence value achieves a reasonable behavior when performing in largely disproportionate screens. For example a monitor that displays a native resolution of 1360 768 pixels yields a major dimension almost 2 that of the minor. In conditions like these it s preferable to use the minor dimension since that ensures that the convergence value will never exceed any dimension of the display unless explicitly requested by the user. In the above example a convergence value of 60 based on the major dimension would in fact be 816 vertical pixels and exceed the whole of the minor screen dimension.

In the end user sets a pointer floor value which is the smallest the pointer will appear at any magnification level. The pointer floor value in this example is 4 for the Select pointer type.

In convergence values are set for a plurality of different pointers and a plurality of different software applications. For example when a caret is shown in a MICROSOFT WORD software application when the GUI is at 8 magnification the caret is also magnified to 8 . However when the GUI magnification is increased in 16 or 32 the caret shown in MICROSOFT WORD remains at 8 magnification. The magnification of a cursor appearing in MICROSOFT WORD is synchronized with the magnification of the GUI until the GUI magnification exceeds 4 . At that point the cursor stays at 4 magnification while the GUI can continue to increase in magnification. Finally a cursor appearing in MICROSOFT VISUAL STUDIO 2010 is magnified at the same level as the GUI until the GUI exceeds 16 magnification. Therefore it can be seen that when the GUI is at 32 magnification the cursors appearing in MICROSOFT VISUAL STUDIO 2010 remain at 16 . Underneath the listbox showing these various settings a button is provided to add new settings that may vary based on the software application by specific dialog boxes invoked by the operating system API by the type of pointer by the pointer set currently used and the like.

It should be noted that in addition to a method an embodiment of the invention may include one or more non transitory tangible computer readable media having computer executable instructions for performing a method of running a software program on a computer the computer operating under an operating system. In such an embodiment the method may include for example issuing instructions from the software program which include establishing a first magnification level for the GUI establishing a second magnification level for a pointing indicia displaying the magnified GUI at the first magnification level monitoring application program interface messaging intercepting a call for a system pointer identifier scaling the pointing indicia to the second magnification level and displaying the pointing indicia. In other embodiments various other aspects of the methods described above may be included on the non transitory tangible computer readable media.

It will be seen that the advantages set forth above and those made apparent from the foregoing description are efficiently attained and since certain changes may be made in the above construction without departing from the scope of the invention it is intended that all matters contained in the foregoing description or shown in the accompanying drawings shall be interpreted as illustrative and not in a limiting sense.

