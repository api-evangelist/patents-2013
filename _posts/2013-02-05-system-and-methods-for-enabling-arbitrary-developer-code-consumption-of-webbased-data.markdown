---

title: System and methods for enabling arbitrary developer code consumption of web-based data
abstract: A structured file includes information to bind a web data source to a web data query system. Code is embedded within the structured file and is in a code language understood by the web data query system. The code is unrestricted in function. Code language objects are exposed within the web data query system for use by the code to interface with the web data query system and the web data source. A URL is associated with the structured file to enable access of the structured file through the Internet. A unit-based quota method is implemented to manage execution of code in the structured file. The unit-based quota method collapses multiple dimensions of computing resource control into a single unit value, tracks a number of units expended by the code, and stops execution of the code when the number of units expended by the code reaches a set limit.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09442978&OS=09442978&RS=09442978
owner: Yahoo! Inc.
number: 09442978
owner_city: Sunnyvale
owner_country: US
publication_date: 20130205
---
This application is a divisional application under 35 U.S.C. 121 of prior U.S. patent application Ser. No. 12 770 651 filed on Apr. 29 2010 entitled System and Methods for Enabling Arbitrary Developer Code Consumption of Web Based Data which is 1 a continuation in part of prior U.S. patent application Ser. No. 12 607 804 filed on Oct. 28 2009 entitled System for Querying and Consuming Web Based Data and Associated Methods and 2 a continuation in part of prior U.S. patent application Ser. No. 12 607 926 filed on Oct. 28 2009 entitled Developer Interface and Associated Methods for System for Querying and Consuming Web Based Data. The disclosure of each above identified patent application is incorporated herein by reference in its entirety.

In today s web internet universe there exist thousands of web services and web data sources that provide valuable data. The various web services and web data sources can be defined using many different data types and formats which can be either loosely structured or well structured. For example web data sources may exist in formats such as HTML XML JSON RSS Atom microformat among others. In order for an application developer developer to access and utilize data from a given web service data source the developer is required to have a detailed understanding of the given web service data source implementation such as its particular data types and formats. This can require a developer to spend copious amounts of time learning a particular web service data source implementation which can hinder application development.

Additionally the numerous available web services data sources can exist in isolation. This requires the developer to perform separate and multiple processes to access and utilize data from multiple web services data sources. Moreover the developer may only be able to access data from a given web service data source in its entirety which will often require the developer to filter combine tweak and or shape data following its retrieval from a given web service data source.

In view of the foregoing there is a need for improved systems and methods by which a developer can access and utilize data from multiple and diverse web services and web data sources.

In one embodiment a method is disclosed for processing web data through a web data query system. The method includes creating a structured file that includes information to bind a web data source to the web data query system. The method also includes embedding code within the structured file. The code is defined in a code language understood by the web data query system. Also the code is unrestricted with regard to function. The method further includes exposing a number of code language objects within the web data query system for use by the code to interface with the web data query system and with the web data source when bound to the web data query system. The method also includes associating a universal resource locator URL with the structured file to enable access of the structured file through the Internet. The structured file is stored on a computer readable storage medium such that the structured file is accessible through the Internet by way of the URL associated with the structured file.

In another embodiment a method is disclosed for operating a web data query system to manage execution of arbitrary programs on server side computing resources. The method includes identifying code operations for which computing resource consumption is to be controlled. The method also includes respectively assigning a unit cost to each identified code operation. A given unit cost for a given code operation is based on an aggregate amount of computing resources consumed by the given code operation. The method further includes setting a total unit usage limit for a program. The program can include any number of the identified code operations. The method also includes tallying the unit cost of each identified code operation each time it is executed during execution the program. The method also includes stopping execution of the program when a combined tallied unit cost of each identified code operation reaches the total unit usage limit for the program.

In another embodiment a system for querying web data is disclosed. The system includes a query language QL web service defined to expose a QL for specification of a web data source including data to be queried and one or more operations to be performed on the web data source. The system also includes a runtime environment defined within computing systems that back the QL web service. The runtime environment is managed by the QL web service. The system further includes a QL table associated with the web data source. The QL table is accessible through a URL. The QL table includes binding data which binds the web data source to the QL web service. The QL table also includes code defined in a code language understood by the QL web service. The code is confined to execute within the runtime environment. The code is also unrestricted with regard to function.

Other aspects and advantages of the invention will become more apparent from the following detailed description taken in conjunction with the accompanying drawings illustrating by way of example the present invention.

In the following description numerous specific details are set forth in order to provide a thorough understanding of the present invention. It will be apparent however to one skilled in the art that the present invention may be practiced without some or all of these specific details. In other instances well known process operations have not been described in detail in order not to unnecessarily obscure the present invention.

A Query Language QL Web Service is disclosed herein that enables developers and their applications to query filter and combine data from different sources across the Internet. In one embodiment the QL Web Service is referred to as the Yahoo Query Language YQL Web Service. However in other embodiments the QL Web Service can be referred to by other names. It should be understood that the QL Web Service is a web service that is accessible through the Internet via a URL and that can be interfaced with using a well defined language to effect acquisition and consumption of data from one or more web services and or web data sources.

The QL Web Service operates within a system that includes 1 the QL Web Service 2 one or more back end web data sources services and 3 one or more QL tables respectively associated with the one or more back end web data sources services. The back end web data sources services represent entities that exist in the Internet realm that contain data of interest of various types and that are accessible through the Internet via a URL. For ease of discussion the back end web data sources services are referred to hereafter as web data sources. It should be understood however that the term web data source as used herein refers to either data or a service that is accessible through the Internet via a URL.

The QL table is a file which includes information that can be read and understood by the QL Web Service to inform the QL Web Service on how to access and interact with a particular web data source for which the QL table is defined. The QL table serves as a mediator and interpreter between the QL Web Service and the particular web data source for which the QL table is defined. It should be understood that the QL Web Service relies upon the QL table to provide information regarding how to access a web data source what data is available at the web data source and the data format s how to get data from the web data source and how to manipulate data at the web data source. Therefore the QL Web Service itself is not hard coded with knowledge about any particular web data source but rather the QL Web Service is defined to obtain and understand information from a mediating QL table with regard to interfacing and interacting with a particular web data source. Also it should be understood that the data that is obtained by the QL Web Service is actually obtained from the back end web data source and the QL table provides the binding between the QL Web Service and back end data source that enables that data to be obtained.

Each QL table for a given web data source is defined in a format that is understood by the QL Web Service. In one embodiment QL tables are defined in an XML format. However it should be understood that in other embodiments the QL tables can be defined in different formats so long as the QL Web Service is capable of understanding the information contained within the QL tables. The web data sources that are accessed by the QL Web Service can be defined in essentially any format. The binding provided by the QL table between the QL Web Service and a particular web data source informs the QL Web Service as to what type s of data are present within the particular web data source. Using the binding information gleaned from the QL table the QL Web Service knows how to access the data present at the particular web data source in its native format. Once the QL Web Service accesses and retrieves the data from the web data source in its native format the QL Web Service converts the retrieved data into an internal format for processing within the QL Web Service. In one embodiment the internal format is an XML format. However it should be understood that is other embodiments the QL Web Service can be defined to use any one of a number of different internal formats.

Based on user specified controls and parameters the QL Web Service is defined to generate a set of results data from the various data that is retrieved from the one or more back end web data sources. The QL Web Service is defined to convey the set of results data in either of multiple output formats as specified by the user of the QL Web Service. Specifically the QL Web Service is defined to convert the set of results data from the internal format used by the QL Web Service into a user specified output format. In one embodiment the user specified output format is either an XML format or a JSON format. However it should be understood that in other embodiments the QL Web Service can be defined to convey the set of results data in essentially any known output format as selected by the user of the QL Web Service.

Before delving into the more detailed description of the QL Web Service and the language QL it exposes for its use a few features of QL Web Service s utility should be understood and appreciated. It should be understood and appreciated that a user of the QL Web Service does not need to know either the URLs of any web data source to be accessed or the complexities associated with calling the URLs of any web data source. Each QL table that is associated with a particular web data source provides the knowledge to the QL Web Service regarding the URLs of the particular web data source and the complexities associated with calling the URLs of the particular web data source. The QL Web Service in turn abstracts this detailed and complex information regarding the particular web data sources URLs to the user of the QL Web Service. More specifically the QL exposed by the QL Web Service allows the user to specify in a single statement one or more QL tables to be operated upon one or more parameters to be operated upon within the specified QL table s and one or more operations to be performed on the specified parameter s . It should be appreciated that the user does not need to know anything about the URLs that are associated with the web data sources represented by the one or more QL tables. This feature will become more apparent in the description to follow.

Additionally a feature of the QL Web Service to be appreciated throughout the description herein is that the QL Web Service provides for joining of data from different web data sources regardless of ownership of the different web data sources and regardless of how the different web data sources are provisioned and made accessible through the Internet. The web data sources that can be accessed by the QL Web Service by way of appropriately defined QL tables can be owned by any entity can be located anywhere in the world and can include data of any type. Thus the QL Web Service provides for joining web data sources together regardless of their diversity in ownership location and or format to produce a combined set of results data. Although the above mentioned features of the QL Web Service are quite substantial it should be understood that the QL Web Service provides many additional features and services as will be apparent from the following more detailed description of the QL Web Service and its associated query language.

The QL Web Service query language QL includes a number of different statements that can be submitted through an appropriately formatted URL to the QL Web Service to access one or more data sources on the Internet acquire data from the data source transform the acquired data and output the set of results data in a selected format such as XML or JSON format. The QL Web Service can access essentially any type of data source including but not limited to Yahoo Web Services other web services and web content in formats such as HTML XML JSON RSS Atom and microformat among others.

The QL Web Service is accessed through a URL which is defined to include a QL statement for acquiring and or manipulating data at one or more web data sources. In one embodiment the QL Web Service has two URLs wherein one URL allows access to public data and the other URL allows access to both public and private data. For example in one embodiment the following URL allows access to public data which does not require authorization http query.yahooapis.com v1 public yql query params 

Also by way of example the following URL requires authorization e.g. by OAuth and allows access to both public and private data http query.yahooapis.com v1 yql query params 

It should be understood that the provider of data at a web data source may implement some type of protection on the data such that authorization of some sort is required to access the data. If a web data source is protected the QL table associated with the web data source is defined to specify the type of protection implemented and the requirements for accessing the web data source. For example when the web data source requires OAuth credentials the associated QL table will specify that OAuth credential are required. Then the user of the QL Web Service having seen the QL table description will know that appropriate OAuth credentials must be provided to access the web data source.

As indicated in the QL statements operate on QL tables. As discussed above the QL table is a file which includes information that can be read and understood by the QL Web Service to inform the QL Web Service on how to access and interact with a particular web data source. The web data source for which the QL table is defined often contains very large collections of structured data. The Yahoo QL Web Service includes an extensive list of QL tables that cover a wide range of Yahoo Web Services and access to off network data. Additionally the QL Web Service provides for creation and use of QL Open Data Tables to bind any web data source to the QL Web Service thereby enabling access to and consumption of the web data source through the QL Web Service.

As mentioned above some web data sources may implement access protection. A QL table associated with a protected web data source that requires access authorization in some form is referred to as a private QL table. A QL table associated with a non protected web data source that does not require access authorization is referred to as a public QL table. An application can access a public QL table through an endpoint that does not require authentication. For example in one embodiment an application can access a public QL table through the v1 public yql endpoint of the Yahoo QL Web Service which does not require authorization. In another example an application can access a private QL table through the v1 yql endpoint of the Yahoo QL Web Service by supplying appropriate credentials such as OAuth credentials. OAuth is an open standard that allows Yahoo users to share their private resources stored on Yahoo with developers without having to hand out their username and password.

The Yahoo QL Web Service supports two legged and three legged OAuth. The two legged OAuth is an OAuth authorization between two parties 1 an application the Consumer and 2 the public data source the Service Provider . The public data source can be a Web service or Web feeds such as RSS or Atom feeds. A public data source does not require authorization from the end user of the application. The three legged OAuth is an OAuth authorization between three parties 1 the end user User 2 the application the Consumer and 3 the private data source the Service Provider . An application that uses the Yahoo Social Directory APIs for example need authorization by the end user to access private social data.

It should be understood that a QL table referenced herein may be either a private QL table or a public QL table depending on the web data source with which it is associated. However regardless of the whether the QL table is public or private the QL Web Service is defined to utilize the QL table in the same manner such that the QL table serves as a mediator between the QL Web Service and the associated web data source.

The QL statements of can be run in several ways. In one embodiment the QL statements can be run in a Yahoo QL Console which is a QL Web Service user interface that is executable within a web browser. The Yahoo QL Console is described in related U.S. patent application Ser. No. 12 607 926 filed on Oct. 28 2009 entitled Developer Interface and Associated Methods for System for Querying and Consuming Web Based Data which is incorporated herein by reference in its entirety.

In another embodiment a web application can use an HTTP request such as an HTTP GET request for example when running SELECT statements wherein the QL statement is specified as a query parameter of the QL Web Service URL. In one embodiment a web application can use an HTTP GET PUT or DELETE request for the QL statements INSERT UPDATE and DELETE respectively. One exception is when a JSONP callback is specified in the QL statement. In an example embodiment of this case an HTTP GET request can be used with a callback query parameter specified on the GET URI. In yet another embodiment a web application that uses the PHP SDK can call a query method of the YahooSession class.

The SELECT statement of QL retrieves data from one or more QL tables which reference respective web data sources. The QL Web Service fetches data from a back end web data source transforms the data as directed and outputs the data in a specified format. In one embodiment the specified output format is either XML or JSON format. In this embodiment output data is presented in a tabular arrangement in which table rows are represented as repeating XML elements or JSON objects and table columns are XML sub elements or attributes or JSON name value pairs. It should be understood however that in other embodiments the QL Web Service can be defined to output results in essentially any format.

The what clause contains the data fields to retrieve. The data fields correspond to the XML elements or JSON objects that will be conveyed in the output data returned by the QL Web Service based on execution of the SELECT statement. Therefore the data fields in the what clause represent the columns in the tabular arrangement of output results returned by the QL Web Service. An asterisk in the what clause means all data fields. The table parameter is a QL table either a QL pre defined i.e. built in table or a QL Open Data Table that binds a web data source to the QL Web Service. The filter parameter is a comparison expression that limits the data rows in the output data returned by the SELECT statement. The output data results of the SELECT statement can be piped via the pipe symbol to an optional function such as a sort function. In one embodiment of QL statement keywords such as SELECT and WHERE are case insensitive. However table and field names are case sensitive. In string comparisons the values are case sensitive. String literals are enclosed in quotes. Either double or single quotes are allowed.

The QL Web Service includes a projection feature by which a vertical slice i.e. projection of the web source data referenced in the associated QL table can be queried. Specifically data fields can be specified by name in the what clause following the SELECT keyword. Multiple data fields can be delimited by commas. For example SELECT lastUpdated itemurl FROM social.updates WHERE guid me

will return data from the web data source corresponding to the data fields lastUpdated and itemurl from the row in QL table social.updates that has guid me.

SELECT FROM social.updates WHERE guid me will return data from the web data source corresponding to all the data fields in QL able social.updates that has guid me

If the data fields in the result set contain data sub fields the data sub fields can be specified by using periods dots as delimiters. This format is referred to as dot style syntax. For example for the social.profile QL table to get only the imageUrl data sub field of the image data field the following can be specified 

The following lines show part of the output results returned by the QL Web Service in XML format for this SELECT statement. Note that only the imageUrl data subfield is returned.

If one or more non existent data fields is specified in the what clause an HTTP response code is returned such as 200 OK. If none of the data fields in the what clause exist the result set is empty. That is zero rows are returned.

The filter in the WHERE clause determines which rows are returned by the SELECT statement. In other words the filter represents the rows in the tabular arrangement of output results returned by the QL Web Service. The filter in the following statement for example returns rows only if the text field matches the string Barcelona 

In one embodiment the QL has two types of filters remote and local. These filter types are differentiated by where the filtering takes place relative to the QL Web Service. With a remote filter the filtering takes place at the back end web data source called by the QL Web Service. A remote filter has the following syntax 

The input key is a parameter that QL passes to the back end web data source. The literal is a value either a string integer or float . Only the equality operator is allowed in a remote filter. For example in the following statement the input key is photo id SELECT FROM flickr.photos.info WHERE photo id 2186714153 

For this SELECT statement the QL Web Service calls the Flickr Web Service passing photo id as follows 

Most QL tables require the SELECT statement to specify a remote filter which requires an input key. Often the input key is not one of the data fields included in the output results returned by a SELECT statement. To see which input keys are allowed or required the DESC statement can be run for the QL table and the key element of the results can be noted. For example as shown in the following lines the results of DESC flickr.photos.info show that the input key photo id is required 

The QL Web Service also performs local filtering on the data it retrieves from the back end web data source. A local filter has the following syntax 

The field parameter specifies the name of a data field in the output of the QL Web Service e.g. the field parameter corresponds to an XML element or a JSON object in the output data to be conveyed by the QL Web Service. To specify a data sub field the containing data fields are separated with periods. For example the data sub field AverageRating is specified as Rating.AverageRating where the data field Rating includes the data sub field AverageRating. The literal parameter is either a quoted string an integer or a float.

In the following example QL statement the QL Web Service is directed to get data from the flickr.photos.interestingness QL table then apply the local filter

In the following example QL statement the local filter checks that the value of the title field starts with the string Chinese or CHINESE 

In the following example QL statement the local filter contains a regular expression that checks for the substring blue 

In the following example QL statement the local filter is specified to return recent photos with the IDs specified in the parentheses 

Local and remote filter expressions can be combined with the boolean AND and OR operators. In one embodiment the AND operator has precedence over the OR operator. To change precedence expressions can be enclosed in parentheses. An example QL statement that combines filters is as follows 

In the above example the first two filters are remote expressions because query and location are input keys. The third filter in the above example that contains the data field Rating.AverageRating is a local filter.

Based on the foregoing it should be understood that a remote filter is represented by a key word in an equality expression. The remote filter name i.e. key word is defined in the QL table and may or may not directly correspond to some term known by the back end data source associated with the QL table. However the QL table defines what remote filters can be provided what the key words are for those remote filters and how the remote filters are applied to the URL that gets created to call the back end data source. The remote filter is passed to the back end data source and is applied at the back end data source. The local filter is represented by a data field in a comparison expression. The data field is a field name defined in the QL table. The data field is not known by the back end data source. The data field is used by the QL Web Service to identify data during operation on the data within the QL Web Service and within the output data results conveyed by the QL Web Service.

It is possible to join data from different web data sources by specifying their respective QL tables using a sub select form of the QL statement. As previously mentioned the QL Web Service provides for joining of data from different web data sources regardless of ownership of the different web data sources and regardless of how the different web data sources are provisioned and made accessible through the Internet. The web data sources that can be accessed by the QL Web Service by way of appropriately defined QL tables as specified in a sub select form of the QL statement can be owned by any entity can be located anywhere in the world and can include data of any type. Thus the sub select feature of the QL Web Service provides for joining web data sources together regardless of their diversity in ownership location and or format to produce a combined set of results data.

The sub select provides input for the IN operator of the outer SELECT statement. The values in the outer SELECT statement can be either input keys known the back end web data source remote filters or data fields known to the QL Web Service by way of their definition in the QL table local filters . For example by using a sub select the following QL statement returns the profiles of all of the connections friends of the user currently logged in to Yahoo 

In the example above the QL statement joins the social.profile and social.connection QL tables on the values of the GUIDs. More specifically the inner SELECT which follows the word IN returns the GUIDs for the user s connections. For each of these GUIDs the outer SELECT returns the profile information.

QL tables can also be joined on multiple keys. In the following example the local.search and geo.places tables are joined on two keys 

In the above example the inner SELECT returns two data fields centroid.latitude and centroid.longitude which are compared with the two input keys latitude and longitude of the outer SELECT.

In one embodiment one sub select is allowed in each SELECT. In other words each SELECT statement can only have one IN keyword but the inner SELECT may also have an IN keyword. The following statement is acceptable 

Many QL Web Service queries access back end web data sources that contain thousands or even millions of items. When querying large web data sources applications may need to page through the results data to improve performance and usability. The QL Web Service enables applications to implement paging or to limit output data table size at either a remote level or at a local level. To find out how many items output data rows a query SELECT returns in XML formatted output data results the value of the yahoo count attribute of the query element can be checked in the output data results. Similarly to find out how many items output data rows a query SELECT returns in JSON formatted output data results the value of the count object can be checked in the output data results. In one embodiment the maximum number of items returned by a SELECT is 5000. Also in one embodiment the maximum processing time for a QL statement is 30 seconds. Also in one embodiment for most QL tables the default number of items returned is 10 if a limit is not specified in the SELECT statement. It should be understood however that in other embodiments the maximum number of items returned by a SELECT statement the maximum processing time for a QL statement and the default number of items returned can be set at values different than those stated for the example embodiments above.

A remote limit controls the number of items rows that the QL Web Service retrieves from the back end web data source. To specify a remote limit an offset start position and a number of items is specified in parentheses after the table name. The default offset is 0. For example in the following QL statement the offset is 0 and the number of items is 10 

When QL statement above runs QL calls Yahoo Search BOSS the back end web data source for the search.web QL table and gets the first 10 items that match the query pizza filter.

The following example QL statement gets items 10 through 30 i.e. starting at position 10 it gets 20 items 

If only one number n is provided in the remote limit controls the offset is considered to be 0 and the number of items is considered to be n . Therefore the remote limit control of n is the same as the remote limit control of 0 n . For example the following QL statement gets the first 20 items because the default offset is 0 

The default number of items for a remote limit varies with the QL table. For most QL tables the default number of items is 10. The maximum number of items also varies with the QL table. To get the maximum number of items enter 0 in parentheses after the table name. For example the following QL statement returns 1000 items from the back end web data source associated with the search.web QL table 

A local limit controls the number of output data rows the QL Web Service returns to the calling application. The QL Web Service applies a local limit to the data set that it has already retrieved from the back end web data source. To specify a local limit the LIMIT and OFFSET keywords each followed by an integer can be included after the WHERE clause. The integer value following the LIMIT keyword specifies the number of rows. The integer value following the OFFSET keyword indicates the starting position. The OFFSET keyword is optional. The default offset is 0 which is the first row.

When the above QL statement runs the QL Web Service gets up to 100 items from the back end web data source. On these items the QL Web Service applies the local limit and offset. So the above QL statement returns 15 output data rows to the calling application starting with the first row offset 0 .

The QL Web Service retrieves items from the back end web data source one page at a time until either the local or remote limit has been reached. The page size to be applied to the back end web data source is specified in the associated QL table and can vary between QL tables. The following example QL statement has an unbounded remote limit 0 so the QL Web Service retrieves items from the back end web data source until the local limit of 65 is reached 

The QL Web Service includes built in functions such as sort which are appended to the SELECT statement with the pipe symbol . These functions are applied to the result data set after all other operations specified in the SELECT statement have been performed such as applying filters and limits. The following is an example QL statement that includes an appended function 

In the above QL statement the sub select returns a list of GUIDs and the outer select returns a set of profiles one for each GUID. This set of profiles is piped to the sort function which orders the results according to the value of the nickname field.

Multiple functions can be chained together with the pipe symbol . The following QL statement queries the local.search table for restaurants serving pizza. The results are piped to the sort function then to the reverse function. The final result contains up to 20 rows sorted by rating from high to low 

When QL runs a SELECT statement it accesses a back end web data source typically by calling a web service. Remote filters and limits are implemented by the back end web service. Local processing including local filters and limits is performed by the QL Web Service on the data it fetches from the back end web data source. It should be appreciated that whether an operation is remote or local affects the data returned to the application that calls the SELECT statement. shows a table which identifies whether an element in a QL SELECT statement is processed locally or remotely in accordance with one embodiment of the present invention.

In one embodiment the QL Web Service includes a set of pre defined i.e. built in QL tables that call the Yahoo Social APIs. The social.profile table for example contains information about a Yahoo user and the social.connections table is a list of the user s friends. The Global User Identifier GUID is a string that uniquely identifies a Yahoo user. In this embodiment of the QL Web Service the me keyword is the GUID value of the user currently logged in to Yahoo . For example if a given person is logged in to Yahoo and that given person runs the following statement the QL Web Service will return the given person s profile information 

Because me is a keyword it is not enclosed in quotes. To specify a GUID value the GUID value can be expressed as a string enclosed in quotes such as in the following example 

If a URL for a call to the QL Web Service contains var literals the QL Web Service replaces the literals with the values of query parameters with the same names. For example suppose that the URL for the call to the QL Web Service has the animal query parameter 

The QL Web Service includes the ability to access data at back end web data sources that are formatted as structured data feeds such as RSS and ATOM. However if no such feed is available it is possible to specify the source as HTML and use XPath to extract the relevant portions of the HTML page. For example to get information from Yahoo Finance about Yahoo Inc. stock YHOO the following QL statement may be initially used 

Because the above QL statement returns all of the page s HTML it would not be very useful in an application. By adding an XPath expression to the above QL statement it is possible retrieve specific portions of the HTML page. The XPath expression in the following statement traverses through the nodes in the HTML page to isolate the latest headlines 

In the above example the XPath expression looks first for a div tag with the ID yfi headlines. Next the expression gets the second div tag and looks for an anchor tag a within a list item li of an unordered list ul . The following QL statement also gets information about Yahoo Inc. stock but traverses the nodes to get key statistics 

Instead of the wildcard asterisk as shown above it is possible to specify a particular element for the XPath to process. For example the following statement extracts only the HTML links href tags within the headlines on Yahoo Finance 

To get just the content from an HTML page it is possible to specify the content keyword after the word select. A QL statement with the content keyword processes the HTML in the following order 

1. The QL statement looks for any element named content within the elements found by the XPath expression.

3. If neither an element nor attribute named content is found the QL statement returns the element s textContent.

The following QL statement for example returns the textContent of each anchor a tag retrieved by the XPath expression 

In one embodiment the QL Web Service can return i.e. output data in either XML JSON or JSONP format. However it should be understood that in other embodiments the QL Web Service can be extended to return data in essentially any format. In one embodiment the default format is XML. In this embodiment to get output data in JSON format include the format son parameter in the URL of the QL Web service. For example 

To specify JSONP as the output data format include both the format and callback query parameters in the URL of the QL Web service. The callback parameter indicates the name of the JavaScript callback function. For example 

It should be understood that the format of the output data conveyed by the QL Web Service is not dependent on the data format at the back end web data source. For example if a back end web data source expresses its data in XML format the QL Web Service is not restricted to conveying the data acquired therefrom in XML format. For example in this case the QL Web Service can return output data in JSON format or any other format.

In one embodiment the QL Web Service also provides for returning output data as a JSON envelope having XML content. More specifically if the QL statement specifies a callback callback cbfunction and also requests the format to be in XML format xml then the QL Web Service returns a string representation of the XML within an array. This type of output data format is referred to as JSONP X.

In one embodiment each response from the QL Web Service includes a query element which contains diagnostics and results elements. Repeating elements within results element correspond to rows from a QL table. For example the following QL statement returns multiple connection elements within the results element 

The attributes of the query element and the sub elements of the diagnostics element in the output data generated by execution of a given QL statement can be examined to get information about the execution of the given QL statement. shows a table that lists the attributes of the query element in the XML formatted output data returned by the QL Web Service in accordance with one embodiment of the present invention. In the JSON formatted response data the attributes listed in are mapped to the name value pairs contained in the query object.

The diagnostics element in the output data includes information about the calls the QL Web Service made to the back end web data sources. shows a table that lists the XML formatted sub elements of the diagnostics element in accordance with one embodiment of the present invention. In the JSON formatted output data the sub elements listed in are mapped to name value pairs contained in the diagnostics object.

If the QL Web Service output data is returned in JSON format and the back end web data source is defined in an XML format then the QL Web Service transforms the data from XML format to JSON format. In one embodiment the QL Web Service transforms XML formatted data to JSON formatted data according to the following rules 

The QL Web Service includes an extensive list of built in QL tables for use that cover a wide range of Yahoo Web services and access to off network data. A listing of the built in QL tables can be obtained by running the QL statement SHOW TABLES. A description of any QL table can be obtained by running the QL statement DESC table where table is the name or URL of the QL table to be described.

Additionally the QL Web Service provides for creation and use of QL Open Data Tables thereby enabling the QL Web Service to bind with any web data source through the QL language. A QL Open Data Table definition is an independently defined structured file e.g. XML file that contains at least the following information to enable binding of the associated web data source with the QL Web Service 

The QL Web Service provides the QL USE statement to access external data via QL Open Data Tables. A single QL Open Data Table can be accessed as indicated in the following example QL USE statement

In the above QL statement USE precedes the location of the QL Open Data Table definition which is then followed by AS and the table name to be associated with the specified QL Open Data Table definition. After the semicolon the QL statement is formed as discussed above with regard to the QL SELECT statement. In the above example the QL Web Service fetches the URL indicated by the USE statement and makes it available as a table named mytable in the current request scope. The statements following use can then select or describe the particular table using the name mytable.

Multiple QL Open Data Tables can be invoked by using multiple USE statements as shown in the following example 

Additionally a QL environment file can be defined to specify use of multiple QL Open Data Tables. The QL environment file provides for use of multiple tables at once without having to specify the USE verb in the QL statements. The QL environment file is a text file that contains a list of USE and SET statements typically ending with a .env suffix. An example QL environment file may appear as follows 

Once the QL environment file is uploaded to the developer s server the developer can simply access the QL Web Service and append the location of the file as follows 

Also multiple QL environment files can be utilized at once by using multiple env query parameters. The multiple QL environment files are loaded in the order they appear in the query string. For example 

The QL Web Service provides for the set up of key values for use within QL Open Data Tables. For example it is possible to set values such as passwords API keys and other required values independently of QL statements and API calls. The following example sets the api key value within the QL statement itself select from guardian.content.search where api key 1234567890 and q environment 

The SET keyword allows you to set key values outside of a QL statement including within QL environment files. The SET keyword uses the following syntax within a QL environment file 

In the example above SET is followed by the key api key and its value 1234567890 and the prefix guardian of the table is specified. Once a key value is set within an environment file the key value is removed from the QL statement as follows 

The SET keyword can be used to hide key values or data. More specifically to avoid exposing private data when sharing QL Open Data Tables a combination of QL features can be used to hide such data as follows 

The QL Web Service is defined to support a structured arrangement of elements and sub elements within a QL Open Data Table. In one embodiment the available QL Open Data Table elements and sub elements include the following which are described in detail below 

The table element is the root element for the document. A table is the level at which an end user can select information from QL web data sources. A table can have many different bindings or ways of retrieving the data. In one embodiment a single table provides a single type of data. The following is an example specification of the table element 

In the above example xmlns is an attribute of the table element. shows a listing of attributes available for specification in association with the table element in accordance with one embodiment of the present invention. It should be understood that in other embodiments the table element may have more or less available attributes than those specifically shown in .

The securityLevel attribute of the table element as listed in determines the type of authentication required to establish a connection. In order for a user to connect to the QL Open Data Table the user must be authorized at the level or higher than the level indicated in the securityLevel attribute. shows a table that lists whether access is available depending on the value in the securityLevel attribute.

In addition to the table element the QL Open Data Table is required to include the meta sub element. The following is an example specification of the meta sub element 

In the above example author documentationURL and sampleQuery are attributes of the meta sub element. shows a listing of attributes available for specification in association with the meta sub element in accordance with one embodiment of the present invention. It should be understood that in other embodiments the meta sub element may have more or less available attributes than those specifically shown in .

Situated within each bindings element is one of four keywords select insert update or delete. The select element describes the information needed for the QL Web Service to read data from an API. The insert and update elements describe the information needed to add or modify data from an API respectively. When removing data the delete element is used to describe the necessary bindings.

When a keyword such as select or update is repeated within the bindings array it can be considered to be an alternative way for the QL Web Service to call a remote server to get the same type of structured data. Typically this is used when the service supports different sets of query parameters QL s keys or combinations of optional query parameters.

Unlike XML JSON objects have no root node. To work with the dot notation the QL Web Service creates a pseudo root node for JSON responses called json . If it is necessary to return a sub structure from a QL Open Data Table that fetches or produces JSON json should be added at the root of the path.

In the above example itemPath is an attribute of the bindings select element. shows a listing of attributes available for specification in association with the bindings select element in accordance with one embodiment of the present invention. It should be understood that in other embodiments the bindings select element may have more or less available attributes than those specifically shown in .

The table bindings select uric uric element referred to as the urls element is where the QL Web Service and the QL Open Data Table supporting the back end web data source come together. The url element describes the URL that needs to be executed to get data for the particular QL Open Data Table given the keys in the key elements. While generally there is only one URL specified if a particular web data service supports a test select and it is desirable to expose it an additional urls element can be added for that environment.

The CDATA TEXT for the urls element contains the URL itself that utilizes substitution of values at runtime based on the uri template spec. The names of the values will be substituted and formatted according to the uri template spec but one method is to enclose a key name within curly braces . All name keys found in the URL will be replaced by the same id key value in the keys elements. The QL Web Service currently supports both http and https protocols. An example of this is shown as follows 

In the above example the QL Web Service will look for key elements with the names publisher and bucket. If the QL statement developer does not provide those keys in the WHERE clause and they are not optional then the QL Web Service detects the problem and will produce an error. If an optional variable is not provided but is part of the QL Open Data Table definition it will be replaced with an empty string. Otherwise the QL Web Service will substitute the values directly into the URL before executing it.

The table bindings select execute element referred to as the execute element allows for invocation of server side JavaScript in place of a GET request. An example of the execute element is shown as follows 

By way of the execute element it is possible to embed JavaScript and E4X the shortened term for EcmaScript for XML which adds native XML support to JavaScript. When a QL statement calls a QL Open Data Table having a definition that includes the execute element the QL Web Service does not perform the request to the templated URI in the endpoint. Rather the QL Web Service provides a runtime environment in which the JavaScript is executed server side. The JavaScript in turn is required to return data as the output to the original QL statement.

The ability to execute JavaScript via the execute element extends the functionality of QL Open Data Tables in many ways including the following 

In one embodiment there are three types of elements available within the inputs element key value and map. Each key element represents a named key that can be provided in the WHERE or INTO clause of QL SELECT INSERT UPDATE or DELETE statements. The QL Web Service inserts these values into the URL request before it is sent to the server. The QL Web Service inserts these values into the URL request if the paramType is set to query or path or header. For a variable type the key named as the id of the element is made available in the execute section of the QL Open Data Table.

The value element can be used to assign a new value or update an existing value within a QL Open Data Table. The value element defines a field that can only be set as an input and therefore cannot be in QL statements to satisfy the WHERE clause. The value element only works with the INSERT and UPDATE verbs and in different ways.

When used with the insert keyword the value element appears in the VALUE expression of the QL statement indicating that a new value is being passed into the QL statement as seen in the following example 

When used with the update keyword the value element is called from the SET portion of the QL statement. This indicates that you are setting a particular value as seen in the following example 

The map element enables use of dynamic keys. With the map element the QL Web Service uses the value passed in through the QL statement as a variable. This variable is used within the execute portion of the QL Open Data Table to determine what action to take. For example you may set up a QL Open Data Table that updates either bit.ly delcio.us or tinyurl depending on the value specified in the QL statement. For a dynamic key called type the actual ID in a QL query would look like the following field.type Java 

In the absence of the map element as a binding all identifiers not corresponding to a binding element and that appear in a QL query are treated as local filters. The map element can be used for each of the paramTypes query matrix header path and variable as described in . The following is an example of the map element being used in a path 

For a query containing the relational expression field.type rss only the dynamic parameter name type would be substituted in the urls element. The URI template would look like the following 

In the above example key and value are elements under the inputs element. shows a table indicating which keywords select insert update delete support the key value and map elements in accordance with one embodiment of the present invention. shows a table listing the attributes available within the key value and map elements in accordance with one embodiment of the present invention.

The QL Web Service provides for aliasing within the key value and map elements. For instance if there is an obscurely named id in the QL Open Data Table an alias can be defined and used to refer to it within QL statements. For example perhaps an id called q is present within the QL Open Data Table which actually is a search parameter. The term as can be used to create an alias in the following way 

The table bindings select paging element referred to as the paging element describes how the QL Web Service should page through the web data source results if they span multiple pages or the service supports offset and counts. An example of the paging element is shown as follows 

The paging element includes an attribute model that is used to specify the type of model to use to fetch more than the initial result set from the web data service. The attribute model can be set equal to a literal value of either offset page or url. The offset value refers to services that allow arbitrary index offsets into the result set. The page value is used for services that support distinct pages or some number of results. The url value is used for services that support a URL to access further data e.g. to access the next page of data. When the url paging model is used the pagesize element discussed below may be used to adjust the number of results returns at once if the web data service allows.

The paging element includes the following sub elements pagesize start total and nextpage. The pagesize element provides information about how the number of items per request can be specified. The start element provides information about how the starting item can be specified in the set of results. The total element provides information about the total number of results available per request by default. The nextpage element provides information about the location of the next page of results. The nextpage element is an optional element used in conjunction with the parent url element. shows a table listing the attributes available within the pagesize start total and nextpage elements in accordance with one embodiment of the present invention.

The QL SELECT statement allows for reading of structured data from almost any source on the Web. To perform data manipulation the QL Web Service provides three other keywords INSERT UPDATE DELETE for writing updating and deleting respectively data mapped using a QL Open Data Table. The QL INSERT statement inserts or adds new data to a back end data source associated with a QL table. The QL UPDATE statement updates or modifies existing data at a back end data source associated with a QL table. The QL DELETE statement removes data from a back end data source associated with a QL table. It should be understood that the INSERT UPDATE and DELETE operations are performed on back end data sources and are performed independently from the SELECT operation. The INSERT UPDATE DELETE statements require the proper binding inputs such as key value or map. The actual addition modification or deletion of data is performed within the QL Open Data Table. Most web sources that provide write capability need authentication. Examples of authentication include username password combinations or secret API tokens. If the QL table requires input that is deemed private such as any passwords authentication keys or other secrets the https attribute within the tables element should be set to true.

The INSERT UPDATE DELETE statements rely entirely on appropriate bindings within a QL Open Data Table to be usable. Specifically it is necessary to use an insert update or delete bindings element. These binding elements help to determine what happens with the information you pass in through a QL statement. For Web services that require specific authentication methods or specific types of HTTP requests the QL Web Service provides several JavaScript methods for use within the execute element including 

The INSERT INTO keywords marks the start of an INSERT statement. The table is either a QL built in table or a QL Open Data Table that represents a data source. Following the table name is a list of field names indicating the table columns where the QL Web Service inserts a new row of data. The VALUES clause indicates the data inserted into those columns. String values are enclosed in quotes. In one embodiment of the QL Web Service statement keywords such as SELECT and WHERE are case insensitive. Table and field names are case sensitive. In string comparisons the values are case sensitive. String literals are enclosed in quotes. Either double or single quotes are allowed.

The UPDATE keyword marks the start of an UPDATE statement. This is followed by the table name. The table is either a QL built in table or a QL Open Data Table that represents a data source. The SET clause is the part of the statement in which new data is passed to the update binding in the QL Open Data Table. The WHERE clause indicates which data should be updated. In one embodiment only remote filters can be present in the WHERE clause of an UPDATE statement. The following example shows how the UPDATE statement syntax can look for updates to a user s status on Yahoo Profiles 

In the above example status and guid are all bindings within the inputs element which is nested within an update element. The status is a value element since this is data that is updating a value using the QL Open. Data Table. The guid binding is a key element as it is a required key that determines ownership of this status.

The DELETE keyword marks the start of a DELETE statement. The table is either a QL built in table or a QL Open Data Table that represents a data source. This is immediately followed by a remote filter that determines what table rows to remove. The following example deletes a particular Twitter tweet wherein the remote filters are the ID of the tweet followed by the username and password for the owner of the tweet 

The QL Web Service is defined to process the QL statement and perform the operations directed by the QL statement by accessing a URL addressed QL table via the Internet . As discussed above the QL table is a structured file defined to bind a particular web data source service to the QL Web Service . By way of the QL table the QL Web Service is informed as to how the particular web data source service can be accessed and consumed thereby binding the particular web data source service to the QL Web Service .

The QL Web Service platform is defined to execute the QL Web Service . As such the QL Web Service platform is defined to connect via the Internet with any of a number of computing nodes A that contains a QL table addressed by a particular URL. Additionally based on the binding of a web data source service by the QL table the QL Web Service platform is defined to connect via the Internet with any of a number of computing nodes A representing the platform that serves the web data source service associated with the QL table. Through this connection the QL Web Service can access and consume the web data source service associated with the QL table as requested by the QL statement received at the QL Web Service platform from the developer .

A system is disclosed herein for querying web data. The system includes a web data source including data to be queried. The web data source is defined in either an HTML format an XML format a JSON format an RSS format an Atom format or microformat among others. The system also includes a query language QL web service defined to expose a QL for specification of the web data source including data to be queried and one or more operations to be performed on the web data source. Requirements specific to the web data source for accessing and performing operations on the web data source are abstracted through the exposed QL. The QL web service is accessible through a QL web service URL. The QL web service URL is either a public URL enabling access to public web data sources or a private URL enabling access to both public and private web data sources. The system further includes a QL table associated with the web data source. The QL table is accessible through a universal resource locator URL . The QL table includes binding data which binds the web data source to the QL web service. The binding data includes instructions to the QL web service with regard to creating URLs to access and retrieve data from the web data source.

The QL web service is defined to query data within the web data source retrieve data from the web data source based on the query filter the retrieved data and format the retrieved and filtered data. The QL web service is also defined to transform the retrieved data from a format in which it exists at the web data source into a different specified format. In one embodiment the QL web service is defined to convey the retrieved data in a tabular arrangement in either an XML format or a JSON format. The XML format specifies XML elements as rows of the tabular arrangement and specifies XML sub elements or XML attributes as columns of the tabular arrangement. The JSON format specifies JSON objects as rows of the tabular arrangement and specifies JSON name value pairs as columns of the tabular arrangement. The QL web service is also defined to filter the data retrieved from the web data source according to one or more remote filters one or more local filters or a combination thereof. Remote filters are applied to data at the web data source. Local filters are applied to data at the QL web service. Additionally the QL web service is defined to query data within the web data source in accordance with paging specifications.

It should be appreciated that the system for querying web data can include multiple web data sources each including respective data to be queried and multiple QL tables respectively associated with the multiple web data sources. The QL web service is defined to use binding data in the multiple QL tables to simultaneously access and retrieve data from the multiple web data sources that are respectively associated with the multiple QL tables and return the data retrieved from the multiple web data sources in a combined format. The multiple web data sources from which data is retrieved can be defined in accordance with different data formats. The QL web service is defined to join multiple web data sources by providing for use of one or more key identifiers returned in a first set of queried data resulting from a first query of a first web data source as input parameters in a second query of a second web data source. In this manner a second set of queried data resulting from the second query is based on the one or more key identifiers returned in the first set of queried data.

A method is disclosed herein for querying web data. The method includes an operation for generating a query language QL statement defined to identify one or more QL tables respectively associated with one or more web data sources and to specify one or more actions to be performed on the one or more web data sources. The QL statement is formatted in accordance with a QL syntax. The method also includes an operation for embedding the generated QL statement within a universal resource locator URL directed to a QL web service. The URL directed to the QL web service is executed within an Internet browser such that the QL statement embedded in the URL is executed by the QL web service.

The method continues with processing the QL statement through the QL web service whereby the QL web service accesses the one or more QL tables identified in the QL statement through the Internet and retrieves direction from the one or more QL tables regarding access and retrieval of data from the one or more web data sources respectively associated with the one or more QL tables identified in the QL statement. Based on the direction retrieved from the one or more QL tables the QL web service is operated to access the one or more web data sources respectively associated with the one or more QL tables and perform the one or more actions on the one or more web data source as specified in the QL statement. The method further includes an operation for conveying a result of the one or more actions performed on the one or more web data sources by the QL web service to the Internet browser in which the URL directed to the QL web service was executed. The result can be conveyed as textual data in visual form such as within a display of a computer system. Also the result can be conveyed as digital data to be stored and processed by a computer system.

Another method is disclosed herein for binding web data to a web data query system. The method includes an operation for creating a structured file that includes information to bind a web data source to the system for querying web data. In one embodiment the structured file is defined in an XML format. The information in the structured file includes authentication and security specifications indicating a type of authentication required for the web data query system to access the web data source and indicating whether or not the web data query system is required to access the web data source over a secure connection. The information in the structured file also includes instructions for how the web data query system should create universal resource locators URLs that access data available from the web data source. The method also includes an operation for associating a URL with the structured file to enable access of the structured file through the Internet. The method further includes an operation for storing the structured file on a computer readable storage medium such that the structured file is accessible through the Internet by way of the URL associated with the structured file.

In the above method the instructions for how the web data query system should create URLs that access data available from the web data source includes a web data source URL and specification of query parameters that are available to access particular data within the web data source. Additionally the information included within the XML file includes pagination options specifying how the web data query system should traverse through the data available from the web data source. Also the information included within the XML file further includes a sample query that is executable by the web data query system to demonstrate how data can be retrieved from the web data source.

Building upon the QL Web Service s Open Data Tables an element gives developers full control of how the data is fetched into the QL Web Service and how the data is presented back to the user thereby letting the computing systems behind the QL Web Service do the data processing work. When a QL statement calls a QL Open Data Table definition that contains the element the QL Web Service does not perform the request to the templated URI in the endpoint. Instead the QL Web Service provides a runtime environment in which the developer code e.g. JavaScript within the element is executed on the computing systems that back the QL Web Service. The developer code executed by way of the element then returns the resulting data as the output to the original QL statement. The output from the element is then fed into the processing pipeline within the QL Web Service engine including local filtering projection and piped functions. In one embodiment the developer code executed by way of the element can be specified directly within the element in the QL Open Data Table. In another embodiment the developer code executed by way of the element can be referenced from within the element in the QL Open Data Table. In this embodiment the developer code may actually reside at a network accessible location outside of the QL Open Data Table.

With the element developers can build tables that manipulate change and sign the URLs to access almost any protected content on the web. Therefore with the element the QL Web Service can access and combine data across a variety of different authenticated web services. Developers can call multiple web services and web data sources within the element to join and mash up data however they desire. By way of the element web data can be tweaked and manipulated into an optimal format for applications to consume.

As discussed above the QL Web Service exposes a SELECT syntax that is usable by developers to acquire and consume web based data. Through the SHOW and DESC commands developers are able to discover available web data sources and structures without having to open another Web browser. The QL Open Data Tables allow developers to define how the QL Web Service query language should bind to web services or web data sources. As discussed above the QL Open Data Table is defined using a single structured document e.g. XML document that specifies which input keys are to be provided to the QL Web Service and how these input keys map to the URL that can fetch data from the web service or web data source. Once created the QL Open Data Table definitions can be shared or contributed to a set of community developed tables hosted by the QL Web Service.

While QL Open Data Tables can bind to many web services there are situations where difficulties may arise. For example different web services can require different signing techniques for their URLs or can return data that s not well formatted like HTML pages . The element provides for extension of the capabilities of the QL Open Data Tables to connect to these other types of web services sources to enable developers to have finer grained control of the QL statement execution within the QL Web Service platform.

Rather than iterating on the QL Open Data Table schema to keep adding additional elements to the templates for every combination of requirements across the diverse population of web data services the element provides a means for developers to take control of the QL Web Service runtime whenever their QL Open Data Table is used. The element enables QL Open Data Table developers to fully control how the QL Web Service binds to web services sources how the QL Web Service should make requests to web services sources and how and what data should be returned by the QL Web Service. The flexibility afforded by a code based component i.e. the element that can be specified in a QL Open Data Table and executed through the QL Web Service engine enables developers to solve problems of authenticating signing and making calls to remote web sources where these problems may be new may not have been previously contemplated and or may not be addressable through built in capabilities of the QL Web Service.

The element contains arbitrary server side code provided by the QL Open Data Table developer that runs during the execution of the QL statement using that QL Open Data Table. In one embodiment the element is allowed to contain arbitrary JavaScript code. However it should be understood that in other embodiments the element can include other types of code so long as the code is understood by the QL Web Service and the systems implemented therein to execute the code.

The developer is allowed to embed any arbitrary code e.g. JavaScript in the execute element. Embedded developer code provided by way of a given element is run inside the computing systems that back the QL Web Service during use of the QL Open Data Table that includes the given element. It should be understood that the language used to define the code provided by way of the element is not transformed or limited in any way by the QL Web Service. Therefore the element enables full application logic i.e. code to be embedded within the QL Open Data Table definition which in some cases represents an API to a web service source.

The element provides a highly flexible binding mechanism between the QL syntax and downstream data providing web services. Thus the element represents a middleware mechanism to arbitrarily transform or mashup data from web services sources. The element extends the QL Open Data Table capabilities through server side transformation and processing using any arbitrary developer code e.g. JavaScript.

The element dramatically increases the reach and power of QL Open Data Tables. For example the element enables the following operations among others 

In one embodiment the element runs server side JavaScript with E4X native XML support. This gives developers a fully functional language and lets them do almost anything they want with the data. As discussed in more detail below the QL Web Service extends the JavaScript language to include a number of global objects specific to the QL Web Service to enable developers to include JavaScript libraries and code from any URL fetch data from any URL Web page run other QL commands and perform data filtering and conversion.

The QL Web Service architecture is simple and scalable due to its almost stateless nature. In one embodiment each engine that interprets and runs QL statements is written in Java and runs in a Tomcat server. The Tomcat server is a Java based Web Application container defined to run Servlets and JavaServer Pages JSP in Web applications. In one embodiment each Tomcat server is fronted by yapache which takes care of ydod and oauth checks. Also in one embodiment outbound requests from Tomcat to fetch external data from web services web pages go via an internal QL Web Service side HTTP caching layer and via htproxy to prevent access to internal endpoints. It should be understood that in other embodiments the computing architecture that backs the QL Web Service can be defined by other types of servers and software than those mentioned for the specific embodiment above so long as the functionality of the QL Web Service as disclosed herein is maintained.

In one embodiment a Rhino interpreter is used to run JavaScript provided by way of the element in the QL Web Service platform. It should be appreciated that the JavaScript language is a straightforward standalone scripting language with no inherent potentially dangerous capabilities like network or file access. Anything beyond the basic script execution must be introduced through internal QL Web Service side Java classes and must be white listed in Rhino to be accessed by scripts. The Rhino interpreter is a Java open source library that can run JavaScript code. The Rhino interpreter includes 

A number of options are defined for running developer code provided by way of the element within a QL Open Data Table through the Rhino interpreter within the Tomcat server as part of the QL Web Service architecture. depicts a first option for running developer code through the Rhino interpreter in which one dedicated process or server is used per element script in accordance with one embodiment of the present invention. In this option the Tomcat server takes a QL request and communicates with one of many Execute Services. Each Execute Service is separated from the rest of the processing to ensure insulation from malicious scripts. Each Execute Service is automatically restarted in case it exits with a non zero exit code. In this option element scripts are processed serially. This option has good isolation properties and has the ability to pinpoint any malicious script. This option does incur an overhead of having to serialize data to and from the Execute Service. There is also a need to create the execute servers or processes themselves. Also in this option the number of scripts that can be simultaneously run is limited to the number of execute services available at any given moment.

For the Rhino JavaScript interpreter to function meaningfully with the QL Web Service QL specific extensions to the JavaScript language are provided to enable runtime access to certain parts of the current QL Web Service execution state and fetching of additional network data or external libraries. shows a table summarizing QL specific global objects introduced to JavaScript for use in developer code provided through the element in accordance with one embodiment of the present invention. The global objects include a y object a request object and a response object. The y global object provides access to additional language capabilities specific to the QL Web Service. The request global object provides the URL on which the QL Web Service would normally perform a GET request in the absence of the element. The response global object allows for specification of how responses are handled. The object response.object provides the results of the element. For instance the value of the response.object can be set to the data to be returned as an E4X object a JSON structure or simply as a string.

The y global object includes methods that provide the basic QL Web Service functionality within JavaScript. The methods of the y global object also provide for inclusion of QL Open Data Tables and JavaScript from remote sources. shows a table summarizing a number of y global object methods in accordance with one embodiment of the present invention. It should be understood that the y global object methods of are provided by way of example. In other embodiments additional y global object methods beyond those shown in can be defined and exposed for use through the QL Web Service. The y global object and its methods enables developer code provided by way of the element to fetch data run other QL statements create and shape data and return data back to the QL Web Service for subsequent processing.

The y.rest method enables the developer code within the element to make GET requests to remote web services sources. The y.rest method also allows the developer code within the element to pass parameters and headers in the GET requests. It should be noted that the request global object is available as an instantiated y.rest instance with all values filled in shows a table summarizing a number of y.rest method properties objects in accordance with one embodiment of the present invention. In other embodiments additional y rest method properties and or objects beyond those shown in can be defined and exposed for use through the QL Web Service. The following shows an example specification of the y.rest method 

The y.rest method also supports chaining which means that an entire REST request can be constructed and run by creating a chain of methods. An example of this is shown as follows 

Along with the QL request the QL response can be set through the properties of the y.rest.get object. shows a table summarizing a number of y.rest.get object properties in accordance with one embodiment of the present invention. In other embodiments additional y.rest.get object properties beyond those shown in can be defined and exposed for use through the QL Web Service.

The y.query method allows the developer code within the element to perform additional QL queries. shows a table summarizing a number of y.query method properties in accordance with one embodiment of the present invention. In other embodiments additional y.query method properties beyond those shown in can be defined and exposed for use through the QL Web Service. Queries called from the y.query method return and execute instantly. However data is returned when the results property is accessed. This feature allows the developer code to make multiple independent simultaneous queries which are processed before being returned together when the results property is accessed. The following shows an example specification of the y.query method 

The y.query method also accepts a hashed set of variables which can be useful for variable substitution on a parameterized query. The following is an example of this which shows substitution of the URL on Yahoo Finance 

The QL Web Service provides several cryptographic functions for use within JavaScript. These cryptographic functions reduce the need for external libraries and make the QL Web Service easier to use. shows a table summarizing a number of y.crypto method functions in accordance with one embodiment of the present invention. In other embodiments additional y.crypto method functions beyond those shown in can be defined and exposed for use through the QL Web Service. The following shows an example specification of the y.crypto method 

The various keys supplied as part of the QL statement are set as global variables during execution of the developer code within the element. shows a table summarizing global variables available for use within the element in accordance with one embodiment of the present invention. In other embodiments additional global variables beyond those shown in can be defined for use with the element.

The QL Web Service handles paging of returned data differently depending on how the developer controls paging within an Open Data Table definition. To illustrate how the element works with different paging controls consider the following example followed by three paging element scenarios 

Paging Scenario 1 No page element specified in the Open Data Table that includes the element. When no paging element is specified the QL Web Service assumes that all available data is to be returned at once. Any remote paging information provided in the select statement 10 being the offset and 100 being the count in our example will be applied to all of the results before being processed by the remainder of the where clause in the select statement. In the example above the first 10 items will be discarded and only another 100 will be used and the element will only be called once.

Paging Scenario 2 A paging element is specified in the Open Data Table that only supports a variable number of results. When a paging element is provided that only supports a variable number of results a single page with variable count the element will only be called once with the total number of elements needed in the variable representing the count. In this scenario the offset will always be 0. In the example above the count will be 110 and the offset will be 0.

Paging Scenario 3 A paging element is specified in the Open Data Table that supports both offset and count. When a paging element is provided that supports both offset and count the element will be called for each page until it returns fewer results than the paging size. In this scenario if the paging size were assumed to be 10 the element will be called up to 10 times and expected to return 10 items each time. If fewer results are returned paging will stop.

In most cases paging within the Open Data Table should match the paging capabilities of the underlying web data source that the table is using. However if the element is adjusting the number of results coming back from a fully paging web service or source then it may not be possible to unify the offset of the page as set up in the Open Data Table with the destinations offset. In this case it may be necessary for the developer to declare the Open Data Table as only supporting a variable number of results.

To get a better understanding of how the developer code within the element is behaving the y.log method can be used to log diagnostic and debugging information. Also a y.getDiagnostics element can be used to keep track of execution items such as syntax errors or uncaught exceptions. The following example logs hello along with a variable 

Using y.log allows the developer to get a dump of data as it stands to ensure for example that the right URLs are being created or that the right responses are being returned. The output of y.log goes into the QL Web Service diagnostics element when the table is used in a select statement. The following JavaScript can be used to get the diagnostics that have been created during execution of the code within the element 

The QL Web Service is designed to be self serve with no barriers for developers to start using and extending. Consequently QL Open Data Tables and JavaScript supplied by the developer in them via the element are not subject to human review. Anyone can create a QL Open Data Table including arbitrary code specified through an element therein and use it without review. This creates a potential for malicious or poorly written developer code executing on the computing systems that back the QL Web Service. Examples of malicious or poorly written developer code include among others 

In general the challenge of managing potentially malicious or poor developer code can be considered in terms managing use of processor memory and input output IO . Fortunately the Rhino interpreter provides a number of features that assist in creating a runtime sandbox for JavaScript executed therein. These Rhino features include stack depth limits monitoring of the number of JavaScript instructions executing instancing no shared state between Rhino instances and white listing of external Java classes that can be exposed to the runtime environment. However the Rhino interpreter does not include features to control of the following 

Java does not support accurate monitoring of processor or memory heap per thread and the garbage collection model further complicates the ability to track these resources. However the QL Web Service needs a mechanism to account for the resources processor memory network that an script is consuming in order to prevent problem scripts from going out of control. Rather than attempting to measure and limit each of these computing resources processor memory network separately a method is disclosed herein for using a combination of a unit based approach where each code resource consumed by the script has an associated unit cost and basic fail safe runtime limits to enforce control over scripts. Once an script uses all of its allocated units or hits one of these basic fail safe runtime limits the script is stopped and returned. shows a table of limits applied to code within QL Open Data Tables in accordance with one embodiment of the present invention. It should be understood that the limits specified in the table of are provided by way of example and may be adjusted augmented or reduced in other embodiments.

The unit based quota method for controlling developer code execution through the element avoids the complexities associated with independently tracking and accounting for processor memory and network usage. In the unit based quota method different functions and objects within the developer code consume different and respectively assigned unit costs. The unit cost of a given developer code function or object is based on its cumulative consumption of processor memory and network. Therefore the unit based quota method for controlling developer code execution collapses the three dimensions of control processor memory network into a single unit value which is more amenable to explanation measurement and accounting.

In one embodiment unit counting is based on object creation during execution of an script. Objects created by Rhino during JavaScript execution are real Java objects. However each object may consume different amounts of computing resources processor memory network . For example creating a string consumes memory proportional to the string length. Creating a y.rest object will consume network resources. Running a y.query consumes network memory and processor. Therefore each object accessed implicitly or explicitly from Rhino is tracked to account for its unit cost. A higher unit cost can be assigned to objects that are more dominant in their use of a given computing resource to provide for balance of the given computing resource to other scripts. Additionally the Rhino interpreter provides an instruction counting mechanism that can be used as a proportional indicator of processor usage by a given object.

The runtime environment of the QL Web Service also includes a number of overall limits that serve to further constrain and control queries that may be run through code within the element. The element has the same absolute time limit as any QL statement e.g. 30 seconds. After this time limit the thread running that QL statement or element is stopped and any already produced data on the output stream is returned to the caller. To prevent Java from running out of memory and to help recovery from multiple memory abusive scripts running together a memoryWatcher is created on each Tomcat server instance. The memoryWatcher monitors the memory usage across the entire virtual machine VM . When the memory usage exceeds a certain threshold e.g. 90 the memoryWatcher calls System.exit 1 which causes the Tomcat server to gracefully shut down allowing for completion of inflight requests and stopping acceptance of new requests . Once shutdown the yjava daemon restarts the Tomcat server instance and the Tomcat server instance starts accepting requests again.

In one embodiment all network calls made from a QL Open Data Table defined outside of the QL Web Service provider are forced to go out via the HTTP htproxy servers that run outside of the QL Web Service provider s firewall. This prevents any calls from coming back into QL Web Service provider s internal services. Also in one embodiment a custom HTTP header is used to avoid recursive calls into the QL Web Service provider s system.

While the unit tracking and various safeguards outlined above will terminate a poorly behaved or malicious script it still consumes resources before being stopped. Therefore it is desirable to prevent the same problem script or associated QL Open Data Table from being executed repeatedly. Also it may be of interest to have the developer source of the problem script blocked from executing other potentially problematic scripts or QL Open Data Tables.

To prevent a problem script or associated QL Open Data Table from being executed repeatedly an md5 value i.e. hash value s computed for the contents of the element each time the element is run and each run failure of the element is recorded against the corresponding computed md5 value in the back end memory of the QL Web Service. If a given script causes a specified number of failures to occur in a specified time window a blocked entry is recorded against the md5 value of the given script in the back end memory of the QL Web Service and no script with that md5 value is allowed to run for a set period of time e.g. one hour.

To prevent a developer source of a problem script from repeatedly executing other potentially problematic scripts or QL Open Data Tables each run failure of an element associated with the developer source is recorded against the interest protocol IP address e.g. YahooRemoteIP address of the developer source in the back end memory of the QL Web Service. If a given developer source is responsible for a specified number of failures in a specified time window a blocked entry is recorded against the developer source in the back end memory of the QL Web Service and no QL Open Data Table and or script associated with that developer source is allowed to run for a set period of time e.g. one hour.

It should be understood that the QL Open Data Tables of are provided by way of example only and do not in any way represent an exhaustive set of features and functionality available through JavaScript within the element. In fact the JavaScript that can be defined within the element is unrestricted in regard to its capabilities and can be defined to perform essentially any operation that is possible through the JavaScript language and associated objects exposed by the QL Web Service.

The element provides arbitrary scripting functionality to the QL Web Service platform and enables the QL Web Service to connect to essentially any API and or web data service source in essentially any way and return essentially any data in any form. The open self serve developer code capability provided by way of the element allows developers to solve the particular complexities of accessing any given web service source and grants almost limitless possibilities without requiring changes to the underlying QL Web Service platform. The ability to execute developer code e.g. JavaScript via the element extends the functionality of QL Open Data Tables in many ways including the following 

As discussed above the output data results of a QL query i.e. of the SELECT statement can be piped via the pipe symbol to an optional function for post processing to either decorate modify aggregate and or reduce the items that are returned by the QL query. The QL Web Service includes a number of built in functions which can be appended to the SELECT statement with the pipe symbol . These pipe functions are applied to the result data set after all other operations specified in the SELECT statement have been performed such as applying filters and limits. Also multiple functions can be chained together with the pipe symbol . Examples of built in pipe functions include the following 

It is difficult to define a set of built in functions that can be applied to QL query results to satisfy all conceivable developer requirements. Therefore it is desirable to allow developers to write their own functions. To this end the QL Web Service includes a binding type called function. The function binding allows developers to create functions through use of the element. Functions defined through the function binding are allowed to participate in determining the response structure. Functions defined through the function binding are not required to understand or dictate the QL Open Data Tables that they can be used with thereby enabling reusability of the functions.

The function binding allows the creator of a QL Open Data Table to use the element infrastructure to define the function. An example QL Open Data Table schema including a function binding is shown as follows 

In one embodiment there are two classes or types of functions in the QL Web Service 1 stream and 2 reduce. Therefore the function type can either be type stream OR type reduce . In one embodiment the default function type is stream . One or more pipe keys are required for functions which either reduce or stream the response. The pipe keys contain the current XML item which has passed the criteria of the QL query including any local filter that has been applied.

The stream type of function is called for each item. The stream type of function can modify the item and return its Modified version of the item. For example the stream type of function can be used to decorate an item with extra information. The stream type of function can use response.object to set the response. shows an example QL Open Data Table that includes a stream type of function named decorate defined using the element in accordance with one embodiment of the present invention. The example QL Open Data Table of can be called using the following example QL query statement 

The reduce type of function is called for each item that is collected stored and called a subsequent time to return the resulting reduced or aggregated response. For example the reduce type of function can be defined to sort truncate count or otherwise operate on a data set. The reduce type of function can declare an itemPath in the case where the function returns multiple items. In the reduce type of function the element code gets an implicit global variable called session which is a map that can be used to store key value pairs that are used by the code to construct the final response. The reduce type of function is called n 1 times where n is the number of items. For each item the reduce type of function is called one time. After the reduce type of function has been called for all n items the reduce type of function is called one more time with a value of null set on the pipe id variable. On this last call the function is expected to identify that the total number of data items has been processed and is expected to use the response.object to set the response. shows an example QL Open Data Table that includes a function named sort defined using the element in accordance with one embodiment of the present invention.

The method continues with an operation for exposing a number of code language objects within the web data query system for use by the code to interface with the web data query system and with the web data source when bound to the web data query system. A method is performed to associate a URL with the structured file to enable access of the structured file through the Internet. In an operation the structured file is stored on a computer readable storage medium such that the structured file is accessible through the Internet by way of the URL associated with the structured file.

The method further includes constraining operation of the code within the web data query system to provide security for the web data query system from the code and to control computing resources consumed by the code. The code embedded within the structured file is executed on one or more computing systems that back the web data query system. Also the code is executed within a runtime environment that is controlled by the web data query system. It should be appreciated that the code embedded within the structured file is not reviewed prior to its execution.

In one embodiment the number of code language objects exposed within the web data query system in operation are instrumented to enable tracking and management of computing resources consumed by the code embedded within the structured file upon its execution. A unit based quota method can be implemented to manage execution of the code embedded within the structured file. The unit based quota method collapses multiple dimensions of computing resource control into a single unit value tracks a number of units expended by the code and stops execution of the code when the number of units expended by the code reaches a set limit. In one embodiment the multiple dimensions of computing resource control include processor memory and network.

Additionally in one embodiment the code embedded within the structured file is encapsulated within a function binding i.e. the function binding discussed above. In one embodiment the function binding is specified as either a stream type of function or a reduce type of function. The stream type of function is defined to modify a data item and return a modified version of the data item. The reduce type of function is defined to operate on a collection of data and return a resulting reduced or aggregated set of data.

The method further includes an operation for setting a total unit usage limit for a program. The program can include any number of the identified code operations. The method also includes an operation for tallying the unit cost of each identified code operation each time it is executed during execution of the program. In an operation execution of the program is stopped when a combined tallied unit cost of each identified code operation reaches the total unit usage limit for the program. Stopping execution of the program includes performing a controlled stoppage of the program and returning any results generated by the program up to the point of stoppage.

In one embodiment the method further includes an operation for dynamically adjusting the unit cost assigned to any one or more of the identified code operations during execution of the program. The dynamic adjustment of the unit cost can be based on a consumption level of the computing resources.

In one embodiment the method can also include operations for monitoring a number of additional computing system metrics and stopping execution of the program when any one of the additional computing system metrics reaches a corresponding set limit. The additional computing system metrics can include among others 

The QL Web Service disclosed herein represents a system for querying web data. This system includes a query language QL web service defined to expose a QL for specification of a web data source including data to be queried and one or more operations to be performed on the web data source. This system also includes a runtime environment defined within computing systems that back the QL web service. The runtime environment is managed by the QL web service. This system further includes a QL table associated with the web data source. The QL table is accessible through a URL and includes binding data which binds the web data source to the QL web service. The QL table can also include code defined in a code language understood by the QL web service. The code is confined to execute within the runtime environment. Also the code is unrestricted with regard to function.

The runtime environment is defined to constrain operation of the code to provide security for the QL web service from the code and to control computing resources consumed by the code. The code included in the QL table is not reviewed prior to its execution within the runtime environment. The QL web service exposes code language objects for use by the code to interface with the QL web service and with the web data source. The code includes a number of the code language objects exposed by the QL web service. The number of code language objects exposed within the QL web service are instrumented to enable tracking and management of computing resources consumed by the code during its execution.

Embodiments of the present invention may be practiced with various computer system configurations including hand held devices microprocessor systems microprocessor based or programmable consumer electronics minicomputers mainframe computers and the like. The invention can also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a wire based or wireless network.

With the above embodiments in mind it should be understood that the invention can employ various computer implemented operations involving data stored in computer systems. These operations are those requiring physical manipulation of physical quantities. Usually though not necessarily these quantities take the form of electrical or magnetic signals capable of being stored transferred combined compared and otherwise manipulated.

Any of the operations described herein that form part of the invention are useful machine operations. The invention also relates to a device or an apparatus for performing these operations. The apparatus may be specially constructed for the required purpose such as a special purpose computer. When defined as a special purpose computer the computer can also perform other processing program execution or routines that are not part of the special purpose while still being capable of operating for the special purpose. Alternatively the operations may be processed by a general purpose computer selectively activated or configured by one or more computer programs stored in the computer memory cache or obtained over a network. When data is obtained over a network the data may be processed by other computers on the network e.g. a cloud of computing resources.

The embodiments of the present invention can also be defined as a machine that transforms data from one state to another state. The data may represent an article that can be represented as an electronic signal and electronically manipulate data. The transformed data can in some cases be visually depicted on a display representing the physical object that results from the transformation of data. The transformed data can be saved to storage generally or in particular formats that enable the construction or depiction of a physical and tangible object. In some embodiments the manipulation can be performed by a processor. In such an example the processor thus transforms the data from one thing to another. Still further the methods can be processed by one or more machines or processors that can be connected over a network. Each machine can transform data from one state or thing to another and can also process data save data to storage transmit data over a network display the result or communicate the result to another machine.

The invention also be embodied as computer readable code on a computer readable medium. The computer readable medium may be any data storage device that can store data which can thereafter be read by a computer system. Examples of the computer readable medium include hard drives network attached storage NAS read only memory random access memory FLASH based memory CD ROMs CD Rs CD RWs DVDs magnetic tapes and other optical and non optical data storage devices. Portions of the computer readable code can also be stored on multiple computer readable media distributed within a network of coupled computer systems so that the computer readable code is stored and executed in a distributed fashion within the network of coupled computer systems.

Although the method operations of various embodiments disclosed herein were described in a specific order it should be understood that other housekeeping operations may be performed in between operations or operations may be adjusted so that they occur at slightly different times or may be distributed in a system which allows the occurrence of the processing operations at various intervals associated with the processing as long as the processing of the overall operations are performed in the desired way.

Although the foregoing invention has been described in some detail for purposes of clarity of understanding it will be apparent that certain changes and modifications can be practiced within the scope of the appended claims. Accordingly the present embodiments are to be considered as illustrative and not restrictive and the invention is not to be limited to the details given herein but may be modified within the scope and equivalents of the appended claims.

