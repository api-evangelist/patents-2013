---

title: Coalescing graphics operations
abstract: Techniques for coalescing graphics operations are described. In at least some embodiments, multiple graphics operations can be generated to be applied to a graphical element, such as a graphical user interface (GUI). The graphics operations can be coalesced into a single renderable graphics operation that can be processed and rendered.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09633408&OS=09633408&RS=09633408
owner: Microsoft Technology Licensing, LLC
number: 09633408
owner_city: Redmond
owner_country: US
publication_date: 20130614
---
Today s computing devices have an ever increasing amount of processing power. For example a typical device has a central processing unit CPU with multiple processing cores that can each perform data processing. Further the number of cores available on individual processors continues to increase. With the prevalence of multi core processors comes the ability to perform multiple processing tasks on a CPU in parallel. For example multiple processing threads that each handles a particular processing task can execute at the same time on respective cores of a processor. Thus the speed with which multiple tasks can be completed is increased over previous single core processors.

While available processing power has increased many computing processes still utilize a serial processing approach for scheduling and or managing processing tasks. For example some applications are not configured to parallelize certain processing tasks and thus do not leverage the parallel processing capabilities of multi core processors. By not parallelizing processing tasks these processes do not receive the performance benefits that result from parallel processing.

This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used as an aid in determining the scope of the claimed subject matter.

Techniques for coalescing graphics operations are described. In at least some embodiments multiple graphics operations can be generated to be applied to a graphical element such as a graphical user interface GUI . The graphics operations can be coalesced into a single renderable graphics operation that can be processed and rendered.

Techniques for coalescing graphics operations are described. In at least some embodiments multiple graphics operations can be generated to be applied to a graphical element such as a graphical user interface GUI . The graphics operations can be coalesced into a single renderable graphics operation that can be processed and rendered.

For instance consider a scenario where a web browser displays a webpage. Techniques discussed herein can utilize a first thread to perform various processing for the webpage such as webpage JavaScript execution formatting tasks layout tasks input processing tasks and so forth. A second independently running thread can be employed to perform rendering tasks such as displaying a current view of the webpage to a screen.

Based on events that affect visual attributes of the webpage the first thread can perform graphics operations that change visual state information for the webpage. Examples of such events include user input to the webpage animation of graphical elements events generated by other processes and so forth. The visual state information for example can include changes to a visual state of the webpage such as movement of graphical elements of the webpage resizing and or recoloring of graphical elements panning and or scrolling of the webpage and so forth.

Further to the example scenario the second thread may not be immediately available to process the graphics operations and render to the webpage based on the operations. For instance the second thread may be busy rendering based on previous graphics operations generated by the first thread.

Accordingly the graphics operations may be queued until the second thread becomes available. The graphics operations for instance may be queued as synchronization points that each corresponds to a discrete change in the visual state of the webpage. When the second thread becomes available to process the graphics operations the graphics operations can be coalesced into a single graphics operation that can be applied to the webpage. Either thread for example can combine the graphics operations into a combined graphics operation that reflects state changes from each of the individual operations. Thus the second thread need not process each graphics operation separately but can process and render the combined graphics operation to arrive at the same visual state of the webpage that would occur if each graphics operation were individually processed.

In the following discussion an example environment is first described that is operable to employ techniques described herein. Next a section entitled Synchronization Points for Propagating State Information describes some example implementation scenarios and procedures that utilize synchronization points in accordance with one or more embodiments. Following this a section entitled Coalescing Graphics Operations describes some example implementation scenarios and procedures for coalescing graphics operations in accordance with one or more embodiments. Finally a section entitled Example System and Device describes an example system and device that are operable to employ techniques discussed herein in accordance with one or more embodiments.

Having presented an overview of example implementations in accordance with one or more embodiments consider now an example environment in which example implementations may by employed.

Computing device includes a processor which is representative of functionality to perform various types of data processing for the computing device . For example the processor can represent a central processing unit CPU of the computing device . The processor includes multiple processor cores that are capable of individually performing processing tasks. Thus the processor is configured to perform parallel processing such as executing multiple processing threads simultaneously. Further examples of implementations of the processor are discussed below with reference to .

The computing device further includes applications which are representative of functionalities to perform various tasks via the computing device . Examples of the applications include a word processor application an email application a content editing application a gaming application and so on.

The applications include a web platform application which is representative of an application that operates in connection with web content. The web platform application for example can include and make use of many different types of technologies such as by way of example and not limitation uniform resource locators URLs Hypertext Transfer Protocol HTTP Representational State Transfer REST HyperText Markup Language HTML Cascading Style Sheets CSS JavaScript Document Object Model DOM as well as other technologies. The web platform application can also work with a variety of data formats such as Extensible Application Markup Language XAML Extensible Markup Language XML JavaScript Object Notation JSON and the like. Examples of the web platform application include a web browser a web application e.g. web app and so on.

Further illustrated is a process manager module which is representative of functionality to manage various aspects of processing tasks for the computing device . A graphics module is also included which is representative of functionality to perform various graphics related tasks for the computing device . For instance the graphics module can perform graphics processing rendering tasks and so forth. The graphics module for example can represent a rendering engine for the applications such as the web platform application . In at least some embodiments the process manager module and or the graphics module can be leveraged to implement techniques for coalescing graphics operations discussed herein.

While the process manager module and the graphics module are illustrated as separate from the applications this is not intended to be limiting. The process manager module and or the graphics module for example can be implemented as a part and or extension of the applications such that their respective functionalities can be leveraged by the applications . Alternatively or additionally the process manager module and or the graphics module can be implemented as part of an operating system of the computing device . Further operational aspects of the process manager module and the graphics module are discussed below.

The computing device includes a display device which is configured to output graphics for the computing device . Displayed on the display device is a graphical user interface GUI which is representative of a GUI associated with one of the applications . The GUI for example can include web content presented via the web platform application . For instance the GUI can represent a web document such as a webpage. According to one or more embodiments techniques for coalescing graphics operations discussed herein can be employed to perform various processing tasks related to the GUI such as layout processing input processing graphics rendering and so forth.

Having described an example environment in which the techniques described herein may operate the following sections now discuss example techniques for utilizing synchronization points for propagating state information and then examples techniques for coalescing graphics operations in accordance with one or more embodiments.

The following section describes example implementation scenarios and procedures further to utilizing synchronization points for propagating state information in accordance with one or more embodiments.

The following discussion describes some example implementation scenarios for techniques for utilizing synchronization points for propagating state information described herein. The example implementation scenarios may be implemented in the environment of the system of and or any other suitable environment. The scenarios for example can represent functionality of the process manager module and or the graphics module . For instance the processing threads discussed in the different scenarios can be generated and or maintained by the process manager module and or the graphics module .

The scenario further includes a primary thread and a render thread which are representative of threads that are employed to perform various processing tasks as part of generating managing and rendering the GUI .

Generally the primary thread represents a processing thread that performs various types of management tasks for the GUI . Examples of management tasks include generating the GUI such as for one of the applications . Other examples of management tasks include executing script e.g. JScript for the GUI GUI formatting tasks GUI layout tasks DOM manipulations and so forth. The render thread represents a processing thread that performs rendering operations such as painting pixels of the GUI to a display. For example changes to visual aspects of the GUI generated by the primary thread can be rendered for display by the render thread . According to various embodiments the primary thread can pass various graphics information to the render thread for rendering and display.

Proceeding to the center portion of the scenario a change to a visual aspect of the GUI causes the primary thread to generate graphics data . The graphics data for example can describe a change to a visual aspect of the GUI . Examples of such changes include color changes visual element resizing animation of a visual element repositioning of a visual element and so forth. The change for instance can occur in various ways including in response to user interaction with the GUI via various types of user input time based notifications or changes from executing website code.

In response to generating the graphics data a paintable synchronization point PSP is generated. Generally the PSP represents a set of information that can be used by the render thread to render portions of the GUI . The PSP for example can include and or be based on the graphics data . Alternatively or additionally the PSP can include information sufficient to enable the render thread to retrieve the graphics data such as a memory address at which the graphics data resides.

In at least some embodiments the PSP includes various types of state information for the GUI . For example the PSP can include state change information such as an indication of visual attributes of the GUI that have changed since a previous PSP was generated and or a previous render operation was performed by the render thread . Thus according to one or more embodiments the PSP may not include data for a complete rendering of the GUI but may simply indicate state change information sufficient to update the GUI to a new visual state. This is not intended to be limiting however and in at least some embodiments a PSP can represent a complete rendering of a GUI.

After emitting the PSP the primary thread may continue processing management tasks for the GUI e.g. without waiting for the render thread to retrieve and or process the PSP .

Proceeding to the lower portion of the scenario the render thread processes the PSP to generate a state change . Generally the state change is a re render of a portion of the GUI based on state information from the PSP . Thus the state change is applied to the GUI e.g. as part of a render and or draw operation to synchronize a visual state of the GUI with the visual state indicated by the PSP . In this particular example application of the state change causes a repositioning of the visual element e.g. a translational movement of the visual element within the GUI .

Thus the scenario illustrates that changes to a visual state of a graphical element generated by a first thread can be encapsulated via a PSP that can be consumed by another thread to apply the changes. Further the first thread may continue performing other processing tasks after the PSP has been emitted e.g. without waiting for the PSP to be processed. Thus in at least some embodiments a PSP provides a mechanism by which state information can be transferred between independent threads.

In at least some embodiments techniques discussed herein enable multiple PSPs to be generated and processed asynchronously. For instance consider the following example scenario.

The scenario further includes a primary thread and a render thread for the GUI . Example details concerning a primary thread and a render thread are discussed above. Based on visual state changes to the GUI a PSP queue is generated that includes multiple PSPs. For instance the PSP queue includes a PSP a PSP and a PSP that are generated by the primary thread . The PSPs can be generated based on various events such as user interaction with the GUI events generated by processes and so forth. As referenced above the PSPs correspond to changes in a visual state of the GUI . For instance the PSPs can correspond to movement of the visual element in the GUI .

In at least some embodiments PSPs can accumulate in the PSP queue when the PSPs are generated by the primary thread faster than the render thread can process and apply the PSPs. For instance the render thread may be performing a complex and time consuming render operation based on a recently consumed PSP such that the primary thread generates additional PSPs before the render thread completes the complex render operation. Thus PSPs can be queued in a temporally sequential order with an older PSP placed before a newer one in the queue.

Proceeding to the lower portion of the scenario the render thread retrieves the PSP from the PSP queue . The render thread processes the PSP to generate a state change . The state change corresponds to a change in a visual state of the GUI . For example the state change represents a difference between a previous visual state and a current visual state of the GUI . Accordingly in at least some embodiments the PSP and thus the state change do not represent a complete re rendering of the GUI but include data that can be applied to update the visual state of a portion of the GUI .

The render thread applies the state change to the GUI such as by re rendering a portion of the GUI. For instance the render thread can change a visual aspect of the visual element such as recoloring the visual element resizing the visual element and so forth based on data from the state change generated from the PSP . Alternatively or additionally applying the state change can involve movement of the visual element such as translation rotation and so forth.

In response to the render thread retrieving and processing the PSP the PSPs move up in the PSP queue . Thus after the render thread is finished processing and applying the PSP the render thread can retrieve and process the PSP . In at least some embodiments PSPs are consumed by the render thread from the PSP queue in an order in which they were generated by the primary thread and placed in the queue. Processing of PSPs from the PSP queue can continue until no further PSPs remain to be retrieved in the PSP queue and or the GUI is closed.

Thus the primary thread can generate PSPs that represent multiple visual state changes to the GUI and can place them in the PSP queue for subsequent processing by the render thread . This enables the primary thread to be available to perform other processing tasks without waiting for the render thread to consume PSPs from the PSP queue . Accordingly the primary thread and the render thread can run independently with interaction between the threads occurring via PSPs.

In at least some embodiments techniques discussed herein enable user input to be efficiently processed via a render thread. For instance consider the following example scenario.

Further illustrated are a primary thread and a render thread for the GUI . Details concerning primary threads and render threads are discussed above.

Proceeding to the center portion of the scenario a user provides input to the GUI . Examples of the input include touch input mouse input keyboard input voice input and so forth. In at least some embodiments the input represents input data received from an input functionality such as an input device driver.

In response to receiving the input the primary thread processes the input to generate a PSP . The PSP represents changes to the GUI based on the input . The PSP for example can indicate various manipulations of the GUI . For instance the PSP can indicate that the GUI is to be scrolled in a display area a zoom in or a zoom out on a portion of the GUI a change to the visual element and so forth.

Continuing to the lower portion of the scenario the render thread retrieves and processes the PSP to generate a state change for the GUI . The state change indicates a re render of the GUI based on the PSP e.g. based on the input . Thus the render thread renders the GUI based on the input . As referenced above this can include scrolling the GUI zooming on a portion of the GUI panning the GUI and or other manipulations of portions of the GUI .

Thus once the render thread has obtained data describing a user input e.g. from a PSP and or otherwise the render thread can apply the input to the GUI independent of interaction with the primary thread . This enables the primary thread to perform other processing while the input is being applied by the render thread and enables the render thread to actively render the GUI based on the input even if the primary thread is busy with another task.

According to various embodiments data that describes a visual region of a display e.g. a GUI can be represented as a tree structure or display tree. Generally a display tree is a data structure that represents various visual elements of a region of a display. A display tree for instance includes different nodes that correspond to respective visual elements of a GUI. As described below interactions between threads can be characterized via manipulations and versions of a display tree. For instance consider the following example scenarios.

The scenario further includes a primary thread and a render thread for the GUI . Example details concerning primary threads and render threads are discussed above. The primary thread is associated with a display tree which is a data representation of the GUI . The display tree for example includes nodes that represent various visual elements of the GUI . For instance the display tree includes a parent node that represents the primary window of the GUI as well as multiple child nodes that each represents a respective visual element of the GUI .

According to one or more embodiments the display tree is utilized by the primary thread to perform various processing for the GUI . For instance as various events occur that indicate modifications to visual elements of the GUI the primary thread modifies the display tree accordingly. Thus the display tree is owned by the primary thread and is updateable by the primary thread to reflect various changes that are to be propagated to the GUI .

Proceeding to the center portion of the scenario a PSP is generated by the primary thread according to various techniques discussed herein. The PSP can be emitted by the primary thread for example in response to various events that change visual aspects of the GUI . The PSP is associated with a display tree .

According to one or more embodiments the display tree represents a snapshot e.g. copy of the display tree captured at a particular moment. For example the primary thread can modify one or more nodes of the display tree in response to various events. The primary thread can then generate a copy of the display tree as the display tree . The primary thread emits the PSP that includes and or is linked to the display tree . Thus the display tree corresponds to a state of the display tree at a particular instance in time.

After the primary thread emits PSP with the display tree the primary thread can proceed with performing other tasks. For instance the primary thread can make further modifications to the display tree without affecting the display tree .

The scenario further includes a display tree maintained by the render thread . Generally the display tree is utilized by the render thread for rendering visual aspects of the GUI . For instance the render thread reads from the display tree to draw to the GUI . According to one or more embodiments the display tree was generated and or modified based on a display tree from a previous PSP e.g. a PSP received prior to the PSP . Thus the display tree is owned by the render thread . For example in at least some embodiments the display tree cannot be directly accessed or modified by the primary thread .

Proceeding to the lower portion of the scenario the render thread retrieves the PSP and modifies the display tree based on the display tree associated with the PSP . The display tree for instance can indicate changes to one or more nodes of the display tree . Thus the changes can be propagated from the display tree to the display tree . Once the state of the display tree is synchronized with the state of the display tree the render thread can proceed with rendering the GUI based on the updated display tree .

Thus visual processing applied by the primary thread to the display tree is propagated via the display tree to the render thread which then applies the visual processing to its own display tree .

Further illustrated in the lower portion of the scenario is that the primary thread emits a PSP which includes a display tree . As with the display tree the display tree is a copy of the display tree generated by the primary thread . The display tree for example includes changes to the state of the display tree that have occurred subsequent to the display tree having been generated.

When the render thread is finished drawing to the GUI from the current state of the display tree the render thread can retrieve the PSP and can synchronize the display tree with the display tree . The render thread can then proceed with rendering the GUI based on the updated display tree .

Thus the scenario illustrates that various states of a display tree can be maintained for a display region. For instance with reference to the GUI at least three states of a display tree for the GUI can be maintained. The primary thread maintains the display tree to which it applies various changes to the visual state of the GUI . To enable changes to the visual state of the GUI to be propagated to the render thread and displayed the state of the display tree can be captured via an intermediate display tree that can be persisted for consumption by the render thread . For instance the display trees represent snapshots of the display tree captured at different states of the display tree . Further the render thread maintains the display tree which it synchronizes to the intermediate display trees and reads from for rendering to the GUI .

In at least some embodiments PSPs can be employed to propagate changes to a display tree without requiring entire copies of a display tree to be generated. For instance consider the following example scenario.

The scenario further includes a primary thread and a render thread for the GUI . Example details concerning primary threads and render threads are discussed above. The primary thread is associated with a display tree which is a data representation of the GUI .

Proceeding to the center portion of the scenario a PSP is generated by the primary thread according to various techniques discussed herein. The PSP can be emitted by the primary thread for example in response to various events that change visual aspects of the GUI .

The PSP includes change data which represents changes to the display tree that have occurred. For example the primary thread can modify one or more nodes of the display tree in response to various events. Other types of changes may also be made such as adding nodes deleting nodes rearranging nodes and so forth. The primary thread can then generate the change data which specifies the changes that are made to the display tree . The primary thread emits the PSP that includes and or is linked to the change data . According to various embodiments the change data corresponds to changes to the display tree that have occurred since a previous PSP was emitted. Thus the PSP does not include an entire copy of the display tree .

After the primary thread emits the PSP with the change data the primary thread can proceed with performing other tasks. For instance the primary thread can make further modifications to the display tree without affecting the change data .

The scenario further includes a display tree maintained by the render thread . Generally the display tree is utilized by the render thread for rendering visual aspects of the GUI . The display tree for instance corresponds to a version of the display tree generated based on a previous PSP.

Proceeding to the lower portion of the scenario the render thread retrieves the PSP and modifies the display tree based on the change data . Thus the changes indicated in the change data can be applied to the display tree . The render thread can then proceed with rendering the GUI based on the updated display tree .

According to various embodiments the PSP persists until the render thread is finished reading data from and or otherwise utilizing the PSP . For instance the PSP represents a valid state of the display tree that remains valid and usable by the render thread until the render thread releases the PSP and or moves on to processing a subsequent PSP. In at least some embodiments after the render thread is finished processing the PSP a memory address and or addresses for the PSP can be released to be used for other purposes e.g. a subsequent PSP.

Thus visual processing applied by the primary thread to the display tree is propagated via the change data to the render thread which then applies the visual processing to its own display tree .

Further illustrated in the lower portion of the scenario is that the primary thread emits a PSP which includes change data . The change data for example indicates changes to the state of the display tree that have occurred subsequent to the primary thread emitting the PSP .

When the render thread is finished drawing to the GUI from the current state of the display tree the render thread can retrieve the PSP and can synchronize the display tree based on the change data . The render thread can then proceed with rendering the GUI based on the updated display tree .

Thus the scenario illustrates that PSPs can be employed to share changes in a visual state of a GUI among threads without generating multiple copies of a display tree for the GUI. Further the lifetime of a PSP can be managed to enable a particular state of a display tree to be persisted for a render thread while a primary thread that generated the PSP performs other processing.

While the scenarios presented above are discussed with reference to rendering scenarios this is not intended to be limiting. For example synchronization points can be used to propagate state information between a variety of different threads as part of a variety of different processes and or tasks.

In at least some embodiments a GUI may include certain elements which cannot or must not be rendered separately on a different thread e.g. for reasons of economy or correctness. Therefore such embodiments can choose to process a PSP on a primary thread until they again deem it appropriate to use a render thread for improved performance. Further such embodiments may choose to defer creation of a render thread pause it or shut it down depending on availability of resources.

Having discussed some example implementation scenarios consider now a discussion of some example procedures in accordance with one or more embodiments.

The following discussion describes some example procedures for synchronization points for state information in accordance with one or more embodiments. The example procedures may be employed in the environment of the system of and or any other suitable environment.

Step determines a state change to be propagated to another thread. As discussed above the state change can relate to a change in a visual aspect of a graphical element such as a portion of the GUI. A variety of other types of state changes however can be propagated according to various embodiments. A state change for example can relate to a variety of different processes and or resources associated with a computing device.

Step emits a synchronization point that includes an indication of the state change. With reference to a change to visual aspect for example the synchronization point can include and or identify data that indicates how the visual aspect is to be changed. For instance the synchronization point can include one or more portions of the display tree for a graphical element that define how the graphical element is to be rendered and displayed. Alternatively and or additionally the synchronization point can identify where data for the state change can be found such as a memory address.

In at least some embodiments emitting a synchronization point can include placing the synchronization point in a synchronization point queue. For instance if one or more other synchronization points remain to be processed the synchronization point can be placed behind the other synchronization points in a synchronization point queue such that the different synchronization points can be processed in order.

Step proceeds with performing other tasks after emitting the synchronization point. The first thread for example can continue executing other tasks such as generating additional synchronization points. Thus the first thread need not wait until the synchronization point is consumed by the second thread to continue processing.

Step retrieves the synchronization point. The second thread for example can retrieve the synchronization point from a synchronization point queue.

Step processes the synchronization point to determine the state change. The state change for example can relate to a change in a visual state of a graphical element such as a GUI. As referenced above however embodiments are not limited to state changes in visual elements and can refer to state changes in a variety of different processes resources and so on.

Step applies the state change. The state change for example can be applied to a process and or resource associated with the synchronization point. For instance the state change can be applied to change the visual appearance of a graphical element.

Step generates a change to a visual state of a graphical element. For instance the primary thread can perform various types processing that causes a change to a graphical element such as a visual change to a GUI. As detailed above the primary thread can make modifications to a display tree maintained by the primary thread.

Step emits a synchronization point that includes an indication of the change to the visual state. The synchronization point for example can include data that characterizes the change and or can identify where the data may be retrieved. For instance the synchronization point can include and or identify a version of a display tree maintained by the primary thread.

Step proceeds with performing other tasks after emitting the synchronization point. The primary thread for example need not wait for the render thread to consume the synchronization point before proceeding with other processing tasks.

Step retrieves the synchronization point. The render thread for instance can retrieve the synchronization point from a synchronization point queue.

Step processes the synchronization point to determine the change in the visual state of the graphical element. For instance a display tree included with and or identified by the synchronization point can be inspected.

Step renders the graphical element to apply the change in the visual state. The render thread for example can apply the changes to the visual state to a display tree maintained by the render thread. The render thread can then render the graphical element based on the updated display tree.

While embodiments are discussed herein with reference to interaction between two different threads this is presented for purpose of example only. For instance in at least some embodiments multiple different threads can produce synchronization points and can emit the synchronization points for processing by a particular thread. In a GUI rendering scenario for example multiple different threads can produce synchronization points that specify changes to visual aspects of the GUI. The synchronization points can be emitted by the different threads for consumption by a rendering thread.

Having discussed some example implementation scenarios and procedures for synchronization points for state information consider now some example implementation scenarios and procedures for coalescing graphics operations in accordance with one or more embodiments.

The following section describes example implementation scenarios and procedures further to coalescing graphics operations in accordance with one or more embodiments. In at least some embodiments the scenarios and procedures discussed below can employ aspects of the techniques discussed above.

The following discussion describes some example implementation scenarios for techniques for coalescing graphics operations described herein. The example implementation scenarios may be implemented in the environment of the system of and or any other suitable environment. The scenarios for example can represent functionality of the process manager module and or the graphics module . For instance the processing threads discussed in the different scenarios can be generated and or maintained by the process manager module and or the graphics module .

As further illustrated in the upper portion of the scenario the render thread is performing a render operation such as based on a PSP emitted by the primary thread . While the render thread is performing the render operation the primary thread is performing additional processing tasks such as generating visual changes to be rendered to the GUI . For instance the primary thread generates a graphics operation a graphics operation and a graphics operation . Generally the graphics operations represent discrete visual changes to be applied to the GUI that are generated via separate respective processing operations. The graphics operations can each be associated with the same graphical element of the GUI or with different respective graphical elements. In at least some embodiments the graphics operations can each represent a PSP generated by the primary thread .

Proceeding to the center portion of the scenario the render thread completes the render operation and thus is available to perform additional rendering tasks. In response the graphics operations are coalesced into a PSP . According to one or more embodiments the PSP represents a combination of the graphics operations such that visual changes to the GUI indicated in each of the graphics operations are represented in the PSP .

For instance consider a scenario where the graphics operations each affect the same graphical element of the GUI . The graphics operation changes a color of the graphical element and the graphics operations indicate respective translational movements of the graphical element within the GUI . Thus the PSP includes data for the color change as well as the translational movements.

Proceeding to the lower portion of the scenario the render thread retrieves and processes the PSP . For instance the render thread renders to the GUI based on graphics operations indicated in the PSP .

Thus the scenario illustrates that in one or more embodiments when multiple graphics operations e.g. PSPs are accumulated e.g. when a render thread is busy the graphics operations can be coalesced into a combined graphics operation such as via a PSP. The combined graphics operation can be rendered such that visual changes indicated in each individual operation are reflected in the displayed result. Accordingly processing time and resources are conserved in that a render thread need not iterate through multiple individual operations but can simply apply a single operation that reflects multiple combined operations.

Various techniques can be employed to track visual changes to graphical elements. For instance a patching model can be utilized which characterizes changes to visual elements as patches that can be applied prior to rendering. For instance consider the following example scenarios.

Associated with the primary thread is a display tree which is representative of a data structure for defining aspects of the GUI . The display tree for example includes multiple nodes that define various attributes of the GUI . For instance individual nodes of the display tree can include data that defines respective graphical elements of the GUI such as a window a text element an image element a Tillable field a selectable control and so forth.

For instance the display tree includes a parent node a child node and a child node . The parent node for example can represent a primary window of the GUI . The child nodes represent graphical elements within the primary window.

According to one or more embodiments the primary thread generates patches for the display tree to indicate changes to the GUI . For instance when an event occurs that changes a visual attribute of the GUI the primary thread generates a patch for a node of the display tree that corresponds to the changed visual attribute.

Consider for example that an event processed by the primary thread causes a change to graphical elements associated with the nodes respectively. Examples of an event include user input animation color changes events generated by other processes and so forth. In response to the event the primary thread generates a patch for the node and a patch for the node .

The node includes a link to the patch and a version number for the patch . The patch further includes a patch version which indicates a version for the patch . For instance multiple changes to the node can occur with a patch being generated for each change. As each new patch is generated a version number for each patch can be updated to indicate a relative position of each patch in a sequence of patches. As detailed below this can enable changes to a node to be accurately rendered.

The patch also includes patch data which indicates changes to the node . The patch data for example can indicate changes such as movement of a graphical element color changes size changes and so forth. A patch can include a variety of other types of data as well in accordance with one or more embodiments.

According to various embodiments the node includes a link e.g. a pointer to the patch and the node includes a link to the patch . Thus when a thread accesses a node the presence of a link indicates that a patch exists for the node. A link can be followed to access an associated patch.

In at least some embodiments a patch is cumulative in nature such that subsequent changes to a node cause an existing patch for the node to be updated. Accordingly the primary thread can base further changes to the state of the node on the patch . As detailed below for instance the primary thread can generate an updated version of the patch to indicate further changes in a state of the node .

Proceeding to the center portion of the scenario the visual changes indicated by the patches are to be propagated to the GUI . The primary thread for example can determine that visual changes to the GUI are to be applied by a render thread. Accordingly the primary thread emits a PSP which includes the patches 

Continuing to the lower portion of the scenario a render thread retrieves and processes the PSP . For instance the render thread applies patch data from the patch to the node and patch data from the patch to the node to generate an updated display tree . Thus data of the nodes is updated based on the patches respectively. The render thread then reads from the updated display tree and renders to the GUI based on data from the updated display tree .

With reference to the scenario discussed previously the individual graphics operations can be implemented as patches that can be coalesced into a single combined graphics operation e.g. as single PSP.

As illustrated in the scenario various threads e.g. the primary thread and the render thread can maintain logically consistent views of a display tree and operate based on their respective view of the display tree without interfering with each other. The primary thread for instance creates patches as needed so that the render thread can read from a most recent version of the tree independent of any unapplied patches for the tree. Thus the primary thread views the display tree in the context of any unapplied patches. As the render thread moves forward in processing time it applies patches e.g. from PSPs after which the patches can be retired. Thus the render thread views the display tree in its most recently updated form e.g. not including any unapplied patches.

According to various embodiments a node can be patched multiple times between render operations e.g. between PSPs to track changes in node state. For instance consider the following example scenario.

Associated with the display tree is a patch which is generated based on a state change that is to be applied to a visual attribute of the GUI . As illustrated the patch applies to a node of the display tree .

Proceeding to the center portion of the scenario an event e.g. a processing event indicates a further state change that is to be applied to the node . Accordingly patch data in the patch is updated to reflect the further state change. In at least some embodiments the patch is cumulative such that multiple changes in state information for the node are reflected in the patch data of the patch .

Continuing to the lower portion of the scenario a PSP that includes the patch is generated that indicates that a render operation is to be performed to the GUI . For instance the PSP can be generated by a primary thread for the GUI . A render thread for the GUI processes the PSP and applies the patch to the node to generate an updated display tree .

Along with the patch other patches generated for other nodes of the display tree can be applied by the render thread to generate the updated display tree . For instance state information from the other patches is applied to the respective nodes.

In at least some embodiments a list of nodes that have associated patches is maintained e.g. as part of and or separate from the PSP . Thus the list can be employed to generate the updated tree in an orderly fashion. As mentioned above a node includes a link e.g. a pointer to any patches for the node. Thus keeping a list of nodes for which patches have been generated provides for a more efficient use of resources since both a node to be patched and patches for the node can be located in a single operation.

Once the render thread is finished applying patches from the PSP to generate the updated display tree the render thread can read from the updated display tree and render to the GUI .

According to various embodiments different processing threads can utilize different versions of a display tree. For instance consider the follow example implementation scenario.

Proceeding to the lower portion of the scenario a PSP is emitted by the primary thread that includes the patches . The PSP instructs a render thread to apply the patches and render to the GUI . Thus the render thread applies the patches to generate an updated display tree . For instance nodes of the display tree can be updated with state information from the patches to generate the updated display tree .

The render thread then reads data from the updated display tree and renders to the GUI based on the data.

Also illustrated is that the primary thread continues perform processing for the GUI after the updated display tree is generated and thus generates patches for the updated display tree . According to various embodiments the primary thread views and or operates on the updated display tree in the context of the display tree itself as well as the associated patches . The render thread however accesses only the updated display tree and not the patches . Further the primary thread can continue to perform processing e.g. generating the patches after the updated display tree is generated and without waiting for the render thread to render based on the updated display tree .

Thus the primary thread generates and or updates patches based on different events that affect the visual state of the GUI . The render thread occasionally updates a display tree for the GUI with patches that have accumulated since a previous display tree update. The render thread renders from the most recent version of a display tree such as the updated display tree . Accordingly patches can be used to track changes in visual state of the GUI between render operations and can be applied to update a renderable state of a display tree for the GUI .

The following discussion describes some example procedures for coalescing graphics operations in accordance with one or more embodiments. The example procedures may be employed in the environment of the system of and or any other suitable environment.

Step coalesces the multiple graphics operations into a combined graphics operation for the graphical element. The combined graphics operation for example can reflect changes to visual state of the graphical element from each of the multiple graphics operations. Thus the combined graphics operation can represent a cumulative effect of each of the individual graphics operations. In at least some embodiments the combined graphics operation can be applied via a single render operation e.g. without separately applying each of the individual graphics operations. Coalescing graphics operations for instance can include combining multiple patches into a single patch that can be applied to a display tree to generate an updated display tree that reflects state information from each of the patches.

According to various embodiments a render thread may be busy rendering previous graphics operations. Thus multiple current graphics operations can be queued while waiting for the render thread to become available. For instance patches can be generated and or updated based on the graphics operations. The multiple graphics operations can be coalesced in response to determining that the render thread has become available to perform further rendering. A group of patches for example can be combined to generate a single patch that can be applied to update a display tree.

Step generates processing instructions indicating that the combined graphics operation is to be rendered. For example a render thread for the graphical element can be instructed and or notified that a combined patch is to be applied to update a node for a graphical element and that the graphical element is to be rendered based on the updated node. In at least some embodiments a PSP can be generated that includes or points to the combined graphics operation e.g. to a patch and or group of patches to be used to update a display tree.

In at least some embodiments a render thread can apply patches for multiple pending PSPs to a display tree and then render from the display tree based on the most recently applied PSP. This enables a final visual result of multiple PSPs to be realized without requiring multiple intermediate draw operations thus conserving system resources.

Step generates a patch that describes a change to a visual state of a graphical element. The patch for example can be associated and or linked to a node of a tree structure for a graphical element such as a GUI. Thus the patch can describe changes to be made to the node data. In various embodiments the patch is separate from an associated node and thus state information included in the patch does not affect a renderable state of the node until the patch is applied to the node.

Step determines that the change to the visual state of the graphical element is to be applied. For instance an indication that a render thread is available to render the change can be received.

Step updates a data structure for the graphical element based on the patch. As discussed above for instance the patch can be applied to a node for the graphical element such that graphics data in the node is updated and or replaced with graphics data from the patch. In at least some embodiments multiple different patches can be applied to respective different nodes of a display tree to generate a renderable updated version of the display tree.

Step renders the graphical element based on the updated data structure. For example a render thread can read from the updated data structure and render the graphical element based on the updated data structure.

While embodiments are discussed herein with reference to updating an existing data structure e.g. an existing node it is to be appreciated that the techniques can be employed to generate a new data structure. A patch for instance can include instructions for generating a new node a new sub tree and so forth. Thus data structures can be created and updated via techniques discussed herein.

Step executes a first thread to generate patches that describe changes to a visual state of a graphical element. As discussed above for example a primary thread for a GUI can generate and or update patches for a display tree for a GUI.

Step executes a second thread to apply the patches to update a data structure for the graphical element and render the graphical element based on the updated data structure. For instance as discussed above a render thread for a GUI can apply the patches to a display tree to generate an updated display tree and render one or more portions of the GUI based on the display tree.

According to various embodiments the first thread and the second thread can be executed on different respective processor cores. Further although a single thread is discussed as generating and applying patches to a data structure it is to be appreciated that embodiments may employ multiple different threads to generate update and or apply patches to a data structure. Additionally embodiments may employ multiple rendering threads for rendering from a data structure such as a display tree.

Having discussed some example procedures consider now a discussion of an example system and device in accordance with one or more embodiments.

The example computing device as illustrated includes a processing system one or more computer readable media and one or more Input Output I O Interfaces that are communicatively coupled one to another. Although not shown the computing device may further include a system bus or other data and command transfer system that couples the various components one to another. A system bus can include any one or combination of different bus structures such as a memory bus or memory controller a peripheral bus a universal serial bus and or a processor or local bus that utilizes any of a variety of bus architectures. A variety of other examples are also contemplated such as control and data lines.

The processing system is representative of functionality to perform one or more operations using hardware. Accordingly the processing system is illustrated as including hardware element that may be configured as processors functional blocks and so forth. This may include implementation in hardware as an application specific integrated circuit or other logic device formed using one or more semiconductors. The hardware elements are not limited by the materials from which they are formed or the processing mechanisms employed therein. For example processors may be comprised of semiconductor s and or transistors e.g. electronic integrated circuits ICs . In such a context processor executable instructions may be electronically executable instructions.

The computer readable media is illustrated as including memory storage . The memory storage represents memory storage capacity associated with one or more computer readable media. The memory storage may include volatile media such as random access memory RAM and or nonvolatile media such as read only memory ROM Flash memory optical disks magnetic disks and so forth . The memory storage may include fixed media e.g. RAM ROM a fixed hard drive and so on as well as removable media e.g. Flash memory a removable hard drive an optical disc and so forth . The computer readable media may be configured in a variety of other ways as further described below.

Input output interface s are representative of functionality to allow a user to enter commands and information to computing device and also allow information to be presented to the user and or other components or devices using various input output devices. Examples of input devices include a keyboard a cursor control device e.g. a mouse a microphone e.g. for voice recognition and or spoken input a scanner touch functionality e.g. capacitive or other sensors that are configured to detect physical touch a camera e.g. which may employ visible or non visible wavelengths such as infrared frequencies to detect movement that does not involve touch as gestures and so forth. Examples of output devices include a display device e.g. a monitor or projector speakers a printer a network card tactile response device and so forth. Thus the computing device may be configured in a variety of ways as further described below to support user interaction.

Various techniques may be described herein in the general context of software hardware elements or program modules. Generally such modules include routines programs objects elements components data structures and so forth that perform particular tasks or implement particular abstract data types. The terms module functionality and component as used herein generally represent software firmware hardware or a combination thereof. The features of the techniques described herein are platform independent meaning that the techniques may be implemented on a variety of commercial computing platforms having a variety of processors.

An implementation of the described modules and techniques may be stored on or transmitted across some form of computer readable media. The computer readable media may include a variety of media that may be accessed by the computing device . By way of example and not limitation computer readable media may include computer readable storage media and computer readable signal media. 

 Computer readable storage media may refer to media and or devices that enable persistent storage of information in contrast to mere signal transmission carrier waves or signals per se. Thus computer readable storage media do not include signals per se. The computer readable storage media includes hardware such as volatile and non volatile removable and non removable media and or storage devices implemented in a method or technology suitable for storage of information such as computer readable instructions data structures program modules logic elements circuits or other data. Examples of computer readable storage media may include but are not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical storage hard disks magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or other storage device tangible media or article of manufacture suitable to store the desired information and which may be accessed by a computer.

 Computer readable signal media may refer to a signal bearing medium that is configured to transmit instructions to the hardware of the computing device such as via a network. Signal media typically may embody computer readable instructions data structures program modules or other data in a modulated data signal such as carrier waves data signals or other transport mechanism. Signal media also include any information delivery media. The term modulated data signal means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example and not limitation communication media include wired media such as a wired network or direct wired connection and wireless media such as acoustic radio frequency RF infrared and other wireless media.

As previously described hardware elements and computer readable media are representative of instructions modules programmable device logic and or fixed device logic implemented in a hardware form that may be employed in some embodiments to implement at least some aspects of the techniques described herein. Hardware elements may include components of an integrated circuit or on chip system an application specific integrated circuit ASIC a field programmable gate array FPGA a complex programmable logic device CPLD and other implementations in silicon or other hardware devices. In this context a hardware element may operate as a processing device that performs program tasks defined by instructions modules and or logic embodied by the hardware element as well as a hardware device utilized to store instructions for execution e.g. the computer readable storage media described previously.

Combinations of the foregoing may also be employed to implement various techniques and modules described herein. Accordingly software hardware or program modules and other program modules may be implemented as one or more instructions and or logic embodied on some form of computer readable storage media and or by one or more hardware elements . The computing device may be configured to implement particular instructions and or functions corresponding to the software and or hardware modules. Accordingly implementation of modules that are executable by the computing device as software may be achieved at least partially in hardware e.g. through use of computer readable storage media and or hardware elements of the processing system. The instructions and or functions may be executable operable by one or more articles of manufacture for example one or more computing devices and or processing systems to implement techniques modules and examples described herein.

As further illustrated in the example system enables ubiquitous environments for a seamless user experience when running applications on a personal computer PC a television device and or a mobile device. Services and applications run substantially similar in all three environments for a common user experience when transitioning from one device to the next while utilizing an application playing a video game watching a video and so on.

In the example system multiple devices are interconnected through a central computing device. The central computing device may be local to the multiple devices or may be located remotely from the multiple devices. In one embodiment the central computing device may be a cloud of one or more server computers that are connected to the multiple devices through a network the Internet or other data communication link.

In one embodiment this interconnection architecture enables functionality to be delivered across multiple devices to provide a common and seamless experience to a user of the multiple devices. Each of the multiple devices may have different physical requirements and capabilities and the central computing device uses a platform to enable the delivery of an experience to the device that is both tailored to the device and yet common to all devices. In one embodiment a class of target devices is created and experiences are tailored to the generic class of devices. A class of devices may be defined by physical features types of usage or other common characteristics of the devices.

In various implementations the computing device may assume a variety of different configurations such as for computer mobile and television uses. Each of these configurations includes devices that may have generally different constructs and capabilities and thus the computing device may be configured according to one or more of the different device classes. For instance the computing device may be implemented as the computer class of a device that includes a personal computer desktop computer a multi screen computer laptop computer netbook and so on.

The computing device may also be implemented as the mobile class of device that includes mobile devices such as a mobile phone portable music player portable gaming device a tablet computer a multi screen computer and so on. The computing device may also be implemented as the television class of device that includes devices having or connected to generally larger screens in casual viewing environments. These devices include televisions set top boxes gaming consoles and so on.

The techniques described herein may be supported by these various configurations of the computing device and are not limited to the specific examples of the techniques described herein. For example functionalities discussed with reference to the process manager module and or the graphics module may be implemented all or in part through use of a distributed system such as over a cloud via a platform as described below.

The cloud includes and or is representative of a platform for resources . The platform abstracts underlying functionality of hardware e.g. servers and software resources of the cloud . The resources may include applications and or data that can be utilized while computer processing is executed on servers that are remote from the computing device . Resources can also include services provided over the Internet and or through a subscriber network such as a cellular or Wi Fi network.

The platform may abstract resources and functions to connect the computing device with other computing devices. The platform may also serve to abstract scaling of resources to provide a corresponding level of scale to encountered demand for the resources that are implemented via the platform . Accordingly in an interconnected device embodiment implementation of functionality described herein may be distributed throughout the system . For example the functionality may be implemented in part on the computing device as well as via the platform that abstracts the functionality of the cloud .

Discussed herein are a number of methods that may be implemented to perform techniques discussed herein. Aspects of the methods may be implemented in hardware firmware or software or a combination thereof. The methods are shown as a set of steps that specify operations performed by one or more devices and are not necessarily limited to the orders shown for performing the operations by the respective blocks. Further an operation shown with respect to a particular method may be combined and or interchanged with an operation of a different method in accordance with one or more implementations. Aspects of the methods can be implemented via interaction between various entities discussed above with reference to the environment .

Techniques for coalescing graphics operations are described. Although embodiments are described in language specific to structural features and or methodological acts it is to be understood that the embodiments defined in the appended claims are not necessarily limited to the specific features or acts described. Rather the specific features and acts are disclosed as example forms of implementing the claimed embodiments.

