---

title: Automated application programming interface (API) generation
abstract: Techniques are provided for automatically generating Application Programming Interfaces (APIs) in a computing device. In one example, a request for the addition of a first API to a software infrastructure of a computing device is received. An API coding table that includes one or more initial API parameters corresponding to the first API is generated and an API coding template stored in memory of the computing device is obtained. A compiler of the computing device generates functional codes for the first API based on the API coding template and the initial API parameters.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08843945&OS=08843945&RS=08843945
owner: Cisco Technology, Inc.
number: 08843945
owner_city: San Jose
owner_country: US
publication_date: 20130731
---
This application is a continuation of U.S. patent application Ser. No. 13 564 904 filed Aug. 2 2012 now issued as U.S. Pat. No. 8 516 508 the entirety of which is incorporated herein by reference.

A software component application program etc. of a computing device system will generally request other hardware software components to perform operations tasks on its behalf. To accomplish this the requesting software component uses a set of standardized requests collectively called an Application Programming Interface API .

In general an API is a mechanism that allows software components to communicate with one another. APIs may include specifications for routines data structures object classes variables etc. and may be defined in accordance with an international standard such as Portable Operating System Interface POSIX or may be specifically defined by a vendor. The term API may refer to a complete interface a single function a group of functions etc.

Due to the widespread use of APIs software development kits SDKs have been proposed and widely used. SDKs are in essence a set of software development tools that enables a programmer to create software for a specific platform e.g. a software package software framework hardware platform computer system video game console operating system or similar platform . Typically an SDK includes predefined APIs programming tools and supporting documentation.

Techniques are provided for automatically generating Application Programming Interfaces APIs in a computing device. In one example a request for the addition of a first API to a software infrastructure of a computing device is received. An API coding table that includes one or more initial API parameters corresponding to the first API is generated and an API coding template stored in memory of the computing device is obtained. A compiler of the computing device generates functional codes for the first API based on the API coding template and the initial API parameters.

One of the traditional goals for developing a software development kit SDK is to provide a consistent Application Programming Interface API for communication i.e. to enable other computing components to communicate with the software component . SDKs may be implemented on platforms that have hardware and software capabilities and as such the number of APIs defined for an SDK could increase after initial deployment. In certain examples the number of APIs may be in the hundreds or even thousands as new features are introduced to a platform. This is problematic in traditional arrangements where a user e.g. engineer or programmer uses the SDK to generate new APIs that support the added functionality. Therefore proposed herein is a scalable API infrastructure that is configured to support a large number of APIs and to facilitate automatic generation of new APIs with little or no user input thereby providing a highly scalable software platform.

For ease of illustration examples will be described herein with reference to use of the scalable API infrastructure in a system that includes an SDK. In these examples applications communicate with one or more application specific integrated circuits ASICs . It is to be appreciated that these examples are non limiting and that the scalable API infrastructure described herein may be implemented in a number of different computing systems to support API based software to software communication and may be used with an SDK.

Applications may comprise for example protocol applications e.g. Open Shortest Path First OSPF IS IS etc. or other applications such as access control list ACL applications or quality of service QoS applications. The hardware independent APIs are in this example SDK APIs that are used by applications to request programming of the hardware ASICs . More specifically in this example an API takes input parameters from application and uses Inter Process Communication IPC to pass these parameters to the user space device driver . These APIs are sometimes referred to herein as front end APIs or the front end of the communication process.

The user space device driver receives the programming request parameters generated by application from API via the IPC and is configured to use the parameters for programming the hardware ASICs . That is the user space device driver is configured to invoke the API dispatcher to dispatch call the programming request parameters to the corresponding API handler for the specific executed API .

The API handlers reside in the hardware control software layer . There is one API handler for each API i.e. a one one correspondence between APIs and API handlers . The API handler corresponding to API receives the programming request parameters and uses these parameters to program one or more of the hardware ASIC devices N in accordance with the original request from the application . The API dispatcher and hardware control software layer are part of the back end of the software to software communication process. In certain examples the API handlers may be specific to an ASIC such that there could be multiple API handlers i.e. one per ASIC for the same front end API. Because the ASICs may be designed to implement particular functions the API handlers for each ASIC could also be different. In the SDK architecture there are separate handlers among the ASICs.

The hardware control software layer is a platform dependent layer that may in this example be a hardware abstraction layer HAL . A HAL is implemented in software between the physical hardware ASICs of computer system and the other software components. In general the function of a HAL is to hide differences in hardware from the operating system kernel so that most of the kernel mode code does not need to be changed to run on systems with different hardware.

The foregoing describes the general operations of an API executed on the scalable API infrastructure . However before APIs may be used they are first generated for subsequent use. In this example the scalable API infrastructure uses a complier to automatically generate API program codes based on a stored coding template and predefined API parameters. In other words one macro is initially defined and the compiler expands this macro to produce a functional API. Consistent naming conventions are used through the infrastructure to facilitate various operations and a Type Length Value TLV is used to package API payloads to send parameters from API front end to back end API handlers. As a result the scalable API infrastructure optimizes API dispatch time provides precise API dispatching to appropriate API back end handlers and provides the ability to batch APIs i.e. lump multiple APIs in one generic API call .

Computing system may be a server computer e.g. desktop laptop etc. networking device router switch firewall etc. or any other system in which software components communicate with other hardware or software components. Computing system comprises ASIC devices N processor and memory . Memory comprises applications N user space device driver hardware control software layer a compiler and scalable API infrastructure . Scalable API infrastructure includes one or more API coding tables and one or more coding templates .

Memory may comprise read only memory ROM random access memory RAM magnetic disk storage media devices optical storage media devices flash memory devices electrical optical or other physical tangible memory storage devices. The processor is for example a microprocessor or microcontroller that executes instructions for the applications user space device driver hardware control software layer compiler and scalable API infrastructure . Thus in general the memory may comprise one or more tangible non transitory computer readable storage media e.g. a memory device encoded with software comprising computer executable instructions and when the software is executed by the processor it is operable to perform the operations described herein in connection with applications user space device driver hardware control software layer compiler and scalable API infrastructure .

The mechanism employed in the examples described herein is to utilize the compiler to automatically generate auto generate sections of functional API code when a new API is added. In order to have the compiler auto generate the sections of programming code the scalable API infrastructure includes one or more pre stored code templates that are used by the compiler . That is the compiler takes a code template and compiles it with some user input API parameters in a manner that expands the template into a functional API. As such the coding infrastructure provided herein allows for a growth in the number of supported APIs while minimizing coding errors. As used herein automatically generating the functional code means that after the initial API parameters are established little or no further user coding occurs to generate the API codes.

In operation the API parameters used in the scalable API infrastructure include a Type Length Value TLV . The Type is unique to the API the Value is the internal data structure used to carry API parameters from the API to the API s handler and the Length is the bytes length of the Value. 

As shown at of when a new API is to be created an API coding table is generated that corresponds to the new API. The API coding table is generated to include a TLV for the new API as well as a unique keyword associated with the new API. The unique keyword may be an American Standard Code for Information Interchange ASCII string. As described below these initial API parameters input into the API coding table i.e. TLV and unique keyword form a macro that is subsequently expanded for different purposes by the complier .

In the example of the new API relates to a virtual local area network VLAN and as such the coding table is sometimes referred to below by the name TABLE LIBSDK VLAN. The coding table may be generated based on information input by a user i.e. a user defines the TLV and ASCII string and or may be partially or fully automatically generated based on information from another software component or other computing system.

Next at of the internal data structure Value used to communicate between the API and the API handler is defined. This internal data structure will include the unique ASCII string defined in the API coding table i.e. the ASCII string associated with the new API . In this example the unique ASIC string is vlan create and the internal data structure is struct libsdk vlan create t for a VLAN API. These data structure form a payload to carry user input API parameters from the front end to the back end. These data structures include all the parameters provided by the caller and some additional fields. These structures are also defined when the APIs are defined and the caller is not aware of this data structure.

At an API handler in the hardware control software layer is provided with an API name containing the unique ASCII string vlan create in the format int abc vlan create struct libsdk vlan create t v p . 

At the API coding table TABLE LIBSDK VLAN is used to define an enumeration enum for each TLV Type. In this example the enumeration definition has the format libsdk enum t. The resulting enumeration code later generated by the compiler is used for indexing into an array that provides API handler functions.

At the API coding table TABLE LIBSDK VLAN is used to create a first level API handler definition. In other words a front end API definition that after compiling takes the data packages it and passes it through the API to the back end is created. In this example the first level API handler definition has the format int libasic tiv hdlr vlan create void p . It is to be noted that the definition will be generated by the compiler using the code template.

At the API coding table TABLE LIBSDK VLAN is used to create a second level API handler definition. That is a back end API handler definition is created that after compiling is used to dispatch the final API handler for each device to the hardware control software layer depending on the device s available on the hardware. As shown below the unique ASCII string vlan create is also used in this second level API handler definition which has the format 

At the final API handler definition for dispatch to the hardware control layer is created. In the example of the ASICs are identified as abc for ASIC and xyz for ASIC and the final API handler definitions are 

As shown above the TLV Type internal data structure API handlers etc. are defined so as to follow a consistent naming convention and to utilize the unique ASCII string therein to assist in auto generating functional codes by the compiler . To further illustrate this and other aspects the example use of a new API to create a VLAN is described in further detail in conjunction with the generation of an API to destroy a VLAN. In this specific example the keyword or ASCII string for the VLAN create API is vlan create while the keyword for the VLAN destroy API is vlan destroy. 

The TLV Type and ASCII string for the VLAN create and destroy APIs are defined in one or more coding tables TABLE LIBSDK VLAN . A macro LIBSDK TBL ENTRY to define the APIs with a TLV Type and a unique ASCII may have the format as shown below 

As noted an initial macro is defined to include the TLV Type and ASCII string keyword . In the scalable API infrastructure this macro may be redefined one or more times to behave in different manners thereby facilitating the API generation and subsequent use. More specifically the definition of TABLE LIBSDK VLAN is used and the behavior of the LIBSDK TBL ENTRY macro is changed. For example the definition of the LIBSDK TLV ENTRY macro may be redefined as shown below to create a list of enumerations 

Another example of redefining macros is shown below where API handlers can be generated by using the same TABLE LIBSDK VLAN definition 

Finally the API may be dispatched to a specific handler for the ASIC devices or depending on the hardware platform on which the code is executed i.e. the same set of APIs could have different implementations for each device on which it is running . The dispatch is shown as 

With the infra structure above in place now the actual correspondence handlers are realized through the following definitions for ASICS and 

An objective of the examples described herein is to provide a one time coding that allows for substantially automated addition of further APIs by simply defining the TLV Type and the unique ASCII string for each new API such as vlan port add or vlan port delete as shown below 

In essence the examples rely upon an infrastructure that allows the compiler to automatically generate functional API codes with minimal user input.

Once a new API is written an array may be defined to dispatch the API to the handler of that API. The dispatcher function also use the libsdk enum t defined earlier as index into this array. The array is generated from a different stored coding template as shown below 

From the enum libsdk enum t it can be seen that TLV TYPE LIBSDK VLAN CREATE has a value of zero 0 and that TLV TYPE LIBSDK VLAN DESTROY has a value of one 1 . These values can be used to index into libasic tiv handlers array to get the handler function for that API. Therefore dispatching to the corresponding API handler is error free and fast.

In certain examples once the first API coding template is created then the subsequent templates are a modified copy of the first template that has the table at the end. This is shown in the following examples for VLAN and the L2 module 

As shown the difference between these two templates is the tables TABLE LIBSDK VLAN and TABLE LIBSDK L2 .

An API used by an application to perform an operation may be referred to as a front end API and the handler for that API may be referred to as a back end handler. For each front end API there is a corresponding TLV Value associated with it. Therefore in the API function that TLV is used as part of the payload passed to the back end dispatcher. The back end dispatcher extracts the TLV Value and uses it to index into the libasic tiv handlers to get the entry with the handler function in that API.

Described above is the infrastructure to help facilitate dispatching of an API to the correct API handler in the back end. An example of a front end API function to create a VLAN in the hardware i.e. the API generated through the above infrastructure and which is called from the applications is shown below 

In certain examples two or more initial API parameters are used for generating the API coding table. These initial API parameters may comprise a unique ASCII string corresponding to the first API and a TLV corresponding to the first API. Additionally the initial API parameters may be entered by a user i.e. the API coding table may be generated based on one or more user inputs identifying the one or more initial API parameters .

In certain examples automatically generating the functional codes for the first API based on the API coding template and the initial API parameters comprises defining an internal data structure useable to communicate between the first API and an API handler in a back end of the software infrastructure. Each API may have its own internal data structure and the name of the structure has the unique ASCII string embedded in it. This data structure contains front end API parameters passed in by the caller. Some additional fields to be used by the SDK infra structure and some fields could be defined to assist batching or other functions.

Automatically generating the functional codes for the first API may further include generating an enumeration definition for the TLV Type. This enumeration coding template is generated only once and more tables may be added such as shown below.

Automatically generating the functional codes for the first API may further include receiving a front end API handler definition creating a back end API handler definition receiving a final API handler definition and compiling the enumeration definition the front end API handler definition the back end API handler definition and the final API handler definition with the compiler to generate functional codes for the first API. The front end API handler definition may be manually coded. Similarly the final API handler definition may also be manually coded based on the ASIC design. The back end API handler definition is uses the template and is automatically created for all back end handlers.

In summary of the above an infrastructure is described that enables a method to substantially auto generate programming codes from a coding template using a compiler. This helps eliminate coding errors and minimize coding from SDK software developers. That is the infrastructure enables the compiler to expand the code template to obtain a desired function API. Throughout the infrastructure the coding templates are used in conjunction with a unique ASCII string e.g. vlan create vlan destroy that enables the auto generation without user involvement. Additionally to dispatch a generated API in the back end another coding template is used to generate an array of API handlers. Software operates on this array to invoke the handler by using TLV as index into this array.

Additionally the use of the TLV data structure allows the batching of multiple TLVs into a single request payload send from applications to a user space device driver. This means that through the described infrastructure applications can bundle one or more APIs in one request and send the request to the user space device driver. The single message containing the batched APIs is decoded at the back end. This batching mechanism keeps the amount of communication messages between the applications and the user space device driver at the minimum and thus reduces the overall CPU usage.

Described herein are techniques to efficiently dispatch large number of APIs to their handlers by providing an infra structure to utilize the compiler to auto generate codes in order to scale to unlimited number hundred or thousand or more of APIs as required in a HAL or SDK software development. It is to be appreciated that the described techniques are not limited to HAL or SDK development only but rather may be used in any software to software implementation.

