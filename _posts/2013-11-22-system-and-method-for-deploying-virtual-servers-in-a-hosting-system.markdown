---

title: System and method for deploying virtual servers in a hosting system
abstract: Some embodiments provide a method that, at a particular node of a hosting system that includes several nodes for hosting virtual machines, retrieves data representing a particular computer system from a storage. The data includes several sections and checksums for the sections. The method validates the sections by using the checksums. The method copies the sections of data onto a disk volume of the node that is allocated for a virtual machine in order to deploy the particular computer system. The method configures the particular computer system to operate as the virtual machine by configuring information specific to the particular instantiation of the particular computer system.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09507542&OS=09507542&RS=09507542
owner: GOGRID, LLC
number: 09507542
owner_city: San Francisco
owner_country: US
publication_date: 20131122
---
This application is a continuation application of U.S. patent application Ser. No. 12 841 150 filed Jul. 21 2010. U.S. patent application Ser. No. 12 841 150 claims the benefit of U.S. Provisional Application 61 346 871 entitled System and Method for Storing and Deploying Server Images in a Hosting System filed May 20 2010. U.S. patent application Ser. No. 12 841 150 and U.S. Provisional Application 61 346 871 are incorporated herein by reference.

The present invention relates to the storage and deployment of images of virtual machines operating on a hardware resource of a hosting system.

Hosting services provide a means whereby multiple users can implement custom server configurations without the overhead costs associated with purchasing upgrading and maintaining equipment needed to implement the configuration. Instead a hosting service provider maintains and provisions a grid of hardware nodes that are shared amongst the multiple users. More specifically resources of a single node can be partitioned and each of these partitions can be allocated to host a virtual server configuration of a different user.

Each hardware node in the grid includes one or more processing units e.g. a CPU multiple CPUs CPUs with multiple processing cores ASICs graphics processing units etc. memory block devices e.g. disk storage devices networking capabilities and other such computing resources that often exceed the computing resources required by any single user s server configuration. By partitioning the resources of a hardware node amongst multiple server configurations a hosting service provider minimizes the amount of hardware needed to host all such server configurations while maximizing the usage of the available hardware.

Virtualization provides the means for partitioning the hardware resources amongst the multiple server configurations. Virtualization creates the fa ade that each server configuration is individually hosted on dedicated equipment with a particular set of resources. Two or more server configurations are provided non conflicting sets of resources of the same hardware node such that a guaranteed amount of processing resources is available to each such configuration. In other words a single physical resource is partitioned to operate as multiple logical resources.

As shown in virtualization allows a single computing device the ability to function as two or more different computing devices with each device having distinct sets of hardware resources and software resources. For instance configuration may be allocated 40 of the memory and 80 of the processor cycles of the device and configuration may be allocated the remaining 60 of the memory and 20 of the processor cycles of the device . Additionally the configuration may operate using a first operating system with a first set of configuration parameters and the configuration may operate using a second operating system with a second set of configuration parameters.

An added benefit of virtualization is that a failure in one configuration does not disrupt the operation of the other configurations even though all such configurations operate over physical resources of a single device. With reference to should the configuration crash due to an improper configuration of the operating system the configuration will continue operating unhindered as the resources used by each configuration or configuration operate independent of one another.

At the core of each virtualization solution is the hypervisor. The hypervisor also referred to as the virtual machine monitor manages a logical partitioning of a physical set of hardware resources of a physical device or node between different virtualized guests. Each virtualized guest implements one or more virtual machines over a logical partition. The hypervisor partitions underlying hardware resources such that each virtual machine is provided what logically appears as a distinct and unshared set of hardware resources. However the hypervisor maps the virtual machine hardware calls to a corresponding subset of physical hardware resources that are actually shared by all virtual machines operating on a particular hardware node.

The hypervisor is thus responsible for mapping the hardware resources of a node to a set of virtual resources. The set of virtual resources can then be distributed independently to one or more operating systems or applications that together form the one or more virtual machines. In this manner each virtual machine effectively is provided its own resources e.g. a processor memory disk storage networking etc. and the operating system of each virtual machine operates with little to no change over the provided set of resources.

Different vendors implement hypervisors differently e.g. Xen Parallels VMware Kernel Virtual Machine KVM etc. . Specifically two prominent hypervisor types are defined as type 1 hypervisors and type 2 hypervisors which are further described with reference to .

The second exploded view illustrates a platform of a computer system in which a type 1 hypervisor is present. The type 1 hypervisor interfaces with the physical hardware of the computer and provides a set of virtual hardware to the system configuration . Thus the system configuration interfaces with the virtual hardware provided by the type 1 hypervisor which itself directly accesses the physical hardware of the computer system .

The third exploded view illustrates a platform of a computer system in which a type 2 hypervisor is present. The platform includes a host kernel layer on top of the physical hardware and a host operating system on top of the host kernel layer . This platform also includes an application layer not shown on top of the operating system layer. Additionally the platform includes a type 2 hypervisor which interfaces with the host operating system . This type 2 hypervisor may be one of the applications in the application layer not shown on top of the host operating system . The type 2 hypervisor is allocated a set of the physical resources by the host operating system . Accordingly the system configuration interfaces with virtual hardware provided by the type 2 hypervisor which itself receives a set of hardware resources from the host operating system .

The computer system shown in the exploded view may be considered a traditional computer system e.g. a traditional computer system as shown in the exploded view with the type 2 hypervisor as one of the applications in the application layer. In other words the computer system of this exploded view may be considered a traditional computer system with system configurations stacked on one another.

Hosting services allow users to implement their system configurations e.g. system configuration on remote computer systems without the pitfalls associated with owning and maintaining the hardware platforms on which the system configurations run. These pitfalls include overhead costs associated with purchasing upgrading and or maintaining equipment and software needed to implement the system configuration. Instead of a user burdening him or herself with these headaches a hosting service provider maintains and provisions a grid of hardware nodes that are shared amongst multiple users. More specifically resources of a single node can be partitioned and each of these partitions can be allocated to a virtual server configuration of a different user.

In order to host a system configuration some hosting systems allow a user to set up the system configuration from scratch. In other words the user selects one operating system from various different operating systems and can then configure the operating system by changing parameters installing other applications to run on top of the operating system etc. However users may wish to have multiple servers that are all the same without having to go through the hassle of configuring every one of the servers separately. Users may also wish to stop using a server for an extended amount of time and then bring the server back up later on without having to pay for the usage of hardware space during the downtime. Furthermore users may wish to take a configuration of one of their virtual servers and use this configuration in another hosting system or on their own physical machine. Therefore there is a need in the art for a method of storing a system configuration of a computer system in order to re use the system configuration at a later time without a user being required to reconfigure a new system.

Some embodiments provide a server hosting and storage system for 1 storing images of virtual machines that are hosted on the system and 2 deploying virtual machines on the hosting system from the stored images. A user of the hosting and storage system has the ability to store an image of any of the user s virtual machines that are hosted on the system. These images are stored in a permanent storage of the hosting and storage system. The user also has the ability to deploy any such stored images automatedly as a virtual machine on the hosting system such that the deployed virtual machine will have the same system configuration as the saved virtual machine. The system configuration as used in this sense includes the operating system of the virtual machine and applications running on top of the operating system as well as any user definable settings for the operating system and applications.

The hosting and storage system of some embodiments includes 1 a front end user interface and or application programming interface for receiving instructions from a user regarding the saving and deployment of virtual machines 2 a system management module for managing a grid of hardware nodes on which the virtual machines are hosted 3 a grid of hardware nodes for hosting the virtual machines 4 a permanent storage network for storing the images and 5 a caching network for segregating the permanent storage network from the hardware grid and for temporarily storing the images. In some embodiments one or more of the hardware nodes includes a hypervisor for managing the sharing of the resources of the hardware node between one or more virtual machines running on the node and a utility management module for managing the image storing and deployment processes on the hardware node.

The image storing process of some embodiments extracts the virtual machine data off of the hard disk of the hardware node and stores this data as a single file. In order for the image storing process to be performed the virtual machine operating on the node must first be prepared. In some embodiments prep scripts operating on the virtual machine remove paravirtualization drivers drivers that enable to the virtual machine to access hardware resources of the node through a hypervisor and various system specific information that may vary between operating systems.

Once prep scripts for the virtual machine have run the utility management module can perform the image storage process. In some embodiments the utility management module extracts the data representing the system configuration of the virtual machine from a hard disk partition allocated to the virtual machine. Some embodiments extract the data in units having a particular size and calculate a checksum for each unit of system configuration data. The units of data along with their checksums can be stored as a single file. This file is stored in a compressed format in some embodiments.

The utility management module of some embodiments streams each unit of data and the checksum for the unit to an external storage. The data is streamed through a caching network to a permanent storage network e.g. a network of cloud storage clusters . In some embodiments the caching network amalgamates the units of data into a single file and compresses the file. The amalgamation and compression may also be performed by the utility management module or the permanent storage network in some other embodiments.

The images stored in the permanent storage may be used to deploy a new virtual machine having the same system configuration as the virtual machine from which the image was created. The image file is decompressed and streamed through the caching network to the utility management module of the node on which the new virtual machine is to be deployed. Some embodiments will first check the caching network to determine whether the image file is already loaded onto one of the cache server in the caching network. When the image file is already on a cache server the file in the permanent storage network is not accessed and the copy loaded on the cache server is used.

To deploy the new virtual machine the utility management module recalculates the checksum for each unit of data in the image file and matches this against the checksum stored in the file. Once verified the data is laid down on a disk volume on the node allocated to the new virtual machine. If any of the checksums do not match then the image data has been corrupted and the image file is re retrieved from the permanent storage network.

When the entirety of the image file data has been verified and laid down on the disk volume the utility management module oversees the installation of the paravirtualization drivers and various system specific information onto the new virtual machine. In some cases the utility management module directly installs this information on the virtual machine while in other cases the utility management module lays the information down on the disk such that the information is installed automatically upon the initial boot of the virtual machine.

As mentioned an image file requested by the utility management module might already be on the caching network. When an image is transferred from the permanent storage network to a node the image is loaded onto a cache server in the caching network. In some embodiments each cache server maintains a queue of images with the most recently deployed images at the top entry point of the queue. Thus when a utility management module sends a request for an image file that image will already be stored on one of the cache servers if the image was recently deployed.

In order to speed up the process of searching through the multiple cache servers on the caching network some embodiments use affinity scoring to assign image files to cache servers and identify cache servers most likely to be storing image files. When an image is loaded into the caching network from permanent storage a score is calculated for each of the cache servers. For a particular image file and cache server the score is a function e.g. a hash function of the image file name and the cache server name in some embodiments. The image file is preferentially loaded onto the cache server with the highest score for that image file. When a utility management module requests the image the cache server with the highest score is checked first for the image file.

Some embodiments have additional features to speed up the process of deploying a virtual machine. In some embodiments a number of pre built disk volumes of one or more sizes e.g. 20 Gb 50 Gb 100 Gb etc. are maintained on the hardware nodes. When a user requests a virtual machine having one of the pre defined sizes no time need be spent creating a partition on the hard disk of the node. Going further some embodiments maintain a number of pre deployed virtual machines from popular image files. In some embodiments some images are publicly available and the most popular of these publicly available system configurations are maintained on the nodes. These pre deployed virtual machines are not configured for use by a particular user but all of the data in the image file has been laid down on a disk volume. When the image is requested by a user the virtual machine need only be configured for use by that user thereby cutting down on the time from the user request to an operational virtual machine.

In addition to files storing single images some embodiments enable a user to store a configuration of multiple connected virtual machines. Such a configuration could include several types of virtual machines such as load balancers web servers database servers etc. In some embodiments when a user initiates a save of such a multi server configuration an image is created and stored for each of the virtual machines in the configuration. The multi server configuration is then defined in a separate file that contains references to each of the images as well as the connections between the different images. A user can request such a saved configuration and the different images will be deployed on one or more hardware nodes in the hosting system and connected according to the references in the multi server configuration file.

While the above discussion describes the use of image files for virtual machines in a hosting and storage network the image files may also be used outside of the hosting environment in some embodiments. For instance a user may download an image file for a particular system configuration and then deploy that system configuration as a virtual machine on a different hosting system in some embodiments so long as the second hosting system has the functionality to read the image file. The user can also deploy the system configuration as a physical machine on their own device without a hypervisor in some embodiments by using an application e.g. on another device that can read the image file and install device drivers rather than paravirtualization drivers. In similar fashion if a user has an application that can mimic the processes on the utility management module for creating an image file the user can create an image of the system configuration of their physical machine and then deploy a virtual machine on the hosting system using the image file.

In the following detailed description of the invention numerous details examples and embodiments of the invention are set forth and described. However it will be clear and apparent to one skilled in the art that the invention is not limited to the embodiments set forth and that the invention may be practiced without some of the specific details and examples discussed.

Some embodiments provide a server hosting and storage system for 1 storing images of virtual machines that are hosted on the system and 2 deploying virtual machines on the hosting system from the stored images. In some embodiments the virtual machines include system virtual machines. A system virtual machine is a particular configuration of a computer system platform with its own file system and operating system. The computer system platform may also include various application programs that are installed on the file system and that are compiled to directly execute on the operating system platform. A system virtual machine is therefore a complete configuration that is independently operable on a hardware node within the hosting system.

On a particular hardware node of the hosting system that hosts multiple virtual machines a system virtual machine operates independent of the other operating systems of the other virtual machines operating on the particular hardware node. In this manner multiple operating system environments e.g. Microsoft Windows Linux etc. co exist on a node without mutually interfering with each other s operations. In other words a hardware node of some embodiments concurrently executes virtual machines of different computer system configurations for one or more users using a single set of hardware resources of the node.

System virtual machines are different than process virtual machines. Unlike system virtual machines a process virtual machine does not include its own operating system. Rather a process virtual machine runs as an application on a host operating system. The process virtual machine provides a platform independent programming environment for application programs that interface with the process virtual machine in order to run on the host operating system. The application programs therefore cannot run on the host operating system without the process virtual machine. Similarly the process virtual machine cannot run the application programs without the host operating system.

In some embodiments a node is a particular physical machine such as a server or other computer device machine that includes processing resources memory resources block disk storage resources network resources etc. that implement and execute the one or more computer system configurations of the virtual machines. The node also includes a hypervisor that operates at a lower level than the virtual machines on the node. The hypervisor manages the access of the virtual machines on a node to the underlying hardware resources of the node.

A user of the hosting and storage system has the ability to store an image of any of the user s virtual machines that are hosted on the system. In some embodiments an image of a virtual machine is a file or files that stores the state of the virtual machine e.g. by copying the contents of the virtual machine s storage . These images are stored in a permanent storage of the hosting and storage system. The user also has the ability to deploy any such stored images automatedly as a virtual machine on the hosting system such that the deployed virtual machine will have the same system configuration as the saved virtual machine. The system configuration in some embodiments includes the operating system of the virtual machine and applications running on top of the operating system as well as any user definable settings for the operating system and applications.

Such a hosting and storage system of some embodiments includes 1 a front end user interface and or application programming interface for receiving instructions from a user regarding the saving and deployment of virtual machines 2 a system management module for managing a grid of hardware nodes on which the virtual machines are hosted 3 a grid of hardware nodes for hosting the virtual machines 4 a permanent storage network for storing the images and 5 a caching network for segregating the permanent storage network from the hardware grid and for temporarily storing the images. In some embodiments one or more of the hardware nodes includes a hypervisor for managing the sharing of the resources of the hardware node between one or more virtual machines running on the node and a utility management module for managing the image storing and deployment processes on the hardware node.

The image storing process of some embodiments extracts the virtual machine data off of the portion of the hard disk and in some cases other storages of the hardware node allocated to the virtual machine and stores this data as a single file. conceptually illustrates a process of some embodiments performed by the hosting and storage system to create and store such an image.

As shown process begins by preparing at an operational virtual machine for storage. In some embodiments instructions are sent to the virtual machine to launch prep scripts that must be run on the virtual machine before the machine can be saved. These prep scripts are pre installed on some or all virtual machines operating in the hosting system in some embodiments. When run the prep scripts of some embodiments remove drivers e.g. paravirtualization drivers and various system specific information. Paravirtualization drivers are drivers that enable the virtual machine to interface with the hypervisor to access hardware resources rather than accessing the resources directly with standard device drivers. The system specific information may vary between operating systems and is information that is specific to the particular instantiation of the system configuration e.g. system identifiers log and history files etc. . In some embodiments the prep scripts place the virtual machine in a non operational state. That is once the prep scripts are launched the virtual machine is no longer operating as a functional server.

Process next captures at the system configuration of the virtual machine. In some embodiments the capture operation is performed by the utility management module running on the hardware node with the virtual machine. In some embodiments the utility management module is a software module e.g. a specialized virtual machine operating within each node that has input output interfaces for communicating with the system management module of the hosting system the hypervisor on the node the hardware resources on the node other virtual machines on the node and the caching network of the hosting system. The utility management module of some embodiments performs the processes to extract and store a system configuration of a virtual machine as well as to deploy and configure a new virtual machine.

To capture the system configuration of the virtual machine some embodiments extract the data from the block storage e.g. disk storage allocated to the virtual machine. Some embodiments extract the data in units of a particular size and calculate a checksum for each unit of the system configuration data. These data units along with their checksums are eventually appended together as a single image file. The checksums are used for data integrity verification when deploying a new virtual machine using the image file. In some embodiments the file is stored in a compressed format e.g. using zip compression .

Next process streams at the captured data to a caching network. As mentioned the utility management module of some embodiments has an input output interface for communicating with the caching network of the hosting system. In some embodiments the utility management module streams each unit of data and the checksum for the unit once the checksum is calculated. The caching network of some embodiments segregates the hardware nodes from the permanent storage network avoiding an input output bottleneck.

Finally process stores at the streamed data as an image file in permanent storage. As mentioned the numerous units of data are stored as one image file. Some embodiments amalgamate the units of data into one file within the caching network. In other embodiments the utility management module or the permanent storage network amalgamates the data into one image file. Once the data is all in one image file the image can be compressed for storage. This file can be retrieved later in order to deploy a virtual machine with the same system configuration as the virtual machine that was extracted to create the image.

In some cases the caching network will then retrieve the image from the permanent storage network. However some embodiments first determine whether the image is already on a cache server in the caching network. When an image is transferred from the permanent storage network to a cache server for the purposes of then being streamed to the requesting utility management module of a node the image is loaded into a queue of the cache server e.g. in volatile memory of the cache server such as RAM . Each cache server keeps a queue of such recently used images with the most recently deployed image at the top entry point of the queue. In this way images that are regularly used will remain near the top of the queue. Thus when a utility management module requests an image file that was recently deployed the image file will already be loaded on one of the caching servers. In this case the image need not be retrieved from the permanent storage network thereby speeding up the retrieval process for the utility management module.

In order to further speed up the retrieval some embodiments use an affinity scoring process to 1 assign images retrieved from the storage network to cache servers and 2 identify cache servers most likely to be storing requested images. When an image is loaded into the caching network from permanent storage a score is calculated for each cache server in the network. For a particular image file and cache server some embodiments calculate the score as a function e.g. a hash function of the image file name and the cache server name. The image file is preferentially loaded onto the cache server with the highest score for that image file. When a utility management module sends a request for the image the queue of the cache server with the highest score is checked first for the image file. This will often enable the image file to be found within the first one or two cache servers checked thereby enabling quicker image retrieval.

Returning to process next deploys at a new virtual machine on the node using the retrieved image. In some embodiments the utility management module allocates a disk volume on the storage of the node then verifies and copies the data from the image file to the disk volume. The retrieved image data is stored in memory of the utility management module. Each unit of data is verified by recalculating the checksum for the unit and comparing the newly calculated checksum to the checksum appended to the unit of data. If there is a difference between the checksums this indicates that the data was corrupted at some point e.g. while on the cache server and the image is re retrieved from the permanent storage network. By checking each unit often data corruption will be detected before the entire image file needs to be loaded into memory and checked.

As each unit of data is verified it is copied onto the disk volume of the node that has been allocated for the virtual machine. Once the virtual machine is deployed the process configures at the virtual machine for use by the user that initially requested the deployment. In some embodiments configuring the virtual machine includes installing drivers e.g. paravirtualization drivers to enable the virtual machine to access hardware resources through the hypervisor as well as installing various system specific information. As described above the system specific information may vary between operating systems and is information specific to the particular instantiation of the image e.g. system identifiers log and history files etc. . Some embodiments also assign the virtual machine an IP address and perform other network configuration necessary to allow the virtual machine to communicate with the user s other virtual machines in the hosting system and if required devices outside the hosting system.

In some embodiments the utility management module executes each of the data extraction data streaming and retrieval disk allocation deployment and configuration operations based on different scripts stored on a remote file system based on instructions from the system management module of the hosting system. However in other embodiments the scripts for performing these operations are stored locally on the file system of the utility management module. In some such embodiments one instruction is sent from the system management module e.g. to deploy a particular image and the utility management module executes the scripts required to perform the instruction.

Some embodiments employ additional features that speed up the process of deploying a new virtual machine. In some embodiments a number of pre built disk volumes of one or more sizes e.g. 20 Gb 50 Gb 100 Gb etc. are maintained on the hardware nodes. When a user requests a virtual machine having one of the pre defined sizes no time need be spent creating a partition on the disk storage of the node. Going further some embodiments maintain a number of pre deployed virtual machines from popular image files. In some embodiments some images are publicly available and the most popular of these publicly available system configurations are maintained on the nodes. These pre deployed virtual machines are not configured for use by a particular user but all of the data in the image file has been copied to a disk volume. When the image is requested by a user the virtual machine need only be configured for use by that user thereby cutting down on the time from the user request to an operational virtual machine.

In addition to files storing single images some embodiments enable a user to store a configuration of multiple connected virtual machines. Such a configuration could include several types of virtual machines such as load balancers web servers database servers etc. In some embodiments when a user initiates a save of such a multi server configuration an image is created and stored for each of the virtual machines in the configuration. The multi server configuration is then defined in a separate file that contains references to each of the images as well as the connections between the different images. A user can request such a saved configuration and the different images will be deployed on one or more hardware nodes in the hosting system and connected according to the references in the multi server configuration file.

While the above discussion describes the use of image files for virtual machines in a hosting and storage network the image files may also be used outside of the hosting environment in some embodiments. For instance a user may download an image file for a particular system configuration and then deploy that system configuration as a virtual machine on a different hosting system in some embodiments so long as the second hosting system has the functionality to read the image file. The user can also deploy the system configuration as a physical machine on their own device without a hypervisor in some embodiments by using an application e.g. on another device that can read the image file and install device drivers rather than paravirtualization drivers. In similar fashion if a user has an application that can mimic the processes on the utility management module for creating an image file the user can create an image of the system configuration of their physical machine and then deploy a virtual machine on the hosting system using the image file.

Several more detailed embodiments of the invention are described in the sections below. Section I provides a conceptual architecture diagram of the hosting and storage system of some embodiments. Next Section II describes the process of creating and storing an image from a virtual machine operating on such a hosting system while Section III describes the deployment of a virtual machine on the hosting system from such an image. Section IV describes the storage architecture and details of the operation of the caching network of some embodiments. Section V describes the storage of template files for multi server configurations and the use of such template files. Next Section VI describes the use of images of virtual machines outside of the hosting system. Section VII then describes pre building disk volumes and pre deploying virtual machines in the hosting system in order to speed up the deployment process. Finally Section VIII describes a computer system which implements some embodiments of the invention.

As shown in the hosting and storage system includes 1 a service request server 2 an API 3 a front end provisioning manager 4 a resource management system module 5 a system management module 6 front end storage 7 back end storage 8 a grid of hardware nodes 9 an image caching network and 10 a permanent storage network . In some embodiments front end storage and back end storage are all one single physical storage. In other embodiments these storages are each a different physical storage or may even be split into multiple storages e.g. the back end storage might include a first storage for scheduling information and a second storage for storing image information .

The service request server 1 provides a user interface to external users through a network 2 receives communications e.g. service requests from the external users through the network and 3 routes the communications to the front end provisioning manager through the API . In some embodiments the service request server is an application server that communicates with a user through a network . Specifically in some such embodiments a user accesses the hosting system through a web browser a downloadable client application etc. residing on the user s computer personal digital assistant PDA mobile telephone or other such electronic communication device. The network may include a network of networks such as the Internet as well as other networks e.g. GPRS GSM etc. . In this manner users can access the hosting and storage system while located anywhere throughout the world.

In addition to communicating with the front end provisioning manager through the server a user can communicate directly with the API in some embodiments. Rather than selecting items in a user interface which are translated into commands by the application server the user directly issues the commands through the network to the API e.g. through a computer language agnostic HTTP based API or command line interface . These commands are passed by the API to the front end provisioning manager .

As mentioned the API routes user communications to the front end provisioning manager . On an initial communication the front end provisioning manager passes the user communication to a registration module not shown for user verification and authentication e.g. username and password verification . In some embodiments the registration module is a fully automated component of the hosting system that performs the verification and authentication operations without human intervention.

If the user is not an existing customer the registration module of some embodiments presents a graphical interface with editable fields through which the user enters additional identification information for creating a user account. The user specified information is then stored within front end data storage for subsequent authentication and authorization of the user. If the user is an existing customer the user s prior virtual machine configurations usage information and stored image information are retrieved from the data storage i.e. database . The information is passed to the front end provisioning manager .

The front end provisioning manager generates a user interface e.g. a graphical user interface GUI through which users specify components of virtual machine configurations hosted by the hardware nodes in the grid . The user interface of some embodiments includes graphical representations of various types of components e.g. load balancers web servers database servers etc. that each represent a component of the user s virtual machine configuration. Users may utilize these graphical representations to add servers to a configuration or to modify the setup e.g. the connections of a particular configuration. In various embodiments users can click on the representations e.g. via left click right click double click etc. within the user interface and or drag and drop the representations within the graphical display in order to add modify delete etc. virtual machines within the configuration.

In some embodiments the user interface also provides users the capability to modify the individual configuration of each of the virtual machines. Each virtual machine has one or more configurable parameters in some embodiments that are associated with configuring resources or characteristics of a virtual server running on a physical hardware resource in the grid of nodes represented by the graphical representation. For example users can modify the memory of a web server the storage capacity of a database server etc.

In some embodiments the specified configuration is scalable to increase or decrease allocated resources in response to demand through simple modification of the graphical representation. Accordingly the resources for any previously deployed virtual machine configuration may be modified by a user at any time by simply modifying the graphical representations for the configuration. To facilitate the scaling of a server configuration the front end provisioning manager of some embodiments acts as a user interface manager that provides a tiered hierarchical representation of the server configuration.

Some embodiments of the front end manager further provide users the ability to specify custom configuration parameters for each component of the configuration or for the configuration as a whole. For instance the front end manager of some embodiments provides users the ability to specify a desired software configuration e.g. operating system anti virus protection anti spam protection other applications etc. to operate in conjunction with the specified hardware configuration. In some embodiments however users are not allowed to specify particular software configurations or add software to an operational component through the user interface. Instead once a component is operational users can log in directly to the component to install software. In addition to the software configuration some embodiments enable users to further specify configuration settings within the operating system of a virtual machine such as entering network addresses for load balancers and firewalls or specifying hostnames for web servers.

The front end manager of some embodiments also specifies to a user a library of stored virtual server images that the user may deploy. In some embodiments the images in this library include one or both of 1 public server images configured by any of the unrelated users of the hosting system and 2 private server images configured and stored by the user themselves. In addition to a library of such server images the user interface of some embodiments provides users the capability to select any of the virtual machines running in the user s virtual machine configurations and store the virtual machine as a deployable virtual server image.

In some embodiments the deployable virtual server image includes the information e.g. the bits describing a virtual machine that was up and running in the hardware grid at a particular time. This information is extracted from the hardware resource on which the virtual machine was running compressed and saved for later deployment. Both the extraction storage process and the subsequent deployment process will be described in detail in later Sections. The interfaces for initiating both the save and deploy processes will be described as well.

As mentioned above in addition to accessing the above functionality through a user interface some embodiments enable a user to perform the same functions and access the same information directly through the API . Through a command line interface the user can request information e.g. the library of stored server images which is provided by the API . The user can also specify components of a configuration modify a configuration specify configuration parameters etc. directly through API . When the user accesses the functionality through the user interface the application server translates the user interface interactions into calls to the API so that the same interaction with front end provisioning manager is achieved.

When a user has finished specifying the virtual server configuration through the user interface or API some embodiments of the front end manager automatically provide the configuration to the hosting system s back end logic which is formed by the resource management system RMS module and the system management module . In some embodiments the resource management system module receives a specified configuration from the front end manager and performs a logical assignment i.e. identifies a mapping of the components e.g. virtual machines within the configuration to the grid of hardware nodes . Similarly when a user specifies a virtual server image to deploy the resource management system module maps this virtual server to a hardware node. This logical assignment is stored in the front end data storage in some embodiments so that it can be later accessed by the components of the hosting and storage system .

In some embodiments the system management module receives the logical assignment from the RMS module or from the data storage . The system management module then automatically deploys the logical assignment across one or more of the physical hardware nodes . The system management module includes a deployment scheduler that identifies particular hardware resources within grid on which to deploy the various virtual machines in a received configuration. In some embodiments a constraint optimization process is performed by the scheduler to determine the optimal hardware node for each virtual machine. The system management module of some embodiments will virtualize one component across multiple different hardware nodes when applicable e.g. when a database server requires a large disk space allocation it may be distributed across multiple nodes . This automatic deployment is described in further detail in U.S. patent application Ser. No. 12 421 597 filed Apr. 9 2009 and titled System and Method for Automated Allocation of Hosting Resources Controlled by Different Hypervisors which is incorporated herein by reference.

As is also described in the above mentioned application Ser. No. 12 421 597 the system management module includes various interfaces for directly accessing and communicating with 1 the hardware resources in grid 2 hypervisors running on the hardware resources and 3 virtual machines including utility management modules running on the hardware resources. Through these interfaces the system management module is able to pass virtual machine configurations and messages directly to the node and pass various instructions to the hypervisor the utility management module or the virtual machines running on a node. These instructions can include instructions to save an image of a virtual machine operating on a node or to retrieve an image from permanent storage for deployment on the node.

The system management module of some embodiments also monitors the usage of the virtual machine configurations and scales the configurations automatedly in accordance with instructions from the users.

The system management module automatically deploys the logical assignment for a virtual machine configuration across nodes in the hardware grid by interfacing with hypervisors operating on the nodes to which the virtual machines in the configuration are allocated. A hypervisor manages the allocation of the resources of a particular hardware node to the various virtual machines running on the node. The hypervisor of each node allows for a non conflicting provisioning of a node s resources to two or more virtual machines and the system management module allows several such nodes with multiple virtual machines to operate seamlessly together.

Also operating on many or all of the nodes is a utility management module or utility virtual machine UVM . As further described in the above mentioned U.S. application Ser. No. 12 421 597 the UVM is a hosting and storage system provider instantiated virtual machine that runs on each node. As such the UVM receives a partitioned set of hardware resources e.g. processing resources memory block storage etc. of the node on which it operates.

In some embodiments the utility management module includes an operating system and set of application modules described in detail with reference to below or remotely stored scripts that produce various physical transformations on the particular machine or node on which the utility management module is located. Some such physical transformations include customizing the resources allocated to a user virtual machine by the system management module deploying a virtual machine from a saved server image and extracting a running virtual machine for storage as a server image. The UVM creates the user virtual machine by configuring the allocated resources with a set of software that performs the operations of the user virtual machine. In this manner the utility management module alters the disk volume or block device by changing bits on the physical sectors of the block device allocated to the user virtual machine. The result of such alterations is to make operational a specific machine implementation that includes the user s virtual machine from an otherwise non configured set of hardware resources. As mentioned the specific machine implementation is either specified by the user through the user interface or is that of a server image from storage.

The back end storage of some embodiments includes a database that stores one or more operating system software images and or software images for applications to run in conjunction with the operating system of a virtual machine configuration. That is when a user specifies a new virtual server configuration or adds software to an existing virtual server configuration in some embodiments the software for the virtual server configuration is retrieved from the back end storage for deployment on one of the hardware resources . For instance a user might specify a particular operating system and several commonly used applications that are configured to optimally operate within the particular operating system. In some embodiments the back end storage is a part of the storage network which is described below.

As mentioned above the hosting and storage system of some embodiments also includes an image caching network and a permanent storage network . Both the image caching network and the permanent storage network are used by some embodiments to store ready to deploy pre configured server images. In some embodiments a user of the hosting and storage system may save their virtual servers to a storage cluster in the permanent storage network . The user may also deploy virtual servers that are stored in the storage network and or the caching network to the hardware grid .

The result of such a deployment is similar to the result of deploying a virtual server by selecting an operating system software applications etc. as described above. However deploying a virtual server using a preconfigured server image in storage is faster in some embodiments and allows the user skip the process of selecting all of the desired software applications for the virtual server. A user may deploy from the storage network and or caching network server images that the user has previously stored e.g. in a portion of a storage cluster on the network allocated to the user . Some embodiments also allow pre configured server images to be shared such that a user may deploy an image that was previously configured and stored by another user either for free or for a fee . Some embodiments present the user with options of preconfigured server images to use through the user interface generated by the front end provisioning manager or in request to a call to the API for such information. Information regarding the server images though not the actual server images themselves is stored in the front end data storage in some embodiments so that the front end provisioning manager may provide the user with the information regarding the images.

When a user selects an option through the user interface to save a particular virtual server that is running on a hardware resource in the grid or sends a save command directly to the API the UVM on the hardware resource performs a series of operations described in detail below in Section II to extract the bits defining the virtual server from the disk volume to which the virtual server is allocated. Some embodiments extract the virtual server in units of a particular size e.g. 1 Mb and attaches error detection information e.g. a calculated checksum to each of the extracted units. These units are then passed from the UVM through the caching network to the storage network for permanent storage. The caching network thus acts as a conduit that segregates the storage network from the hardware grid .

When a user selects an option in the user interface to deploy a virtual server from a server image stored in the caching network and or storage cluster or sends a deployment command directly to the API the system management module designates a hardware resource on which the virtual server is to be deployed. This is performed in some embodiments by the deployment scheduler of the system management module similar to when a user specifies the configuration for a server to deploy.

The UVM on the hardware resource designated for the virtual server performs a series of operations described in detail below in Section III to retrieve the specified server image and deploy the virtual server on a disk volume of the hardware resource. Some embodiments first determine whether the server image is stored on one of the caching servers in the caching network . When the server image is not stored in any of the caching servers the image is retrieved from the permanent storage network and loaded into the caching network . Once the server image is available on the caching network the image is retrieved by the UVM which validates and loads the units onto the disk volume of the hardware resource in a unit by unit manner in some embodiments.

One of ordinary skill in the art will recognize that the caching network may have any number of caching servers that communicate together as will be described in further detail below in Section IV. Similarly the permanent storage network may have any number of storage clusters. In some embodiments each storage cluster may itself have multiple storage devices for storing information electronically. The caching network and the permanent storage network are located at the same site in some embodiments or at different sites in other embodiments. In addition each of the networks and may be split among different sites. For instance each storage cluster could be at a different site in some embodiments.

Furthermore it should be apparent to one of ordinary skill in the art that the grid of hardware resources of some embodiments includes several distinct physical servers or clusters of servers located in a single server farm or distributed across multiple server farms in multiple disparate locations. Accordingly the grid of hardware nodes represents a cloud of computing resources shareable by multiple users. One of ordinary skill will appreciate that servers in other embodiments encompass any standalone computational element that can process requests. In some embodiments the grid of resources contains an inter communication pathway by which each node shares data with other nodes of the array and the hypervisor management module. Through this pathway physically separated nodes can operate together as a single functional unit.

Additionally as mentioned above the various physical resources of each node can be logically partitioned and allocated to one or more virtual machines. For instance each node in the grid of hardware resources of some embodiments includes at least one physical processing unit and through the various partitioning allocation and deployment operations performed by the system management module hypervisor and or utility management module each physical processing unit is able to conceptually operate as multiple separate processing units for two or more virtual machines of the node. Other resources of a node e.g. memory disk space network bandwidth etc. can also be logically split to be shared by multiple users.

It should be apparent to one of ordinary skill in the art that the architecture depicted in does not encompass all embodiments of the invention. In some embodiments the architecture may include other various functional components that work in conjunction with or instead of the enumerated components illustrated in . Additionally some embodiments define the system management module as a separate functional device than each of the utility management modules on each node. However it should be apparent to one of ordinary skill in the art that in some embodiments the functionality of the utility management modules is integrated into the functionality of the system management module and the below described functionality for the system management module and the utility management modules is encompassed within a single device or functional entity. As such the system management module of some embodiments performs the virtual machine resource allocation but also performs the partitioning formatting configuring modifying of the resources and the extraction checksum computation and validation and deployment operations described below.

As mentioned some embodiments provide users the capability to save an image of a presently operational virtual server to a permanent storage such that the virtual server can be easily deployed at a later date. In some embodiments much of the functionality for saving such a virtual server that is running on a hardware node resides on the utility management module UVM of that hardware node.

The hypervisor manages the access of the virtual machines on the node to the underlying hardware resources of the node. The hypervisor manages the hardware resources of the node by partitioning a set of hardware resources to each virtual machine operating on the particular node. In some embodiments the hypervisor provides exclusive use of a partitioned set of the hardware resources to a particular virtual machine. For instance virtual machine has exclusive use of a partitioned set of hardware resources of node . In this manner some embodiments guarantee that a specified amount of hardware resources is always available to each virtual machine.

This virtualization or mapping of the hardware resources by the hypervisor occurs transparently to the operations of the virtual machine causing each virtual machine to operate as though it is using a dedicated set of resources. Such transparent virtualization or mapping of resources prevents one virtual machine from accessing or interfering with the resources allocated to another of the virtual machines . For instance virtual machine is prevented from accessing the file system or memory of any of the other virtual machines operating on node .

The utility management module is itself a virtual machine with an operating system that executes software processes running within the UVM s own virtualized set of the hardware resources of node in some embodiments. The software processes executed by the UVM in some embodiments are defined by a set of scripts located in a remote file system or in the file system of the UVM. Through various control and provisioning messages an external module e.g. the system management module of described above directs the UVM to execute one or more of the scripts at specified instances in time. For instance a system management module would identify one or more scripts for the UVM to execute in order to extract and save an operating virtual machine such as virtual machine .

Utility management module includes a configuration manager an extractor a checksum calculator and a data transmitter . The configuration manager of some embodiments controls the configuration of the hardware resources allocated to each virtual machine. In some embodiments the configuration manager also controls the operation of the other modules within the UVM . That is the configuration manager identifies when a user has requested that one of the virtual machines on the node be saved for later deployment and identifies the scripts to be performed by the UVM in order to perform this save operation.

The configuration manager also communicates with the virtual machines in some embodiments. For instance the configuration manager performs formatting and configuration of the virtual machines in some embodiments. In other embodiments as described and illustrated in U.S. patent application Ser. No. 12 421 597 filed Apr. 9 2009 and titled System and Method for Automated Allocation of Hosting Resources Controlled by Different Hypervisors which is incorporated herein by reference the utility management module includes numerous separate modules that communicate with the virtual machines in order to format and configure the virtual machines. As described in Section III below the configuration manager of some embodiments performs the function of laying down a previously saved virtual machine on an allocated disk volume of the hardware node.

The extractor performs the extraction of the bits of a virtual machine from the disk volume a portion of the hard disk resources of the node on which the virtual machine is running in order to save an image of the virtual machine. In some embodiments the bits are extracted in regularly sized units e.g. 1 Mb . The checksum calculator calculates checksums for each of the extracted units and appends the checksum to the unit. The data transmitter sends the extracted data and checksum to caching network . Further detail regarding the operation of these modules will be described below with respect to . The caching network is comparable to caching network of described above in Section I. Further details regarding the caching networks of some embodiments are described below in Section IV.

As shown in virtual machine includes drivers e.g. disk and network drivers system specific information and preparation module . The virtual machine also includes of course an operating system software applications etc. which are not shown independently in this figure. In some embodiments as shown in the figure the drivers are paravirtualization drivers. Paravirtualization drivers are drivers that are installed on a virtual machine to enable the virtual machine to properly interface with the hypervisor. Because the hardware resources are accessed by virtual machine through hypervisor the correct paravirtualization drivers must be installed on the virtual machine.

The system specific information is information about the particular instantiation of the virtual machine which is deleted before saving a server image for the virtual machine. In some embodiments the system specific information varies based on the operating system of the virtual machine. For instance in some embodiments when the virtual machine is a server running the Microsoft Windows operating system the system specific information includes the Windows Security Identifier SID network configurations and desktop and administrator profiles. In some embodiments when the virtual machine is a server running the Linux operating system the system specific information includes any unique identifiers e.g. a RHEL registration ID etc. log files and history files. Different embodiments will include different information both the above listed information as well as other information that is not listed in the system specific information that is removed from a virtual server before it is saved as a server image.

Preparation module is a module on the virtual machine that when launched prepares the operational virtual machine so that it can be saved as a server image for later deployment. The preparation module runs a set of scripts that remove the drivers and the system specific information in some embodiments. The set of scripts also performs other processes in some embodiments such as resetting administrator or root passwords etc. In some embodiments the preparation module is launched when user instructions are received by the virtual machine to launch the module. These user instructions are sent from an external module such as system management module . In some embodiments the system management module communicates with the virtual machine through the utility management module in order to give the user instructions to launch the preparation module .

Portions of will be described by reference to portions of . illustrates the capture of the data of virtual machine by utility management module so that virtual machine can be saved is a server image. Specifically illustrates in six stages the launch of preparation module the removal of paravirtualization drivers and system specific information the extraction of a unit of data from virtual machine the calculation of a checksum for the extracted unit of data and the transmission of the extracted unit and checksum to caching network .

As shown in process begins by configuring at a virtual server according to user instructions. User instructions to configure a virtual server are sent from an external module such as system management module to the utility management module on the node hosting the virtual server being configured. The system management module in some embodiments receives these instructions from front end architecture such as front end provisioning manager and RMS module which in turn receive the user instructions through a network based on the user s interactions with a user interface e.g. graphical user interface command line etc. . The configuration manager of the utility management module then instructs the virtual server regarding the modifications. In some embodiments though the system management module or equivalent external module directly accesses the virtual server being configured bypassing the utility management module. In some embodiments the external module interfaces with the hypervisor to log into the virtual server. In some other embodiments the user logs in directly to the virtual server in order to configure the server.

The user instructions to configure the virtual server could include the initial deployment of the server selection of operating system and software applications etc. installation of any files or software applications security or other updates modifications to the profiles on the server changing settings e.g. firewall settings etc.

Once the virtual server is in the configuration desired by the user process receives at user instructions to launch the preprocessor module on the virtual server. As illustrated in stage of the preprocessor module is already on the virtual server . In some embodiments all virtual servers in a hosting system such as system are initially deployed with a preprocessor module. In other embodiments only certain virtual servers are deployed with such a module. For instance some embodiments only allow virtual servers having a particular size i.e. disk volume size to be saved as server images and thus only these servers are deployed with the preprocessor module. Some embodiments offer several sizes of virtual servers to users and only the smallest size may be saved as a server image. This allows any saved server image to be deployed at a later date to any size of server e.g. a virtual server from a 20 Gb disk volume could later be deployed onto a 100 Gb disk volume but not necessarily vice versa . In yet other systems the virtual servers are never deployed with the preprocessor module initially and a user initiates both the installation and launch of the module.

As illustrated in stage the instructions to launch the preprocessor module are received through the hypervisor in some embodiments. This illustrates the situation in which the external system management module interfaces with the hypervisor to log directly into the virtual server and issues the commands to launch the preprocessor module. In this situation the system management module acts like a remote agent on the virtual server and the hypervisor is used as an interface to talk to the virtual server. In some other embodiments the user logs directly into the virtual server in order to launch the preprocessor module.

When the preprocessor module is launched process removes at the paravirtualization drivers. In some embodiments the preprocessor module uninstalls the drivers and then deletes the driver files from the virtual machine. When the server is redeployed from a later image the removed drivers or newer updated drivers will be reinstalled.

The process also removes at system specific information from the virtual server. As described above the system specific information that is removed may vary depending on the operating system running on the virtual server. When the operating system is Microsoft Windows the information that is removed in some embodiments includes the Windows Security Identifier network configurations e.g. IP address and desktop and administrator profiles. When the operating system is Linux the information that is removed in some embodiments includes any unique identifiers e.g. a RHEL registration ID etc. log files and history files. Different embodiments will remove different information both the above listed information as well as other information that is not listed here. For other operating systems different system specific information will be removed. Although the removal of the paravirtualization drivers is illustrated in as being performed before the removal of the system specific information some embodiments remove the system specific information first or intermix the removal of the drivers and the system specific information i.e. perform both of these tasks at the same time . The process then ends.

As shown process begins at by logging into the virtual server. The process then attaches at the utility management module to the virtual server. In some embodiments an external module such as the system management module logs into the hardware node directly. Through a command line interface for the node the system management module issues commands to the to have the node log into the virtual server and then to have the node attach the UVM to the virtual server. In some embodiments attaching the UVM to the virtual server entails attaching the UVM to the disk volume on which the virtual server data is stored. Stage of illustrates the attachment of the UVM specifically extractor to the virtual server .

In some embodiments the process is performed when a user issues a command through a graphical user interface or directly through an application programming interface to save a server. For instance the front end modules of some embodiments present a graphical user interface to a user that lists all of the user s virtual servers on a hosting system. The user can then select one of the servers and select an option to save the selected server. This instruction is sent through the front end architecture to the system management module which issues instructions to the hardware node on which the selected virtual server is running. In some embodiments the user interface provides an indication as to which servers are in a savable state i.e. on which virtual servers the preprocessor module has already run . In other embodiments a user selection to save a virtual server causes the preprocessor module to run and immediately afterwards saves the virtual server i.e. the performance of processes and .

As shown in selecting the save icon brings up a dialog box in which a user can enter a name for the server image that will be created and a description of the server image. Once the save button is selected by the user the process begins in some embodiments.

After attaching the UVM to the virtual server the process logs the node out at of the virtual server. In some embodiments the system management module is only logged into the node when absolutely necessary to perform certain operations such as attaching the UVM to the virtual server being saved. This prevents any problems from low level disk operations e.g. a shared memory problem a hypervisor related bug etc. from crashing the entire node. If the entire node were to crash it could bring down any virtual machines running on the node and thus the process of saving a first virtual server of a first user could negatively affect a second virtual server belonging to a second user.

After logging out of the virtual server the process logs into at the UVM that is now attached to the virtual server to be saved. This enables commands to be issued to the UVM to extract and transmit the virtual server data. As the UVM is attached to the virtual server it has access to the disk volume for the virtual server and can easily copy that data.

Next the process copies at a unit of data from the virtual server. In some embodiments the UVM reads a unit of data from the disk volume of the virtual server into the memory of the UVM. The units are different sizes in different embodiments e.g. 1 Mb 5 Mb etc. . As illustrated in stage of in some embodiments an extractor module of the UVM copies the unit of data into the UVM memory. Stage illustrates a unit of virtual server data being transferred to the extractor module .

Process then calculates at a checksum for the copied unit of virtual server data. This checksum can be any standard checksum in some embodiments e.g. hash algorithms such as MD5 CRCs etc. . Different embodiments of the invention use different checksums. The checksums of some embodiments are used to verify the integrity of the data when the server image is deployed at a later date. Because each unit has its own checksum errors in the image data can be detected before the entire image is loaded on a new disk volume thereby saving time. As illustrated in stage of in some embodiments the unit of data is passed from the extractor module to the checksum calculator which then calculates the checksum.

The process next stores at the unit of data and its accompanying checksum. As described above to store the data the UVM transmits the data to a permanent storage network e.g. cloud storage clusters through a caching network in some embodiments. Other embodiments bypass the caching network and send the virtual server image data directly to the permanent storage network. Yet other embodiments provide other storage mechanisms for instance sending the server image data directly to the user so that the user has possession of the image and can deploy the image anywhere they so desire.

Process determines at whether any more virtual server data remains to be copied. When more virtual server data remains the process proceeds to to copy another unit of data. The UVM will copy data units calculate checksums and store the data until all of the server data is copied. When all of the data is copied the process proceeds to described below. only illustrates the copying checksum calculation and transmission of one unit of data. One of ordinary skill in the art will recognize that stages will repeat numerous times until all of the server data is captured.

Process next at the node level detaches at the UVM from the virtual server. As the save process is complete at least on the hardware node side the system management module no longer needs to be logged into the hardware node at all and thus can also log out from the node completely. In some embodiments before the UVM is detached from the virtual server the disk volume allocated to the virtual server is deallocated and overwritten with random data. This prevents a future user of the disk space from extracting any data from the previous user that could potentially be sensitive and or confidential.

In some embodiments only the bits on the disk volume that are actually in use are extracted during the server saving process. That is if the virtual server is allocated a 20 Gb disk volume but only 11 Gb of this disk space is used then only those 11 Gb will be extracted. illustrates a disk volume that is allocated to a virtual server e.g. virtual machine . The black squares indicate used disk space for the server while the white squares indicate free unused disk space on the disk volume .

In some embodiments when the server image is stored e.g. in the permanent storage network it is stored in a compressed format. In some embodiments this compression takes place at the UVM e.g. on a unit by unit basis by the transmitter of the UVM . In other embodiments the compression takes place in the caching network or the permanent storage network. For instance some embodiments transmit each extracted unit through the caching network to the permanent storage network. Once the entire server image is on the permanent storage network the server image can be compressed and then stored. Different embodiments use different compression techniques e.g. zip compression etc. . The server image is stored as a single file in some embodiments. Such a file can be easily exported copied saved to a portable storage such as a flash drive etc.

Some embodiments provide users the capability to deploy a saved server image on a hardware node of a hosting network such as network . Combined with the functionality described in Section II above this enables users to save an operational virtual server having a particular configuration and then at a later date e.g. 6 months later deploy one or more new virtual servers having the same configuration without having to go through the work of setting up the exact configuration desired.

The hypervisor manages the access of the virtual machines on the node to the underlying hardware resources of the node. As described above by reference to hypervisor the hypervisor manages the hardware resources of the node by partitioning a set of hardware resources to each virtual machine operating on the particular node. One of ordinary skill in the art will recognize that hypervisor may include all of the functionality attributed to hypervisor . It is possible for a server image of a virtual machine that was operating on a particular node to be later deployed onto the very same node. In some embodiments though this would be purely coincidental based on scheduling decisions made by the system management module of the hosting network.

The utility management module includes a configuration manager a checksum matcher a checksum calculator and a data receiver . The utility management module is itself a virtual machine with an operating system that executes software processes running within the UVM s own virtualized set of the hardware resources of node in some embodiments. In some embodiments the utility management module includes all of the functionality of the utility management module of . Thus while different modules within the UVM are shown in the UVM may also include an extractor and data transmitter. Similarly the UVM of some embodiments may include all of the modules illustrated in including the checksum matcher and the data receiver .

The configuration manager of some embodiments controls the operation of the other modules within the UVM . That is the configuration manager identifies when a user has requested that a virtual machine be deployed on the node and identifies the scripts to be performed by the UVM in order to perform the deployment operation.

The configuration manager also communicates with the virtual machines on the node in some embodiments. For instance the configuration manager performs formatting and configuration of the virtual machines in some embodiments. In other embodiments as described and illustrated in U.S. patent application Ser. No. 12 421 597 filed Apr. 9 2009 and titled System and Method for Automated Allocation of Hosting Resources Controlled by Different Hypervisors which is incorporated herein by reference the utility management module includes numerous separate modules that communicate with the virtual machines in order to format and configure the virtual machines.

The configuration manager of some embodiments also performs the deployment of a server image by laying down the bits in the stored server image on an allocated disk volume of node . That is the configuration manager accesses the disk volume and modifies the bits in the disk volume to match those received by the UVM for the server image.

The data receiver receives server image data one unit at a time from an external source. As illustrated in data receiver communicates with a caching network . Caching network is also in communication with a permanent storage network on which server images are stored in some embodiments. In some embodiments the data receiver acts passively to receive the image data as the caching network streams the units of data i.e. one command is sent asking the caching network for the server image . In other embodiments the data receiver actively retrieves each unit from the caching network i.e. commands are sent to the caching network as each unit is processed by the UVM .

In some embodiments the units of data received from the caching network each include numerous sub units each of which have a checksum. The checksum calculator and checksum matcher work together in some embodiments to verify the checksums of incoming units or sub units of server image data. Each unit or sub unit has an attached checksum as described above in Section II and the checksum calculator recalculates this checksum based on the received data. The checksum matcher compares the checksum that was received along with the server image data with the checksum calculated for the received data. When the checksums match the data can be passed to the configuration manager to be laid down on the disk volume. When the checksums do not match this means that the data was corrupted at some point e.g. in the caching network and must be re retrieved from permanent storage.

Portions of will be described by reference to . illustrates the retrieval of a server image from permanent storage network and the deployment of the server image as a virtual machine on node . Specifically illustrates in four stages the receipt of instructions to retrieve and deploy a particular server image the transmission of instructions to the caching network asking for the particular server image the transfer to the caching network from permanent storage and the transfer of a unit of data from the caching network to the UVM . illustrates the transfer of a sub unit of data with a checksum to the checksum calculator the transfer of the sub unit and received checksum along with a newly calculated checksum to the checksum matcher the laying down of the sub unit of data on an allocated disk volume the completely laid down virtual machine and the installation of paravirtualization drivers and system specific information on the newly deployed virtual machine.

As shown in process begins by receiving at a command to deploy a particular stored server. In some embodiments this command is received from an external module such as system management module . For instance a system management module in some embodiments receives these instructions from front end architecture such as front end provisioning manager and RMS module which in turn receive the user instructions through a network based on a user s interactions with a user interface e.g. graphical user interface command line etc. . The scheduler of the system management module then determines on which hardware node the new virtual server should be deployed. The instructions are then passed to the UVM for the particular hardware node so that the UVM can handle the retrieval and deployment of the desired virtual server.

As illustrated in the user is then presented a list of server images including images that the user has created from his own virtual servers e.g. via the processes described above in II. As shown the user has selected a server image . illustrates that the user has selected the server image and is presented with a configuration dialog box that enables the user to enter a name IP address and other parameters for the virtual server that will be instantiated in the storage and hosting system. When the user selects button the process begins in some embodiments to deploy the virtual server in the hosting system.

The process then allocates at a disk volume on the node as well as other hardware resources of the node in some embodiments for the virtual server. In some embodiments the configuration manager on the UVM allocates the disk volume on the node by accessing the hardware resources through the hypervisor. Stage of illustrates that a disk volume has been allocated for the virtual server to deployed.

The received instructions regarding the deployment of the server in some embodiments identify the size of the virtual server that is to be deployed. In some embodiments when a virtual server image is saved from a virtual machine having a particular size virtual machines deployed using that server image can be the particular size or larger. Thus for example a server image saved from a virtual machine with 20 Gb of disk space could be deployed onto a 100 Gb disk volume. After deployment a user would then have the ability add software applications files etc. to make use of the extra 80 Gb of disk space.

Next process checks at the caching network for the desired virtual server. In some embodiments each server image stored in the permanent network and or caching network has a unique name. This unique name may include a username of the user who saved the server image. Thus if two users want to name a saved server Web Server 2 there would be a Web Server 2 User1 and Web Server 2 User2 . One of ordinary skill in the art will recognize that this is merely an example of a naming convention for server images and many different naming conventions are possible. Thus the UVM sends a request to the caching network for the desired server image using the name of the server image. Stage of illustrates the communication between the UVM and the caching network as the UVM requests a particular server image.

The process then determines at whether the particular server image is already in the caching network. In some embodiments server images are stored on a cache server in the caching network for a time after they have been deployed. Thus if the server image has been recently deployed it need not be re retrieved from the permanent storage network. The details of retrieving the server image and the behavior of the caching network will be described in detail below in Section IV.

When the desired server image is not presently in the caching network process pulls at the server image from permanent storage into the cache. In some embodiments the caching network reports back to the UVM that the desired server is not stored on any of the caching servers at which point the UVM sends a message through the caching network to the permanent storage network with instructions to send the desired server into the caching network.

In other embodiments this is handled entirely by the caching network and the permanent storage network. When the UVM sends a request to the caching network for a particular server image if the server image is not stored in the caching network then the caching network sends a request to the permanent storage network for the server image. Stage of illustrates the transfer of an image from the permanent storage network to the caching network . This process and the storage in the caching network will be explained in further detail below in Section IV.

Once the server image is in the caching network the image can be transferred to the hardware node for deployment. Process fetches at a unit of the server image from the caching network. In some embodiments the server image is stored on the caching network in units e.g. 256 Mb units and one unit is transferred to the UVM at a time. These units are broken into sub units in some embodiments and each sub unit has a checksum for verifying the integrity of the sub unit. Thus when a unit of the server image is fetched from the caching network this unit is loaded into the memory of the UVM which can then check the checksum of each of the sub units. Stage of illustrates the transfer of a unit of server image from caching network to the data receiver module of UVM .

Process thus checks at the next sub unit of the current server image unit against the checksum for the sub unit. Stage of illustrates that the data receiver transfers a sub unit and its checksum to the checksum calculator . The checksum calculator ignores checksum and recalculates a checksum for the received data of sub unit . If the data in sub unit has not changed since the checksum was originally calculated i.e. at the time of creation of the server image then the newly calculated checksum and the checksum should be the same.

Returning to process next determines at whether the current sub unit is okay that is the process checks the integrity of the data of the sub unit . Stage of illustrates the transfer of sub unit and received checksum along with a newly calculated checksum from the checksum calculator to the checksum matcher . The checksum matcher compares the two checksums in order to verify the integrity of sub unit .

When the checksums do not match the data in the current sub unit has been corrupted and the process purges at the server image from the cache. The process then returns to to pull the server from permanent storage to the cache. In some embodiments server image data may become corrupted in the caching system or during the transfer process. If the corrupted data is used the virtual server may not function properly. Accordingly the process must re load the server image from the copy in permanent storage which is far less likely to become corrupted in some embodiments due to the type of storage used in the permanent storage network.

In some embodiments when the UVM detects that the server image data is corrupt the UVM sends a message to the caching network to let the caching network know to purge its copy of the server image. Then either the UVM or the caching network sends a message to the permanent storage to retrieve a new copy of the server image to load onto the hardware node.

When at the sub unit of image data is checked out as okay that is the received and newly calculated checksums match the process lays down at the sub unit of server data on the disk volume allocated for the server. In some embodiments this entails modifying the bits of the disk volume to match the server image data. Stage of illustrates that the sub unit of image data is laid down as the start of a virtual machine on disk volume .

The process then determines at whether there are more sub units left to check in the current unit of server image data loaded on the UVM. When there are more sub units remaining the process returns to to check the next sub unit for integrity and lay that sub unit down on the allocated disk volume. Otherwise the process determines at whether there are any more units e.g. the 256 Mb chunks of server image data remaining in the cache. When more units remain the process returns to to fetch the next unit of server image data from the cache.

When no more units remain the entire server image has been laid down on the disk volume. Stage of illustrates that virtual machine has been fully laid down on disk volume . As described above in Section II the server images are stored without paravirtualization drivers the drivers that enable the operating system to work with the hypervisor as a virtual machine and without system specific information that varies from operating system to operating system.

Therefore process next configures at the virtual server with the requisite system specific information. In some embodiments the system specific information varies based on the operating system of the virtual machine. For instance in some embodiments when the virtual machine is a server running the Microsoft Windows operating system the system specific information includes the Windows Security Identifier SID network configurations and desktop and administrator profiles. In some embodiments when the virtual machine is a server running the Linux operating system the system specific information includes any unique identifiers e.g. a RHEL registration ID etc. . Some embodiments also assign an IP address to the virtual machine and or ensure that there is a proper license for the system being instantiated. Different embodiments will include different information both the above listed information as well as other information that is not listed in the system specific information that is removed from a virtual server before it is saved as a server image.

Process also installs at the paravirtualization drivers. As mentioned above these drivers enable the virtual machine to properly interface with the hypervisor. In some embodiments other drivers are also installed. In fact some embodiments perform a dynamic driver update in order to ensure that the newest and most up to date drivers are installed on the newly deployed virtual machine. This can apply to both the paravirtualization drivers as well as any other drivers installed on the virtual machine. Stage of illustrates that the paravirtualization drivers and the system specific information have been installed on virtual machine . The virtual machine is now operational in some embodiments.

One of ordinary skill will recognize that in some embodiments operations and will not necessarily be performed in the order shown in process . Some embodiments will perform these operations in the opposite order or will perform both simultaneously. Furthermore when the operating system of the virtual machine is Microsoft Windows the paravirtualization drivers and system specific information is not fully installed on the laid down virtual machine by the UVM. Instead the information is loaded into an appropriate location on the virtual machine and then is installed by the virtual machine itself when the virtual machine is booted up. Similarly when the operating system is Linux log and history files are replaced by the operating system at first boot in some embodiments.

As described above some embodiments store server images on a permanent storage network such as a cloud storage network with multiple cloud storage clusters. In some embodiments the permanent storage network is connected through a caching network to a hardware grid onto which the server images may be deployed and from which the server images may be saved.

Hardware grid includes several hardware nodes . Hardware nodes may all be the same or may each have different hardware. In some embodiments all of the hardware nodes have an installed hypervisor e.g. Xen VMware etc. such that each node can host one or more virtual machines depending on the size of the virtual machines and the available hardware resources of the node. In some embodiments specific types of virtual machines e.g. F5 load balancers operate on specific hardware.

The caching network of some embodiments includes several caching servers . The caching servers may all be the same type of cache server e.g. a Squid server . While the software of the cache server is similar in some embodiments to that used for web caching servers the servers do not necessarily function in the same way as a web server.

The system management module includes a router and a score calculation module . In some embodiments the system management module performs the various functions of the system management module described in the above sections e.g. communicating with the hardware nodes and utility management modules on the nodes etc. . On the other hand in some embodiments the router and score calculation module are located outside of the system management module e.g. in a dedicated router or set of routers .

Router is a router that serves to route data between the hardware nodes and the cache servers . When a server image is saved the UVM on the hardware node from which the server image is saved sends the server image data to the router which distributes the data to the appropriate cache server from which the data can be streamed to the cloud storage network. In some embodiments when a request for a server image is received the router identifies a cache server most likely to be storing the server image. The router uses the score calculation module to identify such a cache server. The score calculation module of some embodiments calculates scores for server image cache server combinations and uses these scores to assign a server image to a cache server. Details of the scoring and cache assignment will be described below. In some embodiments the score calculation module is on a piece of hardware separate from the router . In other embodiments the score calculation module is a module that runs on router .

In the case in which the router is not part of the system management module e.g. is a dedicated caching network router some embodiments do not route the server image data being saved or deployed through the system management module at all. The data is only sent through the router to the caching servers in such embodiments.

The cloud storage network includes several cloud storage clusters a cloud storage retrieval network router and a score calculation module . The cloud storage clusters in some embodiments are shared electronic storage hardware that can be accessed by the same users as the hardware grid . The cloud storage clusters provide permanent in the sense of being more permanent than the cache servers storage for server images and other files for the users.

Cloud storage retrieval network router is a router or in some embodiments a set of routers routes data between the cache servers and the cloud storage clusters . In some embodiments when a server image being saved is streamed through the caching network the router identifies to which cloud storage cluster the server image should be directed based on the user that is saving the server image e.g. by looking up this information on a database stored in the router or external to the router . When a request for a particular server image to deploy is received from the caching network router identifies the storage location in some embodiments. In other embodiments router broadcasts a request for the server image.

When the server image e.g. image is sent from the cloud storage cluster to the caching network this also runs through router . In some embodiments the server image is loaded one unit at a time into the caching network such that the caching network does not have to handle such a larger file server image files uncompressed might be on the order of 10 20 Gb or larger .

When the router receives a server image file requested by the caching network in some embodiments the router connects to the system management module to identify to which cache server the server image file should be sent. In some embodiments the score calculation module calculates a score for the server image file based on data sent from the router . In other embodiments the score was already calculated at the time that the image file was initially requested by the hardware node so it does not need to be recalculated. In fact the router may already have this information in some embodiments such that no request need be sent to the system management module .

One of ordinary skill in the art will recognize that the architecture of system illustrated in is only one example out of many possible architectures for the hosting and storage system of some embodiments. For instance in some embodiments the hardware grid can directly connect to the cloud storage network without being required to send data through the caching network. However in some cases such a direct connection will be an input output bottleneck when there are many users all accessing the storage network at once whereas the caching network allows such a load to be more easily distributed across numerous caching servers. As will be described below in many cases the image retrieval process will not need to even access the cloud storage network because the needed server image will already be loaded on a caching server. In some embodiments communication between the cloud storage network and the caching servers is also routed through router which does all of the score calculation.

As mentioned above the cache servers of caching network act as a go between for the hardware grid on which virtual servers operate and the permanent storage network on which server images are stored. In some embodiments the cache servers act as a conduit that basically streams the server images through when a server image is saved from the hardware grid to the permanent storage. However in the other direction that is the deployment of server images from the permanent storage the cache servers actually act as a cache that holds server images for later deployment onto the hardware nodes.

When a server image is loaded onto a cache server from the permanent storage the server image is then streamed to the appropriate hardware node. In addition the server image remains on the cache server after being deployed on the hardware node in some embodiments. Each cache server in the caching network has a memory that stores a first in first out queue of server images. When a server image is deployed using a particular cache server the server image is sent to the entry point of the queue for that cache server. The queue will have a list of previously deployed server images that it is storing and based on the memory available in the queue one or more of the server images will be pushed from the exit point of the queue.

When a hardware node requests a server image that is already in the queue on the cache server the cache server provides this server image to the hardware node or more specifically to the utility management module on the hardware node . The server image is also bumped back to the entry point of the queue. In this manner popularly deployed server images will remain in the queue thus eliminating the need to retrieve these images from the permanent storage unless the server image data becomes corrupted.

Stage illustrates the result of deploying an Image from cloud storage to hardware grid . Image is cached on the cache server and therefore placed in the server s queue. As shown Image is now at the entry point of the queue. Furthermore Image N has been pushed out of the queue and Image N 1 is now at the exit point. Due to the addition of Image to the queue there is no longer room for Image N . Unlike a standard queue data structure server images are not popped from the queue when they are used but instead when there is no longer room in memory on the cache server. Thus if a future request for Image N comes into the caching network the image will need to be retrieved from permanent storage.

While the addition of Image to the queue pushes one server image Image N out of the queue there will not always be a one to one correspondence between server images entering and exiting the queue in some embodiments. The addition of a server image to the queue of a cache server may not push any server images off of the queue at all in the case that there is more memory available on the cache server than the size of the added server image. On the other hand the addition of a server image to the queue might push multiple server images off of the queue if the added server image is larger than the server image at the exit point of the queue.

Stage illustrates the result of deploying Image M which is already in the queue of cache server . Because server image is already stored in the memory of cache server there is no need to retrieve the image from cloud storage . Instead Image M is fetched directly from cache server and is moved back to the entry point of the queue. Because no new memory is used Image N 1 2360 is not pushed out the exit point of the queue.

Affinity scoring is performed by a module on the path between the permanent storage and the caching network e.g. at router of . When a server image is retrieved from the permanent storage network the score calculator calculates a score for the server image and each cache server in the cache network. Thus if there are thirty cache servers thirty scores are calculated for the retrieved server image in some embodiments. The server image is then preferentially routed to the cache server with the highest score. If this cache server is offline or busy the server image will be routed to the cache server with the second highest score. This continues until an available cache server is identified.

Stage illustrates that an image with the name John s Web Server is retrieved from cloud storage by caching network . The image could be retrieved in response to a request from a utility management module on a hardware node in a grid of hardware resources. The caching network has numerous cache servers three of which are illustrated in the figure. The three cache servers have the names Cacher in the Rye Cache 22 and Johnny Cache .

Stage illustrates the calculation of affinity scores for image . One affinity score is calculated for each cache server on caching network . The scores are calculated by applying a function F to the name of image and the servers . Thus a score F John s Web Server Cacher in the Rye is calculated for cache server a score F John s Web Server Cache 22 is calculated for cache server and a score F John s Web Server Johnny Cache is calculated for the cache server . One of ordinary skill will recognize that F John s Web Server X is calculated for each of the other cache servers X as well.

Some embodiments use a hash function of the two names for the function F. In some embodiments the calculated hash corresponds to an index in an array. The index represents one of the cache servers. Various other functions that use the server image name and cache server name as inputs are used in various different embodiments. Other descriptors of the server image and the cache server may be used as inputs by some embodiments as well e.g. the size of the server image a hardware address of the cache server etc.

As shown in stage F John s Web Server Cache 22 results in the highest affinity score. Accordingly at stage server image is loaded onto cache server Cache 22 . From cache server the image is streamed to hardware node for deployment as described above in Section II. In some embodiments the server image will not necessarily be loaded onto the cache server with the highest score. For instance if a particular cache server is in the process of receiving a first server image or is currently offline or otherwise busy then in some embodiments a second server image will not be loaded onto the particular cache server at the same time. Instead the router would send the server image to the cache server with the second highest affinity score. When the server image is loaded onto a cache server some embodiments insert the server image at the entry point of a queue for the cache server as described above by reference to .

A similar affinity scoring process is used when a utility management module sends a request for a server image to the caching network. As described above in Section III some embodiments first attempt to find the server image on the caching network before retrieving the server image from permanent storage. Some embodiments check each of the cache servers before sending a request to the permanent storage network for the server image. Some embodiments check only a particular number of cache servers e.g. the first cache server the first five servers etc. .

In order to more quickly find a requested server image on the caching network some embodiments calculate affinity scores for the server image paired with each cache server on the network. In some embodiments the scores calculated upon a request for a server image are the same scores described above that are calculated in order to determine onto which cache server a server image retrieved from the storage network should be loaded. In fact some embodiments do not recalculate the scores when loading a server image onto the cache server because the score was recently calculated in the process of attempting to retrieve the server image from the cache server without having to access the storage network. The cache server with the highest score for the retrieved server image is the most likely cache server to which the server image will be loaded and therefore is also the most likely cache server on which the server image will be found when requested by a hardware node.

As shown at stage a request is sent by hardware node to caching network . As before caching network has numerous cache servers including the three with names Cacher in the Rye Cache 22 and Johnny Cache . Server image John s Web Server is currently in the memory of cache server Cache 22 as described above by reference to . In some embodiments server image would have moved down in the queue of cache server as other images are loaded into and or deployed to hardware from cache server .

Although server image is in the queue of cache server the router that receives the request from hardware node for server image does not know this information initially in some embodiments. Thus this router or a module external to the router calculates affinity scores for the server image paired with each cache server on caching network . The scores are calculated by applying a function F to the name of the requested server image and the cache servers . Thus a score F John s Web Server Cacher in the Rye is calculated for cache server a score F John s Web Server Cache 22 is calculated for cache server and a score F John s Web Server Johnny Cache is calculated for the cache server . One of ordinary skill will recognize that F John s Web Server X is calculated for each of the other cache servers X as well.

Some embodiments use a hash function of the two names for the function F. Various other functions that use the server image name and cache server name as inputs are used in various different embodiments. Other descriptors of the server image and the cache server may be used by some embodiments as well e.g. the size of the server image a hardware address of the cache server etc.

As was the case in stage of F John s Web Server Cache 22 results in the highest affinity score. Accordingly cache server Cache 22 will be the first cache server on network checked for the presence of server image . In this case server image is in fact on this cache server and therefore no more cache servers need be checked. In some embodiments when the requested image is not on the cache server with the highest affinity score the cache server with the second highest score will be checked. Until the requested server image is found on one of the cache servers or all cache servers are examined the cache servers are checked in order of affinity score in some embodiments.

Stage illustrates that the server image is streamed to hardware node for deployment from cache server Cache 22 . In some embodiments as described above by reference to this moves the server image back to the entry point of the queue for cache server .

If any data errors in the server image are detected by the utility management module on hardware node some embodiments inform the caching network such that server image will be purged from the queue of cache server . The caching network would then re retrieve the server image from permanent storage performing a process similar to that shown in . The process would not necessarily be the same as in some cases a different cache server with a lower affinity score might be chosen.

The previous sections described saving and deploying single server images. In some embodiments users have the option of saving groups of servers as a whole. Such a group or configuration of servers might include one or more load balancers web servers database servers etc. Referring to the hosting system of the various servers in the configuration might be operating on multiple different hardware nodes in hardware grid .

In some embodiments the process for saving and or deploying a system template draws on the processes for saving and or deploying individual servers as described in Sections II IV. conceptually illustrates a process of some embodiments for saving a system template.

As shown process begins by receiving at a selection of a system template to save. This selection is received from a user through a user interface in some embodiments. illustrates a graphical user interface GUI of some embodiments that enables a user to save a system template. GUI includes a configuration display and a save option display area .

Configuration display includes graphical representations of four servers in a configuration controlled by a particular user. The configuration display includes graphical representations for a load balancer two web servers and and a database server . Each of the graphical representations may be selected by the user in order to access properties of the selected server. For instance selecting the load balancer would enable the user to modify properties of the represented load balancer such as the breakdown in traffic between the two web servers and currently shown as 35 to web server and 65 to web server . Selecting one of the web servers or would enable the user to modify the properties of the represented web server such as the memory allocated disk space installed software etc.

Save option display area includes two selectable save options. These selectable save options include an option for saving an individual image and an option for saving a system template or server configuration. Selecting the individual image option will enable the user to save an image of one of the servers in configuration display i.e. servers as described above in Section II. Selecting the system template save option initiates process in some embodiments saving the system configuration displayed in configuration display .

Returning to process next identifies at the servers in the selected system template. The received system template specifies which servers are to be saved. When this information is received at a system management module e.g. module the system management module identifies the location in the hardware grid e.g. grid of each of the different servers in the system template. As mentioned these servers will not necessarily be all operating on the same physical node but will be instead be spread throughout the grid of hardware nodes.

The process then stores at images of the identified servers and a configuration file for any load balancers as images of load balancers are not stored in some embodiments. In some embodiments each hardware node and the utility management module operating on the hardware node on which one of the identified servers is operating performs process in order to save the virtual server. In some embodiments each of the virtual servers has already performed process to prepare itself for being saved. The pre processing is performed in response to separate user instructions in some embodiments as described in reference to above. In other embodiments when instructions are received to store a system template the pre processing module is launched automatically on each of the virtual servers to be stored. The load balancer configuration file stores information about the load balancer that should be instantiated with the system template. In some embodiments this information includes the type of load balancer e.g. F5 the persistence of the load balancer e.g. sticky sessions cookie persistence etc. the load balancing method e.g. round robin least utilized etc. 

Next the process also stores at the links between the servers. The links are the information that enables the easy restoration at a later time of the entire server configuration in the same configuration as it was operating before. conceptually illustrates storage of the system template for configuration . System template is stored on a cloud storage cluster in some embodiments.

As illustrated server images for each of the servers are stored on cloud storage cluster in addition to numerous other images. In some embodiments server images are stored in the same format as they would be if they were saved individually. That is the server images are stored with checksums every unit e.g. 1 Mb and are compressed files. The configuration file for load balancer is also stored on the storage cluster .

System template is a file that defines how the server images are connected that is system template defines the configuration of the server images. System template includes eight entries. The first four entries specify the various server images that make up the system template. The second four entries specify the connections between the virtual machine instantiations of these server images. The entries in system template specify connections between the load balancer and the two web servers and connections between the two web servers and the database server. Some embodiments include other information as well such as the percentages of traffic being sent from the load balancer to each of the web servers information about configuration file values for the various servers etc.

The system templates are different types of files in different embodiments. In some embodiments system templates are stored as XML files or other in other markup languages. In such embodiments the reference to a web server image might be a tag followed by an entry specifying the web server name storage location etc. and an end tag . References to other server images would be stored similarly. Connections would then be stored as a tag followed by an entry specifying two servers to connect and any properties of the connection and then an end tag . One of ordinary skill will understand that these are merely examples of possible tags for a system template and that other tags forms of markup language or storage formats could be used in different embodiments to define a server configuration such as system template .

While the system template and its associated server images and configuration files are stored on a single cloud storage cluster in some embodiments the server images may be stored on a different storage cluster from the system template or even on different storage clusters from each other.

Much like individual server images once system templates are saved they can then be deployed. To deploy a system template some embodiments deploy each of the server images referenced in the template and then set up the configuration of the server images. conceptually illustrates a process of some embodiments for deploying such a system template. In some embodiments process is performed on a storage and hosting system such as system of .

As shown the process begins by receiving at a selection of a stored template to deploy. This selection is received from a user through a user interface in some embodiments. Much like the graphical user interface of that enables a user to save a system template some embodiments present the user with a graphical user interface that lists their saved templates and allows the user to choose any of them for deployment. Some embodiments also list public templates. Public templates are created by other users and shared for public use in some cases for a fee. The fee may go to either the user who created the template the owners of the hosting and storage system or both.

Once the system template selection is received from the user the process identifies at the server images referenced in the system template. In some embodiments this is performed by a module such as system management module . When the system template is stored as a markup language file a parser e.g. an XML parser on the system management module reads the markup language file to identify the server images.

This may also involve identifying a hardware node for each server image specified by the system template. Different hardware nodes may be identified for the various server images specified by the system template. That is the server images may not all be deployed on the same hardware node. In some embodiments specific hardware is used for load balancer virtual machines and therefore when the system template specifies a load balancer in addition to other servers it is not possible for all of the server images to be deployed on the same hardware node. However multiple web servers may be deployed on one hardware node. In the case in which multiple server farms at different geographic locations are used in the hosting and storage system some embodiments preferentially assign all of the server images to the same geographic location.

Process then deploys at the identified server images. In some embodiments process is performed for each of the identified server images by the utility management module on the hardware node identified for the server image. That is the utility management module allocates hardware for the server image retrieves the server image verifies the integrity of the server image data and lays down the data on the disk volume. Process also configures at the deployed servers. That is the system specific information is configured on the virtual machines and the paravirtualization drivers are installed as described above in Section III.

Next the process configures at connections between the installed servers. In the example of system template the connections between the load balancer and the two web servers would be configured as well as the connections between the two web servers and the database server. The IP addresses of the virtual servers are known to the system management module in some embodiments thereby making it easy for this information to be sent to the necessary servers e.g. giving the IP addresses of the web servers to the load balancer .

As mentioned in some embodiments a user has the ability to choose from a number of system templates. These system templates may be server configurations saved by the user themselves or by other users that have made their system templates public. Some embodiments present the user with a list of their system templates and an option for each of the templates to make that template public. Similarly a user s server images may be made public in some embodiments. For each server image a user has saved an option is presented in the GUI that allows the user to make the server image public.

Different embodiments handle the public server images and system templates differently. In some embodiments the user that saves the server image or system template assigns a cost for another user to deploy the server image or system template. Other embodiments use a fixed cost or make the public server images and system templates available for free. The payment for the server image or system template separate from any costs of deploying and operating the virtual machines on the hosting system is either given to the user that designed the server image or system template and made it public the owners of the hosting and storage system or is split between the two.

Some embodiments present a user with an option to select public server images or system templates in the GUI. Referring to when a user selects a GUI item for adding an image some embodiments present an item in the GUI that the user can select to view public server images and or system templates. When this option is selected in addition to the user s own server images and or system templates the public server images and system templates will be made available. The user can search through the individual server images by size operating system server type applications etc. Similarly the user can search through the system templates based on parameters such as the number of each type of server the parameters of the individual servers size operating system etc. and other differentiators.

In some embodiments a server image saved from a virtual machine in a hosting system as described above in Section II may be used as a dedicated physical machine in the hosting system or as a physical or virtual machine outside the hosting system. For example a server image could be ported to a second different hosting system to a user s personal computer without virtualization etc.

Because the server image is simply a file that file may be downloaded to a user s personal data storage e.g. a hard drive removable flash memory etc. . Some embodiments provide the user with an export option in the GUI for the user s own server images though not for any public server images that are available to the user. The export option enables the user to receive the server image file either via e mail download to the device with which the user has logged into the hosting and storage system or other electronic file transfer. Further options can include placing the server image on a removable medium such as a CD or DVD and mailing the medium to the user.

In some embodiments once the user has possession of the server image the server image may be used on any computer including those outside the hosting system in which it was created. For instance the user could have an account on a different hosting system with a structure that could be either similar to or different from hosting and storage system . If the second hosting system provides the functionalities described above in Section III for deploying a virtual machine from a server image then the user would be able to deploy a virtual machine on the second hosting system based on the server image saved from the first hosting system.

For the second hosting system to be able to deploy the server image as a virtual machine the system would require the ability to decompress and read the file created by the first hosting system. The second hosting system would need to be able to identify the checksums recalculate the checksums and identify the necessary installation processes such as configuring the system specific information installing the paravirtualization drivers etc. Some embodiments of the hosting system that creates the server image however use a proprietary compression algorithm and or checksum format that prevents the user of a server image outside of the hosting system.

As mentioned in some embodiments a user can use the server image file to install a server on a physical device e.g. a personal computer without virtualization. To do this the server will need to be adapted to run directly on the hardware of the device rather than as a virtual machine through a hypervisor. As the server image of some embodiments has no reference to a hypervisor adapting the server to run directly on device hardware may involve installing drivers designed for such bare metal installations rather than paravirtualization drivers.

As shown process begins by receiving at a selection of a stored server image to install on the physical device. This may be received through a user of a first device selecting a server image through a graphical user interface of a first device e.g. selecting a file stored on a removable flash drive a CD etc. that is connected to the physical device and then selecting the physical device as a location to deploy the server image.

Next the process lays down at the server image on the disk volume of the physical device. As there is no virtualization the disk volume is the entire hard drive of the physical device in some embodiments. In some embodiments the first device includes an application that performs the functions of a utility management module for installing the server image. This application attaches to the disk volume of the physical device and lays down the bits of the server image on the disk volume. In some embodiments the application also performs integrity checking by verifying the checksums that are part of the server image file. When the server image data is corrupted some embodiments will not install the server image unless an original copy of the image can be retrieved.

Once the server image data is installed on the physical device process configures at the installed image with system specific information. In some embodiments this is the same system specific information as would be configured were the image installed as a virtual machine in a hosting system. For instance in some embodiments when the virtual machine is a server running the Microsoft Windows operating system the system specific information includes the Windows Security Identifier SID network configurations and desktop and administrator profiles. In some embodiments when the virtual machine is a server running the Linux operating system the system specific information includes any unique identifiers e.g. a RHEL registration ID etc. log files and history files. Different embodiments will include different information both the above listed information as well as other information that is not listed in the system specific information.

The process also installs at physical device drivers on the laid down image. As opposed to paravirtualization drivers the physical device drivers are designed for the operating system to interface directly with the hardware without a hypervisor in between. Because the operating system of the image is the only one running on the device no hardware resources need to be shared with any other operating system. One of ordinary skill in the art will recognize that in some embodiments operations and will not necessarily be performed in the order shown in process . Some embodiments will perform these operations in the opposite order or will perform both simultaneously

Some embodiments also enable a user to save a system running directly on a physical device as a server image that can be deployed as a virtual machine in a hosting and storage system such as that shown in . In fact conceptually illustrates that a server image can be used to easily transfer a system configuration between a physical machine e.g. a user s personal computing device a hardware node in a hardware grid etc. and a virtual machine operating on a hardware node e.g. a hardware node in a hardware grid .

As illustrated system configuration runs on the hardware of physical machine using device drivers . In some embodiments device drivers are part of the kernel of the machine . Using a process or processes similar to portions of processes and the system configuration can be stored as server image . A device attached to physical machine can be used to remove the device drivers and any system specific information from configuration and then store the system configuration as server image . This device can also calculate and attach checksums for each unit e.g. 1 Mb of the system configuration as well as compress the server image in some embodiments. The device may be another physical machine with an application that performs the extraction and compression of the system configuration may be a virtual machine or may be a module that is part of a hosting and storage system e.g. the system management module . As such when extracted server image may be stored on the physical machine that performed the extraction on a different machine or in a hosting and storage system as described above in Section IV.

The server image can then be deployed as a virtual machine on hardware node . As illustrated node includes hardware resources hypervisor and utility management module . The node may be the same as node or node with multiple virtual machines including UVM sharing hardware resources through hypervisor . Through a process such as shown in the server image is laid down on node . The virtual machine has the same system configuration as did physical machine . However paravirtualization drivers are swapped in for the device drivers during the deployment process.

Similarly as described above by reference to process of and illustrated in a system configuration of a virtual machine can be saved as a server image and then installed on a physical device. System configuration can be saved off of hardware node via processes and . The server image can then be used to install system configuration on physical machine . In this case the paravirtualization drivers are swapped out for device drivers allowing the system configuration to interact directly with the hardware of physical machine .

In addition to moving a system configuration from a physical machine to a virtual machine a virtual machine to a physical machine or from a virtual machine in one hosting system to another the server images described above may also be used to move a system configuration from one physical machine to another. This requires a first device that attaches to a first physical machine is capable of extracting the configuration and storing the server image and a second device that attaches to the second physical machine is capable of laying down and deploying the system configuration on the second physical machine. Transferring a system configuration from a first physical machine to a second physical machine enables a computer user who purchases a better machine but likes the setup of their current machine to easily set up the same configuration operating system applications etc. on the newer better machine.

When a user requests to have a virtual server deployed in a hosting and storage system such as that of a number of operations must be performed before the virtual server is actually operational for use. The system management module assigns the virtual server to a particular hardware node then a disk volume is built on the hardware node and then the virtual server may be deployed. The virtual server may be deployed from a server image as described in detail in Section III or may be deployed without such a server image as described in U.S. patent application Ser. No. 12 421 597 filed Apr. 9 2009 and titled System and Method for Automated Allocation of Hosting Resources Controlled by Different Hypervisors which is incorporated herein by reference.

Each of these processes takes time such that there is a delay from the time the user submits a request through the GUI to deploy a server to the time that the server is actually operational. Some embodiments though perform one or more of these operations in advance such that when the user requests for a server to be deployed the server is operational more quickly. For example some embodiments maintain a baseline level of pre built disk volumes within the hardware grid of the hosting system. Furthermore some embodiments also maintain a number of pre configured virtual machines for popular servers.

As shown process begins by identifying at particular types of disk volumes to monitor on the hardware grid. The different types of disk volumes to monitor might be specified by an administrator of the hosting system determined based on an algorithm identifying the most popular types of disk volume used in the hosting system or in some other fashion. The different types of disk volumes are different sizes e.g. 20 Gb 50 Gb 100 Gb etc. in some embodiments. Some hosting systems offer numerous sizes for virtual servers and when a particular size is identified as especially popular size either by an administrator or a monitoring module the particular size might be identified by monitoring. The different types of disk volumes might also be disk volumes on different hardware. For instance some hosting systems use different hardware for different types of virtual servers e.g. load balancers web servers database servers etc. and only pre build disk volumes for some of these types of virtual servers.

Next the process monitors at the available disk volumes in the hardware grid. In some embodiments the monitoring module either the system management module or a separate module regularly polls the hardware nodes to identify whether the nodes have any pre built disk volumes. In other embodiments the monitoring module keeps track of each of the pre built disk volumes based on instructions that have been sent to the nodes. The monitoring module keeps track of how many disk volumes have been built and whether virtual machines have been deployed on the disk volumes. This information may be stored in a database such as back end database of hosting system or may be stored in memory accessed by the monitoring module in some embodiments. The process may monitor the available disk volumes continuously or at regular intervals.

Process then determines at whether there are any disk volumes that need to be built. This determination is made based on the monitoring performed at . When the number of pre built disk volumes of a particular type e.g. size on the hardware grid falls below a particular threshold the process determines that one or more disk volumes are needed. When no new disk volumes are needed the process proceeds to which is described below.

Otherwise the process determines that at least one new disk volume should be built and identifies at the next disk volume to build. When there are numerous disk volumes to be built on the hardware grid some embodiments determine the order in which they should be built randomly. Other embodiments identify which type e.g. size of disk volume is most lacking in the grid and have that type built first.

Next process selects at a hardware node for the identified disk volume. In some embodiments this selection is performed by the system management module or a separate scheduling module as described above in Section I. The optimization algorithm is not as complex as for scheduling a virtual server deployment in some embodiments because for the virtual server its interactions with other virtual servers must be taken into account in determining a hardware node especially when there are multiple server farms in different locations. On the other hand a pre built disk volume does not interact with anything. When there are multiple server farms in different locations though some embodiments do take into account which of the different locations is lacking in pre built volumes of the identified type.

Once the hardware node is identified the process instructs at the selected hardware node to build the identified disk volume. This is sent as an instruction directly to the node in some embodiments. Other embodiments send the instruction to the utility management module on the node or to the hypervisor on the node to have the disk volume built. In some embodiments the utility management module accesses the hardware resources of the node through the hypervisor in order to build the disk volume.

Once the instructions have been sent to the node to allocate the disk volume the process determines at whether any more disk volumes need to be built at the moment. When more disk volumes have been identified the process returns to to identify the next disk volume that should be built. Otherwise the process determines at whether to continue monitoring the hardware grid. Some embodiments continue monitoring the grid at all times unless the hosting system is shut off. When the process determines to continue monitoring the grid it returns to described above. Once the grid no longer need be monitored the process ends.

As mentioned above pre building disk volumes helps cut down on the time required to deploy a virtual machine whether from a saved pre configured server image as described in Section III or a blank image. conceptually illustrates a process of some embodiments for deploying a virtual server in a hardware grid that uses pre built disk volumes. Like process process is performed by a system management module in some embodiments.

As shown the process begins by receiving at information specifying a virtual server to deploy on the hardware grid. In some embodiments this information is received from a user interacting with a user interface. The user instructions to deploy a virtual server are sent through the user interface to front end architecture such as provisioning manager and RMS module of . In turn the RMS module passes the instructions to the system management module so that the system management module can handle the deployment.

Next the process identifies at the type of the disk volume needed for the specified virtual server. In some embodiments this is simply the size of the disk volume specified by the user for the virtual server e.g. 20 Gb 50 Gb etc. . In other embodiments however the type of disk volume may also include a particular type of hardware that is dependent on either the type of virtual sever load balancer web server database server etc. or the specified operating system Windows Linux etc. .

Process then determines at whether there are any disk volumes of the identified type pre built on the hardware grid already. In some embodiments the process polls the various hardware nodes to look for pre built disk volumes. In other embodiments as described above the back end storage or a comparable storage stores a running list of all of the pre built disk volumes. In such embodiments the process consults this list to identify whether the needed volume already exists in the hardware grid.

When the needed disk volume already exists the process selects at a disk volume for the specified virtual server. When multiple pre built disk volumes are available for a particular virtual server some embodiments perform an optimization process to identify the optimal node on which to deploy the specified virtual server. This optimization process is similar to the process used to determine on which node to deploy a virtual server when disk volumes are not pre built. However in the case of pre built disk volumes there will be less possible nodes to choose from as most likely not every single node in the grid will have the desired type of disk volume pre built.

On the other hand when there are no pre built disk volumes of the needed type in the hardware grid the process selects at a hardware node for the specified virtual server. Some embodiments perform an optimization process as mentioned in Section I and described in further detail in U.S. patent application Ser. No. 12 421 597 filed Apr. 9 2009 and titled System and Method for Automated Allocation of Hosting Resources Controlled by Different Hypervisors which is incorporated herein by reference.

Once the hardware node is selected the process instructs at the node to build the desired disk volume. This is sent as an instruction directly to the node in some embodiments. Other embodiments send the instruction to the utility management module on the node or to the hypervisor on the node to have the disk volume built. In some embodiments the utility management module accesses the hardware resources of the node through the hypervisor in order to build the disk volume.

Next the process instructs at the node to deploy the virtual server. In some embodiments this instruction is sent to the utility management module. The utility management module then retrieves a pre configured saved server image from the caching network or permanent storage if the specified virtual server is to be deployed from such a server image. The process then ends.

In addition to pre building disk volumes some embodiments pre deploy popular virtual servers in the hardware grid. This saves even more time than the pre built disk volumes because when a user selects a virtual server for deployment the virtual server need only be configured for the user s IP address and other such configuration settings. The disk volume need not be built and the operating system and other applications need not be installed.

As shown process begins by identifying at particular publicly available server images to monitor. The different server images to monitor might be specified by an administrator of the hosting system determined by a module that identifies the most commonly used server images in the hosting system or in some other fashion. In some embodiments the different server images will include web servers database servers load balancers etc.

Next the process monitors at the unused pre deployed server images in the hardware grid. In some embodiments the monitoring module either the system management module or a separate module regularly polls the hardware nodes to identify whether the nodes have any deployed but unused virtual servers. In other embodiments the monitoring module keeps track of each of the deployed unused virtual servers based on instructions that have been sent to the nodes. The monitoring module keeps track of how many virtual servers have been deployed and whether those virtual servers were assigned to a user. This information may be stored in a database such as back end database of hosting system or may be stored in memory accessed by the monitoring module in some embodiments. The process may monitor the available deployed virtual servers continuously or at regular intervals.

Process then determines at whether there are any virtual servers that need to be deployed on the hardware grid from server images. This determination is made based on the monitoring performed at . When the number of unused deployed virtual servers from a particular server image falls below a particular threshold the process determines that one or more virtual servers need to be deployed from the server image. When no new virtual servers are needed the process proceeds to which is described below.

Otherwise the process determines that at least one virtual server should be deployed and identifies at the next server image that should be deployed as a virtual server. When there are numerous server images that need to be deployed some embodiments determine the order in which they should be deployed randomly. Other embodiments identify which server image is most lacking in the grid and deploy that image first.

Next process selects at a hardware node for the identified disk volume. In some embodiments this selection is performed by the system management module or a separate scheduling module as described above in Section I. The optimization algorithm is not as complex as for scheduling a virtual server deployment for a particular user in some embodiments because for a virtual server configured for a particular user its interactions with other virtual servers must be taken into account in determining a hardware node especially when there are multiple server farms in different locations. On the other hand a pre deployed virtual server does not interact with anything as it is not yet up and running. When there are multiple server farms in different locations though some embodiments do take into account which of the different locations is lacking in pre deployed virtual servers for the particular server image.

Once the hardware node is identified the process instructs at the node to build a disk volume and deploy the virtual server form the server image on the built disk volume. In some embodiments this is simply an instruction to deploy the virtual server along with information about the virtual server. From the disk size information the node will then build the disk volume. In some embodiments these instructions are sent directly to the node. Other embodiments sent the instructions to the utility management module on the node or to the hypervisor on the node. In some embodiments once instructed the utility management module performs most of process to build the disk volume retrieve the specified server image and deploy the server image on the disk volume.

Once the instructions have been sent to the node to retrieve and deploy the server image the process determines at whether any more virtual servers need to be deployed at the moment. When more virtual servers need to be deployed the process returns to to identify the next server image for deployment. Otherwise the process determines at whether to continue monitoring the hardware grid. Some embodiments continue monitoring the grid at all times unless the hosting system is shut off. When the process determines to continue monitoring the grid it returns to described above. Once the grid no longer need be monitored the process ends.

As mentioned pre deploying the server images as virtual servers that are not yet configured for a particular user helps cut down on the time required to deploy a virtual server when a user requests the server. conceptually illustrates a process of some embodiments for deploying a virtual server in a hardware grid that uses pre deployed servers and pre built disk volumes. Some embodiments will use pre built disk volumes for virtual servers that are not deployed from previously saved server images. Like process process is performed by a system management module in some embodiments.

As shown the process begins by receiving at information specifying a virtual server to deploy on the hardware grid. In some embodiments this information is received from a user interacting with a user interface. The user instructions deploy a virtual server are sent through the user interface to front end architecture such as provisioning manager and RMS module of . In turn the RMS module passes the instructions to the system management module so that the system management module can handle the deployment.

Next the process determines at whether the desired virtual server already exists pre deployed in the hardware grid. In some embodiments virtual servers are only pre deployed when the user requests a virtual server from a publicly available pre configured server image. When the user has not specified a publicly available server image for deployment then the desired virtual server will not already exist in the hardware grid. In some cases not all publicly available server images will be pre deployed. When the requested virtual server is one that might be pre deployed in the grid some embodiments poll the various hardware nodes to look for the pre deployed server. In other embodiments as described above the back end storage or a comparable storage stores a running list of all of the pre deployed virtual servers. In such embodiments the process consults this list to identify whether the needed server already exists in the hardware grid.

When the requested virtual server is pre deployed in the hardware grid the process selects at one of the pre deployed instances of the requested virtual server. When there is more than one instance some embodiments perform an optimization process based on the currently used resources the other virtual servers with which the presently requested virtual server will interact etc. The process then selects the optimal instance of the virtual server for configuration for the requesting user. The process then proceeds to described below.

When the requested server is not already deployed the process identifies at the type of the disk volume needed for the specified virtual server. In some embodiments this is simply the size of the disk volume specified by the user for the virtual server e.g. 20 Gb 50 Gb etc. . In other embodiments however the type of disk volume may also include a particular type of hardware that is dependent on either the type of virtual sever load balancer web server database server etc. or the specified operating system Windows Linux etc. .

Process then determines at whether there are any disk volumes of the identified type pre built on the hardware grid already. In some embodiments the process polls the various hardware nodes to look for pre built disk volumes. In other embodiments as described above the back end storage or a comparable storage stores a running list of all of the pre built disk volumes. In such embodiments the process consults this list to identify whether the needed volume already exists in the hardware grid.

When the needed disk volume already exists the process selects at a disk volume for the specified virtual server. When multiple pre built disk volumes are available for a particular virtual server some embodiments perform an optimization process to identify the optimal node on which to deploy the specified virtual server. This optimization process is similar to the process used to determine on which node to deploy a virtual server when disk volumes are not pre built. However in the case of pre built disk volumes there will be less possible nodes to choose from as most likely not every single node in the grid will have the desired type of disk volume pre built.

On the other hand when there are no pre built disk volumes of the needed type in the hardware grid the process selects at a hardware node for the specified virtual server. Some embodiments perform an optimization process as mentioned in Section I and described in further detail in U.S. patent application Ser. No. 12 421 597 filed Apr. 9 2009 and titled System and Method for Automated Allocation of Hosting Resources Controlled by Different Hypervisors which is incorporated herein by reference.

Once the hardware node is selected the process instructs at the node to build the desired disk volume. This is sent as an instruction directly to the node in some embodiments. Other embodiments send the instruction to the utility management module on the node or to the hypervisor on the node to have the disk volume built. In some embodiments the utility management module accesses the hardware resources of the node through the hypervisor in order to build the disk volume.

Next the process instructs at the node on which the disk volume is now built to deploy the virtual server on the built disk volume. When the requested virtual server is deployed from a server image portions of process are performed by the utility management module to retrieve the requested server image from storage and deploy the server image on the disk volume.

The process then instructs the node to configure the virtual server for the user. In some embodiments this includes installing updated paravirtualization drivers and system specific information. The system specific information as described above may vary depending on the operating system of the virtual server. For instance in some embodiments when the virtual machine is a server running the Microsoft Windows operating system the system specific information includes the Windows Security Identifier SID network configurations and desktop and administrator profiles. In some embodiments when the virtual machine is a server running the Linux operating system the system specific information includes any unique identifiers e.g. a RHEL registration ID etc. log files and history files. Different embodiments will include different information both the above listed information as well as other information that is not listed in the system specific information that is removed from a virtual server before it is saved as a server image.

Though operations and are illustrated as different operations in some embodiments only send one set of instructions to the node. When no disk volume is built the instructions indicate for the utility management module to build the disk volume retrieve the server image deploy the server image and configure the server for use. When the disk volume is built but there is no server pre deployed the instructions indicate for the utility management module to retrieve the server image deploy it on the disk volume and configure the server for use. When the server is pre deployed the instructions just indicate for the utility management module to configure the virtual server for use.

While pre building disk volumes and pre deploying virtual servers will generally help speed up the deployment process in some situations the resources allocated to such a pre built volume or pre deployed server will be needed for another server. For instance a 20 Gb disk volume or pre deployed server might be taking up resources that are needed for a 100 Gb server because a system management module determined that the node on which the 20 Gb disk volume is allocated is the optimal location for the 100 Gb virtual server. Some embodiments will thus remove such pre built volumes when the resources are needed for a new server. The disk volume is de allocated and if a server image had been pre deployed on the disk volume then random data is written to the disk. The disk resources are now available for use by the new server.

Many of the above described processes and modules are implemented as software processes that are specified as a set of instructions recorded on a computer readable storage medium also referred to as computer readable medium . When these instructions are executed by one or more computational element s such as processors or other computational elements like ASICs and FPGAs they cause the computational element s to perform the actions indicated in the instructions. Computer is meant in its broadest sense and can include any electronic device with a processor. Examples of computer readable media include but are not limited to CD ROMs flash drives RAM chips hard drives EPROMs etc.

In this specification the term software is meant in its broadest sense. It can include firmware residing in read only memory or applications stored in magnetic storage which can be read into memory for processing by a processor. Also in some embodiments multiple software inventions can be implemented as sub parts of a larger program while remaining distinct software inventions. In some embodiments multiple software inventions can also be implemented as separate programs. Finally any combination of separate programs that together implement a software invention described here is within the scope of the invention. In some embodiments the software programs when installed to operate on one or more computer systems define one or more specific machine implementations that execute and perform the operations of the software programs.

The bus collectively represents all system peripheral and chipset buses that communicatively connect the numerous internal devices of the computer system . For instance the bus communicatively connects the processor with the read only memory the system memory and the permanent storage device . From these various memory units the processor retrieves instructions to execute and data to process in order to execute the processes of the invention. The processor is a processing device such as electronic circuitry.

The read only memory ROM stores static data and instructions that are needed by the processor and other modules of the computer system. The permanent storage device on the other hand is a read and write memory device. This device is a non volatile memory unit that stores instructions and data even when the computer system is off. Some embodiments of the invention use a mass storage device such as a magnetic or optical disk and its corresponding disk drive as the permanent storage device .

Other embodiments use a removable storage device such as a floppy disk flash drive or ZIP disk and its corresponding disk drive as the permanent storage device. Like the permanent storage device the system memory is a read and write memory device. However unlike storage device the system memory is a volatile read and write memory such a random access memory RAM . The system memory stores some of the instructions and data that the processor needs at runtime. In some embodiments the invention s processes are stored in the system memory the permanent storage device and or the read only memory .

The bus also connects to the input and output devices and . The input devices enable the user to communicate information and select commands to the computer system. The input devices include alphanumeric keyboards and pointing devices also called cursor control devices . The input devices also include audio input devices e.g. microphones MIDI musical instruments etc. . The output devices display images generated by the computer system. For instance these devices display a GUI. The output devices include printers and display devices such as cathode ray tubes CRT or liquid crystal displays LCD .

Finally as shown in bus also couples computer to a network through a network adapter not shown . In this manner the computer can be a part of a network of computers such as a local area network LAN a wide area network WAN or an Intranet or a network of networks such as the internet. For example the computer may be coupled to a web server network so that a web browser executing on the computer can interact with the web server as a user interacts with a GUI that operates in the web browser.

Any or all components of computer system may be used in conjunction with the invention. Though type 1 or type 2 hypervisors are shown in some of the various figures it should be apparent to one of ordinary skill in the art that any type of hypervisor may operate with the various components of some embodiments such as the system management module and the utility management module.

As mentioned above the computer system may include one or more of a variety of different computer readable media. Some examples of such computer readable media include RAM ROM read only compact discs CD ROM recordable compact discs CD R rewritable compact discs CD RW read only digital versatile discs e.g. DVD ROM dual layer DVD ROM a variety of recordable rewritable DVDs e.g. DVD RAM DVD RW DVD RW etc. flash memory e.g. SD cards mini SD cards micro SD cards etc. magnetic and or solid state hard drives ZIP disks read only and recordable blu ray discs any other optical or magnetic media and floppy disks.

While the invention has been described with reference to numerous specific details one of ordinary skill in the art will recognize that the invention can be embodied in other specific forms without departing from the spirit of the invention. Thus one of ordinary skill in the art would understand that the invention is not to be limited by the foregoing illustrative details but rather is to be defined by the appended claims.

