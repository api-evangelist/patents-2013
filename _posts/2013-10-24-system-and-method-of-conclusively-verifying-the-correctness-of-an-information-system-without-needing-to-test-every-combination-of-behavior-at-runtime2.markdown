---

title: System and method of conclusively verifying the correctness of an information system without needing to test every combination of behavior at run-time
abstract: An architecture for the initial development and later adaptation of systems comprising a database, one or more client or user-interface programs whose system data, application data and rule data are stored in the database alongside the content. A framework in the database stores system, application and rule data and frameworks in the user-interface and client programs load the system, application and rule data to generate objects and, in doing so, define an application-specific system. Data integrity checks of the system data, application data and rule data using triggers and/or stored procedures ensure the correctness of the system without having to test every combination of behavior at run-time.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09582531&OS=09582531&RS=09582531
owner: 
number: 09582531
owner_city: 
owner_country: 
publication_date: 20131024
---
This application is a continuation of U.S. patent application Ser. No. 12 520 274 entitled SYSTEM AND METHOD OF CONCLUSIVELY VERIFYING THE CORRECTNESS OF AN INFORMATION SYSTEM WITHOUT NEEDING TO TEST EVERY COMBINATION OF BEHAVIOR AT RUN TIME filed by Paul Leslie Tomkins which is a national stage entry under 35 U.S.C. 371 of PCT GB08 00296 filed on Jan. 30 2008 which claims priority upon UK Patent Application No. 0701915.1 filed on Feb. 1 2007 the entire disclosures of which are incorporated herein by reference.

The invention relates to the initial development and later adaption of applications and in particular to information systems which include a database and one or more clients or user interfaces. The invention goes beyond the simple storage of content data in the database to the storage of system data application data and rule data required to develop and run an information system. On connecting to the database a client or user interface program loads the system data application data and rule data to generate an information system.

Information systems are well known. Examples include accounting stock control and contact management systems. At a simple level each of these systems comprise a database and one or more clients or user interfaces. At an intermediate level of detail they comprise tables content data data sets forms and rules. At a more detailed level an information system is composed of tables fields data types indexes data sets entities columns joins filters data sources menus menu widgets toolbars tool widgets forms form widgets events functions blocks iterations conditions tests and statements.

While a stock control system will clearly have a different set of application tables fields data sets forms rules and content data to a contact management system both information systems are made up of substantially the same features like tables content data data sets forms and rules. It is in the number and behaviour of these features that information systems differ.

The behaviour of each of these features has to operate in harmony with the behaviour of the other features for the system to work correctly. Assume an information system has a number of tables fields and rules. It is not uncommon either during the initial development or later adaptation for the data structure of an information system to be changed. This means that tables and fields might need to be added renamed or removed. However the action of changing the data structure means that anything dependent on that data structure will also need to be updated. For example any relationship rules between the tables may have to be updated and any validation rules which reference a changed field will have to be updated. As updates are made so the developer has to ensure that those changes do not affect features further up the stack. Clearly the lower in the stack that a change is made where the chain of dependencies is longer the more checks and updates need to be performed and the more time consuming and error prone changes become.

What makes the initial development and later adaptation of information systems using the traditional architecture time consuming and error prone is that the traditional architecture does not make it easy to identify dependencies or to conclusively verify the correctness of an application.

The way in which features are defined in the traditional architecture do not make it easy for dependencies to be identified. Often in the traditional architecture the definitions of tables and fields are embedded in the database API Application Programming Interface rules are defined in a proprietary procedural SQL Structured Query Language in the database or in C or Basic in the client or user interface data sets are defined as SQL strings and user interface elements are defined in C or Basic. It therefore requires the developer to locate and search through the code to identify and update dependencies and to verify that references point to actual objects and that those referenced objects are computationally compatible.

Information systems differ architecturally in where they incorporate different features the database the client or user interface or any combination of these. Content data is always stored in the database and forms are always a feature of the user interface. But rules and data sets can be defined in the database the client or user interface or a combination of any of these and even sometimes reproduced in the database the client or user interface. The effect of this distribution of features is that developers can only really demonstrate the correctness of a system by testing every possible combination of behavior at run time.

Given that information systems are so difficult to build update and verify it is little wonder that users buy off the shelf packages and adapt their processes to the package rather than adapting the package to their processes. It is also the reason why customized systems are so time consuming expensive and error prone and why so much development overshoots schedules and budgets and why so many projects fail altogether.

What is needed is an architecture which allows information systems to be developed and adapted quickly and where the application can be assured of correctness irrespective of whatever changes it is subjected to.

The object of this invention is to provide an architecture for the initial development and later adaption of information systems which includes a database and one or more client or user interface programs so that applications can be developed and adapted quickly and where the application can be assured of correctness irrespective of whatever changes it is subjected to.

Accordingly this invention provides a system comprising a database one or more client or user interface programs and any number of supporting libraries whose system data application data and rule data are stored in the database alongside the content data so that the correctness of the system can be ensured.

Preferably the system structures application structures system data application data rule data and content data are stored in the same relational database but may instead be stored in different relational databases in non relational databases in any persistent store or an in memory structure all application specific properties and events are stored in the database but some properties and events can be stored external to the database the integrity checking occurs both at the user interface or client and then again at the database but such checks could occur any number of times at the point of selecting the options in the user interface in a middleware application through which data is passed between the user interface or client and the database or on committing the changes in the database.

The present invention describes an architecture for an information system which includes a database and one or more client or user interface programs so that information systems can be developed and adapted quickly and where the application can be assured of correctness irrespective of whatever changes it is subjected to.

The key aspect of the present invention is the storage of system data application data and rule data in the database alongside content data in such a way that the integrity of the system is ensured. Hence to understand the description of the present invention we will start with how information systems are traditionally designed and methodically re architect the process one stage at a time such that a person skilled in the art can follow the logic appreciate the benefits and replicate the architecture.

The description will provide the opportunity to demonstrate how supplementary features can be added to an information system in the form of extensions and how such extensions are integrated consistently into the architecture of the present invention. The description will then take as an example a basic order entry system which exhibits all the core features of an information system.

A database is in any persistent store or in memory structure in which data is stored. A program is a generic user interface or client which provides the framework into which the number and behaviour of system and application specific features are loaded which generates instances and customizes the behaviour of application specific objects and from which system and application rules can be executed. In doing so generic user interface and client programs are transformed into application specific user interface and clients. In the present invention a distinction is made between a user interface program and a client program. The present invention provides a module for the Apache HTTP web server. The module connects to the database like a user interface program but does not directly provide a user interface. The user interface to the module is provided independently by the web browser.

System structures are defined as structures which are consistent across all types of information system. For example system structures comprise the tables fields data types and rules which features common to all types of information systems can be stored in and validated with. Such features include the tables fields data types indexes data sets entities columns joins filters data sources menus menu widgets toolbars tool widgets forms form widgets events functions blocks iterations conditions tests and statements of an information system.

Application structures are defined as structures which are specific to a type of information system. In a basic order entry system application structures might include tables and fields to store products customers orders and the individual order lines data.

System data is defined as data which is consistent across all types of information systems. System data lists the system tables system fields system data types and system rules which are common to all types of information system. In the present invention the boolean field SYS IS SYSTEM is set to 1 to identify system data as opposed to application data in the system structures.

Application data is defined as data which distinguishes one type of information system from another. Application data lists the number and behaviour of the features required by the specific information system. For example application data lists the application specific tables fields data types indexes data sets entities columns joins filters data sources menus menu widgets toolbars tool widgets forms form widgets events functions blocks iterations conditions tests and statements and the application specific behaviour of each of these individual features. In the present invention the boolean field SYS IS SYSTEM is set to 0 to identify application data as opposed to system data in the system structures.

Content data is defined as data stored in the application specific structures. In a basic order entry content data might include the list of products customers orders and the content of the individual lines of an order.

Rule data is defined as data which is used to ensure the correctness of the system application and content data. In the present invention the boolean field SYS IS SYSTEM is set to 1 to indicate system rules and to 0 to indicate application rules in the system structures.

Database architecture generally makes the list of tables accessible through the application programming interface API of the database. The API also lists which fields belong to which tables the data types of the individual fields and the indexes that are applied to those fields.

Some databases Firebird as an example and the database used in the present invention go further and provide this meta data in Firebird tables RDB RELATIONS as illustrated in RBD RELATION FIELDS as illustrated in RBD FIELDS as illustrated in and a combination of RDB INDICES and RDB INDEX SEGMENTS as illustrated in . That this information is available in a structured format consistent with the architecture proposed by the present invention provides further reliability as explained below.

Changes to the database usually expressed in DDL data definition language examples of which appear in ensure that a field can never be assigned to a non existent table that a field can never be assigned a non defined data type and that an index can never be applied to a non existent field.

The database further ensures that if a table is deleted or renamed usually expressed in DDL examples of which appear in then all the fields assigned to that table are deleted or reassigned to the renamed table. If a field is deleted or renamed any indexes assigned to that field are deleted or reassigned to the newly renamed field. The database will reject a request to delete or rename a data type which is referenced by a field.

Internally most databases maintain the integrity of their meta data as described above. Relational databases in particular go further in providing tools like triggers and stored procedures to developers to maintain the integrity of the content data as well. The present invention uses this feature to provide an environment for the initial development and later adaptation of information systems which ensures the correctness of the system.

The present invention can now use this table field and data type meta data provided by structures in Firebird illustrated in to provide a further list of tables fields and data types as system data in system structures.

The reader will notice that indexes are defined in the table SYS FIELD by the boolean flag fields SYS ASC INDEX and SYS DESC INDEX and that as a consequence there is no need for a separate system table to store this data.

By linking the system data with the Firebird provided meta data this invention can be confident that the tables fields data types or indexes listed as the system data do exist and are defined as listed in the actual database. That this meta data provided by Firebird is available in a structured format consistent with the architecture of the present invention provides the architecture with absolute reliability as shown in which illustrates how the data in system table SYS TABLE maintains integrity with the Firebird meta data provided by RDB RELATIONS with a join on SYS TABLE.SYS NAME and RDB RELATIONS.RDB RELATION NAME which illustrates how the data in system table SYS FIELD maintains integrity with the Firebird meta data provided by RDB RELATION FIELDS with a join on SYS FIELD.SYS NAME and RDB RELATION FIELDS.RDB FIELD NAME which illustrates how the data in system table SYS DATA TYPE maintains integrity with the Firebird meta data provided by RDB FIELDS with a join on SYS DATA TYPE.SYS NAME and RDB FIELDS. RDB FIELD NAME and illustrates how indexes defined in system table SYS FIELD maintain integrity with the Firebird meta data provided by RDB INDICIES and RDB INDEX SEGMENTS with a join on RDB INDEX SEGMENTS.RDB FIELD NAME and SYS FIELD.SYS NAME.

The reader will notice that the definition of system tables but not Firebird meta data structures like SYS TABLE in and SYS FIELD in contain foreign keys. Unless specified otherwise the foreign key references the field with name SYS IDENTITY in the table of the same name as the foreign key field. In the present invention the primary key is always one field with the name SYS IDENTITY. The illustrations also help identify the foreign keys which show a relationship line joining the foreign key to the primary key. Unless specified otherwise the value in the foreign key field must contain a value in the referenced table s primary key or 0. Unless specified otherwise referential integrity between tables is a one to many relationship type.

For example table SYS FIELD has a foreign key field SYS TABLE which references field SYS IDENTITY in table SYS TABLE in a one to many relationship. Table SYS FIELD has a foreign key field SYS DATA TYPE which references field SYS IDENTITY in table SYS DATA TYPE in a one to many relationship. Table SYS FIELD also has a foreign key SYS WIDGET TYPE which references field SYS IDENTITY in table SYS WIDGET TYPE in a one to many relationship. Table SYS WIDGET TYPE is discussed below.

The SYS TABLE and SYS DATA TYPE foreign key references in table SYS FIELD are further controlled by references in the Firebird meta data as illustrated in and which ensure that the field listed in SYS FIELD is actually a field in the table that SYS FIELD.SYS TABLE claims to be a member of and that the field is actually of the type that SYS FIELD.SYS DATA TYPE claims to be.

Integrity is maintained between the present invention s system data and Firebird meta data using procedural SQL in triggers in Firebird such that whenever a table field data type or index in Firebird is added removed or changed a trigger executes and synchronizes the system tables SYS TABLE SYS FIELD and SYS DATA TYPE. Further triggers written in Firebird procedural SQL ensure that data in tables SYS TABLE SYS FIELD and SYS DATA TYPE does reflect the meta data in the tables RDB RELATIONS RDB RELATION FIELDS RDB FIELDS RDB INDICIES and RDB INDEX SEGMENTS.

All other integrity rules unless otherwise specified operating on system application or content data are defined with the present invention s rules which are described below.

The field SYS CAPTION in tables SYS TABLE SYS FIELD and SYS DATA TYPE stores the user friendly name of the object which is displayed in the user interface in contrast to field SYS NAME which stores the internal name of the object.

The first stages therefore in re architecting the initial development and later adaptation of information systems is to provide system data types in which to store system data and to provide system tables and fields to list the tables fields data types and indexes defined in the database. The present invention builds on this foundation as will be described later.

Examples of rules in the traditional architecture are illustrated in . When rules are incorporated into the database and multiple clients and user interfaces for example a desktop client a web server or a web client it is common for that programming logic to be reproduced and written in different computer languages for each environment. For example a validation rule written inside the database may be written in a proprietary procedural SQL language the same validation on a desktop client may be written in C or Basic and either compiled into the application or interpreted by the application. On a web server the same validation may be coded in PHP and in a web client the same validation may be re coded again in JavaScript. In this situation there is the high possibility of subtle differences in logic creeping into the system because of language differences.

Accordingly the present invention resolves these two issues by storing all rules in the database by declaring a rule syntax as XML extensible mark up language and by executing the interpreted rule scripts through the same dynamically linked function libraries. This is illustrated in .

By calling the same dynamically linked function libraries executed from the database and any client or user interface the possibility of subtle differences in logic creeping into the system is substantially reduced. Any difference in logic would then owe its existence to the presence of functions in one environment and absence in another or to different versions of the same functions between environments.

The two potential causes for inconsistency absence of functions and version differences could be eliminated by running the database and all clients and user interfaces on the same machine thereby sharing the same dynamically linked function libraries. This however is not always possible in a client server environment.

The present invention proposes to write as illustrated in a rule interpreter class for the Firebird database engine the database used in the present invention which will be able to load the rule XML described below for the event being executed. The rule interpreter class will not only have access to the transaction context in which the event is being executed but also will be able to call the appropriate functions which are organized into dynamically linked libraries again shown in . list sets of functions that are frequently shipped with most programming tools and shipped with the present invention.

The present invention also proposes to write as illustrated in a rule interpreter class which can be shared by all clients and user interfaces which will be able to load the rule XML described below from the databases and like the rule interpreter class in the database described above will not only have access to the data source described below in which the event is being executed but also will be able to call the appropriate functions which are organized into dynamically linked libraries shown in and .

The sets of functions listed in are designed in the present invention to be callable from the rule interpreter engine used by the database or from the rule interpreter engines used by the clients or user interfaces.

Rules are defined as scripts which comprise variables conditions iterations and functions and the present invention provides two types of functions function wrappers and custom functions.

Function wrappers are scripts that provide direct access to the pre compiled functions shipped with the system by calling them directly. Examples of such pre compiled functions shown in are shipped with most programming tools and in the present invention are organized into dynamically linked function libraries when they need to be called equally by the database and any clients or user interfaces. shows function wrappers as they would be defined in C in comparison with how they are defined in the present invention s XML format which the end user calls in custom functions or in event scripts.

Not all function wrappers call pre compiled functions in dynamically linked libraries. Function wrappers may also call functions defined directly in the database client user interface operating system or any external application. Defining a function directly in the database client or user interface is appropriate when the functionality provided by that function applies only to the database client or user interface. An example may be a function to return the current transaction number in the database or a function to maximize the user interface program.

Custom functions are scripts defined by the end user of the information system. An example of a custom function in the traditionally architecture is shown in and the same function described in present invention s XML format is shown in . Function wrappers and custom functions can be re used in as many other custom functions or event scripts as the user chooses.

The programming paradigm of the present invention like most information systems uses event driven programming where code is executed as a result of for example clicking a button updating a record or receiving an HTTP request. On the occurrence of such events scripts are executed.

Most databases provide events of the type BEFORE INSERT AFTER INSERT BEFORE UPDATE AFTER UPDATE BEFORE DELETE and AFTER DELETE which are executed whenever records are inserted updated and deleted from tables. By calling the proposed rule interpreter from within the database on each of these events with the type of event the sender of the event and the identity of the transaction the interpreter can look up the appropriate event XML script and execute it.

The reason why the same event is executed both on the database and the client or user interface is that executing the event on the database provides assurance that the validation taken as the example here will always be executed thus maintaining the integrity of the data. However there is network latency between the user requesting that some data should be changed on the database and the response from the database that the request has been received and accepted or rejected by the database. To improve the responsiveness the same rule may be applied on the client or user interface to give immediate feedback to the user as to whether the database is likely to accept or reject the input.

User interfaces tend to have a more comprehensive array of possible events as shown in . As the description progresses the reader will see that the present invention provides handlers which allow client and user interface events to be bound to scripts in a manner consistent with the way in which table and field events are bound to scripts as described above.

In the present invention the syntax of function wrappers custom functions and event scripts is defined in XML. An example of a function wrapper was provided in . An example of a custom function is provided in . An example of an event script is provided in and

The next stage therefore in re architecting the design of information systems is to provide functions and scripts in XML format which can be interpreted consistently from the database user interface or client.

From the XML definition of function wrappers custom functions and event scripts the present invention derives a set of data structures in which to store the constituent parts of a rule. This is shown in which illustrates how the constituent parts of a rule script are decomposed and organized into tables and fields which illustrates how events are bound to scripts which illustrates how functions are bound to scripts and which illustrates how arguments used in function wrappers custom functions and event scripts are defined for the scripts. These structures are discussed in more detail below.

Assume from this point in the description that the definition of all system and application tables created will be inserted into system table SYS TABLE and that the definition of all system and application fields created will likewise be inserted into system table SYS FIELD as described above. This means that each of the tables and fields in the set of data structures in which the present invention stores the constituent parts of a rule will be inserted into SYS TABLE and SYS FIELD respectively.

To produce the XML definitions of rules a stored procedure is employed within the database which collects the rule data from the data structures and generates the XML. The rule interpreter built into the database illustrated in can then load this XML parse the XML and execute the script. Similarly the rule interpreter in the clients and user interfaces also illustrated in can also load this XML from the database parse the XML and execute the script.

By decomposing the rules into its constituent parts and storing each part as a discrete entry in the database and imposing integrity constraints the present invention provides the further and more important benefit of ensuring that only those functions which return values of the correct or a compatible type can be used. shows a field defined in an information system whose value is automatically generated. This is often called a formula field. If the data type of the field were defined as a double data type then logically the function which returns the value must return a double or a data type which can be cast to a double. Notice in how the combination of the value of field UNIT COST and the value of QUANTITY can be cast to a double. shows an example of a formula field DATE whose data type DATE is incompatible with the assignment data type which is a DOUBLE. This would result in unpredictable behaviour. Likewise a function may take a series of parameters with each parameter being a specific type as illustrated in . If the data type of a parameter were defined DATE data type then logically the argument value must be a DATE or a value which can be cast to a DATE. It is possible in interpreted languages for an argument in a function to be of a data type incompatible with the data type as defined by the parameter in the function declaration. In such a scenario as illustrated in where the first parameter requires a DATE data type but is inappropriately assigned a DOUBLE data type this would result in unpredictable behaviour. However the present invention removes all possibility of such errors from occurring by imposing integrity constraints.

An important feature of the present invention is that the integrity of the data used to define the rules like all other data is maintained thereby ensuring the correctness of the application. Because a rule script decomposed into its constituent parts with each part stored as a discrete entry in the database is unusual and difficult to achieve the explanation will show how scripts are decomposed where the constituent parts are stored and the integrity constraints that must be applied.

This is illustrated in a more usual way in which shows the script as it is displayed in the user interface and which points out the individual blocks in the script identifying the different condition blocks and the iteration blocks. In there are three blocks with the first block an unconditional block the second block an iteration block and the third block a conditional block.

In the interpreter if SYS CONDITION is non zero then the condition referenced will be executed and if SYS ITERATION is non zero then the iteration referenced will be executed.

A condition as defined in table SYS CONDITION shown in may be one of two basic types. The first type is a condition in which there are tests which must evaluated and where the result of the evaluation determines whether the condition is passed. Such conditions may have quantifiers like if all the following are true or if any of the following is true . The second basic type of condition has no tests and is always executed. This is very similar to a final else condition and in the present invention this is how it is executed. SYS QUANTIFIER has a value corresponding to the type of condition. In the present invention a value of 0 in SYS QUANTIFIER indicates that the condition has no tests and will always be executed.

This is illustrated in a more usual way in which shows the script as it is displayed in the user interface and which points out the conditions in the script. The reader will also see the else condition in which is common to scripts.

When SYS QUANTIFIER has a value other than 0 SYS ELSE CONDITION must be non zero. As can be see from SYS ELSE CONDITION is a foreign key pointing back to SYS CONDITION. The meaning of this self referencing is to identify the next condition in the block. The final else condition has a 0 in the SYS ELSE CONDITION field. This is illustrated in a more usual way in . Integrity rules not only ensure the rules described above but also that circular references do not occur.

Like modern programming languages in the interpreter the first condition to return a value of true after executing the tests described later is the condition whose statements also described later will to be executed.

An iteration as defined in table SYS ITERATION shown in contains a foreign key reference to the dataset as defined in table SYS DATA SET. The iteration is executed in the interpreter as a loop over the dataset referenced. helps to illustrate an iteration over a dataset.

This is illustrated in the more usual way in which shows a series of tests as they are displayed in the user interface and which identifies the types of tests in the condition. Field SYS SEQUENCE specifies the order in which the tests must be performed.

In the interpreter if SYS SUBFUNCTION is non zero then the function referenced will be executed and the boolean test value will be returned to the condition referenced in SYS CONDITION and if SYS SUBCONDITION is non zero then the condition referenced will be executed and the boolean result of that condition will be returned to the condition referenced in SYS CONDITION.

This is illustrated in a more usual way in which shows a statement as it is displayed in the user interface within the context of a condition or an iteration. Field SYS SEQUENCE specifies the order in which the statements must be performed.

This is illustrated in a more usual way in which shows three statements a function a condition and an iteration within the context of a condition as they are displayed in the user interface. Field SYS SEQUENCE specifies the order in which the statements must be performed.

In the interpreter if SYS SUBFUNCTION is non zero then the function referenced will be executed if SYS SUBCONDITION is non zero then the condition referenced will be executed and if SYS SUBITERATION is non zero then the iteration referenced will be executed.

In the paragraphs above the explanation has stated that a function will be executed by the interpreter. A function whether it is a function wrapper or a custom function has a list of parameters as illustrated in . Each parameter lists only the data type and its position. This is shown in where table SYS FUNCTION PARAMETER has a foreign key field SYS INPUT TYPE which stores the data type and a field SYS SEQUENCE which stores the position of the parameter in the parameter list. Rules maintain the integrity of the data by ensuring that the value in field SYS INPUT TYPE references a data type as listed in table SYS DATA TYPE and that each parameter in the list of parameters for a function has a unique sequence number as identified by SYS SEQUENCE.

When a function is called the parameters are populated by argument values. This is illustrated in where the parameters of function definitions need to be populated by argument values in the two callable instances of functions. Individual function arguments are listed in table SYS FUNCTION ARGUMENT shown in . In table SYS FUNCTION ARGUMENT field SYS FUNCTION INSTANCE is a foreign key to the callable instance of the function in which the argument is used. Field SYS FUNCTION PARAMETER is a foreign key which identifies the parameter that the argument represents. The value of each argument in each function instance is defined as a reference in table SYS REFERENCE shown in .

Integrity rules ensure that the data type of the reference as listed in table SYS REFERENCE is compatible with the data type of the parameter as listed in field SYS INPUT TYPE of table SYS FUNCTION PARAMETER. This resolves the issue of compatible data types which were described above and illustrated in and .

Fields are listed in the system table SYS FIELD. Field SYS TABLE in table SYS FIELD identifies the name of the table of the field referenced in SYS REFERENCE. Context identifies the record that provides the value of the argument. Relationship rules between tables provide the context. The relationships provide a list of the available tables and the links between these tables. With the available links context is able to navigate the database table structure to access records in tables related to the record being manipulated. This is illustrated in . For example if an event executing on ORDER where SYS IDENTITY 4 needs to access the value of the field DISCOUNT in table CUSTOMER then context is aware of the relationship between tables ORDER and CUSTOMER and knows that the current ORDER record is related to the record in CUSTOMER where CUSTOMER.SYS IDENTITY 1 by the foreign key reference in ORDER.CUSTOMER. Similarly if an event executing on ORDER where SYS IDENTITY 4 needs to sum up the value of the fields QUANTITY and UNIT COST in table ORDER LINE then context is aware of the relationship between tables ORDER and ORDER LINE and knows that the current ORDER record is related the list of records in ORDER LINE where ORDER LINE.ORDER 4 which in references three records where ORDER LINE 5 6 and 7. Events and the sender argument of the event are described below.

Literal values are stored in the system table SYS LITERAL. Table SYS LITERAL is described in . It stores the data type of the value in field SYS DATA TYPE which is a foreign key referencing table SYS DATA TYPE and the user friendly name in field SYS CAPTION. The value of the literal value is stored in fields SYS STRING SYS NUMBER or SYS BINARY. If the data type of the literal value is a type of string then the value is stored in field SYS STRING and fields SYS NUMBER and SYS BINARY are left empty. If the data type of the literal value is a type of number then the value is stored in field SYS NUMBER and fields SYS STRING and SYS BINARY are left empty. If the data type of the literal value is a type of binary then the value is stored in field SYS BINARY and fields SYS NUMBER and SYS STRING are left empty. shows some example literal values.

Variable values are stored in the system table SYS VARIABLE. Table SYS VARIABLE is described in and stores the data type of the variable in field SYS DATA TYPE which is a foreign key referencing table SYS DATA TYPE the internal name of the variable in field SYS NAME and the user friendly name in field SYS CAPTION. shows some example variables which are programmatically available within the Firebird database.

Function return values are dynamically calculated when a function is executed. shows field SYS OUTPUT TYPE of table SYS FUNCTION DEFINITION which is a reference to the data type of the function s return value. This is also illustrated in .

To perform any useful work a script must call compiled functions. While function wrappers call compiled functions directly custom functions must call compiled functions indirectly. The task of the interpreter is to parse the function wrapper and custom functions and to call the compiled functions as described in . The library and name of the compiled function is stored in fields SYS LIBRARY and SYS ENTRY POINT in table SYS FUNCTION DEFINITION which is illustrated in A C. With this information the interpreter is able to call the interpreted function passing the correct arguments and accepting the appropriate return value data type.

Custom functions differ from function wrappers in that they comprise a definition which in turn comprises a collection of blocks as illustrated in where table SYS BLOCK has a foreign key reference SYS FUNCTION DEFINITION to the function definition of which they are a member as listed in table SYS FUNCTION DEFINITION. Individual blocks are executed as described above. While the same function may appear as multiple instances in multiple events and custom functions the definition of those function instances is identical.

Having described functions in detail above the explanation of events follows an identical logic to that of functions as illustrated in with the exception that unlike functions there are no event wrappers to compare to function wrappers. Instead all events are customized instances which cannot be re used in other event instances. illustrates that table SYS BLOCK contains a foreign key reference field SYS EVENT INSTANCE to the event instance of which they are a member as listed in table SYS EVENT INSTANCE rather than a function definition as explained about functions above.

Because the present invention uses event driven programming paradigm this means that all scripts are executed as a result of some event as described in . Different types of events have different parameters as is common in event driven applications. One noteworthy feature of events is the parameter which identifies the sender of the event and the parameter which identifies the identity of the transaction both of which contribute to context and acid compliance Atomicity Consistency Isolation and Durability.

Other than these differences the explanation of events in the present invention follows the same path as that of functions and the reader is directed to that explanation for an understanding of event handling.

The modified architecture so far demonstrates that while information systems differ in the types of their rules all information systems use rules. The present invention therefore discards the concept of embedding or compiling rule scripts in the database and the clients or user interfaces as illustrated in in preference for rules decomposed and stored as data in the database as shown in . By providing a rule interpreter to the database which can load and execute rules the present invention nudges the database file from an application specific file with rules defined in procedural SQL and embedded in the database to a generic database where only rule data differs. By providing rule interpreters to the client and user interface programs which can load and execute rules the present invention nudges the clients and user interfaces from an application specific client with rules embedded in the client and user interface to a generic information system client or user interface program where the application specific logic is stored in the database and loaded from the database when the client or user interface program connects to the database. That it is unusual to see rule scripts fully decomposed is the reason the description went to such lengths to describe the structures in which the discrete entries are stored and the validations imposed.

By decomposing the rules into discrete values in the database and applying integrity checking to each part of the rules such that the rules can be assured of correctness the present invention so far ensures that at least the rules can be assured of correctness irrespective of whatever changes the system is subjected to.

Defining data sets in the database is appropriate for static data sets and defining data sets in the client or user interface is appropriate for dynamic data sets. Both static and dynamic data sets are useful in information systems.

Given that data sets can reasonably be defined in the database or the client or user interface the issue remains that the correctness of a data set is unknown until runtime if it is defined in the client or user interface and in some databases even when it is defined in the database itself.

To resolve this issue the present invention proposes that instead of defining a data set as a block of text as shown in which is parsed out into its constituent parts at runtime by the database API the definition of a data set be decomposed into its constituent parts with each part stored as a discrete entry in the database.

The system field SYS FILTER in system table SYS DATA SET is a foreign key to the primary key system field SYS IDENTITY in system table SYS CONDITION described above in rules. This is because a filter is a condition and like other conditions the results of the tests specified in table SYS TEST identify which rows in the source table or source data set qualify for inclusion in the data set.

An entity defined in SYS ENTITY identifies the table or data set that the data is to be taken from. The source of the entity may be either a table defined in table SYS TABLE or a data set defined in table SYS DATA SET. The system field SYS SOURCE TABLE in system table SYS ENTITY is a foreign key to the primary key in table SYS TABLE and the system field SYS SOURCE DATA SET in system table SYS ENTITY is a foreign key to the primary key in table SYS DATA SET. If the source of the data is a table then SYSSOURCE DATA SET is set to 0. If the source of the data is a data set then SYS SOURCE TABLE is set to 0.

A column defined in the system table SYS COLUMN identifies the field column or expression that provides the data. The source of the column may be a field defined in SYS SOURCE FIELD which is a foreign key to the primary key in table SYS FIELD the source may be a column defined in SYS SOURCE COLUMN which is a foreign key to the primary key in table SYS COLUMN or the source may be an expression defined in SYS SOURCE EXPRESSION which is a foreign key to the primary key in SYS FUNCTION INSTANCE described above. If the source of the data is a field then SYS SOURCE COLUMN and SYS SOURCE EXPRESSION are set to 0. If the source of the data is a column then SYS SOURCE FIELD and SYS SOURCE EXPRESSION are set to 0. If the source of the data is an expression then SYS SOURCE FIELD and SYS SOURCE COLUMN are set to 0.

If the source of an entity is a table then the source of each column in that entity must be either a field or an expression. If the source of an entity is a data set then the source of each column in that entity must be either a column or an expression. Integrity checks enforce these rules.

A join between entities defined in the system table SYS JOIN identifies the two entities comprising the join and the two columns in each of those entities that are joined. The system field SYS LEFT ENTITY in system table SYS JOIN is a foreign key to the primary key in system table SYS ENTITY and the system field SYS RIGHT ENTITY in system table SYS JOIN is also a foreign key to the primary key in system table SYS ENTITY. The system field SYS LEFT COLUMN in system table SYS JOIN is a foreign key to the primary key in system table SYS COLUMN and the system field SYS RIGHT COLUMN in system table SYS JOIN is also a foreign key to the primary key in system table SYS COLUMN. The column defined in field SYS LEFT COLUMN of table SYS JOIN must be a member of the entity defined in field SYS LEFT ENTITY of table SYS JOIN as listed in table SYS ENTITY. The column defined in field SYS RIGHT COLUMN of table SYS JOIN must be a member of the entity defined in field SYS RIGHT ENTITY of table SYS JOIN as listed in table SYS ENTITY. The field SYS TYPE identifies the type of join which might be an inner join a left outer join a right outer join a union or one of the many other types of joins. Rules ensure that the integrity described above is maintained.

Before a data set can be run the SQL needs to be generated from the definition stored in the data structures. A stored procedure in the database is used to assemble the constituent parts of the data set and generate the SQL.

Where a data set is required by a rule script in particular one which comprises an iteration then the SQL generated by the stored procedure can then executed by the interpreter.

The present invention abandons the concept of static SQL defined in the database and dynamic SQL mixed in with programming code in the client and user interface and in their place provides a data set class in the clients and user interfaces which loads the SQL from the database. This SQL is passed back to the database API as the data set definition which returns a set of data to the clients and user interfaces in accordance with the SQL request.

This provision of a class in the user interface or client which can create instances of objects whose customizable properties are loaded from values loaded from the database is a core architectural characteristic of the present invention and illustrated in and .

The definitions of data sets are no longer stored optionally in the database and the clients or user interfaces. Instead the definitions are always stored in the database. Further that the storage of a data set definition in the database is no longer stored as a block of text as shown in but decomposed into its constituent parts with each part stored as discrete entries in the database as illustrated in . By imposing integrity constraints the architecture can ensure the correctness of the data sets irrespective of whatever changes the system is subjected to.

A stored procedure exists in the database which assembles the SQL from the structures. If the script interpreter built into the database needs a data set in order to execute a rule then the interpreter can load the generated SQL which can then be executed. Finally there exists a data set class in the clients and user interfaces designed to load not only the constituent parts but also the generated SQL of that dataset from database which can be used in a call back to the database API which the database returns as a set of data in accordance with the SQL request called the data set.

The reader will be familiar with the concepts of object orientated programming with its classes and objects and with the concepts of database design with its tables and records. An important feature of the present invention is that the classes in the client and user interface have a correlation to the tables in the database. The present invention distinguishes customizable properties from public properties of object orientated classes in that customizable properties are designed to be populated with data loaded from the database whereas public properties are designed to be accessible by other classes.

This is illustrated in which shows a table with fields to store the customizable properties of PushButton object instances. The reader will note the correlation between the table SYS PUSHBUTTON and the class PushButton and in particular the correlation between the fields in table SYS PUSHBUTTON and the public properties of class PushButton. shows how records in table SYS PUSHBUTTON correlation to object instances of the class PushButton where customizable properties are loaded from the table and set in the object instances. In such customizable properties include the caption and icon.

By providing a data set class in the clients and user interfaces which can load any SQL statement the present invention nudges the clients and user interfaces from an application specific client to a generic information system client program where the application specific logic is stored in the database and loaded from the database when the client program connects to the database. The completed client and user interface program shown in is compared with the traditional client and user interface application shown in .

The list of widgets available in the user interface is stored in the database in table SYS WIDGET TYPE illustrated in . Each record in SYS WIDGET TYPE stores the caption the icon of the widget type and more importantly the class name in which that widget type is defined and the library in which the class is made available if the widget definition exists in a library plugged into the user interface.

The user interfaces of most information systems comprise form menubar and toolbar features. The list of forms menubars and toolbars available in the user interface are stored in the tables SYS FORM SYS MENU BAR and SYS TOOL BAR respectively. Individual instances of forms of class Form menubars of class MenuBar and toolbars of class ToolBar available in the user interface load their customizable property values from records in the tables SYS FORM SYS MENU BAR and SYS TOOL BAR respectively. This is illustrated in .

One application can contain many top level windows with each top level window having a separate menu bar. Each menu bar is listed in SYS MENU BAR. Each menubar can contain many menus. SYS MENU therefore contains a foreign key field SYS MENU BAR which references the menubar which the menu belongs to. Referential integrity rules ensure that a menu does belong to an existing menu and that if a menubar is deleted from SYS MENU BAR that the menus listed in SYS MENU and which belong to the menubar being deleted are in turn deleted ensuring that dangling menus never exist.

The list of menus available in the user interface are stored in the database table SYS MENU. Each record in the table SYS MENU stores the customizable properties for the individual object instances of class Menu shown in to be displayed in the user interface.

Having in the previous paragraphs described widgets separately from menus toolbars and forms the description will now describe how these are combined. illustrates a menu which contains a number of widgets. shows a toolbar which also contains a number of widgets. likewise shows a form which contains a number of widgets.

The table SYS MENU WIDGET illustrated in stores the list of widgets which are contained on individual menus. The foreign key SYS WIDGET is a reference to the widget in table SYS WIDGET that appears on the menu identified by the field SYS MENU which is a foreign key referring to the menu in Mable SYS MENU. The field SYS SEQUENCE specifies the order that the widgets appear on the menu.

The table SYS TOOL WIDGET illustrated in stores the list of widgets which are contained on individual toolbars. The foreign key SYS WIDGET is a reference to the widget in table SYS WIDGET that appears on the toolbar identified by the field SYS TOOL BAR which is a foreign key referring to the toolbar in table SYS TOOL BAR. The field SYS SEQUENCE specifies the order that the widgets appear on the toolbar.

The table SYS FORM WIDGET illustrated in stores the list of widgets which are contained on individual forms. The foreign key SYS WIDGET is a reference to the widget in table SYS WIDGET that appears on the form identified by the field SYS FORM which is a foreign key referring to the form in table SYS FORM. The fields SYS LEFT SYS TOP SYS WIDTH and SYS HEIGHT specify the position of the widget on the form.

In the architecture of the present invention the customizable properties of widgets are no longer stored in the user interface but in the database. This does not mean that all the properties of widget instances need be stored in the database. It is only those properties which need to be customized by the application that need be stored in the database. These customizable property values of each widget type instance are stored in fields in the database and there exists widget classes in the user interface designed to load the customizable properties from the database and create customized object instances of those widgets as illustrated in and

Likewise the customizable properties of forms menubars and toolbars are no longer stored in the user interface but in fields in the database and there exists form menubar and toolbar classes in the user interface designed to load the customizable properties from the database and create customized objects instances of those forms menubars and toolbars as illustrated in and

The customizable properties of menus on menubars and widgets on menus widgets on toolbars and widgets on forms are no longer stored in the user interface but in fields in the database and there exists a menu class in the user interface designed to load the customizable properties from the database and create customized object instances of those menus as illustrated in and

The modified architecture so far demonstrates that while information systems differ in the number and design of their widgets forms menubars menus and toolbars all information systems use widgets forms menubars menus and toolbars. The present invention therefore discards the concept of embedding the definition of widgets forms menubars menus and toolbars in the user interface in preference for decomposing the customizable properties and storing them as data in the database. By providing widget form menubar menu and toolbar classes in the user interface which can load their custom property definitions from the database the present invention nudges the user interface from an application specific client to a generic information system client program where the application specific logic is stored in the database and loaded from the database when the user interface program connects to the database. The completed user interface program shown in is compared with the traditional user interface application shown in .

By imposing rules on the structures the present invention makes it easy to identify dependencies and to conclusively verify the correctness of an application such that for example a column in the dataset entity providing the source of data for a widget will always exist irrespective of whatever changes the system is subjected to.

The architecture of the present invention can be extended to provide further functionality. In an information system such extended functionality may include specialized widgets or an e mail module which can be plugged in. If extensions are present then these operate in the same way that shipped features operate.

A possible specialized widget that might be plugged in might be one that provides the display of measurements in feet and inches and we might call this specialized widget type Feetinch. To integrate this widget into the proposed architecture five steps need to be performed.

The first step is to make the FeetInch widget available to any applicable user interface program because only the user interface is able to display widgets.

This generally means making the code in which the widget is defined into a dynamically linked library that the user interface program can load. The second step is to create a table in the database similar to that shown in which provides a foreign key to the table SYS WIDGET and lists all customizable properties as fields of a data type appropriate to hold the value and a foreign key field to SYS EVENT INSTANCE for each of the customizable events. The third stage is to add entries to SYS EVENT DECLARATION and SYS EVENT PARAMETER as illustrated in to define the number and order of parameters that each customizable event comprises. The fourth stage is to add a record into table SYS WIDGET TYPE which provides a user friendly name and icon for the widget and the path to the dynamically linked library in which the class is defined as well as the name of the class in the dynamically linked library as illustrated in . The fifth and final task is to load into the rule structures all the rules required to enforce integrity of the Feetlnch widget s data. As explained above extensions are integrated consistently into the architecture of the present invention.

Until this point the description has only briefly mentioned content data and user defined rules. The description will now explain the steps the user must take to add their own application table user defined data type a form to edit their content data and a button to execute a custom script. While the linear order in which the description may be logical it is not proposed that this will necessarily be the sequence followed in the actual development of the information system which often follows a more iterative pattern.

As explained above application structures are defined as structures which are specific to a type of information system. In a basic order entry system which exhibits all the core features of an information system the user might require application tables and fields to store product customer order and the individual order line data.

The first stage is to establish some application specific data types which do not exist in the database. Let us assume that the application requires a specialized data type not currently available in the database to store part number data. This new data type shall have name Part Number and the caption Part Number .

To create the new data types the user must issue DDL commands to the database for each new data type as shown in . In Firebird these statements will cause the database to add records to the meta data table RDB FIELDS for each new data type as shown in . As explained above the present invention installs a trigger on table RDB FIELDS such that an insert into RDB FIELDS will cause the database to add a record to table SYS DATA TYPE an update RDB FIELDS will cause the database to update the related record in table SYS DATA TYPE and a delete from RDB FIELDS will cause the database to delete the related record in table SYS DATA TYPE. The structure and contents of table SYS DATA TYPE is shown in .

The second stage is to create four tables which are specific to the application. Let us assume that the application requires a table to store products another to store customers another to store orders and a table to list the individual lines in an order. For each new table to be created the user must issue a DDL command to the database an example of which is shown in . In Firebird these statements will cause the database to add a record to the meta data table RDB RELATIONS for each new table as shown in . For each field added a record will be added to the meta data table RDB RELATION FIELDS as shown in . The structure and contents of table SYS TABLE is shown in and the structure and contents of table SYS FIELD is shown in .

As explained above the present invention installs a trigger on table RDB RELATIONS such that an insert into RDB RELATIONS will cause the database to add a record to table SYS TABLE an update RDB RELATIONS will cause the database to update the related record in table SYS TABLE and a delete from RDB RELATIONS will cause the database to delete the related record in table SYS TABLE. Likewise a trigger is installed on table RDB RELATION FIELDS such that an insert into RDB RELATION FIELDS will cause the database to add a record to table SYS FIELD an update RDB RELATION FIELDS will cause the database to update the related record in table SYS FIELD and a delete from RDB RELATION FIELDS will cause the database to delete the related record in table SYS FIELD.

For each table created a trigger must be installed for each of the events that the database makes available. In the case of Firebird six events are available. These are BEFORE INSERT AFTER INSERT BEFORE UPDATE AFTER UPDATE BEFORE DELETE and AFTER DELETE which are executed whenever records are inserted updated and deleted from tables. Code is added to each trigger to call the proposed rule interpreter with the type of event the sender of the event and the identity of the transaction. An example is illustrated in .

The next stage is to change the field SYS CAPTION in table SYS DATA TYPE to a user friendly name if required using a DML data manipulation language commands for each new data type as shown in . The user friendly names of tables can be changed by updating the value of field SYS CAPTION in table SYS TABLE using a DML command for each new table as shown in . Likewise the user friendly names of fields can be changed by updating the value of field SYS CAPTION in table SYS FIELD using a DML command as shown in

Indexes must be added using DDL statements as shown in . As explained above the present invention installs a trigger on table RDB INDICES and RDB INDEX SEGMENTS such that an insert into update on or delete from RDB INDICES and RDB INDEX SEGMENTS will cause the database to update the related record to table SYS FIELD by setting the values of fields SYS ASC INDEX and SYS DESC INDEX.

Relationships between tables can be implemented by updating the appropriate rule structures as illustrated in . Validation rules on fields can similarly be implemented by updating the appropriate rule structures as illustrated in .

If a default widget type needs to be assigned to each new field listed in table SYS FIELD then the foreign key SYS WIDGET TYPE can be edited and a value which exists as the primary key of table SYS WIDGET TYPE entered into the field.

The next series of steps will provide the application with a form with which to edit the content data and a button to automate some application specific process. However before the form can be defined some data sets and a data source will need to be established.

The manner in which data sets are defined in the architecture of the present invention has been discussed earlier and illustrated in . Creating a new data set is a matter of manipulating those data set structures with DML commands. Data sources on the other hand have not been explained.

A data source is used to combine multiple data sets to display on one form in a master detail arrangement. The structure of table SYS DATA SOURCE is illustrated in . Table SYS DATA SOURCE has a foreign key field SYS MASTER DATA SET and another foreign key field SYS DETAIL DATA SET which references data sets listed in SYS DATA SET. Field SYS MASTER COLUMN and SYS DETAIL COLUMN are foreign keys which reference columns in SYS COLUMN. A rule ensures that the column referenced in SYS MASTER COLUMN is a member of the data set referenced in SYS MASTER SET and that the column referenced in SYS DETAIL COLUMN is a member of the data set referenced in SYS DETAIL SET. Table SYS DATA SOURCE also has a foreign key field SYS FORM which references a form listed in SYS FORM and which determines which form a data source is the source of data for. Consistent with the present invention if a data set is deleted from table SYS DATA SET referential integrity rules will ensure that the data set reference in SYS DATA SOURCE is also deleted. If a form is deleted from SYS FORM referential integrity rules will ensure that all the records in SYS DATA SOURCE referencing that form are also deleted.

Taking the example of a basic order entry system four data sets may be defined with each data set loading all the fields from the four application tables with captions Customer Products Order and Order Lines . The data source may be a combination of these tables organized into a master detail arrangement. This can be visualized in .

To create the form the user inserts a record into table SYS FORM with a caption like Customer Orders . For each widget to appear on the form the user must add a record to the table SYS WIDGET and add corresponding entries to the tables for each widget type as shown in . If the widget is designed to display data from the database then the field SYS COLUMN in table SYS WIDGET must specify a column in the form s data source which provides the data. If the widget is a non data widget like a push button then the field SYS COLUMN can be set to 0. As described above SYS FORM WIDGET must be completed with the list of widgets to appear on the form.

Validation rules assigned to fields in the database in table SYS FIELD field SYS ON VALIDATE are also executable on the client. The initiation rules assigned to fields in the database in table SYS FIELD field SYS ON INITIATE are valid only on a user interface and provide what is commonly known as a default value and like validation rules are executable on the user interface.

For widgets like a push button which is not a field editor on click event rules must be defined in the table SYS PUSHBUTTON field SYS ON CLICK as described above. If the push button is to appear as a widget on the form in a menu and on a toolbar then tables SYS FORM WIDGET SYS MENU WIDGET and SYS TOOL WIDGET must be completed as described above.

In the present invention the user executes the user interface program with the architecture as shown in and connects to a database with the architecture also shown in . On connection to the database the client or user interface programs loads the customizable properties events and scripts from the database and with classes in the clients or user interfaces generates object instances with those properties thereby constructing the application in the knowledge that the application is assured of correctness. It is not relevant whether the customizable properties events and scripts need be loaded in their entirety immediately on connecting to the database or whether the customizable properties events and scripts should be loaded from the database as they are needed.

The reader might have noticed that while the architecture of the present invention maintains the integrity of the system and ensures the correctness of the application heavy demands are placed on the user in terms of executing valid DDL and DML statements. The description will now address the issue of making the initial development and later adaptation of the application simple quick and error free using so called drag and drop and point and select user interfaces.

The traditional architecture of information systems was illustrated in and makes the initial development and later adaptation of information systems time consuming and error prone because it does not make it easy to identify dependencies or to conclusively verify the correctness of an application except by testing every possible combination of behaviour at run time. That traditional design was methodically re architected one step at a time until the architecture proposed by the present invention is revealed in . This new architecture not only accelerates the initial development and later adaptation of information systems but also removes any possibility for error makes dependencies easy to determine and provides within its design the ability to conclusively verify the correctness of an application without having to test every possible combination of behaviour at run time.

