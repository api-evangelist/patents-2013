---

title: Known good code for on-chip device management
abstract: In one embodiment, a processor comprises a programmable map and a circuit. The programmable map is configured to store data that identifies at least one instruction for which an architectural modification of an instruction set architecture implemented by the processor has been defined, wherein the processor does not implement the modification. The circuitry is configured to detect the instruction or its memory operands and cause a transition to Known Good Code (KGC), wherein the KGC is protected from unauthorized modification and is provided from an authenticated entity. The KGC comprises code that, when executed, emulates the modification. In another embodiment, an integrated circuit comprises at least one processor core; at least one other circuit; and a KGC source configured to supply KGC to the processor core for execution. The KGC comprises interface code for the other circuit whereby an application executing on the processor core interfaces to the other circuit through the KGC.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09058163&OS=09058163&RS=09058163
owner: Advanced Micro Devices, Inc.
number: 09058163
owner_city: Sunnyvale
owner_country: US
publication_date: 20131113
---
This application is a divisional of U.S. patent application Ser. No. 11 957 930 filed on Dec. 17 2007. The above application is incorporated herein by reference in its entirety.

This invention is related to the field of processors and computer systems and more particularly to the use of known good code in such systems to enable processor architecture extensions control on board devices and other uses.

Processors are designed to execute instructions defined in an instruction set architecture ISA . The ISA defines the instructions how they are encoded and what operations occur when they are executed. The ISA generally also defines the various modes of operation of the processor and other information that a programmer may require in order to successfully code a program for the processor to accomplish the desired operation. In other words the ISA is essentially a description of how the processor operates when provided with an instruction stream to execute.

Because the programmer relies on the processor to operate as specified in the ISA modifications to the ISA must be made carefully and typically with significant input from both programmers or software companies and the processor designers or processor manufacturers . The processor must implement the ISA modifications in hardware to ensure that the required behavior is provided by the processor. Thus the definition of the changes must be carefully described and agreed upon since a new hardware generation of the processor will be needed to implement the changes. Subsequent modifications would require still further hardware generations.

In another embodiment an integrated circuit comprises at least one processor core at least one other circuit and a Known Good Code KGC source configured to supply KGC to the processor core for execution. The KGC comprises interface code for the other circuit whereby an application executing on the at least one processor core interfaces to the at least one other circuit through the KGC.

While the invention is susceptible to various modifications and alternative forms specific embodiments thereof are shown by way of example in the drawings and will herein be described in detail. It should be understood however that the drawings and detailed description thereto are not intended to limit the invention to the particular form disclosed but on the contrary the intention is to cover all modifications equivalents and alternatives falling within the spirit and scope of the present invention as defined by the appended claims.

The description below refers to the use of Known Good Code KGC to implement architectural modifications for a processor in a flexible fashion e.g. by emulating the modifications via KGC execution . Additionally the description below also refers to other uses of KGC. Prior to describing these uses an overview of KGC is provided.

Generally KGC may refer to code that is protected from unauthorized modification throughout its lifetime and that is provided from an authenticated entity. The authenticated entity may be an entity that is known to the manufacturer of the processor as being trustworthy for example. The KGC may be protected from modification by providing the code in non modifiable storage where the communication mechanism between the storage and the processor is protected in some fashion. Alternatively the KGC may be provided in modifiable or non protected storage but may be cryptographically authenticated prior to execution.

The KGC may be executed in a secure execution computing environment SECE . An SECE may be a computing environment in which the code KGC and associated data cannot be modified or inspected by other code executing on the computer. The SECE may be created by processor hardware e.g. at power up or may be created by software that executes soon after startup to create the SECE and place the KGC in the SECE. Examples of an SECE may include for example the microcode engine in a processor a processor that loads KGC from a local secure non volatile memory into instruction and data caches of the processor and locks the code and data in the caches and an embedded processor or other execution engine that executes KGC out of a local non volatile memory and communication interfaces if any to other devices are either authenticated authorized and possibly encrypted or are physically protected e.g. within a multi chip module . Where appropriate for clarity KGC may be referred to as native KGC if it is executed by the same processor that executes other code and non native KGC if it is executed by a different processor such as an embedded processor. If the term KGC is used without the native or non native label then the context is unambiguous or either native or non native KGC could be used in that context.

If the processor is coupled directly to the KGC source via a protected channel and the KGC source is change protected i.e. the KGC source cannot be changed by any unauthorized entity the cryptographic authentication unit may be eliminated. The authorized entities may include the entity that created the KGC and in some cases the manufacturer of the processor . Thus the KGC source may comprise any computer accessible storage device.

If the processor is not directly coupled to the KGC source via a protected channel the KGC is subject to unauthorized modification either in that source or during transfer to the change protected memory . The cryptographic authentication unit may authenticate the KGC to ensure that no such modification has occurred. For example the cryptographic authentication unit may use a root of trust for verification RTV from the processor to authenticate the KGC. Any authentication scheme may be used in various embodiments.

The authenticated KGC is stored in the change protected memory for fetching over the protected channel by the processor . In some embodiments the channel from the KGC source to the change protected memory may be protected and the KGC source may be change protected and thus no cryptographic authentication may be required. Such embodiments may be implemented if the change protected memory provides lower latency access than the KGC source for example or provides some other benefit besides the change protection e.g. lower power concurrent access in a multiprocessor system in which each processor has a local change protected memory or shares a change protected memory with a subset of the processors etc. .

Generally the change protected memory may be any sort of memory that restricts or eliminates the ability to change the contents of the memory . Specifically the change protected memory may restrict the ability to change its contents to only those authorized to do so. The change protected memory may be physically isolated in such a way that only an authorized entity can change the contents or may be protected in some other fashion e.g. locking into a cache memory .

The non volatile memory may have various implementations. For example the non volatile memory may be a read only memory ROM or may be a battery backed RAM or solid state memory. In other embodiments the non volatile memory may be a combination of memories e.g. a ROM or other non volatile memory and cache memory to which the KGC is loaded and locked . In cases in which the KGC is loaded into the cache and locked into the cache other mechanisms may also be implemented e.g. the locked entries may not be snooped for coherency purposes preventing observation of the code data via coherence mechanisms test ports and other access points that are not part of the standard cache lookup may be disabled from accessing the locked entries etc. .

The memory may be the basic input output system BIOS memory in a computer system or may be another non volatile memory that is included in the system.

Because KGC is provided from an authenticated trusted source and is protected from unauthorized modification KGC may be trusted by the processor manufacturer. Accordingly KGC may be used to implement architectural modifications that have not yet been implemented in processor hardware. KGC implemented architectural modifications may permit users e.g. code writers and computer systems that include the processor to use architectural extensions before they have been committed to hardware or use architectural deletions after the deletions have been committed to hardware .

For example the architectural extensions e.g. new instructions new functionality for existing instructions and their execution environment new accelerators or other functional blocks within the processor or closely coupled to the processor etc. may be implemented in KGC before they are implemented in hardware. If any problems in the definition of the architectural extensions are detected while they are implemented via KGC the problems can be corrected before the extensions are committed to hardware e.g. by changing the extension itself . Expected benefits of the extension e.g. higher performance lower power consumption etc. can be estimated using the KGC implementation. The extension may subsequently be committed to hardware with higher confidence. Additionally if a competitor using the same instruction set architecture introduces new features the KGC may be used to implement the features and thus allow rapid following of a competitor s changes.

For architectural deletions e.g. deletion of instructions that are no longer widely used or believed to be no longer widely used or deletion of legacy modes of operation that are no longer needed or believed to be no longer needed the KGC may be used to implement the deleted functionality. If the functionality is still in use in legacy code for example the legacy code will still operate correctly albeit with lower performance. Accordingly deletions may be implemented with the confidence that any residual use of the deleted functionality will still work properly.

To use KGC to implement architectural modifications a mechanism to transition to KGC execution may be implemented. The mechanism may include the processor detecting that currently executing code makes uses of the architectural modification and causing the KGC to be executed in response to the detection. The currently executing code will be referred to herein as a user program although the program may be executing as privileged code e.g. the operating system or other privileged code . The transition occurs transparent to the user program and thus the architectural extension or deletion may be emulated for the user program.

The mechanism may include a programmable map that can be programmed with data usable by the processor to detect the architectural modifications. The data programmed into the map may vary depending on how the modifications are detected. For example in one embodiment illustrated in the data may comprise all or a portion of the instruction s encoding e.g. opcode opcode modifiers operand fields etc. . The data may also include various mode indications from one or more configuration control registers that indicate a current operating mode of the processor. The data may still further include an address or data generated during execution of the instruction such as the embodiment illustrated in . The data may include any combination of the instruction encoding and data address generated during execution and or any other event that may occur during execution e.g. exception a particular type of exception interrupt a particular type of interrupt etc. . The programmable map may be any type of storage or combination of storage e.g. registers addressable by instructions executed by the processor a memory array etc. .

The user program comprises a stream of instructions such as instructions I I I etc. as shown in . Generally the instructions I I I I I and I are instructions defined in the instruction set architecture implemented by the processor referred to as macro instructions . One of the instructions New Inst in may be a newly defined instruction according to the architectural modifications implemented by the KGC. That is the instruction may be undefined in the architecture as implemented in the processor hardware. If allowed to execute the instruction would cause an exception on the processor . Alternatively the instruction may be previously defined but may use new functionality that is part of the architectural modification emulated by the KGC. The processor may include a pre execute stage mapping arrow to the KGC for the instruction preventing the exception if any and causing the KGC to be fetched and executed. The transition to KGC illustrated by the arrow may also enable the KGC state so that it is visible to the executing instructions within the KGC. In some cases the processor may elevate the privilege level for execution of KGC to ensure that KGC is able to implement its specified function but may also ensure that any events that would cause an exception for the user program and are not needed for KGC execution will cause exceptions during KGC execution. Thus the privilege elevation may be limited to certain resources only specific parts of the overall privileged protection scheme etc.

The KGC also includes a stream of instructions KGC I to KGC IN as shown in . The KGC instructions are also macro instructions as defined in the instruction set architecture implemented by the processor without the architectural modifications emulated by the KGC . The KGC instructions when executed emulate the architectural modifications that are not implemented in the processor . The KGC may complete with instructions that typically cause execution to return to user program at the instruction following the new instruction e.g. I in although continuing execution at another point is also possible e.g. a subsequent instruction in the user program if more than one instruction was emulated an exception or other error handling routine if an error is detected etc. .

In a similar fashion the KGC may emulate functionality that has been deleted via architectural modifications that have been implemented in the processor . For example if an instruction has been deleted from the architecture the KGC may emulate that instruction so that legacy user programs will still function correctly. Still further the KGC may be used to provide proper operation if the processor implements an instruction incorrectly e.g. a bug is found in the processor hardware .

The processor may execute a user program with the fetch unit fetching the instructions from the ICache and providing the fetched instructions to the decode unit . The decode unit may decode the instructions and supply the decoded instructions to the execute core for execution. In some cases the decode unit may provide operand read requests to the user state storage and the KGC state storage if KGC is being executed .

Additionally the decode unit may be coupled to the programmable map which may be programmed with data identifying one or more instructions that are to cause a transition to KGC execution. The programmable map may be programmed at power up of the processor before any user programs are to be executed. The programmable map may be addressable by instructions for programming purposes or hardware circuitry may read the map from a designated computer system location into the programmable map as part of preparing the processor to execute instructions.

In this embodiment the data stored in the programmable map may identify all or part of an instruction that is to cause a transition to KGC execution. For example opcode fields modifiers operand specifiers etc. in the instruction may be used. Additionally various mode indications may be included in the programmable map data in some embodiments.

If the decode unit detects an instruction indicated in the programmable map the decode unit may discard the instruction and subsequent instructions in the user program code stream and may signal the fetch unit to fetch the KGC Fetch KGC signal in . Native KGC may be locked in the ICache for example. Alternatively the native KGC may be in non volatile memory on the same chip or in the same MCM or may be in isolated system memory. In other embodiments the decode unit may signal an external execute engine such as that shown in to execute non native KGC.

The decode unit may comprise any decode circuitry. The decode unit may comprise one or more hardware decoders configured to decode instructions in parallel on different instructions if more than one decoder is provided . The decode unit may also include a microcode unit configured to dispatch microcode routines for more complex instructions.

The execute core may comprise any execution configuration e.g. superscalar superpipelined in order out of order etc. . Additionally the execute core may only permit access to the KGC state storage if the native KGC is executing. The user state storage and the KGC state storage may each comprise any semiconductor storage e.g. registers a register file memory array etc. .

The user program comprises a stream of instructions such as instructions I I I etc. as shown in . Generally the instructions I I I I IO Inst I and I are macro instructions. The IO Inst is an instruction that maps to input output I O either memory mapped I O or the so called in out I O IOIO . IOIO corresponds to the IN and OUT instructions in the x86 instruction set. Generally an IOIO instruction may be any instruction which produces an I O cycle where the I O cycle occurs to an I O address space that is separate from the memory address space and is recognized by the processor as being separate. The IO Inst may be detected by the processor during execution via a trigger event arrow that causes a transition to KGC execution.

In one implementation the trigger event may be the address generated during execution of the IO Inst. Alternatively the data read or written during execution may be the trigger event or any other event during execution of the IO Inst may be the trigger event. In other embodiments the instruction need not be an I O instruction as long as it causes an event that can be detected as a trigger event by the processor . Other trigger events may include a timer expiration error detection e.g. ECC error or any other detectable change in machine state.

In the embodiment of it is the execution core that is coupled to the programmable map and which generates the fetch KGC indication to the fetch unit or an external execution engine . The data in the programmable map may identify an address a range of addresses data a range of data exceptions interrupts etc. that may be a trigger event during execution of the instruction to cause a transition to KGC. The data may also include data identifying the instruction e.g. opcode and other encodings used in conjunction with the execute generated data to identify an instruction that causes a transition to KGC or instead of the execute generated data . The data may still further include various mode indications as mentioned above.

In addition to signalling that KGC should be fetched executed the execution core may also synchronize to the instruction corresponding to the trigger event hold off execution of the first KGC instruction until the triggering instruction and all preceding instructions have completed execution and not executing instructions subsequent to the triggering instruction in the user program until the KGC execution has completed . The execution core may also cause the decode unit and any other units before the execute stage of the pipeline to purge user program instructions or the fetch KGC signal may be used to signal a purge.

The previous section discussed the use of KGC for implementing architectural modifications. Other uses for KGC are also contemplated.

For example illustrates an integrated circuit that includes one or more general purpose GP cores A N and one or more special purpose SP cores A M all integrated onto a single silicon substrate or included in an MCM in other implementations . The GP cores A N may be processors similar to the processor designed to execute instructions as defined in an instruction set architecture. The SP cores may be accelerators added functionality or other devices. For example the SP cores may be graphics processing units GPUs optimized for graphics operations cryptographic accelerators configured to perform cryptography tasks trusted platform modules low power low performance processor cores that can be used for power management and other desired devices. If more than one SP core is included the SP cores may differ from each other. Generally the SP cores A M may comprise any desired circuitry provided in addition to the GP cores A N.

The KGC in the embodiment of may be a device manager which controls access by the GP cores A N to the SP cores A N. The KGC may provide an application programming interface API that can be used by user programs executing on the GP cores A N to access the SP cores A M. Thus the SP cores A M may be changed including how the cores are accessed and the GP cores A N and user programs may be insulated from those changes. Additionally the KGC device manager may handle prioritization of tasks and the sharing of SP cores A M among the GP cores A M. For example an SP core A M may be performing a lower priority task when a higher priority task is requested. The KGC device manager may interrupt the SP core save the state corresponding to the lower priority task and begin the higher priority task. The KGC device manager may have a secure storage location to hold the state of different tasks so that the state is not exposed to an unrelated user program. That is one program s state is hidden from the other program by the KGC. Thus the KGC device manager may provide security. If an SP core is a cryptographic device for example the keys and other sensitive data used in the cryptography may not be visible to an unrelated process. Additionally the KGC device manager may emulate an SP core allowing the core to be removed or allowing for virtual cores if all of the physical cores are busy when a request is received.

The KGC device manager may also control which features are enabled or disabled within the integrated circuit . Such feature control may have a variety of uses. For example a pay as you go model may be supported in which features that have been purchased are enabled and when the purchase expires they can be disabled. Features can be disabled for an initial sale but later enabled if the customer provides an additional payment.

An example of the operation of one embodiment of the KGC as device manager in response to a request from a GP core A N is illustrated in the flowchart of . While the blocks are shown in for ease of understanding other orders may be used. The KGC may comprise instructions which when executed implement the flowchart of .

The KGC may determine if the requested core exists in the integrated circuit decision block . If the requested core does not exist e.g. the core was removed or not included in a later design of the integrated circuit decision block no leg the KGC may emulate the non existent core block . Alternatively if the requested core does not exist on the integrated circuit but equivalent hardware is available elsewhere in a computer system including the processor the KGC may communicate with the external hardware to perform the requested task. By providing the check for existence and the emulation the KGC may permit programs that rely on the SP cores A M to function even if the SP cores are not included.

If the requested core exists in the integrated circuit decision block yes leg the KGC may determine if the requested core A M is available decision block . There may be more than one core of a given type and if any of the cores A M of the requested type is available e.g. enabled and idle that core A M may be assigned to perform the task. If the requested core A M is available decision block yes leg the KGC may program the core to perform the requested task block . Once the task completes decision block yes leg the KGC may inform the requestor block . Determining that the task is complete may take a variety of forms. For example the KGC may poll the assigned core A M or the assigned core may assert an interrupt upon completion. If the completed task preempted another task on the core decision block yes leg the KGC may securely transfer the task state for the preempted task from secure storage block and may program the core to perform the request beginning at the stored state block which may then continue to execute as previously described. The secure storage may be KGC allocated data storage that is not visible to code other than the KGC e.g. located data cache storage writeable NVRAM storage etc. If the completed task did not preempt a task and there is a task waiting to execute in the secure storage decision block yes leg the KGC may securely transfer the task state for the waiting task from secure storage block and may program the core to perform the waiting task block which may then execute as previously described.

If the requested core is not available decision block no leg the KGC may determine if a requested core is performing a lower priority task than the requested task decision block . Priority may be assigned to tasks using any desired priority scheme. The scheme may be associated with the requested tasks e.g. some types of tasks may be higher priority than other types or may be assigned based on the relative priority of the user programs that generated the requests. If a lower priority task is being performed by a core A M decision block yes leg the KGC may preempt the lower priority task to perform the higher priority task block . The KGC may securely transfer the state of the preempted task to secure storage so that the state is hidden from other user programs and even from the initiating user program itself block . The KGC may then program the core to perform the request block which may then execute as previously described. If there is not core performing a lower priority task decision block no leg the KGC may store the task request state in secure storage to await an available core block . Alternatively the KGC may emulate the requested core if desired.

Another contemplated use of KGC relates to the x86 or IA 32 and extensions such as AMD 64 instruction set. The x86 instruction set controls privilege via a four level privilege scheme. The most privileged level is referred to as ring 0 and is often necessary for operating system kernel operations. However there is no partitioning within ring 0. Any task operating at ring 0 can effect any state in the machine even state to which that task should have no access. The ring 0 configuration allows erroneous code to cause problems for unrelated operations and also is a security concern.

KGC may be used to counter these effects by partitioning ring 0. illustrates the partitions with ring 0 illustrated as a circle and the lines A C illustrating the partitions. When code that belongs in one partition attempts to access resources that are not part of that partition the KGC may intercept the access and determine if it is permissible or not. For example an access from one partition to another is illustrated as the dotted arrow . Instead of allowing the access the access may instead be routed to the KGC solid arrow . If the access is permitted the KGC may perform the access on behalf of the requestor solid arrow . In this fashion the partitions may be insulated from each other. If a partition is penetrated by malicious code that partition may be affected but the impact on other partitions may be reduced or even eliminated.

The partitioning illustrated in may be implemented in a variety of ways. For example different memory ranges may be assigned to different partitions which may be programmed into the programmable map . If a memory address that is outside of the partition of the code being executed is generated a transition to KGC may occur. Similarly configuration control register state may be divided among the partitions and accesses to the configuration control registers may be limited based on the current partition by programming the programmable map to detect impermissible registers as operands.

While KGC may be used to implement new architectural features in some cases the KGC alone may not provide the desired performance that a hardware implementation would provide. In one embodiment the KGC may manage an interface to a programmable logic unit that is included on an integrated circuit with the processor. At least a portion of the functionality assigned to the KGC may be implemented in to the programmable logic unit and thus may be performed at higher hardware like speeds. The remaining functionality may be implemented in the KGC itself.

The programmable logic configuration may be loaded into the programmable logic unit using the program interface Program in . The program interface may be isolated from the external inputs outputs of the integrated circuit and thus may only be programmed by KGC executing on the processor . The KGC may read the configuration A or B from the KGC source and may write the configuration to the programmable logic unit over the program interface.

In some implementations the configuration of the programmable logic unit may be selected during power up and the KGC may load the configuration into the programmable logic unit during power up and retain the configuration thereafter. In other implementations the configuration of the programmable logic unit may be changed in operation by selecting another configuration from the KGC source and reprogramming the programmable logic unit . In such implementations the operation of the programmable logic unit may change based on the task being performed by the KGC. For example if the KGC included two computation intensive tasks that benefit from the programmable logic unit the configuration for the more frequently used task may be loaded into the programmable logic unit . If the other task that is not loaded into the programmable logic unit is requested the programmable logic unit may be changed. Alternatively the programmable logic unit may only be changed if the other task is requested more frequently and the KGC may perform the task in software until the determination is made to change the programmable logic unit configuration.

The programmable logic unit may receive inputs In 0 n in and may generate outputs Out 0 m in . The inputs may be sourced from KGC state storage and the outputs may be received by the KGC state storage providing the mechanism for the KGC to drive the programmable logic unit and to receive results from the programmable logic unit . For example the inputs and outputs may be mapped to bits in registers within the KGC state storage .

The programmable logic unit may comprise any type of non permanent programmable logic. For example field programmable gate array FPGA or complex programmable logic device CPLD technology may be used. Flash erasable read only memories or random access memory technologies may be used in the programmable logic unit .

Numerous variations and modifications will become apparent to those skilled in the art once the above disclosure is fully appreciated. It is intended that the following claims be interpreted to embrace all such variations and modifications.

