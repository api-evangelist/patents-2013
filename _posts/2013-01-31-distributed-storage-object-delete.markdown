---

title: Distributed storage object delete
abstract: System and methods for storage object distribution using dynamic policy controls are provided. An embodiment method deleting an object in a distributed storage system includes receiving, from a client, a delete request for an object, retrieving, by a primary datacenter, an object metadata list corresponding to the object to be deleted, and inserting, by the primary datacenter, a delete marker on a top of a stack data structure in an object metadata list.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09104717&OS=09104717&RS=09104717
owner: Futurewei Technologies, Inc.
number: 09104717
owner_city: Plano
owner_country: US
publication_date: 20130131
---
The present disclosure relates to distributed storage systems and in particular embodiments to distributed storage systems offering reliable object deletion.

Deleting an object due to a DELETE Object request or PUT Update Object request in running storage service in a multiple datacenter MDC environment is a complex task. Multiple DELETE and PUT requests may arrive during a small window. In addition the requests may be interleaved. Furthermore subsequent requests sent to remote datacenters may arrive out of sequence and some of the requests may fail. A distributed storage system needs to handle these cases with deterministic behavior and needs to achieve eventual consistency within a predictable period.

If distributed system architecture does not handle the DELETE operation properly there can be several use cases resulting in unintended data losses that cannot be recovered.

An embodiment method of deleting an object in a distributed storage system includes receiving from a client a delete request for the object retrieving by a primary datacenter an object metadata list corresponding to the object to be deleted and inserting by the primary datacenter a delete marker on a top of a stack data structure in the object metadata list.

An embodiment method of updating metadata in a distributed storage system includes creating by an object storage controller a current version of the metadata corresponding to an object in response to a command received from a client and chronologically storing in a storage cluster the current version of the metadata corresponding to the object along with previous versions of the metadata corresponding to the object.

An embodiment method of storing metadata in a distributed storage system includes receiving at an object storage controller a command corresponding to an object from a client loading by the object storage controller an object metadata list associated with the object from a storage cluster and updating with the object storage controller the object metadata list associated with the object by creating a current version of the metadata and retaining previous versions of the metadata.

An embodiment datacenter in a distributed storage system includes an object storage controller configured to receive a command regarding an object from a client and to create a current version of metadata corresponding the object in response to the command and a memory associated with the object storage controller the memory configured to chronologically store the current version of the metadata corresponding to the object in a stack along with at least one previous version of the metadata corresponding to the object.

Corresponding numerals and symbols in the different figures generally refer to corresponding parts unless otherwise indicated. The figures are drawn to clearly illustrate the relevant aspects of the embodiments and are not necessarily drawn to scale.

The making and using of the presently preferred embodiments are discussed in detail below. It should be appreciated however that the present disclosure provides many applicable inventive concepts that can be embodied in a wide variety of specific contexts. The specific embodiments discussed are merely illustrative and do not limit the scope of the disclosure.

The present disclosure will be described with respect to preferred embodiments in a specific context namely datacenters operating in a distributed storage system. The concepts in the disclosure may also apply however to other types of storage systems and associated devices and components.

Referring now to an embodiment distributed storage system is illustrated. As shown the embodiment distributed storage system includes several datacenters communicating through a network e.g. the Internet . It should be recognized that a practical application of the embodiment distributed storage system may include components devices hardware and so on which have not been included in for ease of illustration. In addition the embodiment distributed storage system may include more or fewer datacenters than depicted in . In an embodiment one of the datacenters which is labeled DC1 is considered the primary datacenter while the other datacenters labeled DC2 and DC3 are considered secondary or back up datacenters.

Referring now to an embodiment datacenter is illustrated in further detail. As shown the datacenter includes an object storage controller OSC an object integrity service OIS and a storage cluster . In an embodiment the object storage controller is a server or other computing device loaded with appropriate software to perform the functions described herein. It should be recognized that the embodiment datacenter may include components devices hardware e.g. routers firewalls cashing controller etc. which have not been included in for ease of illustration.

The object storage controller is configured to interact with clients. In particular the object storage controller is configured to receive commands from one or more clients regarding an object containing data and stored within the embodiment distributed storage system . The command may be a delete object command an update object command i.e. a put command a get command and so on. In an embodiment a delete command may not cause an object to be immediately deleted in the embodiment distributed storage system . Rather the delete command may indicate that the object may eventually be permanently deleted from the storage cluster . However the object will not be accessible to clients once the delete command has been successfully processed by the embodiment distributed storage system .

As will be more fully explained below the object storage controller of the primary datacenter DC1 may receive different commands a.k.a. requests application programming interface API calls etc. relating to the same object from different clients at or around the same time. For example a first client may instruct the object storage controller to delete an object at or about the same time that a second client instructs the object storage controller to update the object. Unless handled appropriately this and other conflict scenarios can cause data integrity problems in the embodiment distributed storage system .

Still referring to the object storage controller includes an object storage controller memory . As will be more fully explained below the object storage controller memory stores among other things metadata and metadata lists. Such metadata and or metadata lists may be uploaded from the storage cluster or sent to the storage cluster for storage.

The object integrity service is in communication with the object storage controller . In an embodiment the object integrity service is a server or other computing device loaded with appropriate software to perform the functions described herein. The object integrity service is configured to detect and correct errors in metadata and objects check the integrity of data stored in the embodiment distributed storage system react to tasks in a queue perform scrubbing operations and so on.

Still referring to the object integrity service includes an object integrity service memory . As will be more fully explained below the object integrity service memory stores among other things metadata and metadata lists task lists a queue with tasks and so on. Such metadata and or metadata lists may be received from the object storage controller from other datacenters e.g. DC2 DC3 uploaded from the storage cluster and so on.

The storage cluster represents a plurality of servers or other computing devices. In an embodiment the storage cluster is a collection of servers each having a storage device. The storage device may take the form of a magnetic disk an optical drive flash memory and so on. The storage cluster may be referred to as Sea of Disk SoD . As will be more fully explained below the storage cluster is configured to store metadata pertaining to an object in a metadata list format as shown .

As shown in the object metadata list includes metadata associated with a current version of an object which is referred to as a current version of the metadata . The object metadata list also includes metadata associated with previous or older versions of the metadata for the same object which is referred to as previous versions of the metadata . The metadata in the object metadata list of is used within the embodiment distributed storage system to coordinate the activities associated with a version of the object e.g. parity generation compression multi datacenter copying recovery deletion garbage collection etc. .

As shown in the current version of the metadata and the previous versions of the metadata are organized in a stack data structure . As such the metadata in the object metadata list may be referred to as generations of metadata a list of versions of metadata and so on. Indeed each PUT request received from a client regarding an object creates a new current version of the metadata. The new current version of the metadata is stored in the object metadata list along with the previous versions of the metadata including the one that is no longer current for that object. Notably the previous versions of the metadata are retained when the current version of the metadata is created and placed in stack data structure of the object metadata list .

In an embodiment the current version of the metadata is disposed at the top of the stack data structure as oriented in . Moreover the current version of the metadata and the previous versions of the metadata are stored chronologically in the object metadata list . If a DELETE request is received from the client a special version of the metadata known as a delete marker is placed on the stack data structure . For example in the previous version of the metadata labeled Version 3 metadata DELETE is a delete marker which signifies that that the version of the object below the delete marker in this case the version of the object that corresponds to Version 2 metadata PUT has been or will be deleted.

Still referring to the current version of the metadata and the previous versions of the metadata each include for example an object name a universal unique identifier UUID a timestamp an entity tag ETag an object size an access control list and so on. The UUID identifies the object itself while the ETag identifies the content of the object. Indeed in an embodiment the ETag is a checksum or hash value of the content. The UUID is internal to the embodiment distributed storage system whereas the ETag is returned as a header in response to some of the client requests.

Because the current version of the metadata is situated at the top of the object metadata list above the previous versions of the metadata the datacenters know which version of the metadata is the most current. Indeed and as will be more fully explained below the data centers benefitting from the embodiment distributed storage architecture described herein are able to compare the information in the metadata e.g. the ETag the timestamp etc. in the current version of the metadata and the previous versions of the metadata to resolve conflicting commands received from different clients at or about the same time. A few examples are provided herein to illustrate the point.

To begin when a client intends to upload an object the client sends the following update command i.e. PUT or request for the object to the primary datacenter DC1 in which for the purposes of this example has the universal resource locator URL of uds.example.com.

When the update command is received the primary datacenter DC1 takes the following actions. First the primary datacenter DC1 retrieves the object metadata list corresponding to the object being updated from the storage cluster and temporarily stores it in the object storage controller memory . Thereafter the primary datacenter DC1 creates a new current version of the metadata and places that new version of the metadata on the top of the stack data structure in the object metadata list shown in .

Once the new current version of the metadata has been placed at the top of the stack data structure in the object metadata list the primary datacenter DC1 records the system time as the timestamp in the new current version of the metadata . The timestamp is considered the object creation time.

The primary datacenter DC1 also generates the UUID and stores the UUID in the new current version of the metadata . Once the UUID has been created the primary datacenter DC1 will begin writing the content or data corresponding to the update request in UUID segments e.g. UUID.0 UUID.1 UUID.2 etc. until all the content or data has been updated per the request from the client. The primary datacenter DC1 also generates an ETag for the object received from the client. The ETag which is based on the content of the object is saved in the new current version of the metadata .

If the upload is successful the primary datacenter DC1 in sends the following response to the client which includes the timestamp that was recorded and the ETag that was generated.

Where multiple datacenters are involved as illustrated in the primary datacenter DC1 may forward the update command to the secondary datacenters DC2 DC3 . In an embodiment the primary datacenter DC1 forwards the update command as soon as possible after it is received in order to create a synchronous copy of the object on one of the secondary datacenters . In an embodiment the primary datacenter DC1 may also request that an asynchronous copy of the object be stored on one or more of the secondary datacenters .

In other words when the update command is received at the primary datacenter DC1 the object may be updated at the primary datacenter DC1 and at the secondary primary datacenter DC2 immediately followed by an instruction that the object be updated at another secondary datacenter DC3 sometime in the future when for example system resources or other factors deem appropriate. As such at least one backup copy of the object is made right away. In an embodiment the synchronous copy of the object is made at the secondary datacenter DC2 prior to the response being sent to the client indicating a successful upload.

Where multiple datacenters are involved the update request will look similar to the one depicted above. However an additional header x hws request timestamp is added. The value of this header is the timestamp discussed above as shown.

Now that the current version of the metadata in the object metadata list includes an ETag corresponding to the most recent version of the content the ETag may be beneficially used in connection with subsequent DELETE requests. For example when the primary datacenter DC1 sends subsequent DELETE requests to the secondary datacenters DC2 DC3 it will include the ETag value in the If Match header. The secondary datacenters DC2 DC3 will match the ETag value with the value that they have stored. If the received and stored ETag values match the DELETE request is successfully executed by the secondary datacenters DC2 DC3 . If the received and stored ETag values do not match the DELETE request is ignored. In an embodiment the client may optionally send an ETag header along with the DELETE request.

In light of the above where multiple datacenters are involved the ETag may be used to ensure that commands are executed properly. By way of example if the primary datacenter DC1 and the secondary datacenter DC2 each have version three of an object but the other secondary datacenter DC3 still has version two of an object a command from a client to delete the object will include the ETag that indicates which version either version three or version two in this example should be deleted. By knowing the correct version to act on race conditions and other potentially detrimental conflicting command problems are alleviated in the multiple datacenter context.

When a client intends to delete an object the client sends the following delete command or request for the object to the primary datacenter DC1 in which for the purposes of this example has the universal resource locator URL of uds.example.com.

When the delete command is received the primary datacenter DC1 takes the following actions. First the primary datacenter DC1 retrieves the object metadata list corresponding to the object being deleted from the storage cluster and temporarily stores it in the object storage controller memory . Thereafter the primary datacenter DC1 inserts a delete marker on the top of the stack data structure in the object metadata list shown in .

After the delete marker has been placed at the top of the stack data structure the version of the object immediately below the delete mark in the stack data structure is no longer available if a new READ request is received from the client.

If the delete is successful the primary datacenter DC1 in sends the following response to the client which includes the timestamp that was recorded.

Where multiple datacenters are involved as illustrated in the primary datacenter DC1 may forward the delete command to the secondary datacenters DC2 DC3 . The delete request will look similar to the one depicted above. However two additional headers x hws request timestamp and If match are added. The value of the x hws request timestamp header is the timestamp and the value of the If match header is the value of the ETag that was generated during the update command when the object was created or uploaded as shown.

If the delete is successful the secondary datacenter DC2 DC3 sends back the following response which includes the ETag to the primary datacenter DC1 in .

Now that the current version of the metadata in the object metadata list includes an ETag corresponding to the most recent version of the content the ETag may be beneficially used in connection with subsequent DELETE requests. For example when the primary datacenter DC1 sends subsequent DELETE requests to the secondary datacenters DC2 DC3 it will include the ETag value in the If Match header. The secondary datacenters DC2 DC3 will match the ETag value with the value that they have stored. If the received and stored ETag values match the DELETE request is successfully executed by the secondary datacenters DC2 DC3 . If the received and stored ETag values do not match the DELETE request is ignored. In an embodiment the client may optionally send an ETag header along with the DELETE request.

Notably if any of the secondary datacenters DC2 DC3 is not using the embodiment distributed storage architecture described herein and is instead using for example an Amazon S3 compatible system then the secondary datacenter DC2 DC3 would likely ignore both the x hws request timestamp and If match headers. In the alternative the secondary datacenters DC2 DC3 may attempt to use other information such as the timestamp to resolve and conflicts. In either case the secondary datacenter DC2 DC3 would not send back the ETag header in response to the primary datacenter DC1 . This might cause the secondary datacenter DC2 DC3 without the embodiment distributed storage architecture described herein to delete a newer version of the object unintentionally.

For example assume that the primary datacenter DC1 and one of the secondary datacenters DC2 have been updated to a version three of the object and another of the secondary datacenters DC3 still contains version two of the object. If the third datacenter DC3 is not equipped with the embodiment distributed storage architecture described herein the third datacenter DC3 will not recognize the ETag in the request to delete version three of the object. As such the third datacenter will simply delete version two of the object despite the request being intended for version three. In contrast both the primary datacenters DC1 and the secondary datacenter DC2 that do have the embodiment distributed storage architecture described herein will delete version three of the object as instructed and will leave version two of the object alone.

If the above unintended delete at the secondary datacenter DC3 of the second version of the object occurs the object integrity service will eventually recognize the problem and restore the second version of the object which was inappropriately deleted so that the integrity of the data in the embodiment distributed storage system is maintained. In other words the object integrity service running in the primary datacenter DC1 would take action to make the object status consistent in all the datacenters .

In contrast to the above where the secondary datacenters DC2 DC3 are using the embodiment distributed storage architecture described herein the secondary datacenters DC2 DC3 will compare the ETag value in the If Match header of the request with the ETag value corresponding to the object. If the values don t match the secondary datacenters DC2 DC3 know to reject the delete request.

Referring now to an embodiment method of updating metadata in a distributed storage system is illustrated. In block the object storage controller creates a current version of the metadata corresponding to an object in response to a command received from a client. In block the object storage controller memory chronologically stores the current version of the metadata corresponding to the object along with at least one previous version of the metadata corresponding to the object.

Referring now to an embodiment method of storing metadata in a distributed storage system is illustrated. In block the object storage controller receives a command corresponding to an object from a client. In block the object storage controller loads the object metadata list associated with the object into the object storage controller memory . In block the object storage controller updates the object metadata list associated with the object by creating a current version of the metadata and retaining a previous version of the metadata .

The bus may be one or more of any type of several bus architectures including a memory bus or memory controller a peripheral bus video bus or the like. The CPU may comprise any type of electronic data processor. The memory may comprise any type of system memory such as static random access memory SRAM dynamic random access memory DRAM synchronous DRAM SDRAM read only memory ROM a combination thereof or the like. In an embodiment the memory may include ROM for use at boot up and DRAM for program and data storage for use while executing programs.

The mass storage device may comprise any type of storage device configured to store data programs and other information and to make the data programs and other information accessible via the bus . The mass storage device may comprise for example one or more of a solid state drive hard disk drive a magnetic disk drive an optical disk drive or the like.

The processing system also includes one or more network interfaces which may comprise wired links such as an Ethernet cable or the like and or wireless links to access nodes or different networks. The network interface allows the processing system to communicate with remote systems or units via the networks. For example the network interface may provide wireless communication via one or more transmitters transmit antennas and one or more receivers receive antennas. In an embodiment the processing system a.k.a. processing unit is coupled to a local area network or a wide area network for data processing and communications with remote devices such as other processing units the Internet remote storage facilities or the like.

While the disclosure provides illustrative embodiments this description is not intended to be construed in a limiting sense. Various modifications and combinations of the illustrative embodiments as well as other embodiments will be apparent to persons skilled in the art upon reference to the description. It is therefore intended that the appended claims encompass any such modifications or embodiments.

