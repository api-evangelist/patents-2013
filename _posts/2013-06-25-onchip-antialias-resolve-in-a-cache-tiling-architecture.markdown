---

title: On-chip anti-alias resolve in a cache tiling architecture
abstract: One embodiment of the present invention includes a graphics subsystem for processing multi-sample anti-aliasing work. The graphics subsystem includes a cache unit, a tiling unit, and a screen-space pipeline coupled to the cache unit and to the tiling unit. The tiling unit is configured to organize multi-sample anti-aliasing commands into cache tile batches. The screen-space pipeline includes a pixel shader and a raster operations unit, and receives cache tile batches from the tiling unit. The pixel shader is configured to generate sample data based on a set of primitives and to generate resolved data based on the sample data. The raster operations unit is configured to store the sample data in the cache unit and to invalidate the sample data after the pixel shader generates the resolved data.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08941676&OS=08941676&RS=08941676
owner: NVIDIA Corporation
number: 08941676
owner_city: Santa Clara
owner_country: US
publication_date: 20130625
---
This application claims benefit of U.S. provisional patent application Ser. No. 61 719 271 filed Oct. 26 2012 and titled An Approach for Tiled Caching. The subject matter of this related application is hereby incorporated herein by reference.

Embodiments of the present invention relate generally to three dimensional 3D graphics processing and more specifically to on chip anti alias resolve in a cache tiling architecture.

Many graphics processing tasks generate intermediate data which is data that is generated and used during the execution of a graphics processing task but is not the final data output for the graphics processing task. One type of graphics processing task that generates intermediate data is multi sample anti aliasing which is a particular type of anti aliasing technique in which multiple color samples are generated for each screen pixel. The multiple color samples associated with each screen pixel are then resolved to generate a blended color value for each screen pixel. In multi sample anti aliasing the multiple samples are deemed intermediate data because the samples are not the final output of the graphics processing task rather the blended color values for the screen pixels constitute the final output.

Some graphics subsystems implement a tiling architecture in which a render target is subdivided into cache tiles. Work received by such a graphics subsystem is rearranged such that the work is processed in cache tile order. In other words work associated with a first cache is processed first then work associated with a second cache tile is processed then work associated with a third cache tile and so forth. In some implementations data associated with cache tiles is maintained in an on chip cache memory while the cache tile is being processed which reduces the amount of traffic between the on chip cache and the frame buffer. This approach in turn reduces memory bandwidth utilization and associated power consumption. Also in some implementations the architecture includes multiple processing entities that operate in concert to process each cache tile. Each processing entity is assigned a portion of each cache tile and performs processing operations associated with that portion.

Several challenges exist with respect to performing anti aliasing in an architecture that implements cache tiling and includes multiple processing entities. For example the multiple processing entities need to be configured to manage data dependencies that are associated with the multi sample anti aliasing operation. Although these data dependencies exist in a graphics subsystem with only one processing entity performing multi sample anti aliasing with multiple processing entities that cooperate to render each cache tile complicates the steps that need to be taken to manage these data dependencies because data dependencies may exist across processing entities.

Another challenging aspect of processing multi sample anti aliasing operations in a graphics subsystem that includes multiple processing entities that implement a cache tiling architecture is managing data flow between the cache memory that stores the cache tiles and an external memory such as a frame buffer. As described above intermediate data such as the sample data is only needed during the multi sample anti aliasing operation and is not the final output of such operation. Such intermediate data need not be written out from the cache memory to the frame buffer. Writing such intermediate data out to the frame buffer would unnecessarily consume memory bandwidth and power.

As the foregoing illustrates what is needed in the art are techniques for managing intermediate data associated with anti aliasing while also managing data dependencies between the operations in the anti aliasing task.

One embodiment of the present invention sets forth a graphics subsystem for processing multi sample anti aliasing work. The graphics subsystem includes a cache unit and a screen space pipeline coupled to the cache unit. The screen space pipeline includes a pixel shader and a raster operations unit. The pixel shader is configured to generate sample data based on a set of primitives and to generate resolved data based on the sample data. The raster operations unit is configured to store the sample data in the cache unit and to invalidate the sample data after the pixel shader generates the resolved data.

One embodiment of the present invention sets forth a computing device for processing multi sample anti aliasing work. The computing device includes a graphics subsystem. The graphics subsystem includes a cache unit and a screen space pipeline coupled to the cache unit. The screen space pipeline includes a pixel shader and a raster operations unit. The pixel shader is configured to generate sample data based on a set of primitives and to generate resolved data based on the sample data. The raster operations unit is configured to store the sample data in the cache unit and to invalidate the sample data after the pixel shader generates the resolved data.

One embodiment of the present invention sets forth a method for processing multi sample anti aliasing work. The method includes generating a first set of sample data based on a first set of primitives. The method also includes generating a first set of resolved data based on the first set of sample data. The method also includes storing the first set of sample data in a first set of cache lines. The method also includes invalidating the first set of cache lines after the first set of resolved data is generated.

One advantage of the disclosed technique is that data dependencies between sample data and resolved data are honored. Another advantage is that the sample data that is generated is not written out to the frame buffer thus reducing memory bandwidth consumption.

In the following description numerous specific details are set forth to provide a more thorough understanding of the present invention. However it will be apparent to one of skill in the art that the present invention may be practiced without one or more of these specific details.

In operation I O bridge is configured to receive user input information from input devices such as a keyboard or a mouse and forward the input information to CPU for processing via communication path and memory bridge . Switch is configured to provide connections between I O bridge and other components of the computer system such as a network adapter and various add in cards and .

As also shown I O bridge is coupled to a system disk that may be configured to store content and applications and data for use by CPU and parallel processing subsystem . As a general matter system disk provides non volatile storage for applications and data and may include fixed or removable hard disk drives flash memory devices and CD ROM compact disc read only memory DVD ROM digital versatile disc ROM Blu ray HD DVD high definition DVD or other magnetic optical or solid state storage devices. Finally although not explicitly shown other components such as universal serial bus or other port connections compact disc drives digital versatile disc drives film recording devices and the like may be connected to I O bridge as well.

In various embodiments memory bridge may be a Northbridge chip and I O bridge may be a Southbrige chip. In addition communication paths and as well as other communication paths within computer system may be implemented using any technically suitable protocols including without limitation AGP Accelerated Graphics Port HyperTransport or any other bus or point to point communication protocol known in the art.

In some embodiments parallel processing subsystem comprises a graphics subsystem that delivers pixels to a display device that may be any conventional cathode ray tube liquid crystal display light emitting diode display or the like. In such embodiments the parallel processing subsystem incorporates circuitry optimized for graphics and video processing including for example video output circuitry. As described in greater detail below in such circuitry may be incorporated across one or more parallel processing units PPUs included within parallel processing subsystem . In other embodiments the parallel processing subsystem incorporates circuitry optimized for general purpose and or compute processing. Again such circuitry may be incorporated across one or more PPUs included within parallel processing subsystem that are configured to perform such general purpose and or compute operations. In yet other embodiments the one or more PPUs included within parallel processing subsystem may be configured to perform graphics processing general purpose processing and compute processing operations. System memory includes at least one device driver configured to manage the processing operations of the one or more PPUs within parallel processing subsystem .

In various embodiments parallel processing subsystem may be integrated with one or more other the other elements of to form a single system. For example parallel processing subsystem may be integrated with CPU and other connection circuitry on a single chip to form a system on chip SoC .

It will be appreciated that the system shown herein is illustrative and that variations and modifications are possible. The connection topology including the number and arrangement of bridges the number of CPUs and the number of parallel processing subsystems may be modified as desired. For example in some embodiments system memory could be connected to CPU directly rather than through memory bridge and other devices would communicate with system memory via memory bridge and CPU . In other alternative topologies parallel processing subsystem may be connected to I O bridge or directly to CPU rather than to memory bridge . In still other embodiments I O bridge and memory bridge may be integrated into a single chip instead of existing as one or more discrete devices. Lastly in certain embodiments one or more components shown in may not be present. For example switch could be eliminated and network adapter and add in cards would connect directly to I O bridge .

In some embodiments PPU comprises a graphics processing unit GPU that may be configured to implement a graphics rendering pipeline to perform various operations related to generating pixel data based on graphics data supplied by CPU and or system memory . When processing graphics data PP memory can be used as graphics memory that stores one or more conventional frame buffers and if needed one or more other render targets as well. Among other things PP memory may be used to store and update pixel data and deliver final pixel data or display frames to display device for display. In some embodiments PPU also may be configured for general purpose processing and compute operations.

In operation CPU is the master processor of computer system controlling and coordinating operations of other system components. In particular CPU issues commands that control the operation of PPU . In some embodiments CPU writes a stream of commands for PPU to a data structure not explicitly shown in either or that may be located in system memory PP memory or another storage location accessible to both CPU and PPU . A pointer to the data structure is written to a pushbuffer to initiate processing of the stream of commands in the data structure. The PPU reads command streams from the pushbuffer and then executes commands asynchronously relative to the operation of CPU . In embodiments where multiple pushbuffers are generated execution priorities may be specified for each pushbuffer by an application program via device driver to control scheduling of the different pushbuffers.

As also shown PPU includes an I O input output unit that communicates with the rest of computer system via the communication path and memory bridge . I O unit generates packets or other signals for transmission on communication path and also receives all incoming packets or other signals from communication path directing the incoming packets to appropriate components of PPU . For example commands related to processing tasks may be directed to a host interface while commands related to memory operations e.g. reading from or writing to PP memory may be directed to a crossbar unit . Host interface reads each pushbuffer and transmits the command stream stored in the pushbuffer to a front end .

As mentioned above in conjunction with the connection of PPU to the rest of computer system may be varied. In some embodiments parallel processing subsystem which includes at least one PPU is implemented as an add in card that can be inserted into an expansion slot of computer system . In other embodiments PPU can be integrated on a single chip with a bus bridge such as memory bridge or I O bridge . Again in still other embodiments some or all of the elements of PPU may be included along with CPU in a single integrated circuit or system of chip SoC .

In operation front end transmits processing tasks received from host interface to a work distribution unit not shown within task work unit . The work distribution unit receives pointers to processing tasks that are encoded as task metadata TMD and stored in memory. The pointers to TMDs are included in a command stream that is stored as a pushbuffer and received by the front end unit from the host interface . Processing tasks that may be encoded as TMDs include indices associated with the data to be processed as well as state parameters and commands that define how the data is to be processed. For example the state parameters and commands could define the program to be executed on the data. The task work unit receives tasks from the front end and ensures that GPCs are configured to a valid state before the processing task specified by each one of the TMDs is initiated. A priority may be specified for each TMD that is used to schedule the execution of the processing task. Processing tasks also may be received from the processing cluster array . Optionally the TMD may include a parameter that controls whether the TMD is added to the head or the tail of a list of processing tasks or to a list of pointers to the processing tasks thereby providing another level of control over execution priority.

PPU advantageously implements a highly parallel processing architecture based on a processing cluster array that includes a set of C general processing clusters GPCs where C 1. Each GPC is capable of executing a large number e.g. hundreds or thousands of threads concurrently where each thread is an instance of a program. In various applications different GPCs may be allocated for processing different types of programs or for performing different types of computations. The allocation of GPCs may vary depending on the workload arising for each type of program or computation.

Memory interface includes a set of D of partition units where D 1. Each partition unit is coupled to one or more dynamic random access memories DRAMs residing within PPM memory . In one embodiment the number of partition units equals the number of DRAMs and each partition unit is coupled to a different DRAM . In other embodiments the number of partition units may be different than the number of DRAMs . Persons of ordinary skill in the art will appreciate that a DRAM may be replaced with any other technically suitable storage device. In operation various render targets such as texture maps and frame buffers may be stored across DRAMs allowing partition units to write portions of each render target in parallel to efficiently use the available bandwidth of PP memory .

A given GPCs may process data to be written to any of the DRAMs within PP memory . Crossbar unit is configured to route the output of each GPC to the input of any partition unit or to any other GPC for further processing. GPCs communicate with memory interface via crossbar unit to read from or write to various DRAMs . In one embodiment crossbar unit has a connection to I O unit in addition to a connection to PP memory via memory interface thereby enabling the processing cores within the different GPCs to communicate with system memory or other memory not local to PPU . In the embodiment of crossbar unit is directly connected with I O unit . In various embodiments crossbar unit may use virtual channels to separate traffic streams between the GPCs and partition units .

Again GPCs can be programmed to execute processing tasks relating to a wide variety of applications including without limitation linear and nonlinear data transforms filtering of video and or audio data modeling operations e.g. applying laws of physics to determine position velocity and other attributes of objects image rendering operations e.g. tessellation shader vertex shader geometry shader and or pixel fragment shader programs general compute operations etc. In operation PPU is configured to transfer data from system memory and or PP memory to one or more on chip memory units process the data and write result data back to system memory and or PP memory . The result data may then be accessed by other system components including CPU another PPU within parallel processing subsystem or another parallel processing subsystem within computer system .

As noted above any number of PPUs may be included in a parallel processing subsystem . For example multiple PPUs may be provided on a single add in card or multiple add in cards may be connected to communication path or one or more of PPUs may be integrated into a bridge chip. PPUs in a multi PPU system may be identical to or different from one another. For example different PPUs might have different numbers of processing cores and or different amounts of PP memory . In implementations where multiple PPUs are present those PPUs may be operated in parallel to process data at a higher throughput than is possible with a single PPU . Systems incorporating one or more PPUs may be implemented in a variety of configurations and form factors including without limitation desktops laptops handheld personal computers or other handheld devices servers workstations game consoles embedded systems and the like.

Operation of GPC is controlled via a pipeline manager that distributes processing tasks received from a work distribution unit not shown within task work unit to one or more streaming multiprocessors SMs . Pipeline manager may also be configured to control a work distribution crossbar by specifying destinations for processed data output by SMs .

In one embodiment GPC includes a set of M of SMs where M 1. Also each SM includes a set of functional execution units not shown such as execution units and load store units. Processing operations specific to any of the functional execution units may be pipelined which enables a new instruction to be issued for execution before a previous instruction has completed execution. Any combination of functional execution units within a given SM may be provided. In various embodiments the functional execution units may be configured to support a variety of different operations including integer and floating point arithmetic e.g. addition and multiplication comparison operations Boolean operations AND OR XOR bit shifting and computation of various algebraic functions e.g. planar interpolation and trigonometric exponential and logarithmic functions etc. . Advantageously the same functional execution unit can be configured to perform different operations.

In operation each SM is configured to process one or more thread groups. As used herein a thread group or warp refers to a group of threads concurrently executing the same program on different input data with one thread of the group being assigned to a different execution unit within an SM . A thread group may include fewer threads than the number of execution units within the SM in which case some of the execution may be idle during cycles when that thread group is being processed. A thread group may also include more threads than the number of execution units within the SM in which case processing may occur over consecutive clock cycles. Since each SM can support up to G thread groups concurrently it follows that up to G M thread groups can be executing in GPC at any given time.

Additionally a plurality of related thread groups may be active in different phases of execution at the same time within an SM . This collection of thread groups is referred to herein as a cooperative thread array CTA or thread array. The size of a particular CTA is equal to m k where k is the number of concurrently executing threads in a thread group which is typically an integer multiple of the number of execution units within the SM and m is the number of thread groups simultaneously active within the SM .

Although not shown in each SM contains a level one L1 cache or uses space in a corresponding L1 cache outside of the SM to support among other things load and store operations performed by the execution units. Each SM also has access to level two L2 caches not shown that are shared among all GPCs in PPU . The L2 caches may be used to transfer data between threads. Finally SMs also have access to off chip global memory which may include PP memory and or system memory . It is to be understood that any memory external to PPU may be used as global memory. Additionally as shown in a level one point five L1.5 cache may be included within GPC and configured to receive and hold data requested from memory via memory interface by SM . Such data may include without limitation instructions uniform data and constant data. In embodiments having multiple SMs within GPC the SMs may beneficially share common instructions and data cached in L1.5 cache .

Each GPC may have an associated memory management unit MMU that is configured to map virtual addresses into physical addresses. In various embodiments MMU may reside either within GPC or within the memory interface . The MMU includes a set of page table entries PTEs used to map a virtual address to a physical address of a tile or memory page and optionally a cache line index. The MMU may include address translation lookaside buffers TLB or caches that may reside within SMs within one or more L1 caches or within GPC .

In graphics and compute applications GPC may be configured such that each SM is coupled to a texture unit for performing texture mapping operations such as determining texture sample positions reading texture data and filtering texture data.

In operation each SM transmits a processed task to work distribution crossbar in order to provide the processed task to another GPC for further processing or to store the processed task in an L2 cache not shown parallel processing memory or system memory via crossbar unit . In addition a pre raster operations preROP unit is configured to receive data from SM direct data to one or more raster operations ROP units within partition units perform optimizations for color blending organize pixel color data and perform address translations.

It will be appreciated that the core architecture described herein is illustrative and that variations and modifications are possible. Among other things any number of processing units such as SMs texture units or preROP units may be included within GPC . Further as described above in conjunction with PPU may include any number of GPCs that are configured to be functionally similar to one another so that execution behavior does not depend on which GPC receives a particular processing task. Further each GPC operates independently of the other GPCs in PPU to execute tasks for one or more application programs. In view of the foregoing persons of ordinary skill in the art will appreciate that the architecture described in in no way limits the scope of the present invention.

The PD collects vertex data associated with high order surfaces graphics primitives and the like from the front end and transmits the vertex data to the VAF .

The VAF retrieves vertex attributes associated with each of the incoming vertices from shared memory and stores the vertex data along with the associated vertex attributes into shared memory.

The VTG is a programmable execution unit that is configured to execute vertex shader programs tessellation programs and geometry programs. These programs process the vertex data and vertex attributes received from the VAF and produce graphics primitives for further processing within the graphics processing pipeline . Although not explicitly shown the VTG may include in some embodiments one or more of a vertex processing unit a tessellation initialization processing unit a task generation unit a task distributor a topology generation unit a tessellation processing unit and a geometry processing unit.

The vertex processing unit is a programmable execution unit that is configured to execute vertex shader programs lighting and transforming vertex data as specified by the vertex shader programs. For example the vertex processing unit may be programmed to transform the vertex data from an object based coordinate representation object space to an alternatively based coordinate system such as world space or normalized device coordinates NDC space. The vertex processing unit may read vertex data and vertex attributes that is stored in shared memory by the VAF and may process the vertex data and vertex attributes. The vertex processing unit stores processed vertices in shared memory.

The tessellation initialization processing unit is a programmable execution unit that is configured to execute tessellation initialization shader programs. The tessellation initialization processing unit processes vertices produced by the vertex processing unit and generates graphics primitives known as patches. The tessellation initialization processing unit also generates various patch attributes. The tessellation initialization processing unit then stores the patch data and patch attributes in shared memory. In some embodiments the tessellation initialization shader program may be called a hull shader or a tessellation control shader.

The task generation unit retrieves data and attributes for vertices and patches from shared memory. The task generation unit generates tasks for processing the vertices and patches for processing by later stages in the graphics processing pipeline .

The task distributor redistributes the tasks produced by the task generation unit. The tasks produced by the various instances of the vertex shader program and the tessellation initialization program may vary significantly between one graphics processing pipeline and another. The task distributor redistributes these tasks such that each graphics processing pipeline has approximately the same workload during later pipeline stages.

The topology generation unit retrieves tasks distributed by the task distributor. The topology generation unit indexes the vertices including vertices associated with patches and computes U V coordinates for tessellation vertices and the indices that connect the tessellated vertices to form graphics primitives. The topology generation unit then stores the indexed vertices in shared memory.

The tessellation processing unit is a programmable execution unit that is configured to execute tessellation shader programs. The tessellation processing unit reads input data from and writes output data to shared memory. This output data in shared memory is passed to the next shader stage the geometry processing unit as input data. In some embodiments the tessellation shader program may be called a domain shader or a tessellation evaluation shader.

The geometry processing unit is a programmable execution unit that is configured to execute geometry shader programs thereby transforming graphics primitives. Vertices are grouped to construct graphics primitives for processing where graphics primitives include triangles line segments points and the like. For example the geometry processing unit may be programmed to subdivide the graphics primitives into one or more new graphics primitives and calculate parameters such as plane equation coefficients that are used to rasterize the new graphics primitives.

The geometry processing unit transmits the parameters and vertices specifying new graphics primitives to the VPC . The geometry processing unit may read data that is stored in shared memory for use in processing the geometry data. The VPC performs clipping culling and viewport transform to determine which graphics primitives are potentially viewable in the final rendered image and which graphics primitives are not potentially viewable. The VPC then transmits processed graphics primitives to the tiling unit .

The tiling unit is a graphics primitive sorting engine that resides between a world space pipeline and a screen space pipeline as further described herein. Graphics primitives are processed in the world space pipeline and then transmitted to the tiling unit . The screen space is divided into cache tiles where each cache tile is associated with a portion of the screen space. For each graphics primitive the tiling unit identifies the set of cache tiles that intersect with the graphics primitive a process referred to herein as tiling. After tiling a certain number of graphics primitives the tiling unit processes the graphics primitives on a cache tile basis where graphics primitives associated with a particular cache tile are transmitted to the setup unit . The tiling unit transmits graphics primitives to the setup unit one cache tile at a time. Graphics primitives that intersect with multiple cache tiles are typically processed once in the world space pipeline but are then transmitted multiple times to the screen space pipeline .

Such a technique improves cache memory locality during processing in the screen space pipeline where multiple memory operations associated with a first cache tile access a region of the L2 caches or any other technically feasible cache memory that may stay resident during screen space processing of the first cache tile. Once the graphics primitives associated with the first cache tile are processed by the screen space pipeline the portion of the L2 caches associated with the first cache tile may be flushed and the tiling unit may transmit graphics primitives associated with a second cache tile. Multiple memory operations associated with a second cache tile may then access the region of the L2 caches that may stay resident during screen space processing of the second cache tile. Accordingly the overall memory traffic to the L2 caches and to the render targets may be reduced. In some embodiments the world space computation is performed once for a given graphics primitive irrespective of the number of cache tiles in screen space that intersects with the graphics primitive.

The setup unit receives vertex data from the VPC via the tiling unit and calculates parameters associated with the graphics primitives including without limitation the color values surface normal vectors and transparency values at each vertex of the graphics primitive. The setup unit then transmits processed graphics primitives to rasterizer .

The rasterizer scan converts the new graphics primitives and transmits fragments and coverage data to the pixel shading unit . Additionally the rasterizer may be configured to perform z culling and other z based optimizations.

The pixel shading unit is a programmable execution unit that is configured to execute fragment shader programs transforming fragments received from the rasterizer as specified by the fragment shader programs. Fragment shader programs may shade fragments at pixel level granularity where such shader programs may be called pixel shader programs. Alternatively fragment shader programs may shade fragments at sample level granularity where each pixel includes multiple samples and each sample represents a portion of a pixel. Alternatively fragment shader programs may shade fragments at any other technically feasible granularity depending on the programmed sampling rate.

In various embodiments the fragment processing unit may be programmed to perform operations such as perspective correction texture mapping shading blending and the like to produce shaded fragments that are transmitted to the ROP . The pixel shading unit may read data that is stored in shared memory.

The ROP is a processing unit that performs raster operations such as stencil z test blending and the like and transmits pixel data as processed graphics data for storage in graphics memory via the memory interface where graphics memory is typically structured as one or more render targets. The processed graphics data may be stored in graphics memory parallel processing memory or system memory for display on display device or for further processing by CPU or parallel processing subsystem . In some embodiments the ROP is configured to compress z or color data that is written to memory and decompress z or color data that is read from memory. In various embodiments the ROP may be located in the memory interface in the GPCs in the processing cluster array outside of the GPCs or in a separate unit not shown within the PPUs .

The graphics processing pipeline may be implemented by any one or more processing elements within PPU . For example one of the SMs of could be configured to perform the functions of one or more of the VTG and the pixel shading unit . The functions of the PD the VAF the VPC the tiling unit the setup unit the rasterizer and the ROP may also be performed by processing elements within a particular GPC in conjunction with a corresponding partition unit . Alternatively graphics processing pipeline may be implemented using dedicated fixed function processing elements for one or more of the functions listed above. In various embodiments PPU may be configured to implement one or more graphics processing pipelines .

In some embodiments the graphics processing pipeline may be divided into a world space pipeline and a screen space pipeline . The world space pipeline processes graphics objects in 3D space where the position of each graphics object is known relative to other graphics objects and relative to a 3D coordinate system. The screen space pipeline processes graphics objects that have been projected from the 3D coordinate system onto a 2D planar surface representing the surface of the display device . For example the world space pipeline could include pipeline stages in the graphics processing pipeline from the PD through the VPC . The screen space pipeline could include pipeline stages in the graphics processing pipeline from the setup unit through the ROP . The tiling unit would follow the last stage of the world space pipeline namely the VPC . The tiling unit would precede the first stage of the screen space pipeline namely the setup unit .

In some embodiments the world space pipeline may be further divided into an alpha phase pipeline and a beta phase pipeline. For example the alpha phase pipeline could include pipeline stages in the graphics processing pipeline from the PD through the task generation unit. The beta phase pipeline could include pipeline stages in the graphics processing pipeline from the topology generation unit through the VPC . The graphics processing pipeline performs a first set of operations during processing in the alpha phase pipeline and a second set of operations during processing in the beta phase pipeline. As used herein a set of operations is defined as one or more instructions executed by a single thread by a thread group or by multiple thread groups acting in unison.

In a system with multiple graphics processing pipeline the vertex data and vertex attributes associated with a set of graphics objects may be divided so that each graphics processing pipeline has approximately the same amount of workload through the alpha phase. Alpha phase processing may significantly expand the amount of vertex data and vertex attributes such that the amount of vertex data and vertex attributes produced by the task generation unit is significantly larger than the amount of vertex data and vertex attributes processed by the PD and VAF . Further the task generation unit associated with one graphics processing pipeline may produce a significantly greater quantity of vertex data and vertex attributes than the task generation unit associated with another graphics processing pipeline even in cases where the two graphics processing pipelines process the same quantity of attributes at the beginning of the alpha phase pipeline. In such cases the task distributor redistributes the attributes produced by the alpha phase pipeline such that each graphics processing pipeline has approximately the same workload at the beginning of the beta phase pipeline.

Please note as used herein references to shared memory may include any one or more technically feasible memories including without limitation a local memory shared by one or more SMs or a memory accessible via the memory interface such as a cache memory parallel processing memory or system memory . Please also note as used herein references to cache memory may include any one or more technically feasible memories including without limitation an L1 cache an L1.5 cache and the L2 caches.

The screen space represents one or more memory buffers configured to store rendered image data and other data transmitted by functional units within the graphics processing pipeline . In some embodiments the one or more memory buffers may be configured as one or more render targets. The screen space represents a memory buffer configured to store the image rendered by the graphics processing pipeline. The screen space may be associated with any number of render targets where each render target may be configured independently of other render targets to include any number of fields. Each field within a render target may be configured independently of other fields to include any number of bits. Each render target may include multiple picture elements pixels and each pixel may in turn include multiple samples. In some embodiments the size of each cache tile may be based on the size and configuration of the render targets associated with the screen space. In operation once rendering completes the pixels in the one or more render targets may be transmitted to a display device in order to display the rendered image.

By way of example a set of render targets for the screen space could include eight render targets. The first render target could include four fields representing color including red green and blue component colors and transparency information associated with a corresponding fragment. The second render target could include two fields representing depth and stencil information associated with the corresponding fragment. The third render target could include three fields representing surface normal vector information including an x axis normal vector a y axis normal vector and a z axis normal vector associated with the corresponding fragment. The remaining five render targets could be configured to store additional information associated with the corresponding fragment. Such configurations could include storage for various information including without limitation 3D positional data diffuse lighting information and specular lighting information.

Each cache tile represents a portion of the screen space . For clarity only five cache tiles are shown in . In some embodiments cache tiles may have an arbitrary size in X and Y screen space. For example if a cache tile were to reside in a cache memory that also is used to store other data then the cache tile could be sized to consume only a specific portion of the cache memory. The size of a cache tile may be based on a number of factors including the quantity and configuration of the render targets associated with the screen space the quantity of samples per pixel and whether the data stored in the cache tile is compressed. As a general matter a cache tile is sized to increase the likelihood that the cache tile data remains resident in the cache memory until all graphics primitives associated with the cache tile are fully processed.

The raster tiles represent a portion of the cache tile . As shown the cache tile includes sixteen raster tiles arranged in an array that is four raster tiles wide and four raster tiles high. In systems that include multiple GPCs processing associated with a given cache tile may be divided among the available GPCs . In the example shown if the sixteen raster tiles of cache tile were processed by four different GPCs then each GPC could be assigned to process four of the sixteen raster tiles in the cache tile . Specifically the first GPC could be assigned to process raster tiles and . The second GPC could be assigned to process raster tiles and . The third GPC could be assigned to process raster tiles and . The fourth GPC would then be assigned to process raster tiles and . In other embodiments the processing of the different raster tiles within a given cache tile may be distributed among GPCs or any other processing entities included within computer system in any technically feasible manner.

Graphics pipelines typically process data in a pipelined manner meaning that certain operations such as pixel shading are performed on one batch of data while other operations such as rasterization are performed on another batch of data. Additionally some graphics subsystems such as the graphics pipeline depicted in implement a tiling architecture in which a render target is subdivided into cache tiles. Work received by such a graphics subsystem is rearranged such that the work is processed in cache tile order. Data associated with cache tiles is maintained in an on chip cache memory while the cache tile is being processed which reduces the amount of traffic between the on chip cache and a frame buffer. Some graphics subsystems that implement a tiling architecture include multiple processing entities that operate in concert to process each cache tile. Each processing entity is assigned a portion of each cache tile and performs processing operations associated with that portion.

One challenging aspect of the architecture described above is that pipelining introduces data dependencies associated with anti aliasing operations because the operation for generating the final color values is dependent on the results of the operation for generating the sample surface. These data dependencies are complicated by the inclusion of multiple processing entities. An additional challenging aspect of processing multi sample anti aliasing operations in a graphics subsystem that includes multiple processing entities that implement a cache tiling architecture is managing data flow between the cache memory that stores the cache tiles and an external memory such as a frame buffer. As described above intermediate data such as the sample data is only needed during the multi sample anti aliasing task and is not the final output of such task. Such intermediate data need not be written out from the cache memory to the frame buffer and writing such intermediate data out to the frame buffer would unnecessarily consume memory bandwidth and power.

The techniques described below include mechanisms for managing data dependencies associated with multi sample anti aliasing and for managing data flow to and from a cache memory in a highly parallel graphics architecture that implements cache tiling.

The graphics subsystem includes at least two instances of the screen space pipeline and the world space pipeline for increased performance. Although depicted in with two instances of the world space pipeline and the screen space pipeline the teachings provided herein apply to graphics pipelines having any number of world space pipelines and screen space pipelines .

The functionality of the world space pipelines and the screen space pipelines are implemented by processing entities such as general processing clusters GPC described above. In one embodiment the first world space pipeline may be implemented in a first GPC and the second world space pipeline may be implemented in a second GPC . As a general matter each screen space pipeline may be implemented in a different GPC and in a similar fashion each world space pipeline may be implemented in a different GPC . Further a given GPC can implement a world space pipeline and also a screen space pipeline . For example the first GPC may implement both the first world space pipeline and the first screen space pipeline .

The front end unit receives commands from a device driver and schedules tasks for processing by the world space pipeline . In one embodiment the front end unit distributes tasks to the first world space pipeline and the second world space pipeline in round robin order. The front end unit also transmits barrier commands to the screen space circular buffer for use by the tiling units as described below. The screen space circular buffer is a memory construct that may be stored in a cache such as an L2 cache.

The first world space pipeline and the second world space pipeline function in a similar manner as described above with respect to . In other words the first world space pipeline and the second world space pipeline generate primitives in response to the work received from the front end unit .

The first world space pipeline and second world space pipeline each include a bounding box generator unit not shown that determines to which screen space pipeline the first screen space pipeline or the second screen space pipeline each primitive should be transmitted. Both the first world space pipeline and the second world space pipeline may send primitives to either or both of the first screen space pipeline or the second screen space pipeline .

Each tiling unit is associated with a respective screen space pipeline . Each tiling unit thus receives primitives from the crossbar destined to the corresponding screen space pipeline and transmits those primitives to the corresponding screen space pipeline . For example the first tiling unit receives primitives destined for the first screen space pipeline and transmits the primitives to the first screen space pipeline .

Each of the units in the screen space pipeline i.e. setup rasterizer pixel shader and ROP functions in a similar manner as described above with respect to . The pre raster operations unit PROP not depicted in is a unit that is configured to perform among other things early z testing optimizations for color blending and address translations.

A back end unit receives data from the screen space pipeline and provides feedback through feedback pathway to PROP . The back end unit includes a barrier command counter for counting the number of tiled barrier commands received by the back end unit . The functionality of the back end unit may be implemented in the front end unit in which case the graphics subsystem would include only the front end unit .

Operation of the graphics subsystem is now described in the context of anti alias commands transmitted from a device driver . In operation the device driver transmits anti alias commands to the front end unit . The anti alias commands include commands configured to cause the graphics subsystem to generate a multi sample anti aliased image. The anti alias commands include a batch of multi sample render commands a tiled barrier command an anti alias resolve command and a cache invalidate command .

The front end unit distributes tasks associated with the batch of multi sample render commands with the anti alias resolve command and with the cache invalidate command to the first world space pipeline and the second world space pipeline . The front end unit also causes the barrier command to be transmitted to a screen space circular buffer for subsequent access by the first tiling unit and the second tiling unit as discussed below. The first world space pipeline and the second world space pipeline process these tasks to generate primitives for processing by the first screen space pipeline and the second screen space pipeline .

Each tiling unit receives a batch of primitives that are associated with the batch of multi sample render commands . When the tiling unit receives the last primitive included in the batch of primitives the screen space circular buffer transmits the barrier command to the tiling unit . After this the tiling unit receives the anti alias resolve command and the cache invalidate command .

Each tiling unit tiles all of the work in the tiling unit . In other words when the tiling unit receives the primitives and commands associated with the anti alias commands the tiling unit generates cache tile batches that include the primitives and commands associated with the anti alias commands . Each cache tile batch is associated with a different cache tile and includes primitives that overlap a particular cache tile. Each cache tile batch also includes the tiled barrier command the anti alias resolve command and the cache invalidate command . Each tiling unit transmits each cache tile batch to the screen space pipeline associated with the tiling unit .

The batch of primitives proceeds through the screen space pipeline . Units in the screen space pipeline process the batch of primitives and generate a multi sample surface that includes multiple samples per pixel.

The barrier command proceeds through the screen space pipeline after the batch of primitives . When the PROP unit receives the barrier command the PROP unit sets a barrier flag corresponding to the cache tile associated with the cache tile batch that includes the barrier command . This barrier flag causes work received after the barrier command to not proceed past the PROP unit until after the barrier flag is cleared.

The anti alias resolve command flows down the pipeline following the barrier command . The anti alias resolve command is configured to cause the screen space pipeline to apply an anti alias filter to the sample surface to generate final pixel values. More specifically the anti alias resolve command is configured to cause the pixel shader to access the multi sample surface and to apply a filter to the sample data in the multi sample surface to generate final color data. The barrier flag set in the PROP unit causes the anti alias resolve command which arrives at PROP after the barrier command to halt at the PROP unit until the barrier flag is reset.

The invalidate command flows down the pipeline following the anti alias resolve command . The invalidate command is configured to cause a cache to invalidate cache entries associated with the multi sample surface in order to prevent those entries from being written out to the frame buffer. The cache entries that are invalidated store data associated with the multi sample surface such as color data z data and the like. Because the invalidate command is received by the PROP unit after the anti alias resolve command the invalidate command is also halted by the PROP unit .

The screen space pipeline completes processing the batch of primitives when the pixel shader and raster operation unit have completed corresponding operations. As stated above the barrier command follows this work. When the barrier command reaches the back end unit the back end unit increments a barrier command counter to indicate that the back end unit has received a barrier command from one of the screen space pipelines .

If the barrier command counter indicates that a barrier command has been received from less than all of the screen space pipelines then the back end unit does not transmit a barrier release signal through feedback pathway to either PROP unit and both the first PROP unit and the second PROP unit continue to prohibit work received after the barrier command from being processed or from proceeding past the first PROP unit or the second PROP unit .

If the barrier command counter indicates that a barrier command has been received from each of the screen space pipelines then the back end unit transmits a barrier release signal through feedback pathway which causes both first PROP unit and second PROP unit to reset corresponding barrier flags. Resetting the barrier flags causes both first PROP and second PROP to begin processing work received after the barrier command including the anti alias resolve command and the invalidate command . Because the batch of primitives has completed processing in the pixel shader and in ROP sample data is available for the anti alias filter and thus the anti alias resolve command can proceed.

In several cache tile batches are illustrated. A first cache tile batch is associated with a first cache tile a second cache tile batch is associated with a second cache tile and a third cache tile batch is associated with a third cache tile . The first cache tile batch the second cache tile batch and the third cache tile batch are each generated by the first tiling unit . Similarly a first cache tile batch is associated with the first cache tile a second cache tile batch is associated with the second cache tile and a third cache tile batch is associated with the third cache tile . The first cache tile batch the second cache tile batch and the third cache tile batch are each generated by the second tiling unit . Each cache tile batch includes the batch of primitives the barrier command the anti alias resolve command and the invalidate command .

As is shown work associated with the anti alias resolve command for any particular cache tile cannot proceed past PROP until all of the work associated with rendering the sample surface has completed processing in both the first ROP and the second ROP . Preventing work associated with the anti alias resolve command from proceeding past PROP until all work associated with rendering the sample surface has completed allows the samples in the sample surface to be generated and available before the anti alias resolve command begins processing.

A barrier command is not needed between the anti alias resolve command and the cache invalidate command because commands in a cache tile batch are processed in application programming interface API order. This means that the cache invalidate command which is processed by ROP will not be processed until after operations associated with the anti alias resolve command in both the pixel shader and ROP are completed.

The first sample cache tile includes samples that have been already rendered by a pixel shader and invalidated by ROP indicated by the X symbol . The second sample cache tile includes samples that have been already rendered by the pixel shader but that have not been invalidated yet. The third sample cache tile also includes samples that have been rendered but not yet invalidated. The fourth sample cache tile includes no rendered samples.

The first final cache tile includes pixels that have been rendered. Pixels in the first final cache tile have been rendered because the samples in the first sample cache tile have already been rendered and invalidated. The second final cache tile includes some pixels that have been rendered but also includes some pixels that have not been rendered. Since the samples in the second sample cache tile have just recently been rendered the pixels in the second final cache tile have just started to be rendered.

The third final cache tile includes no rendered pixels because the entire third sample cache tile has not yet been rendered and thus a release signal has not yet been generated. Finally the fourth final cache tile includes no rendered pixels because no samples have been rendered for the fourth sample cache tile yet.

The techniques described above with respect to are sufficient when the anti alias filter only accepts as input samples from within the pixel for which the filter operation is being applied. However when the anti alias filter accepts samples from more than one pixel as input then the device driver transmits additional commands to the graphics subsystem in order to cause sample data to be available for the filter for each of the cache tiles. Because the anti alias filter accepts samples from more than one pixel as input the anti alias resolve command accepts as input sample data from both within the cache tile as well as from a border of pixels that surrounds the cache tile. This sample data must therefore be available to the anti alias resolve command upon execution so that the anti alias filter may blend sample data across cache tile boundaries.

All of the commands for executing an anti alias operation with a multi pixel filter are tiled by the tiling unit meaning that the tiling unit generates cache tile batches that each include the above mentioned commands. The commands transmitted by the device driver include the following a command to translate the scissor rectangle in a forward direction with respect to the traversal line that is towards cache tiles that are to be traversed in the future a command to render the sample surface a tiled barrier command a command to translate the scissor rectangle back to the default position that is to the position associated with the cache tile by default a command to resolve the sample surface a command to translate the scissor rectangle in a rearward direction with respect to the traversal line that is towards cache tiles that have already been traversed and a tiled cache invalidate command.

As described above each cache tile is associated with a portion of a render target . Processing for any particular cache tile occurs for the portion of the render target associated with the cache tile. However work associated with a cache tile may be configured to act on a portion of a render target that is offset with respect to the area of the render target normally associated with the cache tile. A modifiable scissor rectangle specifies whether and to what extent any work being processed by the pipeline is translated.

Because the scissor rectangle is translated forward for generating multi sample data for each cache tile a sample data for border portion is not generated during processing of any of the cache tiles. Therefore sample data for border portion is generated prior to beginning traversal of cache tiles along tile traversal line . This generation of sample data for border portion can be done with one of several techniques. In one such technique a cache tile is defined that occupies the space defined by border portion . The sample data is generated for this cache tile prior to beginning traversal of cache tiles along traversal line .

As shown a method begins at step where a tiling unit receives work from a world space pipeline and divides the work up by cache tile. Each cache tile includes a command to generate sample data a barrier command a command to resolve the sample data and a cache invalidate command. In step the pixel shader and ROP generate sample data for a cache tile. In step after generating the sample graphics data the pixel shader resolves the sample data for a cache tile to generate final pixel values. In step after generating the final pixel values the ROP unit invalidates the sample data for a cache tile. In step the tiling unit determines whether there are more cache tiles to process. If there are more cache tiles then the method returns to step . If there are no more cache tiles then the method proceeds to step where the tiling unit finishes processing cache tiles. At this point the tiling unit may accumulate primitives until the tiling unit decides to perform another flush operation.

As shown a method begins at step where a tiling unit receives work from a world space pipeline and divides the work up by cache tile. The work for each cache tile includes a command to generate sample data a barrier command a command to resolve the sample data a cache invalidate command and commands to translate a scissor rectangle. In step the pixel shader and ROP generate sample data for a cache tile with the scissor rectangle translated in a forward direction. In step after generating the sample data the pixel shader resolves the sample data for a cache tile to generate final pixel data with no scissor rectangle translate applied. In step after generating the anti aliased image the ROP unit invalidates the sample data for a cache tile with the scissor rectangle translated in a rearward direction. In step the tiling unit determines whether there are more cache tiles to process. If there are more cache tiles then the method returns to step . If there are no more cache tiles then the method proceeds to step where the tiling unit finishes processing cache tiles. At this point the tiling unit may accumulate primitives until the tiling unit decides to perform another flush operation.

In sum a graphics pipeline that includes a tiling unit receives a batch of primitives for rendering a sample surface from a world space section of the graphics pipeline. The tiling unit generates cache tile batches each associated with different cache tiles and transmits the cache tile batches to a screen space section of the graphics pipeline that includes a raster operations unit. The raster operations unit processes the primitives in each cache tile batch to generate samples for each cache tile.

A tiled barrier command included in the cache tile batches is configured to cause a pre raster operations unit to allow commands associated with generating sample data to proceed past the pre raster operations unit. The tiled barrier command is also configured to cause the pre raster operations unit to prevent commands received after the barrier command from proceeding past the pre raster operations unit until a raster operations unit has generated samples sample surface. Once the samples for the sample surface is generated the pre raster operations unit allows the commands associated with resolving the sample surface to continue down the pipeline. After the sample data has resolved and the final pixel values have been generated the graphics pipeline invalidates cache data associated with the sampled surface.

For multi sample anti aliasing in which resolving the sampled surface involves considering sample data corresponding to more than one screen pixel the tiling unit also includes scissor rectangle translate commands in the cache tile batches. The scissor rectangle translate commands cause the area of a render target on which the raster operations unit operates to shift by an amount specified by the scissor rectangle. Prior to generating samples for the sample surface the raster operations unit translates the cache tile scissor rectangle in a forward direction with respect to the direction of cache tile traversal.

This operation causes the raster operations unit to generate multi sample data for portions of the multi sampled image corresponding to several pixels within future cache tiles providing a cushion of pixel data for the resolve step for those future cache tiles. Prior to resolving the multi sampled image the raster operations unit translates the cache tile scissor to the original position of the cache tile scissor. This translate operation allows the portion of the multi sample data associated with the cache tile to be generated by the resolve operation. Finally prior to invalidating the cache entries associated with the multi sample image the raster operations unit translates the cache tile scissor in a rearward direction with respect to the direction of cache tile traversal. This operation causes the invalidation operation to invalidate data associated with several pixels from already traversed cache tiles which are no longer needed but to not invalidate the cushion of pixels needed for resolve the multi sample data associated with future cache tiles.

One advantage of the disclosed technique is that data dependencies between generating sample data and resolving the sample data are honored. Another advantage is that the sample data that is generated is not written out to the frame buffer thus reducing memory bandwidth consumption. Another advantage is that the disclosed techniques provide mechanisms for managing data dependencies and for reducing memory bandwidth consumption in graphics subsystem architecture that implements cache tiling and that includes multiple processing entities.

One embodiment of the invention may be implemented as a program product for use with a computer system. The program s of the program product define functions of the embodiments including the methods described herein and can be contained on a variety of computer readable storage media. Illustrative computer readable storage media include but are not limited to i non writable storage media e.g. read only memory devices within a computer such as compact disc read only memory CD ROM disks readable by a CD ROM drive flash memory read only memory ROM chips or any type of solid state non volatile semiconductor memory on which information is permanently stored and ii writable storage media e.g. floppy disks within a diskette drive or hard disk drive or any type of solid state random access semiconductor memory on which alterable information is stored.

The invention has been described above with reference to specific embodiments. Persons of ordinary skill in the art however will understand that various modifications and changes may be made thereto without departing from the broader spirit and scope of the invention as set forth in the appended claims. The foregoing description and drawings are accordingly to be regarded in an illustrative rather than a restrictive sense.

