---

title: Generalized contextual intelligence platform
abstract: One embodiment of the present invention provides a system for providing user information to a recommender. During operation, the system receives, from the recommender, a registration for notification of changes to a context graph. The context graph includes information about user behavior and/or user interests. Next, the system receives, from a mobile device, event data derived from contextual data collected using detectors that detect the mobile device's physical surroundings. The system modifies the context graph based on the event data. The system then determines that the modification to the context graph matches the registration, and sends a notification of context graph change to the recommender.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09208439&OS=09208439&RS=09208439
owner: PALO ALTO RESEARCH CENTER INCORPORATED
number: 09208439
owner_city: Palo Alto
owner_country: US
publication_date: 20130429
---
This disclosure is generally related to contextual intelligence. More specifically this disclosure is related to a method and system for collecting mobile device contextual information and facilitating efficient adaptation of a generic contextual intelligence system for customized applications.

As mobile devices equipped with technology to detect physical surroundings become more pervasive in our everyday lives software on the mobile devices that detect and make use of physical surroundings can increasingly contribute to improving the lifestyle of mobile device users. Such software includes context aware systems that may adapt to the computing environment including physical surroundings and make recommendations based on the physical surroundings. A context aware system on a mobile device detects the computing environment and adapts to changing conditions detected from the environment such as location and movement of the mobile device nearby devices and other surrounding conditions.

Such context aware systems may vary according to architecture and user model. A user model describes user activity and interests at different points in time including present and future activity. The system may recommend activities such as leisure activities based on the user model. Unfortunately it takes considerable time and expense to develop such context aware systems.

One embodiment of the present invention provides a system for providing user information to a recommender. During operation the system receives from the recommender a registration for notification of changes to a context graph. The context graph includes information about user behavior and or user interests. Next the system receives from a mobile device event data derived from contextual data collected using detectors that detect the mobile device s physical surroundings. The system modifies the context graph based on the event data. The system then determines that the modification to the context graph matches the registration and sends a notification of context graph change to the recommender.

In a variation on this embodiment the system receives from the mobile device additional event data including application event data and or operating system event data. The system then modifies the context graph based on the additional event data. The system determines that the modification to the context graph matches the registration and sends a notification of context graph change to the recommender.

In a variation on this embodiment the event data includes high level event data generated by the mobile device from contextual data.

In a variation on this embodiment the system receives a query for context graph data from the recommender and sends the context graph data to the recommender.

In a variation on this embodiment the system receives real time event data through a RESTful WebAPI and modifies the context graph data based on the received real time event data.

In a variation on this embodiment the system receives bulk upload of event data through an event posting interface and modifies the context graph data based on the received bulk upload event data.

The following description is presented to enable any person skilled in the art to make and use the embodiments and is provided in the context of a particular application and its requirements. Various modifications to the disclosed embodiments will be readily apparent to those skilled in the art and the general principles defined herein may be applied to other embodiments and applications without departing from the spirit and scope of the present disclosure. Thus the present invention is not limited to the embodiments shown but is to be accorded the widest scope consistent with the principles and features disclosed herein.

Embodiments of the present invention solve the problem of efficiently developing context aware systems by providing a generic contextual intelligence platform that may be adapted for specific applications. Such a contextual intelligence system facilitates real time processing of contextual information and support contextual application development for Web and mobile applications.

The generic contextual intelligence platform includes a client side architecture and a server side architecture. The client side architecture collects contextual data and sends processed contextual data to the server side architecture as event data. Contextual data describes a computing context detected by a mobile device client such as physical surroundings and or application and or operating system context. The server side architecture stores the contextual data and uses the contextual data to modify a graph containing user behavior and interest information. Applications may use information from the graph to modify application specific user models and generate recommendations.

The client side architecture collects contextual data by detecting a computing context including physical surroundings application and operating system context and analyzes and writes the collected data to storage. The client side architecture processes context detected through a hardware detector from an application or from the operating system and the resulting contextual data is stored as low level event data. Low level event data indicate events that are detected from context and not generated by the client side architecture. For example a low level event can be a walking pattern sensed by an accelerometer the selection of a button in an application or a screen capture. The client side architecture may generate high level events using the contextual data and send the high level events to a server. A high level event can be for example a user reading e mail. The client side architecture may also send event data to applications executing on the client.

The server side architecture receives event information from the client and may analyze the event information to modify a context graph. A context graph is an in memory model that stores facts and assertions about a user s behavior and interests. The server may also use a publish subscribe event system to send events to recommenders. A recommender is an application that recommends items or activities for a user. These recommenders maintain application specific user models using user information derived from the context graph. The server sends event data to a recommender when the event matches a subscription request from that particular recommender. The recommenders then modify their application specific user models with the user information and make recommendations based on the application specific user models.

In order to adapt the disclosed generic infrastructure to customized needs one need only provide customized activity detection modules customized user models and or customized recommenders. The infrastructure is designed as a modular structure and the different functions are compartmentalized and not dependent on each other. One can customize one or more modules for their particular application and or also use default modules. An engineer adapting the generic infrastructure may embed contextual intelligence in their application and even monetize the application with contextually aware features. By adapting a generic infrastructure one can save considerable time and expense in developing a customized contextual intelligence system.

Server stores analyzes and publishes the received event data. Server may modify a context graph using the event data. One can modify application specific user models by using user information stored in the context graph. Such application specific user models facilitate implementation of recommender applications.

Client side architecture includes physical detectors such as GPS accelerometer and compass . The physical detectors detect physical context surrounding a mobile device and the system provides abstractions for utilizing the physical detectors including a platform application programming interface API . Platform API facilitates communication with the devices and may preprocess the contextual data. Platform API then sends its output to a data logger and a client analytics package . The client analytics package analyzes the physical and application data and generates high level events to forward to the server. Multiple analytics components may run on the client. The system can also send captured application data to the data logger . Note that captured application data includes user events occurring within an application. The data logger may write the physical context data and the captured application data to a platform database via a database abstraction layer . Platform database stores historical traces to facilitate analysis of the data.

The system can collect contextual data using a number of different techniques. The system can obtain the contextual data either from inside a client application or via a specific data logger application. For example the system can collect contextual data directly from applications via embedded hooks. The system can also collect contextual data through the operating system including by capturing screens detecting click events and transferring event log files. Further the system can collect contextual data from devices such as GPS receivers accelerometers etc.

The client side architecture implements a centralized listener pattern that allows for connected applications to register to receive contextual events from the analytics system. There may be a number of applications and modules that register for and utilize contextual information. Using the centralized listener pattern the client can also transfer events to a centralized server system either as low level activity traces or as higher level events generated by the analytics systems.

An in memory publish subscribe system implements the centralized listener pattern to provide contextual events to client applications and to the HTTP server stub . The client side architecture allows applications to register for particular types of events. For example an application interested in location specific events may choose to register for GPS events. With client side analytics and interest registration the infrastructure can reduce the impact of a multi user system with a large volume of events thereby reducing the likelihood of overloading a server.

In one embodiment the HTTP server stub facilitates transmission of high level events to a remote server. The HTTP server stub can receive events from the publish subscribe system and transmit events using HTTP to a remote server system e.g. in JavaScript Object Notation JSON format . Note that one can configure the stub to customize transmission of events. In one embodiment the stub only relays events that are registered with the publish subscribe system.

Server side processing facilitates social applications applications that require a higher level of data processing than can be accomplished on a single client or applications that require a server side persistent state. For these scenarios requiring server side processing the client can upload data to the server either by uploading in real time or using bulk upload.

For continuous real time events upload the client can post JSON messages to a server based RESTful Web API. A RESTful web API is a web service implemented using HTTP and the principles of representational state transfer REST . REST is a style of software architecture for distributed systems such as the World Wide Web. The client can identify the real time events with a userid for the user the data is associated with. Real time upload of events allows the client to continuously update user state for real time applications.

For bulk uploads the client can use HTTP POST to upload large data files e.g. from a database . Application specific code can process such bulk uploads into a server side data store. Note that clients can use bulk upload for large blocks of data such as screenshots or extensive low level log files intended for analysis using machine learning techniques.

In as described with respect to a mobile device initially collects physical contextual data using GPS and compass as well as detect application events including user interactions . Mobile device may analyze contextual data and or generate high level events using client side analytics and transmit events to the server. The client can transmit both high level events and low level events to the server via an event posting interface and or a RESTful WebAPI see .

When the server receives events at the server side RESTful WebAPI the server can convert the events into internal message queue events. Using a message queuing architecture on the server allows the system to decouple event reception from event processing. Any module on the server can subscribe to the message queue either using a user identifier or otherwise.

The server may write the event data to storage analyze the data and or publish the event data. The server may write the data to storage for subsequent analysis. The server may transfer event information from an event posting interface to data store adapter . Such event information may be transferred via a real time event stream which may include streams of real time events for each user. The server may use a data store adapter to record events to low level storage such as low level event history database . Low level event history database can be for example a NoSQL database storing low level event history information.

Server side analytics can include machine learning modules for analyzing the event data. Components in server side analytics can access real time data from the publish subscribe event system or historical data from the low level event history database . Typically such components run in batch mode rather than real time. In one implementation such components may run during low load periods e.g. at night time in order to optimize user models. The system may redirect the processing output from such components back into the event processing system for transfer into a context graph. The server can also write the output from server side analytics into low level event history database .

The server may also publish event data to subscribers and may use some of the event data to modify a context graph as further discussed in . The server may publish events through a publish subscribe event system using multiple concurrent queues. Server side analytics may use a high level event stream to send events to publish subscribe event system .

In one implementation the server may use RabbitMQ for message queuing functionality. The server may also use high performance event processing subsystems for greater transaction volumes such as that based on OMQ or message passing interface MPI . OMQ is a high performance synchronous messaging library for use in scalable distributed or concurrent applications. MPI is a portable standardized message passing system that functions on parallel computers. In one implementation the system includes an embeddable stub that allows analytic components to post data from an application into publish subscribe event system where the data can be transferred to a context graph.

The server can also receive and combine data from multiple clients to leverage its greater processing power. In one embodiment the server may analyze data aggregated from a number of clients. For example the server may analyze co location events involving locations of a number of clients. To transfer data back to a client a server side application may push events into a client s publish subscribe system asynchronously using a long poll persistent push connection. For example the server may push notifications to the clients involved in the co location events. Note that the system may also use a long poll connection to deliver recommendations to clients. For example the system may inject recommendations as specially labeled messages into the event processing system which transfers the messages to the client for display via a long poll connection. Note that the system may also use traditional polling instead of long polling.

One embodiment of the present invention may also include a framework for developing machine learning components that include stubs providing access to stored event data and real time events and access to publish subscribe event system for posting events into the system. Machine learning modules can use a data driven approach in that their parameters are serializable into a database.

In one embodiment the system instantiates a machine learning component in an application using a low number of function calls. The system can instantiate a suitable component with data from the database. The system can then connect the component to the event processing system and activate the component for a particular user. In one implementation a web based authoring system can facilitate the design and provisioning of such functionality.

As illustrated in during operation event posting interface sends events received from clients to publish subscribe event system . Publish subscribe event system may send some events to machine learning modules such as machine learning module1 and machine learning module2 which form part of server side analytics . The machine learning modules may determine appropriate responses to events. The system may employ a number of different types of machine learning modules including classifiers re enforcement learners and other miscellaneous types. The system can train classifiers using historical data from the low level event history. The classifiers may also have a detection component which can run either in real time on the event stream or periodically on the data in the stored history. Re enforcement learners can also observe changes to the mobile device context via event observation and learn appropriate responses.

In one embodiment the system may store contextual data for each user. Each user is associated with a context graph that describes their current state. Context graph is a per user in memory graph based model that stores facts and assertions about user behavior and actions. Context graph is a database of information about the user. For example context graph may include data relating to the personal habits of the user. Such data may include that a user tends to drink coffee at four o clock or that the user tends to go to work at two o clock.

Context graph functions as a storage component of a generalized user model. A user model describes predicted current and future activities and interests for a user. The system can store data in context graph using a type less approach to data storage. Context graph may store data according to different data models including data models for entity relationship data and unstructured data. Note that context graphs can also be shared between users. In one embodiment the system can manage context graphs with greater numbers of nodes using cross module interconnections.

The system enters data into context graph through subscriptions to publish subscribe event system . A mapper modifies context graph after receiving information from publish subscribe event system . The components that transfer event information into context graph can be specially developed for specific applications. As discussed with respect to clients may also send and receive information directly to and from the context graph using a RESTful WebAPI .

A dependency system connects recommenders to context graph so that the system may notify recommenders of context graph changes. Changes to the data in context graph trigger changes and alerts via the dependency system . Such changes include topological changes and or changes to individual properties on objects e.g. nodes and edges in context graph .

Dependency system can transfer data from context graph into an application specific user model. Such an application specific user model may be used in a rule or mixed model based recommender or any other type of recommender.

In one embodiment when the dependency system detects the graph changes the changes trigger a recommender to compute rankings and or scores for recommendable items and or activities and or services. The recommender may push recommendations asynchronously to the client.

A recommender using the data in context graph can register for graph modification callbacks with dependency system . The recommender can use the callbacks in conjunction with graph queries and assertions to update application specific model values when graph data changes in context graph . The recommender may then generate and or modify recommendations based on the application specific model values.

Note that the data stored in context graph and the change notification mechanism is sufficient for many recommendation applications. However for more sophisticated applications such as a mixed model recommendation system one can add an interface layer for propagating changes from context graph to an application specific user model. Further one may also add a query language to the system so that the recommenders may use the query language to issue queries against the context graph thereby facilitating update of the application specific user model.

Two exemplary prototype applications utilizing application specific user models are discussed below. The first example is a rule based recommendation engine that uses dependency system to update rules. The second example is a mixed model content recommendation system that subscribes to the context graph and uses their output to affect changes to its variables. Additionally modules for combining recommendations are suggested below.

In one embodiment a system using a rule based recommendation engine may use the dependency system to update the status of rules which can push recommendations to a client. Changes to the context graph trigger re evaluation of the rule state. When the rule state changes the recommender makes recommendations via the association of a recommendable item with the rule. In a trivial case the recommender pushes recommendations to a client. More complex systems can vote on recommendations with the votes assembled via a ranking system.

In another embodiment a mixed model content recommendation system can utilize discrete variables to indicate user interest in particular subjects and can score or rank content that has similar variables indicating the content type. The mixed model system can subscribe to the context graph and use their output to affect changes to its variables. Each recommendable item can be characterized by a number of variables in a vector space. Variables can for example indicate ethnicity of restaurants. When changes are made to the context graph the recommender calculates recommendations by executing a calculation relating model factors with recommendation vector variables. The recommender then assigns each recommendable item a numerical score.

The system described herein may also include combiner modules that accept output from recommenders and combine the output to determine a recommendation score. For example a vote based combiner can score recommendations according to the number of votes they receive. This is suitable for combining the output from a number of rule based recommenders. As another example a combiner may also select a best recommendation from among multiple recommendation scores to determine an output recommendation score.

The data structures and code described in this detailed description are typically stored on a computer readable storage medium which may be any device or medium that can store code and or data for use by a computer system. The computer readable storage medium includes but is not limited to volatile memory non volatile memory magnetic and optical storage devices such as disk drives magnetic tape CDs compact discs DVDs digital versatile discs or digital video discs or other media capable of storing computer readable media now known or later developed.

The methods and processes described in the detailed description section can be embodied as code and or data which can be stored in a computer readable storage medium as described above. When a computer system reads and executes the code and or data stored on the computer readable storage medium the computer system performs the methods and processes embodied as data structures and code and stored within the computer readable storage medium.

Furthermore methods and processes described herein can be included in hardware modules or apparatus. These modules or apparatus may include but are not limited to an application specific integrated circuit ASIC chip a field programmable gate array FPGA a dedicated or shared processor that executes a particular software module or a piece of code at a particular time and or other programmable logic devices now known or later developed. When the hardware modules or apparatus are activated they perform the methods and processes included within them.

The foregoing descriptions of various embodiments have been presented only for purposes of illustration and description. They are not intended to be exhaustive or to limit the present invention to the forms disclosed. Accordingly many modifications and variations will be apparent to practitioners skilled in the art. Additionally the above disclosure is not intended to limit the present invention.

