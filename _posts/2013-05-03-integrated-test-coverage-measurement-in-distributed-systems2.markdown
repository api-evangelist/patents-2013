---

title: Integrated test coverage measurement in distributed systems
abstract: Methods and systems for implementing test coverage measurement are disclosed. A first set of interactions among a set of production services are determined. The first set of interactions comprises a plurality of service requests between individual ones of the set of production services. A second set of interactions among a set of test services are determined. The second set of interactions comprises a plurality of service requests between individual ones of the set of test services. A test coverage metric is generated. The test coverage metric indicates an amount of the first set of interactions that are covered by the second set of interactions.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09559928&OS=09559928&RS=09559928
owner: Amazon Technologies, Inc.
number: 09559928
owner_city: Reno
owner_country: US
publication_date: 20130503
---
Many companies and other organizations operate computer networks that interconnect numerous computing systems to support their operations such as with the computing systems being co located e.g. as part of a local network or instead located in multiple distinct geographical locations e.g. connected via one or more private or public intermediate networks . For example distributed systems housing significant numbers of interconnected computing systems have become commonplace. Such distributed systems may provide back end services to web servers that interact with clients. Such distributed systems may also include data centers that are operated by entities to provide computing resources to customers. Some data center operators provide network access power and secure installation facilities for hardware owned by various customers while other data center operators provide full service facilities that also include hardware resources made available for use by their customers. However as the scale and scope of distributed systems have increased the tasks of provisioning administering and managing the resources have become increasingly complicated.

Web servers backed by distributed systems may provide marketplaces that offer goods and or services for sale to consumers. For instance consumers may visit a merchant s website to view and or purchase goods and services offered for sale by the merchant and or third party merchants . Some network based marketplaces e.g. Internet based marketplaces include large electronic catalogues of items offered for sale. For each item offered for sale such electronic catalogues typically include at least one product detail pages e.g. a web page that specifies various information about the item such as a description of the item one or more pictures of the item as well as specifications e.g. weight dimensions capabilities of the item. In various cases such network based marketplaces may rely on a service oriented architecture to implement various business processes and other tasks. The service oriented architecture may be implemented using a distributed system that includes many different computing resources and many different services that interact with one another e.g. to produce a product detail page for consumption by a client of a web server.

While embodiments are described herein by way of example for several embodiments and illustrative drawings those skilled in the art will recognize that embodiments are not limited to the embodiments or drawings described. It should be understood that the drawings and detailed description thereto are not intended to limit embodiments to the particular form disclosed but on the contrary the intention is to cover all modifications equivalents and alternatives falling within the spirit and scope as defined by the appended claims. The headings used herein are for organizational purposes only and are not meant to be used to limit the scope of the description or the claims. As used throughout this application the word may is used in a permissive sense i.e. meaning having the potential to rather than the mandatory sense i.e. meaning must . Similarly the words include including and includes mean including but not limited to. 

Various embodiments of methods and systems for providing integrated test coverage measurement are described. Using the systems and methods described herein interactions between services e.g. call paths in a production environment may be monitored over a period of time. Similarly interactions between services e.g. call paths in a test environment may be monitored over a period of time. The interactions in the production environment may be compared to the interactions in the test environment. Based on the comparison a metric and or report may be generated to indicate the degree to which the test interactions cover the production interactions.

The test coverage measurement system may comprise one or more computing devices any of which may be implemented by the example computing device illustrated in . In various embodiments the functionality of the different services components and or modules of the test coverage measurement system e.g. interaction monitoring functionality call graph generation functionality and metric calculation functionality may be provided by the same computing device or by different computing devices. If any of the various components are implemented using different computing devices then the respective computing devices may be communicatively coupled e.g. via a network. Each of the interaction monitoring functionality call graph generation functionality and metric calculation functionality may represent any combination of software and hardware usable to perform their respective functions as discussed as follows.

The interaction monitoring functionality may monitor or track interactions between services in a service oriented system such as a system structured according to a service oriented architecture SOA . A service oriented architecture may include multiple services configured to communicate with each other e.g. through message passing to carry out various tasks such as business process functions. The services may be distributed across multiple computing instances and or multiple subsystems which are connected e.g. via one or more networks. In some embodiments such services may be loosely coupled in order to minimize or in some cases eliminate interdependencies among services. This modularity may enable services to be reused in order to build various applications through a process referred to as orchestration.

Service oriented systems may be configured to process requests from various internal or external systems such as client computer systems or computer systems consuming networked based services e.g. web services . For instance an end user operating a web browser on a client computer system may submit a request for data e.g. data associated with a product detail page a shopping cart application a checkout process search queries etc. . In another example a computer system may submit a request for a web service e.g. a data storage service a data query etc. . In general services may be configured to perform any of a variety of business processes.

The services described herein may include but are not limited to one or more of network based services e.g. a web service applications functions objects methods e.g. objected oriented methods subroutines or any other set of computer executable instructions. In various embodiments such services may communicate through any of a variety of communication protocols including but not limited to the Simple Object Access Protocol SOAP . In various embodiments messages passed between services may include but are not limited to Extensible Markup Language XML messages or messages of any other markup language or format. In various embodiments descriptions of operations offered by one or more of the services may include Web Service Description Language WSDL documents which may in some cases be provided by a service broker accessible to the services.

In one embodiment the interaction monitoring functionality may monitor interactions between services in a production environment and also in a test environment. The production environment may be a real world environment in which a set of production services A are invoked either directly or indirectly by interactions with a real world client consumer or customers e.g. of an online merchant or provider of web based services. In one embodiment the test environment may be an environment in which a set of test services B are invoked in order to test their functionality. The test environment may be isolated from real world clients consumers or customers of an online merchant or provider of web based services. In one embodiment the test environment may be implemented by configuring suitable elements of computing hardware and software in a manner designed to mimic the functionality of the production environment. Accordingly at least some of the individual test services may correspond to individual production services. In one embodiment the test environment may temporarily borrow resources from the production environment. In one embodiment the test environment may be configured to shadow the production environment such that individual test services represent shadow instances of corresponding production services. When the production environment is run in shadow mode copies of requests generated by production services may be forwarded corresponding to shadow instances in the test environment to execute the same transactions.

To monitor the interactions between production services A and the interactions between test services B lightweight instrumentation may be added to the services A and B. The instrumentation e.g. a reporting agent associated with each service may collect and report data associated with each inbound request outbound request or other service interaction e.g. a timer based interaction processed by a service. Further aspects of the service instrumentation interaction monitoring functionality and call graph generation functionality are discussed below with respect to .

Turning back to the call graph generation functionality may generate and store data indicative of a hierarchy of call pathways between services. The call pathways may represent inbound service requests and outbound service requests relative to a particular service. To process a given received request the system described herein may invoke one or more of the types of services described above. As used herein an initial request may be referred to as the root request. In various embodiments the root request may but need not originate from a computer system outside of the service oriented system described herein. In many embodiments a root request may be processed by an initial service which may then call one or more other services. Additionally each of those services may also call one or more other services and so on until the root request is completely fulfilled. Accordingly the particular services called to fulfill a request may be represented as a call graph that specifies for each particular service of multiple services called to fulfill the same root request the service that called the particular service and any services called by the particular service. For instance a call graph may in some cases be a deep and broad tree with multiple branches each representing a series of related service calls. The call graph generation functionality may use any suitable data and metadata to build the call graphs such as request identifiers and metadata associated with services and their interactions. The request identifiers and metadata are discussed below with respect to .

For clarity of description various terms may be useful for describing elements of a call graph. Note that the following terminology may only be applicable to services and requests of a given call graph. In other words the following terminology may only be applicable for services and requests associated with the same root request. From the perspective of a particular service any service that calls the particular service may be referred to as a parent service. Furthermore from the perspective of a particular service any service that the particular service calls may be referred to as a child service. In a similar fashion from the perspective of a particular request any request from which the particular request stems may be referred to as a parent request. Furthermore from the perspective of a particular request any request stemming from the particular request may be referred to as a child request. Additionally as used herein the phrases request call service request and service call may be used interchangeably. Note that this terminology refers to the nature of the propagation of a particular request throughout the present system and is not intended to limit the physical configuration of the services. As may sometimes be the case with service oriented architectures employing modularity each service may in some embodiments be independent of other services in the service oriented system e.g. the source code of services or their underlying components may be configured such that interdependencies among source and or machine code are not present .

As shown in a plurality of call graphs A may be generated for the production services A. Each of the call graphs A may be a hierarchical data structure representing a plurality of call paths between individual production services over a period of time. For example the call graphs A may be generated based on monitoring of the production services A for a sufficient length of time e.g. longer than a month to capture rare call paths. A plurality of call graphs B may also be generated for the test services B. Each of the call graphs B may be a hierarchical data structure representing a plurality of call paths between individual test services over a period of time. The period of time represented by the test call graphs B may differ from the period of time represented by the production call graphs A. For example the period of time represented by the test call graphs B may be shorter than the period of time represented by the production call graphs A.

In various embodiments the test services B may be invoked on any suitable basis to generate the call graphs B. In one embodiment the test services B may be executed based on a set of synthetic machine generated requests that are intended to mimic real world traffic. In one embodiment the test services B may be executed based on a subset of real world traffic e.g. a subset of requests captured by monitoring the production services A over a period of time. If the configuration of the test services B differs from the configuration of the production services A then the same set of initial requests or traffic may yield a different call graph for the test environment than for the production environment. The configuration of the test services B may differ if more services are included if fewer services are included and or if the parent child relationship between any of the services varies from the production environment to the test environment.

The metric calculation functionality may compare the production call graphs A to the test call graphs B and generate one or more metrics based on the comparison. In one embodiment the metric calculation functionality may generate a test coverage metric . The test coverage metric may indicate an amount such as a percentage of the call paths or other interactions in the production call graphs A that are represented by corresponding call paths or other interactions in the test call graphs B. In other words the test coverage metric may indicate the degree to which the test interactions cover the production interactions.

Any suitable technique may be used to generate the test coverage metric . In one embodiment for example the metric calculation functionality may walk both sets of call graphs to establish a correspondence between the nodes e.g. services and edges e.g. calls of the two sets of call graphs. In one embodiment a hash may be computed for each production path and each test path and a hash for the corresponding test path may be compared to the hash for the production path. The test coverage metric may be reported to one or more users with any suitable reporting or notification techniques. In one embodiment the test coverage metric may be reported to the same user s who initiated a test coverage measurement process including interaction monitoring call graph generation and metric calculation.

Accordingly the test coverage metric may measure the completeness of a set of tests relative to the real world operation of a distributed service oriented system. If the test coverage metric is sufficiently high and if the performance of the tested system is also sufficient then a user may choose to deploy the tested configuration into production under the assumption that it will continue to perform well. By generating the test coverage metric once and then running new tests the test coverage metric may be used to measure how well the introduction of new tests improves the test coverage. By generating the test coverage metric once modifying the configuration of the test services B and then running additional tests the test coverage metric may also be used to measure how well the configuration change improves the test coverage.

As shown in a first set of call graphs may be determined based on the interactions among the set of production services. The first set of call graphs may include a plurality of call paths between individual ones of the set of production services. The first set of call graphs may be stored as one or more data structures representing the production services and the call paths between the production services.

As shown in a plurality of interactions among a set of test services in a test environment may be monitored over a period of time. In one embodiment the set of test services may generally correspond to the set of production services. The period of time for monitoring the test services may differ from the period of time for monitoring the production services. In one embodiment the interactions among the set of test services may be monitored by tracking service requests using a respective reporting agent for each of the test services. For example the service requests may include one or more inbound service requests one or more outbound service requests and or one or more other service interactions.

As shown in a second set of call graphs may be determined based on the interactions among the set of test services. The second set of call graphs may include a plurality of call paths between individual ones of the set of test services. The second set of call graphs may be stored as one or more data structures representing the test services and the call paths between the test services.

As shown in a comparison may be performed between the second set of call graphs and the first set of call graphs. The comparison may determine differences and similarities with respect to the nodes and edges of the two sets of call graphs. As shown in based on the comparison a test coverage metric may be determined. The test coverage metric may indicate a percentage of the call paths in the first set of call graphs that are included in the second set of call graphs. Based on the sets of call graphs and the comparison a report may also be generated to indicate further differences between the production environment and the test environment.

In one embodiment the first set of call graphs may include a first plurality of clusters and the second set of call graphs may include a second plurality of clusters. Each of the clusters may include a plurality of related call paths representing different scenarios. In one embodiment the test coverage metric may indicate a percentage of the clusters in the first set of call graphs that are included in the second set of call graphs.

The test coverage measurement system may comprise one or more computing devices any of which may be implemented by the example computing device illustrated in . In various embodiments the functionality of the different services components and or modules of the test coverage measurement system e.g. interaction monitoring functionality call graph generation functionality and report generation functionality may be provided by the same computing device or by different computing devices. If any of the various components are implemented using different computing devices then the respective computing devices may be communicatively coupled e.g. via a network. Each of the interaction monitoring functionality call graph generation functionality and report generation functionality may represent any combination of software and hardware usable to perform their respective functions.

In various embodiments the report generation functionality may generate a test coverage report indicating various different types of information about the monitored interactions the call graphs A and B and any other information indicative of differences between the production environment and the test environment. In one embodiment related call paths may be clustered into scenarios. Test coverage may then be measured and reported on a scenario by scenario basis instead of or in addition to a path by path basis. In one embodiment therefore the test coverage metric and or test coverage report may indicate the degree to which the different scenarios in the production traffic are covered by the corresponding scenarios in the test traffic.

In one embodiment scenarios may be identified based on the similarity of the edit distance of their corresponding graphs. For example a service that calls ten services that each call ten services may have 10 10 potential call paths. By progressively clustering these 10 10 paths may be identified as part of one call pattern or scenario In one embodiment a string may represent the call path in linear form. Using any suitable heuristics the strings may be compared for their edit distance. If the edit distance is sufficiently small i.e. relative to some threshold then the corresponding call paths may be clustered together into the same scenario. If one call path is a subset of another and brings no new information to a call graph then that call path may be clustered. In this manner the clustering of production call paths into scenarios may simply the testing burden. Instead of measuring coverage on a path to path basis coverage may be measured on a scenario to scenario basis. The report may be two tiered to indicate the percentage of scenarios covered and the percentage of call paths covered within each scenario.

In one embodiment a probability of the call path occurring may be determined for each of the call paths in the production environment and also in the test environment. In one embodiment the test coverage report may indicate the probability of a particular call path occurring in production in comparison to the probability of the same call path occurring in testing. Any substantial differences in probability may be flagged in the report . In addition to reporting the coverage of call paths in testing the report may include the percentage of production traffic covered by the call paths in testing. For example the report may indicate that the tests covered 50 of the call paths but covered 95 of the actual production scenarios because those covered call paths are responsible for 95 of the production traffic.

The report may include a frequency distribution and or probability distribution relating to the production environment and or test environment. In one embodiment the report may indicate the frequency of particular interactions in the production environment and or in the test environment. The report may flag any differences in frequency between the production environment and the test environment e.g. if the difference in frequency is greater than a predefined threshold. In one embodiment the report may indicate the probability of the occurrence of particular interactions in the production environment and or in the test environment. The report may flag any differences in probability between the production environment and the test environment e.g. if the difference in probability is greater than a predefined threshold.

The report may include multiple test coverage metrics. The report may also include path by path results expressed in a tabular format. For example the report may include a table where each row in the table represents data for a particular call path. In the example shown below the first column represents the call path identifier of each particular call path the second column represents the number of occurrences of the call path in the first environment e.g. a production environment the third column represents the number of occurrences of the call path in the second environment e.g. a test environment the fourth column is a Boolean value indicating whether the call path was covered by i.e. present in the second environment and the fifth column indicates the number of occurrences of the path in the first environment that are also covered by the second environment 

Based on the data in this example the report may include two or more test coverage metrics. In this example a first metric may be a percentage representing the coverage of paths by the second environment i.e. unique paths with at least one occurrence in the second environment total paths 5 7 71.4 . Additionally a second metric may be a percentage representing the frequency of occurrences in the first environment that are covered by the second environment 461 1819 25.3 .

In one embodiment the report may indicate specific call paths or other interactions in the production call graphs A that are covered in the test call graphs B. In one embodiment the report may indicate specific call paths or other interactions in the production call graphs A that are not covered in the test call graphs B. For example if 1200 different upstream call paths that invoked a payment and 82 different downstream call paths that the payment invoked are identified in production traffic then the report may indicate that the tests covered 982 of the 1200 upstream call paths and 72 of the 82 downstream call paths. The report may indicate the percentages of the downstream call paths the upstream call paths and or the total call paths covered in the tests. The report may also indicate which call paths from the production traffic were not encountered in the tests. In one embodiment the report may provide examples of when the call paths not encountered in testing were encountered in production. If a new release under testing is actually intended to eliminate the call paths that were not covered in testing then the report may permit verification of their elimination.

In some cases services in the production environment may have side effects that would be undesirable in the test environment. For example a service that secures payment for a transaction from a credit card provider may be disabled from communicating with the credit card provider in the test environment. Although this service request may be made in the production environment but not in the test environment the report may be used to gain transparency into the lack of coverage in this case. By reporting the call paths that are invoked in production but not in the test scenario or vice versa the report generation functionality may give the user the ability to identify differences between the two environments.

The test coverage measurement system may comprise one or more computing devices any of which may be implemented by the example computing device illustrated in . In various embodiments the functionality of the different services components and or modules of the test coverage measurement system e.g. interaction monitoring functionality call graph and code coverage generation functionality and report generation functionality may be provided by the same computing device or by different computing devices. If any of the various components are implemented using different computing devices then the respective computing devices may be communicatively coupled e.g. via a network. Each of the interaction monitoring functionality call graph and code coverage generation functionality and report generation functionality may represent any combination of software and hardware usable to perform their respective functions.

In one embodiment the interaction monitoring functionality may monitor the interactions between the production services A and the interactions between test services B as described above with respect to . The interaction monitoring functionality may also assist in determining code coverage analysis for the two sets of services e.g. using instrumentation of the services.

The production services A may be implemented using a first set of program code and the test services B may be implemented using a second set of program code. In one embodiment the call graph and code coverage generation functionality may determine code coverage data A for the production services A. The code coverage data A may indicate which portions of the first set of program code were executed in generating the call graphs A. In one embodiment the code coverage data A may also indicate a percentage of the first set of program code executed in the plurality of interactions among the first set of services in the production environment. The call graph and code coverage generation functionality may also determine code coverage data B for the test services B. The code coverage data B may indicate which portions of the second set of program code were executed in generating the call graphs B. In one embodiment the code coverage data B may also indicate a percentage of the second set of program code executed in the plurality of interactions among the second set of services in the test environment.

In various embodiments the report generation functionality may generate a test coverage report indicating various different types of information about the monitored interactions the call graphs A and B the code coverage data A and B and any other information indicative of differences between the production environment and the test environment. In one embodiment by combining code coverage analysis with path coverage analysis the report may indicate the percentage of code covered e.g. executed in production in comparison to the percentage of code covered e.g. executed in testing. The report may indicate which code pathways were executed in which scenarios. In this manner the report may enable better decision making on behalf of administrators of the tested services.

Various embodiments of a system and method for tracking service requests may include a framework for tracking a series of requests that propagate through a service oriented system such as a system structured according to a service oriented architecture SOA . Such a system may include multiple services configured to communicate with each other e.g. through message passing to carry out various tasks such as business process functions. In some embodiments such services may be loosely coupled in order to minimize or in some cases eliminate interdependencies among services. This modularity may enable services to be reused in order to build various applications through a process referred to as orchestration.

Service oriented systems may be configured to process requests from various internal or external systems such as client computer systems or computer systems consuming networked based services e.g. web services . For instance an end user operating a web browser on a client computer system may submit a request for data e.g. data associated with a product detail page a shopping cart application a checkout process search queries etc. . In another example a computer system may submit a request for a web service e.g. a data storage service a data query etc. . In general services may be configured to perform any of a variety of business processes.

The services described herein may include but are not limited to one or more of network based services e.g. a web service applications functions objects methods e.g. objected oriented methods subroutines or any other set of computer executable instructions. In various embodiments such services may communicate through any of a variety of communication protocols including but not limited to the Simple Object Access Protocol SOAP . In various embodiments messages passed between services may include but are not limited to Extensible Markup Language XML messages or messages of any other markup language or format. In various embodiments descriptions of operations offered by one or more of the services may include Web Service Description Language WSDL documents which may in some cases be provided by a service broker accessible to the services.

To process a given received request the system described herein may invoke one or more of the types of services described above. As used herein an initial request may be referred to as the root request. In various embodiments the root request may but need not originate from a computer system outside of the service oriented system described herein. In many embodiments a root request may be processed by an initial service which may then call one or more other services. Additionally each of those services may also call one or more other services and so on until the root request is completely fulfilled. Accordingly the particular services called to fulfill a request may be represented as a call graph that specifies for each particular service of multiple services called to fulfill the same root request the service that called the particular service and any services called by the particular service. For instance a call graph may in some cases include a deep and broad tree with multiple branches each representing a series of related service calls.

For clarity of description various terms may be useful for describing elements of a call graph. Note that the following terminology may only be applicable to services and requests of a given call graph. In other words the following terminology may only be applicable for services and requests associated with the same root request. From the perspective of a particular service any service that calls the particular service may be referred to as a parent service. Furthermore from the perspective of a particular service any service that the particular service calls may be referred to as a child service. In a similar fashion from the perspective of a particular request any request from which the particular request stems may be referred to as a parent request. Furthermore from the perspective of a particular request any request stemming from the particular request may be referred to as a child request. Additionally as used herein the phrases request call service request and service call may be used interchangeably. Note that this terminology refers to the nature of the propagation of a particular request throughout the present system and is not intended to limit the physical configuration of the services. As may sometimes be the case with service oriented architectures employing modularity each service may in some embodiments be independent of other services in the service oriented system e.g. the source code of services or their underlying components may be configured such that interdependencies among source and or machine code are not present .

As described above a given parent request may result in multiple child service calls to other services. In various embodiments of the system and method for tracking service requests request identifiers embedded within such service calls or located elsewhere may be utilized to generate a stored representation of a call graph for a given request. In various embodiments such request identifiers may be stored in log files associated with various services. For instance a service may store identifiers for inbound requests in an inbound request log and or store identifiers for outbound requests in an outbound request log. In various embodiments call graph generation logic may generate a representation of a call graph from identifiers retrieved from such logs. Such representations may be utilized for diagnosing errors with request handling providing developer support and performing traffic analysis.

An origin identifier ID may be an identifier assigned to all requests of a given call graph which includes the initial root request as well as subsequent requests spawned as a result of the initial root request. For example as described above the service oriented systems of various embodiments may be configured to process requests from various internal or external systems such as client computer systems or computer systems consuming networked based services. To fulfill one of such requests the service oriented system may call multiple different services. For instance service A may be the initial service called to fulfill a request e.g. service A may be called by an external system . To fulfill the initial request service A may call service B which may call service C and so on. Each of such services may perform a particular function or quantum of work in order to fulfill the initial request. In various embodiments each of such services may be configured to embed the same origin identifier into a request of or call to another service. Accordingly each of such requests may be associated with each other by virtue of containing the same origin identifier. As described in more detail below the call graph generation logic of various embodiments may be configured to determine that request identifiers having the same origin identifier are members of the same call graph.

The manner in which the origin identifier may be represented may vary according to various embodiments and implementations. One particular example of an origin identifier may include a hexadecimal string representation of a standard Universally Unique Identifier UUID as defined in Request for Comments RFC 4122 published by the Internet Engineering Task Force IETF . In one particular embodiment the origin identifier may contain only lower case alphabetic characters in order to enable fast case sensitive comparison of request identifiers e.g. a comparison performed by the call graph generation logic described below . Note that these particular examples are not intended to limit the implementation of the origin ID. In various embodiments the origin ID may be generated according to other formats.

Transaction depth may indicate the depth of a current request within the call graph. For instance as described above service A may be the initial service called to fulfill a root request e.g. service A may be called by an external system . To fulfill the initial request service A may call service B which may call service C and so on. In various embodiments the depth of the initial request may be set to 0. For instance when the first service or root service receives the root service request the root service e.g. service A may set the transaction depth 120 to 0. If in response to this request the originating service calls one or more other services the transaction depth for these requests may be incremented by 1. For instance if service A were to call two other services B1 and B2 the transaction depth of the request identifiers passed to such services would be equivalent to 1. The transaction depth for request identifiers of corresponding requests sent by B1 and B2 would be incremented to 2 and so on. In the context of a call graph the transaction depth of a particular request may in various embodiments represent the distance e.g. number of requests between that request and the root request. For example the depth of the root request may be 0 the depth of a request stemming from the root request may be 1 and so on. Note that in various embodiments such numbering system may be somewhat arbitrary and open to modification.

The manner in which the origin identifier may be represented may vary according to various embodiments and implementations. One particular example of a transaction depth may be represented as a variable width base 64 number. In various embodiments the value of a given transaction depth may be but need not be a value equivalent to the increment of the previous transaction depth. For instance in some embodiments each transaction depth may be assigned a unique identifier which may be included in the request identifier instead of the illustrated transaction depth .

Interaction identifiers collectively referred to as interaction identifier s may each identify a single request or service call for a given call graph. For instance as described above service A may be the initial service called to fulfill a request e.g. service A may be called by an external system . To fulfill the root request service A may call service B which may call service C and so on. In one example the call of service B by service A may be identified by interaction identifier the call of service C by service B may be identified by interaction identifier and so on.

Note that in various embodiments separate service requests between the same services may have separate and unique interaction identifiers. For example if service A calls service B three times each of such calls may be assigned a different interaction identifier. In various embodiments this characteristic may ensure that the associated request identifiers are also unique across service requests between the same services since the request identifiers include the interactions identifiers .

Note that in various embodiments the interaction identifier may be but need not be globally unique e.g. unique with respect to all other interaction identifiers . For instance in some embodiments a given interaction identifier for a given request need be unique only with respect to request identifiers having a particular origin identifier and or a particular parent interaction identifier which may be the interaction identifier of the request preceding the given request in the call graph i.e. the interaction identifier of the request identifier of the parent service . In one example if service A were to call two other services B1 and B2 the request identifier of service B1 and the request identifier of service B2 would have separate interaction identifiers. Moreover the parent interaction identifier of each of such interaction identifiers may be the interaction identifier of the request identifier associated with the call of service A. The relationship between interaction identifiers and parent interaction identifiers is described in more detail below.

In various embodiments interaction identifiers may be generated randomly or pseudo randomly. In some cases the values generated for an interaction identifier may have a high probability of uniqueness within the context of parent interaction and or a given transaction depth. In some embodiments the size of the random numbers that need to be generated depends on the number of requests a service makes.

Request stack may include one or more of the interaction identifiers described above. In various embodiments the request stack may include the interaction identifier of the request to which the request identifier belongs. In some embodiments the request stack may also include other interaction identifiers such as one or more parent interaction identifiers of prior requests e.g. a stack or history of previous interaction identifiers in the call graph . In various embodiments the request stack may have a fixed size. For instance the request stack may store a fixed quantity of interaction identifiers including the interaction identifier of the request to which the request identifier belongs and one or more parent interaction identifiers.

In various embodiments the utilization of a request stack having a fixed length e.g. fixed quantity of stored interaction identifiers may provide a mechanism to control storage and bandwidth throughout the service oriented system. For example the service oriented system of various embodiments may in some cases receive numerous e.g. thousands millions or some other quantity of services requests per a given time period e.g. per day per week or some other time period such as requests from network based browsers e.g. web browsers on client systems or requests from computer systems consuming network based services e.g. web services . In some embodiments a request identifier adhering to the format of request identifier may be generated for each of such requests and each of any subsequent child requests. Due to the shear number of requests that may be handled by the service oriented systems of various embodiments even when the request stack of a single request identifier is of a relatively small size e.g. a few bytes the implications on storage and bandwidth of the overall system may in some cases be significant. Accordingly various embodiments may include ensuring that each request identifier contains a request stack equal to and or less than a fixed stack size e.g. a fixed quantity of interaction identifiers . Similarly various embodiments may include fixing the length of each interaction identifier stored as part of the request stack e.g. each interaction identifier could be limited to a single byte or some other size . By utilizing interaction identifiers of fixed size and or a request stack of a fixed size various embodiments may be configured to control the bandwidth and or storage utilization of the service oriented system described herein. For instance in one example historical request traffic e.g. the number of requests handled by the service oriented system per a given time period may be monitored to determine an optimal request stack size and or interaction identifier size in order to prevent exceeding the bandwidth or storage limitations of the service oriented system.

In various embodiments the utilization of a request stack having a fixed length e.g. fixed quantity of stored interaction identifiers may provide a mechanism to control one or more fault tolerance requirements of the system including but not limited to durability with respect to data loss and other errors associated with individual services and host systems as well as the entire service oriented system . For example in some embodiments the larger the size of the request stack e.g. the more interaction identifiers included within a given request identifier the more fault tolerant the system becomes.

In embodiments where request stack includes multiple interaction identifiers the request stack may serve as a history of interaction identifiers. For instance in the illustrated embodiment interaction identifier may represent a series of interaction identifiers in ascending chronological order where interaction identifier corresponds to the oldest service call and interaction identifier corresponds to the most recent service call .

In addition to the illustrated elements request identifier may in various embodiments include one or more portions of data for error detection and or error correction. Examples of such data include but are not limited to various types of checksums.

In the illustrated example each request identifier includes a request stack of a fixed size e.g. three interaction identifiers . In other embodiments larger or smaller request stacks may be utilized as long as the request stack includes at least one interaction identifier. Furthermore in some embodiments request stack sizes may be of uniform size across the service oriented system as is the case in the illustrated embodiment . However in other embodiments subsets of services may have different request stack sizes. For instance a portion of the service oriented system may utilize a particular fixed stack size for request identifiers whereas another portion of the service oriented system may utilize another fixed stack fixed stack size for request identifiers.

Referring collectively to and a representation of the receipt of an inbound service request or service call as well as the issuance of an outbound request by service is illustrated. Request identifiers and of may correspond to the like numbered elements of . As illustrated service may receive an inbound service request . Service may receive the inbound service request from another service within the service oriented system according to various embodiments. Inbound service request may include the requisite instructions or commands for invoking service . In various embodiments inbound service request may also include a request identifier which may include values for an origin identifier transaction depth and request stack as described above with respect to . In various embodiments request identifier may be embedded within inbound service request e.g. as metadata . For example according to various embodiments the request identifier may be presented as part of metadata in a service framework as part of a Hypertext Transfer Protocol HTTP header as part of a SOAP header as part of a Representational State Transfer REST protocol as part of a remote procedural call RPC or as part of metadata of some other protocol whether such protocol is presently known or developed in the future. In other embodiments request identifier may be transmitted to service as an element separate from inbound service request . In various embodiments request identifier may be located elsewhere and inbound service request may include information e.g. a pointer or memory address for accessing the request identifier at that location.

In response to receiving the inbound service request service may perform a designated function or quantum of work associated with the request such as processing requests from client computer systems or computer systems requesting web services. In various embodiments service may be configured to store a copy of request identifier within inbound log . In some cases service may require the services of another service in order to fulfill a particular request as illustrated by the transmission of outbound service request .

As is the case in the illustrated embodiment service may be configured to send one or more outbound service requests to one or more other services in order to fulfill the corresponding root request. Such outbound service requests may also include a request identifier based at least in part on the received request identifier . Request identifier may be generated by service or some other component with which service is configured to coordinate. Since outbound service request is caused at least in part by inbound service request i.e. request stems from request the outbound service request and the inbound service request can be considered to be constituents of the same call graph. Accordingly service or some other component of the service oriented framework may be configured to generate request identifier such that the request identifier includes the same origin identifier as that of the inbound service request . In the illustrated embodiment such origin identifier is illustrated as 343CD324. For instance in one embodiment service may be configured to determine the value of the origin identifier of the request identifier of the inbound service request and write that same value into the request identifier of an outbound service request. In various embodiments service or some other component of the service oriented framework may also be configured to generate request identifier such that the request identifier includes a transaction depth value that indicates the transaction depth level is one level deeper than the transaction depth of the parent request e.g. inbound service request . For instance in one embodiment any given call graph may have various depths that each have their own depth identifier. In some embodiments such depth identifiers may be sequential. Accordingly in order to generate request identifier such that it includes a transaction depth value that indicates the transaction depth level is one level deeper than the transaction depth of the parent request e.g. inbound service request service may be configured to determine the value of the transaction depth from the parent request sum that value with an increment value e.g. 1 or some other increment value and store the result of such summation as the transaction depth value of the request identifier of the outbound service request. In the illustrated embodiment the transaction depth value of the inbound request identifier is 3 whereas the transaction depth value of the outbound request identifier is 4.

In some cases transaction depth identifiers may instead have identifiers that are not necessarily related to each other sequentially. Accordingly in some embodiments service may be configured to determine the transaction depth value from the request identifier of the parent request. From that value service may determine the actual depth level corresponding to the transaction depth value e.g. via a lookup table that provides a sequential listing of transaction depth levels to corresponding transaction depth values . From that depth level service may be configured to determine the next sequential transaction depth e.g. via a lookup table that provides a sequential listing of transaction depth levels to corresponding transaction depth values as well as the transaction depth value corresponding to that transaction depth. Service may be configured to store such transaction depth value as the transaction depth value of the request identifier of the outbound service request.

Service may also be configured to generate request identifier of the outbound service request such that the request identifier has a request stack that includes an interaction identifier associated with the outbound service request and all of the interaction identifiers of the request stack of request identifier except for the oldest interaction identifier which in many cases may also be the interaction identifier corresponding to a request at the highest transaction depth level when compared to the transaction depth levels associated with the other interaction identifiers of the request stack. For example the root request may occur at transaction depth 0 a subsequent request may occur at transaction depth 1 another subsequent request may occur at transaction depth 2 and so on. In some respects the request stack may operate in a fashion similar to that of a first in first out FIFO buffer as described in more detail below.

To generate the request stack of request identifier service may be configured to determine the interaction identifiers present within the request stack of request identifier . Service may also be configured to determine the size of the request stack that is to be included within request identifier i.e. the quantity of interaction identifiers to be included within the request stack . In some embodiments this size may be specified by service another service within the service oriented system e.g. the service that is to receive request or some other component of the service oriented system e.g. a component storing a configuration file that specifies the size . In other embodiments the size of the request stack may be specified by service . In one embodiment the size of the request stack may be dynamically determined by service or some other component of the service oriented system . For instance service may be configured to dynamically determine the size of the request stack based on capacity and or utilization of system bandwidth and or system storage. In one example service may be configured to determine that bandwidth utilization has reached a utilization threshold e.g. a threshold set by an administrator . In response to such determination service may be configured to utilize a smaller request stack size in order to conserve bandwidth. In various embodiments a similar approach may be applied to storage utilization.

Dependent upon the size of the inbound request stack and the determined size of the outbound request stack as described above a number of different techniques may be utilized to generate the request stack of request identifier as described herein. In one scenario the size of the inbound request stack may be the same as the determined size of the outbound request stack as is the case in the illustrated embodiment. In this scenario if the size of the outbound service request stack is to be n interaction identifiers service may be configured to determine the n 1 most recent interaction identifiers of the request stack of the inbound request identifier. Service may be configured to embed the n 1 most recent interaction identifiers of the inbound request stack into the request stack of the outbound request identifier in addition to a new interaction identifier that corresponds to request issued by service . In the illustrated embodiment for each request identifier the oldest interaction identifier is illustrated on the leftmost portion of the request stack and the newest interaction identifier is illustrated on the rightmost portion. In the illustrated embodiment to generate the request stack of the outbound request identifier service may be configured to take the request stack of the inbound request identifier drop the leftmost e.g. oldest interaction identifier shift all other interaction identifiers to the left by one position insert a newly generated interaction identifier for the outbound request and embed this newly generated request stack in the request identifier of the outbound request.

In another scenario the size of the request stack of the inbound service request identifier may be less than the size of the determined request stack size for the outbound service request identifier . In these cases the request stack size of the outbound service request may enable all of the interaction identifiers of the request stack of the inbound service request identifier to be included within the request stack of the outbound service request identifier. Accordingly in various embodiments service may be configured to embed all of the interaction identifiers in the request stack of the outbound request identifier in addition to a new interaction identifier that corresponds to request issued by service .

In an additional scenario the size of the request stack of the inbound service request identifier may be greater than the size of the determined request stack size for the outbound service request identifier . For instance if the size of the request stack for the outbound service request identifier is m interaction identifiers and the size of the request stack for the inbound request identifier is m x interaction identifiers where x and m are positive integers service may be configured to determine the m 1 most recent interaction identifiers of the request stack of the inbound request identifier. Service may also be configured to embed such m 1 most recent interaction identifiers of the request stack of the inbound request identifier into the request stack of the outbound request identifier in addition to a new interaction identifier that corresponds to request issued by service .

As described above inbound request log may be managed by service and include records of one or more inbound service requests. In one embodiment for each inbound service request received service may be configured to store that request s identifier which may include an origin identifier transaction depth and request stack as illustrated within the inbound request log. In various embodiments service may also store within the log various metadata associated with each inbound service request identifier. Such metadata may include but is not limited to timestamps e.g. a timestamp included within the request such as a timestamp of when the request was generated or a timestamp generated upon receiving the request such as a timestamp of when the request was received by service the particular quantum of work performed in response to the request and or any errors encountered while processing the request. In various embodiments outbound request log may include information similar to that of inbound request log . For example for each outbound request issued service may store a record of such request within outbound request log . For instance service may for each outbound request store that request s identifier within outbound request log . As is the case with inbound request log service may also store within outbound request log various metadata associated with requests including but not limited to metadata such as timestamps and errors encountered.

Referring collectively to and each service within the service oriented system may include a log reporting agent such as log reporting agent . Log reporting agent may in various embodiments report the contents of inbound request log and or outbound request log to a log repository e.g. a data store such as a database or other location in memory . One example of such a repository is illustrated log repository of . Various protocols for transmitting records from the logs of a service to a log repository may be utilized according to various embodiments. In some embodiments the log reporting agent may periodically or aperiodically provide log information to the log repository. In various embodiments the log reporting agent may be configured to service requests for log information such as a request from the log repository or some other component of the service oriented system. In some embodiments in addition to or as an alternative to reporting log information from logs and log reporting agent may report log information to the log repository in real time in some cases bypassing the storage of information within the logs altogether . For instance as a request is detected or generated the log reporting agent may immediately report the information to the log repository. In various embodiments log data may specify for each request identifier the service that generated the request identifier and or the service that received the request identifier.

As illustrated in multiple services within the service oriented system may be configured to transmit respective log data to log repository . The data stored within log repository e.g. service request identifiers and associated metadata may be accessed by call graph generation logic . Call graph generation logic may be configured to generate a data structure representing one or more call graphs such as call graph data structures . As described above the particular services called to fulfill a root request may be represented as a call graph that specifies for a particular service called the service that called the particular service and any services called by the particular service. For instance since a root request may result in a service call which may propagate into multiple other services calls throughout the service oriented system a call graph may in some cases include a deep and broad tree with multiple branches each representing a sequences of service calls.

To generate such a call graph call graph generation logic may be configured to collect request identifiers e.g. request identifiers and that each include the same origin identifier. In the illustrated embodiment 563BD725 denotes an example of such an origin identifier. In various embodiments call graph generation logic may mine e.g. perform a search or other data analysis log data associated with various services in order to find a collection of request identifiers that correspond to the same origin identifier and thus correspond to the same root request e.g. root request .

In various embodiments inbound and outbound request logs may be maintained for each service. In these cases call graph generation logic may be configured to compare request identifiers in order to determine that a given service called another service in the process of fulfilling the root request. For example in one embodiment the call graph generation logic may compare a request identifier from a given service s outbound request log to the request identifier from another service s inbound request log. If a match is detected the call graph generation logic may indicate that the service corresponding to that outbound request log called the service corresponding to that inbound request log. For example call graph generation logic may discover a request identifier equivalent to request identifier within the outbound request log associated with service . In this example call graph generation logic may also locate a request identifier equivalent to request identifier within the inbound log of service . In response to this match call graph generation logic may indicate that an edge representing a service call exists between two particular nodes of the call graph e.g. the node corresponding to service and the node corresponding to service . The above described process may be repeated to determine the illustrated edges that correspond to request identifiers and . In other embodiments since the manner in which interaction identifiers are generated may ensure that each interaction identifier is unique for a given depth level and origin identifier the call graph generation logic may instead search for matching interaction identifiers between request identifiers of adjacent depth levels instead of searching for matching request identifiers.

In other embodiments only one type of log e.g. either inbound or outbound may be maintained for a given service. For example if only outbound request logs are maintained for each of the services then the call graph generation logic may utilize different techniques for determining an edge that represents a service call in the call graph data structure. In one example call graph generation logic may compare two request identifiers that have adjacent depth values. For instance in the illustrated embodiment the call graph generation logic may be configured to compare request identifier to request identifier since such request identifiers contain the adjacent depth values of 1 and 2. In this case the call graph generation logic may determine whether the most recent interaction identifier of request identifier e.g. B is equivalent to the 2nd most recent interaction identifier of request identifier e.g. B . For request identifier the 2nd most recent interaction identifier is evaluated since the most recent interaction identifier position will be fill with a new interaction identifier inserted by the service that generated request identifier in this case service . In the illustrated embodiment this comparison returns a match since the values for the interaction identifiers are equivalent. In response to such match the call graph generation logic may be configured to indicate within the data structure that an edge representing a service call exists between service and .

In various embodiments the call graph generation logic may be configured to generate a call graph in the presence of data loss. For instance consider the case where the service oriented system maintains outbound service logs and the log data for service is lost as might be the case in the event of a failure on the host system on which service runs or in the case of a failure of log repository . Since the request identifiers of various embodiments may include a request stack of multiple interaction identifiers multiple layers of redundancy may be utilized to overcome a log data loss. In this example since the outbound log data for service is lost request identifiers and may not be available. Accordingly the call graph generation logic may be configured to utilize a request identifier from a lower depth level to reconstruct the pertinent portion of the call graph. While request identifiers and may be not be available due to data loss the request identifier and is available. Since request identifier includes a stack or history of interaction identifiers that request identifier may be utilized to obtain information that would have been available if request identifier were not lost to data failure. Since request identifier has a depth level that is two levels lower than the depth level of request identifier the call graph generation logic may utilize the third most recent not the second most recent as was the case in the previous example interaction identifier. In this example the third most recent interaction identifier is evaluated since that position would contain the interaction identifier generated by service in the illustrated embodiment. If the call graph generation logic determines that the most recent interaction identifier of request identifier matches the third most recent interaction identifier of request identifier the call graph generation logic may determine that service called service even if the log data for service is unavailable e.g. due to data loss . Accordingly the call graph generation logic may indicate an edge representing a service call exists between service and service within the generated call graph data structure.

In addition to the request identifiers described above metadata relating to service interactions may be collected e.g. by the log reporting agent and used in the generation of call graphs. In various embodiments the metadata includes but is not limited to any of the following a timestamp an indication of whether the interaction is on the client side or server side the name or other identifier of the application programming interface API invoked for the interaction the host name data that describes the environment e.g. a version number of a production environment or test environment and or any other metadata that is suitable for building the call graphs and or comparing one set of call graphs to another. The collected metadata may be used to determine a graph of service interactions i.e. by identifying or distinguishing nodes and edges from other nodes and edges. The collected metadata may also be used to determine a correspondence between a node or edge in two different graphs e.g. a production graph and a test graph . If the metadata includes information identifying a test run and or the version of an environment then the metadata may enable reporting of test results e.g. test coverage metrics and or reports by test run and or environment.

In some embodiments various metadata may also be included within such call graph data structure such as timestamps the particular quantum of work performed in response to a given request and or any errors encountered while processing a given request. For example the illustrated services may record timestamps of when a request is received when a request is generated and or when a request is sent to another service. These timestamps may be appended to the call graph data structure to designate latency times between services e.g. by calculating the time difference between when a request is sent and when it is received . In other cases metadata may include error information that indicates any errors encountered or any tasks performed while processing a given request. In some embodiments such metadata may include host address e.g. an Internet Protocol address of a host in order to generate a graph structure that indicates which host machines are processing requests note that in some embodiments host machines may host multiple different services .

The system and method for tracking service requests described herein may be configured to perform a variety of methods. The call graph generation logic described herein may be configured to receive multiple request identifiers each associated with a respective one of multiple service requests. Each given request identifier may include an origin identifier associated with a root request a depth value specifying a location of the associated service request within a sequence of service requests and a request stack including one or more interaction identifiers assigned to a service request issued from one service to another service. For example receiving multiple request identifiers may in some cases include receiving log data that includes such request identifiers. For instance the call graph generation logic may receive log data directly from host systems that host the services of the service oriented system described herein. In some cases the call graph generation logic may receive log data from one or more log repositories such as log repository described above. In general the call graph generation logic may utilize any of the techniques for obtaining request identifiers described above with respect to call graph generation logic .

The call graph generation logic may further based on multiple ones of the request identifiers that each include an origin identifier associated with a particular root request generate a data structure that specifies a hierarchy of services called to fulfill that particular root request wherein based on one or more of the interaction identifiers and one or more of the depth values the generated data structure specifies for a given service of said hierarchy a parent service that called the given service and one or more child services called by the given service. For example in various embodiments generating the data structure may include determining that each of a subset of the multiple request identifiers includes the same origin identifier as well as indicating each associated service request as a node of the hierarchy within the data structure. Examples of such nodes are illustrated in as services and . Generating such data structure may also include for each node within the hierarchy assigning the node to a level within the hierarchy based on the transaction depth value of the request identifier associated with the service request corresponding to that node. Examples of such depth level values are described above with respect to transaction depth of . Generating the data structure may also include determining that the request stack of a given node at a given level within the hierarchy includes an interaction identifier that is the same as an interaction identifier of the request stack of another node located within an adjacent level of the hierarchy. For instance the call graph generation logic may include any of the various interaction identifier comparison techniques described above with respect to . In response to determining such match the call graph generation logic may indicate a service call as an edge between said given node and said other node. Examples of such an edge are illustrated as the edges coupling the nodes of described above.

In various embodiments the techniques for analyzing request identifiers and generating a call graph may be performed on an incremental basis. For example as request identifiers are updated e.g. as logs and or log repositories receive new data the call graph generation logic described herein may be configured to incrementally update the generated call graph data structure to reflect the newly reported requests. In some embodiments the techniques described herein may be performed on a depth level basis. For example as request identifiers are received e.g. by the log repository or call graph generation logic described herein each identifier may be categorized e.g. placed in a categorized directory based on transaction depth.

In various embodiments the generated call graph data structures described herein may be utilized for diagnostic purposes. For instance as described above the call graph data structure may include metadata such as a record of error s that occur when processing a request. Because this metadata may be associated with specific nodes and or service calls various embodiments may include determining sources of errors or faults within the service oriented system. In some embodiments the generated call graph data structures described herein may be utilized for analytical purposes. For example based on call graph data structures generated as described herein various embodiments may include determining historical paths of service calls and or path anomalies. For instance various embodiments may include detecting that for a given root request one or more services are being called unnecessarily. For instance such services may not be needed to fulfill the particular root request. Accordingly in some embodiments such services may be culled from processing further requests similar to or the same as the root request that originally initiated the unnecessary service calls e.g. a re orchestration process may be employed to modify the particular services called for a particular type of request . By removing such unnecessary service calls various embodiments may conserve resources such as storage and or bandwidth. In other embodiments the generated call graph data structures described herein may be utilized for auditing purposes. For example in the case that the service oriented system provides network based services e.g. web services to consumers of such services who may provide remuneration for the consumption of services such consumers may desire to at least occasionally view information that confirms they are being charged in a fair manner. To provide such information to the consumer various embodiments may include providing the consumer with various records such as records that indicate how frequent they consume network based services and in what quantity. Such information may be generated based on the call graph data structures described herein.

In one embodiment the call graph generation logic may receive a first request identifier associated with an inbound service request. The request identifier may include an origin identifier associated with a root request a depth value specifying a location of the inbound service request within a sequence of service requests and a request stack including multiple interaction identifiers each assigned to a respective service request issued from one service to another service of multiple services. One example of receiving such a request identifier is illustrated in as the receipt of inbound service request identifier by service .

The call graph generation logic may also generate a new request stack. The new request stack may include all of the interaction identifiers of the first request identifier except for an oldest one of the interaction identifiers. For instance as illustrated in the request stack of outbound request identifier does not include 6F which is the oldest interaction identifier of the inbound service request identifier . The new request stack may also include a new interaction identifier associated with an outbound service request. For instance as illustrated in the request stack of outbound service request identifier includes a new interaction identifier 2C. 

The call graph generation logic may also generate a second request identifier associated with the outbound service request. The second request identifier may include the origin identifier a new depth value specifying a location of the outbound service request within the sequence of service requests and the new request stack. One example of such a second request identifier is illustrated as outbound service request identifier of .

In various embodiments the call graph generation logic may also generate the new depth value such that the new depth value is a result of incrementing the first depth value. For example in the illustrated embodiment of the depth value of the outbound request identifier i.e. 4 may be the result of incrementing the depth value of the inbound request identifier i.e. 3 . In various embodiments the call graph generation logic may store either of or both of the first request identifier and the second request identifier as log data accessible to one or more computer systems. For instance in the illustrated embodiment of the inbound and outbound request identifiers may be stored in inbound request log and outbound request log respectively.

One example system configuration for tracking service requests is illustrated in . As illustrated the various components of the example system are coupled together via a network . Network may include any combination of local area networks LANs wide area networks WANs some other network configured to communicate data to from computer systems or some combination thereof. Each of host systems and may be implemented by a computer system such as computer system described below. Call graph generation logic may be implemented as software e.g. program instructions executable by a processor of host system hardware or some combination thereof. Call graph data structures may be generated by host system logic and stored in a memory of host system . Log repository may be implemented as a data store e.g. database memory or some other element configured to store data coupled to network . In other embodiments log repository may be implemented as a backend system of host system and accessible to host system via a separate network. Host system may be configured to execute program instruction to implement one or more services . Such services may include but are not limited to one or more of network based services e.g. a web service applications functions objects methods e.g. objected oriented methods subroutines or any other set of computer executable instructions. Examples of services include any of the services described above. Host systems and services may be configured in a similar manner.

In various embodiments the various services of the illustrated embodiment may be controlled by a common entity. However in some embodiments external systems such as a system controlled by another entity may be called as part of a sequence of requests for fulfilling a root request. In some cases the external system may adhere to the request identifier generation techniques described herein and may integrate with the various services described above. In the event that an external system does not adhere to the various techniques for generating request identifiers as described herein the external system may be treated as a service that is not visible in the call graph or alternatively requests sent back from the external system may be treated as new requests altogether e.g. as root requests . In various embodiments the system configuration may include one or more proxy systems and or load balancing systems. In some cases the system configuration may treat these systems as transparent from a request identifier generation perspective. In other cases these systems may generate request identifiers according to the techniques described above.

In some embodiments the service oriented system described herein may be integrated with other external systems that may utilize different techniques for identifying requests. For instance the request identifiers described herein may in various embodiments be wrapped or enveloped in additional data e.g. additional identifiers headers etc. to facilitate compatibility with various external systems.

In at least some embodiments a computer system that implements a portion or all of one or more of the technologies described herein may include a general purpose computer system that includes or is configured to access one or more computer readable media. illustrates such a general purpose computing device . In the illustrated embodiment computing device includes one or more processors coupled to a system memory via an input output I O interface . Computing device further includes a network interface coupled to I O interface .

In various embodiments computing device may be a uniprocessor system including one processor or a multiprocessor system including several processors e.g. two four eight or another suitable number . Processors may include any suitable processors capable of executing instructions. For example in various embodiments processors may be general purpose or embedded processors implementing any of a variety of instruction set architectures ISAs such as the x86 PowerPC SPARC or MIPS ISAs or any other suitable ISA. In multiprocessor systems each of processors may commonly but not necessarily implement the same ISA.

System memory may be configured to store program instructions and data accessible by processor s . In various embodiments system memory may be implemented using any suitable memory technology such as static random access memory SRAM synchronous dynamic RAM SDRAM nonvolatile Flash type memory or any other type of memory. In the illustrated embodiment program instructions and data implementing one or more desired functions such as those methods techniques and data described above are shown stored within system memory as code i.e. program instructions and data .

In one embodiment I O interface may be configured to coordinate I O traffic between processor system memory and any peripheral devices in the device including network interface or other peripheral interfaces. In some embodiments I O interface may perform any necessary protocol timing or other data transformations to convert data signals from one component e.g. system memory into a format suitable for use by another component e.g. processor . In some embodiments I O interface may include support for devices attached through various types of peripheral buses such as a variant of the Peripheral Component Interconnect PCI bus standard or the Universal Serial Bus USB standard for example. In some embodiments the function of I O interface may be split into two or more separate components such as a north bridge and a south bridge for example. Also in some embodiments some or all of the functionality of I O interface such as an interface to system memory may be incorporated directly into processor .

Network interface may be configured to allow data to be exchanged between computing device and other devices attached to a network or networks such as other computer systems or devices as illustrated in for example. In various embodiments network interface may support communication via any suitable wired or wireless general data networks such as types of Ethernet network for example. Additionally network interface may support communication via telecommunications telephony networks such as analog voice networks or digital fiber communications networks via storage area networks such as Fibre Channel SANs or via any other suitable type of network and or protocol.

In some embodiments system memory may be one embodiment of a computer readable i.e. computer accessible medium configured to store program instructions and data as described above for implementing embodiments of the corresponding methods and apparatus. However in other embodiments program instructions and or data may be received sent or stored upon different types of computer readable media. Generally speaking a computer readable medium may include non transitory storage media or memory media such as magnetic or optical media e.g. disk or DVD CD coupled to computing device via I O interface . A non transitory computer readable storage medium may also include any volatile or non volatile media such as RAM e.g. SDRAM DDR SDRAM RDRAM SRAM etc. ROM etc that may be included in some embodiments of computing device as system memory or another type of memory. Further a computer readable medium may include transmission media or signals such as electrical electromagnetic or digital signals conveyed via a communication medium such as a network and or a wireless link such as may be implemented via network interface . Portions or all of multiple computing devices such as that illustrated in may be used to implement the described functionality in various embodiments for example software components running on a variety of different devices and servers may collaborate to provide the functionality. In some embodiments portions of the described functionality may be implemented using storage devices network devices or special purpose computer systems in addition to or instead of being implemented using general purpose computer systems. The term computing device as used herein refers to at least all these types of devices and is not limited to these types of devices.

Various embodiments may further include receiving sending or storing instructions and or data implemented in accordance with the foregoing description upon a computer readable medium. Generally speaking a computer readable medium may include storage media or memory media such as magnetic or optical media e.g. disk or DVD CD ROM volatile or non volatile media such as RAM e.g. SDRAM DDR RDRAM SRAM etc. ROM etc. In some embodiments a computer readable medium may also include transmission media or signals such as electrical electromagnetic or digital signals conveyed via a communication medium such as network and or a wireless link.

The various methods as illustrated in the Figures and described herein represent exemplary embodiments of methods. The methods may be implemented in software hardware or a combination thereof. In various of the methods the order of the steps may be changed and various elements may be added reordered combined omitted modified etc. Various ones of the steps may be performed automatically e.g. without being directly prompted by user input and or programmatically e.g. according to program instructions .

The terminology used in the description of the invention herein is for the purpose of describing particular embodiments only and is not intended to be limiting of the invention. As used in the description of the invention and the appended claims the singular forms a an and the are intended to include the plural forms as well unless the context clearly indicates otherwise. It will also be understood that the term and or as used herein refers to and encompasses any and all possible combinations of one or more of the associated listed items. It will be further understood that the terms includes including comprises and or comprising when used in this specification specify the presence of stated features integers steps operations elements and or components but do not preclude the presence or addition of one or more other features integers steps operations elements components and or groups thereof.

As used herein the term if may be construed to mean when or upon or in response to determining or in response to detecting depending on the context. Similarly the phrase if it is determined or if a stated condition or event is detected may be construed to mean upon determining or in response to determining or upon detecting the stated condition or event or in response to detecting the stated condition or event depending on the context.

It will also be understood that although the terms first second etc. may be used herein to describe various elements these elements should not be limited by these terms. These terms are only used to distinguish one element from another. For example a first contact could be termed a second contact and similarly a second contact could be termed a first contact without departing from the scope of the present invention. The first contact and the second contact are both contacts but they are not the same contact.

Numerous specific details are set forth herein to provide a thorough understanding of claimed subject matter. However it will be understood by those skilled in the art that claimed subject matter may be practiced without these specific details. In other instances methods apparatus or systems that would be known by one of ordinary skill have not been described in detail so as not to obscure claimed subject matter. Various modifications and changes may be made as would be obvious to a person skilled in the art having the benefit of this disclosure. It is intended to embrace all such modifications and changes and accordingly the above description is to be regarded in an illustrative rather than a restrictive sense.

