---

title: Method and apparatus for providing secure streaming data transmission facilities using unreliable protocols
abstract: The disclosure provides a method and apparatus for transmitting data securely using an unreliable communication protocol, such as User Datagram Protocol. In one variation, the disclosure describes retaining compatibility with conventional Secure Sockets Layer (SSL) and SOCKS protocols, such that secure UDP datagrams can be transmitted between a proxy server and a client computer in a manner analogous to conventional SOCKS processing. Further, the disclosure describes a network arrangement that employs a cache having copies distributed among a plurality of different locations. SSL/TLS session information for a session with each of the proxy servers is stored in the cache so that it is accessible to at least one other proxy server. Using this arrangement, cached SSL/TLS communication session information may be retrieved and used by a second proxy server to accept a session with the client device when the client device switches proxy servers.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09467290&OS=09467290&RS=09467290
owner: AVENTAIL LLC
number: 09467290
owner_city: San Jose
owner_country: US
publication_date: 20130819
---
The present application is a continuation and claims the priority benefit of U.S. patent application Ser. No. 13 004 812 filed Jan. 11 2011 now U.S. Pat. No. 8 533 457 which is a continuation and claims the priority benefit of U.S. patent application Ser. No. 11 927 362 filed Oct. 29 2007 now U.S. Pat. No. 7 870 380 which is a continuation and claims the priority benefit of U.S. patent application Ser. No. 09 783 146 filed Feb. 13 2001 now U.S. Pat. No. 7 360 075 which is a continuation in part and claims the priority benefit of U.S. patent application Ser. No. 09 782 593 filed Feb. 12 2001 now U.S. Pat. No. 7 353 380 the disclosures of the aforementioned applications are incorporated herein by reference.

U.S. patent application Ser. No. 09 927 362 is also related to U.S. patent application Ser. No. 09 783 147 filed Feb. 13 2011 now U.S. Pat. No. 7 383 329 which is incorporated herein by reference.

This invention relates generally to data transmission schemes and protocols. More particularly the invention provides a method and apparatus for securely transmitting data between two or more computer nodes using an unreliable protocol such as User Datagram Protocol UDP . Moreover the invention provides a method and apparatus by which a communication session with a computer using the secure transmission of the invention can be switched to another computer without having to generate a new session.

The well known Transmission Control Protocol Internet Protocol TCP IP has been used for many years to transmit data packets between computers. TCP provides a guaranteed delivery and ordering scheme for data packets such that two or more computers using TCP can rely on the protocol to ensure that any given packet will reach its destination in the order in which it was transmitted. Internet Protocol IP generally provides a point to point packet transmission service without guaranteed delivery. shows how an application program can be layered on top of TCP IP according to a conventional protocol stack. The popular Hyper Text Transport Protocol HTTP relies on the existence of a TCP connection between a client s browser and a server computer in order to fetch and display web pages.

Although TCP provides guaranteed delivery capabilities using built in mechanisms i.e. each application need not concern itself with reliability details one disadvantage of using TCP is that it can incur delays and other side effects when transmitting a stream of data. For example if two computers use TCP to transmit a packetized video stream the received packets may appear jerky because missing or dropped packets must be re transmitted before they can be re ordered into the received packet stream. Consequently TCP is not a good candidate for streaming data such as videoconferencing applications.

The well known User Datagram Protocol UDP provides a packet oriented transmission service for communicating between two computers such as a client computer and a server computer. In contrast to TCP and other guaranteed delivery protocols packets transmitted using UDP are not guaranteed to arrive at the destination computer. Moreover packets that are transmitted in a particular order may arrive at the destination computer out of order. Thus UDP is termed an unreliable transport protocol. In contrast to TCP and other guaranteed delivery protocols however UDP provides a more time sensitive delivery scheme making it more suitable for streaming media such as video data.

As applications such as videoconferencing have increased the importance of streaming media a need has arisen to provide secure streaming transmission facilities. For example many corporations need to transmit streaming video between a headquarters facility and one or more remote offices. The transmission may include sensitive information that the company needs to protect from unintended recipients or eavesdropping. Because neither TCP nor UDP provide such security they may be insufficient in themselves for such transmissions.

In recent years various attempts have been made to provide secure transmission facilities by enhancing guaranteed delivery protocols with encryption techniques. For example the Secure Sockets Layer SSL is a protocol that provides a secure channel between two machines such as a server computer and a client computer. The secure channel is transparent yet encrypted between client and server such that nearly any protocol that can be run over TCP can be run over SSL with only minimal modifications. Indeed SSL TLS security and fault detection rely on TCP or a similar guaranteed delivery protocol to order packets and guarantee delivery. After undergoing various revisions SSL was renamed Transport Layer Security TLS and adopted by the Internet Engineering Task Force IETF as reflected in RFC 2246. The term SSL TLS will be used to refer collectively to these two closely related protocols . A principal application of SSL TLS is on line shopping wherein consumers transmit sensitive credit card information using HTTP protocols and web browsers in a secure manner.

Because most Internet protocols operate over TCP connections SSL TLS provides a convenient scheme for securely transmitting data between two or more computers such as a client computer and a server computer. shows architecturally how an application can use SSL TLS to transmit secure data over a reliable connection such as TCP. As is conventional the steps for securely transmitting data using SSL TLS generally include the following 

Because of its transparent nature any TCP based protocols e.g. HTTP FTP etc. or any similar guaranteed delivery protocol can be operated over TLS. Further details of SSL and TLS are provided in a book entitled SSL and TLS Designing and Building Secure Systems by Eric Rescorla ISBN 0 201 61598 3 published by Addison Wesley.

Unfortunately reliance on TCP or other guaranteed delivery protocols renders SSL TLS susceptible to the same performance problems that TCP incurs. For example using SSL TLS to transmit streaming video data incurs the same costs and penalties e.g. jerky video that the underlying TCP incurs. By its nature SSL TLS requires the use of a reliable connection such as provided by TCP because they will terminate a connection if a packet is dropped or received out of order.

In recent years a protocol known as Private Communication Technology PCT was proposed although it was never commercially successful. PCT was an attempt to extend SSL to secure datagram traffic using so called stream cipers . For example PCT used a different header format 4 bytes 2 length and 2 record type from SSL 5 bytes 1 record type 2 version number 2 length . The handshaking message bodies also contained a different beginning format PCT used 4 bytes 2 handshake type 2 record flags while SSL uses only 1 byte handshake type . PCT datagram support used the following format 

The proposed PCT mechanisms imposed various performance tradeoffs. For example although the PCT mechanism could be used with stream ciphers it is likely to be much slower because of additional hashing and key schedule creation to process every single record. In other words it uses a different key for every datagram which is computationally costly. Key schedule setup can be expensive for some block ciphers. Moreover PCT did not provide a mechanism for integration with the SOCKS or other multiprotocol proxies.

Conventional wisdom states that UDP is not suitable for secure communications. The Rescorla book identified above for example specifically states that UDP does not provide reliable transport and so SSL cannot be successfully run over UDP because records might be arbitrarily lost or reordered which would look like an active attack to the SSL implementation. Consequently the prior art teaches away from using UDP in combination with SSL to transmit secure data. Yet UDP would be a good match for many streaming media applications which can tolerate occasionally dropped data packets but not delays that occur in TCP. For example a videoconference that is broadcast in real time can tolerate an occasionally missing video frame but not the jerkiness that occurs when missing packets are retransmitted and reordered. Moreover user session terminations occur frequently with standard UDP sent over standard SSL.

Some protocols rely on both TCP and UDP to transmit high performance data such as video or audio streaming. REALAUDIO for example is believed to use both TCP and UDP wherein TCP is used for signaling e.g. start stop while UDP is used to transmit data packets for the streaming content. However the UDP datagrams are transmitted in the clear rendering them susceptible to interception or attack.

A protocol known as KERBEROS used mainly in academic circles provides security by encrypting UDP datagrams. The mechanism used by KERBEROS to provide datagram security is specified in RFC 1964. However it is not compatible with SSL TLS protocols and thus has not found widespread use. One of the primary reasons that KERBEROS has not been commercially successful is that it is complex to operate and not streamlined for widespread use in network processing. In particular network based security software must interoperate efficiently with web servers and proxy servers to control and secure user access. In general simpler protocols have been favored for fast processing and distributed systems.

KERBEROS also uses separate encryption mechanisms namely key establishment handshakes to communicate secure UDP and TCP traffic. However it may be desirable to reduce computational and network traffic overhead by integrating those under a single standard security protocol such as SSL running on a multiprotocol proxy server standard such as SOCKS. KERBEROS also adds a random key field for packet identification to extend the data record in a conventional manner for purposes of initializing the encryption algorithm. However this requires additional computation and network traffic as KERBEROS has a separate sequence number in the data record. It may be advantageous in some systems to have a single field serving both purposes.

UDP and SSL are standards in the software industry. UDP is used for processing datagrams while SSL provides secure communication. At the same time the adoption of multiprotocol proxy servers such as those running the popular SOCKS protocol provide a means for combining industry standard communications protocols such as TCP and UDP in one system. Until recently it has not been possible to do so because of the incompatibility of UDP and SSL. To understand this problem and the limitations it creates for management of network communications under a single proxy server protocol such as SOCKS it is first necessary to understand how SOCKS processes information.

The SOCKS protocol provides a generic proxying protocol for traversing firewalls and other boundaries. Version 5 of this protocol described in IETF RFC 1928 provides features such as authentication and UDP support. shows a conventional approach for connecting to a server through a firewall by means of a proxy server and the SOCKS protocol. As shown in a client computer communicates with an application server through a proxy server . The system may include a firewall not shown that acts as an application layer gateway between networks. Application server typically offers TELNET FTP SMTP and HTTP access. Client computer includes an application e.g. a web browser and a SOCKS client . Proxy server includes a SOCKS server and a proxy function . In accordance with SOCKS version 5 which provides security features client application can obtain services from server as follows.

First client application makes a request to connect to server . Next SOCKS client detects the requested connection and is aware that communication with server must be handled via proxy server . Consequently SOCKS client sends a request to SOCKS server to establish a TCP connection. Proxy function establishes a connection with server and all further communication between client application and server goes through SOCKS server and proxy function . As is conventional SOCKS uses SSL TLS to establish a secure connection with client and may demand a password before permitting the connection to be established. The architecture of restricts access to server at a single point e.g. proxy server and carries some of the load of communicating with server in a way that penetrates firewalls. Because they rely on SSL TLS to provide security the connections in necessarily rely on TCP or a similar guaranteed delivery protocol .

The architecture of can also be used to transmit nonsecure UDP datagrams. This scheme involves negotiating a UDP port connection between client and proxy server such that nonsecure UDP datagrams are transmitted through the port whereas secure commands are transmitted over the secured SSL TLS TCP connection. Such a scheme has sometimes been referred to as naked UDP mode reflecting the fact that the UDP datagrams are unsecure. A system employing this technique has been commercially available from Aventail Corporation of Seattle Wash. for several years. In general SOCKS client adds a SOCKS header to each record transmitted from client which is stripped off by SOCKS server before being transmitted to server .

As described above it is not possible to securely transmit UDP datagrams in the context of SSL TLS due to SSL TLS s reliance on TCP to provide a reliable connection service. However it would be advantageous to provide a secure UDP service in the scheme of such that proxy server could facilitate high performance video streaming between client and server without compromising the security of the data. Consequently one challenge is to find a way to operate both secure TCP and secure UDP through proxy server preferably using SSL as the security layer and SOCKS as the multiprotocol proxy server. More generally it would be desirable to find a way to retain compatibility with the SSL TLS standard without incurring the overhead and disadvantages caused by their reliance on TCP.

In addition to being unable to be successfully run over UDP the SSL TLS protocols offer another drawback. In the example described above the client device initiates a secure protocol session with the proxy server by completing a full SSL TLS handshake with the proxy server . During this handshake the client computer and the proxy server exchange SSL TLS version numbers cipher settings session specific data authentication certificates and other information that they need to communicate with each other using the SSL TLS protocol. Using this information both the client computer and the proxy server generate the same master secret key which in turn is used to generate individual session keys. These session keys are symmetric keys used to encrypt and decrypt individual groups of information exchanged during the session and to verify the integrity of exchanged information.

As will be appreciated by those of ordinary skill in the art conducting a full SSL TLS handshake to initiate a SSL TLS session is time consuming and presents a heavy load on the network s resources both in terms of network communication traffic and in processing time for the client device and the proxy server . Once the proxy server has received the required SSL TLS session information in a full SSL TLS handshake however the proxy server may subsequently resume that SSL TLS session with the client computer using only a partial SSL TLS handshake. Advantageously the partial SSL TLS handshake is much quicker and consumes less network resources than the full SSL TLS handshake.

A problem with this arrangement occurs however if the connection between the client computer and the proxy server is terminated and the client computer then tries to establish communication with the application server through another proxy server . For example the first proxy server may have failed and be unavailable or a load balancer may simply have routed the new connection from the client device to the new proxy server to reduce the communication load on the first proxy server . In any case the new proxy server will not have the SSL TLS session information needed to resume the SSL TLS session with the client computer . Accordingly the client device and the new proxy server must conduct a full SSL TLS handshake in order to create a new SSL TLS communication session. This process is time consuming and may require a substantial amount processing time from both the client computer and the new proxy server . Moreover depending upon the state of the original session between the client device and the proxy server the loss of the previous session s state may be irreplaceable. For example if the state of the earlier session was established by exchanging data that cannot be duplicated then that session cannot be recreated.

To address this problem some network systems attempt to ensure that a terminated connection between a client computer and its associated proxy server is reestablished with that original proxy server rather than with a new proxy server device . For example some systems design a load balancer to recognize when the client device has established a session with a particular proxy server and then route all future connections from the client computer to that proxy server . This solution has a number of drawbacks however. It requires that the load balancer be very complex and perform a variety of functions. Further it does not address the situation that occurs if the initial proxy server becomes unavailable e.g. if it fails and simply cannot reestablish a connection with the client computer . It also does not address the situation where the first proxy server becomes overloaded with connections to other client computers. In effect this solution may prevent the load balancer from performing a load balancing function.

In view of the failure of conventional attempts to providing secure data transmission facilities without incurring the penalties and overhead inherent in reliable communication protocols there exists a need to provide such facilities to support high bandwidth applications such as secure videoconferencing. Moreover there is a need to provide secure data transmission services while retaining compatibility with SSL TLS. Further there is a need for a network arrangement that will allow a client computer to switch between a communication connection with a first proxy server to a second proxy server while maintaining the state of a SSL TLS session established between the client computer and the first proxy server. Preferably such a network arrangement should permit such a switch from a connection with a first proxy server to a connection with a second proxy server even if the first proxy server becomes unavailable due to failure or other problems.

The present invention overcomes the aforementioned problems by providing a method and apparatus for transmitting encrypted data over an unreliable protocol such as UDP. In one variation a special bit is set in data records which when received by a proxy server causes the records to be diverted to special processing. The special processing may include use of a nonce to detect the existence of repeat records and use of an initialization vector that permits the proxy server to decrypt a record without reference to data in any other record. Data records that do not have the special bit set are processed according to conventional SSL TLS processing.

Further the invention provides a network arrangement that employs a cache having copies distributed among a plurality of different locations. According to the invention SSL TLS session information for a session with any of the proxy servers is stored in the cache so that it is accessible to at least one other proxy server. Using this arrangement when a client device switches from a connection with a first proxy server to a connection with a second proxy server the second proxy server can retrieve SSL TLS session information from the cache corresponding to the SSL TLS communication session between the client device and the first proxy server. The second proxy server can then use the retrieved SSL TLS session information to accept a session with the client device. According to some embodiments of the invention identical copies of the cache are stored for each proxy server in the network arrangement and each proxy server accesses its own copy of the cache to obtain necessary SSL TLS session information. With other embodiments of the invention a copy of the cache is maintained at a single source e.g. a redundant set of cache storage devices that is accessible to all of the proxy servers in the network arrangement.

Other features and advantages of the invention will become apparent with reference to the following detailed description and the figures.

In contrast to the system of proxy server includes two types of SOCKS processing a conventional SOCKS processing function and a modified SOCKS processing function . Record detector receives server bound records from SOCKS client and depending on whether a particular bit has been set indicating that the records are secure UDP records routes them through a software switch to either conventional SOCKS processing function or modified SOCKS processing function . Details of modified SOCKS processing function are provided below.

The architecture shown in allows proxy server to operate either with conventional SOCKS clients such as SOCKS client of or with SOCKS clients that have been modified to operate in accordance with the principles of the present invention modified SOCKS client which uses unreliable protocols such as UDP to transmit encrypted data. Moreover both types of clients can be simultaneously accommodated. In one embodiment both UDP and TCP protocols can be operated on the same proxy server. Further details of the modified processing are provided below. Proxy function operates essentially in the same manner as proxy function of .

There are many variations on the architecture of that fall within the inventive principles. As one example record detector can be optional. As another example if client and proxy server agree during an initialization sequence that all subsequent UDP datagrams between them will be transmitted according to a modified encryption scheme as described herein it may not be necessary to flag and evaluate each record to determine whether it conforms to one protocol or the other. It is of course also possible to implicitly designate the record type by way of other fields such that the type of record and resulting processing will be evident from the other fields. Of course as with naked UDP a secure TCP message can be combined with the present invention to contain keys or other encryption records in support of secure UDP. Moreover the functions of proxy server can be incorporated into server or another computer rather than requiring a separate proxy server to implement these functions. Finally it will be apparent that encrypted records can be transmitted from client computer to proxy server and vice versa such that a bi directional secure communication path is established.

As shown in a first byte of plaintext is encrypted using an encryption function such as the conventional Data Encryption Standard DES . A session encryption key that is shared between the sender and recipient e.g. SOCKS client and SOCKS server and an initialization vector IV are input to the encryption function and the resulting encrypted ciphertext is produced. In accordance with the SSL TLS standard this ciphertext is embedded in a record including a header and a MAC that is generated via hashing function as a function of key the plaintext and a sequence number that is incremented for each record. The resulting record is transmitted to proxy server over a TCP connection previously established as part of the initial handshaking between client and proxy server . The first initialization vector can be agreed upon between the sender and recipient during initialization.

In accordance with the SSL TLS standard the next plaintext is encrypted using the same key but using ciphertext generated from the previously transmitted record as the second initialization vector. This creates a link between successive records such that if the link is broken e.g. a packet is lost or corrupted the scheme will fail.

The second and subsequent incoming record is decrypted using session key but instead of initialization vector ciphertext A is used as the initialization vector. This matches the counterpart encryption scheme shown in . As described above if the recipient did not receive record or it was received out of order the decryption will not occur properly due to reliance on the chained initialization vectors needed for decryption. The error will be detected by MAC comparison function since the decrypted plaintext will not produce a MAC that matches the MAC in the incoming record.

As explained above the conventional SSL TLS reliance on previously transmitted data records requires that the underlying packet transmission mechanism be completely reliable. This is referred to as cipher block chaining and it requires reliable transmission of records because each successive data record is encrypted in reliance on the previously generated record with respect to DES cipher block chaining is defined by FIPS . Consequently if a record is received out of order or a data record is dropped the encryption scheme will break down and the sequence numbers will not match. If this happens according to the conventional SSL TLS scheme the TCP connection will be terminated and a new connection will be required to re establish data transmission. This security feature is intended to thwart hackers from interfering with the secure transmission scheme by inserting or manipulating data records between the client and proxy server. As explained above if UDP or another unreliable protocol were used to transmit the data according to the scheme of any missing or mis ordered records would immediately cause the connection to be lost. Note that for the purposes of simplification only a single block of ciphertext is shown in record of . In practice multiple blocks can be included in a single record and the cipher block chaining can be performed between successive blocks in the single record.

As shown in plaintext is encrypted using an encryption function such as the conventional DES encryption algorithm. The encryption is performed using a shared session key and a first initialization vector resulting in ciphertext which is used to create a modified SSL TLS record . Plaintext is also used in combination with different key and a first nonce value to create a MAC using hashing function . In contrast to the encryption scheme of the record includes nonce value and initialization vector which may comprise any preferably unique value e.g. random numbers . According to one embodiment a combined nonce IV value is generated using a strong random number generator e.g. one defined by the X9.62 standard produced by the commercially available RSA BSAFE CRYPTO C function .

In contrast to conventional SSL TLS schemes the nonce IV value is explicitly included as part of each record so that the record can be decrypted without reliance on a previously transmitted record. In certain embodiments the sequence number and initialization vector can be combined into a single value the nonce which can be an arbitrary or randomly generated number. In one embodiment the nonce is the same size as the sequence number in SSL e.g. 8 bytes and each value is unique i.e. the recipient can check them against a list of previously received records . The initialization vector may comprise the same size as a block of cipher e.g. 8 bytes and each value can be unique. In one variation it may be desirable to create a large Hamming distance between difference initialization vectors e.g. random numbers where each bit has a 50 chance of changing . Instead of appending separate nonces and initialization vectors a combined nonce IV value can be used. A cryptographically strong random number generator can be used to generate such numbers such as the RSA B SAFE CRYPTO C product sold by RSA Security Inc.

On the right side of plaintext is encrypted in a similar manner and a separate nonce and initialization vector is used to created data record .

Turning to the decryption of records and will now be described. The ciphertext from record is decrypted using shared session key and the initialization vector extracted from the data record to produce plaintext . The plaintext is fed through a hash function with key and the nonce extracted from the data record to produce a MAC that can be compared with the MAC extracted from the record.

The second record is decrypted in a similar manner except that it does not rely on values in the previously transmitted record to perform decryption. In this manner dropped or mis ordered records can still be handled.

According to a variation of the invention illustrated in multiple cipher blocks can be included in a single record and the ciphertext for each block can be decrypted with reference to the previous cipher block. The first ciphertext is decrypted in decryption function using initialization vector whereas successive ciphertext blocks are decrypted using the ciphertext of the previous block generally encryption would operate in an inverse manner . A single MAC value can be calculated on the basis of concatenated plaintext blocks and .

As described above the nonce and IV can be combined into a single value such that the same value is used both as an IV and as a unique identifier for MAC calculation.

In one variation the explicitly transmitted nonce is used to determine whether a previously received record has been received a second time. If so the protocol optionally terminates the connection or generates a warning since such a situation might be indicative of a hacker attack by so called replaying packets. Note that the latter is different from conventional SSL TLS which terminates the connection if a sequence number is received out of order. Moreover in certain embodiments the sequence number checking can be disabled or not used.

According to one aspect of the present invention in contrast to conventional SSL TLS initialization vectors are not chained across records. Each record includes a unique initialization vector and ciphertext blocks are chained together within a record as is conventional.

The use of a special UDP bit is only one technique for identifying records as conventional or modified SSL TLS records. In one embodiment no bit at all is needed and the assumption is made that every record conforms to the modified SSL TLS protocol as described herein. In other embodiments different flags or methods can be used to signify that a particular record should be processed according to the modified scheme set forth above. As one example during the initial handshaking that occurs between client and proxy server a message can be sent indicating that subsequent records will be received according to the aforementioned protocol. In another embodiment secure TCP can be used to exchange a set of MAC or IV values equivalent to the nonce for comparison and identification of the data record.

It should also be recognized that unreliable protocols other than UDP can be used to carry out the inventive principles and the invention is not limited to UDP datagrams. Moreover it should be appreciated that other encryption algorithms other than DES e.g. AES could be used and the invention is not limited in this respect.

Assume that a client wants to receive secure video data from an application server using the architecture shown in . That is server will transmit a stream of unreliably transmitted data using UDP to client through proxy server which will ensure that the records are sent in encrypted form to client . Beginning in step the client and proxy server establish a TCP connection. This step is conventional and conforms to the SOCKS protocols. In step the client and proxy server exchange credentials e.g. they negotiate security parameters according to conventional SSL schemes. In one variation of the invention client and proxy server also agree that UDP datagrams will be transmitted in encrypted form according to the principles described above. This can be done by transmitting a TCP packet new indicating that secure UDP datagrams will be transmitted using a particular port. The client can also send the server information regarding the target application server e.g. IP address and port . Note that although steps and are described as being performed using a reliable protocol they can of course be implemented using an unreliable protocol as long as the information needed for the encryption steps can be shared or communicated between computers in some manner.

In step a nonce IV is generated using for example a random number generator. In step a UDP datagram received from server is encrypted using the nonce and the other fields shown in are generated as required. For example each block of ciphertext can be chain block encrypted using the plaintext from the previous byte as the initialization vector and the MAC can be generated as is conventional. Moreover the nonce can be appended to the record as illustrated in .

In step a secure UDP bit is set in the record header to indicate that the record has been encrypted according to the modified SSL TLS SOCKS protocol. As explained above this bit is optional since the encryption information can be indicated in various other ways. Finally in step the record is transmitted from proxy server to client . In step the record is received in record detector and if the secure UDP bit is set the record is decrypted in step according to the modified SOCKS processing outlined above. Otherwise in step the record is decrypted according to conventional SOCKS processing.

Thus has been described a system and methods for transmitting data securely using an unreliable protocol such as UDP. The invention can be used in a wide variety of systems and applications including videoconferencing streaming media including audio video or both bulk transfers of files computer games over the Internet including near realtime gaming systems Internet telephony cellular telephone transmission wireless LANS and other system. The invention can provide advantages in the form of lower power consumption and less computer processing because the use of the inherently less complex and unreliable communication protocols e.g. UDP IP and others reduces the overhead and processing needed to transmit data securely. The invention can be used not only for communicating over the Internet but for use in other computer networks such as local area networks e.g. Ethernet peer to peer networks and the like. It is also suitable for securing various data types including nonstreaming media although its principal application is with UDP traffic for streaming media.

One network arrangement in which embodiments of the invention can be employed is illustrated in . The network shown in includes a number of client computers A B C D . . . and a plurality of proxy servers A B C D . . . . each of which is connected to an application server . Also a connection from each client computer is carried through a communication medium through a firewall to a load balancer which then routes communications from each client computer to one of the proxy servers A B C D . . . for relay to the application server . As previously noted any of the server and client computers can be implemented on a single computing unit or distributed across multiple computing units. Also multiple client and or server devices may be implemented on a single computing unit.

While only the single application server is shown in for ease of understanding the network can include a number of application servers each communicating with a number of proxy servers simultaneously. The number of client computers communicating with each proxy server in the network could be for example more than 100. Similarly the network could include a large number e.g. in excess of 100 of proxy servers A B C D . . . communicating with each application server . The communication medium may be any suitable medium. For example if the client computer A is configured to communicate with the proxy server A using a Web based communication program e.g. a browser then the communication medium may be the Internet. Alternately if the client computer D is configured to communicate with the proxy server B using a remote dial up communication program then the communication medium may be a direct plain old telephone system POTS connection.

In this example the client computers A B C D . . . communicate with the plurality of proxy servers A B C D . . . using either a conventional SSL TLS process for reliable communication protocols or the modified SSL TLS process for unreliable communication protocols described in detail above. As will become apparent from the following description the network arrangement allows a secure SSL TLS session connection from a client computer to a proxy server be switched to another proxy server without having to generate a new SSL TLS session for both sessions using the conventional SSL TLS procedure and the modified SSL TLS procedure for unreliable protocols discussed above.

Each of the proxy servers A B C D . . . in the network includes a cache memory . According to the invention each of the cache memories A B C D . . . contains a copy of a cache . The cache then contains a collection of SSL TLS session information based upon the various SSL TLS communication sessions between the multiple client computers A B C D . . . and the multiple proxy servers A B C D . . . . For example the cache contains SSL TLS session information corresponding to the SSL TLS session between the client computer A and the proxy server A.

SSL TLS session information for a SSL TLS session preferably includes all of the information necessary for a proxy server to resume that SSL TLS session with a client computer without having to generate a new SSL TLS session. For example the SSL TLS session information may include all of the information needed for a proxy server to resume a SSL TLS session with a client computer with only a partial SSL TLS handshake operation. Thus the SSL TLS session information should include the master secret key used to generate session keys for encrypting and decrypting data exchanged during the session. For various embodiments of the invention the SSL TLS session information should also include the peer certificate used to authenticate the client computer and or the user of the client computer .

In addition the SSL TLS session information may include a session identifier to identify the session e.g. an arbitrary byte sequence chosen by the proxy application to identify an active or resumable session a cipher specification specifying the bulk data encryption algorithm such as null DES etc. the message authentication check MAC algorithm such as MD5 or SHA and the cryptographic attributes such as the hash size used by the client computer and the proxy application . Still further the SSL TLS information may include the algorithm used to compress data prior to encryption and flag information indicating whether or not the session can be used to initiate new connections.

It should be noted that the term SSL TLS session as used herein refers to both sessions generated using the conventional SSL TLS processes for reliable communication protocols and the modified SSL TLS processes for unreliable communication protocol discussed above. Of course in order to allow a proxy server to resume a SSL TLS session without generating a new SSL TLS session the SSL TLS session information may also include information specific to the type of SSL TLS technique employed to originally generate the session. Thus if the SSL TLS session was generated using the modified SSL TLS process for unreliable communication protocol discussed above the SSL TLS session information may also include data e.g. a flag indicating an agreement between the client computer and the proxy server that all subsequent records exchanged during the session will be processed according to the modified SSL TLS process.

Accordingly each cache stores the information necessary to resume the SSL TLS sessions generated by both the convention SSL TLS process or the modified SSL TLS process described above between the multiple client computers A B C D . . . and the multiple proxy servers A B C D . . . . The cache thus includes the SSL TLS information necessary to resume the SSL TLS session between the client computer A and the proxy server A. Because each proxy server has copy of the cache in its associated cache memory if the connection between the client computer and the proxy server A is terminated the client computer A can establish a new session with any of the other proxy servers B C D . . . with the same SSL TLS session information as the earlier session between the client computer A and the proxy server A.

In one embodiment of the invention each cache memory A B C D . . . contains a complete copy of the cache . As each proxy server obtains new SSL TLS session information for a new session with a client computer or updated SSL TLS session information for an existing session with a client computer the proxy server sends the new or updated SSL TLS session information to each copy of the cache for storage.

The network embodying the invention provides significant advantages over a conventional network arrangement. Because a client computer can establish a session with any of the proxy servers using the SSL TLS session information obtained during a previous session the load balancer does not need to try to route a connection from a client computer back to the proxy server with which it had previously established a session. Thus the function of the load balancer can be simplified to distributing incoming communications from client computers A B C D . . . evenly among the available proxy servers A B C D . . . . Further even if a proxy server becomes completely unavailable i.e. it suffers a complete failure the client computer can establish a new session with another proxy server without having to recreate the SSL TLS session information previously obtained in the earlier session.

While the above described embodiment maintains a complete copy of the cache in each cache memory other embodiments of the invention may keep a copy of only a portion of the cache in each cache memory as shown in . With these embodiments however the SSL TLS session information for each session should still be stored in others of the multiple cache memories A B C D . . . so that each proxy server can access the SSL TLS session information. For example the SSL TLS session information for the session between the client A and the proxy server A may be stored in only the cache memory A associated with proxy server A cache memory B associated with proxy server B and cache memory C associated with proxy server C . If the proxy server A then becomes unavailable and the client computer A is switched to a connection with the proxy server B then the proxy server B can establish a session with the client computer A using the SSL TLS session information retrieved from its own memory cache B.

Moreover even if the client computer A is instead switched to a connection with a proxy server that does not have the SSL TLS session information in its cache memory e.g. proxy server D then that proxy server can request the SSL TLS session information from another available proxy server e.g. proxy server B that does have the appropriate SSL TLS session information in its cache memory . For example if the connection with the client computer A is switched to proxy server D that proxy server D can sequentially request the SSL TLS session information from the other available proxy servers until it receives the SSL TLS session information in reply. Alternately the proxy server D may issue simultaneous requests to all of the other available proxy servers and employ e.g. the SSL TLS session information in the first received reply.

The above described embodiments of the invention may be referred to as peer configuration type embodiments as the proxy servers alone are responsible for maintaining the cache . With these peer configuration embodiments of the invention maintaining copies of the entire cache or copies of overlapping portions of the cache in each cache memory A B C D . . . requires that each proxy server transmit new or updated SSL TLS session information to multiple cache memories in a write process. Preferably this write process is performed using a reliable communication technique that requires a positive acknowledgement from the receiving device so that each proxy server can confirm that its associated cache memory has processed the new or updated SSL TLS session information. If the number of proxy servers in the network is relatively small the type and amount of SSL TLS session information being saved by the proxy servers is relatively stable and the total amount of SSL TLS session information in the cache is relatively small then writing the necessary SSL TLS session information to each cache memory A B C D . . . with this configuration using a reliable positive acknowledgement based communication technique will not create a large resource overhead for the network . For example if the network only has nine proxy servers then writing new or updated SSL TLS session information to each proxy server does not consume an inordinate amount of the network s resources.

If on the other hand the type of SSL TLS session information stored in the cache must be updated frequently or the network includes a large number of proxy servers e.g. more than nine proxy servers then writing each piece of new or updated SSL TLS session information to every proxy server in the network using a reliable positive acknowledgement based communication technique may divert significant resources from the network . For example as the number of client computers increases even infrequent updates to multiple cache memories for each client computer may divert a significant amount of resources from the network . Similarly as the number of proxy servers increases writing new or updated SSL TLS session information to the cache memory of each proxy server using a reliable positive acknowledgement based communication technique may divert a significant amount of resources from the network . Further if the cache becomes too large it may be difficult to store a complete copy of the cache in the cache memory of a proxy server .

Accordingly a network implementing yet another embodiment of the invention is shown in . As with the previously discussed network arrangement the network includes a plurality of client computers A B C D . . . and a plurality of proxy servers A B C D . . . each of which are connected to the application server . As also previously described each client computer is connected to a load balancer through a communication medium and a firewall . The load balancer routes a connection from each client computer to one of the proxy servers e.g. from client computer A to proxy server A as shown in the figure . Also as with the network shown in each of the proxy servers A B C D . . . in the network has an associated cache memory A B C D . . . .

This embodiment of the invention additionally includes however a cache repository for storing one or more copies of the cache . As will be understood from the following explanation this embodiment is thus a two tiered configuration for storing the cache rather than a peer configuration as with the previously discussed embodiments of the invention. That is this embodiment has one tier of SSL TLS session information storage provided by the cache memories A B C D . . . of the proxy servers A B C D . . . and a second tier of SSL TLS session information storage provided by the cache repository .

As seen in the cache repository may include two cache memory server devices and . Each of these cache memory server devices and stores a complete copy of the cache . It should be noted however that the cache repository includes the two cache memory server devices and for redundancy. Thus if one of the cache memory server devices and fails or otherwise becomes unavailable the cache repository will still include a complete copy of the cache in the remaining cache memory server device. Other embodiments of the invention may alternately employ only a single cache memory server device as the repository if redundancy is not desired or three or more cache memory server devices if redundancy is a priority.

The cache memories A B C D . . . in the embodiment of might not store copies of the entire cache . Instead if the cache is larger than can be stored in the cache memories A B C D . . . each cache memory may store only a portion of the cache that relates to its associated proxy server . For example the portion of the cache copied into cache memory A may only include the SSL TLS session information for sessions established with the proxy servers A and B. Thus if the client computer A loses its connection to the proxy server A and then tries to establish a new session with the proxy server B the cache memory B may not contain SSL TLS session information for the earlier session with the proxy server A.

With this embodiment however when a proxy server receives a request to establish a session with a client computer for which it s memory cache does not have SSL TLS session information the proxy server can obtain the relevant SSL TLS session information from the cache repository . Thus in the foregoing example the proxy server B will obtain the SSL TLS session information for the client computer s A previous session from the cache repository . The new proxy server can then use the SSL TLS session information to establish a new session with the same SSL TLS session information as the previous session.

In addition to being useful where the size of the cache is too large for an entire copy of the cache to efficiently be stored in the cache memory of a proxy server this embodiment of the invention employing a cache repository will typically also be more efficient for networks with very large numbers of proxy servers A B C D . . . e.g. networks with more than ten proxy servers depending upon whether the type of SSL TLS session information being stored in the cache requires the cache to be updated frequently . With this embodiment each proxy server will normally need to use a reliable positive acknowledgement communication technique to write new or updated SSL TLS session information to only the cache repository thereby reducing the amount of communication traffic created by write operations and their confirmations across the network. The other proxy servers in the network can then obtain the new or updated SSL TLS session information through less reliable communication techniques or directly from the cache repository as will be discussed below.

It should be noted however that the two tiered arrangement shown in is exemplary. Those of ordinary skill in the art will appreciate that three tier four tier and other multiple tier arrangements can be employed depending upon the total size of the cache . For example if the size of the cache is too large to be efficiently stored in a single cache memory server device or then two or more cache repositories can be employed each storing a different portion of the cache . An entire copy of the cache may then be stored on a relatively inefficient storage device e.g. a bank of magnetic disk storage devices accessible to each of the cache repositories . Also each proxy server may then be associated with a particular cache repository and store some or the entire portion of the cache maintained by its associated cache repository . Various other embodiments will be apparent to those of ordinary skill in the art. Accordingly the term multi tier will be used hereafter to refer to embodiments of the invention having two or more hierarchical levels of devices storing at least a portion of the cache .

It also should be noted that with alternate embodiments of invention the different portions of the cache A B C D . . . stored in cache memories A B C D . . . may overlap. For example the portion of the cache A may contain SSL TLS session information that is also stored in the portion of the cache B and the portion of the cache C. Having some overlap between the different portions of the cache may reduce the amount of network traffic as a proxy server may already have SSL TLS session information for a new client computer seeking connection. Further each of the cache memories A B C D . . . may contain a copy of the entire cache as shown in . This embodiment of the invention may be preferable to the embodiment shown in when e.g. the size of the cache is sufficiently small to be stored in its entirety in a cache memory .

One possible embodiment of a proxy server will now be described with reference to . As seen in this figure the proxy server includes a proxy application a distributed cache application programming interface API a distributed cache application a communicator application and the cache memory . As will be discussed in detail below the proxy application performs the primary functions of the proxy server and includes each of the record detector the conventional SOCKS processing function the modified SOCKS processing function and the proxy function . That is the proxy application establishes secure communication with a client computer and relays messages between the client computer and the application server . The proxy application also sends SSL TLS session information for a session with a client computer to the distributed cache application via the distributed cache API .

The distributed cache API retrieves information from the cache memory and facilitates requests to send information to or delete information from the cache memory by passing them along to the distributed cache application . The distributed cache application stores information in the cache memory and also controls the exchange of information between the cache memory and other proxy servers and where applicable the cache repository . The distributed cache application communicates with the other proxy servers and the cache repository where applicable through the communicator application .

Accordingly after completing the full SSL TLS handshake the proxy application sends SSL TLS session information obtained from the full SSL TLS handshake to the cache memory for storage.

More particularly the proxy application may form a record for storage in the cache that includes a data field with the SSL TLS resumption information and a key field with the SSL TLS session identifier. The record may also include a time to live field with a time at which the record will expire and should be removed from the cache. In addition the record may include a record identifier pre pended to the key information i.e. the session identifier as will be discussed below. The proxy application passes this record through the distributed cache API to the distributed cache application for storage in the cache memory .

When the proxy application receives a request from a client computer to initiate a session the request will include a SSL TLS session identifier if that client computer has already established an SSL TLS communication with a proxy application either the same proxy application now receiving the request or another proxy application . The proxy application then passes the SSL TLS session identifier onto the cache API as a search key so that the API may request the distributed cache application to retrieve the SSL TLS information from the cache memory corresponding to the SSL TLS session identifier.

As previously noted the function of the distributed cache API is to retrieve an existing record from the cache memory using a GET operation. Further the some embodiments of the invention the distributed cache API facilitates requests to add delete or modify a record by passing these commands onto the distributed cache application . Thus the distributed cache application may perform ADD DELETE and UPDATE operations on the cache memory . Preferably the ADD operation adds a record to the cache memory based upon the information in the record s key field even if the record for that key already exists in the cache memory . The DELETE operation removes a record from the cache memory while the UPDATE operation updates a record already existing in the cache memory . Also the distributed cache application may have the capability forcing a purge of each of the cache memories A B C D . . . .

It should be noted that the cache API will first attempt to complete a GET operation by obtaining the requested record from the local copy of the cache or the copy of the portion of the cache from the cache memory . With some preferred embodiments of the invention this request will be immediately successful as each cache memory stores a complete copy of the cache . If the requested record is not found in the local cache memory e.g. if the cache memory contains only a portion of the cache that does not have the requested record or a copy of the cache that has been corrupted however then the cache API will involve the distributed cache application to obtain the record from another source. With the peer configured embodiment of the invention shown in the distributed cache application will attempt to retrieve the requested record from one or more of the other proxy servers . In the multi tier configured embodiment of the invention shown in however the distributed cache application may instead attempt to retrieve the requested record from the cache repository .

Similarly when the distributed cache application adds updates or deletes a record from its local cache it also relays the corresponding add update or delete command to other devices in the network. For example in the peer configured embodiment of the invention shown in the distributed cache application will relay the command to each of the other proxy servers . In the multi tier configured embodiment of the invention shown in however the distributed cache application may relay the command to the cache repository . The cache repository may then in turn relay the command to one or more of the other proxy servers . In this manner new or updated SSL TLS session information obtained by the proxy application of one proxy server is conveyed to the other proxy servers for use in future sessions with the client computer .

The storage of the SSL TLS session information in the cache by the distributed cache application will now be discussed. As will be appreciated by those of ordinary skill in the art as the number of proxy servers A B C D . . . increases the number of possible sessions between client computers and proxy servers A B C D . . . also increases. Accordingly the amount of SSL TLS session information stored in the cache will increase as well. This is true for both the peer distributed cache embodiment exemplified in and for the multi tiered distributed cache embodiment exemplified in . Accordingly SSL TLS session information should be stored in the cache so that it can be quickly and efficiently retrieved when necessary. Some preferred embodiments of the invention may therefore use a hash table to implement the cache and employ a hashing function to store and retrieve SSL TLS session information from the hash table.

As is known in the art and discussed above each piece of SSL TLS session information may be stored in the cache as part of a record. To enter a record into a hash table the distributed cache application performs a mathematical algorithm or hash operation on the key data in the key field e.g. the SSL TLS session identifier in order to map the key data to a numerical value. The SSL TLS session information identified by the key data is then stored in the hash table at a location sometimes referred to as a bucket corresponding to the numerical value against which the key data was mapped by the hash operation.

It should be noted that different key values may hash to the same hash value. Thus different records may be stored in the same location in or bucket in the hash value. Accordingly the hash operation preferably is selected so that an even distribution of hash values is obtained for the entire range of possible key data values. This is to ensure that a disproportionate number of records are not stored at a particular location in the hash table. That is it is preferable to employ a hash operation that evenly distributes records in the hash table. Thus when a record must be retrieved the average retrieval time for a record from any location in the hash table should be close to or the same as from any other location in the hash table.

According to some preferred embodiments of the invention the BUZhash hashing algorithm may be employed to evenly distribute SSL TLS session information records in the cache . This hashing algorithm is described in the article Hashing Concepts and the Java Programming Language by Robert Uzgalis 1996 which article is incorporated entirely herein by reference. As explained in the article the BUZhash algorithm conventionally operates as described below using the Sketchy Algorithm Language 

As discussed in the Uzgalis article when applied to a binary key value the BUZhash algorithm is particularly good at both generating a random number from any given key value and distributing the possible range of key values evenly in a table. Those of ordinary skill in the art will appreciate however that other hash algorithms known in the art may also be employed to store the SSL TLS session information in the cache . Also it will be apparent that new hash algorithms may be developed which can be used to store SSL TLS session information in the cache .

It should be noted that the distributed cache application treats all key values opaquely and operates under the assumption that all key values are unique. That is a unique key can only identify a single record in the cache . If a second record is added to the cache with the same key data as an existing record only one of the records will survive. It may be desirable however to use the same key data to refer to different records. For example as previously explained a SSL TLS session identifier may be used as key data to identify a record with SSL TLS resumption information. It may also be desirable to use the SSL TLS session identifier to identify a different record such as a record with authentication information for the user employing the client computer e.g. authentication information used to determine the data that the client computer s user may access from the application server .

Accordingly with various embodiments of the invention the cache API may provide for the use of a table identifier to distinguish between two different records that share the same key data. With these various embodiments of the invention the proxy application specifies a table identifier value that is pre pended to the key data as part of all calls through the cache API that involve the specification of key data. This allows the proxy application to in effect specify a virtual table to which the record identified by a particular key should be written to or read from. Of course as will be appreciated by those of ordinary skill in the art because all records of the cache are stored in a single hash table as described above this is only a logical construct.

Preferably the proxy application is the responsible for ensuring that each table identifier value is properly created and consistently applied. The proxy application may prepend the table identifier to the key and then pass the key to the cache API or alternatively to omit a buffer allocation operation and a copy operation the proxy application may pass the table identifier to the cache API and the cache API may prepend the table identifier. Because the cache API treats the table identifier as part of the key data the proxy application should preferably minimize the size of this value is as much as possible. Minimizing the size of the table identifier will allow for both optimal memory usage and optimal hashing performance.

The cache memory may be any type of memory medium. As will be appreciated by those of ordinary skill in the art however the cache memory may be preferably embodied in a readable and rewritable semiconductor memory device commonly referred to as RAM or main memory as this type of memory device allows information to be both quickly stored and retrieved.

Currently computers that are conventionally used as server devices may have such memories that can store between 2 gigabytes and 4 gigabytes of information. Thus approximately 2 4 million 1 kilobyte records can be stored in this type of memory device for each proxy server . Of course other types of memory medium such as a magnetic medium or an optical medium may alternately be employed.

According to some embodiments of the invention the communicator application provides for point to point i.e. acknowledgement based communication such as a unicast or TCP IP like communication between devices in the network. This type of communication is useful for example to synchronize SSL TLS session information between a newly initiated cache memory with an existing cache memory to ensure that all of the SSL TLS session information is accurately copied to the new cache memory before it is used by its corresponding proxy application .

This type of point to point communication e.g. unicast or TCP IP like communication provided by the communicator application can also be used by distributed cache application to update or add individual records in the cache memories of other proxy servers . As discussed above however with the embodiment of the invention shown in the overhead on the network resources for writing SSL TLS session information to each cache memory increases as the number of proxy servers increases. This is because each proxy server must write new or updated SSL TLS session information to each cache memory using a separate write process and then receive an acknowledgement of receipt of the write command from each cache memory in reply requiring a significant amount of network traffic and processor time for each proxy server in the network . More specifically the number of data packets that must be transmitted for each communication is 2N where N is the number of devices e.g. proxy servers receiving the communication.

Thus while the messages from the communicator application can be individually delivered to each appropriate recipient device in the network using e.g. point to point messaging this type of communication restricts the speed and efficiency of the invention. Accordingly with some preferred embodiments of the invention the communicator application also provides reliable multicast communication. As is known in the art a communication technique may be considered reliable if a data packets transmitted according to the technique are correctly ordered and duplicates can be discarded by the receiving party b the technique allows the receiving party to detect when data packets are missing from a transmission and c the technique provides a repair mechanism for the receiving party to obtain data packets missing from a transmission. Multicasting as is also well known in the art is a procedure whereby different network devices receive a message sent to a single network address.

Therefore the communicator application may use reliable multicast transmissions to add update or delete SSL TLS session information to or from the appropriate devices in the network. By using reliable multicasting these embodiments of the invention advantageously convey SSL TLS session information to a number of different devices simultaneously simply by transmitting the SSL TLS session information to a single shared multicast address. As previously noted the process of multicasting is well known in the art and several multicasting protocols such as the multicast transfer protocol MTP have been established to facilitate multicast communications.

One type of reliable multicast communication technique is the multicast communication with positive application acknowledgement. With this technique an application receiving the multicast transmission sends an acknowledgement back to the device originating the multicast transmission after the application has successfully processed the transmitted data. This type of reliable multicast communication may preferably be employed by the communicator application when relaying an ADD command from the distributed cache application to add SSL TLE session information to other cache memories in a peer configuration embodiment or to the cache repository in a multi tier configuration embodiment . In the peer configuration embodiment using a reliable positive acknowledgement multicast communication technique reduces the number of data packets that must be transmitted across the network for each communication to 1 N where N is the number of devices e.g. proxy servers receiving the communication. That is one communication is multicast to each of N devices and N positive acknowledgements are transmitted back to the originating device.

While reliable positive acknowledgement multicasting allows multiple devices to reliably receive updated or new SSL TLS session information simultaneously it may still require significant network resources to implement with the peer configuration. Because each device receiving a multicast message will need to individually acknowledge receipt of the communication to the network device from which the message originated in a network with a large number of proxy servers i.e. where N becomes large transmitting SSL TLS session information to each proxy server using reliable positive acknowledgement multicasting may still substantially impair the performance of the network.

For various applications of the invention however employing the multi tier configuration embodiments described above can reduce the use of network resources still further. With these embodiments new or updated state information need be transmitted to only the cache repositories using a reliable positive acknowledgement based communication technique. The proxy servers can then obtain the new or updated state information using a less reliable and thus typically less expensive in terms of network resources communication technique or obtain the new or updated state information from a cache repository when needed. Thus by using the multi tier configuration the number of packets that must be transmitted across the network for each addition of new or updated state information can be reduced still further to 1 n where n is the number of cache repositories receiving the new or updated state information. Because the number n of cache repositories will typically be much smaller than the number N of proxy server in the invention using the multi tier configuration can substantially reduce the use of network resource both in network traffic and processing time for individual resources required to cache new or updated state information.

With the multi tier configurations embodiments of the invention the proxy servers may then receive new or updated state information using for example a negative acknowledgment NACK technique to provide reliable multicast communication instead of the positive acknowledgment technique discussed above. With a negative acknowledgment multicast procedure the devices receiving the multicast message do not send an acknowledgment to the originating device upon receipt of the message. Instead each receiving device responds to the originating device only when it determines that it has missed a portion of the multicast communication.

For example some communication protocols require that each segment of data in a communication be sequentially numbered. Thus with the negative acknowledgement procedure a device receiving a communication according to such a protocol a might respond to the originating device only when it recognized that it had not received one of the data segments i.e. when it determined that it was missing a sequentially numbered data segment . Accordingly the communicator application according to various embodiments of the invention employs this technique to provide negative acknowledgements to another device in the network when it recognizes that it has not received data from that device.

Thus this negative acknowledgement reliable multicast arrangement can be used to deliver new or updated SSL TLS session information to each of the proxy servers in mult multi tier configuration embodiments of the invention thereby reducing the amount of communication traffic between the devices. Of course both a positive acknowledgement multicast communication and a negative acknowledgement multicast communication can be accomplished using a single multicast transmission at all of the relevant receiving devices. The device sending the transmission will then wait until receiving positive acknowledgements from all of the devices designated to communicate using the positive acknowledgement technique before sending another multicast transmission. The sending device will then also respond to any negative acknowledgement it receives according to the appropriate negative acknowledgement multicast communication protocol.

Conventional negative acknowledgement reliable multicast communication techniques present an additional problem however sometimes referred to as overrunning. In this situation the transmitting device sends data faster than one or more of the receiving devices can process it resulting in some of the transmitted data being lost. Further the transmitting device may send out too much information to receive a negative acknowledgment from another device indicating that a portion of the communication was lost. The extent of this problem is dependent upon the flow rate of communication traffic across the network however. When there is little communication traffic over the network however then the device initiating the multicast communication will be able to transmit information faster without overrunning a receiving device or missing a negative acknowledgement. Likewise when the communication traffic over the network increases the device initiating the multicast communication should transmit data more slowly to avoid overrunning a receiving device or missing a negative acknowledgement.

To address this problem some prior art negative acknowledgment multicast systems have proposed to set an absolute limit on the rate at which data is transmitted in a multicast communication to ensure that a negative acknowledgment from another device is received under all circumstances. This constant rate solution of the prior art however does not take into varying communication traffic flow across the network. Instead it always operates at the lowest possible efficiency to ensure that all negative acknowledgments are received. Other prior art systems use deterministic techniques with a master and token arrangement but these systems are relatively slow inefficient and complex.

Accordingly with some preferred embodiments of the invention the communicator application may provide negative acknowledgement reliable multicast communications in conjunction with a traffic flow rate detection process for determining the flow of communication traffic across the network. By accurately detecting the flow of communication traffic across the network the communicator application can correspondingly increase or decrease the rate at which it transmits data in the reliable negative acknowledgement multicast communication. This flow rate detection process will now be discussed with reference to .

As shown in these figures the communicator application has a data interface portion . The interface includes an output queue containing data segments to be multicast to other devices in the network. The interface also has an input queue containing data segments that have been received via multicast communications from other devices. According to these preferred embodiments of the invention the communicator application may include itself as a recipient of its own multicast transmission. Thus the communicator application will receive the data segment it transmitted to other devices in the network. By determining when a recently transmitted packet of data is received back at the communicator application the communicator application can determine the level of traffic flow in the network. For example with some preferred embodiments of the invention the communicator application may refrain from outputting another data segment from the output queue until it has received a previously transmitted data segment in its input queue .

As will be appreciated by those of ordinary skill in the art a number of variations for this flow rate detection technique are possible. For example the communicator application may postpone sending a new data segment e.g. Data shown in until the transmitted data segment immediately preceding it e.g. Data is received in the input queue see . Alternately the communicator application may determine an average number of data segments in the input queue that occur between its own transmitted data segments to ascertain the current flow conditions of traffic across the network. Numerous other modifications are also possible using the receipt of self transmitted data segments to determine flow conditions of traffic across the network. Further this technique can be employed even for communications that are not multicast. For example the communicator application may be able to send a copy of a point to point message to itself on a feedback loop. The communicator application can then use the occurrence of a message in the input queue that the communicator application has sent to itself to determine the amount of traffic on the network.

Also as previously explained the same multicast transmissions can be employed to deliver messages using both a positive acknowledgement multicast communication technique and a negative acknowledgement multicast communication technique. It should be noted that when the negative acknowledgement multicast communication technique is used in conjunction with flow detection the flow control feature used with the negative acknowledgement multicast technique will control the operation of the positive acknowledgement multicast technique. That is the sending device will not send out multicast transmissions to any device including those devices communicating with the positive acknowledgement multicast communication technique faster than permitted by the flow control feature.

This flow controlled negative acknowledgement multicast communication technique may therefore preferable be provided by the communication application in multi tier configurations of the invention to distribute new and updated SSL TLS session information to the proxy servers without significantly increasing the use of the network s resources both in terms of network traffic and in processing time required by the transmitting and receiving devices. Of course the communicator application may also provide communication techniques with no reliability for various administrative functions of the proxy server .

Thus by using reliable multicast communication techniques i.e. the positive acknowledgement multicast communication technique and the flow controlled negative acknowledgement multicast communication technique to deliver SSL TLS session information to multiple devices at the same time SSL TLS session information for a session between a proxy server and a client computer can be efficiently cached in a plurality of different cache memories and cache repositories . If a connection between a client computer and one proxy server is terminated another proxy server can then resume the session with the client computer using the cached SSL TLS session information.

Although specific embodiments of the invention have been described various modifications alterations alternative constructions and equivalents are also encompassed within the scope of the invention. For example in addition to storing SSL TLS session information described above other information may be conveniently stored in the cache . For example if a client computer and a proxy server designate one or more ports used to transmit encrypted data these ports may be stored in the cache to facilitate resuming a SSL TLS session with the client computer . Also if the client computer provides the IP address and port of the target application server this information may also conveniently be stored in the cache to facilitate resuming a SSL TLS session with the client computer . Further for SSL TLS sessions generated with the modified SSL TLS the cache may store nonces exchanged during the session. Thus if the session is resumed with a different proxy server the new server can detect when a datagram has already been received.

It should also be noted that the described invention is not restricted to operation within certain specific data processing environments but is free to operate within a plurality of data processing environments such as a distributed computer network environment a single stand alone computer system environment or other computing environments. Additionally although the present invention has been described using a particular series of transactions and steps it should be apparent to those skilled in the art that the scope of the present invention is not limited to the described series of transactions and steps.

There is inherent flexibility in creating the logic system flow tables and data structures used for programming the present invention. Data structures and values upon which calculations are performed may be explicit derived from other data imported from other sources or result from program calculations or logical operations all without departing from the spirit or limiting the scope of the invention. The algorithms for indexing searching and data processing in this patent may be substituted or modified to support various performance and or systems integration requirements all without deviating from the spirit or limiting the scope of the invention.

Further while the present invention has been described using a particular combination of hardware and software it should be recognized that other combinations of hardware and software are also within the scope of the present invention. The present invention may be implemented only in hardware or only in software or using combinations thereof.

The specification and drawings are accordingly to be regarded in an illustrative rather than a restrictive sense. It will however be evident that additions subtractions deletions and other modifications and changes may be made thereunto without departing from the broader spirit and scope of the invention as set forth in the claims.

Reference numerals in the appended method claims identifying steps are for convenience only and are not intended to imply a necessary ordering of the steps. It is therefore to be understood that within the scope of the appended claims the invention may be practiced otherwise than as specifically described. No claim should be interpreted to be in means plus function format.

