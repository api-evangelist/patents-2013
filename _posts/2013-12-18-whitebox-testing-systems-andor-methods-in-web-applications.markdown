---

title: White-box testing systems and/or methods in web applications
abstract: Certain example embodiments relate to white-box testing techniques, e.g., for graphical user interfaces (GUIs). Responsive to a first parameter received from a test suite executer, test bootstrap code included in an application is executed, where the application and the test suite executer run in the same browser. A test case to be run on the application and a test case executer to execute the test case are retrieved by the executed test bootstrap code. The retrieved test case is executed in a same context of the browser as the application. Results from executing the test case are stored.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09098636&OS=09098636&RS=09098636
owner: SOFTWARE AG
number: 09098636
owner_city: Darmstadt
owner_country: DE
publication_date: 20131218
---
Certain example embodiments described herein relate to systems and or methods for testing software applications in web browser environments and aspects thereof. More particularly certain example embodiments relate to white box testing techniques e.g. for graphical user interfaces GUIs . Certain example embodiments advantageously provide techniques that potentially address problems typically encountered when applications are tested in production environments.

Software testing can be an important step during the software development cycle e.g. that helps verify whether the software meets defined requirements and works as expected. In modern software development techniques such as the iterative and incremental agile software development approaches software testing is a continuing process. Compared to traditional software development processes in which most of the testing efforts oftentimes occur after the software coding stage has been completed in iterative and agile techniques the software is tested continuously before it is released. The agile approach generally involves software programmers testing the software completely after each software enhancement or change e.g. to help ensure the software works as intended and is deliverable to a customer and or to a production environment after each development cycle. Such development approaches therefore can require frequent execution of automated testing. For example with the iterative and or agile approaches it may be necessary for a programmer to test the software each time a feature is coded or completed every time code is checked into a version control system etc.

Test automation or in general software testing methods can be distinguished into white and black box tests. White box tests use knowledge about the internal structure and workings of the software and can check if internal application programming interfaces APIs work as expected or whether the internal state of the program is correct. White box tests can be applied at the unit integration and system levels of the software testing process.

Black box tests require no knowledge about the internal implementation and treat the software under test like a black box . Black box tests may be performed in addition to white box tests and may also be applied to the acceptance level of software testing. One kind of acceptance tests is the graphical user interface GUI test. A GUI test involves program code that tries to reproduce the interaction that is performed by the user on the interface e.g. by clicking with the mouse on controls by entering any kind of input via the keyboard etc. After the interaction part is finished the test code compares the output results with the expected results. This code can be written manually by the programmer or automatically recorded by using corresponding automation tools that allow recording of all interactions on the interface and transforming them into a corresponding code e.g. playback script .

GUI tests have the disadvantage that they are very sensitive to changes on the user interface UI . For example GUI tests would require frequent changes to the test code because the agile approach demands very frequent changes iterations of the software. As a solution to such problems it is useful to implement GUI tests that are realized as black box as well as white box tests. The software pattern known as the model view presenter which is a common approach for the implementation of modern web applications follows this idea.

Most of the existing frameworks for web browser graphical user interface tests e.g. Selenium are divided into a component that offers an application programming interface API to define the interaction and to check the expected result as well as a component that executes the defined interaction in the web browser. The component that executes the defined test interactions use the native automation APIs provided by the browsers. These native APIs of the browser allow checking the state of the document object model DOM structure in the browser. As such this approach enables to check the internal state of an application and to implement white box tests.

Modern web applications which are frequently implemented in JavaScript are optimized by a pre compiler step. Some or all of the following and or other common pre compiler steps can make it difficult and sometimes even impossible for existing test frameworks to test the production system code translation generation e.g. from Java to JavaScript creation of code variations e.g. for cross browser support code optimization obfuscation of code etc.

Such changes to the code during compiling and or obfuscation may cause the behavior of the application to dramatically change in a production environment. In addition all these steps result in an auto generated production code that differs from the original code. Because of the code translation generation and the obfuscating steps the code structure itself may be changed e.g. possibly involving changes to function and variable names etc. Thus testing such compiled and or obfuscated application code on production environments using existing white box test frameworks can become very difficult and sometimes even impossible not to mention expensive.

It thus will be appreciated that existing approaches to white box testing of GUI web applications are disadvantageous to the extent that they require additional tools software to test the installed production environment with such test tools often being platform and or target system specific quite often require that test code be written in a different programming language as the implementation language of the production code are difficult for the end user to execute the test cases to validate his her environment e.g. after an installation to verify if the environment works correctly etc.

Certain example embodiments help address these and or other issues. For instance an example method embodiment for testing an application includes responsive to a first parameter received from a test suite executer executing test bootstrap code included in the application where the application and the test suite executer are running in a browser. The method also includes the executed test bootstrap code retrieving a test case to be run on the application and a test case executer to execute the test case executing the retrieved test case in a same context of the browser as the application and storing results from executing the retrieved test case.

According to an aspect of certain example embodiments the test bootstrap code is compiled together with code of the application.

According to another aspect of certain example embodiments the retrieving includes requesting by the executed test bootstrap code the test case from a remote computer responsive to the requesting receiving the test case and the test case executer and injecting the received test case and the test case executer to the application.

In another aspect of certain example embodiments executing the retrieved test case includes performing the execution of the test case by the injected test case executer.

The method may include calling one or more internal functions of the application from within the injected test case code in certain example embodiments.

The method may include starting the test suite executer in the browser where the starting includes loading code of the test suite executer from a computer injecting the loaded code of the test suite executer to a page of the browser and executing the injected code of the test suite executer to provide the first parameter to the application.

An example computer system embodiment for testing an application includes first processing resources including at least one processor and a memory. The processor is configured to perform responsive to a first parameter received from a test suite executer executing test bootstrap code included in the application where the application and the test suite executer are running in a browser. The processor is further configured to perform the executed test bootstrap code retrieving a test case to be run on the application and a test case executer to execute the test case executing the retrieved test case in a same context of the browser as the application and storing results from executing the retrieved test case.

Another example computer system embodiment includes second processing resources communicatively connected to the first processing resources over a network and storage connected to the second processing resources. The storage stores a plurality of test cases each said test case including a interactions between the application and components external to the application that were gathered during a run of the application and received user input from a user and b assertions to be made to the application once the application reaches a desired test state. Retrieving the test case includes requesting by the executed test bootstrap code the test case from the second processing resources responsive to the requesting receiving the test case and the test case executer from the storage and injecting the received test case and the test case executer to the application.

An example non transitory computer readable storage medium includes instructions stored thereon which when executed by a computer causes the computer to perform operations for testing an application. The operations include responsive to a first parameter received from a test suite executer execute test bootstrap code included in the application where the application and the test suite executer are running in a browser. The operations also include the executed test bootstrap code retrieving a test case to be run on the application and a test case executer to execute the test case executing the retrieved test case in a same context of the browser as the application and storing results from executing the retrieved test case.

These aspects features and example embodiments may be used separately and or applied in various combinations to achieve yet further embodiments.

Certain example embodiments relate to white box testing techniques e.g. for graphical user interfaces GUIs . Certain example embodiments may be used for white box testing web applications in production environments.

While enabling white box testing certain example embodiments advantageously maintain the test code separately from the production code. Maintaining the separation between the test code and the production software code is desirable for several reasons including for example to reduce the size of code that is delivered from the server and increases the startup time of the application. Certain example embodiments address the limitation of conventional test approaches where when test code is not compiled and or obfuscated together with the packaged or delivered production code it becomes difficult to perform white box tests with that production code.

Certain example embodiments provide a framework system that allows for the execution of white box tests on an obfuscated production web application while clearly separating the production code from the test code. In certain example embodiments the test code need not be pre packaged with the production code but can be later injected by the framework into the production code for the test execution and both executed in the same web browser context.

For certain example embodiments no additional test software is required to be installed in order to validate any production environment after an installation. Because the test code runs in the same web browser no additional features such as browser plugins are necessary for test execution in some implementations. Moreover all operation systems on which the web browser is available are supported in at least some implementations. In general all web browsers in which the production code runs can be supported by the example embodiments described herein. This advantageously makes it also possible for the end user e.g. customer to validate his her installation and to identify errors on his her environment e.g. regardless of the target browser environment etc.

Using web browser also referred to simply as browser the user may access web server to run application . Upon user access application is downloaded or otherwise made accessible to browser and is executed e.g. executing application . For purposes of performing tests upon executing application some of the test components may also be downloaded to client computer and run in browser e.g. as executing test framework .

Client computer may be any type of computer such as for example a personal computer mobile computer tablet computer smart phone etc. that has a processing system that includes one or more processors and memory. The memory may include volatile memory and or non volatile memory. Program instructions and or data may be stored in memory and be read and processed by the one or more processors.

Remote computer may include one or more server computers that are geographically distributed or co located. Remote computer includes one or more processors and memory including volatile and non volatile memory for storage. Storage may comprise one or more connected storage devices. For example storage may be cloud storage residing in geographically dispersed storage devices connected by the Internet.

Remote computer and or web server may be part of a production environment. A production environment can be considered an environment where software products including applications such as application and associated other components are run for their intended use by end users such as actual customers. This is in contrast to a development environment or test environment where the applications are used by developers or testers. For example in an online shopping business upgrades to its web site e.g. portal may be coded and tested in a test environment by developers and testers and ultimately the upgraded application software will be deployed in the production environment where customers visiting the online shopping portal through their browsers are served with the upgraded application software. Production code a term that refers to application code placed in the production environment for web applications are often compiled and or obfuscated as noted above for various reasons. At least partial compilation and or obfuscation may be an automatic and or necessary part of the application deployment process for instance. In other cases it may be desirable to compile code for performance reasons. In still other cases it may be desirable to obfuscate at least some sensitive portions of the code for security reasons.

Test components include a test suite executer a test case bootstrapper and a test case executer. Additionally test components may include test cases and test suites that group the available test cases. Each test case may include test case code and a corresponding test case definition or template.

Example test cases include operations corresponding to user interactions with the application to be tested. Each test case may include a interactions between the application and components external to the application as the application runs and received user input from a user until a test state is reached and b validations to be made to the application once the application reaches the test state. When executing a test case the application is fed with interactions included in the test case through for example the test case executer until the application reaches a known test state until the test case ends etc. Once the application reaches the test state or the test case ends one or more assertions e.g. validations may be made of the variable and or other parameter values in the application. The values returned may be compared with corresponding expected values to determine the test case resulted in a success or failure.

The test case definition also referred to as test case template for each test case uniquely identifies the test case and may include a high level description of the test case. The test case may be identified by a unique identifier among all tests that are available to be run in a particular test framework. The test case definition may also identify where the corresponding test case code is available. Pre and or post conditions for the test case execution may also be specified in the test case definition.

A test suite comprises a plurality of test cases. Each test suite may be identified by a unique suite identifier and include a group of related test cases or test cases selected according to some predetermined criteria.

The test suite executer operates to load one or more test suites and test case definitions from a server and to initiate the execution of each test case. Each test case may be executed in a separate browser tab. Each test case definition specifies which URL of the web application must be loaded to start and perform the corresponding test case. The test suite executer adds a specific bootstrap parameter e.g. via the URL from the test case definition to activate the test case bootstrapper. This bootstrap parameter contains a test identifier composed of the test suite identifier and the test case identifier that informs the test case bootstrapper which test code needs to be loaded from the server and injected into the production code to execute the test.

In some implementations the test case bootstrapper is always available in the application and is linked during the compile process into the production code. This makes it possible in certain example embodiments to execute white box tests on each installed web application in which the bootstrapper code is available. The bootstrapper itself in some implementations may have only a few lines of code e.g. thereby advantageously reducing the code size and or the download time of the production code. The test case bootstrapper operates to retrieve the test case code from the server and for the injection of the code into the production code as well as to run the text case executer.

Obtaining and executing the test case code proceeds in two steps. In the first step the test case executer is loaded from the server and injected into the application. The test case executer code executes the test case and provides a set of help functions allowing the test case to simulate user interactions and to validate results of the interactions. After execution the test case executer gets the result from the test case and communicates this result to the test suite executer using browser cookies and or the browsers local web storage.

In the second step the test case code JavaScript file is loaded from the server and injected into the production code. This allows the test code to run together with the production code and to execute and access functions from the production code.

The test case executer is responsible for the test case execution and provides the test results to the text suite executer. The test case executer also provides the API to simulate user interactions and to check the results of the interactions that can be used in the test case code. After the test case execution the result of the test case is stored into a browser cookie or into the web browser local storage.

The web browser local storage is a simple key value store in which a web application can store data and that can be also shared between browser tabs. As the key the test case identifier is used and into the value the result of the test case execution is stored. If the test case was not successful a log will also be stored.

Alternatively browser cookies may be used to store test results. For example in case that the browser does not support local web storage a cookie may be used. Cookies may contain the same key value structure e.g. as JavaScript Object Notation or JSON .

As shown in the operations of method in the illustrated embodiments are performed by the test suite executer e.g. operations and by the browser engine e.g. operation by the test case bootstrapper e.g. operations and by the test case executer e.g. operations .

At operation the test suite executer URL is opened in a web browser such as browser . The test suite executer operates to load the test suite and test case definitions from a server e.g. web server and to execute each test case in a separate tab of the browser. The test suite executer is separate from the production code and can be accessed by opening a special URL on the web server. The URL for accessing the test suite executer may be restricted to be accessible only for the purposes of testing.

Upon opening the URL for the test suite executer the main test framework code containing the test suite executer is loaded from the server and injected in to the currently active page of the browser. Injecting the test suite executer results in the active page including the code e.g. JavaScript or other script in the code of the current active page. The current page with the test framework code injected may be referred to as the test framework page. The injected code of the test suite executer is then executed. For example if the injected code is JavaScript then the browser s JavaScript engine would run the code.

At operation test suites and test case definitions are loaded from the server. In this operation the test suite executer obtains the test suite definition list from the server defining all or some of the test suites to execute on the application. Each test suite definition includes a unique suite identifier and a list of references defining the test cases that are included in the suite.

At operation for each test suite the corresponding test case definitions are downloaded from the server. In this operation the test suite executer obtains the test case definitions for every test case. Each test case definition may be composed of a test case identifier and an application target e.g. URL . The test case target is the application view or component the test case is testing. The test case definition does not contain the test code in certain example embodiments.

At operation for each test case to be run the test suite executer opens a new tab in the browser. A tab for running a test may be referred to as a test tab and provides a separate context for each test case to be run. From within the newly opened browser tab a URL e.g. the URL specified in the corresponding test case definition is called with one or more predetermined URL parameters to activate the test case bootstrapper in the application being tested.

At operation responsive to the URL and the passed parameters the application code which also contains the test case bootstrapper is loaded in the new test tab.

At operation the test case bootstrapper loads the test case code and runs the test case executer. The code for the test case executer and the test case code may be loaded to the browser from the server. Loading the test case executer and test case code includes downloading the test case executer and test case code and injecting them to the application.

At operation the test case executer executes the test code within the context of the new test tab. According to an embodiment as also noted above execution of the test case code includes running of the injected JavaScript of the test case by the JavaScript engine of the browser.

At operation possibly in conjunction with operation user interactions defined in the test case are performed.

At operation results of the executed test are observed. For example the document object model DOM structure and internal state of the application may be examined. The results may include values or variables at defined stages of processing of the application results of assertions and or validation statements included in the test case code etc.

At operation the results of the test case execution are stored in the web browser local storage. The results are stored in shared data structures allocated for the purpose or in browser cookies.

At operation the test suite executer collects the results of the test case executions by monitoring the web browser local storage to where each of the test cases stores their respective results.

At operation a determination is made as to whether any more tests are to be executed. According to an embodiment the downloaded test suite definition would indicate the test cases to be run. In other embodiments all test cases of one or more test suites are run in order to complete the testing. If more tests are to be executed the method proceeds to operation and operations are repeated until all test cases have been executed.

When it is determined that all test cases have completed execution the method proceeds to step to complete test execution. Completion of the tests may include reporting the results of the tests. As noted above results from each test may be stored in data structures in shared memory and the test suite executer may access these stored results and report as appropriate. Reporting may include displaying in the browser printing or storing a listing of the results transmitting reports to a developer s email address and or the like.

Server has in its storage or has access to other storage that includes application code test framework code test suite and test case definitions and test case code . Application code test framework code test suite and test case definitions and test case code are downloaded by client browser at various stages during the testing process.

As also noted in relation to the test suite executer is downloaded to the browser and run by opening a URL an example of which is shown in input field to access a web server such as server .

Based upon the URL specified or a parameter in the URL test framework code is downloaded from server to browser . The test framework code includes the code for the test suite executer that is then executed in browser . Test framework code may include one or more files of file types such as JavaScript HTML and or other script based or other languages capable of web GUI construction and or control.

When downloaded the test framework code or portions thereof is injected to the current web page e.g. tab . The test suite executer downloaded as part of the test framework code may execute in tab in browser .

Within the context of browser tab several operations including one or more of operations may be performed. Operation represents the downloading of the test case framework from server as described above.

When the test suite executer has started in tab it may perform each of the operations . At operation test suite definitions are downloaded. Test suite definitions may be stored on server in any of a number of formats suitable for specifications and or templates such as XML etc. In this step the test suite executer obtains the test suite definition list from the server defining all test suites to execute on the application. Each test suite definition includes a unique suite identifier and a list of one or more references defining the test cases that belong to the suite.

At operation test case definitions are downloaded. The test case definitions too may be specified in a format such as but not limited to XML. Test suite definitions may indicate the identities types and locations of the available test suites. Test case definitions may indicate the identities types and location of each test available in a test suite. In this step the test suite executer obtains the test case definitions for every test case. The test case definition includes a test case identifier and an application target e.g. specified as a URL . The test case target may be the application view or component the test case is designed to test. Test case code is not included in the downloaded test case definitions.

At operation test suite executer creates and or initializes shared data structures for use in collecting and communicating results generated by the execution of test cases. In this operation the test suite executer creates and initializes the shared data structure used to share test case results and test data between the test cases which are executed in separated and different browser tabs. This structure is used to from the test cases to communicate the test result to the test suite executer. The structure may also be used to communicate test results between test cases. The shared data structures may be formed based upon the information available from the test suite definitions and or the test case definitions. For example the number of data structures to be created may be based upon the number of test cases to be executed. Each data structure may be configured to hold the values written out and or observed during and or after each of the test cases. The shared data structures may be formed in browser local memory that can be accessed by a plurality of the pages.

At operation as described with respect to operation above the test suite executer opens for each test case in the test suite a new browser tab e.g. tabs and using the defined application target URL of the test case and adding the test case run parameter containing the test suite identifier and the test case identifier.

At operation the test suite executer waits for each test case execution to finish. This may be performed by monitoring a shared data structure in the web browser local store by using a specific browser cookie that also contains a similar data structure depending on the web browser supports local web storage or in some other way. For example each test case may set a flag in its results data structure to indicate it has completed its execution and this may be monitored appropriately.

After the application e.g. from application code shown in is loaded into browser the test case bootstrapper included in the application in an operation checks the provided URL for a test run parameter including the test suite and or test case identifier. The application and the test code bootstrapper called for executing a particular test as specified in the URL may operate in its own browser tab . Based upon the test suite test case identifiers provided in the URL in operation the appropriate test case code is identified and loaded from the server . The test case executer which can be downloaded from test framework code on server is injected into the production code e.g. application code by adding a HTML script tag e.g. item that references the code of the test case executer . After the test case executer is loaded the test case code will be loaded injected to the production code and executed. To perform a test case the corresponding test case code may provide a run method or the like. Operations and show for example that test case bootstrapper activates test code executer and that test code executer activates test case code .

Test case executer provides an API that can be used in test case code e.g. to perform user interactions and to validate the execution of an interaction. Test case executer supports different user interaction such as for example any kind of mouse events on a DOM object in the browser such as a mouse click on a button as well as any kind of keyboard events that are possible e.g. entering a value into a text box . Test case executer is also configured to initiate the test case execution.

Browser with tab being active graphically illustrates the test case executer interacting with a test case e.g. test case 1 from test suite 1 . Based upon its interaction with the test case test case executer stores or updates results in results data structures in shared memory .

Browser with tab being active graphically illustrates a summary of the current tests being displayed by the test suite executer. The test suite executer may access the shared data structures and to read result data and or update result data stored in the shared structures by one or more test case executers such as test case executer that stored results in data structure .

The test case code is compiled obfuscated together with the production code and the test case executer not separately shown in . The obfuscation compiling process may be done during the build process of the application and the obfuscated code may be provided and or stored by the server. This enables the calling of internal functions such as productiveFuncC in the application code from inside test case code as well as by using the API provided by the test case executer. Each test case code may be stored in a separate JavaScript file that is assigned a unique name composed by the test suite identifier and the test case identifier. In certain instances the identifier for test suites and test case may be a simple string.

As shown in the test case code can use the internal functions of the productive code as well as the API of the test case executer to access UI elements e.g. of the application to simulate user interactions and to validate the result of the interaction. This advantageously enables the running of stable and fast test cases to validate a production installation of a web application in certain example embodiments.

Although certain example embodiments have been described as relating to separate tabs it will be appreciated that separate browser windows may be used in place of or together with tabs. It also will be appreciation that although certain example embodiments have been described in connection with JavaScript the techniques disclosed herein may be used in connection with other scripting languages and or the like.

It will be appreciated that as used herein the terms system subsystem service engine module programmed logic circuitry and the like may be implemented as any suitable combination of software hardware firmware and or the like. It also will be appreciated that the storage locations herein may be any suitable combination of disk drive devices memory locations solid state drives CD ROMs DVDs tape backups storage area network SAN systems and or any other appropriate tangible non transitory computer readable storage medium. Cloud and or distributed storage e.g. using file sharing means for instance also may be used in certain example embodiments. It also will be appreciated that the techniques described herein may be accomplished by having at least one processor execute instructions that may be tangibly stored on a non transitory computer readable storage medium.

It is to be understood that this disclosure is not to be limited to the disclosed embodiments but on the contrary is intended to cover various modifications and equivalent arrangements included within the spirit and scope of the appended claims.

