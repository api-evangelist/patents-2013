---

title: Transaction message collector
abstract: Various embodiments of systems and methods for a transaction message collector are described herein. The message collector receives the message from a message producer. In one aspect, the message is stored in an active message bulk storage or a new active message bulk storage. In another aspect, after the message is stored in the message collector, a confirmation is sent from the message collector to the message producer informing the message producer that the message is stored in the message collector. In yet another aspect, the active message bulk storage is forwarded to a message consumer for consumption based upon meeting at least one of plurality of time or memory based conditions. In a further aspect, after the active message bulk storage is consumed by the message consumer a result of consumption of the active message bulk storage is created and sent to the message producer.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09306892&OS=09306892&RS=09306892
owner: SAP SE
number: 09306892
owner_city: Walldorf
owner_country: DE
publication_date: 20131212
---
This application is a continuation application of U.S. patent application Ser. No. 13 047 824 filed Mar. 15 2011 which is incorporated herein by reference.

Embodiments generally relate to computer systems and more particularly to methods and systems for determining status of a message during a data communication.

Messaging systems such as Java Message Service JMS allow different applications to communicate with each other. Generally the messaging systems facilitate data communication between a message producer and a message consumer. The message producer is used to send a message to the message consumer. The messaging system may also include one or more intermediate components that process the message before the message consumer receives the message for consumption. An example of the message could be a file or an E Mail which is read from a database by the message producer. The intermediate components perform various processes on this file or E Mail and finally this processed file or E Mail is received by the message consumer. An example of the message consumer may be a mail box of a user that receives the E Mail retrieved by the message producer from an E Mail server.

In certain cases the messaging system includes a non bulk producer of message and a bulk consumer of message. The present day messaging systems use a component such as a Message Aggregator which receives the message from the non bulk producer aggregates the message to form a bulk and forwards the bulk to the bulk message consumer for consumption. The messaging system using the Message Aggregator uses an input channel for transmitting the messages from the message producer to the Message Aggregator and an output channel for transmitting the bulk from the Message Aggregator to the message consumer.

The Message Aggregator allows data communication in messaging system. However in case of issues with either the Message Aggregator or the bulk message consumer e.g. the Message Aggregator or the bulk message consumer is shut down there is no way for the non bulk message producer to know the status of the message. This might lead to loss of message in the messaging system which is undesirable.

Therefore a method and system is required that provides the status of the message in the messaging system. Also a method is required that uses a single channel for all communications in the messaging system.

Various embodiments of systems and methods for a transaction message collector are described herein. A message collector receives a message from a message producer. The message is stored in an active message bulk storage stored in the message producer. The message is stored in the active message bulk storage corresponding to a message type of the message. A confirmation is sent from the message collector to the message producer the confirmation informing the message producer that the message is stored in the active message bulk storage.

The active message bulk storage is forwarded from the message collector to a message consumer for consumption if at least one of a plurality of time or memory based conditions is satisfied. The message collector receives a result of consumption of the active message bulk storage from the executor corresponding to the message type of the active message bulk storage. The message collector forwards the result of consumption of the active message bulk storage from the message collector to the message producer via the result handler corresponding to the message type of the active message bulk storage.

These and other benefits and features of embodiments of the invention will be apparent upon consideration of the following detailed description of preferred embodiments thereof presented in connection with the following drawings.

Embodiments of techniques for transaction message collector are described herein. In the following description numerous specific details are set forth to provide a thorough understanding of embodiments of the invention. One skilled in the relevant art will recognize however that the invention can be practiced without one or more of the specific details or with other methods components materials etc. In other instances well known structures materials or operations are not shown or described in detail to avoid obscuring aspects of the invention.

Reference throughout this specification to one embodiment this embodiment and similar phrases means that a particular feature structure or characteristic described in connection with the embodiment is included in at least one embodiment of the present invention. Thus the appearances of these phrases in various places throughout this specification are not necessarily all referring to the same embodiment. Furthermore the particular features structures or characteristics may be combined in any suitable manner in one or more embodiments.

In one embodiment the messaging system includes the message consumer . The message consumer may be a bulk message consumer i.e. the message consumer can consume a plurality of messages stored in an active message bulk storage at same time.

In one embodiment the messaging system includes a message collector . The message collector stores the message sent from the message producer in an active message bulk storage in the message collector . Each active message bulk storage in the message collector corresponds to a message type of the message. For example the active message bulk storage corresponds to message of type X . The active message bulk storage corresponding to message of type X stores the message of type X received from the message producer .

In one embodiment a result handler is registered with the message collector . Each result handler is registered corresponding to a message type of the message. For example the result handler corresponds to the message of type X . After the message of type X is stored in the active message bulk storage the message collector sends a confirmation to the message producer that the message is stored in the active message bulk storage . In one embodiment the message collector sends the confirmation via the result handler corresponding to message of type X .

In one embodiment an executor is registered with the message collector . Each executor is registered corresponding to a message type of the active message bulk storage . The executor corresponds to the active message bulk of type X . As shown the message collector forwards the active message bulk storage to the message consumer via the executor . After the active message bulk storage is consumed by the message consumer the executor prepares a result of consumption of the active message bulk storage . The executor then sends the result of consumption to the message collector . Finally the message collector forwards the result of consumption of the active message bulk storage to the message producer via the result handler corresponding to the message type X of the active message bulk storage .

Next at block the message received from the message producer is stored in the message collector. The message received from the message producer is stored in the active message bulk storage in the message collector. In one embodiment the message collector stores one or more active message bulk storage. Each of the one or more active message bulk storage corresponds to a different message type. For example the message collector may store an active message bulk storage for message type an active bulk storage for message type and an active message bulk storage for message type .

As discussed above the received message is stored in the active message bulk storage corresponding to the message type of the message. For example if the message type of the received message is the message is stored in the active message bulk storage .

In one embodiment the message collector stores a message ID list. The MsgID of each of the messages stored in the message collector is stored in the message ID list. The MsgID of the message that has been sent to the message consumer for consumption is removed from the message ID list.

Next at block a confirmation is sent from the message collector to the message producer informing the message producer that the message is stored in the active message bulk storage stored in the message collector. The confirmation is sent to the message producer after the received message is stored in the active message bulk storage in the message collector. In one embodiment the message collector sends the confirmation to the message producer via the result handler corresponding to the message type of the message.

In one embodiment the message producer may also send a request to the message collector to determine whether the received message is stored in the message collector. The message producer sends the request by sending the message identification MsgID of the message. The confirmation is sent to the message producer when the received message is stored in the message collector. In one embodiment a check is performed whether the MsgID received by the message producer is stored in the message ID list. If the MsgID is stored in the message ID list the confirmation is sent to the message producer that the message corresponding to the MsgID is stored in the message collector.

Next at block the message collector forwards the active message bulk storage to the message consumer. As discussed above the message collector forwards the active message bulk storage via the executor corresponding to the message type of the active message bulk storage. In one embodiment the message collector forwards the active message bulk storage if at least one of a plurality of time or memory based conditions is satisfied. The time or memory based conditions may include conditions such as is the time since the message is stored in the active message bulk storage greater than equal to a preset timeout period or is the size of the active message bulk storage greater than a preset memory size of the active message bulk storage or the size of the message collector.

In one embodiment the message consumer consumes the active message bulk storage forwarded by the message collector. In one embodiment consuming the active message bulk storage includes consuming each of the messages stored in the active message bulk storage.

Next at block the message collector receives the result of consumption of the active message bulk storage. In one embodiment after the active message bulk storage is consumed by the message consumer the message collector prepares the result of consumption of the active message bulk storage. The message collector then sends the result of consumption to the message producer. The message collector corresponding to the message type of the active message bulk storage sends the result of consumption to the message collector. In one embodiment the result of consumption includes the result of consumption of each of the message stored in the active message bulk storage.

Finally at block the message collector forwards the result of consumption to the message producer. In one embodiment the message collector forwards the result of consumption via the result handler corresponding to the message type of the active message bulk storage.

Initially at block the result handler is registered with the message collector. In one embodiment the message producer registers the result handler with the message collector.

In one embodiment the message producer registers a plurality of result handlers with the message collector. Each result handler of the plurality of result handlers is registered for a corresponding message type of the message. For example the message producer may register a result handler for message type a result handler for message type and a result handler for message type .

In one embodiment each of the plurality of result handlers is registered for a corresponding MsgID of the message. For example the message producer may register a result handler corresponding to a MsgID a result handler corresponding to a MsgID and a result handler corresponding to a MsgID .

A result handler hash map is stored in the message collector which has the message type of the message and the result handler corresponding to the message type as entries. In one embodiment the result handler hash map stores the MsgID of the message and the result handler corresponding to the MsgID of the message. Registering the result handler with the message collector includes providing entries to the result handler hash map stored in the message collector. In one embodiment providing entries to the result handler hash map includes providing the message type and the result handler corresponding to the message type to the result handler hash map. In one embodiment providing entries to the result handler hash map includes providing the MsgID and the result handler corresponding to the MsgID to the result handler hash map. In one embodiment the entries for the result handler hash map are provided by the message producer.

The message collector includes a method void registerResultHandlerForMessage for registering the result handler with the message collector. In one embodiment the method voidregisterResultHandlerForMessage is invoked by the message producer. In one embodiment the method void registerResultHandlerForMessage is provided as input the MsgID or the message type of the message and the result handler corresponding to the message type or the MsgID. Invoking this method by the message producer registers the result handler with the message type or the MsgID of the message provided as input.

In one embodiment the result handler is an interface. In one embodiment the result handler is an Application Programming Interface API . In one embodiment the result handler is implemented by the message producer.

In one embodiment the messaging system includes one or more intermediate components. Typically the intermediate components are present between the message producer and the message consumer. The one or more intermediate components process the message sent from the message producer to the message consumer. In one embodiment the processing of the message by the one or more intermediate components may include for example routing of the message transmission of the message XML validation of the message etc.

In one embodiment an intermediate result handler may also be registered with the message collector. The intermediate result handler is registered with the message collector by the intermediate component. Registering the intermediate result handler with the message collector includes providing entries to the result handler hash map. In one embodiment providing entries to the result handler hash map includes providing the message type or the MsgID and the intermediate result handler corresponding to the message type of the message to the result handler hash map.

The method voidregisterResultHandlerForMessage of the message collector is invoked by the intermediate component. The method void registerResultHandlerForMessage has the MsgID of the message or the message type of the message as input and the intermediate result handler corresponding to the MsgID or the message type. The method voidregisterResultHandlerForMessage registers the intermediate result handler with the MsgID or the message type provided as input.

Next at block the executor is registered with the message collector. The message consumer registers the executor with the message collector. In one embodiment the message consumer registers a plurality of executors with the message collector. Each executor of the plurality of executors is registered by the message consumer for a particular message type. For example an executor may be registered for message type and an executor may be registered for message type .

In one embodiment the message collector stores an executor hash map that stores the message type and the executor corresponding to the message type. Registering the executor hash map with the message collector includes providing entries to the executor hash map. In one embodiment providing entries to the executor hash map includes providing the message type and the executor corresponding to the message type to the executor hash map. In one embodiment the entries to the executor hash map are provided by the message consumer.

In one embodiment the message collector includes a method void registerExecutorForMessageType. The method void registerExecutorForMessageType is invoked by the message consumer. The method registerExecutorForMessageType is provided as input the message type and the executor corresponding to the message type. Invoking this method registers the executor with the message type provided as input to the method registerExecutorForMessageType.

In one embodiment the executor is an interface. In one embodiment the executor is an Application Programming Interface API . The executor is implemented by the message consumer.

Next at block the message collector receives a message from the message producer. As discussed above the message producer is a non bulk producer of message and sends one message at a time to the message collector.

Next at block a check is performed on the received message to determine if the executor corresponding to the message type of the received message is stored in the executor hash map within the message collector. In one embodiment if the executor corresponding to the message type of the received message is not stored in the message collector i.e. if the condition in decision block is false then the received message is not stored in the message collector.

The message collector includes a method to execute asynchronously. In one embodiment this method is provided as input the message received from the message producer. This method helps the message producer or the intermediate component to forward the message to the message collector. In one embodiment this method is invoked by the intermediate component positioned immediately before the message collector. When the executor corresponding to the message type of the message is not stored in the executor hash map this method returns false and the message is not stored in the message collector.

In one embodiment if the executor corresponding to the message type of the message is stored in the executor hash map i.e. if the condition in block is true then a determination is made at decision block whether the active message bulk storage corresponding to the message type of the received message is stored in the message collector. As discussed above the message collector may store one or more active message bulk storage where each active message bulk storage corresponds to a particular message type.

If the active message bulk storage corresponding to the message type of the received message is not stored in the message collector i.e. if the condition in decision block is false then a new active message bulk storage is created block . In one embodiment the new active message bulk storage created corresponds to the message type of the received message. The new active message bulk storage is stored in the message collector block . In one embodiment the received message is stored in the new active message bulk storage stored in the message collector block .

If the active message bulk storage corresponding to the message type of the received message is stored in the message collector i.e. if the condition in decision block is true then the received message is stored in the active message bulk storage corresponding to the message type of the message block .

In one embodiment the message collector stores the message ID list. The MsgIDs of each of the messages stored in the message collector is stored in the message ID list. In one embodiment the MsgIDs of each of the message stored in the active message bulk storage or the new active message bulk storage is stored in the message ID list.

After the message is stored in either the active message bulk storage block or the new active message bulk storage block a confirmation is sent from the message collector to the message producer that the message is stored in the active message bulk storage or the new active message bulk storage block as shown in . The message collector invokes the result handler corresponding to the message type of the message to send the confirmation to the message producer.

In one embodiment the message collector sends the confirmation to the intermediate component that the message is stored in either the active message bulk storage or the new active message bulk storage. The message collector invokes the intermediate result handler corresponding to the message type of the message to send the confirmation to the intermediate component.

In one embodiment the result handler and the intermediate result handler have a method setBulkMode. In one embodiment the method setBulkMode is provided as input the MsgID of the message stored in the active message bulk storage or the new active message bulk storage. The method setBulkMode is invoked by the message collector after the message is stored in the active message bulk storage or the new active message bulk storage. Invoking the method setBulkMode sends the confirmation to the message producer and the intermediate component that the message is stored in the active message bulk storage or the new active message bulk storage.

As discussed above the message producer or the intermediate component sends the request to the message collector to determine if the message is stored in the message collector. In one embodiment the message ID list is checked to determine if the message is stored in the message collector.

The message collector includes a method Boolean is BulkModeOn. In one embodiment this method is invoked by the message producer or the intermediate component. In one embodiment the message producer or the intermediate component provide the MsgID of a message to determine if the message corresponding to the MsgID is stored in the message collector. In one embodiment the method Boolean is BulkModeOn provides the confirmation by returning true to the message producer or the intermediate component if the received message is stored in the message collector.

Next a check is performed at block to determine if any of the active message bulk storage or the new active bulk storage stored in the message collector satisfies any of a plurality of time or memory based conditions. In one embodiment the plurality of time or memory based conditions include 1 the memory size of the active message bulk storage or the new active message bulk size is greater than or equal to a preset memory size of the active message bulk storage 2 the memory size of the active message bulk storage or the new active message bulk size is greater than or equal to memory size of the message collector 3 the time elapsed for the message to be stored in the active message bulk storage or the new active message bulk storage is greater than or equal to a preset timeout period and 4 the number of active message bulk storage stored in the message collector is greater than or equal to a preset maximum number of bulk messages.

In one embodiment the message collector includes a method setBulkSize. The method setBulkSize is invoked by the executor. The method setBulkSize is provided as input a message type of the message and the preset memory size of the active message bulk storage corresponding to the message type. Invoking this method sets the preset memory size of the active message bulk storage corresponding to each message type. For example the preset memory size for the active message bulk storage which corresponds to message type may be set as 5 MB and the preset memory size for the active message bulk storage which corresponds to message type may be set as 3 MB. In one embodiment the executor sets the preset memory size for the active message bulk storage.

The executor sets the preset timeout period. A background job ActiveMsgFinderBackGroundJob runs continuously to check if the time elapsed since the message is stored in the active message bulk storage exceeds a preset timeout period. In one embodiment the memory size of the message collector and the preset maximum number of active message bulk storage is set at design time during the configuration of the message collector.

Next the active message bulk storage or the new active message bulk storage satisfying at least one of the time or memory based conditions in block is transferred to a to be processed list block . The to be processed list is stored in the message collector. The to be processed list stores the active message bulk storage that is ready to be consumed by the message consumer.

Next the active message bulk storage or the new active message bulk storage in the to be processed list is forwarded to the message consumer for consumption block . The message collector invokes the executor for forwarding the active message bulk storage or the new active message bulk storage from the to be processed list to the message consumer.

In one embodiment the message collector retrieves the executor corresponding to the message type of the active message bulk storage or the new active message bulk storage stored in the to be processed list from the executor hash map. The message collector invokes the retrieved executor for forwarding the active message bulk storage from the to be processed list to the message consumer for consumption. In one embodiment the active message bulk storage is forwarded to the message consumer by a thread. In one embodiment the message collector stores a thread pool that provides the thread for forwarding the active message bulk storage or the new active message bulk storage to the message consumer. After the active message bulk storage or the new active message bulk storage is forwarded to the message consumer for consumption the MsgID of the messages stored in the active message bulk storage or the new active message bulk storage is removed from the message ID list.

Next the active message bulk storage or the new active message bulk storage received by the message consumer is consumed by the consumer block . In one embodiment the message consumer is a bulk message consumer. In one embodiment consuming the active message bulk storage includes consuming the message stored in the active message bulk storage by the message consumer. In one embodiment the message consumer consumes all the messages stored in the active message bulk storage at the same time.

Next at block the executor creates the result of consumption of the active message bulk storage or the new active message bulk storage after the active message bulk storage or the new active message bulk storage is consumed by the message consumer. In one embodiment the executor prepares a result of consumption hash map that has the result of consumption of the active message bulk storage or the new active message bulk storage consumed by the message consumer. The result of consumption hash map stores the one or more messages stored in the active message bulk storage or the new active message bulk storage consumed by the message consumer and the result of consumption of each of the one or more messages. The result of consumption is successful when the message is successfully consumed by the message consumer and is an exception if the message is not successfully consumed by the message consumer. In one embodiment the result of consumption hash map also includes the reason for the exception along with the exception.

The message collector receives the result of consumption from the executor. In one embodiment the result of consumption hash map is received from the executor. In one embodiment the executor includes a method bulk result execute. This method is invoked by the message collector. In one embodiment the method bulk result execute has as input the active message bulk storage or the new active message bulk storage stored in the to be processed list. Invoking the method bulk result execute transfers the active message bulk storage or the new active message bulk storage stored in the to be processed list to the message consumer for consumption. The method bulk result execute returns the result of consumption of the active message bulk storage or the new active message bulk storage to the message collector. In one embodiment the method bulk result execute returns the result of consumption hash map to the message collector.

Finally at block the message collector invokes the result handler and the intermediate result handler to transfer the result of consumption to the message producer and the intermediate component respectively. In one embodiment the message collector invokes the result handler and the intermediate result handler to transfer the result of consumption hash map to the message producer and the intermediate component respectively. In one embodiment the message producer and the intermediate component receive the result of consumption of the active message bulk storage and the new active message bulk storage consumed by the message consumer.

In one embodiment the result handler and the intermediate result handler include a method handleResults which is invoked by the message collector. The method handleResults is provided as input to the result of consumption hash map. Invoking the method handleResults by the message collector forwards the result of consumption hash map to the message producer and the intermediate component by the result handler and the intermediate result handler respectively.

The messaging system includes one or more intermediate components for example intermediate component intermediate component and intermediate component . In one embodiment the message sent from the message producer to the message consumer passes through each of the intermediate components and . Each of the intermediate components and processes the message before the message reaches the message consumer . In one embodiment the messaging system includes a message collector . The message collector stores the message received from the message producer .

In one embodiment the message collector includes the method registerResultHandlerForMessage invoked by the message producer and the intermediate component s or . The message producer provides the following inputs to the method ResultHandlerForMessage message type A result handler A message type B result handler B and message type C result handler C . The method ResultHandlerForMessage registers the result handler A with message type A the result handler B with message type B and the result handler C with message type C.

The intermediate component s or provides the following inputs to the method ResultHandlerForMessage message type A intermediate result handler A message type B intermediate result handler B and message type C intermediate result handler C . The method ResultHandlerForMessage registers the intermediate result handler A with message type A the intermediate result handler B with message type B and the intermediate result handler C with message type C.

In one embodiment the message collector stores a result handler hash map. In one embodiment registering the result handlers and and the intermediate result handlers and includes providing entries to a result handler hash map stored in the message collector .

Next the message consumer registers the executors and with the message collector as illustrated in block of . The message collector includes the method registerExecutorForMessageType which is invoked by the message consumer . The message consumer provides the following input to the method registerExecutorForMessageType message type A executor A message type B executor B and message type C executor C . The method registerExecutorForMessageType registers the executor A with message type A executor B with message type B and executor C with message type C.

In one embodiment the message collector stores an executor hash map. Registering the executor A executor B and executor C includes providing entries to the executor hash map storing the message type and the executor corresponding to the message type.

The message producer provides the message type and the corresponding result handler entries to the result handler hash map i.e. the message producer provides the entries message type A result handler A message type B result handler B and message type C result handler C to the result handler hash map .

The intermediate component s provides the message type and the corresponding intermediate result handler entries to the result handler hash map i.e. the intermediate component s provide the entries message type A intermediate result handler A and message type B intermediate result handler B and message type C intermediate result handler C to the result handler hash map .

Next the message collector receives message message message and message from the message producer as illustrated in block of . In one embodiment the message producer uses a thread to send the message a thread to send the message a thread to send the message and a thread to send the message . In one embodiment the message and message have a message type A the message has a message type B and the message has a message type C.

Next a check is performed to determine if the executor corresponding to the message type i.e. A B and C of the received messages to is stored in the executor hash map as illustrated in block of . In one embodiment if the executor corresponding to the message type of the message is not stored in the executor hash map the message is not stored in the message collector.

If the executor corresponding to the message type of the message is stored in the executor hash map a check is performed to determine if the active message bulk storage corresponding to the message type of each of the messages to is stored in the message collector as illustrated in block of . As the executor hash map stores the executor A the executor B and the executor C corresponding to the message types A B and C of messages to the check is performed to determine if the active message bulk storage corresponding to the message types A B and C of the messages to is stored in the message collector. In one embodiment the message collector does not initially store any active message bulk storage.

Next as the message collector does not initially store the active message bulk storage corresponding to the messages types of the message to a new active message bulk storage is created corresponding to the message type A B and C of messages to as illustrated in block of . When the message which has the message type A is received a new active message bulk A storage is created and stored in the message collector as illustrated in blocks and of . The message is then stored in the new active message bulk A storage as illustrated in block of . When the message which has the message type B is received new active message bulk B storage is created and stored in the message collector as illustrated in blocks and of . The message is then stored in the active message bulk B storage as illustrated in block of .

Next when the message which has the message type A is received the check is performed to determine if the active message bulk storage corresponding to the message type A of the message is stored in the message collector as illustrated in block of . In one embodiment as the active message bulk A storage corresponding to the message type A of the message is stored in the message collector the message is stored in the active message bulk A storage as illustrated in block of .

Next when the message which has the message type C is received new active message bulk C storage is created and stored in the message collector as illustrated in blocks and of . The message is then stored in the new active message bulk C storage as illustrated in block of .

After each of the messages to are stored in the message collector the active message bulk A storage includes message and message active message bulk A storage message message active message bulk B storage includes message active message bulk B storage message and active message bulk C storage includes message active message bulk C storage message .

The message collector stores an active message bulk storage hash map which stores the message type and the active message bulk storage corresponding to the message type. illustrates the active message bulk storage hash map stored in the message collector according to an embodiment. As shown the active message bulk storage hash map has entries message type A and the corresponding active message bulk A storage message type B and the corresponding active message bulk B storage and message type C and the corresponding active message bulk C storage .

After each of the messages to are stored in the active message bulk storage or the new active message bulk storage the message collector sends a confirmation to the message producer and the intermediate component. The confirmation informs the message producer and the intermediate component that the message is stored in the message collector as illustrated in block of . After the message is stored in the active message bulk storage A the message collector invokes the result handler A and the intermediate result handler A to send the confirmation to the message producer and the intermediate component respectively informing the message producer and the intermediate component that the message is stored in the active message bulk A storage.

Similarly after each of the messages message message and message is stored in the active message bulk B storage active message bulk A storage and the active message bulk C storage respectively the message collector invokes the result handler B the result handler A and the result handler C respectively and the intermediate result handler B the intermediate result handler A and the intermediate result handler C respectively to send the confirmation to the message producer and the intermediate component respectively informing the message producer and the intermediate component that the messages message message and message are stored in the active message bulk B storage active message bulk A storage and active message bulk C storage respectively.

In one embodiment the message ID list stores the MsgID of each of the messages to stored in the message collector. In one embodiment message has a MsgID message has a MsgID message has a MsgID and message has a MsgID .

The message producer or the intermediate component may send a request by sending a MsgID to the message collector to determine if the message corresponding to the MsgID is stored in the message collector. In one embodiment the message producer or the intermediate component sends the request by sending the MsgID to the message collector. In one embodiment the message producer sends the request by providing the MsgID as input to the method is BulkModeOn of the message collector.

The message ID list is checked to determine if the MsgID is stored in the message ID list . In one embodiment as the MsgID is stored in the message ID list the message collector sends the confirmation to the message producer informing the message producer or the intermediate component that the message is stored in the active message bulk A storage. In one embodiment the method is BulkModeOn sends the confirmation by returning a True as the message is stored in the active message bulk A storage.

Next a determination is made to check if the active message bulk A storage the active message bulk B storage or the active message bulk C storage satisfies at least one of the plurality of time or memory based conditions 1 the memory size of the active message bulk storage is greater than or equal to a preset memory size of active message bulk storage 2 the memory size of the active message bulk storage is greater than or equal to the memory size of the message collector 3 the time elapsed for the message to be stored in the active message bulk storage is greater than or equal to a preset timeout period and 4 the number of active message bulk storage stored in the message collector is greater than or equal to a preset maximum number of the active message bulk storage as illustrated in block of .

The preset memory size for each of the active message bulk A storage the active message bulk B storage and the active message bulk C storage memory is set by the executor A executor B and executor C respectively. In one embodiment the preset memory size for active message bulk A storage is set as 5 MB for the active message bulk size B storage is set as 4 MB and for the active message bulk C storage is set as 6 MB.

In one embodiment the preset time out for each of the active message bulk A storage active message bulk B storage and active message bulk C storage is set as 60 seconds. In one embodiment the preset timeout period is set at design time when the message collector is configured. In one embodiment the preset time out period is set by the executor A executor B and executor C .

In one embodiment the memory size of the message collector is 50 MB. In one embodiment the preset maximum number of active message bulk storage in the message collector is set as 10. In one embodiment the memory size of the message collector and the preset maximum number of active message bulk storage is set at design time during the configuration of the message collector. In the above exemplary embodiment the memory size of each of the messages to is 2.5 MB.

In one embodiment the background job ActiveMsgFinderBackGroundJob runs continuously to check if the time elapsed since the message is stored in the active message bulk A storage is greater than or equal to 60 seconds the time elapsed since the message is stored in the active message bulk B storage is greater than or equal to 60 seconds and the time elapsed since the message is stored in the active message bulk C is greater than or equal to 60 seconds.

Next the active message bulk A storage the active message bulk B storage or the active message bulk C storage satisfying at least one of the conditions discussed above is transferred to a to be processed list stored in the message collector as illustrated in block of . In one embodiment the active message bulk A storage has memory size as 5 MB as message and message both have a memory size of 2.5 MB. In one embodiment the active message bulk A storage satisfies at least one of the conditions discussed above as the memory size of the active message bulk A storage is equal to the preset memory size of active message bulk A storage 5 MB . Next the active message bulk A storage which satisfies the condition discussed above is transferred to the to be processed list stored in the message collector as illustrated in block of .

Next the message collector forwards the active message bulk A storage which stores message and message to the message consumer for consumption. The message collector invokes the executor A to transfer the active message bulk A storage to the message consumer for consumption as illustrated in block of . In one embodiment after the active message bulk A storage is forwarded to the message consumer for consumption the MsgIDs and corresponding to message and message stored in the active message bulk A storage are removed from the message ID list .

Next the message consumer consumes the active message bulk A storage. In one embodiment consuming the active message A bulk storage includes consuming message and message stored in the active message bulk A storage by the message consumer as illustrated in block of .

In one embodiment the result of consumption of message by the message consumer is successful. In one embodiment the result of consumption of message by the message consumer is unsuccessful exception .

Next the executor A prepares the result of consumption of the active message A bulk storage by the message consumer. In one embodiment the executor A prepares the result of consumption hash map which stores the message and message stored in the active message bulk A storage and the result of consumption of the message and message by the message consumer.

Next the message collector receives the result of consumption hash map from executor A . The executor A includes a method bulk result execute. In one embodiment this method is called by the message collector. In one embodiment the method bulk result execute has an input to the active message bulk A storage stored in the to be processed list. In one embodiment invoking the method bulk result execute transfers the active message A bulk storage stored in the to be processed list to the message consumer for consumption. In one embodiment the method bulk result execute returns the result of consumption to the message collector as illustrated in block of .

Next the message collector invokes the result handler A and the intermediate result handler A to forward the result of consumption hash map to the message producer and the intermediate component respectively.

Finally the result handler A and the intermediate result handler A forward the result of consumption to the message producer and the intermediate component respectively as illustrated in block of .

The result handler A and the intermediate result handler A includes a method handleResults. In one embodiment the method handleResults is invoked by the message collector. In one embodiment the method handleResults is provided as input to the result of consumption hash map . In one embodiment invoking the method handleResult by the message collector forwards the result of consumption hash map to the message producer and the intermediate component.

Some embodiments of the invention may include the above described methods being written as one or more software components. These components and the functionality associated with each may be used by client server distributed or peer computer systems. These components may be written in a computer language corresponding to one or more programming languages such as functional declarative procedural object oriented lower level languages and the like. They may be linked to other components via various application programming interfaces and then compiled into one complete application for a server or a client. Alternatively the components maybe implemented in server and client applications. Further these components may be linked together via various distributed programming protocols. Some example embodiments of the invention may include remote procedure calls being used to implement one or more of these components across a distributed programming environment. For example a logic level may reside on a first computer system that is remotely located from a second computer system containing an interface level e.g. a graphical user interface . These first and second computer systems can be configured in a server client peer to peer or some other configuration. The clients can vary in complexity from mobile and handheld devices to thin clients and on to thick clients or even other servers.

The above illustrated software components are tangibly stored on a computer readable storage medium as instructions. The term computer readable storage medium should be taken to include a single medium or multiple media that stores one or more sets of instructions. The term computer readable storage medium should be taken to include any physical article that is capable of undergoing a set of physical changes to physically store encode or otherwise carry a set of instructions for execution by a computer system which causes the computer system to perform any of the methods or process steps described represented or illustrated herein. Examples of computer readable storage media include but are not limited to magnetic media such as hard disks floppy disks and magnetic tape optical media such as CD ROMs DVDs and holographic devices magneto optical media and hardware devices that are specially configured to store and execute such as application specific integrated circuits ASICs programmable logic devices PLDs and ROM and RAM devices. Examples of computer readable instructions include machine code such as produced by a compiler and files containing higher level code that are executed by a computer using an interpreter. For example an embodiment of the invention may be implemented using Java C or other object oriented programming language and development tools. Another embodiment of the invention may be implemented in hard wired circuitry in place of or in combination with machine readable software instructions.

A data source is an information resource. Data sources include sources of data that enable data storage and retrieval. Data sources may include databases such as relational transactional hierarchical multi dimensional e.g. OLAP object oriented databases and the like. Further data sources include tabular data e.g. spreadsheets delimited text files data tagged with a markup language e.g. XML data transactional data unstructured data e.g. text files screen scrapings hierarchical data e.g. data in a file system XML data files a plurality of reports and any other data source accessible through an established protocol such as Open DataBase Connectivity ODBC produced by an underlying software system e.g. ERP system and the like. Data sources may also include a data source where the data is not tangibly stored or otherwise ephemeral such as data streams broadcast data and the like. These data sources can include associated data foundations semantic layers management systems security systems and so on.

In the above description numerous specific details are set forth to provide a thorough understanding of embodiments of the invention. One skilled in the relevant art will recognize however that the invention can be practiced without one or more of the specific details or with other methods components techniques etc. In other instances well known operations or structures are not shown or described in details to avoid obscuring aspects of the invention.

Although the processes illustrated and described herein include series of steps it will be appreciated that the different embodiments of the present invention are not limited by the illustrated ordering of steps as some steps may occur in different orders some concurrently with other steps apart from that shown and described herein. In addition not all illustrated steps may be required to implement a methodology in accordance with the present invention. Moreover it will be appreciated that the processes may be implemented in association with the apparatus and systems illustrated and described herein as well as in association with other systems not illustrated.

The above descriptions and illustrations of embodiments of the invention including what is described in the Abstract is not intended to be exhaustive or to limit the invention to the precise forms disclosed. While specific embodiments of and examples for the invention are described herein for illustrative purposes various equivalent modifications are possible within the scope of the invention as those skilled in the relevant art will recognize. These modifications can be made to the invention in light of the above detailed description. Rather the scope of the invention is to be determined by the following claims which are to be interpreted in accordance with established doctrines of claim construction.

