---

title: Variable fragment shading with surface recasting
abstract: A system, method, and computer program product are provided for shading primitive fragments. A target buffer may be recast when shaded samples that are covered by a primitive fragment are generated at a first shading rate using a first sampling mode, the shaded samples are stored in the target buffer that is associated with the first sampling mode and the first shading rate, a second sampling mode is determined, and the target buffer is associated with the second sampling mode. A sampling mode and/or shading rate may be changed for a primitive. A primitive fragment that is associated with a first sampling mode and a first shading rate is received and a second sampling mode is determined for the primitive fragment. Shaded samples corresponding to the primitive fragment are generated, at a second shading rate, using the second sampling mode and the shaded samples are stored in a target buffer.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09355483&OS=09355483&RS=09355483
owner: NVIDIA Corporation
number: 09355483
owner_city: Santa Clara
owner_country: US
publication_date: 20130719
---
The present invention relates to shading and more particularly to shading graphics primitive fragments.

Conventional multi sample shading techniques compute one color value per fragment a collection of samples in a pixel that are covered by one triangle and the one color value is replicated to all covered samples within the pixel to produce an image with anti aliased edges. Super sample shading techniques compute a color for every sample in a fragment producing an image with anti aliased edges as well as anti aliased shading in the interior primitive regions. Therefore super sampling typically produces a higher quality anti aliased image compared with multi sampling. In general the processing frame rate using super sampling is proportional to the number of samples while the frame rate using multi sampling is proportional to the number of pixels.

Thus there is a need for balancing processing performance and image quality during shading and or addressing other issues associated with the prior art.

A system method and computer program product are provided for shading primitive fragments. A target buffer may be recast when shaded samples that are covered by a primitive fragment are generated at a first shading rate using a first sampling mode the shaded samples are stored in the target buffer that is associated with the first sampling mode and the first shading rate a second sampling mode is determined and the target buffer is associated with the second sampling mode. A shading rate and or sampling mode may be changed for a primitive. A primitive fragment that is associated with a first sampling mode and a first shading rate is received and a second sampling mode is determined for the primitive fragment. Shaded samples corresponding to the primitive fragment are generated at a second shading rate using the second sampling mode and the shaded samples are stored in a target buffer.

A sampling mode specifies a number of samples per pixel. Conventionally the number of samples per pixel is greater than or equal to one. A shading rate specifies the number of samples that are shaded for each pixel that is fully covered by a primitive fragment. The shading rate may be used to specify whether shading is performed using a super sample technique or a multi sample technique. For example a shading rate of one indicates that shading is performed using a multi sample technique because a single shaded sample value is computed and used for all of the samples of a pixel. A shading rate of N where N is greater than one indicates that shading is performed using a super sample technique because N shaded sample values are computed for each pixel. In general a higher shading rate corresponds to a higher quality image. A target buffer into which the shaded samples are stored is associated with a sampling mode and a shading rate. Conventionally primitives are processed according to a sampling mode and a shading rate and the same sampling mode and shading rate are associated with the target buffer. The sampling mode and shading rate may determine how data stored in the target buffer is interpreted and or the resolution of the target buffer.

Based on application requirements primitive fragments can be generated from a plurality of sampling modes and shading rates. For example one fragment may be generated using a one sampling mode while a second fragment from the same primitive may be generated at a second shading rate. The sampling mode and or the shading rate may be changed for the first and or second primitive. Shaded samples from both fragments are then stored in a target buffer. Based on the chosen sampling mode the graphics processor may be reconfigured for efficient utilization of internal datapaths achieved by recasting the target buffer to a new shading rate. The shading rate is variable per pixel or per group of two or more pixels and the rate may even be less than one so that a single shaded sample value is computed for more than one pixel as described further herein. In other words a sampling rate may effectively be less than once per pixel.

The shading rate and or sampling mode may be determined or changed for each graphics primitive while the graphics primitive is being rendered to improve performance. For example shading may be performed at an decreased shading rate when a graphics primitive associated with a super sample or anti aliased sampling mode is processed using an aliased sampling mode. In the context of the following description the shading rate is a number of samples that are shaded per pixel so that an increased shading rate corresponds to an increase in per pixel shader program execution. In particular the shading rate can be decreased for graphics primitives that do not cover all of the pixels in a pixel group when a processing core is configured to process the pixels in the pixel group in parallel even processing a pixel in the pixel group that is not covered by a graphics primitive. When a super sample sampling mode is used a color value is computed for each sample location in a pixel and a high quality anti aliased image may be produced. Therefore the highest shading rate when a super sample sampling mode is used is N shader program executions to compute N shaded samples for a fully covered pixel group assuming that 4 pixels are in a pixel group and each pixel includes N sample locations.

In contrast when a multi sample sampling mode is used a single color value is computed for one sample location in a pixel typically the pixel center and the single color value is used i.e. replicated for all of the sample locations in the pixel. While a multi sample sampling mode may also be used to produce an anti aliased image the shading quality may be lower in terms of color frequency compared with an image produced using a super sample sampling mode. The highest shading rate when a multi sample sampling mode is used is 1 shader program execution for a fully covered pixel group assuming that 4 pixels are in a pixel group and that one shaded sample is computed for each pixel.

When a multi sample sampling mode is used shading may also be performed at a decreased shading rate when a graphics primitive associated with a first multi sample sampling mode is processed using a second multi sample sampling mode that has more sample locations for each pixel compared with the first multi sample sampling mode. For example a graphics primitive associated with a 2 sample per pixel multi sample sampling mode is processed using a 8 sample per pixel multi sample sampling mode so that each 8 shaded samples that are generated correspond to 4 pixels of a 2 sample per pixel target surface instead of a single pixel. Therefore the shading rate decreases by 4 compared when rendering to the 2 sample per pixel target surface using the 8 sample per pixel sampling mode. Specifically the 8 shaded samples correspond to four pixels each having 2 samples instead of 1 pixel having 8 samples. The shading rate is reduced from one to 1 4 shaded sample per pixel.

More illustrative information will now be set forth regarding various optional architectures and features with which the foregoing framework may or may not be implemented per the desires of the user. It should be strongly noted that the following information is set forth for illustrative purposes and should not be construed as limiting in any manner. Any of the following features may be optionally incorporated with or without the exclusion of other features described 

A parallel processing unit may be configured to process a group of pixels in parallel to generate the shaded color values for the samples i.e. shaded samples . Processing a 2 2 group of pixels enables the processing unit to compute texture coordinate derivative values e.g. du d du dy dv d and dv dy that can be used to compute a texture level of detail for the four pixels within the 2 2 pixel group. However the parallel processing unit is also configured to perform the shading operations for the pixels in the 2 2 pixel group in a SIMD Single Instruction Multiple Data manner.

A thread i.e. a thread of execution is an instantiation of a set of instructions such as shader program instructions. A set of threads is executed in parallel to process a pixel group. The parallel processing unit allocates a thread to each pixel in the pixel group and each thread produces a different shaded sample each time the set of threads execute the shader program instructions for the pixel. When multi sampling is used each thread in the set of threads executes the shader program instructions once to produce the single color value for a respective pixel in the pixel group. The shading rate is one shaded sample or one thread shader program execution per pixel regardless of the number of samples that are stored for a multi sample mode .

When super sampling is used each thread executes the shader program instructions once to produce a color value for one sample of a respective pixel in the pixel group. When the pixels include four samples each thread will execute the shader program instructions four times to produce the four shaded samples of a respective pixel. Four threads are consumed per pixel.

A drawback of the SIMD processing technique used by the parallel processing unit is that the four threads execute the shader program instructions even when one the sample is not covered by a primitive. For example as shown in a primitive covers the four sample locations A B C and D of the pixel and does not cover any sample locations in the other pixels of the 2 2 pixels group namely pixels and . Each of the four threads executes the shader program instructions to generate a shaded sample for location A in the pixels and . Because location A is not covered by the primitive for pixels and three of the four threads are actually idle or disabled and do not necessarily execute the shader program instructions. The three idle threads are not available to perform other processing while a shaded sample is produced for one or more of the pixels in the 2 2 pixel group. Therefore when the thread allocated to produce shaded samples for locations B C and D in the pixel executes the shader program instructions a second third and fourth time the threads allocated to the pixels and are also idle. The number of threads that are consumed computing a shaded sample or idle for the primitive fragment is 16 to shade the pixel . Clearly some processing efficiency is lost when shading a primitive that does not cover at least one sample in each pixel of a pixel group.

As previously explained when a multi sample sampling mode is used a single color value is produced by each thread and the single color value may be computed for the pixels centers. As shown in color values are computed for the pixel centers and corresponding to the pixels and respectively. Primitive fragment may be rendered to a target buffer having a higher resolution so that each sample of the pixel group corresponds to a different pixel of the pixel group . For example a target buffer designated as a 640 480 pixel buffer configured to store 4 super sample pixels may be recast as a 1280 960 pixel buffer configured to store 1 multi sample pixels during the generation and storing of the shaded samples for the primitive fragment .

The primitive fragment is processed using a 1 multi sample sampling mode for the recast target buffer having 4 the resolution so that each of the 4 threads generates a shaded sample when the shader program instructions are executed. The shader program instructions only need to be executed once to generate the four shaded samples and none of the threads are idle. The shaded samples are written to the recast target buffer so that the four shaded samples are stored for the pixel . The shading rate for the primitive fragment is decreased by 4 from 4 shaded samples per pixel to 1 shaded sample per pixel. Correspondingly the number of threads that are consumed to compute shaded samples is reduced from 16 threads for processing the pixel group using the 4 super sample sampling mode to 4 threads for processing the pixel group using the 1 multi sample sampling mode.

In another example in which each pixel includes 8 sample locations a primitive fragment covering all samples of a single pixel may be processed using a ix multi sample sampling mode for a target buffer having 8 the resolution so that each of the 4 threads generates a shaded sample when the shader program instructions are executed. The shader program instructions only need to be executed twice to generate the eight shaded samples. The shaded samples may then be written to a 1 resolution target buffer so that the eight shaded samples are stored for the covered pixel. The shading rate for the primitive fragment is decreased by 4 from 32 shaded samples per pixel to 8 shaded samples per pixel. Correspondingly the number of thread shader program executions for processing the primitive fragment for the pixel group using the 8 super sample sampling mode is reduced from 32 to 8.

A high quality anti aliased image may be produced by changing the sampling mode used to generate shaded samples for primitive fragments from a super sample to a multi sample sampling mode and shading performance may be improved by the resulting decreased shading rate. However the locations of the samples that are generated for the pixel group are not the same as the sample locations A B C and D for the pixel because when a multi sample sampling mode is used instead of a super sample sampling mode the color values are computed for the pixel centers and . As shown in the corresponding sample locations A B C and D are offset from the pixel centers and within the pixels and respectively.

While the offset of the sampling locations does not necessarily compromise the quality of the color values the offset of the sampling locations can produce inaccurate texture map coordinates which may compromise the quality of the image. A driver kernel may be configured to offset the texture coordinates u v by inserting additional instructions into the shader program so that the texture coordinates computed for the pixels and equal the texture coordinates that would be computed for the sample locations A B C and D of the pixel . In one embodiment the driver kernel may also be configured to insert additional instructions into the shader program so that computed texture coordinate derivatives are scaled when the rendering resolution is changed. For example three of the shaded samples may be used to construct a derivative plane equation and each thread may execute an additional shader program instruction to obtain the value of an attribute corresponding to the sample location A B C or D. For example the additional shader program instruction may be configured to interpolate a plane equation to compute the value of the attribute. In one embodiment one or more additional shader program instructions are configured to offset texture coordinates and derivative computations when a target buffer is recast.

For some primitive fragments the coverage of the pixel group may not equal the pixel coverage for the pixel group when the sample locations A B C and D for the pixels in the pixel group are effectively mapped to the pixel center positions and in the pixel group . For example a sample location in the pixel group may be covered by a primitive fragment and the corresponding pixel center in the pixel group may not be covered by the primitive fragment so that a shaded sample would not be generated for the sample location. Similarly a narrow primitive fragment may cover a pixel center in the pixel group and not cover a sample location in the pixel group so that an unneeded shaded sample is generated for the sample location. In one embodiment the driver kernel may be configured to insert additional instructions into the shader program to jitter the sample patterns used for the multi sample sampling modes so that the sample locations are used instead of the pixel centers i.e. the sample locations A B C and D in the pixel group are used instead of the pixel centers and . In another embodiment changing the sampling mode from a super sample sampling mode to a multi sample sampling mode may be limited to full screen graphics primitives.

At operation the processing core determines if all of the pixels in a pixel group such as the pixel group are covered by a primitive fragment. When all of the pixels are not covered only a portion of the pixels in the pixel group that is processed in parallel by a set of threads is covered by the primitive fragment. If all of the pixels are covered then at operation one shaded sample is generated by each thread allocated to the pixel group. In the context of the present description the processing core may allocate one thread to each pixel of a pixel group and shader program instructions may cause the threads to determine if all of the pixels are covered by the primitive fragment. In one embodiment a pixel group may include two or more adjacent pixels e.g. 2 1 1 2 2 2 etc. .

At operation the super sample SS sampling mode is used to generate the shaded samples. At operation the processing core determines if another sample location should be processed for at least one of the pixels in the pixel group and if so the shader program is executed by one or more threads to generate shaded sample s for the other sample location. Otherwise shaded samples have been generated for the covered sample locations in the pixel group and at operation the threads store the shaded samples in a target buffer. The target buffer may be a color buffer that is stored in a memory and configured to store one or more shaded samples for each pixel.

If at operation the processing core determines that all of the pixels in the pixel group are not covered by the primitive fragment then at operation one shaded sample is generated by each thread allocated to the pixel group. At operation the super sample sampling mode that is associated with the primitive fragment is not used to generate the shaded samples. Instead a ix multi sample sampling mode is used to generate the shaded samples at operation .

When each pixel includes four samples and only a single pixel is covered by the primitive fragment the ix multi sample sampling mode corresponds to 4 thread shader program executions per pixel or a shading rate of 4 shaded samples per pixel so that all of the shaded samples may be generated when the four threads execute the shader program once. In contrast the shading rate corresponding to the super sample sampling mode is 16 shaded samples per pixel or 16 thread shader program executions per pixel. When each pixel includes four samples and only two pixels are covered by the primitive fragment the 1 multi sample sampling mode corresponds to a shading rate of four shaded samples per pixel or 4 thread shader program executions per pixel so that all of the shaded samples may be generated when the four threads execute the shader program twice. In contrast the shading rate corresponding to the super sample sampling mode is 16 shaded samples per two pixels or 16 thread shader program executions per two pixels .

At operation the processing core determines if another pixel should be processed for at least one of the pixels in the pixel group and if so the shader program is executed by one or more threads to generate shaded sample s for the other pixel. Otherwise shaded samples have been generated for the covered sample locations in the pixel group and at operation the threads store the shaded samples in a target buffer. The target buffer may be a color buffer that is stored in a memory and configured to store one or more shaded samples for each pixel.

As previously described the sampling mode may be changed from a super sample sampling mode to a multi sample sampling mode to decrease the shading rate. When a multi sample sampling mode is specified for shading one or more primitives a resolution of the multi sample mode may be changed to decrease the shading rate. The shading rate may be decreased so that each thread shader program execution computes shaded samples for multiple pixels by reducing the resolution of the multi sample mode. The color value computed for a pixel center is used to produce shaded samples for two or more pixels instead of being used to produce shaded samples for only one pixel.

A target buffer designated as a 1280 960 pixel buffer configured to store 2 multi sample pixels may be recast as a 640 480 pixel buffer configured to store 8 multi sample pixels during the generation and storing of the shaded samples for one or more primitive fragments. The edge sharpness of full resolution rendering may be preserved for the recast target buffer while the shading rate is decreased. However because a generated color value is replicated to generate shaded samples for multiple pixels recasting a multi sample buffer to a lower resolution buffer in terms of pixels is best suited for low frequency or constant color textures. Recasting a multi sample buffer to a lower resolution buffer may also be used to render shadowmaps where a shader program is configured to remove coverage based on whether a pixel is lit by a light source rather than compute a color value directly.

In one embodiment the sampling mode may be dynamically changed for shading each primitive fragment. In another embodiment the sampling mode may be changed to decrease the shading rate and reduce power consumption of a graphics processor. When recasting a multi sample buffer to a lower resolution buffer is used for final rendering post processing of the higher resolution target buffer may be used to interpolate values between groups of constant color pixels to reduce any screen door artifacts resulting from the decreased shading rate.

At operation the processing core determines if the shading rate should be decreased. If the shading rate should not be increased then at operation one shaded sample is generated by each thread allocated to a pixel in a pixel group and the first multi sample sampling mode is used to generate the shaded samples. At operation each thread replicates the one shaded sample based on the first multi sample sampling mode. For example when the first multi sample sampling mode is 4 the one shaded sample is replicated to produce 4 shaded samples. At operation the threads store the shaded samples in a target buffer. The target buffer may be a color buffer that is stored in a memory and configured to store one or more shaded samples for each pixel.

If at operation the processing core determines that the shading rate should be decreased then at operation a second multi sample sampling mode is determined that corresponds to a second shading rate. At operation one shaded sample is generated by each thread allocated to a pixel in a pixel group and the second multi sample sampling mode is used to generate the shaded samples. At operation each thread replicates the one shaded sample to generate shaded samples for multiple pixels based on the second multi sample sampling mode. For example when the first multi sample sampling mode is 8 and the second multi sample sampling mode is 2 the shaded sample for one pixel is replicated to produce 4 shaded samples for 4 different pixels. At operation the threads store the shaded samples in a target buffer. The target buffer may be a color buffer that is stored in a memory and configured to store one or more shaded samples for each pixel.

In one embodiment the PPU includes an input output I O unit configured to transmit and receive communications i.e. commands data etc. from a central processing unit CPU not shown over the system bus . The I O unit may implement a Peripheral Component Interconnect Express PCIe interface for communications over a PCIe bus. In alternative embodiments the I O unit may implement other types of well known bus interfaces.

The PPU also includes a host interface unit that decodes the commands and transmits the commands to the grid management unit or other units of the PPU e.g. memory interface as the commands may specify. The host interface unit is configured to route communications between and among the various logical units of the PPU .

In one embodiment a program encoded as a command stream is written to a buffer by the CPU. The buffer is a region in memory e.g. memory or system memory that is accessible i.e. read write by both the CPU and the PPU . The CPU writes the command stream to the buffer and then transmits a pointer to the start of the command stream to the PPU . The host interface unit provides the grid management unit GMU with pointers to one or more streams. The GMU selects one or more streams and is configured to organize the selected streams as a pool of pending grids. The pool of pending grids may include new grids that have not yet been selected for execution and grids that have been partially executed and have been suspended.

A work distribution unit that is coupled between the GMU and the SMs manages a pool of active grids selecting and dispatching active grids for execution by the SMs . Pending grids are transferred to the active grid pool by the GMU when a pending grid is eligible to execute i.e. has no unresolved data dependencies. An active grid is transferred to the pending pool when execution of the active grid is blocked by a dependency. When execution of a grid is completed the grid is removed from the active grid pool by the work distribution unit . In addition to receiving grids from the host interface unit and the work distribution unit the GMU also receives grids that are dynamically generated by the SMs during execution of a grid. These dynamically generated grids join the other pending grids in the pending grid pool.

In one embodiment the CPU executes a driver kernel that implements an application programming interface API that enables one or more applications executing on the CPU to schedule operations for execution on the PPU . An application may include instructions i.e. API calls that cause the driver kernel to generate one or more grids for execution. In one embodiment the PPU implements a SIMD Single Instruction Multiple Data architecture where each thread block i.e. warp in a grid is concurrently executed on a different data set by different threads in the thread block. The driver kernel defines thread blocks that are comprised of k related threads such that threads in the same thread block may exchange data through shared memory. In one embodiment a thread block comprises 32 related threads and a grid is an array of one or more thread blocks that execute the same stream and the different thread blocks may exchange data through global memory.

In one embodiment the PPU comprises X SMs X . For example the PPU may include 15 distinct SMs . Each SM is multi threaded and configured to execute a plurality of threads e.g. 32 threads from a particular thread block concurrently. Each of the SMs is connected to a level two L2 cache via a crossbar or other type of interconnect network . A color blend unit is configured to perform blend functions such as the blend function used to accumulate the modulated sample color values and combined modulated sample values into the color buffer that may be stored in the memory and cached in the L2 cache . In one embodiment the color blend unit may also be configured to modulate the sample color values for each pixel by setting the alpha value srcAlpha to the number of samples per pixel to generate a modulated sample color value or setting the alpha value to the per pixel coverage to generate a combined modulated sample color value. For example in terms of the OpenGL applications programming interface the blend func GL ADD blend src GL ALPHA blend dst GL ONE. The sample color value src is scaled by the alpha value and summed with the color value that is stored for the pixel dst .

The L2 cache is connected to one or more memory interfaces . Memory interfaces implement 16 32 64 128 bit data buses or the like for high speed data transfer. In one embodiment the PPU comprises U memory interfaces U where each memory interface U is connected to a corresponding memory device U . For example PPU may be connected to up to 6 memory devices such as graphics double data rate version 5 synchronous dynamic random access memory GDDR5 SDRAM .

In one embodiment the PPU implements a multi level memory hierarchy. The memory is located off chip in SDRAM coupled to the PPU . Data from the memory may be fetched and stored in the L2 cache which is located on chip and is shared between the various SMs . In one embodiment each of the SMs also implements an L1 cache. The L1 cache is private memory that is dedicated to a particular SM . Each of the L1 caches is coupled to the shared L2 cache . Data from the L2 cache may be fetched and stored in each of the L1 caches for processing in the functional units of the SMs .

In one embodiment the PHI comprises a graphics processing unit GPU . The PPU is configured to receive commands that specify shader programs for processing graphics data. Graphics data may be defined as a set of primitives such as points lines triangles quads triangle strips and the like. Typically a primitive includes data that specifies a number of vertices for the primitive e.g. in a model space coordinate system as well as attributes associated with each vertex of the primitive. The PPU can be configured to process the graphics primitives to generate a frame buffer i.e. pixel data for each of the pixels of the display . The driver kernel implements a graphics processing pipeline such as the graphics processing pipeline defined by the OpenGL API.

An application writes model data for a scene i.e. a collection of vertices and attributes to memory. The model data defines each of the objects that may be visible on a display. The application then makes an API call to the driver kernel that requests the model data to be rendered and displayed. The driver kernel reads the model data and writes commands to the buffer to perform one or more operations to process the model data. The commands may encode different shader programs including one or more of a vertex shader hull shader geometry shader pixel shader etc.

For example the GMU may configure one or more SMs to execute a vertex shader program that processes a number of vertices defined by the model data. In one embodiment the GMU may configure different SMs to execute different shader programs concurrently. For example a first subset of SMs may be configured to execute a vertex shader program while a second subset of SMs may be configured to execute a pixel shader program. The first subset of SMs processes vertex data to produce processed vertex data and writes the processed vertex data to the L2 cache and or the memory . After the processed vertex data is rasterized i.e. transformed from three dimensional data into two dimensional data in screen space to produce fragment data the second subset of SMs executes a pixel shader to produce processed fragment data which is then blended with other processed fragment data and written to the frame buffer in memory . The vertex shader program and pixel shader program may execute concurrently processing different data from the same scene in a pipelined fashion until all of the model data for the scene has been rendered to the frame buffer. Then the contents of the frame buffer are transmitted to a display controller for display on a display device.

A pixel shader program may be configured to generate images according to the techniques described in conjunction with when executed by one or more SMs . The driver kernel may be configured to insert additional instructions into a shader program as previously described. In one embodiment the processing cores are configured to dynamically determine a second sampling mode and corresponding shading rate based on a particular primitive fragment power consumption mode and or shading performance setting. A multi sample target buffer may be stored in the memory .

The PPU may be included in a desktop computer a laptop computer a tablet computer a smart phone e.g. a wireless hand held device personal digital assistant PDA a digital camera a hand held electronic device and the like. In one embodiment the PPU is embodied on a single semiconductor substrate. In another embodiment the PPU is included in a system on a chip SoC along with one or more other logic units such as a reduced instruction set computer RISC CPU a memory management unit MMU a digital to analog converter DAC and the like.

In one embodiment the PHI may be included on a graphics card that includes one or more memory devices such as GDDR5 SDRAM. The graphics card may be configured to interface with a PCIe slot on a motherboard of a desktop computer that includes e.g. a northbridge chipset and a southbridge chipset. In yet another embodiment the PPU may be an integrated graphics processing unit iGPU included in the chipset i.e. Northbridge of the motherboard.

As described above the work distribution unit dispatches active grids for execution on one or more SMs of the PPU . The scheduler unit receives the grids from the work distribution unit and manages instruction scheduling for one or more thread blocks of each active grid. The scheduler unit schedules threads for execution in groups of parallel threads where each group is called a warp. In one embodiment each warp includes 32 threads. The scheduler unit may manage a plurality of different thread blocks allocating the thread blocks to warps for execution and then scheduling instructions from the plurality of different warps on the various functional units i.e. cores DPUs SFUs and LSUs during each clock cycle.

In one embodiment each scheduler unit includes one or more instruction dispatch units . Each dispatch unit is configured to transmit instructions to one or more of the functional units. In the embodiment shown in the scheduler unit includes two dispatch units that enable two different instructions from the same warp to be dispatched during each clock cycle. In alternative embodiments each scheduler unit may include a single dispatch unit or additional dispatch units .

Each SM includes a register file that provides a set of registers for the functional units of the SM . In one embodiment the register file is divided between each of the functional units such that each functional unit is allocated a dedicated portion of the register file . In another embodiment the register file is divided between the different warps being executed by the SM . The register file provides temporary storage for operands connected to the data paths of the functional units.

Each SM comprises L processing cores . In one embodiment the SM includes a large number e.g. 192 etc. of distinct processing cores . Each core is a fully pipelined single precision processing unit that includes a floating point arithmetic logic unit and an integer arithmetic logic unit. In one embodiment the floating point arithmetic logic units implement the IEEE 754 2008 standard for floating point arithmetic. Each SM also comprises M DPUs that implement double precision floating point arithmetic N SFUs that perform special functions e.g. copy rectangle pixel blending operations and the like and P LSUs that implement load and store operations between the shared memory L1 cache and the register file . In one embodiment the SM includes 64 DPUs 32 SRN and 32 LSUs .

Each SM includes an interconnect network that connects each of the functional units to the register file and the shared memory L1 cache . In one embodiment the interconnect network is a crossbar that can be configured to connect any of the functional units to any of the registers in the register file or the memory locations in shared memory L1 cache .

In one embodiment the SM is implemented within a GPU. In such an embodiment the SM comprises J texture units . The texture units are configured to load texture maps i.e. a 2D array of texels from the memory and sample the texture maps to produce sampled texture values for use in shader programs. The texture units implement texture operations such as anti aliasing operations using mip maps i.e. texture maps of varying levels of detail . In one embodiment the SM includes 16 texture units .

The PPU described above may be configured to perform highly parallel computations much faster than conventional CPUs. Parallel computing has advantages in graphics processing data compression biometrics stream processing algorithms and the like.

The system also includes input devices a graphics processor and a display i.e. a conventional CRT cathode ray tube LCD liquid crystal display LED light emitting diode plasma display or the like. User input may be received from the input devices e.g. keyboard mouse touchpad microphone and the like. In one embodiment the graphics processor may include a plurality of shader modules a rasterization module etc. Each of the foregoing modules may even be situated on a single semiconductor platform to form a graphics processing unit GPU .

In the present description a single semiconductor platform may refer to a sole unitary semiconductor based integrated circuit or chip. It should be noted that the term single semiconductor platform may also refer to multi chip modules with increased connectivity which simulate on chip operation and make substantial improvements over utilizing a conventional central processing unit CPU and bus implementation. Of course the various modules may also be situated separately or in various combinations of semiconductor platforms per the desires of the user.

The system may also include a secondary storage . The secondary storage includes for example a hard disk drive and or a removable storage drive representing a floppy disk drive a magnetic tape drive a compact disk drive digital versatile disk DVD drive recording device universal serial bus USB flash memory. The removable storage drive reads from and or writes to a removable storage unit in a well known manner.

Computer programs or computer control logic algorithms may be stored in the main memory and or the secondary storage . Such computer programs when executed enable the system to perform various functions. For example a compiler program that is configured to examiner a shader program and enable or disable attribute buffer combining may be stored in the main memory . The compiler program may be executed by the central processor or the graphics processor . The main memory the storage and or any other storage are possible examples of computer readable media.

In one embodiment the architecture and or functionality of the various previous figures may be implemented in the context of the central processor the graphics processor an integrated circuit not shown that is capable of at least a portion of the capabilities of both the central processor and the graphics processor a chipset i.e. a group of integrated circuits designed to work and sold as a unit for performing related functions etc. and or any other integrated circuit for that matter.

Still yet the architecture and or functionality of the various previous figures may be implemented in the context of a general computer system a circuit board system a game console system dedicated for entertainment purposes an application specific system and or any other desired system. For example the system may take the form of a desktop computer laptop computer server workstation game consoles embedded system and or any other type of logic. Still yet the system may take the form of various other devices including but not limited to a personal digital assistant PDA device a mobile phone device a television etc.

Further while not shown the system may be coupled to a network e.g. a telecommunications network local area network LAN wireless network wide area network WAN such as the Internet peer to peer network cable network or the like for communication purposes.

While various embodiments have been described above it should be understood that they have been presented by way of example only and not limitation. Thus the breadth and scope of a preferred embodiment should not be limited by any of the above described exemplary embodiments hut should be defined only in accordance with the following claims and their equivalents.

