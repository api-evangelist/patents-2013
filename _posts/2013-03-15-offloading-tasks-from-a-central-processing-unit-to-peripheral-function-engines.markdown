---

title: Offloading tasks from a central processing unit to peripheral function engines
abstract: An apparatus includes an array of universal digital blocks (UDBs) and a central processing unit (CPU) coupled to the array of UDBs via a bus. The UDBs may be coupled together to perform tasks, operations or functions that may be offloaded from the CPU to the array of UDBs.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08990455&OS=08990455&RS=08990455
owner: Cypress Semiconductor Corporation
number: 08990455
owner_city: San Jose
owner_country: US
publication_date: 20130315
---
The present disclosure relates generally to microcontrollers and particularly to components of a microcontroller.

A system on chip SoC may include a central processing unit CPU and multiple other components for performing various functions operations calculations or actions. Often complex calculations are performed by the CPU of the SoC because the other components of the SoC are not complex enough or do not have enough processing power to perform the complex calculations. For example calculation of a square root value is often performed by the CPU. In another example performing automatic gain control is often performed by the CPU. In a further example calculating the root mean square is often performed by the CPU. As the requirements of users and applications executed by the SoC become more complex the burden on the CPU increases because the CPU performs most if not all of the complex calculations or operations. This may cause delays when the CPU performs multiple operations and may also cause the CPU to user more processing resources which may cause the CPU to user more power.

The following description sets forth numerous specific details such as examples of specific systems components methods and so forth in order to provide a good understanding of several embodiments of the present invention. It will be apparent to one skilled in the art however that at least some embodiments of the present invention may be practiced without these specific details. In other instances well known components or methods are not described in detail or are presented in simple block diagram format in order to avoid unnecessarily obscuring the present invention. Thus the specific details set forth are merely exemplary. Particular implementations may vary from these exemplary details and still be contemplated to be within the scope of the present invention.

In one embodiment certain processing tasks are performed outside of a central processing unit CPU using a network of distributed universal digital blocks UDBs connected via DMA and programmable logic. Multiple UDBs may be coupled together to perform task calculations operations and functions that a single UDB may be unable to perform. By connecting the memory registers datapaths and processing logic of UDBs the UDBs may be combined to perform complex task allowing the CPU to offload these tasks to the UDBs. The CPU may use fewer processing resources use processing resources for a shorter amount of time and may use less power when offloading tasks to UDBs. illustrates an embodiment of a core architecture of a Programmable System on Chip PSoC such as that used in the PSoC family of products offered by Cypress Semiconductor Corporation San Jose Calif. . In one embodiment the core architecture includes a digital subsystem . The digital subsystem includes a universal digital block array comprising a plurality of universal digital blocks UDBs a CAN 2.0 interface controller CAN 2.0 an IC Master and Slave controller IC M S a plurality of multifunction digital blocks MDBs and a full speed USB 2.0 interface controller FSUSB 2.0 . MDBs may be configured to perform common digital functions such as timers counters and pulse width modulators PWMs . The elements of digital system may be coupled to digital interconnect and or to the system bus .

The core architecture may also include an analog subsystem . The analog subsystem may include an LCD direct drive block a digital filter block DFB a plurality of switched capacitor continuous time mixed function analog SC CT blocks a temperature sensor block a capacitive sensing CapSense block a plurality of digital to analog converters an analog to digital converter ADC including a delta sigma ADC a plurality of operational amplifiers opamps and a plurality of comparators CMP . The elements of analog subsystem may be coupled to analog interconnect and or the system bus . CapSense block may be coupled to the analog interconnect separate from other elements of analog subsystem .

The core architecture may also include memory subsystem CPU subsystem and programming and debug subsystem . Memory subsystem may include an EEPROM block synchronous random access memory SRAM an external memory interface EMIF block and flash memory FLASH . CPU subsystem may include a CPU an interrupt controller and a bus bridge controller DMA PHUB which may include a direct memory access DMA controller . The program and debug subsystem may include a programming block and debug and trace block and a boundary scan block . The program and debug subsystem may be coupled to the CPU subsystem. The CPU subsystem and the memory system may be coupled to system bus . The memory subsystem may be coupled to the CPU subsystem through the system bus . In one embodiment FLASH may be coupled to the CPU directly.

The core architecture may also include system wide resources . System wide resources may include a clocking subsystem and power management subsystem . Clocking subsystem may include an internal low speed oscillator block ILO a watch dog timer WDT and wake up controller block a real time clock RTC timer block an internal main oscillator block IMO a crystal oscillator block Xtal Osc a clock tree power manager and reset block . In one embodiment the RTC timer block and the ILO may be coupled to the WDT and wake up controller block . In another embodiment clock tree may be coupled to xtal osc block and IMO . Power management system may include power on reset POR and low voltage dropout LVD block a sleep power block a 1.8V internal regulator LDO a switch mode pump SMP and power manager . Power manager may be coupled to power manager of the clocking subsystem . In one embodiment system wide resources may be coupled to system bus .

The core architecture may also include a plurality of pins . Pins may be used to connect elements of core architecture to off chip elements or route signals into out of or to different pins of the device. Core architecture may also include a plurality of special input outputs SIOs and general purpose input outputs GPIOs . SIOs may be coupled to digital interconnect . GPIOs may be coupled to analog interconnect digital interconnect RTC timer block and or Xtal Osc block . Core architecture may also include USB input outputs USB PHY which may be coupled to FSUSB 2.0 .

Digital subsystem portion may include a plurality of digital core system elements such as clock dividers and memory fixed function peripherals and IO ports coupled to a digital routing fabric e.g. digital system interconnect DSI . DSI may be coupled to UDB array which may include a plurality of UDBs . UDBs fixed function peripherals IO ports interrupts DMA and digital core system elements may be coupled to the DSI to implement full featured device connectivity. DSI may allow any digital function to be routed to any pin or other feature to be routed when coupled through UDB array . In one embodiment UDBs may be a collection of uncommitted logic PLD and structural logic optimized to create common embedded peripherals and customized functionality that are application or design specific. In one embodiment UDBs may be arranged in a matrix with a homogenous structure to allow flexible mapping of digital functions onto the array. The array may support extensive and flexible routing interconnects between UDBs and DSI .

UDB e.g. peripheral function engine may include a first programmable logic device PLD coupled to PLD chaining IO routing channel through routing IO and a second PLD . Second PLD may be coupled to PLD chaining IO first PLD and routing channel through routing IO . UDB may also include a clock and reset control block which may be coupled to a status and control block . Status and control block may be coupled to routing channel through routing IOs and . UDB may also include a datapath module which is coupled through to datapath modules of other UDBs through datapath chaining IOs and . PLDs and may take inputs from the routing channel and form registered or combinational sum of products logic and may be used to implement state machines state bits and combinational logic equations. In some embodiments PLD configurations may be automatically generated from graphical primitives where functions are mapped to the PLD the PLD is configured based on the settings of those functions. In some embodiments datapath module may be a datapath containing structured logic to implement a dynamically configurable arithmetic logic unit ALU and a variety of compare configurations and conditions. The datapath module may also contain input output FIFOs to serve as the parallel data interface between the CPU system and the UDB . The status and control block may be used by the UDB to interact with and synchronize to the CPU e.g. . In one embodiment DMA may be used to couple the FIFOs and the status and control block to other UDBs or the CPU.

Datapath module may include six primary working registers which may be accessed by the CPU or DMA during device operation. Primary working registers may be categorized as accumulators A0 and A1 data registers D0 and D1 or FIFOs F0 and F1 . In one embodiment accumulators may be sources and sinks for ALU or sources for compares. Data registers may be sources for ALU as well as for compares. FIFOs may be primary interfaces to system bus . FIFOs may also be data sources for the data registers and accumulators. FIFOs may also capture data from accumulators and from ALU . In one embodiment each FIFO may be four bytes deep.

ALU may be configured to perform a variety of general purpose functions by writing to ALU control registers not shown or sending control signals to ALU . Digital functions may include Increment Decrement Add Subtract Logical AND Logical OR and Logical XOR. Digital functions may be reloaded into the ALU and selected by writing to ALU control registers not shown by the CPU e.g. or the DMA controller e.g. . Datapath module may also be configured to perform functions independent of ALU operation. Such functions may include Shift Left Shift Right Nibble Swap and Bitwise OR Mask.

Datapath module may be optimized to implement embedded functions such as timers counters integrators PWMs pseudo random sequence generators PRSs cyclic redundancy checks CRCs shifters dead band generators and other digital functions by writing to ALU control registers not shown with the CPU e.g. or the DMA controller e.g. .

In one embodiment datapath module may be configured to chain conditions and signals with neighboring datapaths to create higher precision arithmetic shift CRC or PRS functions.

In one embodiment ALU may be shared in applications that are over sampled or do not need high clock rates. Carry and shift out data from ALU may be stored in data registers and may be selected as inputs in subsequent cycles. Such a configuration may provide support for functions that require greater bit lengths than are available in a single datapath.

In one embodiment conditions may be created by datapath module which may include two compare operands. The two compares of datapath module may have bit masking options. Compare operands may include accumulators A0 and A1 and data registers D0 and D1 in a variety of configurations. Other conditions created by datapath module may include zero detect all ones detect and overflow. Conditions may be the primary outputs of datapath module . The outputs of datapath module may be driven out to the UDB routing matrix. In one embodiment conditional computation can use the built in chaining to neighboring UDBs to operate on wider data widths without the need to use routing resources.

In one embodiment the most significant bit MSB of ALU and shift function may be programmatically specified to support variable width CRC and PRS functions. In conjunction with masking function the MSB of ALU and shift function may implement arbitrary width timers counters and shift blocks.

Datapath module may include built in support for single cycle CRC computation and PRS generation of arbitrary width and arbitrary polynomial. CRC and PRS functions longer than eight bits may be implemented in conjunction with PLD logic or built in chaining may be used to extend the functions into neighboring UDBs.

FIFOs F0 and F1 may be four bytes deep and configured independently as an input buffer or an output buffer. In the case of an input buffer system bus may write to the FIFO and datapath module may perform an internal read of the FIFO. In the case of an output buffer datapath module may perform an internal write to the FIFO and system bus may read from the FIFO. FIFOs F0 and F1 may generate a status that is selectable as a datapath output and can be driven to routing. Once driven to routing the status generated by F0 and F1 may interact with sequencers to move the device between states or to execute ordered functions interact with interrupts to generate tasks in software or interact with the DMA to store the status to a memory location or registers without consuming CPU overhead.

UDB status and control module includes routing channel . Routing channel may be coupled to status register and control register . Status register and control register are coupled to system bus . In one embodiment the bits of control register which may be written to by the system bus may be used to drive into the routing matrix and provide firmware with the opportunity to control the state of UDB processing. The status register may allow the state of the UDB to be read out onto the system bus directly from internal routing. Status register and control register may have programmable connections to the routing matrix which allows routing connections to be made depending on the requirements of the application.

In some embodiments device peripherals that are connected by DSI may include timers and counters a CAN interface an IC interface an interrupt controller a DMA controller IO port pins global clocks an EMIF delta sigma ADCs SC CT blocks DACs comparators or any other digital core or fixed function peripheral that may use programmable routing. Signals that may use programmable routing may include but are not limited to 

Embodiments including flexible interrupt and DMA routing in the DSI allow for more efficient and faster routing of signals and configuration of digital subsystem components. illustrates one embodiment of an interrupt and DMA controller . Fixed function interrupt request lines IRQs may be routed into UDB array through input and out through output . Fixed function DRQs may be routed into UDB array through input and out through output . IRQs may then be routed through an edge detect through input and output . DRQs may be routed through an edge detect through input and output . Fixed function DRQs DRQs and the output of edge detect may be routed through MUX to the input of DMA controller . Fixed function IRQs IRQs from the UDB array the output of DMA controller and the output of edge detect may be routed through MUX to interrupt controller . In one embodiment the DMA output signal may be routed on the DSI so that the DMA output signal may be provided to UDBs trigger interrupts or perform other DMA etc.

DMA controller and a CPU interface CPU I F are part of a peripheral hub PHUB . PHUB may be coupled to the UDB array shown in the memory subsystem e.g. the USB controller or other system peripherals which may include elements of the analog subsystem the digital subsystem or system wide resources e.g. . The DMA controller through the PHUB may be coupled to the CPU e.g. which may also receive signals from the UDB array .

Flash memory provides nonvolatile storage for user firmware user configuration data bulk data storage and optional error correcting code ECC . In some embodiments flash space may be allocated to ECC specifically. In other embodiments the flash space allocated to ECC may be reallocated to other flash memory functions when not used for ECC. ECC may correct and detect errors in firmware memory. In some embodiments an interrupt may be generated when an error is detected.

Programming of flash memory may be performed through a special interface and preempt code execution out of flash memory. The flash programming interface may perform flash erasing programming and setting code protection levels. Flash in system serial programming ISSP typically used for production programming may be possible through both the SWD and JTAG interfaces. In system programming typically used for bootloaders may be completed through interfaces such as I2C USB UART SPI or other communication protocols. Flash memory may include a flexible flash protection model that prevents access and visibility to on chip flash memory. The flash protection module may prevent duplication or reverse engineering of proprietary code.

EEPROM memory may be a byte addressable nonvolatile memory. Reads from EEPROM may be random access at the byte level. Reads may be completed directly writes may be completed by sending write commands to an EEPROM programming interface. CPU code execution may continue using programs stored in flash memory during EEPROM writes. EEPROM may be erasable and writeable at the row level. In some embodiments EEPROM may be divided into 128 rows of 16 bytes each. In other embodiments EEPROM may be divided into more or fewer rows or more or fewer bytes.

Reconfigurable routing of the analog subsystem allows IOs to be routed to any analog resource as a bank of functions DAC comparators SC CT functional blocks opamps etc. . Additionally reconfigurable routing of the analog subsystem may allow intra block routing or intra channel routing for specific functions DAC comparators SC CT functional blocks opamps etc. . The reconfigurable routing may be controlled by the microprocessor CPU the DMA register interfaces or by programmable digital logic. In one embodiment UDBs may be configured to provide the programmable digital logic that controls the analog reconfigurability.

Signal processing characteristics of analog and mixed signal blocks banks of blocks or channels may be controlled by programmable digital logic regardless of their type. For example an ADC and a comparator which are not part of the same analog block or bank or channel may be reconfigured to output or process signals by the same control element such as a UDB or DMA controller.

Data and clock signals from analog and mixed signal blocks banks or channels may be routed on chip to other analog and mixed signal blocks banks or channels or to digital subsystem components to extend the signal processing capability of the device. For example a digital filtering of an ADC output spread spectrum clocking and clocking with variable jitter may be accomplished by routing analog and mixed signal outputs through the programmable interconnect to other on chip elements.

Additionally analog and mixed signal blocks banks and channels may be controlled synchronously or asynchronously by digital signals from the clocking or digital subsystems through analog routing.

As discussed above a UDB e.g. peripheral function engine includes a datapath PLDs a status and control block and a clock and reset control block. In one embodiment the data path may be where a majority of arithmetic and computational operations are formed. For example if an 8 bit counter is implemented using a UDB e.g. peripheral function engine the increment and decrement functions may be implemented in the datapath. In one embodiment the datapath may be a configurable ALU with configurable FIFOs and working registers. The datapath may have no program memory associated with it. The datapath may be programmed with different op codes that may cause the ALU to perform different functions e.g. adding subtracting incrementing decrementing XORing ANDing multiplying shifting etc. In one embodiment the PLDs may control the operation of the datapath. For example the PLDs may be used to control the order of operations performed by the data path. Many functions operations actions and or tasks may be performed using the datapaths and PLDs of the UDBs. For example a delta sigma modulator cyclic redundancy check or I2C component may be implemented using UDBs. In one embodiment the PLDs can be chained together to create larger implementations of a function as well. For example multiple PLDs from multiple UDBs may be chained together to implement a 16 bit counter instead of an 8 bit counter.

In one embodiment the status and control block may be used as an interface with the rest of the system e.g. the other components of the PSoC . For example the status and control blocks of different UDBs may be connected to facilitate a higher level control of the UDBs e.g. changing modes speeds reading component status etc. . The status and control block may also be a public location for control or status data for the different components of the system. The status and control block may function as an interface between the firmware and digital domains.

When performing more complicated tasks functions or operations a single UDB or multiple chained UDBs may be insufficient. For example implementing a single pole IIR filter or a square root calculator may use a more complicated configuration of UDBs e.g. an array of peripheral function engines . In one embodiment the datapaths of a first set of UDBs may perform calculations that help control the datapaths of another set of UDBs that are performing the arithmetic or logical operations. For example as discussed further below in conjunction with when configuring UDBs to calculate the square root of a number a first datapath in one UDB may be a counter whose maximum value is constantly decrementing. This helps the other datapaths in the other UDBs keep track of shifting. The datapaths in the first set of UDBs may be controlled by a state machine e.g. by PLDs . The other datapaths may be chained or may execute different functions in parallel. The state machines are implemented in the PLDs to control each set of datapaths. DMA may be configured to facilitate data transfer between different datapaths in different UDBs between RAM and between status and control blocks.

In one embodiment datapaths may be configured by specifying the op codes that the datapaths may execute. For example when configuring UDBs to perform square root calculations the square root calculation algorithm may be divided into a finite set of operations and the order in which the operations should be executed. These operations may be mapped to the capabilities of the UDBs datapath. For example addition may be mapped to addition capabilities of the datapath multiplication may be mapped to a series of shifts and additions capabilities of the datapath etc. These operations sometimes may be combined with other operations to save program space. Some operations may involve movement or sharing of data between datapaths or from one datapath s output to the same datapath s input etc. DMA may be used to move or share data between datapaths or UDBs. Datapaths may be configured using a configuration tool such as an application program software module or software component that may be executed by a SoC e.g. by the CPU of a SoC . In one embodiment the configuration tool may translate data such as op codes mask values shift preferences etc. into a Verilog macro or code. The Verilog macro or code may be used to configure the datapath when programming the SoC.

The DMA may be configured using a programming language e.g. the C programming language or another high level language or using application programming interfaces APIs . The APIs may be used to translate abstract functions like allocating a memory location e.g. a register to the register writes executed by the CPU to the DMA Controller DMAC . In one embodiment the DMA may be configured by the CPU e.g. when the SoC starts up to respond to digital signals from the datapaths or their controlling state machines implemented in PLDs. In one embodiment by configuring the DMA to couple datapaths to each other when a datapath indicates that the datapath has completed a certain step of the calculation a logic signal connected to a DMA channel s input request terminal may be set to high. This may cause the datapath s result to be moved to its destination. In one embodiment a Verilog macro or code may be also be used to configure the PLDs when programming the SoC.

In other embodiments an array of UDBs may be coupled together and configured to perform other functions such as signal demodulation voltage rail monitoring and digital filter chains.

In one embodiment two configurations of UDBs may be used to calculate the square root using the Newton Raphson iteration method. The first UDB configuration has a shifting datapath which keeps track of shifting used for multiplication in the Newton Raphson iteration method. The other UDB configuration has a computational datapath which will perform the arithmetic or logical operations to calculate the square root. There may be X number of the computational datapaths used wherein X is the number of bytes in the input value. The UDB with the shifting datapath is used because the number of shifts performed in the Newton Raphson iteration method should decrement over the course of the square root calculation. In one embodiment a state machine is implemented in PLDs of the UDBs to control which op codes are selected in each cycle. The state machine receives status inputs from the datapaths via a configurable digital interconnect and outputs op code selection signals to the datapaths via the configuration digital interconnect .

The computational datapath may use the op codes listed above in Table 1 when performing calculations or operations. The op code 0 indicates that the computational datapath should not perform an action. The op code 1 indicates that the computational datapath should read the value 1 from the register e.g. register D1 . The op code 2 indicates that value in register e.g. register A1 should be shifted left by one bit. The op code 3 indicates that the value in register E.g. register A1 should be added to the value in register e.g. register A0 . The op code 4 indicates that register e.g. register A0 should be set to the value of register e.g. register D0 . The op code 5 indicates that register e.g. register A0 should be set to the value of the input stored in register e.g. register F0 . The op code 6 indicates that the register e.g. register A1 should be set to the value of register e.g. register A0 . The op code 7 indicates that the value of register should be set to the value of register minus the value of register . In one embodiment the different op codes in Table 1 may be commands that are programmed into the configuration memory of the computational datapath such that the datapath will execute the operation listed in Table 1 when the computational datapath receives control input e.g. receives input from a state machine or a PLD . It should be noted that the op codes listed in Table 1 may not define the order in which commands are issued. The op codes listed in Table 1 illustrate the type of commands that the computational datapath may receive from a state machine or a PLD.

The datapath may use the op codes listed above in Table 2 when tracking the current round s shifting limit. The op code 0 indicates that the datapath should not perform an action. The op code 1 indicates that the datapath should subtract one from the register . The op code 2 indicates the datapath should subtract one from value of register . The op code 3 indicates that the value in register should be set to the value in register . The op code 4 indicates that register should be set to the value of register . The op code 5 indicates that the value of register should be incremented by 1. The op codes 6 and 7 are not used by the shifting datapath .

Referring to the method starts at block where the method identifies a task from a plurality of tasks to offload from a CPU to an array of UDBs e.g. an array of peripheral function engines . In one embodiment a user e.g. a designing engineer may determine that certain tasks or functions may be offloaded to the array of UDBs. For example a task that completely handles or performs a certain functionality handles or performs the beginning or end of the functionality may be offloaded to the array of UDBs. For example performing automatic gain control may free CPU time for other operations. In another example front end filtering allows the CPU more contiguous processing time before the CPU takes the input value and processes the input value. In a further example calculating a square root value may be a final calculation that may be provided straight to a serial interface after completion. By calculating the square root value using the array of UDBs this may reduce the computational bandwidth used by the CPU.

The user may store different configuration data e.g. Verilog macros APIs source code such as C source code files etc. that may include information that may be used to configure the UDBs to perform tasks that the user determines may be offloaded to the UDBs. A configuration module or component may use the configuration data to configure the UDBs in the SoC. A configuration module or component may be a software application or component e.g. a compiler a hardware component e.g. a circuit that is coupled to the SoC or is part of the SoC or a combination of both. In one embodiment when an SoC performs functions or operations e.g. when the SoC executes an application the user may provide user input to indicate to the configuration module that one or more tasks should be offloaded to the UDBs. The user may also provide user input that indicates to the configuration module which configuration data should be used by to configure the UDBs to perform the one or more tasks. The configuration module may use the configuration data to configure the UDBs. In another embodiment when an SoC performs functions or operations e.g. when the SoC executes an application the configuration module may detect that the SoC is about to perform one or more tasks that may be offloaded to the UDBs. The configuration module may prompt a user with the list of one or more tasks and may receive user input selecting a task or multiple tasks . The configuration module may use the configuration data for the selected task or multiple tasks to configure the UDBs to perform the selected task or multiple tasks . In a further embodiment when an SoC performs functions or operations e.g. when the SoC executes an application the configuration module may detect that the SoC is about to perform one or more tasks that may be offloaded to the UDBs. The configuration module may automatically access configuration data for the one or more tasks and may configure the UDBs to perform the one or more tasks based on the configuration data.

At block the method receives data indicating which functions should be performed by each UDB in the array of UDBS. For example the method may receive a list of op codes and functions or actions that a datapath in a UDB may perform when an op code is received. These functions may be the computational portion of an algorithm or task. Complicated portions of this algorithm or task may be broken down further into functions achievable in UDBs and the process e.g. the sequences or order of functions by which they are achieved. At block the method receives additional data indicating the sequence by which the task is completed. For example the method may receive information that may be used to generate a state machine in the PLD of a UDB. The method may receive the data received in block and the additional data received in block at the same time in a combined data that includes both the data and the additional data. At block the method configures the datapaths in the UDBs based on the data. For example the method may configure an ALU in a datapath of the UDB to perform certain functions when certain op codes are received. At block the method configures PLDs in the UDBs based on the additional data. For example the method may configure the PLD to function as a state machine that controls the sequence of operations performed by the datapath for a UDB. At block the method may couple multiple datapaths to each other. For example the method may couple the output of a datapath to an input of a second datapath. At block the method may couple the outputs of datapaths to registers e.g. memory registers of other datapaths. For example two datapaths may be connected in serial and the output value from a first datapath may be used by a second datapath when the second datapath performs calculations. After block the method ends.

Embodiments of the present invention include various operations described herein. These operations may be performed by hardware components software firmware or a combination thereof. Any of the signals provided over various buses described herein may be time multiplexed with other signals and provided over one or more common buses. Additionally the interconnection between circuit components or blocks may be shown as buses or as single signal lines. Each of the buses may alternatively be one or more single signal lines and each of the single signal lines may alternatively be buses.

In the above description numerous details are set forth. It will be apparent however to one of ordinary skill in the art having the benefit of this disclosure that embodiments of the disclosure may be practiced without these specific details. In some instances well known structures and devices are shown in block diagram form rather than in detail in order to avoid obscuring the description.

Some portions of the detailed description are presented in terms of algorithms and symbolic representations of operations on data bits within a computer memory. These algorithmic descriptions and representations are the means used by those skilled in the data processing arts to most effectively convey the substance of their work to others skilled in the art. An algorithm is here and generally conceived to be a self consistent sequence of steps leading to a desired result. The steps are those requiring physical manipulations of physical quantities. Usually though not necessarily these quantities take the form of electrical or magnetic signals capable of being stored transferred combined compared and otherwise manipulated. It has proven convenient at times principally for reasons of common usage to refer to these signals as bits values elements symbols characters terms numbers or the like.

It should be borne in mind however that all of these and similar terms are to be associated with the appropriate physical quantities and are merely convenient labels applied to these quantities. Unless specifically stated otherwise as apparent from the above discussion it is appreciated that throughout the description discussions utilizing terms such as identifying receiving configuring coupling controlling or the like refer to the actions and processes of a computer system or similar electronic computing device that manipulates and transforms data represented as physical e.g. electronic quantities within the computer system s registers and memories into other data similarly represented as physical quantities within the computer system memories or registers or other such information storage transmission or display devices.

Certain embodiments may be implemented as a computer program product that may include instructions stored on a machine readable medium. These instructions may be used to program a general purpose or special purpose processor to perform the described operations. A machine readable medium includes any mechanism for storing or transmitting information in a form e.g. software processing application readable by a machine e.g. a computer . The machine readable medium may include but is not limited to magnetic storage medium e.g. floppy diskette optical storage medium e.g. CD ROM magneto optical storage medium read only memory ROM random access memory RAM erasable programmable memory e.g. EPROM and EEPROM flash memory or another type of medium suitable for storing electronic instructions.

Additionally some embodiments may be practiced in distributed computing environments where the machine readable medium is stored on and or executed by more than one computer system. In addition the information transferred between computer systems may either be pulled or pushed across the communication medium connecting the computer systems.

The digital processing devices described herein may include one or more general purpose processing devices such as a microprocessor or central processing unit a controller or the like. Alternatively the digital processing device may include one or more special purpose processing devices such as a digital signal processor DSP an application specific integrated circuit ASIC a field programmable gate array FPGA or the like. In an alternative embodiment for example the digital processing device may be a network processor having multiple processors including a core unit and multiple microengines. Additionally the digital processing device may include any combination of general purpose processing devices and special purpose processing devices.

The words example or exemplary are used herein to mean serving as an example instance or illustration. Any aspect or design described herein as example or exemplary is not necessarily to be construed as preferred or advantageous over other aspects or designs. Rather use of the words example or exemplary is intended to present concepts in a concrete fashion. As used in this application the term or is intended to mean an inclusive or rather than an exclusive or . That is unless specified otherwise or clear from context X includes A or B is intended to mean any of the natural inclusive permutations. That is if X includes A X includes B or X includes both A and B then X includes A or B is satisfied under any of the foregoing instances. In addition the articles a and an as used in this application and the appended claims should generally be construed to mean one or more unless specified otherwise or clear from context to be directed to a singular form. Moreover use of the term an embodiment or one embodiment or an implementation or one implementation throughout is not intended to mean the same embodiment or implementation unless described as such. Furthermore the terms first second third fourth etc. as used herein are meant as labels to distinguish among different elements and may not necessarily have an ordinal meaning according to their numerical designation.

Although the operations of the methods herein are shown and described in a particular order the order of the operations of each method may be altered so that certain operations are omitted so that certain operations are added so that certain operations may be performed in an inverse order or so that certain operations may be performed at least in part concurrently with other operations. In another embodiment instructions or sub operations of distinct operations may be in an intermittent and or alternating manner.

The algorithms and displays presented herein are not inherently related to any particular computer or other apparatus. Various general purpose systems may be used with programs in accordance with the teachings herein or it may prove convenient to construct a more specialized apparatus to perform the required method steps. The required structure for a variety of these systems will appear from the description below. In addition the present disclosure is not described with reference to any particular programming language. It will be appreciated that a variety of programming languages may be used to implement the teachings of the disclosure as described herein.

The above description sets forth numerous specific details such as examples of specific systems components methods and so forth in order to provide a good understanding of several embodiments of the present disclosure. It will be apparent to one skilled in the art however that at least some embodiments of the present disclosure may be practiced without these specific details. In other instances well known components or methods are not described in detail or are presented in simple block diagram format in order to avoid unnecessarily obscuring the present disclosure. Thus the specific details set forth above are merely examples. Particular implementations may vary from these example details and still be contemplated to be within the scope of the present disclosure.

It is to be understood that the above description is intended to be illustrative and not restrictive. Many other embodiments will be apparent to those of skill in the art upon reading and understanding the above description. The scope of the disclosure should therefore be determined with reference to the appended claims along with the full scope of equivalents to which such claims are entitled.

