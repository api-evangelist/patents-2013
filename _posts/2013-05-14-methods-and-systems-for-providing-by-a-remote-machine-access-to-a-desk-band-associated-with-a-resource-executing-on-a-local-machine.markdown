---

title: Methods and systems for providing, by a remote machine, access to a desk band associated with a resource executing on a local machine
abstract: A method for providing, by a remote machine, access to a desk band associated with a resource on a local machine includes receiving, by a first agent on the remote machine, an identification of a desk band associated with a resource on a local machine. The first agent, in communication with a shell on the remote machine, maintains a taskbar window in a remote desktop environment. The taskbar window includes at least one window associated with a resource provided by the remote machine and a window region representing the desk band by using graphical data stored on the remote machine. The first agent transmits, to a second agent on the local machine, window attribute data and output data associated with the taskbar window in the remote desktop environment. The second agent displays at least a portion of the received output data in a local window on a local desktop environment.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09032026&OS=09032026&RS=09032026
owner: Citrix Systems, Inc.
number: 09032026
owner_city: Fort Lauderdale
owner_country: US
publication_date: 20130514
---
The present application claims priority to U.S. patent application Ser. No. 13 110 787 entitled Methods and Systems for Providing by a Remote Machine Access to a Desk Band Associated with a Resource Executing on a Local Machine filed on May 18 2011 which claims priority to U.S. patent application Ser. No. 12 210 177 entitled Methods and Systems for Providing by a Remote Machine Access to a Desk Band Associated with a Resource Executing on a Local Machine filed on Sep. 12 2008 which claims priority to U.S. Provisional Patent Application Ser. No. 60 971 688 entitled Methods and Systems for Generating Desktop Environments Providing Integrated Access to Remote and Local Resources filed Sep. 12 2007 and to U.S. Provisional Patent Application Ser. No. 61 054 402 entitled Methods and Systems for Generating Desktop Environments Providing Integrated Access to Remote and Local Resources and Associated Graphical User Interface Elements filed May 19 2008 each of which are incorporated herein by reference.

The present disclosure relates to methods and systems for generating desktop environments. In particular the present disclosure relates to methods and systems for generating a remote desktop environment on a remote machine for display on a local machine the remote desktop environment providing integrated access both to resources provided by the local machine and to resources provided by the remote machine.

Conventional efforts to combine output data from various remote machines with output data generated on a client machine into a single display do not typically display an integrated desktop environment. One system providing segregated access to remote and local applications is the RES POWERFUSE product manufactured by Real Enterprise Solutions Development B.V. of the Netherlands. However rather than provide a single integrated desktop environment displaying output data in a combined windowing environment the RES POWERFUSE product displays local windows either on top of a display of a remote desktop or to be minimized. As a result a local window is not typically visible when a user focuses on a remote window which is frustrating and counter intuitive for WINDOWS users. Additionally the RES POWERFUSE may be limited to environments running the WINDOWS operating systems.

In one aspect a method for providing access to a desk band associated with a resource executing on a local machine by a remote machine in a networked computing system includes receiving by a first agent executing on a remote machine an identification of a desk band associated with a resource provided by a local machine. The method includes maintaining by the first agent in communication with a shell executing on the remote machine a taskbar window in a desktop environment on the remote machine the taskbar window including at least one window associated with a resource provided by the remote machine and including a window region representing the desk band by using graphical data stored on the remote machine. The method includes transmitting by the first agent to a second agent executing on the local machine window attribute data and output data associated with the taskbar window in the desktop environment on the remote machine. The method includes displaying by the second agent executing on the local machine at least a portion of the received output data in a local window on a desktop environment on the local machine.

In one embodiment the method includes maintaining by the first agent in communication with a shell executing on the remote machine a taskbar window in a desktop environment on the remote machine the taskbar window including at least one window associated with a resource provided by the remote machine and including a window region representing the desk band on the local machine by using graphical data received from the local machine. In another embodiment the method includes transmitting by the first agent to the second agent a z order entry for the taskbar window. In still another embodiment the method includes receiving by the first agent a request for execution of a command associated with a user interface element displayed by the desk band associated with the resource provided by the local machine. In yet another embodiment the method includes redirecting by the first agent the request to the second agent on the local machine.

In one embodiment the method includes transmitting by the second agent the request to the resource on the local machine. In another embodiment the method includes intercepting by the first agent a user interaction with the window region. In still another embodiment the method includes intercepting by the second agent a user interaction with the window region. In yet another embodiment the method includes redirecting by the second agent the user interaction to the desk band associated with the resource provided by the local machine.

In another aspect a system for providing by a remote machine access to a desk band associated with a resource executing on a local machine includes a first agent executing on a remote machine receiving an identification of a desk band associated with a resource provided by a local machine and maintaining in communication with a shell executing on the remote machine a taskbar window in a desktop environment on the remote machine the taskbar window including at least one window associated with a resource provided by the remote machine and including a window region representing the desk band by using graphical data stored on the remote machine. The system includes a second agent executing on the local machine receiving from the first agent window attribute and output data associated with the taskbar window in the desktop environment on the remote machine and displaying at least a portion of the received output data in a local window on a desktop environment on the local machine.

In one embodiment the first agent maintains in communication with a shell executing on the remote machine a taskbar window in a desktop environment on the remote machine the taskbar window including at least one window associated with a resource provided by the remote machine and including a window region representing the desk band on the local machine by using graphical data received from the local machine. In another embodiment the window attribute data includes a z order entry for the taskbar window. In still another embodiment the local window on the desktop environment on the local machine is a local display of the desktop environment on the remote machine.

In one embodiment the local window on the desktop environment on the local machine is a local display of the taskbar window in the desktop environment on the remote machine. In another embodiment the second agent includes an interception component intercepting a user interaction with a local display of the received output data. In still another embodiment the interception component redirects the user interaction to the desk band associated with the resource provided by the local machine.

In still another aspect a method for providing access to a desk band associated with a resource executing on a local machine by a remote machine in a networked computing system includes receiving by a local agent executing on a local machine window attribute data associated with a taskbar window maintained by a remote machine. The method includes displaying by the local agent to a user of the local machine a first local window representing the taskbar window maintained on the remote machine responsive to the received window attribute data. The method includes re parenting by the local agent a second local window displaying a desk band associated with a resource provided by the local machine to the first local window representing the taskbar window maintained on the remote machine.

In one embodiment the method includes directing by the local agent a display of the second local window displaying a desk band associated with the resource provided by the local machine the second local window displayed at a window region identified responsive to the received window attribute data. In another embodiment the method includes generating by an execution of the resource output data. In still another embodiment the method includes displaying by the desk band in the second local window the generated output data.

In still even another aspect a method for providing access to a desk band associated with a resource executing on a local machine by a remote machine in a networked computing system includes a local agent executing on a local machine. The local agent includes a receiver receiving window attribute data associated with a taskbar window maintained by a remote machine. The local agent displays in communication with a shell on the local machine a first local window representing the taskbar window maintained on the remote machine responsive to the received window attribute data. The local agent re parents a second local window displaying a desk band associated with a resource provided by the local machine to the first local window representing the taskbar window maintained on the remote machine.

In yet another aspect a method for providing access to a desk band associated with a resource executing on a local machine by a remote machine in a networked computing system includes detecting by a local agent executing on a local machine a request by a first shell on the local machine for creation of a desk band object associated with a resource provided by the local machine. The method includes instantiating by the local agent a proxy container object responsive to detecting the request. The method includes instantiating by the proxy container object the desk band object. The method includes receiving by a remote agent executing on a remote machine an identification of the desk band object associated with the resource provided by the local machine. The method includes maintaining by the remote agent a window region in a taskbar on a desktop environment maintained on the remote machine the window region representing the identified desk band object. The method includes instantiating by the remote agent on the remote machine a proxy handler associated with the identified desk band object. The method includes receiving by the proxy container object from the proxy handler an identification of a window region associated with the identified desk band object. The method includes identifying by the proxy container object for the desk band object the identified window region as a desk band site. The method includes directing by the desk band object a display of output data in the identified window region in a display on the local machine of the desktop environment maintained on the remote machine.

In still one aspect a method for providing access to a desk band associated with a resource executing on a local machine by a remote machine in a networked computing system includes installing by a local agent executing on a local machine a proxy container object associated with a resource provided by the local machine. The method includes instantiating by the proxy container object a desk band object associated with a resource provided by the local machine. The method includes receiving by a remote agent executing on a remote machine an identification of the desk band object associated with the resource provided by the local machine. The method includes maintaining by the remote agent a window region in a taskbar on a desktop environment maintained on the remote machine the window region representing the identified desk band object. The method includes instantiating by the remote agent on the remote machine a proxy handler associated with the identified desk band object. The method includes receiving by the proxy container object from the proxy handler an identification of a window region associated with the identified desk band object. The method includes identifying by the proxy container object for the desk band object the identified window region as a desk band site. The method includes directing by the desk band object a display of output data in the identified window region in a display on the local machine of the desktop environment maintained on the remote machine.

In still further another aspect a system for providing access to a desk band associated with a resource executing on a local machine by a remote machine in a networked computing system includes a local agent executing on a local machine detecting a request by a shell for creation of a desk band object associated with a resource provided by the local machine and instantiating a proxy container object responsive to detecting the request the proxy container object instantiating the desk band object and identifying a window region as a desk band site. The system includes a remote agent executing on a remote machine receiving an identification of the desk band object associated with the resource provided by the local machine and maintaining a window region in a taskbar on a desktop environment maintained on the remote machine the window region representing the identified desk band object. The system includes a proxy handler instantiated by the remote agent and associated with the identified desk band object transmitting to the proxy container object an identification of a window region associated with the identified desk band object. The system includes the desk band object directing a display of output data in the identified window region in a display on the local machine of the desktop environment maintained on the remote machine.

Referring now to an embodiment of a network environment is depicted. In brief overview the network environment comprises one or more clients also generally referred to as local machine s client s client node s client computer s or endpoint s in communication with one or more servers also generally referred to as server s or remote machine s via one or more networks .

Although shows a network between the clients and the servers the clients and the servers may be on the same network . The network can be a local area network LAN such as a company Intranet a metropolitan area network MAN or a wide area network WAN such as the Internet or the World Wide Web. In some embodiments there are multiple networks between the clients and the servers . In one of these embodiments a network may be a private network and a network may be a public network. In another of these embodiments a network may be a private network and a network a public network. In still another embodiment networks and may both be private networks.

The network may be any type and or form of network and may include any of the following a point to point network a broadcast network a wide area network a local area network a telecommunications network a data communication network a computer network an ATM Asynchronous Transfer Mode network a SONET Synchronous Optical Network network a SDH Synchronous Digital Hierarchy network a wireless network and a wireline network. In some embodiments the network may comprise a wireless link such as an infrared channel or satellite band. The topology of the network may be a bus star or ring network topology. The network and network topology may be of any such network or network topology as known to those ordinarily skilled in the art capable of supporting the operations described herein. The network may comprise mobile telephone networks utilizing any protocol or protocols used to communicate among mobile devices including AMPS TDMA CDMA GSM GPRS or UMTS. In some embodiments different types of data may be transmitted via different protocols. In other embodiments the same types of data may be transmitted via different protocols.

In one embodiment the system may include multiple logically grouped servers . In these embodiments the logical group of servers may be referred to as a server farm . In some of these embodiments the servers may be geographically dispersed. In some cases a farm may be administered as a single entity. In other embodiments the server farm comprises a plurality of server farms . In one embodiment the server farm executes one or more applications on behalf of one or more clients .

The servers within each farm can be heterogeneous. One or more of the servers can operate according to one type of operating system platform e.g. WINDOWS NT manufactured by Microsoft Corp. of Redmond Wash. while one or more of the other servers can operate on according to another type of operating system platform e.g. Unix or Linux . In some embodiments a server executes an application on behalf of a user or a client . In other embodiments a server executes a virtual machine which provides an execution session within which applications execute on behalf of a user or a client . In one of these embodiments the execution session is a hosted desktop session. In another of these embodiments the server executes a terminal services session. The terminal services session may provide a hosted desktop environment. In still another of these embodiments the execution session provides access to a computing environment which may comprise one or more of an application a plurality of applications a desktop application and a desktop session in which one or more applications may execute.

The servers of each farm do not need to be physically proximate to another server in the same farm . Thus the group of servers logically grouped as a farm may be interconnected using a wide area network WAN connection or a metropolitan area network MAN connection. For example a farm may include servers physically located in different continents or different regions of a continent country state city campus or room. Data transmission speeds between servers in the farm can be increased if the servers are connected using a local area network LAN connection or some form of direct connection.

A server may be a file server application server web server proxy server appliance network appliance gateway application gateway gateway server virtualization server deployment server SSL VPN server or firewall. In some embodiments a server provides a remote authentication dial in user service and is referred to as a RADIUS server. In other embodiments a server may have the capacity to function as either an application server or as a master application server. In still other embodiments a server is a blade server. In yet other embodiments a server executes a virtual machine providing to a user or client computer access to a computing environment.

In one embodiment a server may include an Active Directory. The server may be an application acceleration appliance. For embodiments in which the server is an application acceleration appliance the server may provide functionality including firewall functionality application firewall functionality or load balancing functionality. In some embodiments the server comprises an appliance such as one of the line of appliances manufactured by the Citrix Application Networking Group of San Jose Calif. or Silver Peak Systems Inc. of Mountain View Calif. or of Riverbed Technology Inc. of San Francisco Calif. or of F5 Networks Inc. of Seattle Wash. or of Juniper Networks Inc. of Sunnyvale Calif.

The clients may also be referred to as client nodes client machines endpoint nodes or endpoints. In some embodiments a client has the capacity to function as both a client node seeking access to resources provided by a server and as a server providing access to hosted resources for other clients 

In some embodiments a client communicates with a server . In one embodiment the client communicates with one of the servers in a farm . Over the network the client can for example request execution of various applications hosted by the servers in the farm and receive output data of the results of the application execution for display. In one embodiment the client executes a program neighborhood application to communicate with a server in a farm .

A client may execute operate or otherwise provide an application which can be any type and or form of software program or executable instructions such as any type and or form of web browser web based client client server application a thin client computing client an ActiveX control or a Java applet or any other type and or form of executable instructions capable of executing on client . In some embodiments the application may be a server based or a remote based application executed on behalf of the client on a server . In one embodiment the server may display output data to the client using any thin client or remote display protocol such as the Independent Computing Architecture ICA protocol manufactured by Citrix Systems Inc. of Ft. Lauderdale Fla. the Remote Desktop Protocol RDP manufactured by the Microsoft Corporation of Redmond Wash. the X11 protocol the Virtual Network Computing VNC protocol manufactured by AT T Bell Labs the SPICE protocol manufactured by Qumranet Inc. of Sunnyvale Calif. USA and of Raanana Israel the Net2Display protocol manufactured by VESA of Milpitas Calif. the PC over IP protocol manufactured by Teradici Corporation of Burnaby B.C. the TCX protocol manufactured by Wyse Technology Inc. of San Jose Calif. the THINC protocol developed by Columbia University in the City of New York of New York N.Y. or the Virtual D protocols manufactured by Desktone Inc. of Chelmsford Mass. The application can use any type of protocol and it can be for example an HTTP client an FTP client an Oscar client or a Telnet client. In other embodiments the application comprises any type of software related to voice over internet protocol VoIP communications such as a soft IP telephone. In further embodiments the application comprises any application related to real time data communications such as applications for streaming video and or audio.

The client and server may be deployed as and or executed on any type and form of computing device such as a computer network device or appliance capable of communicating on any type and form of network and performing the operations described herein. depict block diagrams of a computing device useful for practicing an embodiment of the client or a server . As shown in each computing device includes a central processing unit and a main memory unit . As shown in a computing device may include a visual display device a keyboard and or a pointing device such as a mouse. As shown in each computing device may also include additional optional elements such as one or more input output devices generally referred to using reference numeral and a cache memory in communication with the central processing unit .

The central processing unit is any logic circuitry that responds to and processes instructions fetched from the main memory unit . In many embodiments the central processing unit is provided by a microprocessor unit such as those manufactured by Intel Corporation of Mountain View Calif. those manufactured by Motorola Corporation of Schaumburg Ill. those manufactured by Transmeta Corporation of Santa Clara Calif. the RS 6000 processor those manufactured by International Business Machines of White Plains N.Y. or those manufactured by Advanced Micro Devices of Sunnyvale Calif. The computing device may be based on any of these processors or any other processor capable of operating as described herein.

Main memory unit may be one or more memory chips capable of storing data and allowing any storage location to be directly accessed by the microprocessor such as Static random access memory SRAM Burst SRAM or SynchBurst SRAM BSRAM Dynamic random access memory DRAM Fast Page Mode DRAM FPM DRAM Enhanced DRAM EDRAM Extended Data Output RAM EDO RAM Extended Data Output DRAM EDO DRAM Burst Extended Data Output DRAM BEDO DRAM Enhanced DRAM EDRAM synchronous DRAM SDRAM JEDEC SRAM PC100 SDRAM Double Data Rate SDRAM DDR SDRAM Enhanced SDRAM ESDRAM SyncLink DRAM SLDRAM Direct Rambus DRAM DRDRAM or Ferroelectric RAM FRAM . The main memory may be based on any of the above described memory chips or any other available memory chips capable of operating as described herein. In the embodiment shown in the processor communicates with main memory via a system bus described in more detail below . depicts an embodiment of a computing device in which the processor communicates directly with main memory via a memory port . For example in the main memory may be DRDRAM.

The computing device may support any suitable installation device such as a floppy disk drive for receiving floppy disks such as 3.5 inch 5.25 inch disks or ZIP disks a CD ROM drive a CD R RW drive a DVD ROM drive tape drives of various formats USB device hard drive or any other device suitable for installing software and programs such as any client agent or portion thereof. The computing device may further comprise a storage device such as one or more hard disk drives or redundant arrays of independent disks Flash memory or EEPROMs for storing an operating system and other related software and for storing application software programs such as any program related to the client agent . Optionally any of the installation devices could also be used as the storage device. Additionally the operating system and the software can be run from a bootable medium for example a bootable CD such as KNOPPIX a bootable CD for GNU Linux that is available as a GNU Linux distribution from knoppix.net.

Furthermore the computing device may include a network interface to interface to a Local Area Network LAN Wide Area Network WAN or the Internet through a variety of connections including but not limited to standard telephone lines LAN or WAN links e.g. 802.11 T1 T3 56 kb X.25 SNA DECNET broadband connections e.g. ISDN Frame Relay ATM Gigabit Ethernet Ethernet over SONET ADSL SDSL wireless connections or some combination of any or all of the above. Connections can be established using a variety of communication protocols e.g. TCP IP IPX SPX NetBIOS Ethernet ARCNET SONET SDH Fiber Distributed Data Interface FDDI RS232 IEEE 802.11 IEEE 802.11a IEEE 802.11b IEEE 802.11g CDMA GSM WiMax and direct asynchronous connections . In one embodiment the computing device communicates with other computing devices via any type and or form of gateway or tunneling protocol such as Secure Socket Layer SSL or Transport Layer Security TLS or the Citrix Gateway Protocol manufactured by Citrix Systems Inc. of Ft. Lauderdale Fla. The network interface may comprise a built in network adapter network interface card PCMCIA network card card bus network adapter wireless network adapter USB network adapter modem or any other device suitable for interfacing the computing device to any type of network capable of communication and performing the operations described herein.

A wide variety of I O devices may be present in the computing device . Input devices include keyboards mice trackpads trackballs microphones and drawing tablets. Output devices include video displays speakers inkjet printers laser printers and dye sublimation printers. The I O devices may be controlled by an I O controller as shown in . The I O controller may control one or more I O devices such as a keyboard and a pointing device e.g. a mouse or optical pen. Furthermore an I O device may also provide storage and or an installation medium for the computing device . In still other embodiments the computing device may provide USB connections to receive handheld USB storage devices such as the USB Flash Drive line of devices manufactured by Twintech Industry Inc. of Los Alamitos Calif.

In some embodiments the computing device may comprise or be connected to multiple display devices which each may be of the same or different type and or form. As such any of the I O devices and or the I O controller may comprise any type and or form of suitable hardware software or combination of hardware and software to support enable or provide for the connection and use of multiple display devices by the computing device . For example the computing device may include any type and or form of video adapter video card driver and or library to interface communicate connect or otherwise use the display devices . In one embodiment a video adapter may comprise multiple connectors to interface to multiple display devices . In other embodiments the computing device may include multiple video adapters with each video adapter connected to one or more of the display devices . In some embodiments any portion of the operating system of the computing device may be configured for using multiple displays . In other embodiments one or more of the display devices may be provided by one or more other computing devices such as computing devices and connected to the computing device for example via a network. These embodiments may include any type of software designed and constructed to use another computer s display device as a second display device for the computing device . One ordinarily skilled in the art will recognize and appreciate the various ways and embodiments that a computing device may be configured to have multiple display devices 

In further embodiments an I O device may be a bridge between the system bus and an external communication bus such as a USB bus an Apple Desktop Bus an RS 232 serial connection a SCSI bus a FireWire bus a FireWire bus an Ethernet bus an AppleTalk bus a Gigabit Ethernet bus an Asynchronous Transfer Mode bus a HIPPI bus a Super HIPPI bus a SerialPlus bus a SCI LAMP bus a FibreChannel bus or a Serial Attached small computer system interface bus.

A computing device of the sort depicted in typically operates under the control of operating systems which control scheduling of tasks and access to system resources. The computing device can be running any operating system such as any of the versions of the MICROSOFT WINDOWS operating systems the different releases of the Unix and Linux operating systems any version of the MAC OS for Macintosh computers any embedded operating system any real time operating system any open source operating system any proprietary operating system any operating systems for mobile computing devices or any other operating system capable of running on the computing device and performing the operations described herein. Typical operating systems include WINDOWS 3.x WINDOWS 95 WINDOWS 98 WINDOWS 2000 WINDOWS NT 3.51 WINDOWS NT 4.0 WINDOWS CE WINDOWS XP and WINDOWS VISTA all of which are manufactured by Microsoft Corporation of Redmond Wash. MACOS manufactured by Apple Computer of Cupertino Calif. OS 2 manufactured by International Business Machines of Armonk N.Y. and Linux a freely available operating system distributed by Caldera Corp. of Salt Lake City Utah or any type and or form of a Unix operating system among others.

The computer system can be any workstation desktop computer laptop or notebook computer server handheld computer mobile telephone or other portable telecommunication device media playing device a gaming system mobile computing device or any other type and or form of computing telecommunications or media device that is capable of communication and that has sufficient processor power and memory capacity to perform the operations described herein. For example the computer system may comprise a device of the IPOD family of devices manufactured by Apple Computer of Cupertino Calif. a PLAYSTATION 2 PLAYSTATION 3 or PERSONAL PLAYSTATION PORTABLE PSP device manufactured by the Sony Corporation of Tokyo Japan a NINTENDO DS NINTENDO GAMEBOY NINTENDO GAMEBOY ADVANCED or NINTENDO REVOLUTION device manufactured by Nintendo Co. Ltd. of Kyoto Japan or an XBOX or XBOX 360 device manufactured by the Microsoft Corporation of Redmond Wash.

In some embodiments the computing device may have different processors operating systems and input devices consistent with the device. For example in one embodiment the computing device is a TREO 180 270 600 650 680 700p 700w or 750 smart phone manufactured by Palm Inc. In some of these embodiments the TREO smart phone is operated under the control of the PALM operating system and includes a stylus input device as well as a five way navigator device.

In other embodiments the computing device is a mobile device such as a JAVA enabled cellular telephone or personal digital assistant PDA such as the i55sr i58sr i85s i88s i90c i95cl or the im1100 all of which are manufactured by Motorola Corp. of Schaumburg Ill. the 6035 or the 7135 manufactured by Kyocera of Kyoto Japan or the i300 or i330 manufactured by Samsung Electronics Co. Ltd. of Seoul Korea.

In still other embodiments the computing device is a Blackberry handheld or smart phone such as the devices manufactured by Research In Motion Limited including the Blackberry 7100 series 8700 series 7700 series 7200 series the Blackberry 7520 or the Blackberry PEARL 8100. In yet other embodiments the computing device is a smart phone Pocket PC Pocket PC Phone or other handheld mobile device supporting Microsoft Windows Mobile Software. Moreover the computing device can be any workstation desktop computer laptop or notebook computer server handheld computer mobile telephone any other computer or other form of computing or telecommunications device that is capable of communication and that has sufficient processor power and memory capacity to perform the operations described herein.

In one embodiment the server includes a policy engine for controlling and managing the access to a resource selection of an execution method for accessing the resource and the delivery of resources. In another embodiment the server communicates with a policy engine. In some embodiments the policy engine determines the one or more resources a user or client may access. In other embodiments the policy engine determines how the resource should be delivered to the user or client e.g. the method of execution. In still other embodiments the server provides a plurality of delivery techniques from which to select a method of execution such as a server based computing application streaming or delivering the application locally to the client for local execution.

Referring now to a block diagram depicts one embodiment of a system for maintaining a full screen integrated desktop environment on a remote machine for display on a local machine. In brief overview the system includes a remote machine a first agent a local machine and a second agent . The first agent executing on the remote machine monitors a desktop environment which includes a plurality of data objects and provides access to i a first resource available to a user of the local machine and provided by the remote machine and ii a second resource provided by the local machine that is available to the user of the local machine . The first agent generates a proxy window in the desktop environment . The proxy window represents a local window on the local machine that displays output data generated by the second resource provided by the local machine . The first agent executing on the remote machine receives an identification of a change to window attribute data associated with the local window on the local machine that displays output data generated by the second resource . The first agent modifies at least one of the plurality of data objects responsive to the identification of the change. The second agent executing on the local machine receives from the first agent an identification of the modification to the at least one of the plurality of data objects . The second agent modifies attribute data associated with a data object in the desktop environment displayed by the local machine responsive to the received identification of the modification.

Referring now to and in greater detail the first agent executing on the remote machine monitors the desktop environment which includes a plurality of data objects and provides integrated access to i a resource available to a user of the local machine and provided by the remote machine and ii a resource provided by the local machine that is available to the user of the local machine . In one embodiment the remote machine is a server . In another embodiment the local machine is a client device connecting to the server to access one or more resources available to a user of the local machine .

In one embodiment a resource comprises a program an application a document a file a plurality of applications a plurality of files an executable program file a desktop environment a computing environment or other resource made available to a user of the local machine . The resource may be delivered to the local machine via a plurality of access methods including but not limited to conventional installation directly on the local machine delivery to the local machine via a method for application streaming delivery to the local machine of output data generated by an execution of the resource on a third machine and communicated to the local machine via a presentation layer protocol delivery to the local machine of output data generated by an execution of the resource via a virtual machine executing on a remote machine or execution from a removable storage device connected to the local machine such as a USB device or via a virtual machine executing on the local machine and generating output data. In some embodiments the local machine transmits output data generated by the execution of the resource to another client machine .

In some embodiments a user of a local machine connects to a remote machine and views a display on the local machine of a local version of a remote desktop environment comprising a plurality of data objects generated on the remote machine . In one of these embodiments at least one resource is provided to the user by the remote machine or by a second remote machine not shown and displayed in the remote desktop environment . However there may be resources that the user executes on the local machine either by choice or due to a policy or technological requirement. In another of these embodiments a user may invoke a local application from the remote desktop interface generated by the remote machine and have the local application appear in the same desktop environment as the remote applications provided by the remote machine . In still another of these embodiments the user of the local machine would prefer an integrated desktop environment providing access to all of the resources available to the user instead of separate desktop environments for resources provided by separate machines. For example a user may find navigating between multiple graphical displays confusing and difficult to use productively. Or a user may wish to use the data generated by one application provided by one machine in conjunction with another resource provided by a different machine. In another of these embodiments requests for execution of a resource windowing moves application minimize maximize resizing windows and termination of executing resources may be controlled by interacting with a remote desktop environment that integrates the display of the remote resources and of the local resources. In yet another of these embodiments an application or other resource accessible via an integrated desktop environment both those resources generated on the local machine and those generated on the remote machine is shown on the remote desktop environment as if it were executing on or executable from the remote desktop environment. For example a resource may also appear in a listing of available resources provided in a Start Menu a shortcut may be provided on the desktop or the Quick Launch menu and the resources can be launched selected and interacted with in the same way as an application provided by the remote machine .

In one embodiment data objects from a remote machine are integrated into a full screen desktop environment generated by the local machine . In another embodiment the remote machine maintains the integrated desktop. In still another embodiment the local machine maintains the integrated desktop.

In some embodiments a single remote desktop environment is displayed. In one of these embodiments the remote desktop environment is displayed as a full screen desktop. In other embodiments a plurality of remote desktop environments is displayed. In one of these embodiments one or more of the remote desktop environments are displayed in non full screen mode on one or more display devices . In another of these embodiments the remote desktop environments are displayed in full screen mode on individual display devices. In still another of these embodiments one or more of the remote desktop environments are displayed in full screen mode on one or more display devices . In yet another of the embodiments a resource provided by the second machine may be integrated with one of the plurality of remote desktop environments .

In some embodiments the first agent monitors a desktop environment including a plurality of data objects . In some embodiments a data object is a window. In one of these embodiments the data object is a window displayed in the desktop environment . In another one of these embodiments the data object is a data structure storing attribute data and which may or may not have an associated visible representation in the desktop environment . In still another of these embodiments a data object is the data structure storing data associated with a user interface element visual state identification of associated functionality location of graphical data etc. and a window is a graphical representation of the user interface element. In still another of these embodiments a shell executing on a machine provides a display of user interface elements in a desktop environment. In still even another of these embodiments the shell displays graphical data associated with a data object in accordance with attribute data associated with the data object.

In one embodiment a window in the plurality of data objects displays the output data generated by an execution of a resource provided by the remote machine . In another embodiment a window in the plurality of data objects displays the output data generated by an execution of a resource provided by a third machine as discussed in further detail below in connection with . In still another embodiment a window in the plurality of data objects depicts a taskbar from a desktop environment. In still even another embodiment a window represents a menu such as a Start menu or a context specific menu associated with an application. In yet another embodiment a window in the plurality of data objects has a z order entry such that it is displayed beneath the other windows in the plurality of data objects and depicts a desktop. In other embodiments the first agent transmits to the second agent attribute data associated with each of the plurality of data objects . In one of these embodiments the second agent displays a local version of the plurality of data objects having attribute data corresponding to the window attribute data received from the first agent .

In one of these embodiments the graphical display and the window attribute data for the plurality of data objects and for all data objects in the integrated desktop environment are transmitted to the second agent for generation of a local display of the integrated desktop environment . In another of these embodiments the second agent displays to a user of the local machine the local display of the plurality of data objects and the remote desktop environment .

Referring ahead to a block diagram depicts one embodiment of a system in which the first agent integrates resources from various sources into a remote desktop environment . In some embodiments and as shown in the first agent may receive the identification of the resources available to a user of the local machine from a plurality of servers . In one of these embodiments the first agent receives an identification of the available resources from machines and .

In one of these embodiments the remote machine receives an identification of the available resources from server receives the output data generated by an execution of the resource on server and transmits the output data so generated to local machine . In another of these embodiments the first agent receives only the identification of the available resources from the machine and the machine transmits the output data generated by an execution of the resource to the local machine .

In one of these embodiments the first agent receives from a machine an identification of resources available to the local machine . In another of these embodiments the first agent receives from the second agent an identification of available resources from the machines and . In still another of these embodiments the local machine receives via a method for resource streaming the available resource from the server . In this embodiment the local machine executes the resource locally and the graphical output data is integrated with the remote desktop environment . In still even another of these embodiments the remote machine receives an identification of the available resources from server and receives via a method for resource streaming the available resource from machine and transmits the output data generated by an execution of the resource to the local machine . In other embodiments the first agent receives from the second agent an identification of a resource available to the user of the local machine for integration into the remote desktop environment .

In one embodiment executing a resource provided by the local machine may allow a user to leverage a characteristic of the local machine that is not provided by the remote machine for example the local machine may have more appropriate processing ability graphics functionality bandwidth or license rights for accessing the resource than the remote machine . In another embodiment the remote machine may lack the ability to execute the resource because for example only the user of the local machine owns an application or owns a resource such as an operating system required to execute the application. In still another embodiment the resource is a resource such as an application or desktop environment installed on the local machine via a method for streaming the application to the local machine from a third machine . In still even another embodiment the resource is a resource such as an application or desktop environment whose output data the local machine receives via a presentation layer protocol communication with a third machine . In yet another embodiment the first agent receives an identification of a conferencing or Internet communication application a user peripheral such as a media player a digital camera or a web camera or a processor intense data intense or graphics intense application such as a media editing application or a computer aided design application.

Referring back to the first agent incorporates the identification of the resource into the remote desktop environment . In one of these embodiments the first agent adds a program execution shortcut to a menu for requesting execution of resources the program execution shortcut corresponding to the identified resource . In another of these embodiments the first agent generates a graphical representation such as an icon associated with the resource for display in the remote desktop environment . In still another of these embodiments the first agent may alternatively receive the graphical representation from the second agent for display in the remote desktop environment . In still even another of these embodiments the first agent generates a proxy for an icon displayed on the local machine . In yet another of these embodiments a user requests execution of a resource by interacting with a program execution shortcut or a graphical representation displayed in the local version of the remote desktop environment .

In one embodiment the first agent receives the request for execution of a resource responsive to the user interaction with a program execution shortcut or a graphical representation and sends the request for execution to the second agent . In another embodiment a user requests execution of a resource by interacting with the local display of the remote desktop environment for example by selecting a graphical representation of a file document uniform resource locator or other resource displayed by the desktop environment.

The first agent generates a proxy window for integration into the remote desktop environment . In one embodiment the first agent is referred to as a proxy window management component . In another embodiment the proxy window management component is responsible for making the proxy window conform to client initiated changes to window attribute data. In still another embodiment the proxy window management component is responsible for monitoring any desktop initiated changes to window attribute data and communicating them to the second agent which applies them to the corresponding local application window .

In some embodiments not shown in the proxy window management component provides additional functionality. In one of these embodiments such functionality may include a MICROSOFT Active Accessibility MSAA hook and other monitoring mechanisms to detect new application windows and window attribute data changes initiated on the desktop. In another of these embodiments the proxy window management component may further include support for launching published applications. In still another of these embodiments the proxy window management component may send updates initiated from the remote machine regarding changes to window attribute data to the second agent where the updates will be applied to the local window and to the local displays of the plurality of data objects . In still even another of these embodiments the proxy management component may be enabled to apply client initiated updates to window attribute data associated with proxy window and to the plurality of data objects . In yet another of these embodiments the proxy management component may remove proxy windows when the client connection disappears.

In one embodiment the first agent and the second agent include a hooking component for intercepting window related messages. For example and in some embodiments an agent executing on a machine or on which the MICROSOFT WINDOWS operating system executes may use a version of the MICROSOFT Active Accessibility hook to monitor relevant window events. For example and in other embodiments an agent may include a MICROSOFT Computer based Training CBT window hook or other hooking mechanisms to intercept and monitor window events.

The proxy window represents a window on the local machine that displays output data generated by the resource provided by the local machine. In one embodiment the first agent receives an identification of a change to window attribute data associated with this local window . In another embodiment in response to a received identification of a change the first agent modifies at least one of the plurality of data objects . In another embodiment the proxy window has a z order entry in a z order list associated with the plurality of data objects in the remote desktop environment . In still another embodiment the proxy window has window attribute data including data identifying position size z order focus state minimized normal maximized state and other information associated with visual state and a taskbar button and appears in a desktop Alt TAB selection dialog. In yet another embodiment window visual state and attribute data may be stored by a data object associated with or comprising the proxy window .

In one embodiment the proxy window does not need to be painted on the remote desktop environment or can be painted very efficiently e.g. in a uniform color. In another embodiment the first agent is aware of the clipping regions associated with the proxy window and does not send window attribute data for those regions.

In one embodiment the second agent on the local machine modifies a z order entry for the local window that displays output data generated by the second resource responsive to the identification of the modification. In another embodiment the second agent includes a transmitter transmitting to the first agent an identification of a change to window attribute data associated with the local window that displays output data generated by the second resource for modification by the first agent of at least one data object in the plurality of data objects . In still another embodiment the second agent includes a receiver that receives at least one entry in a z order list including a z order entry for the proxy window . In still even another embodiment the second agent includes a receiver that receives according to a presentation layer protocol application output data generated by the remote resource . In another embodiment the second agent includes a transceiver in communication with a window management component on the local machine that synchronizes a visual state of the window on the local machine with a visual state of the corresponding proxy window .

In still another embodiment the second agent is an integrated window management component executing on the local machine that enumerates monitors and manages local windows that are included in the integrated desktop . In still even another embodiment the integrated window management component manages all local windows that are integrated into the local display of the desktop . In yet another embodiment the integrated window management component communicates window existence and client initiated visual state changes over a virtual channel to the first agent on the remote machine .

In one embodiment the integrated window management component provides additional functionality. In another embodiment such functionality may include an MSAA hook and other monitoring mechanisms to detect new application windows and window attribute data changes initiated on the client. In still another embodiment the integrated window management component may send client initiated updates regarding changes to window attribute data to the first agent where the updates will be applied to the proxy window and communicated to the local machine for application to the local displays of the plurality of data objects . In yet another embodiment integrated window management component may be enabled to apply updates initiated by the remote machine to window attribute data associated with local window and then to the local displays of the plurality of data objects . In some embodiments the integrated window management component displays the desktop environment comprising the plurality of data objects 

In some embodiments a remote machine and a local machine communicate using a presentation layer protocol for example by communicating via the ICA protocol or the RDP protocol or any of the protocols discussed above in connection with . In one of these embodiments the first agent and the second agent exchange graphical data i.e. the data actually displayed in each window on the desktop environment via a first virtual channel. In another of these embodiments the first virtual channel is for example an ICA virtual channel. In still another of these embodiments window attribute data including but not limited to information about window positioning window size z ordering of window and other such information is communicated between the remote machine and the local machine via a second virtual channel. In yet another of these embodiments the second virtual channel is for example an ICA virtual channel. In some embodiments a single virtual channel is used to exchange all data. In other embodiments the first agent and the second agent exchange window attribute data. In another of these embodiments a third agent executing on the remote machine and the second agent exchange graphical data. In still another of these embodiments a third agent executing on the remote machine and a fourth agent executing on the local machine exchange graphical data.

Referring now to a flow diagram depicts one embodiment of a method for maintaining a full screen integrated desktop environment on a remote machine for display to a user by a local machine the desktop environment providing integrated access both to resources provided by the local machine and resources provided by the remote machine. In brief overview the method includes monitoring by a first agent executing on the remote machine a desktop environment comprising a plurality of data objects the desktop environment providing integrated access to i a first resource provided by the remote machine available to a user of the local machine and ii a second resource provided by the local machine that is available to the user of the local machine block . The first agent generates a proxy window in the desktop environment the proxy window representing a window on the local machine that displays output data generated by the second resource block . The first agent receives an identification of a change to window attribute data associated with the window on the local machine that displays output data generated by the second resource block . The first agent modifies at least one of the plurality of data objects responsive to the identification of the change block . The first agent transmits to a second agent executing on the local machine an identification of the modification to the at least one of the plurality of data objects block . The second agent modifies attribute data associated with a data object displayed by the local machine responsive to the received identification of the modification block .

In one embodiment a remote agent monitors a desktop environment on the remote machine the desktop environment comprising a plurality of data objects. In another embodiment the remote agent receives an identification of a change to a data object displayed on the local machine . In another embodiment the remote agent modifies a data object in the plurality of data objects responsive to receiving the identification of the change. In still another embodiment the remote agent transmits to a local agent executing on the local machine an identification of the change to the data object on the remote machine . In some embodiments the change is a change to graphical output data displayed by the data object. In other embodiments the change is a change to window attribute data associated with the data object. In still other embodiments the change is an identification of a request for access to functionality associated with the data object. In one of these embodiments the functionality may include without limitation execution of a resource and display of a user interface element.

In one embodiment the local agent identifies a data object in a plurality of data objects forming a desktop environment on the local machine responsive to receiving the identification of the change to the data object in the plurality of data objects on the remote machine . In another embodiment the local agent identifies a data object such as a window associated with a resource . In still another embodiment the local agent identifies a data object such as a graphical user interface element maintained by a shell executing on the local machine . In yet another embodiment the local agent identifies a data object displaying output data generated on the remote machine and received by the local agent from the remote agent . In some embodiments the local agent identifies a data object affected by the change identified by the remote agent .

In one embodiment the local agent processes the change identified by the remote machine by modifying a window attribute of a data object. In another embodiment the local agent processes the change identified by the remote machine by modifying graphical output data displayed by the data object. In still another embodiment the local agent processes the change identified by the remote machine by redirecting the identification of the change to a handler such as a shell extension invoker described in further detail below. In yet another embodiment the local agent displays a desktop environment providing integrated access to resources graphical data and functionality provided by both the local machine and the remote machine.

Referring now to and in greater detail a first agent executing on a the remote machine monitors a desktop environment comprising a plurality of data objects the desktop environment providing integrated access to i a first resource provided by the remote machine available to a user of the local machine and ii a second resource provided by the local machine that is available to the user of the local machine block . In some embodiments the first agent monitors the generation and modification of the desktop environment and of a plurality of data objects providing access to a plurality of resources executing on remote servers such as the remote machine and to at least one resource provided by the local machine . In other embodiments the local agent displays the desktop environment maintained by the remote machine and providing access to the first resource and the second resource.

The first agent generates a proxy window representing a window on the local machine that displays output data generated by the second resource block . In one embodiment the proxy window has a z order entry in a z order list associated with the plurality of data objects in the remote desktop environment . In another embodiment the local window is reflected into the remote desktop window list using the proxy window which has dimensions position z order value and focus state in the remote desktop environment . In still another embodiment the first agent synchronizes these window attributes with a data object maintained on the local machine . In yet another embodiment the first agent synchronizes a visual state of the corresponding proxy window with a visual state of the window on the local machine .

The first agent receives an identification of a change to window attribute data associated with the window on the local machine that displays output data generated by the second resource block . In one embodiment the first agent receives the identification of the change via a virtual channel. In another embodiment the first agent receives a message that a user minimized the local window . In still another embodiment the first agent receives a message that a user restored a minimized local window . In still even another embodiment the first agent receives a message that a user changed a size or position of the local window . In still another embodiment the first agent receives a message that a user maximized a local window . In yet another embodiment the second agent transmits to the first agent an identification of a change to window attribute data associated with the window on the local machine for modification by the first agent of at least one of the plurality of data objects 

In one embodiment when a data object associated with a remote resource is selected by a user and the local window loses focus the second agent transmits a message to the first agent instructing the first agent to direct a window management component to remove focus from the proxy window and to focus on a data object in the plurality of data objects . In another embodiment when a data object associated with a remote resource is selected by a user and the local window loses focus the second agent allows the resource to paint inside its window resulting in a completely transparent view of local and remote resources.

The first agent modifies at least one of the plurality of data objects responsive to the identification of the change block . In some embodiments the first agent directs a window management component of an operating system executing on the remote machine to modify a window displayed in the remote desktop environment . In another of these embodiments the first agent sends a message to a window management component of an operating system executing on the remote machine to restore the proxy window . In other embodiments the first agent modifies attribute data associated with the proxy window responsive to the identification of the change. In still other embodiments the first agent modifies a z order entry for the proxy window responsive to the identification of the change. In further embodiments the first agent communicates with a shell on the remote machine to modify a data object in the plurality of data objects responsive to the identification of the change.

The first agent transmits to a second agent executing on the local machine an identification of the modification to the at least one of the plurality of data objects block . In some embodiments the first agent transmits to the second agent the entire z order list including any modified entries. In other embodiments the first agent transmits to the second agent a partial z order list. In still other embodiments the second agent on the local machine receives from the first agent at least one entry in the z order list associated with the remote desktop environment . In further embodiments the transmission includes an identification of a modification to at least one entry in a z order list associated with the plurality of data objects 

In one embodiment the first agent transmits the identification of the modification to the at least one of the plurality of data objects to the second agent via a virtual channel coupled to the remote desktop environment . In another embodiment the first agent transmits to the second agent via a virtual channel conveying window attribute data associated with the proxy window messages directing the modification of a corresponding local window which displays in accordance with the window attribute data conveyed by the virtual channel graphical output data generated by a resource executing on the second machine .

In one embodiment the proxy window responds to requests initiated on the remote machine to change visual state or to invoke its taskbar menu. In another embodiment the visual state of the local application window is synchronized with the visual state of the corresponding proxy window . In still another embodiment the proxy window can pass visual state change requests to the second agent via the first agent without needing to apply them to itself. In some embodiments the first agent may modify a z order entry for the proxy window responsive to the identification of the window attribute change. In other embodiments the first agent may transmit to the second agent an identification of the modification made to the z order entry. In still other embodiments in response to the identification of the modification the second agent may modify the window attribute data e.g. a z order entry associated with local window . In further embodiments the first agent does not transmit the proxy window to the second agent only window attribute data associated with the proxy window .

In some embodiments the first agent sends a message to the second agent to restore the local window . In one of these embodiments the second agent sends a message to the resource to restore the minimized local window . In still other embodiments the first agent sends a message to the second agent to terminate the execution of a local resource when the first agent terminates the generation and display of the remote desktop environment . In some embodiments the first agent sends a message to the second agent to terminate an operating system executing on the local machine . In one of these embodiments the first agent sends a message to the second agent to shut down the local machine .

In one embodiment the second agent receives attribute data associated with at least one data object in the plurality of data objects. In another embodiment the second agent receives an identification of the modification to the at least one of the plurality of data objects.

The second agent modifies attribute data associated with a data object displayed by the local machine responsive to the received identification of the modification block . In some embodiments the second agent modifies attribute data associated with the local window that displays output data generated by the second resource . In other embodiments the second agent modifies a z order entry for the local window .

In one embodiment the local machine displays a local version of each of the plurality of data objects . In some embodiments a data object is a window. In one embodiment the second agent directs a window management component on the local machine to assign each of the locally displayed data objects a z order entry in a z order list of windows displayed on the local machine . In another embodiment each of the assigned z order entries for each of the locally displayed objects result in the display of the locally displayed windows above a local window associated with a local application on the local machine other than the local display of a local application displayed in local window . In this embodiment the local window is kept below the local display of the remote desktop environment in the client side z order. That is it is kept below each of the windows in the plurality of windows and below the local window which is integrated with the plurality of windows . In still another embodiment the plurality of windows and the local window are displayed on the local machine according to the z order list maintained on the remote machine .

In some embodiments the second agent receives an identification of a region in the remote desktop environment corresponding to a region on the local display associated with a local resource . In one of these embodiments the second agent receives the identification from the first agent . In another of these embodiments as described in additional detail below the second agent identifies the region responsive to information received from the first agent . In still another of these embodiments as described in additional detail below the second agent identifies the region responsive to identifying a color key in a communication from the first agent .

In some embodiments the local display is a single window that displays the graphical output data of the remote desktop environment including the window output for the plurality of data objects . In one of these embodiments an individual window does not need to have a corresponding local window on the local machine . In another of these embodiments the local display is maintained as the topmost window thus keeping local applications underneath the local display in the client side z order. In still another of these embodiments a region of local display is shown as transparent to allow the correct parts of a local window to show through the local display as if the local window were on the remote desktop environment . In still even another of these embodiments the proxy window is displayed on a region of the remote desktop environment corresponding to the region of local display which is to be transparently displayed. In yet another of these embodiments the transparent region is referred to as a clipping region.

In some embodiments to identify the areas to be made transparent the first agent uses the proxy window to identify a clipping region. In one of these embodiments the first agent intercepts a paint request on the remote desktop environment . In another of these embodiments the first agent transmits to the second agent an identification of a clipping region.

In other embodiments the second agent identifies the areas of local display to be displayed by the local resource . In one of these embodiments the second agent identifies the areas responsive to information received from the first agent . In another of these embodiments the second agent identifies a key received from the first agent such as a color key or an identifiable pattern or tag identifying a clipping region.

In still other embodiments the second agent ensures that the resource paints output data to the appropriate local window which is located in a region corresponding to the clipping region on the remote desktop environment . In one of these embodiments the second agent in communication with a window management component ensures that the local display is kept topmost and displays the graphical output data associated with the remote desktop environment other than the output data that would be displayed in a clipping region. In another of these embodiments the second agent instructs a window management component to regard an instruction to paint a particular color or pattern to a region for example to a region of the local display as an instruction to keep the region transparent. This color key may include an alpha value e.g. a 32 bit R G B alpha rather than a 24 bit R G B value which can be used to distinguish it from all non transparent colors for resources that don t use partial transparency .

In yet other embodiments the agent paints a clipping region for a proxy window by responding to a paint request from a window management component to the proxy window by painting the window in a color key. In one of these embodiments the agent associates a paint request in a color key with the appropriate local application window. In another of these embodiments the agent also needs to use paint requests in a different color for an or a part of an existing clipping region to remove the painted region from the associated clipping region.

In some embodiments the first agent may paint a clipping region in the color key rather than send a z order entry to the second agent . In other embodiments the first agent sends at least one z order entry for a proxy window associated with a local window . In one of these embodiments the second agent ensures that a local window has the same relative z order relationship on the client as the corresponding proxy window does on the remote machine e.g. if proxy window is below proxy window on the remote machine regardless of how many server windows there are and whether they are above or below either A or B then the second agent ensures that a local window is below a local window .

In other embodiments the windows underneath the local display show through wherever the local display is painted in the color key. In one of these embodiments the second agent maintains the local windows in the appropriate relative Z order so that they will paint correctly and a window that is above another will correctly occlude the other even though both occupy the entire clipping region. In another of these embodiments the second agent also ensures that user input will be directed to the correct window. For example a mouse click on a transparent region will be sent to the underlying window not to the local display .

In some embodiments the first agent transmits to the second agent an identification of a clipping region for each proxy window in a remote desktop environment . In one of these embodiments the second agent directs the local resource to paint output data to the region of local display corresponding to the clipping region. In another of these embodiments directing the local resource to paint output data to a region of the local display avoids the need for transparency. In still another of these embodiments the first agent identifies a clipping region on the remote desktop environment that corresponds to a region displaying local window . In still even another of these embodiments the first agent uses a color key or identifiable pattern or tag as described above to tag a clipping region. In one of these embodiments the agent or the agent associates a paint request in a color key with the appropriate local application window. In another of these embodiments the agent or the agent responds to paint requests in a different color for an or a part of an existing clipping region for an application window by removing the newly painted region from the associated clipping region. In still another of these embodiments the agent or agent associates a different color key for each local window. In yet another of these embodiments the second agent identifies a clipping region responsive to information received from the first agent .

In some embodiments the first agent may paint a clipping region in a color key rather than send a z order entry to the second agent . In other embodiments the first agent may send an identification of a clipping region to the second agent rather than send a z order entry to the second agent . In still other embodiments the first agent may send information other than a z order entry to agent that allows agent to identify a clipping region rather than send a z order entry to the second agent . In yet other embodiments the first agent does not send a z order entry to the second agent at all.

In other embodiments the second agent ensures that the local display is maintained topmost in the local desktop environment. In one of these embodiments the local display is used to show all of the remote desktop graphics output including areas belonging to local window . In another of these embodiments local windows never show through. In still another of these embodiments when the second agent receives output data not containing the color key for a portion of a clipping region associated with a local window the second agent removes the output region from the clipping region for that window.

In still other embodiments the second agent directs the local resource to paint the output data it generates to a region in the local display corresponding to the region identified by the first agent as a clipping region. In one of these embodiments the second agent in communication with a window management component sends the local resource a WM PAINT message for a display context that references a clipping region on the local display . In another of these embodiments the second agent sends the messages for any updated portions of a local window s associated clipping region whenever portions of the clipping region change. In still another of these embodiments the second agent sends the paint messages in a periodic refresh loop as local windows are always covered by the local display and can no longer asynchronously update their regions that are visible on the client display. In still even another of these embodiments the second agent ensures that user input in clipping regions including mouse clicks and where appropriate keyboard events are redirected by the local display to the corresponding local application window. This means detecting mouse events in clipping regions determining which local window is associated with the mouse event coordinates and sending the event to that window at those coordinates.

As described above in some embodiments a clipping region is identified. In one of these embodiments an agent or calculates a clipping region responsive to information associated with the remote desktop environment including a list of windows their z order size position and for non rectangular windows their shape .

In another of these embodiments the agent or acquires the information from one or more sources including but not limited to the seamless virtual channel data used by the Headless Client subclassing windows Microsoft Active Accessibility e.g. using WinEvents and MSAA hooking and by hooking various Windows APIs. In still another embodiment the agent or identifies a clipping region or portion of a clipping region by hooking or responding to window messages including WM PAINT WM NCPAINT WM ERASEBKGND which allow the agent or to see requests by Windows for a window to perform a paint operation within a region. Each time the agent or identifies one of these messages the corresponding region is added to the clipping region for the associated window. The agent or uses knowledge of which windows receive which paint requests to maintain a record of which regions of the screen belong to each application window. Each time the agent or intercepts a paint request for a different window covering all or part of an existing clipping region for another window that part is removed from that window s clipping region. The agent or can also directly retrieve the clipping region using Windows API functions such as GetRandomRgn which allows the agent or to directly interrogate a window for clipping regions. In some embodiments the agents and communicate as described above to exchange information required by the second agent to modify the local display or local windows or local windows corresponding to the plurality of windows as described below in connection with .

Referring now to a flow diagram depicts one embodiment of a method for maintaining a full screen integrated desktop environment on the remote machine for display to a user by a local machine the desktop environment providing integrated access both to resources provided by the local machine and resources provided by the remote machine. In brief overview the method includes displaying by a first agent executing on the local machine a desktop environment comprising a plurality of data objects the desktop environment providing integrated access to i a first resource provided by the remote machine available to a user of the local machine and ii a second resource provided by the local machine that is available to the user of the local machine block . The first agent transmits an identification of a change to window attribute data associated with the window on the local machine that displays output data generated by the second resource for modification by a second agent executing on the remote machine of at least one of the plurality of data objects responsive to the identification of the change block . The first agent receives from the second agent an identification of a modification to the at least one of the plurality of data objects block . The first agent modifies attribute data associated with a data object displayed by the local machine responsive to the received identification of the modification block .

A first agent executing on the local machine displays a desktop environment comprising a plurality of data objects the desktop environment providing integrated access to i a first resource provided by the remote machine available to a user of the local machine and ii a second resource provided by the local machine that is available to the user of the local machine block . In some embodiments the first agent receives attribute data associated with the at least one data object in the plurality of data objects. In one of these embodiments the first agent receives graphical data and window attribute data from the second agent and displays the graphical data in a window formed according to the window attribute data. In another embodiment the first agent receives graphical data and corresponding window attribute data for a plurality of windows forming a remote desktop environment and displays the graphical data in a plurality of windows formed according to the window attribute data. In other embodiments the first agent and the second agent exchange window attribute data. In one of these embodiments the first agent and the second agent also exchange graphical data. In another of these embodiments a third agent executing on the remote machine and the first agent exchange graphical data. In still another of these embodiments a third agent executing on the remote machine and a fourth agent executing on the local machine exchange graphical data. In yet another of these embodiments the second agent on the remote machine and a fourth agent executing on the local machine exchange graphical data.

The first agent transmits an identification of a change to window attribute data associated with the window on the local machine that displays output data generated by the second resource for modification by a second agent executing on the remote machine of at least one of the plurality of data objects responsive to the identification of the change block . In some embodiments the first agent transmits to the second agent an identification of a change to a z order entry of a local window on the local machine displaying output data generated by the second resource . In one embodiment when a user of the local machine makes a change to a local window for example by minimizing maximizing or resizing the window the first agent transmits a message to the second agent to make a corresponding change to a proxy window and to its z order entry in the z order list ordering the plurality of windows and the proxy window .

The first agent receives from the second agent an identification of a modification to the at least one of the plurality of data objects block . In some embodiments the first agent receives at least one entry in a z order list including a z order entry of at least one window in the remote desktop environment and including the z order entry of a proxy window corresponding to a local window on the local machine displaying output data generated by the local resource . In one embodiment the first agent displays a local window displaying output data generated by an execution of the second resource and a plurality of windows formed in accordance with received window attribute data in accordance with the at least one entry in the z order. In another embodiment the first agent monitors the local display of the plurality of data objects and of the local window . In another embodiment the first agent in communication with a window management component of an operating system executing on the local machine manages the local display of the plurality of data objects and of the local window.

The first agent modifies attribute data associated with a data object displayed by the local machine responsive to the received identification of the modification block . In some embodiments the first agent modifies attribute data associated with the local window that displays output data generated by the second resource responsive to the identification of the modification. In one of these embodiments the first agent may modify a z order entry for the local window . In other embodiments the first agent modifies window attribute data for the displayed remote desktop environment responsive to a received z order entry. In some embodiments the first agent modifies a z order entry for a local version of a window in the plurality of windows . In other embodiments the first agent modifies window attribute data for a local version of a window in the plurality of windows . In one of these embodiments the first agent resizes the local version of the window in the plurality of windows . In one of these embodiments the first agent repositions the local version of the window in the plurality of windows . For example the first agent may modify window attribute data of the local window responsive to a received z order entry sent as a result of a window management component implementing a window cascade on the server.

In other embodiments as described above in connection with block rather than receiving a z order entry the first agent receives an identification of a clipping region in the remote desktop environment corresponding to a region on the local display associated with a local resource . In one of these embodiments the first agent receives the identification from the second agent . In another of these embodiments described in additional detail above the first agent identifies the region responsive to information received from the second agent . In still another of these embodiments as described in additional detail above the first agent identifies the region responsive to identifying a color key in a communication from the second agent .

In yet other embodiments the first agent modifies a z order entry for a proxy window representing the local window in a z order list on the remote machine responsive to the identification of the change the proxy window having a z order entry in a z order list associated with the plurality of windows in the remote desktop environment . In one embodiment the first agent assigns the local window a z order entry synchronized with the z order entry of the proxy window which has a z order entry in a z order list including z order entries for a plurality of windows . In another embodiment generating a z order list including entries both for windows generated by a resource executing on a server and for windows generated by a resource executing on a client allows for integrated and overlapping displays of local and remote windows.

Referring now to a flow diagram depicts one embodiment of a method for maintaining a full screen integrated desktop environment on a remote machine for display to a user by a local machine the desktop environment providing integrated access both to resources provided by the local machine and resources provided by the remote machine. The method includes monitoring by a first agent executing on the remote machine a desktop environment comprising a plurality of data objects the desktop environment providing integrated access to i a first resource provided by the remote machine available to a user of the local machine and ii a second resource provided by the local machine that is available to the user of the local machine block . The first agent generates a proxy window in the desktop environment wherein the proxy window represents a window on the local machine that displays output data generated by the second resource block . The first agent receives an identification of a change to window attribute data associated with the window on the local machine that displays output data generated by the second resource block . The first agent modifies at least one of the plurality of data objects responsive to the identification of the change block . The first agent transmits to a second agent executing on the local machine an identification of the modification to the at least one of the plurality of data objects block .

In one embodiment monitoring a desktop environment is performed as discussed above in connection with . In another embodiment generating a proxy window in the desktop environment is performed as discussed above in connection with . In another embodiment receiving by the first agent an identification of a change to window attribute data associated with the window on the local machine is performed as discussed above in connection with . In still another embodiment modifying by the first agent at least one of the plurality of data objects is performed as discussed above in connection with . In yet another embodiment transmitting by the first agent to a second agent executing on the local machine an identification of the modification to the at least one of the plurality of data objects block is performed as discussed above in connection with .

Referring now to a block diagram depicts one embodiment of a system for maintaining a full screen integrated desktop environment for display on a local machine the desktop environment providing integrated access to both resources provided by the local machine and to resources provided by a second remote machine. In brief overview the system includes a first machine a first agent a second machine a second agent and a remote machine . The first agent receives an identification of a remote resource available to a user of the second machine and provided by the remote machine . The first agent executing on the first machine monitors a desktop environment which includes a plurality of data objects and provides access to i the remote resource provided by the remote machine and ii a resource provided by the second machine that is available to the user of the second machine . The first agent receives a request for execution of the remote resource provided by the remote machine . The first agent directs a second agent on the second machine to request execution of the remote resource provided by the remote machine . The first agent receives from the second machine an identification of a change to attribute data of a local window on the second machine the local window displaying output data generated by the remote resource provided by the remote machine . The first agent modifies attribute data for a proxy window representing the local window on the first machine responsive to the identification of the change. The first agent transmits to the second machine an identification of the modification to the proxy window . The second agent executing on the second machine modifies attribute data associated with a data object displayed in the second machine responsive to the received identification of the modification.

In some embodiments attribute data of local window is a z order entry of local window . In other embodiments attribute data of proxy window is a z order entry for a proxy window in a z order list on the first machine the proxy window having a z order entry in a z order list associated with a plurality of windows in the remote desktop environment .

The second agent provides access to the remote desktop environment . In some embodiments establishment of a seamless pass through presentation layer protocol connection between the remote desktop environment to the remote machine is requested. In one of these embodiments a second client agent is executed on the second machine to establish the connection between the second machine and the remote machine . In one embodiment the second client agent is an RDP client. In another embodiment the second client agent is an ICA client. In another embodiment the second client agent is a client utilizing any of the protocols discussed previously in connection with .

Referring now to a screen shot depicts one embodiment of a system for maintaining a full screen integrated desktop environment for display on the local machine the desktop environment providing integrated access to both resources provided by the local machine and to resources provided by a second remote machine. As depicted in two presentation layer protocol sessions are executed on the second machine . Session with the bold boundary is a presentation layer protocol session providing access to a desktop environment . Session with the dashed boundary is a presentation layer protocol session providing access to a resource as depicted in the resource is a word processing program MICROSOFT WORD . The WORD application window which is local window has been merged with the presentation of the desktop session which is represented by the remote desktop environment . If the first machine had established the session the first machine would have received the output data and would have then forwarded the output data to the second machine for display. Instead in this embodiment the second machine established the presentation layer protocol session required to access WORD instead of the first machine establishing a presentation layer protocol session and the second machine receives the output data directly from the remote machine . However the display of output data generated by resource is integrated into the local display of desktop environment .

Referring now to a flow diagram depicts one embodiment of a method for maintaining a full screen integrated desktop environment on a remote machine for display on a local machine the desktop environment providing integrated access to both resources provided by the local machine and to resources provided by a second remote machine the method including receiving by a first agent executing on a first machine an identification of a remote resource available to a user of a second machine the remote resource provided by a third machine block . The first agent monitors a desktop environment comprising a plurality of data objects and providing access to i the remote resource provided by the third machine and ii a resource provided by the second machine that is available to the user of the second machine block . The first agent receives a request for execution of the remote resource provided by the third machine block . The first agent directs a second agent executing on the second machine to request execution of the remote resource provided by the third machine block . The second agent transmits to the first agent an identification of a change to attribute data of a local window on the second machine the local window displaying output data generated by the remote resource provided by the third machine block . The first agent modifies attribute data of a proxy window representing the local window on the first machine responsive to the identification of the change block . The first agent transmits to the second agent an identification of the modification to the proxy window block . The second agent modifies attribute data associated with a data object displayed in the second machine responsive to the received identification of the modification block .

Referring now to and in greater detail a first agent executing on a first machine receives an identification of a remote resource available to a user of a second machine the remote resource provided by a third machine block . In one embodiment the first agent receives the identification from the remote machine . In another embodiment the first agent receives the identification from the second machine . In still another embodiment the first agent receives the identification from an agent on one of the remote machine and the second machine . In yet another embodiment the first agent receives the identification from a fourth machine .

In one embodiment a resource comprises a program an application a document a file a plurality of applications a plurality of files an executable program file a desktop environment a computing environment or other resource made available to a user of the second machine . The resource may be delivered to the remote machine via a plurality of access methods including but not limited to conventional installation directly on the remote machine delivery to the remote machine via a method for application streaming or execution from a removable storage device connected to the remote machine such as a USB device.

The first agent monitors a desktop environment comprising a plurality of data objects and providing access to i the remote resource provided by the third machine and ii a resource provided by the second machine that is available to the user of the second machine block . In some embodiments the first agent monitors the remote desktop environment as described above in connection with B A B and C.

The first agent receives a request for execution of the remote resource provided by the third machine block . In one embodiment the first agent receives the request via a communications channel such as an ICA channel between the first agent and the second agent . In another embodiment the first agent receives the request when a user of the second machine selects a graphical representation of the remote resource depicted in the local display of the remote desktop environment . For example the first agent may generate a graphical representation of the remote resource such as an icon and incorporate the icon into the remote desktop environment upon receiving the identification of the remote resource from the remote machine . In still another embodiment the first agent receives a request for execution of the remote resource when a resource executing on one of the first machine and the second machine attempts to access a resource such as a file that requires the execution of the remote resource .

The first agent directs a second agent executing on the second machine to request execution of the remote resource provided by the third machine block . In one embodiment the first agent directs the second agent to execute another agent on the second machine and to instruct the second agent to request execution of the remote resource provided by the remote machine . In another embodiment the second agent is a presentation layer protocol client such as an ICA client or an RDP client or any client utilizing any of the protocols discussed previously in connection with . In still another embodiment the second agent establishes a connection to the remote machine and requests execution of the remote resource . In yet another embodiment the second agent receives output data generated by the execution of the remote resource and displays the output data in the local window . In some embodiments the second agent directs the first agent to request execution of the remote resource on server upon making a determination the requested resource is unavailable or not executable from the second machine .

The second agent transmits to the first agent an identification of a change to attribute data of a local window on the second machine the local window displaying output data generated by the remote resource provided by the third machine block . In some embodiments attribute data of local window is a z order entry of the local window . In one of these embodiments the second agent transmits the identification of the change to the z order entry of the local window to the first agent . In another of these embodiments the second agent transmits the identification of the change to the z order entry of the local window to the first agent as described above in connection with B A B and C.

The first agent modifies attribute data of a proxy window representing the local window on the first machine responsive to the identification of the change block . In some embodiments attribute data of proxy window is a z order entry for a proxy window in a z order list on the first machine the proxy window having a z order entry in a z order list associated with a plurality of windows in the remote desktop environment . In some of these embodiments the first agent modifies a z order entry for a proxy window as described above in connection with B A B and C.

The first agent transmits to the second agent an identification of the modification to the proxy window block . In some embodiments the first agent transmits to the second agent an identification of the modification to the proxy window as described above in connection with B A B and C.

The second agent modifies attribute data associated with a data object displayed in the second machine responsive to the received identification of the modification block . In some embodiments the second agent modifies attribute data associated with a data object displayed in the second machine responsive to the received identification of the modification as described above in connection with B A B and C.

Referring now to a block diagram depicts one embodiment of a system for providing by a remote machine access to functionality associated with a resource executing on a local machine. In brief overview the system includes a local machine a resource provided by the local machine a shell extension associated with the resource a remote machine a remote agent a shell extension invoker and a shell extension proxy handler .

Referring now to and in greater detail a remote agent executing on a remote machine receives an identification of a shell extension associated with a resource provided by a local machine . In one embodiment a shell extension handler adds functionality to an operating system shell executing on a computing device . In another embodiment an operating system shell is software providing an operating system user interface to the user. In still another embodiment a first operating system shell may be supplemented or replaced with a third party shell. In still even another embodiment when a user of a computing device interacts with a data object associated with a shell extension the interaction triggers the execution of a shell extension handler. In some embodiments a shell extension includes for example and without limitation a context menu handler a drag and drop handler a data handler a drop handler an icon handler a property sheet handler a thumbnail image handler an infotip handler a metadata handler a column handler a copy hook handler an icon overlay handler a search handler a system tray icon handler or any other shell extension.

In one embodiment a shell extension handler is an in process COM object. In another embodiment the COM object conforms to a particular set of interfaces that can be registered with the shell to provide additional functionality. In still another embodiment there are interface functions and methods that are specific to a type of extension and allow the invoking of the extended functionality and the registering of the extensions with the shell.

In some embodiments a shell extension is associated with a file type. In one embodiment file types also referred to as file classes are defined by a file extension. In another embodiment a file type association FTA is defined by a registry entry that maps a file extension to a file type association handler. In still another embodiment a file type association handler provides logic to execute an action on any given file of that type. In still another embodiment a single file type may have a default handler but may also define multiple alternate handlers. In yet another embodiment a single handler may handle more than one file type. In some embodiments a PerceivedFileType may also be associated with an extension. In one of these embodiments a PerceivedFileType acts like an alternate abstract system provided file type through which additional file type association handlers can be defined.

In some embodiments a handler and a shell extension are associated with a file class or file type. In one of these embodiments a shell extension provided by a drop handler enables a file to be a drop target for example for use in defining a Send To menu entry. In another of these embodiments a shell extension provided by an icon handler enables provisioning of file specific icons to the shell. In still another of these embodiments a shell extension provided by a property sheet handler enables addition to or modification of a property page associated with the shell. In still even another of these embodiments a shell extension provided by a thumbnail image handler provides a thumbnail image for a file. In yet another of these embodiments a shell extension provided by an info tip handler provides data associated with a display of a pop up information tip associated with a file.

In other embodiments a handler and a shell extension are not associated with a file class or file type. In one of these embodiments a shell extension provided by a column handler adds additional columns to a display of data by the shell for example by adding new columns to a details section displayed by a shell. In another of these embodiments a shell extension provided by a copy hook handler approves or denies a request to execute a folder operation for example the handler may approve or veto a request to move copy delete or rename a folder or printer. In still another of these embodiments a shell extension provided by a drag and drop handler provides functionality for adding items and corresponding handlers to a context menu shown when dragging and dropping with the right mouse button in the shell. In still even another of these embodiments a shell extension provided by an icon overlay handler specifies an overlay for an icon associated with a type of file. In yet another of these embodiments a shell extension provided by a search handler enables implementation of a custom search engine and may provide access to the custom search engine from the shell or from within a menu such as a Start menu.

A shell extension invoker resides on the local machine and is associated with the identified shell extension. In one embodiment a shell extension invoker initiates the execution of a local shell extension handler upon receiving a notification of a user request for access to a shell extension. In another embodiment the shell extension invoker receives from a shell extension proxy handler on a remote machine a request for a shell extension installed on the local machine . In still another embodiment the shell extension invoker proxies the received request to the appropriate local shell extension handler on the local machine .

In one embodiment the shell extension invoker hosts a shell extension instance on the local machine to execute the proxied requests originating on the remote machine . In another embodiment the shell extension invoker returns a result of an execution of a shell extension on the local machine to a shell extension proxy handler .

In some embodiments there is one instance of a shell extension invoker per shell extension type as the target shell extension instance can be made identifiable in the proxied request . In other embodiments it is possible to combine concrete implementations for multiple shell extension types into one physical component.

A shell extension proxy handler is installed by the remote agent and is associated with the identified shell extension . The shell extension proxy handler receives a request for access to the shell extension and redirects the request to the shell extension invoker . In one embodiment the shell extension handler receives a notification of a user interaction with a user interface element displayed on the local machine . In another embodiment the user interaction is an event such as a right mouse click that is translated into a request for access to functionality provided by the shell extension .

In some embodiments such a request may be initiated by a user of a local display of a desktop environment for example of a desktop environment as described above in connection with or by any other source such as a program or process executing on remote machine . In one embodiment the shell extension proxy handler includes a transceiver receiving a result of executing the shell extension on the local machine . In another embodiment the shell extension proxy handler includes a transceiver transmitting to the shell extension invoker data associated with the request.

In one embodiment the shell extension proxy handler on the remote machine represents a shell extension provided on the local machine . In another embodiment a plurality of shell extension proxy handlers on the remote machine represent a shell extension provided on the local machine . In still another embodiment the shell extension proxy handler proxies shell extension actions such as requests received by the remote machine for access to a shell extension to the shell extension invoker . In still even another embodiment the shell extension proxy handler includes functionality for responding to a shell extension action without redirecting the request to the shell extension invoker . In some embodiments the shell extension proxy handler is in communication with a path mapping component to map a path name to a file system object visible from the remote machine to a path name to the same file system object on the local machine . In other embodiments the shell extension proxy handler is in communication with a windows mapping component to map a remote window such as a parent window in a user interface display on the remote machine to a window displayed on the local machine .

In some embodiments the shell extension proxy handler includes a transceiver transmitting to the shell extension invoker data associated with the request. In other embodiments the shell extension proxy handler transmits the data associated with the request to the remote agent which transmits the data to a local agent on the local machine wherein the local agent transmits the data to the shell extension invoker . The shell extension proxy handler may receive from the shell extension invoker a result of executing the shell extension on the local machine .

The remote agent in communication with a window management component may integrate a display of the result into a desktop environment generated by the remote machine . In one embodiment the remote agent receives an identification of at least one shell extension from the local agent . In another embodiment the remote agent deploys a shell extension proxy handler responsive to receiving the identification of the at least one shell extension. In still another embodiment the remote agent modifies a remote registry to register the shell extension proxy handler . In yet another embodiment the remote agent transmits a notification to the shell on the remote machine identifying the modification to the remote registry .

In one embodiment the remote agent receives a data set identifying shell extensions on the local machine . In another embodiment the data set includes a graph of associations between nodes consisting of file types ProgID or PseudoProgID registry keys shell extension handlers and shell extension handler executables along with disparate attributes associated with each node.

In some embodiments the remote agent removes the shell extension proxy handler so that users of the remote machine are not presented with client originated shell extensions when no client is present. In one of these embodiments the remote agent removes an identification of the shell extension proxy handler from the shell de registering the shell extension proxy handler . In one of these embodiments changes made to extension related data on the remote desktop during the connection lifetime persist once the client connection is closed. In another embodiment data integration is reversible and is reversed once the client connection disappears.

In other embodiments a single remote agent executes on the remote machine . In still other embodiments a plurality of remote agents execute on the remote machine . In one of these embodiments each of the plurality of remote agents is associated with a separate shell extension. In another of these embodiments each of the plurality of remote agents is associated with a separate type of shell extension.

In other embodiments installation of the shell extension proxy handler by the remote agent may include registering the shell extension proxy handler with a registry on the remote machine and sending a message to a shell on the remote machine .

In some embodiments the shell is a WINDOWS EXPLORER program for example in an embodiment in which the remote machine executes the WINDOWS operating system. In one of these embodiments the WINDOWS EXPLORER on the remote desktop operates without modification. In another of these embodiments the operation of WINDOWS EXPLORER is modified by hooking or by the operation of filter drivers. In other embodiments the shell is a command shell program. In still other embodiments the shell is a shell provided by the MAC operating system.

The system may include a local agent executing on the local machine and identifying the shell extension associated with the resource that is to be integrated into the remote desktop . In one embodiment the local agent may identify the shell extension by watching or polling a local registry or by hooking registry functions within a resource or by registering for registry change notifications or by monitoring changes via a registry filter driver. In another embodiment the local agent may then publish the identified shell extension to the remote agent .

In one embodiment the local agent is a shell extension monitor that monitors at least one shell extension. In another embodiment the local agent includes a shell extension monitor while also providing other functionality for example the local agent may be an agent an agent a presentation layer protocol program or a local agent as described above in connection with .

In some embodiments the system includes a component providing additional management capabilities e.g. it will deal with situations where both client and remote desktop provide clashing shell extensions for the same file class. In one of these embodiments a management component may use rules or policies or other means to determine whether to use the shell extension provided by the local machine or that provided by the remote machine side or whether both shell extensions are to be activated for example by modifying a graphical representation of the shell extension to identify the computing device providing the shell extension. In another of these embodiments the remote agent provides this functionality.

In other embodiments there may be management policies or controls that specify on a case by case basis what happens when both client and remote desktop define the same entity file type PseudoProgID registry key handler or any attribute of those entities . In one of these embodiments the client setting overrides the remote desktop setting for the duration of the connection. In another of these embodiments the client entity can be given a new name e.g. a ProgID registry key clash can be resolved by having a new ProgID registry key representing the client version and both might apply at once. In still another of these embodiments the remote desktop setting remains unmodified.

In some embodiments the system includes mitigation mechanisms to improve a level of efficiency of the system. In one of these embodiments a mitigation mechanism includes a policy controlling which types and instances of extensions are integrated. In one of these embodiments a mitigation mechanism includes a policy controlling which portions of at least one file system are proxied to extension handlers that may be on a different file system from the at least one file system and may for example restrict integration to files residing on the same machine as the handler to prevent file transfer over a presentation layer protocol. In another of these embodiments a mitigation mechanism includes a caching mechanism.

In some embodiments the system includes a window mapping component. In one of these embodiments a shell extension interface call specifies a window for a shell extension proxy handler to use as a parent window in which to display any additional user interface elements generated by the shell extension interface call. In another of these embodiments the shell extension invoker retrieves from the window mapping component an identification of a corresponding parent window displayed by the local machine . In still another of these embodiments the window mapping component executes on the local machine . In yet another of these embodiments the window mapping component includes a component executing on the remote machine .

In some embodiments the system provides shared file system visibility between a remote machine and a local machine . In one of these embodiments some or all of the file system objects visible on one machine are also visible on the other and a mapping between file system paths in both directions is known. For example and in another of these embodiments both the remote machine and the local machine may map the same network drive making it visible to both. In another of these embodiments an expectation of shared file system visibility arises due to characteristics of shell extension APIs for example many shell extensions are initialized by the shell using a list of filenames to operate upon for example by using an IDataObject containing the list and thereafter they operate upon the file attributes or file contents via the filenames. In other embodiments alternatives to sharing file system visibility are provided including working with limited shared visibility or initializing a handler using an IStreams interface. In still other embodiments the system includes a file system path mapping component which may provide functionality for improving shared file system visibility between a remote machine and the local machine .

In one embodiment a file system path mapping component maps file system paths between a file system on the remote machine and the local machine . In another embodiment the file system path mapping component allows shell extension actions on files and directories to work across the remote machine and the local machine where a file system path to an object such as a text document on the remote machine may not be the same as the path to the corresponding object on the local machine for example in a case where a drive C on local machine is mapped to drive M on remote machine using client drive mapping the remote machine path M Temp test.txt refers to the same file as the local machine path C Temp test.txt. In still another embodiment the file system path mapping component forms a part of a component providing data mapping functionality. In yet another embodiment the file system path mapping component leverages functionality for client drive mapping special folder redirection and reverse client drive mapping desktop drive mapping or server drive mapping .

In one embodiment the file system path mapping component is aware of a plurality of ways to map file system paths between the remote machine and the local machine including but not limited to network shares whether from the remote machine and the local machine or from both the remote machine and the local machine to a third location and administrative network shares. In another embodiment the file system path mapping component includes functionality for correctly handling mappings for shell folders even those that might be redirected such as My Documents . In still another embodiment the file system path mapping component determines which file system objects on the remote machine are not visible to the local machine and hence which do not have shell extension proxy handler functionality made available for them.

In one embodiment the file system path mapping component executes on the remote machine . In another embodiment the file system path mapping component executes on the local machine . In still another embodiment the file system path mapping component executes on both the remote machine and the local machine . In yet another embodiment the file system path mapping component includes a remote machine element identifying at least one file system objects on the remote machine that are not to be made visible to the local machine .

Referring now to a flow diagram depicts an embodiment of a method for providing by a remote machine access to functionality associated with a resource executing on a local machine . In brief overview the method includes receiving by a remote agent executing on a remote machine an identification of a shell extension associated with a resource provided by a local machine block . The remote agent installs a proxy handler associated with the identified shell extension block . The proxy handler receives a request for access to the shell extension block and redirects the request to a shell extension invoker executing on the local machine block .

A remote agent executing on a remote machine receives an identification of a shell extension associated with a resource provided by a local machine block . In some embodiments a local agent executing on the local machine identifies a shell extension associated with a local resource wherein the shell extension is to be integrated into a desktop environment of the remote machine . Such identification by the local agent may in some embodiments be achieved by watching or polling a local registry or by hooking registry functions within a resource or by registering for registry change notifications or by monitoring changes via a registry filter driver. In some of these embodiments the local agent may publish the identified shell extension to for example the remote agent .

In one embodiment the remote agent receives from the local agent with the identification of the shell extension an identification of a registry key for integration into the desktop environment. In another environment and as described in greater detail above the registry key may be a PseudoProgID registry key defining information relevant to a file type association with which the shell extension is associated. In still another embodiment a local resource that is included in the integrated desktop includes a shell extension handler that implements functionality defined by a PseudoProgID registry key.

In one embodiment the remote agent receives from the local agent with the identification of the shell extension an identification of a file type to be included in the integrated desktop. In another embodiment a shell extension that is included in the integrated desktop is associated with the file type. In still another embodiment the remote agent registers with the remote registry a registry key associated with the identified file type.

In one embodiment the remote agent receives from the local agent an identification of a shell extension handler providing enhanced drag and drop functionality. In another embodiment the remote agent receives from the local agent an identification of a shell extension handler providing customized icons for display. In still another embodiment the remote agent receives from the local agent an identification of a shell extension handler providing additional functionality for a data object such as a file class object a mounted drive object or a control panel applet object. In still even another embodiment the remote agent receives from the local agent an identification of a shell extension handler providing additional functionality for an image associated with a shell object such as a thumbnail image. In yet another embodiment the remote agent receives from the local agent an identification of a shell extension handler providing additional functionality in a display of dynamic information to a user such as in an InfoTip pop up window.

In one embodiment the remote agent receives from the local agent an identification of a shell extension handler providing additional functionality for customized columns displayed in a desktop environment for example in a Details view in a MICROSOFT WINDOWS desktop environment . In another embodiment the remote agent registers the shell extension proxy handlers directly under the registry key HKCR Folder shellex ColumnHandlers and no file type association or ProgIDs are involved. In still another embodiment when shell object s are dragged between shell folders using the right mouse button the shell shows a context menu when the user drops the object s this menu contains the options to copy move or create a shortcut to the source file in the target location or cancel the operation. In yet another embodiment the remote agent receives from the local agent an identification of a shell extension handler augmenting a context menu with new options and code to execute them if selected.

In one embodiment the remote agent receives from the local agent an identification of a shell extension handler providing additional functionality for customizing images associated with an icon such as for example an icon overlays or other small image overlaid on the bottom left part of an icon to provide additional information for example the shell may use a small arrow overlay to indicate a link and custom overlays can be provided using an icon overlay handler. In one embodiment the remote agent receives from the local agent an identification of a shell extension handler implementing an interface such as IShellIconOverlayIdentifier

In one embodiment the local agent identifies a plurality of shell extensions installed on the local machine which are provided by any resource on the local machine and that are to be integrated into the remote desktop. In another embodiment the local agent identifies at least one shell extension upon the establishment of a presentation layer protocol connection between the local machine and the remote machine . In still another embodiment the local agent identifies at least one shell extension upon the establishment of a connection between the local machine and the remote machine within which the local machine will display an integrated full screen desktop providing integrated access to resources including shell extensions provided by both the local machine and the remote machine . In yet another embodiment the local agent identifies at least one shell extension upon the establishment of a connection between the local machine and the remote machine within which the local machine will integrate a display of at least one data object maintained on the remote machine into a local display of a desktop environment.

In some embodiments to identify a shell extension the local agent identifies a shell extension handler provided by any resource whose display of output data is to be included in the display of the integrated desktop. In one of these embodiments the local agent identifies a file class associated with the shell extension handler. In another of these embodiments a ProgID refers to a name within the WINDOWS operating system for a resource such as an application or COM server that acts as a file type association handler. In still another of these embodiments a default ProgID is defined for each file type association but file types may also be associated with lists of alternate ProgIDs and lists of registered application executables that can also handle them a registered application acts as a pseudo ProgID for the purposes of file type association but it is defined differently in the registry. In yet another of these embodiments a pre defined shell objects may also act as pseudo ProgIDs representing classes of shell objects these include without limitation drives folders directories file system objects of any type any file class the background of either a desktop or Explorer folder view window .

In one embodiment a PseudoProgID is a ProgID a name identifier of a resource. In another embodiment a PseudoProgID is a registered application which also references a resource. In still another embodiment a PseudoProgID is a class of pre defined shell object. In yet another embodiment a PseudoProgID provides functionality substantially similar to that of a file type. In still another of these embodiments a PseudoProgID registry key may define information relevant to the file type association it provides including without limitation a default icon an info tip a friendly type name for display to a user and an identification of an edit flag defining what file type association editing actions can be performed via the shell.

In one embodiment to identify a shell extension the local agent identifies a shell extension handler not associated with any file classes but provided by any resource whose display of output data is to be included in the display of the integrated desktop.

In some embodiments the local agent gathers information to identify a shell extension handler a relevant file type a relevant ProgID or PseudoProgID and the associations amongst them. In one of these embodiments a shell extension handler is discovered by enumerating all registry keys of the correct form for the type of shell handler in question. For example and in another of these embodiments some of the relevant registry keys are of the form HKCR shellex where the default value under that key is the string form of the GUID for the handler COM object which is registered in the usual fashion . In this embodiment and for registered applications the data is found under key HKCR Applications instead of the key where is the executable name generally including the .exe or .dll extension but omitting path. This embodiment describes the process in terms of HKCR but in other embodiments the shell uses additional layers of registry keys to determine appropriate behavior for a particular object. In other embodiments the keys may define user customization for a file type system file associations system file perceived type associations and wildcard keys for the base class and all file system objects. In this embodiment this form is used by extensions that are registered for a particular file class different extension types use different registry key forms. In still another of these embodiments extensions that are not bound to a file class may use different registry keys such as the following examples 

In still even another of these embodiments this enumeration process results in a list of extension handler GUIDs as well as a list of Pseudo ProgIDs for which handlers are registered and the association between them or of an association to a file extension rather than a ProgID. In yet another embodiment the COM GUIDs can be mapped to executable files using the registry s COM registration database. In some embodiments the local agent may gather additional information specific to the extension type during a process of enumeration of a shell extension handler.

In one embodiment the local agent identifies a drop handler implementing IPersistFile and IDropTarget interfaces. In another embodiment the local agent identifies a shell extension handler associated with a ProgID registry key by enumerating at least one registry key of a particular form. For example in still another embodiment the local agent enumerates registry keys of the form HKCR shellex DropHandler.

In one embodiment the local agent identifies a shell extension handler providing functionality associated with a menu item. For example the shell extension handler may enable a new menu in a menu. In another embodiment the local agent retrieves an enumeration of shortcuts stored in a directory associated with a shell shortcut on the local machine . In still another embodiment the local agent accesses a directory such as a Send To directory using HGetSpecialFolderLocation NULL CSIDL SENDTO pidl to identify the shell extension handler.

In one embodiment the local agent identifies a file associated with a shell extension handler on the local machine for example drop handlers may be associated with small often zero byte files with extensions which may be found in the shell Send To directory. In this embodiment a registry key associated with the extension HKCR typically has a default value of the form CLSID which defines the drop handler GUID. In this embodiment the CLSID entry for the drop handler GUID has a default string used by the shell when a user browses a Send To directory as well as the typical COM server definition data HKCR CLSID shellex DropHandler may also be present with a default value that is a loopback pointing to the same GUID. In this embodiment the local agent uses the GUID to identify the shell extension handler.

In one embodiment the local agent identifies a shell extension handler by enumerating a file in a Send To folder maintained by a shell on the local machine . In another embodiment the local agent identifies a shell extension handler by enumerating an application shortcuts identified in a Send To folder. In still another embodiment the local agent identifies a shell extension handler by enumerating a file system location shortcut identified in a Send To folder. In yet another embodiment the local agent identifies a shell extension handler by determining or computing a set of built in menu items provided on the local machine . In some embodiments the local agent transmits to the remote agent an identification of a file system location shortcut associated with a shell extension proxy handler and an identification of a path name associated with the shortcut.

In one embodiment the local agent identifies a handler implementing IPersistFile and IExtractIcon interfaces. In another embodiment the local agent identifies a shell extension handler associated with a ProgID registry key by enumerating all registry keys of a particular form. For example in still another embodiment the local agent enumerates registry keys of the form HKCR shellex IconHandler.

In one embodiment the local agent identifies a shell extension handler providing additional functionality for a Properties menu item displayed when a user right clicks on a data object in a desktop environment displayed on the local machine . In another embodiment when a user requests access to a Properties menu item a property sheet is displayed with a user may view or modify a property of the data object. In still another embodiment the shell extension handler providing additional functionality allows the customization of this property sheet.

In one embodiment such a shell extension handler may provide additional functionality for example by adding a page to a Properties sheet for a file class object. In another embodiment such a shell extension handler may provide additional functionality to a Properties sheet for a mounted drive object. In still another embodiment such a shell extension handler may provide additional functionality to a control panel applet object. In still even another embodiment a shell extension handler providing additional functionality for a file class or a mounted drive can add a custom page to the Properties sheet for that class. In yet another embodiment a shell extension handler providing additional functionality for a control panel applet can replace a page in the property sheet provided by the applet.

In one embodiment the local agent identifies a shell extension handler implementing IShellExtInit and IShellPropSheetExt interfaces. In another embodiment the local agent identifies a shell extension handler associated with a ProgID registry key by enumerating all registry keys of a particular form. For example in still another embodiment the local agent enumerates registry keys of the form HKCR shellex PropertySheetHandlers .

In some embodiments a shell extension handler providing additional functionality for a data object such as a mounted drive object is not associated with a ProgID registry key. In one of these embodiments the local agent identifies the shell extension handler by enumerating registry keys of the forms HCKR Drive shellex PropertySheetHandlers . In other embodiments a shell extension handler providing additional functionality for a data object such as a control panel applet object is not associated with a ProgID registry key. In one of these embodiments the local agent identifies the shell extension handler by enumerating registry keys of the form 

In one embodiment the local agent identifies a shell extension handler implementing an IThumbnailProvider interface and one or more of IInitializeWithFile IInitializeWithItem and IInitializeWithStream interfaces. In another embodiment the local agent identifies a shell extension handler associated with a file class. In still another embodiment the local agent identifies a shell extension handler registered using a subkey named for a specific GUID.

In one embodiment the local agent identifies the shell extension handler by enumerating registry keys of the form HKCR shellex E357FCCD A995 4576 B01F 234630154E96 the default value of the key is a string form of the GUID of the shell extension COM server. In another embodiment the local agent identifies the shell extension handler by enumerating values under HKCR that can affect the thumbnail preview handling for a given file class including but not limited to i ThumbnailCutoff which defines a minimum size beyond which thumbnails will not be displayed ii TypeOverlay which specifies a specific thumbnail overlay as a resource no overlay or the ProgID s default icon and iii Treatment which specifies a type of adornment that Windows should apply to the thumbnail.

In one embodiment the local agent identifies a shell extension handler implementing an IQueryInfo and IPersistFile interface. In another embodiment the local agent identifies a shell extension handler associated with a file class. In still another embodiment the local agent identifies a shell extension handler registered using a subkey named for a specific GUID. In still even another embodiment the local agent identifies the shell extension handler by enumerating registry keys of the form HKCR shellex 00021500 0000 0000 0000 000000000046 the default value of the key is a string form of the GUID of the shell extension COM server.

In one embodiment the local agent identifies a shell extension handler implementing an IColumnProvider interface. In another embodiment the local agent identifies a shell extension handler registered under a PseudoProgID Folder . In still another embodiment the local agent identifies the shell extension handler by enumerating registry keys of the form HKCR Folder shellex ColumnHandlers where is the string form of the GUID of the handler. In yet another embodiment the local agent identifies a shell extension handler implementing an IColumnProvider Initialize function to initialize the shell extension handler i.e. a new copy of the DLL can be created for each proxy column handler required and each proxy handler instance knows which client side handler via GUID to direct proxied requests to and are registered under its own GUID .

In one embodiment the local agent identifies a shell extension handler implementing an ICopyHook interface. In another embodiment the local agent identifies a shell extension handler registered under a PseudoProgID Directory . In still another embodiment the local agent identifies the shell extension handler by enumerating registry keys of the form HKCR Folder shellex CopyHookHandlers where the default value of that key is the string form of the GUID of the handler.

In one embodiment the local agent identifies a shell extension handler implementing an IContextMenu interface. In another embodiment the local agent identifies a drag n drop shell extension handler enumerating all registry keys of the form HKCR Directory shellex DragDropHandlers where the default value of this key is the string form of the GUID of the shell extension COM server.

In one embodiment the local agent identifies a shell extension handler implementing an IShellIconOverlayIdentifier interface. In another embodiment the local agent identifies a shell extension handler registered with a shell on the local machine . In still another embodiment the local agent identifies the shell extension handler by enumerating registry keys of the form HKLM Software Microsoft Windows CurrentVersion Explorer ShellIconOverlayIdentifiers where the default value of that key is the string form of the GUID of the handler.

In one embodiment the local agent identifies a shell extension handler by enumerating registry keys of the form HKLM Software Microsoft Windows CurrentVersion Explorer FindExtensions Static where the default value of that key is the string form of the CLSID ShellSearchExt GUID currently 169A0691 8DF9 11d1 A1C4 00C04FD75D13 . In another embodiment the local agent identifies the shell extension handler by retrieving a value stored in a subkey including a default value identifying the shell extension handler. In another embodiment the local agent identifies the shell extension handler by retrieving a value stored in a subkey of a subkey named Defaulticon whose default value specifies an icon associated with the shell extension handler as a string . In still another embodiment the local agent identifies an attribute of the shell extension handler by retrieving a value stored in a SearchGUID subkey of a subkey where the default value is the GUID of the DHTML document. In still another embodiment the local agent identifies an attribute of the shell extension handler by retrieving a value stored in a URL subkey of a SearchGUID subkey of a subkey where the default value is a URL subkey whose default value is a path to an HTML document to be opened in an Explorer bar. In still another embodiment the local agent identifies an attribute of the shell extension handler by retrieving a value stored in a SearchGUID subkey of a subkey where the SearchGUID subkey includes a UrlNavNew key whose default value is the path to the HTML doc to be opened to the right of the Explorer bar.

In some embodiments a local agent identifies a resource associated with a shell extension handler. In one of these embodiments a local agent identifies the resource after completing a process of enumerating at least one shell extension handler. In another of these embodiments for each handler identified the local agent determines whether the identified handler is provided by one of the resources that owns a shortcut that is to be included in the display of the integrated full screen desktop.

In one embodiment the local agent includes functionality for determining whether a first resource is associated with a second resource. In another embodiment the determination is made responsive to an analysis of at least one discovered short cut. In still another embodiment an application installer installs a resource in an application specific directory trees dedicated to that particular binary application. In such an embodiment the local agent includes functionality for performing circumstances a path based test to identify the application. In some embodiments the local agent may include functionality for performing sophisticated determinations to supplement path based testing including but not limited to inspecting the file properties for indications that may identify the application parsing installation logs drawing inferences from file timestamps searching for human readable strings within the executable and consulting databases of executable hashes or digital signatures. In other embodiments a determination is made as to whether the folder containing the discovered resource is the same as or a descendant of any folder containing an integrated shortcut target. For example if a static verb handler or context menu handler executable is found in this folder 

and if there is a shortcut to be integrated into the remote desktop whose target is found in this folder C Program Files Company B App C binaries then the discovered handler may be considered to belong to the same application as the shortcut and thus should also be integrated into the remote desktop along with any Pseudo ProgIDs that use it.

In one embodiment the local agent identifies at least one shell extension handler and at least one resource associated with the at least one shell extension handler. In another embodiment the local agent identifies a ProgID or Pseudo ProgID registry key associated with an identified shell extension handler to be included in the integrated desktop. In still another embodiment the local agent identifies at least one file type to be included in the integrated desktop the at least one file type mapping to the identified ProgID or Pseudo ProgID registry key. In yet another embodiment the identified at least one file type is already identified for inclusion in the integrated desktop as it is directly associated with an extension handler.

In some embodiments an identified file type is defined by its file extension e.g. .doc or .ini . In one of these embodiments the file type may be identified by enumerating all registry keys of the form HKCR where is the file extension including the leading period. In another of these embodiments under each file type registry key the following data may be found without limitation 

In still another of these embodiments the mapped ProgID registry key and registered applications may be checked against the list of PseudoProgID registry keys that will be integrated. In still even another of these embodiments a pre defined shell object having a PseudoProgID registry key is handled differently as it may act as a class of object that may include all file types e.g. PseudoProgID which represents all file types . In yet another embodiment any file type which maps to a PseudoProgID registry key that is to be integrated may also be integrated although on the remote machine it may not map to any client PseudoProgID registry key that were not themselves integrated .

In one embodiment the local agent monitors the at least one shell extension for any change. In another embodiment the local agent polls at least a portion of the local registry . In still another embodiment the local agent includes a hooking component and hooks registry functions. In some embodiments the local agent stores an identification of the at least one shell extension on the local machine . In another embodiment the local agent transmits an identification of the at least one shell extension to the remote agent on the remote machine .

In one embodiment the local agent performs on going monitoring for changes to data. In another embodiment to perform monitoring the local agent may use functionality such as that provided by SHChangeNotifyRegister RegNotifyChangeKeyValue or a registry filter driver or by polling or other mechanism to determine when changes to the registry data occur. In still another embodiment given the set of registry data changes identified the local agent computes the changes to the set of integrated shell extension data.

The remote agent installs a proxy handler associated with the identified shell extension block . In some embodiments the remote agent may register the proxy handler with a registry on the remote machine . In some embodiments installation of the proxy handler by the remote agent may include sending a message to a shell on the remote machine . In one embodiment the remote agent integrates a display of the result into a desktop environment generated by the remote machine .

In one embodiment the remote agent registers with the remote registry a registry key associated with the shell extension proxy handler . In another embodiment the remote agent registers with the remote registry a PseudoProgID registry key associated with the shell extension proxy handler . In still another embodiment prior to registering the registry key with the remote registry the remote agent determines whether the remote registry includes a version of the registry key. In yet another embodiment registering the registry key with the remote registry results in the addition of attributes defined by the registry key to the desktop environment monitored by the remote agent . In some embodiments and as described in greater detail above the attributes defined by the registry include icons user friendly alternate file names and information to display in a window associated with the resource such as an InfoTip pop up window . In other embodiments the remote agent installs a shell extension proxy handler after adding a PseudoProgID registry key to the remote registry .

In one embodiment the installation of a shell extension proxy handler results in integration of functionality between the resource on the local machine and the desktop environment monitored by the remote agent . In another embodiment the shell extension proxy handler processes a request received from the shell for functionality associated with the resource . In still another embodiment the shell extension proxy handler redirects a request received from the shell for functionality associated with the resource to the local machine for processing by the shell extension invoker . In yet another embodiment a received result of executing the shell extension on the local machine is displayed in a desktop environment generated by the remote machine .

In one embodiment the remote agent installs a single shell extension proxy handler . In another embodiment the remote agent installs a proxy handler COM server which may be a dynamically linked library or as an executable file for a particular shell extension type. In still another embodiment as the remote agent installs each of a plurality of shell extension proxy handlers a new copy of the proxy handler COM server is installed for each of the shell extension proxy handlers. In still even another embodiment a new copy of the proxy handler COM server executable file is created each time a new shell extension GUID is identified In some embodiments when executed the proxy handler COM server analyzes its own file name to identify a GUID identifying a data object on the local machine with which the shell extension proxy handler and the proxy handler COM server are associated. In one of these embodiments the GUID identifying the data object on the local machine is transmitted to the local agent with a redirected request for access to shell extension functionality.

In one embodiment the remote agent associates a file type identified by the local agent with a registry key received from the local agent such as a PseudoProgID registry key. In another embodiment the remote agent associates a file type association handler with the file type and with the registry key. In some embodiments the remote agent transmits a notification of the association to the shell . In one of these embodiments the remote agent transmits a message to the shell by calling a function used to notify the shell of changes for example the remote agent may call a SHChangeNotify function with the SHCNE ASSOCCHANGE event parameter.

In some embodiments the remote agent installs a shell extension proxy handler not associated with a ProgID registry key. In one of these embodiments the remote agent creates the shell extension proxy handler . In another of these embodiments the remote agent associates the shell extension proxy handler with a GUID identifying a shell extension handler on the local machine . In still another of these embodiments the remote agent associates the shell extension proxy handler with the shell extension invoker . In yet another of these embodiments the remote agent registers the shell extension proxy handler with the shell for example the remote agent may transmit a message to the shell identifying the shell extension proxy handler or the remote agent may modify a registry entry to identify the shell extension proxy handler .

In one embodiment the remote agent virtually installs a shell extension proxy handler. In some embodiments the remote agent intercepts a request for an identification of a handler. In one of these embodiments the remote agent intercepts a request for a file in a file system identifying the handler. In another of these embodiments the remote agent intercepts a request for a registry key in a registry identifying the handler. In still another of these embodiments In still another of these embodiments the remote agent responds to an intercepted request with an identification of the shell extension proxy handler. In still even another of these embodiments a file system filter driver intercepts the request and responds with the identification of the shell extension proxy handler. In yet another of these embodiments a registry filter driver intercepts the request and responds with the identification of the shell extension proxy handler. In other embodiments the remote agent includes a hooking component hooking a request for an identification of a handler and responding with an identification of the shell extension proxy handler. In still other embodiments the remote agent intercepts a COM function call for an identification of a handler and responds with an identification of the shell extension proxy handler.

The proxy handler receives a request for access to the shell extension block . In some embodiments the request for access to the shell extension may be transmitted by a shell on the remote machine to the proxy handler . In other embodiments a user of a remote desktop environment may request for access to the shell extension . In still other embodiments a shell requests access to the proxy handler itself In some embodiments the remote agent identifies a user request for access to the shell extension . In one of these embodiments a user interacts with a display of a data object on the local machine and the local agent detects the interaction and forwards an identification of the interaction to the remote agent . In another of these embodiments the remote agent determines that a user interaction with a display of a data object such as a user interface element displayed in an integrated desktop environment is a request for access to a shell extension . In still another of these embodiments the remote agent identifies a file type associated with the data object. In still even another of these embodiments the remote agent forwards the identified user request to the shell which may provide the functionality described above for identifying a user interaction as a request for access to a shell extension In other embodiments a resource requests access from the shell to a shell extension.

In one embodiment the shell receives an identification of a user interaction with a data object associated with a resource provided by the local machine. In another embodiment the shell determines that the identified user interaction is a request for access to functionality provided by a shell extension. In still another embodiment the shell receives an identification of a user request for access to functionality provided by a shell extension.

In one embodiment the shell identifies a file type association of the data object. In another embodiment the shell identifies a file type association of a shell extension. In still another embodiment the shell identifies shell extension proxy handler associated with the requested functionality. In still even another embodiment the shell initializes the shell extension proxy handler . In another embodiment the shell identifies at least one shell object associated with the shell extension proxy handler . In yet another embodiment the shell identifies at least one folder and at least one operation modifying flag associated with the shell extension proxy handler .

In some embodiments to initialize a shell extension proxy handler the shell uses an interface to retrieve an identification of the shell extension proxy handler . In one of these embodiments for example the shell uses an IPersistFile interface to call a GetClassID function and retrieve a CLSID for the shell extension proxy handler . In another of these embodiments the shell uses the IPersistFile interface to call a Load function and supply a file name on which the shell extension proxy handler should operate and a file access mode. In still another of these embodiments the shell extension proxy handler returns its CLSID in response to GetClassID and stores the filename and access mode passed to Load for use when handling future calls from the shell or passes it mapped to the file system view of the local machine on to a shell extension handler on the local machine via the shell extension invoker if that responsibility is delegated to the client. For some types of shell extension proxy handler for example where file usage semantics are constrained by the definition of the extension interface the shell extension proxy handler may stream the file possibly doing so on demand to the shell extension handler on the local machine or to the shell extension invoker instead of passing the file name or deliver data blocks from the file as requested.

In one of these embodiments the shell uses the IPersistFile interface to retrieve a CLSID if the shell extension proxy handler supplies its own CLSID. In another of these embodiments the system maintains a mapping from the CLSID of the shell extension proxy handler to a CLSID of a shell extension handler on the local machine . In still another of these embodiments a standard shell extension proxy handler DLL is copied to a new instance with a unique path for each new shell extension handler GUID and associated with the shell extension handler CLSID in a way that the proxy handler itself can determine for example the CLSID of the shell extension proxy handler may be embedded in the file path to the shell extension proxy handler . In other embodiments any supplementary mechanism that can associate the proxy handler CLSID to the shell extension handler CLSID may be used. In still other embodiments the CLSID of the shell extension handler on the local machine may be embedded in the path and a mechanism provided to create the association between the CLSID of a shell extension handler on the local machine and the CLSID of the shell extension proxy handler . In yet other embodiments both the CLSID of the shell extension handler on the local machine and the CLSID of the shell extension proxy handler may be embedded in the path name.

In some embodiments the shell initializes a shell extension proxy handler implementing an interface such as IInitializeWithFile IInitializeWithStream or IInitializeWithItem. In one of these embodiments the shell uses an interface such as IInitializeWithFile IInitializeWithStream or IInitializeWithItem to initialize the shell extension proxy handler by specifying a file or a pseudo file upon which the shell extension proxy handler should operate. In another of these embodiments using these interfaces does not require the shell extension proxy handler to return a CLSID. In still another of these embodiments an IInitializeWithFile Initialize function accepts a file path and an access mode read only or read write and in response to initialization the shell extension proxy handler attempts to open the file with the requested mode and keep it open for the life of the handler or until IPropertyStore Commit function is called . In still even another of these embodiments an IInitializeWithStream Initialize function accepts an IStream pointer and an access mode read only or read write and in response to initialization the shell extension proxy handler keeps the stream open for the lifetime of the handler or until IPropertyStore Commit is called. In this embodiment an IStreams interface can represent files that are not accessible via file system paths e.g. files embedded within a ZIP file . In yet another of these embodiments an IInitializeWithItemAnitialize function accepts an IShellItem pointer and an access mode read only or read write .

In some embodiments a shell extension proxy handler can choose which of these interfaces to expose. In one of these embodiments the choice may depend on which of these interfaces the corresponding shell extension handler on the local machine exposes. In another of these embodiments the shell extension proxy handler exposes an IInitializeWithFile interface and can then operate with any or all of the three interfaces on the corresponding shell extension handler on the local machine although in some embodiments the shell extension proxy handler relies upon shared file system visibility to do so . For example and in still another of these embodiments the corresponding shell extension handler on the local machine may i pass the mapped file name directly to the file initialization interface ii open the file using the mapped filename and present it as an IStream for the stream initialization interface and iii pass the shell item corresponding to the file specified by the mapped filename to the shell item interface. In still even another of these embodiments a corresponding shell extension handler on the local machine that supports the stream interface is represented by a shell extension proxy handler that supports the stream interface using stream remoting techniques. In yet another of these embodiments there are other combinations of interfaces used by the shell extension proxy handler and the corresponding shell extension handler on the local machine .

The proxy handler redirects the request to a shell extension invoker executing on the local machine block . In some embodiments the proxy handler transmits to the shell extension invoker data associated with the request. In other embodiments the proxy handler receives a result of executing the shell extension on the local machine. In some of these embodiments a received result of executing the shell extension on the local machine is displayed in a desktop environment generated by the remote machine .

In one embodiment an initialized shell extension proxy handler receives from the shell an identification of a user request for access to shell extension functionality. In another embodiment the shell extension proxy handler receives from the shell data associated with the request. In still another embodiment the shell extension proxy handler redirects the request and any associated data received from the shell to the shell extension invoker on the local machine .

In some embodiments the shell extension proxy handler transmits the request and any associated data directly to the shell extension invoker . In other embodiments the shell extension proxy handler transmits the request and any associated data to the remote agent for forwarding to the shell extension invoker . In still other embodiments the remote agent forwards the request and any associated data directly to the shell extension invoker . In yet other embodiments the remote agent forwards the request and any associated data to the local agent for forwarding to the shell extension invoker .

In one embodiment the shell extension invoker receives a user request for access to shell extension functionality from at least one of the local agent the remote agent the shell extension proxy handler and the remote machine . In another embodiment the shell extension proxy handler identifies a local shell extension handler associated with the requested functionality. In still another embodiment the shell extension invoker initializes the identified local shell extension handler. In still even another embodiment the shell extension invoker re maps a path name from the remote machine included in the request to a corresponding path name on the local machine . In yet another embodiment the initialized shell extension handler processes the request and provides the requested shell extension functionality. In some embodiments to process the request the initialized shell extension handler calls at least one application programming interface associated with the shell extension functionality to provide the functionality. In one of these embodiments the request from the remote machine includes an identification of the at least one application programming interface.

In other embodiments the local agent identifies at least one shell extension handler on the local machine and provides the remote agent with a definition of the at least one shell extension handler. In one of these embodiments the remote agent installs the identified at least one shell extension handler on the remote machine . In another of these embodiments the shell extension handler on the remote machine receives the identification of the user request from the shell and processes the request without redirecting the request to the local machine . In still another embodiment installing the shell extension handler directly on the remote machine provides local execution of shell extension functionality on remote machine without communication with local machine which may reduce bandwidth requirements and latency.

In one embodiment the shell initializes a shell extension proxy handler that provides functionality for enabling a file to be a drop target. In another embodiment the shell initializes a shell extension proxy handler that provides functionality for defining an additional menu entry for example by adding an additional entry in a send to menu that allows a user to move a file or a copy of the file to a different location including but not limited to allowing the movement of the file or copy of the file to a different folder in a file system or an attachment of the file or copy of the file to an electronic mail message. In some embodiments the shell initializes such a shell extension proxy handler when the shell receives an identification that a user has interacted with a data object by dragging a representation of the data object from one location to another and dropped the representation of the data object to another. In one of these embodiments the shell initializes such a shell extension proxy handler when the shell receives an identification of a use of a particular interface such as for example a call to an IDropTarget interface.

In one embodiment the shell calls DragEnter when a user first drags a representation of a data object over a file that is a drop target or when a user selects a Send To menu item implemented by a drop handler. In another embodiment a DragEnter call passes an IDataObject pointer to specify which files and or directories are being dragged using CF HDROP format and the handler s return value indicates whether it will accept the file s being dragged. In still another embodiment DragLeave is called when a user drags away from the target file without dropping. In still even another embodiment Drop is called when the user drops onto the target file.

In one embodiment the DragEnter call passes in amongst other things an IDataObject pointer used to enumerate a set of files and or directories being dragged. In another embodiment the shell extension proxy handler redirects this list to a corresponding shell extension handler on the local machine providing a DragEnter function mapped from the file system view of the remote machine to the file system view of the local machine and encapsulated in a newly constructed IDataObject on the local machine . In still another embodiment the corresponding shell extension handler on the local machine determines the return value indicating whether the dragged files will be copied to linked to moved to by the handler or not accepted at all this value is returned to the shell . In still even another embodiment where the shell extension proxy handler determines that the local machine cannot see some of the files being dragged the shell extension proxy handler returns to the shell a value indicating that the dragged files will not be accepted. In still another embodiment the shell extension proxy handler proxies a DragLeave calls to the corresponding shell extension handler on the local machine for processing. In yet another embodiment the shell extension proxy handler proxies to the corresponding shell extension handler on the local machine a Drop call with an enumeration of at least one file or folder being dropped and an identification of the file system path on the local machine for processing.

In some embodiments a shell extension proxy handler is a proxy Send To drop handler representing a shortcut on the local machine to a file system location on the local machine . In one of these embodiments when DragEnter is called the shell extension proxy handler identifies an associated target file system path on the local machine and an enumeration of dragged files. In another of these embodiments the shell extension proxy handler redirects the identified path and enumeration to the corresponding shell extension handler on the local machine . In still another of these embodiments the corresponding shell extension handler on the local machine identifies a drop action based on the path and the enumeration of dragged files and the value is returned via the shell extension proxy handler to the shell . In yet another of these embodiments when Drop is called the shell extension proxy handler redirects the path the drop action and the enumeration of dragged files to the corresponding shell extension handler which requests each file from the shell extension proxy handler and performs the drop action.

In one embodiment the shell initializes a shell extension proxy handler that provides icons customized on a file by file basis for display in a shell . In another embodiment the shell extension proxy handler executes logic to determine which icon to display. In still another embodiment the shell extension proxy handler executes logic to generate an icon for display. In yet another embodiment the shell extension proxy handler directs the shell to call Extract to get icon handles thereby bypassing the shell s icon cache which is keyed on filename icon index .

In one embodiment the shell uses an IExtractIcon interface to retrieve an icon for the object. In another embodiment the shell calls a function such as IExtractIcon GetIconLocation specifying flags that identify without limitation the following i whether an icon can be extracted asynchronously ii information for a fallback icon to display while waiting for a slow icon extraction to complete iii whether an icon is for use with a shell folder or with a shortcut and iv whether an icon represents a file in the opened or closed state. In still another embodiment the shell extension proxy handler redirects a call to a GeticonLocation function to a corresponding shell extension handler on the local machine via the shell extension invoker with an input parameter file system path from the remote machine translated to a corresponding file system path on the local machine .

In one embodiment the shell extension proxy handler receives a return value generated by a corresponding shell extension handler. In another embodiment the shell extension proxy handler returns to the shell a filename and an icon index identifying the icon as well as flags identifying without limitation the following i whether the shell should cache the icon ii whether a specified filename icon index pair contain the location of an icon in a file iii whether all objects of this file class have the same icon and hence whether the shell extension could be replaced by a static icon definition iv whether the shell should create a document icon using the returned icon and v whether the shell should further modify the identified icon. In still another embodiment the corresponding shell extension handler returns a valid icon path and the shell extension proxy handler translates the path from a file system path on the local machine to a file system path on the remote machine and returns the translated flag to the shell . In yet another embodiment the corresponding shell extension handler returns an indication that all objects of this file class use the same icon which the shell extension proxy handler uses when responding future calls for objects of this class.

In some embodiments where a specified filename icon index pair received from the shell extension proxy handler do not contain the location of an icon in a file the shell may pass the returned values in a call to an Extract function to get the icon handle. In one of these embodiments when the Extract function is called the shell extension proxy handler passes the request to the shell extension invoker which calls the corresponding shell extension handler. In another of these embodiments if the client handler returns valid icon handles the icons are read marshaled and transmitted to the shell extension proxy handler where they are cached and turned into icons in memory. In still another of these embodiments the handles to the in memory icons are returned to the shell . In yet another of these embodiments if the corresponding shell extension handler returns S FALSE instead of returning the requested icon handles the shell extension proxy handler notifies the shell to use the Extracticon function on the filename index returned from the original GeticonLocation call.

In other embodiments where the shell should further modify the identified icon the shell may add a stamp to the icon such as a VISTA UAC shield icon in MICROSOFT WINDOWS environments . In still other embodiments where the shell should not further modify the identified icon the shell may use a default icon instead. In still even other embodiments where a file name identifying an icon is returned the shell attempts to load the icon from its cache. In one of these embodiments however a no cache flag defeats this attempt and the shell will call an Extract function. In yet other embodiments where the GeticonLocation function provides some but not all of the information associated with an icon the shell calls the Extract function passing in the returned filename icon index to retrieve the icon s handle requesting both small and large icon handles passing in a parameter indicating the desired size of both. In one of these embodiments the call to this function may return S FALSE if the original filename icon index is valid in this case the shell uses those values to extract the icon. In further embodiments a shell extension invoker determines when a corresponding shell extension handler references an icon located in a file on the local machine extracts the icon gives it a unique identity for future reference and sends it to the shell extension proxy handler which can cache it for future use and return a reference to it as a filename icon index or by causing the shell to call Extract . In one of these embodiments this allows the caching of icons across connections and sessions.

In one embodiment a shell initializes a shell extension proxy handler providing additional functionality for a data object such as a file class object a mounted drive object or a control panel applet object. In another embodiment a shell receives an identification of a user request for access to functionality provided by a shell extension for a property sheet associated with a data object such as a file class object a mounted drive object or a control panel applet object. In still another embodiment the shell calls a function such as IShellExtInit Initialize passing in a data object containing the object s name in CF HDROP format and a PIDL referencing the folder containing the object. In still another embodiment for property sheets associated with a file class object or a mounted drive object the shell calls an AddPages function to allow a shell extension handler to add a page to the property sheet. In still even another embodiment for property sheets associated with a control panel applet object the shell calls a ReplacePage function to allow a shell extension handler to replace a page. In yet another embodiment for property sheets associated with a mounted drive object the data object passed to an Initialize method may be in CFSTR MOUNTEDVOLUME format rather than CF HDROP format in cases where the volume is mounted to a folder rather than a drive letter .

In one embodiment a property sheet page is a modeless dialog box which means it can execute logic and produce graphics output. In another embodiment the shell extension proxy handler in communication with the shell extension invoker inserts a proxy property sheet page in a display of the property sheet on the remote machine . In still another embodiment the shell extension proxy handler in communication with the shell extension invoker ensures that a proxy property sheet page received from the local machine is displayed above a display of the property sheet on the remote machine .

In one embodiment a shell initializes a shell extension proxy handler providing additional functionality for an image associated with a data object for example the functionality may include a customized thumbnail image. In another embodiment when a shell receives a request for access to the customized thumbnail image if the shell does not have a copy of the thumbnail image in a cache on the remote machine the shell calls a function such as IThumbnailProvider GetThumbnail which accepts a maximum thumbnail size and returns a HBITMAP and a parameter describing the alpha channel or lack of it in the returned bitmap.

In one embodiment the shell extension proxy handler redirects the call to the IThumbnailProvider GetThumbnail function to the shell extension invoker . In another embodiment the shell extension invoker may execute a corresponding shell extension handler on the local machine in process. In still another embodiment the shell extension invoker may execute a corresponding shell extension handler on the local machine out of process. In yet another embodiment the corresponding shell extension handler on the local machine returns a thumbnail bitmap which the shell extension invoker forwards to the shell extension proxy handler .

In one embodiment the shell extension invoker forwards the thumbnail bitmap to the shell extension proxy handler as a streamed possibly compressed bitmap. In another embodiment the shell extension invoker stores the thumbnail bitmap as a file on the client and returns a reference to the file to the shell extension proxy handler . In still another embodiment the shell extension proxy handler maintains a cache of received thumbnail bitmaps. In yet another embodiment the shell extension proxy handler forwards the received thumbnail bitmap to the shell .

In one embodiment a shell initializes a shell extension proxy handler providing additional functionality for a display of dynamic information. In another embodiment for example a shell extension proxy handler may provide additional dynamic information for use in infotips the small tooltip like windows that appear when a user hovers a pointing device over certain shell objects especially many files and folders . In still another embodiment such a shell extension proxy handler may make use of a portion of a file to generate the infotip data for that file. In still even another embodiment such a shell extension handler may make use of data or metadata for an object in order to generate infotip data. In yet another embodiment policies or other mitigation mechanisms as described above may be implemented to control which handler instances are integrated.

In one embodiment a shell receives a request for access to a customized infotip associated with a file and calls a function in a shell extension proxy handler such as IQueryInfo GetInfoTip to retrieve the customized infotip. In another embodiment at least one input flag specifies a variation of a request e.g. requesting the name of the item or when the item is a shortcut requesting the infotip for the shortcut or the target . In still another embodiment the shell extension proxy handler redirects the request to the shell extension invoker which redirects the request to a corresponding shell extension handler. In still even another embodiment the shell extension invoker receives text for display as an infotip and forwards the received text to the shell extension proxy handler . In yet another embodiment the shell extension proxy handler returns the infotip text in a buffer allocated in a memory space of the shell using a CoTaskMemAlloc function.

In one embodiment a shell initializes a shell extension proxy handler providing additional functionality for a display of a column of data. In another embodiment the shell extension proxy handler is a global object called every time the shell receives a request to display data according to a Details view. In still another embodiment the shell extension handler may open and read the entire file for which column data is being requested. In still even another embodiment the shell extension proxy handler may only need to read a small portion of the file or of the file metadata.

In one embodiment a shell receives a request for access to a customized display of data in a column format. In another embodiment the shell uses an interface such as IColumnProvider in responding to the request. In still another embodiment the shell calls a function such as Initialize to specify the folder that is about to be displayed. In still even another embodiment the shell calls a function such as GetColumnInfo to retrieve a column identifier and at least one characteristic of the column.

In one embodiment the shell extension proxy handler receives a call to an Initialize function from the shell and redirects the call to the shell extension invoker which forwards the call to a corresponding shell extension handler on the local machine . In another embodiment the corresponding shell extension handler returns a structure that identifies the column a title and description the type of data as a VARIANT type the list view format and a set of flags for the default column state including but not limited to the following String integer date shown in the shell Slow to compute so data is retrieved by the shell asynchronously displayed in the More . . . dialog rather than the shortcut menu Hidden from the UI. In still another embodiment the corresponding shell extension handler returns an identification of the customized column including a FMTID PID pair where FMTID is a property set format identifier defined as a GUID and where PID is a DWORD specifying the column s property identifier.

In one embodiment the shell extension proxy handler receives a call to a GetColumnInfo function from the shell and redirects the call to the shell extension invoker which forwards the call to a corresponding shell extension handler on the local machine . In another embodiment the corresponding shell extension handler retrieves data to display in a column for each file called. In still another embodiment the shell extension proxy handler receives a call to a GetltemData function from the shell and redirects the call to the shell extension invoker which forwards the call to a corresponding shell extension handler on the local machine .

In one embodiment the shell extension invoker receives the retrieved column data from the corresponding shell extension handler and forwards the retrieved data to the shell extension proxy handler . In another embodiment the shell extension proxy handler provides the retrieved data to the shell . In still another embodiment the shell extension proxy handler caches the received data.

In one embodiment a shell receives a request for access to a shell extension proxy handler that prevents folders from being copied moved deleted or renamed. In another embodiment the shell extension proxy handler is a global object called for every request to copy move delete or rename a folder and approves or vetoes the request.

In one embodiment a shell receives a request to copy move delete or rename folder. In another embodiment the shell calls a function such as CopyCallBack to specify the source and destination folders and their attributes the operation to be performed various flags that affect the operation and a HWND that the shell extension proxy handler may use as the parent window for any UI elements. In still another embodiment the shell extension proxy handler redirects the call to the shell extension invoker which forwards the call to a corresponding shell extension handler on the local machine . In yet another embodiment the corresponding shell extension handler returns a value indicating whether the shell should allow the operation prevent this operation but allow other operations that have been approved to continue or cancel both the current operation and any pending approved operations.

In one embodiment the shell extension invoker receives the value from the corresponding shell extension handler and forwards the received value to the shell extension proxy handler . In another embodiment the shell extension proxy handler provides the received value to the shell . In still another embodiment the shell extension proxy handler caches the received value.

In one embodiment the shell initializes a shell extension handler implementing an interface such as IShellIconOverlayIdentifier. In another embodiment a shell receives a request for access to a shell extension handler that provides a customized icon overlay.

In one embodiment the shell calls a function such as GetOverlayInfo to request a location of an icon overlay as a file path icon index pair.

In another embodiment when more than one overlay is requested for a particular file and the shell cannot resolve the conflict using its own internal rules the shell calls a function such as GetPriority to determine an icon overlay s priority for example this may be a number from 0 100 with 100 being lowest where the highest priority overlay is the one used. In still another embodiment before painting an object s icon the shell passes the object name to IsMemberOf to request a value indicating whether or not to apply an identified overlay to an icon associated with a data object. In yet another embodiment the shell calls a function such as GetOverlayInfo to request the overlay s filename icon index in order to access the overly in the system image list.

In one embodiment the shell extension proxy handler receives a call from the shell to an interface such as IShellIconOverlayIdentifier or to a function such as GetOverlayInfo GetPriority or IsMemberOf . In another embodiment the shell extension proxy handler redirects the call to the shell extension invoker which forwards the call to a corresponding shell extension handler on the local machine . In still another embodiment the shell extension invoker receives a result from the corresponding shell extension handler and forwards the result to the shell extension proxy handler . In some embodiments the shell extension proxy handler caches the result received from the shell extension invoker .

In one embodiment an icon overlay identified by the corresponding shell extension handler on the local machine is extracted and marshalled back to the shell extension proxy handler which stores it in a local icon file and returns the file path to the shell . In another embodiment the shell extension proxy handler translates a path name on the local machine identified by the corresponding shell extension handler and the shell extension proxy handler forwards the translated path name to the shell . In still another embodiment the shell extension proxy handler receives an identification of a priority associated with an icon overlay and forwards the identification to the shell . In yet another embodiment the shell extension proxy handler receives a value indicating whether or not to apply an identified overlay to an icon associated with a data object and forwards the value to the shell .

In one embodiment a shell initializes a shell extension proxy handler providing additional customized searching functionality. In another embodiment the shell initializes a static shell extension proxy handler . In still another embodiment the shell initializes a dynamic shell extension proxy handler . In still even another embodiment the shell initializes a shell extension proxy handler providing static DHTML documents that appear in the Start Search menu entry when selected the documents cause a browser to be launched with the browser bar opened to the search document and an optional document may be displayed to the right of the browser bar .

Referring now to a block diagram depicts one embodiment of a system for providing by a remote machine access to functionality of a context menu associated with a resource executing on a local machine. In brief overview the system includes a local machine a local agent a resource provided by the local machine a context menu associated with the resource the context menu including a context menu item a remote machine a remote agent a remote registry including at least one registry entry a shell on the remote machine and a proxy handler e.g. dynamic verb proxy handler or static verb proxy handler .

In one embodiment a context menu is a menu that is displayed when a user right clicks a file folder or a collection of files or folders a blank area of either the desktop a folder view in Explorer or other data object displayed in a desktop environment. In another embodiment a shell on a machine provides several default menu items in a context menu. In still another embodiment a resource may modify a default context menu to include additional context menu items. In still another embodiment a shell extension handler may modify a default context menu to include additional context menu items. In yet another embodiment whether a context menu item is displayed may depend on the particular object selected or on its attributes.

In one embodiment a context menu item is associated with a resource . In another embodiment the context menu item displays a description of a command that when executed provides access to functionality associated with or provided by the resource . In still another embodiment the command is referred to as a verb. In still even another embodiment a verb is an action that can be invoked on a file object. In still another embodiment a verb may be static i.e. valid for all instances of a particular file type or dynamic it might only apply to some of the files of a particular file type . In yet another embodiment a modifiable default verb is associated with a context menu item and is launched when a user double clicks on a file in the shell or when a non executable file is launched.

In one embodiment a PseudoProgID may register static verbs that apply to all files that it handles. In another embodiment these verbs include definitions of how to invoke the logic of the verb as a command line app or via DDE or a COM interface . In still another embodiment the shell defines some standard canonical verbs and PseudoProgID registry keys can define static supplemental verbs in MICROSOFT WINDOWS XP or later. In yet another embodiment a PseudoProgID registry key may also define ContextMenuHandlers COM components that provide dynamic verbs i.e. verbs that depend on the particular file s and may have or depend upon additional state .

In one embodiment a shell verb underlies a context menu item. In another embodiment a context menu item is associated with a default verb. In still another embodiment the default verb is invoked by the shell when a non executable file is launched including when the user double clicks on it in Explorer . In some embodiments since shell verbs underlie context menu items methods for integrating context menu items across machines include methods of integrating functionality provided by shell verbs. In one of these embodiments methods for integrating the underlying verbs will also provide for integration of associations between the verbs and a type of file.

In one embodiment each context menu item represents a verb whether static or dynamic canonical or supplemental named or anonymous that may be applied to a data object. In another embodiment the shell constructs the context menu for a data object by including the appropriate subset of canonical verbs any supplemental verbs which define a corresponding static menu item and any dynamic menu items corresponding to dynamic verbs that are provided by an applicable ContextMenuHandler.

Referring now to and in greater detail the remote agent executing on the remote machine receives information associated with the context menu item . In one embodiment the information is associated with a verb definition which itself is associated with the context menu item . The context menu is included within a context menu and associated with a resource provided by a local machine . The remote agent modifies at least one registry entry on the remote machine responsive to the received information. In one embodiment a context menu item is associated with a static verb. In another embodiment a context menu item is defined statically in the registry via the associated information. In still another embodiment the context menu item appears in a context menu dynamically when the context menu is constructed by the shell .

In one embodiment the remote agent includes a receiver receiving an identification of the context menu item . In one embodiment the local agent transmits to the remote agent information associated with a static verb. In another embodiment this information includes a PseudoProgID to which the verb definition applies. In still another embodiment the local agent sends the verb name. In yet another embodiment the local agent sends an identification of the verb handler.

In one embodiment for a static verb the information includes an identification of one of the command line DDE target or COM server depending which one has been used to define the static verb. In another embodiment for a dynamic verb the information includes a GUID of the ContextMenuHandler that defines and implements a dynamic verb. In still another embodiment the remote agent may independently choose a method for each of static and dynamic verbs. In yet another embodiment responsive to the received information the remote agent will install and or deploy and or configure at least one proxy handlers.

In some embodiments the remote agent includes a receiver receiving an identification of a command associated with the context menu item . In one of these embodiments the remote agent modifies a registry entry on the remote machine to include the identification of the command associated with the context menu item . In another of these embodiments the command refers to a method used to implement a verb invocation. In still another of these embodiments a command is itself a method that defines how a static verb invocation is handled. In still even another of these embodiments a DDE command defines how a static verb invocation is handled. In still even another of these embodiments a handler defined by a COM interface defines how a static verb invocation is handled. In yet another of these embodiments a COM object implementing a COM interface defines how a dynamic verb invocation is handled.

In one embodiment the remote agent may receive an identification of a command on the local machine that is associated with a verb underlying the context menu item . In another embodiment responsive to receiving the identification of the command the remote agent configures a registry entry on the remote machine to define a second command for that verb. In still another embodiment the second command defines an invocation of the proxy handler for that verb definition. In yet another embodiment the received command refers to a handler on the local machine which the remote machine may or may not have.

In another of these embodiments the remote agent installs a type of proxy handler e.g. either at least one dynamic verb proxy handler or at least one static verb proxy handler or both associated with the identified command. In other embodiments a database accessed by the remote agent enumerates a plurality of proxy handlers e.g. dynamic verb proxy handler or static verb proxy handler . In one of these embodiments the database maps the proxy handler instance to the corresponding local machine verb or local machine verb invocation method handler. In further embodiments the remote agent monitors the remote desktop environment communicates with other components of system and transmits data to the local machine as described previously in connection with .

In one embodiment the remote agent is a presentation layer protocol agent. In another embodiment the remote agent is a presentation layer protocol agent providing additional functionality as described herein. In still another embodiment the remote agent provides different functionality from that of a presentation layer protocol agent.

In some embodiments the remote agent includes a verb publishing agent. In one of these embodiments the verb publishing agent receives data from a client verb monitor which may be provided as a component of the local agent . In another of these embodiments the verb publishing agent modifies a registry on the remote machine . In still another of these embodiments the verb publishing agent notifies a shell executing on the remote machine of the modification to the registry on the remote machine . In still even another of these embodiments the verb publishing agent on the remote machine removes a context menu item and its associated data upon termination of a connection with the local machine . In another embodiment the verb publishing agent maps a static verb associated with a resource on the local machine to a remote desktop static verbs and maps a dynamic verb associated with a resource on the local machine to a remote desktop dynamic verb. In yet another embodiment the verb publishing agent maps a static verb associated with a resource on the local machine to a dynamic verb associated with a resource on the remote machine .

In one embodiment a verb associated with a PseudoProgID registry key identified on the local machine is added to a registry on the remote machine . In another embodiment at least one verb includes the default verb along with static and dynamic verb definitions and an identification of at least one verb handler for each verb instance as well as any static verb menu item strings. In still another embodiment a plurality of verbs are associated with the PseudoProgID.

In one embodiment a context menu or shortcut menu e.g. remote context menu and local context menu is displayed when a user right clicks on one or more shell object. In another embodiment each context menu item e.g. item item represents a verb that may be applied to the shell object. In still another embodiment a verb is an action that can be invoked on the file object. In still even another embodiment verbs may be static for example a static verb may be valid for all instances of a particular file object type.

In one embodiment a verb may be dynamic for example a dynamic verb may only apply to some of the file objects of a particular file object type. In another embodiment dynamic verbs may utilize the assistance of a shell extension handler which is a COM Component Object Model component that runs in process to the shell. In still another embodiment this handler provides the means to display different context menus for file objects of the same type. In yet another embodiment a verb may be invoked when the user double clicks on a file object programmatically or when a non executable file is launched.

A proxy handler e.g. dynamic verb proxy handler or static verb proxy handler associated with a context menu handler is installed by the remote agent . In one embodiment the proxy handler is indirectly associated with the context menu item . In another embodiment the proxy handler is associated with a PseudoProgID. In some embodiments a verb invoker e.g. dynamic verb invoker or static verb invoker executes on the local machine . In one of these embodiments the proxy handler e.g. dynamic verb proxy handler or static verb proxy handler includes a transceiver for receiving a request for execution of a command associated with the context menu item and redirecting the request to the verb invoker e.g. dynamic verb invoker or static verb invoker for execution on the local machine . In one embodiment the command refers to the invocation of the verb and is required for both dynamic and static verb proxy handlers. In another embodiment the command refers to an API call used typically for dynamic verbs as part of the context menu construction process.

In one embodiment the proxy handler e.g. dynamic verb proxy handler or static verb proxy handler may include a transceiver receiving a result of executing the command on the local machine and providing the result to the shell on the remote machine. In another embodiment the verb invoker e.g. dynamic verb invoker or static verb invoker may integrate the result of the execution of the command into the local display of the desktop environment providing integrated access both to resources provided by the remote machine and resources provided by the local machine . In another embodiment the shell may integrate the result of the execution of the command into a display of a desktop environment on the remote machine providing integrated access both to resources provided by the remote machine and to resources provided by the local machine . In some embodiments a user of a local machine views a display of a context menu integrating menu items associated with resources from both the local machine and the remote machine . In other embodiments for example a first context menu item is associated with an application provided by a remote machine and a second context menu item associated with an application provided by the local machine and providing additional functionality. In further embodiments each context menu item in a context menu is associated with an application provided by a local machine . In some embodiments a user interacts with a displayed context menu item to request access to functionality provided by an associated resource.

A shell on the remote machine receives from the remote agent a request for a display of a context menu including the context menu item the request is generated on the local machine . In some embodiments the shell generates graphical data representing the requested context menu including the context menu item responsive to the modified at least one registry entry . In one of these embodiments the proxy handler is a static verb proxy handler . In some embodiments the remote agent is a presentation layer protocol agent receiving a notification of the user interaction from the local machine . In one of these embodiments the shell receives the notification and identifies the interaction as a request for a context menu.

In one embodiment a static verb proxy handler is a target for static verbs integrated by the remote agent or by a verb publishing agent on behalf of at least one PseudoProgID. In another embodiment the static verb proxy handler implements at least one verb invocation interface command line DDE or DropTarget . In still another embodiment the static verb proxy handler proxies a verb invocation request to a static verb invoker on the local machine . In still even another embodiment the static verb proxy handler transmits to the static verb invoker an identification of an invoked PseudoProgID. In still another embodiment a verb or verb handler associated with a specific PseudoProgID instance is invoked. In yet another embodiment the static verb proxy handler communicates with a file system path mapping component during the proxied invocation to map a path on the remote machine to a path to a file system object visible to the local machine .

In one embodiment a static verb invoker handles proxied static verb invocation requests originating from the remote machine . In another embodiment the static verb invoker receives an identification of at least one shell object and data for identifying a verb handler on the local machine . In another embodiment the static verb invoker communicates with a file system path mapping component to map a path on the remote machine to a path to a file system object visible to the local machine . In some embodiments there is one instance of the static verb invoker . In other embodiments there is a plurality of static verb invokers .

In other embodiments the shell i receives from the proxy handler data associated with the context menu item and ii generates graphical data representing the requested context menu including the context menu item responsive to the received data associated with the context menu item . In one of these embodiments the remote agent installed a dynamic verb proxy handler . In another of these embodiments the proxy handler includes a transceiver receiving from the shell on the remote machine a request for data associated with the context menu and transmitting to the shell an identification of the context menu item

In one embodiment a dynamic verb proxy handler is a target for dynamic verbs integrated by the remote agent or by a verb publishing agent on behalf of at least one PseudoProgID. In another embodiment the dynamic verb proxy handler implements a context menu handler COM interfaces. In still another embodiment the dynamic verb proxy handler proxies a verb invocation request to a dynamic verb invoker on the local machine . In still even another embodiment the dynamic verb proxy handler transmits to the dynamic verb invoker an identification of an invoked PseudoProgID. In still another embodiment the dynamic verb proxy handler communicates with a file system path mapping component during the proxied invocation to map a path on the remote machine to a path to a file system object visible to the local machine . In yet another embodiment the dynamic verb proxy handler communicates with a window mapping component during a proxied invocation to map an identification of a window on the remote machine to a window on the local machine .

In one embodiment a dynamic verb invoker handles proxied dynamic verb invocation requests originating from the dynamic verb proxy handler on the remote machine . In some embodiments there is one instance of the dynamic verb invoker . In one embodiment the dynamic verb invoker acts as a ContextMenuHandler host hosting the ContextMenuHandler DLLs on the local machine executing the proxied requests originating on the remote machine and returning the results back to the remote machine . In other embodiments there is a plurality of dynamic verb invokers .

In one embodiment a 1 1 mapping exists between a verb proxy handler e.g. dynamic verb proxy handler or static verb proxy handler and a target verb handler. In another embodiment the target verb handler is a handler executable file on the local machine . In still another embodiment the target verb handler is a handler executable file and an identification of at least one associated parameter. In still even another embodiment there is a plurality of verb proxy handlers . In yet another embodiment a first verb proxy handler may be a copy of a binary file used by a second verb proxy handler the first verb proxy handler and the second verb handler having different names. In some embodiments the mapping exists on the local machine. In other embodiments the mapping exists on the remote machine.

In one embodiment a 1 N mapping exists between a verb proxy handler and a plurality of target verb handlers. In another embodiment the mapping target is identified by a PseudoProgID verb tuple. In still another embodiment a verb proxy handler proxies to multiple target verb handlers having the same form. In still even another embodiment where a 1 N mapping exists the target verb handler is a handler executable file on the local machine . In yet another embodiment any form of static verb proxy handler can be used to proxy to any form of static verb handler on the local machine . In some embodiments the mapping exists on the local machine. In other embodiments the mapping exists on the remote machine.

In one embodiment a 1 1 mapping is provided between a ContextMenuHandler proxy handler on the remote machine and a ContextMenuHandler dynamic verb handler on the local machine . In another embodiment a 1 1 mapping is provided between a DropTarget proxy handler on the remote machine and a static verb handler on the local machine for a given PseudoProgID verb pair. In still another embodiment a 1 1 mapping is provided between a command line or DDE command static verb proxy handler and a command line or DDE command static verb invocation handler on the local machine. In yet another embodiment a 1 N mapping is provided between a command line or DDE command static verb proxy handler which maps to more than one command line or DDE command static verb handlers on the local machine .

A local agent on the local machine receives from the remote agent the generated graphical data and integrates the generated graphical data into a local display of a desktop environment providing integrated access both to resources provided by the remote machine and resources provided by the local machine . In some embodiments the local agent identifies a verb definition associated with a resource provided by the local machine for integration into the desktop environment providing integrated access both to resources provided by the remote machine and resources provided by the local machine . In other embodiments the local agent publishes the identified context menu item . For example the local agent may publish the identified context menu to the remote agent . In still other embodiments the local agent transmits to the remote agent information associated with the context menu item

In one embodiment the local agent is a presentation layer protocol client. In another embodiment the local agent is a presentation layer protocol client providing additional functionality as described herein. In still another embodiment the local agent provides different functionality from that of a presentation layer protocol client.

In one embodiment the local agent includes a source verb monitor. In another embodiment the source verb monitor identifies at least one file type associated with a verb associated with a resource including a context menu item that is included in a local display of the integrated desktop environment. In still another embodiment the source verb monitor monitors at least one file type associated with a verb associated with a resource including a context menu item that is included in a local display of the integrated desktop environment.

In some embodiments the local agent includes a verb publishing handler. In one of these embodiments the verb publishing handler receives data from a source verb monitor which may be provided as a component of the local agent . In another of these embodiments the verb publishing handler transmits the received data to a remote agent . In other embodiments however the remote agent includes the verb publishing handler.

In one embodiment the identified verb is static. In still another embodiment the identified verb is identified via an identification of a pre defined shell object. In still even another embodiment the identified verb is identified via an identification of a PerceivedFileType. In yet another embodiment the identified verb is identified via an enumeration of at least one PseudoProgID handling the verb.

In one embodiment a dynamic verb and its associated context menu item may also be provided on demand by a ContextMenuHandler shell extension. In another embodiment the shell extension handler is an in process COM server that implements the IContextMenu COM interface. In still another embodiment context menu items may be traditional menu entries drawn by the system once defined by the handler or may be owner drawn by the handler as necessary. In some embodiments a ContextMenuHandler whose GUID is is bound to by adding a registry key to a registry. In one of these embodiments the registry key has the form HKCR shellex ContextMenuHandlers .

In some embodiments a ContextMenuHandler proxy handler COM server which may be a dynamically linked library is created. In one of these embodiments as dynamic verb proxy handlers i.e. ContextMenuHandlers are integrated into the registry on the remote machine a new copy of the ContextMenuHandler proxy handler executable is created each time a new ContextMenuHandler GUID from a local machine is identified. In still another of these embodiments the new copy is given a unique fully qualified filename and a mapping maintained from the new filename to the GUID on the local machine . In still even another of these embodiments the dynamic verb handler identifies the new copy of the COM server executable via a new remote desktop GUID. In some embodiments when executed the proxy handler COM server analyzes its own file name to identify a GUID identifying a data object on the local machine with which the shell extension proxy handler and the proxy handler COM server are associated.

In one embodiment a DropTarget proxy handler COM server DLL or EXE is created. In another embodiment when a static verb is integrated into a registry on the remote machine a copy of the DropTarget proxy handler COM server executable is created each time a new PseudoProgID verb combination from the local machine is identified. In still another embodiment the copy is given a unique fully qualified filename and a mapping is maintained from the new filename to the PseudoProgID verb tuple for example a file database table data structure or embedded path element may store the mapping. In yet another embodiment a new GUID on the remote machine references the copy of the COM server executable. In some embodiments when executed the COM server inspects its own module filename and determines via the mapping which PseudoProgID verb tuple it is acting on behalf of.

Referring now to a flow diagram depicts an embodiment of a method for providing by a remote machine access to functionality of a context menu associated with a resource executing on a local machine . In brief overview the method includes receiving by a remote agent executing on a remote machine information associated with a context menu handler associated with a resource provided by a local machine block . The remote agent installs a proxy handler e.g. dynamic verb proxy handler or static verb proxy handler associated with the context menu handler responsive to the received information block . The remote agent modifies at least one registry entry on the remote machine responsive to the received information block . A shell on the remote machine receives from the remote agent a request for a display of a context menu including the context menu item wherein the request is generated on the local machine block . The shell on the remote machine generates graphical data representing the requested context menu responsive to the at least one modified registry entry block . The remote agent transmits to a local agent on the local machine the generated graphical data block . The local agent integrates the generated graphical data into a local display of a desktop environment providing integrated access both to resources provided by the remote machine and to resources provided by the local machine block .

In one embodiment shell context menu handling functionality provided by the local machine is integrated into a shell context menu provided by the remote machine . In another embodiment the context menu items and associated functionality handling provided by a resource are integrated into a desktop environment provided by the remote machine and made available within at least one shell context menu on the remote machine . In still another embodiment methods and functions provide integration for context menu verbs and for handling user requests for access to the functionality. In yet another embodiment the integration includes an integrated display of context menu items and access to integrated functionality such as the execution of applications identified directly and by file type association.

In one embodiment a context menu proxy handler integrates a display of a context menu item provided by a resource on a local machine in a context menu on a remote machine . In another embodiment the context menu proxy handler leverages functionality for mapping a file system object located on the remote machine to a file system object on the local machine . In some embodiments the context menu proxy handler integrates the display of the context menu item and associated functionality provided by the resource without requiring a modification to user interaction methods.

Referring now to and in greater detail a remote agent executing on a remote machine receives information associated with a context menu handler associated with a resource provided by a local machine block . In some embodiments the remote agent receives an identification of the context menu handler . In other embodiments the remote agent receives an identification of a default action associated with the context menu . In yet other embodiments the local agent identifies a context menu item associated with the resource provided by the local machine . In some other embodiments the remote agent receives an identification of the context menu item . In some embodiments the local agent identifies a context menu item associated with a resource provided by the local machine . In some of these embodiments the local agent may publish the identified context menu item

In one embodiment the local agent identifies information associated with a context menu item to transmit to the remote agent . In another embodiment the local agent accesses a registry on the local machine to identify the context menu item or its associated information.

In some embodiments as described above in connection with shell extension enumeration a local agent identifies a resource associated with a context menu handler. In one of these embodiments a local agent identifies the resource after completing a process of enumerating at least one shell extension handler. In another of these embodiments for each handler identified the local agent determines whether the identified handler is provided by one of the resources that is to be included in the display of the integrated full screen desktop. In other embodiments as described above in connection with shell extensions and file type association identification the local agent identifies at least one file type referencing a PseudoProgID or a ProgID. referenced by PseudoProgID or ProgID. In further embodiments the local agent transmits to the remote agent a graph of associations between nodes consisting of file types PseudoProgID verbs verb handler executables along with disparate attributes associated with each node.

In one embodiment the local agent identifies a file type associated with a verb or context menu handler associated with a resource included in an integrated desktop environment. In another embodiment the local agent identifies an association between an identified file type and a PseudoProgID to create a file type association for a context menu. In still another embodiment the local agent identifies a default ProgID.

In one embodiment the local agent identifies a static verb defined by a PsuedoProgID registry key in a registry on the local machine . In another embodiment the local agent retrieves from a registry on the local machine an enumeration of keys of the form HKCR shell where is the language independent name of the command. In still another embodiment a default verb is defined by the Default value of the shell key parent of the verb key above or if no default value is given there the default verb is open . In still even another embodiment for a registered resource the data is found under key HKCR Applications instead where is the executable name generally including the .exe or .dll extension but omitting path. In still another embodiment the verb definition registry key contains the menu item text if any and defines method s to invoke it including but not limited to the following an command line to execute a DDE conversation to launch with an application and a COM server GUID implementing an IDropTarget interface. In yet another embodiment this information is also used by a function such as a ShellExecute function when called to invoke the given static verb on a file associated with the given PseudoProgID registry key. Although this document describes the process in terms of HKCR in some embodiments the shell uses additional layers of registry keys to determine appropriate behavior for a particular object. These keys may define user customization for a file type system file associations system file perceived type associations and wildcard keys for the base class and all file system objects.

In one embodiment a local agent identifies a static verb associated with a context menu item included in an integrated desktop environment. In another embodiment the local agent retrieves an enumeration of a static verb and its associated context menu item from a registry on the local machine . In still another embodiment the local agent retrieves all registry keys having any of the following forms 

In one embodiment for an identified registry key the local agent gathers a default REG SZ value defining a context menu item string for that verb. In another embodiment for an identified registry key the local agent gathers an identification of a method for invoking the verb including without limitation i a command subkey whose default REG SZ value identifies a command line to use with 1 as the placeholder token for the target object s and additional parameters for canonical printer related verbs ii a ddeexec subkey whose default REG SZ value is a DDE command string to send and any additional subkeys identifying additional DDE parameters and iii a DropTarget subkey with a Clsid REG SZ value defining the GUID of the COM server that implements the verb using the IDropTarget interface and an executable for a COM server. In another embodiment the local agent identifies in a PseudoProgID grandparent registry key the parent of the shell key a Defaulticon subkey whose default REG SZ value specifies the default icon to use for files associated with this ProgID. In still another embodiment the local agent identifies in a PseudoProgID grandparent registry key the parent of the shell key a FriendlyTypeName value whose default value includes a string resource specification that is suitable for display to the user. In still even another embodiment the local agent identifies in a PseudoProgID grandparent registry key the parent of the shell key an InfoTip value identified as for FriendlyTypeName but for use as an info tip. In yet another embodiment the local agent identifies in a PseudoProgID grandparent registry key the parent of the shell key an EditFlags value that controls at least one aspect of the shell s handling of file types handled by this PseudoProgID. In further embodiments this process provides a list of defined PseudoProgID and for each one a list of static verbs and for each verb the definition of the executable handler s that implement them.

In one embodiment a local agent identifies a context menu handler associated with a context menu item included in an integrated desktop environment. In another embodiment the local agent retrieves an enumeration of the context menu handler from a registry on the local machine . In still another embodiment the local agent retrieves all registry keys having any of the following forms 

In still even another embodiment a subkey of an identified registry key defines a context menu handler. In still another embodiment a subkey has a name of the form . In yet another embodiment a subkey has an arbitrary name whose Default REG SZ value is of the form .

In one embodiment where the local agent identifies a DropTarget registry key given the GUID the handler executable can be looked up in the CLSID registry. In another embodiment a context menu handler may also specify a shellex MayChangeDefaultMenu subkey that indicates that the handler should be called even for the default action as the default verb may depend on the object targeted. In still another embodiment this process provides a list of defined PseudoProgIDs and for each one a list of ContextMenuHandlers and for each handler the GUID and executable handler that implements them.

In one embodiment a remote agent receives from a local agent information associated with a context menu item. In another embodiment the remote agent receives an identification of the context menu item.

The remote agent installs a proxy handler associated with the context menu handler responsive to the received information block .

In one embodiment the remote agent installs a static verb proxy handler associated with the context menu handler responsive to the received information. In one embodiment the remote agent virtually installs a shell extension proxy handler. In some embodiments the remote agent intercepts a request for an identification of a handler. In one of these embodiments the remote agent intercepts a request for a file in a file system identifying the handler. In another of these embodiments the remote agent intercepts a request for a registry key in a registry identifying the handler. In still another of these embodiments In still another of these embodiments the remote agent responds to an intercepted request with an identification of the shell extension proxy handler. In still even another of these embodiments a file system filter driver intercepts the request and responds with the identification of the shell extension proxy handler. In yet another of these embodiments a registry filter driver intercepts the request and responds with the identification of the shell extension proxy handler. In other embodiments the remote agent includes a hooking component hooking a request for an identification of a handler and responding with an identification of the shell extension proxy handler. In still other embodiments the remote agent intercepts a COM function call for an identification of a handler and responds with an identification of the shell extension proxy handler.

The remote agent modifies at least one registry entry on the remote machine responsive to the received information block .

A shell on the remote machine receives from the remote agent a request for a display of a context menu including the context menu item wherein the request is generated on the local machine block . The shell on the remote machine generates graphical data representing the requested context menu including the context menu item responsive to at least one modified registry entry block . The remote agent transmits to a local agent on the local machine the generated graphical data block . The local agent integrates the generated graphical data into a local display of a desktop environment providing integrated access both to resources provided by the remote machine and to resources provided by the local machine block .

In some embodiments the static verb proxy handler receives from the shell a request for execution of a command associated with the context menu item associated with the resource provided by the local machine . The static verb proxy handler redirects the request to a static verb invoker executing on the local machine and the static verb invoker executes the command. In one of these embodiments a result of executing the command on the local machine is integrated into a desktop environment of the remote machine .

In one embodiment a shell receives an identification of a user interaction with a displayed context menu and requests execution of an associated static verb. In another embodiment a local agent transmits to a remote agent the identification of the user interaction and the remote agent transmits the identification to the shell . In still another embodiment the shell retrieves data for display to the user from the modified registry entry. In yet another embodiment the shell transmits the identification to a static verb proxy handler for processing the static verb proxy handler identified to the shell in the modified registry entry.

In one embodiment a shell identifies a user interaction with a displayed context menu item. In another embodiment the shell calls a function such as IContextMenu InvokeCommand to initiate execution of the command associated with the displayed context menu item. In still another embodiment the static verb proxy handler provides the integration between the local machine and the remote machine . In another embodiment the static verb proxy handler identifies a verb handler on the local machine for which the request is intended. In still another embodiment the static verb proxy handler identifies a PseudoProgID verb combination triggered by a user interaction with an associated data object. In yet another embodiment the static verb proxy handler handles a request from the shell and proxies it to the identified verb handler on the local machine . In some embodiments the proxy verb handler identifies a GUID of a local machine verb handler either an IDropTarget instance .

In one embodiment the shell transmits the identification to an IDropTarget COM server instance implementing static verb proxy handler logic. In another embodiment the shell calls a function such as an IDropTarget Drop function on the specified instance of a static verb proxy handler COM server. In still another embodiment the static verb proxy handler COM server inspects its own fully qualified module filename and maps that to a PseudoProgID registry key on the local machine and to a verb that it is acting on behalf of In still even another embodiment the static verb proxy handler COM server transmits an identification of the mapped PseudoProgID registry the static verb and any additional data such as drop target parameters to a static verb invoker on the local machine . In some embodiments the file system path mapping component provides a mapping from a path on the remote machine to a path on the local machine .

In one embodiment a static verb invoker inspects a registry to determine how to invoke the given PseudoProgID verb action. In another embodiment the static verb invoker redirects the data received from the static verb proxy handler on the remote machine to a shell on the local machine . In still another embodiment the static verb invoker provides the requested functionality. In still even another embodiment the static verb invoker receives a notification from the shell that the shell has provided the requested functionality.

In some embodiments the static verb invoker notifies the static verb proxy handler that the functionality has been provided. In one of these embodiments the static verb proxy handler notifies the shell on the remote machine that the functionality has been provided. In another of these embodiments the static verb proxy handler integrates a display of output data generated by the providing of the functionality such as for example output data generated by an execution of an application into a desktop environment on the remote machine .

Referring now to a flow diagram depicts an embodiment of a method for providing by a remote machine access to functionality of a context menu associated with a resource executing on a local machine . In brief overview the method includes receiving by a remote agent executing on a remote machine information associated with a context menu handler associated with a resource provided by a local machine block . The remote agent installs a proxy handler associated with the context menu handler responsive to the received information block . A shell on the remote machine receives from the remote agent a request for a display of a context menu including in some embodiments the context menu item wherein the request is generated on the local machine block . The shell on the remote machine receives from the proxy handler data associated with the context menu block . The shell on the remote machine generates graphical data representing the requested context menu responsive to the data associated with the context menu item block . The remote agent transmits to a local agent on the local machine the generated graphical data block . The local agent integrates the generated graphical data into a local display of a desktop environment providing integrated access both to resources provided by the remote machine and to resources provided by the local machine block .

A remote agent executing on a remote machine receives information associated with a context menu handler associated with a resource provided by a local machine block . In some embodiments the remote agent receives an identification of a context menu item . In other embodiments the remote agent receives an identification of a command associated with the context menu item . In yet another embodiment the remote agent receives an identification of a default action associated with a PseudoProgID. In some embodiments the local agent identifies a context menu item associated with a resource provided by the local machine . In some of these embodiments the local agent may publish the identified context menu item

The remote agent installs a proxy handler associated with the context menu handler responsive to the received information block . In some embodiments the remote agent installs a dynamic verb proxy handler associated with a PseudoProgID responsive to the received information. In other embodiments a shell uses an IShellExtInit COM interface and invokes an Initialize function to initialize interaction by a dynamic verb proxy handler with the object. In further embodiments the shell passes to the proxy handler information identifying a data object with which the user interacted. In one of these embodiments the shell passes to the dynamic verb proxy handler an identification of a folder. In another of these embodiments the shell passes to the dynamic verb proxy handler an identification of at least one file object.

In one embodiment the remote agent virtually installs a shell extension proxy handler. In some embodiments the remote agent intercepts a request for an identification of a handler. In one of these embodiments the remote agent intercepts a request for a file in a file system identifying the handler. In another of these embodiments the remote agent intercepts a request for a registry key in a registry identifying the handler. In still another of these embodiments In still another of these embodiments the remote agent responds to an intercepted request with an identification of the shell extension proxy handler. In still even another of these embodiments a file system filter driver intercepts the request and responds with the identification of the shell extension proxy handler. In yet another of these embodiments a registry filter driver intercepts the request and responds with the identification of the shell extension proxy handler. In other embodiments the remote agent includes a hooking component hooking a request for an identification of a handler and responding with an identification of the shell extension proxy handler. In still other embodiments the remote agent intercepts a COM function call for an identification of a handler and responds with an identification of the shell extension proxy handler.

A shell on the remote machine receives from the remote agent a request for a display of a context menu including in some embodiments the context menu item block . The shell on the remote machine receives from the proxy handler data associated with the context menu block .

In one embodiment the dynamic verb proxy handler receives the identification of the user interaction with the object. In another embodiment the dynamic verb proxy handler receives an identification of the object. In still another embodiment the dynamic verb proxy handler identifies the object responsive to the received notification. In yet another embodiment the dynamic verb proxy handler determines whether to provide a menu item for this interaction responsive to the identification of the object.

In one embodiment the shell uses an IContextMenu interface to invoke a QueryContextMenu function. In another embodiment the shell provides a handle to a context menu being built and at least one other parameter associated with the context menu. In still another embodiment the context menu proxy handler adds at least one menu item to the context menu and reports back information related to the items that were added. In yet another embodiment the context menu proxy handler can add arbitrary menu items including submenus and owner drawn items .

In some embodiments the shell calls a function such as IContextMenu GetCommandString to retrieve data associated with the displayed context menu item. In one of these embodiments for example the shell may retrieve text for display in a status bar such as a fly by help string. In another of these embodiments the shell may retrieve an identification of a verb associated with the context menu item. In still another of these embodiments the shell identifies a window associated with the displayed menu item.

In other embodiments the shell calls a COM function provided by the dynamic context menu handler such as IContextMenu3 HandleMenuMsg2 to handle windows message associated with the displayed context menu item. In one of these embodiments the shell processes a message such as WM MEASUREITEM which is used to request the current size of the owner drawn menu item. In another of these embodiments the shell processes a message such as WM DRAWITEM which is used to draw the owner drawn item. In still another of these embodiments the shell processes a message such as WM MENUCHAR which is used to handle owner drawn menu accelerator keys. In yet another of these embodiments the shell processes a message such as WM INITMENUPOPUP.

The shell on the remote machine generates graphical data representing the requested context menu and in some embodiments the context menu item responsive to the data associated with the context menu block .

In one embodiment the shell generates a context menu associated with a resource provided by the local machine . In another embodiment the shell identifies a dynamic verb proxy handler associated with the context menu for example the shell may query a registry to determine whether a PsuedoProgID registry key associated with the resource identifies a dynamic verb proxy handler . In still another embodiment the shell initializes the dynamic verb proxy handler for use in the generation of the context menu.

In one embodiment the shell calls a function such as IShellExtInit Initialize identifying at least one item for which the shell is constructing the context menu. In another embodiment the dynamic verb proxy handler receives the request from the shell . In still another embodiment the dynamic verb proxy handler inspects its fully qualified pathname and uses that to determine the mapping to the GUID of the ContextMenuHandler on the local machine that it is acting on behalf of. In yet another embodiment the dynamic verb proxy handler redirects the request to the dynamic verb invoker on the local machine with the identified ContextMenuHandler GUID. In some embodiments the file system mapping components maps at least one path identifying the at least one item identified in the request by the shell to a path for an item on the local machine .

In one embodiment the dynamic verb invoker on the local machine hosts the ContextMenuHandler on the local machine . In another embodiment the dynamic verb invoker initializes the ContextMenuHandler. In still another embodiment the dynamic verb invoker redirects to the ContextMenuHandler the request received from the dynamic verb proxy handler . In still even another embodiment the ContextMenuHandler determines whether a menu item is associated with the at least one item identified by the shell . In yet another embodiment the ContextMenuHandler returns the identification if any to the shell .

In one embodiment the shell calls a function such as IContextMenu QueryContextMenu to pass the request with any associated data such as the ContextMenuHandler GUID to the dynamic verb invoker . In another embodiment the dynamic verb invoker constructs an empty context menu and passes the request to the ContextMenuHandler on the local machine . In still another embodiment the ContextMenuHandler on the local machine inserts the additional menu items into the empty context menu. In still even another embodiment the resulting menu items are enumerated by the dynamic verb invoker using GetMenuItem . In yet another embodiment the dynamic verb invoker redirects the enumeration to the dynamic verb proxy handler which inserts them into the context menu identified by the shell and returns an identification of the modification to the shell .

In one embodiment if owner drawn context menu items were specified then the shell calls IContextMenu3 HandleMenuMsg2 on the dynamic verb proxy handler with owner drawn messages. In another embodiment the dynamic verb proxy handler proxies the received request to the ContextMenuHandler on the local machine .

In one embodiment a window mapping component translates a window identification provided by the shell to identify a window associated with the at least one item. In another embodiment the window mapping component translates the window identification to an identification of a window on the local machine . In still another embodiment the translated window name is used by the ContextMenuHandler on the local machine to paint a portion of the window on the local machine with the owner drawn items over the top of the data sent by the remote machine . In other embodiments the ContextMenuHandler paints the menu items to an off screen buffer instead. In one of these embodiments the ContextMenuHandler transmits the results of painting the owner drawn item to the off screen surface to the dynamic verb proxy handler where the dynamic verb proxy handler can paint the owner drawn item on to the remote desktop context menu.

In one embodiment a user interaction with a context menu item includes the highlighting of the menu item. In another embodiment the shell calls a function such as IContextMenu GetCommandString to retrieve text for display as a fly over help message. In still another embodiment the dynamic verb proxy handler receives the function call and proxies the request to the ContextMenuHandler on the local machine .

In one embodiment a user interaction with a context menu item includes invoking a menu command. In another of these embodiments the shell calls a function such as IContextMenu InvokeCommand with an identification of a window object associated with the context menu and an identification of a window region for example by identifying screen coordinates in which the command was invoked. In still another embodiment the dynamic verb proxy handler receives the function call and proxies the request to the ContextMenuHandler on the local machine via the dynamic verb invoker . In still another embodiment the dynamic verb proxy handler receives the function call and proxies the request to the ContextMenuHandler on the local machine which creates a user interface in response to the menu command invocation. In some embodiments the execution of the invoked command occurs on the local machine . In one of these embodiments the results of execution of the invoked command are returned to the shell . In further embodiments verbs may be programmatically invoked.

The remote agent transmits to a local agent on the local machine the generated graphical data block . The local agent integrates the generated graphical data into a local display of a desktop environment providing integrated access both to resources provided by the remote machine and to resources provided by the local machine block . In other embodiments the proxy handler receives from the shell a request for execution of a command associated with a context menu item in the context menu associated with the resource provided by the local machine . The proxy handler redirects the request to a verb invoker executing on the local machine and the verb invoker executes the command. In one of these embodiments the dynamic verb invoker and the dynamic verb proxy handler provide substantially similar functionality for handling redirected requests for execution of context menu verbs as the functionality provided by the static verb invoker and the static verb proxy handler described above in connection with . In another of these embodiments a result of executing the command on the local machine is integrated into a desktop environment of the remote machine .

Referring now to a flow diagram depicts an embodiment of a method for providing by a local machine access to functionality of a context menu associated with a resource executing on a local machine . The method includes receiving by a local agent executing on a local machine information associated with a context menu handler associated with a resource provided by a local machine block . The local agent installs a proxy handler associated with the context menu handler responsive to the received information block . A shell on the remote machine receives from the remote agent a request for a display of a context menu including in some embodiments the context menu item wherein the request is generated on the local machine block . The shell on the remote machine receives from the proxy handler data associated with the context menu block . The shell on the remote machine generates graphical data representing the requested context menu responsive to the data associated with the context menu block . The local agent integrates the generated graphical data into a local display of a desktop environment providing integrated access both to resources provided by the remote machine and to resources provided by the local machine block .

In some embodiments the proxy handler receives from the shell a request for execution of a command associated with the context menu associated with the resource provided by the remote machine . The proxy handler redirects the request to a verb invoker executing on the remote machine . The shell in communication with the verb invoker executes the command.

In one embodiment a method includes receiving by a local agent executing on a local machine information associated with a context menu handler associated with a resource provided by a remote machine . The local agent installs a proxy handler associated with the context menu handler responsive to the received information. The local agent modifies at least one registry entry on the local machine responsive to the received information. A shell receives a request for a display of a context menu wherein the request is generated on the local machine . The shell generates graphical data representing the requested context menu responsive to the at least one modified registry entry. The local agent integrates the generated graphical data into a local display of a desktop environment providing integrated access both to resources provided by the remote machine and to resources provided by the local machine .

Referring now to a block diagram depicts one embodiment of a system for providing by a remote machine access to graphical data associated with a resource provided by a local machine. In brief overview the system includes a remote machine a remote agent a proxy icon handler a local machine a local agent a local icon handler an icon associated with a resource provided by the local machine a shell on the remote machine and a window displaying a plurality of icons in a remote desktop environment . In some embodiments the system visually integrates a subset of the system tray or systray icons present on a local machine into the system tray of the remote machine . A system tray window may include for example and without limitation such icons as a battery meter PC card status volume control task scheduler printer clock anti virus programs and any other icon.

In one embodiment an icon is animated. In another embodiment an icon may change appearance or be replaced by a second icon to reflect an underlying state of a resource associated with the icon. In still another embodiment a display of an icon that is obscured by a representation of a second data object may be included in the integrated display. In still even another embodiment a window displaying a plurality of icons may have a fixed size limiting the number of displayable icons. In yet another embodiment a modified version of an icon is displayed for example a version of the icon identifying a machine on which an associated resource executes may display.

In one embodiment the icon is an icon displayed in a system tray window. In another embodiment the icon is an icon displayed in a toolbar control. In still another embodiment the icon is an icon displayed in a system control area window. In yet another embodiment the icon is an icon displayed in a notification area window.

In one embodiment the icon provides functionality upon request by a user. In another embodiment the functionality provided is the execution of a resource associated with the icon for example a user may select the icon by selecting the display of the icon with a pointing device to request execution of a resource associated with the icon clicking on the icon . In still another embodiment the functionality is a display of a dynamically generated data object upon request by a user for example a user may position a pointing device cursor over a display of an icon hovering the mouse over the icon and view a dynamically generated window providing the user with information associated with the icon.

Referring now to and in greater detail the remote agent executing on a remote machine initializes a proxy icon handler . In some embodiments the remote agent initializes the proxy icon handler and communicates with various components of system as described previously in connection with . In one embodiment the remote agent includes a transmitter transmitting to the local agent a z order entry for the window displaying the plurality of icons.

The proxy icon handler includes a transceiver receiving from an icon handler on a local machine data associated with an icon associated with a resource provided by the local machine . The proxy icon handler in communication with a shell on the remote machine may modify a window displaying a plurality of icons in a remote desktop environment wherein the plurality of icons includes at least one icon associated with a resource provided by the remote machine and includes the icon associated with the resource provided by the local machine .

In some embodiments the proxy icon handler includes a transceiver receiving a request for access to the resource provided by the local machine associated with the icon and redirecting the request to the icon handler executing on the local machine . In one embodiment the local icon handler communicates with a shell extension invoker to receive messages from the remote machine . In another embodiment the local icon handler communicates with a local agent to receive messages from the remote machine . In still another embodiment the local icon handler communicates directly with the proxy icon handler to receive messages. In still even another embodiment the local icon handler receives a redirected message identifying a user request for access to functionality provided by an icon published to the desktop environment on the remote machine . In yet another embodiment the local icon handler receives a redirected message including a request for graphical data associated with an icon managed by the local icon handler .

In some embodiments the local icon handler includes a transmitter for sending to the proxy icon handler information associated with a local icon. In one of these embodiments the local icon handler includes functionality for identifying a current state of a local icon such as whether or not the icon is currently displayed. In another of these embodiments local icon handler includes functionality for identifying informational text associated with the icon for example the local icon handler may be in communication with a local registry retrieve informational text to be displayed with the local icon upon request and transmits the informational text to the proxy icon handler . In still another of these embodiments the local icon handler retrieves data from a registry on the local machine to identify the current state of the local icon and the informational text associated with the local icon for example the local icon handler may include a method or function for requesting an enumeration of registry keys to retrieve the data from the registry. In other embodiments the local icon handler includes a receiver receiving from the proxy icon handler a direction to display icon data locally.

In one embodiment the proxy icon handler may include a receiver receiving an identification of the icon associated with a resource provided by the local machine . In some embodiments the proxy handler may include a receiver receiving a file including the icon associated with a resource provided by the local machine . In other embodiment the proxy handler may include a receiver receiving a data stream including the icon file. In still other embodiments the proxy icon handler may generate the window displaying the plurality of icons in the remote desktop environment the window including at least one icon associated with a resource provided by the remote machine and including a modified version of the icon associated with the resource provided by the local machine . In further embodiments the proxy icon handler may modify the window displaying the plurality of icons in the remote desktop environment the window including at least one icon associated with a resource provided by the remote machine and including a modified version of the icon associated with the resource provided by the local machine . In some embodiments the proxy icon handler does not modify the window . In some embodiments the proxy icon handler does not modify the icon

The proxy icon handler may further generate a system tray window displaying the plurality of icons in the remote desktop environment wherein the plurality of includes at least one icon associated with a resource provided by the remote machine and the icon associated with the resource provided by the local machine . In some embodiments the proxy icon handler may modify an existing system tray window displaying the plurality of icons in the remote desktop environment .

In one embodiment a single process provides the functionality of the proxy icon handler . In another embodiment a process need not be dedicated to this purpose as long as it can provide reliable and reasonably prompt handling of the icon notification window messages. In still other embodiments multiple processes may provide the functionality.

In one embodiment the local icon handler includes a Shell NotifyIcon function. In another embodiment the local icon handler intercepts a function for identifying a resources calling the Shell NotifyIcon function. In still another embodiment the local icon handler hooks the Shell NotifyIcon function. In yet another embodiment the local icon handler executes prior to the installation of an icon associated with a resource provided by the local machine. In some embodiments initialization of the local icon handler requires a reboot of the remote machine and administrative privileges. In other embodiments initialization of the local icon handler does not require a reboot of the remote machine or administrative privileges.

A local agent executing on the local machine receives from the remote agent window attribute data associated with the window displaying the plurality of icons and graphical data representing the window . In some embodiments the local agent receives from the remote agent a z order entry for the window displaying the plurality of icons in the remote desktop environment . In some embodiments the window may be the system tray window of the remote machine . In other embodiments the window may be the taskbar window of the remote machine . The local agent displays the received graphical data in a window formed according to the received window attribute data. In some embodiments the local agent replaces a display of a system tray window on the local machine with a display of the window generated by the proxy icon handler on the remote machine . In other embodiments the local agent displays according to the received window attribute data a full screen integrated desktop within a window .

In some embodiments the proxy icon handler applies a filter to remove from the plurality of icons a duplicate icon. In one of these embodiments the filter is used to eliminate a duplicate icon where two instances of a resource are executing and a user requests directly or indirectly through a preference or policy setting associated with the user or with the resource the removal of duplicate icons. In another of these embodiments the filter is used in combination with a policy or administrative setting to prevent integration of an icon for example a management component may limit a number of integrated icons to prevent a representation of a system tray from exceeding a limitation on size.

Referring now to a screen shot depicts one embodiment of a remote system tray including a plurality of icons . As depicted in the representation of the icon provided by the local machine is included in a system tray window displaying a representation of the icon associated with the resource provided by the remote machine . In one embodiment the system tray is displayed on the local machine . In another embodiment the system tray is referred to as a notification area within a toolbar control. In still another embodiment the system tray is referred to as a system control area. In still even another embodiment the system tray includes a notification area. In yet even another embodiment the system tray includes a system control area.

Referring now to a flow diagram depicts an embodiment of a method for providing by a remote machine access to graphical data associated with a resource provided by a local machine . In brief overview the method includes initializing by a remote agent executing on a remote machine a proxy icon handler block . The proxy icon handler receives from an icon handler executing on a local machine data associated with an icon associated with a resource provided by the local machine block . The proxy icon handler in communication with a shell on the remote machine modifies a window displaying a plurality of icons e.g. in a remote desktop environment the plurality of icons e.g. including at least one icon e.g. associated with a resource provided by the remote machine and including the icon associated with the resource provided by the local machine block . The remote agent transmits to a local agent executing on the local machine window attribute data associated with the window displaying the plurality of icons e.g. and graphical data representing the window displaying the plurality of icons e.g. block . The local agent displays the received graphical data in a window formed according to the received window attribute data block .

A remote agent executing on a remote machine initializes a proxy icon handler block . In some embodiments the remote agent initializes the proxy icon handler and communicates with various components of system as described previously in connection with .

The proxy icon handler receives from an icon handler executing on a local machine data associated with an icon associated with a resource provided by the local machine block . In some embodiments the proxy icon handler may receive an identification of the icon associated with a resource provided by the local machine . In other embodiments the proxy icon handler may retrieve a file including the icon associated with a resource provided by the local machine . In one embodiment the proxy icon handler receives an identification of an icon associated with a resource provided by the local machine the icon displayed in a system tray window maintained by the local machine.

In another embodiment the proxy icon handler receives an identification of an icon associated with a resource provided by the local machine the icon displayed in a system control area window maintained by the local machine. In still another embodiment the proxy icon handler receives an identification of an icon associated with a resource provided by the local machine the icon displayed in a notification area window maintained by the local machine.

In some embodiments the proxy icon handler receives an identification of at least one icon associated with a resource provided by the local machine. In one of these embodiments the proxy icon handler receives the identification from the remote agent . In another of these embodiments the proxy icon handler receives the identification from the local icon handler executing on the local machine . In other embodiments the proxy icon handler receives graphical data associated with the icon. In one of these embodiments the graphical data is displayed to display the icon. In still other embodiments the proxy icon handler receives an identification of a modification to a previously identified icon. In one of these embodiments the proxy icon handler modifies a representation of the icon on the remote machine responsive to the identification of the modification.

In one embodiment a local icon handler identifies the at least one icon for inclusion in an integrated display of a window including a plurality of icons. In another embodiment the local icon handler uses MICROSOFT Active Accessibility to identify a data object associated with an icon on the local machine the data object identifying screen coordinates for the bounds of the icon along with a caption. In still another embodiment the local icon handler uses a screen scraping technique to generate a copy of graphical data displayed in the identified screen coordinates and associated with the at least one icon. In still even another embodiment the local icon handler retrieves an enumeration of the at least one icon and associated icon data from a registry on the local machine . In yet another embodiment the local icon handler retrieves an enumeration including a unique listing of each of a plurality of icons. In some embodiments the local icon handler uses a message based interface to a toolbar control to retrieve information about at least one icon in the toolbar that is used by WINDOWS to implement the notification area or the system control area .

In some embodiments the local icon handler monitors a local icon for changes such as insertion deletion or modification of the local icon. In one of these embodiments the local icon handler monitors all icon related operations on the local machine . In another of these embodiments the local icon handler identifies a resource associated with an icon by processing a monitored icon related operation. In still another of these embodiments the local icon handler hooks a response by at least one resource to a WINDOWS message directing resources on the local machine to generate a corresponding at least one icon . In still even another of these embodiments the local icon handler hooks a WINDOWS message by at least one resource to a system tray area data object modifying a second data object displayed by the system tray area data object. In yet another of these embodiments the local icon handler retrieves data from a buffer within a memory space associated with a shell on the local machine .

In some embodiments the local icon handler sends a WINDOWS control message to identify a total number of icons displayed by a data object displaying a plurality of icons such as a system tray window displaying a plurality of icons . In one of these embodiments the local icon handler calls a function such as TB GETBUTTON k and receives a data structure such as a TBBUTTON struct containing information relating to an icon including but not limited to the following i a bitmap index of an image list ii a command identifier for the icon and iii an identification of text associated with the icon.

In one embodiment a local agent on the local machine transmits to the remote agent data associated with the icon associated with the resource provided by the local machine . In another embodiment the local agent transmits data including an identification of a change to data associated with the icon and previously transmitted to the remote agent . In still another embodiment the remote agent forwards the received data to the proxy icon handler . In yet another embodiment a proxy handler associates a proxy icon with a data object representing a system tray on the remote machine responsive to the received information. In one embodiment data associated with the proxy icon specifies a proxy icon handler that should receive notifications of user interaction. In another embodiment data associated with the proxy icon identifies display data that the proxy icon handler should display upon receiving a notification of a type of user interaction for example the data may identify a type of pop up menu to display when a user clicks on an icon in the system tray associated with the proxy icon or identifying a type of informational window to display when a user positions a cursor icon over the icon in the system tray.

The proxy icon handler modifies a window displaying a plurality of icons in a remote desktop environment the plurality of icons including at least one icon associated with a resource provided by the remote machine and including the icon associated with the resource provided by the local machine block . In some embodiments the window displaying the plurality of icons may be a system tray window of the remote desktop environment . In other embodiments the proxy icon handler removes from the plurality of icons a duplicate icon. In one of these embodiments the proxy icon handler applies a filter to remove a duplicate icon. In still other embodiments the proxy icon handler modifies the window displaying the plurality of icons in the remote desktop environment the window including at least one icon associated with a resource provided by the remote machine and including a modified version of the icon associated with the resource provided by the local machine .

In one embodiment graphical data associated with a data object maintained on the remote machine is displayed on the local machine . In another embodiment for example a user interface element is generated on the remote machine such as an icon menu tool bar or task bar and a remote agent transmits graphical data representing the user interface element for display on the local machine . In still another embodiment the local machine displays the graphical data according to window attribute data received from the remote agent for example the remote agent may transmit to the local agent coordinates for a window region on the remote machine and the local agent may display received graphical data in a corresponding window region on the local machine . In still even another embodiment the display of the graphical data may obscure a display of a data object maintained on the local machine . In yet another embodiment for example a local agent in communication with a shell directs the display of a local task bar and then directs the display on top of the display of the local task bar of graphical data associated with a task bar on the remote machine . In some embodiments as described above the methods and systems described herein provide functionality for integrating the display of both local and remote data objects.

In one embodiment a proxy icon handler on the remote machine modifies a system tray window to include graphical data received from the local machine and representing a system tray icon associated with a resource on the local machine. In another embodiment and as described in greater detail below the remote agent transmits graphical data to the local machine for display. In still another embodiment the local agent directs the formation of a system tray window displaying the graphical data received from the remote agent including the graphical data forming the icon representing a system tray icon associated with a resource on the local machine .

In one embodiment a proxy icon handler accesses an application programming interface such as Shell NotifyIcon to request insertion modification deletion or change of focus of an icon into the system tray on the remote machine . In another embodiment the proxy icon handler accesses an interface to retrieve an icon handler defining an appearance of an icon. In still another embodiment the proxy icon handler provides an interface to which the shell may send a notification of a user interaction with a message identifier and an icon identifier. In yet another embodiment a parameter of the interface defines presence captions appearance and behavior of data displayed with the icon such as an informational window generated when a user interacts with the icon.

In one embodiment the proxy icon handler receives messages associated with user interactions with the proxy icon. In another embodiment the proxy icon handler receives from the shell windows messages with a message ID. In still another embodiment the shell transmits the messages to a window associated with the proxy icon handler . In still even another embodiment these messages incorporate notification data that is constructed according to a specified currently active type of notification behavior. In yet another embodiment the proxy icon handler provides functionality for processing the notification messages.

The remote agent transmits to a local agent executing on the local machine window attribute data associated with the window displaying the plurality of icons and graphical data representing the window displaying the plurality of icons block . In some embodiments the remote agent transmits to the local machine a z order entry for the window displaying the plurality of icons 

The local agent displays the received graphical data in a window formed according to the received window attribute data block . In some embodiments a display of a system tray on the local machine is replaced with a display of the window displaying the plurality of icons 

In one embodiment the proxy icon handler receives a request for access to the resource provided by the local machine and associated with the icon . In another embodiment the proxy icon handler redirects the request to the icon handler executing on the local machine . In still another embodiment the proxy icon handler redirects the request to the local agent on the local machine . In still even another embodiment the proxy icon handler receives from the remote agent an identification of a user interaction with the icon associated with the resource provided by the local machine . In one embodiment the request for access to the resource is a result of a user interaction with a display on the local machine of a data object. In another embodiment using a pointing device such as a mouse to click on an icon or to hover a cursor over an icon a user may request the display of an icon specific context menu. In still another embodiment a user may request the display of a window such as a new window a window obscured by a display of a different data object or a minimized window. In yet another embodiment the user may request access using a keyboard.

Referring now to a block diagram depicts one embodiment of a system for providing by a local machine access to graphical data associated with a resource provided by a remote machine . In brief overview the system includes a local machine a local agent a remote machine a remote agent a remote desktop environment an icon associated with a resource provided by the remote machine and a local window displaying a plurality of icons in a local desktop environment the plurality of icons including at least one icon e.g. associated with a resource e.g. provided by the local machine. In some embodiments the local window may be a system tray window of the local machine .

In more detail the system includes a local agent which incorporates an icon associated with a resource provided by a remote machine into a local window displaying a plurality of icons in a local desktop environment wherein the plurality of icons include at least one icon e.g. associated with a resource e.g. provided by the local machine . In some embodiments the local window is a system tray window of the local machine . The local agent associates or re parents the local window to a window displaying to a user of the local machine a desktop environment maintained by the remote machine and providing integrated access to both resources provided by the local machine and resources provided by the remote machine.

In other embodiments the system includes a proxy icon handler on the local machine which receives a request for access to the resource provided by the remote machine and associated with the icon . In some of these embodiments the proxy icon handler redirects the request to the remote agent . In other embodiments the proxy icon handler redirects the request to a remote icon handler . Alternatively or additionally the proxy icon handler may receive an identification of a user interaction with the local display of the icon associated with the resource provided by the remote machine . Alternatively or additionally the local agent may receive from the proxy icon handler an identification of a user interaction with the icon associated with the resource provided by the remote machine .

Referring now to a flow diagram depicts an embodiment of a method for providing by a local machine access to graphical data associated with a resource provided by a remote machine . In brief overview the method includes receiving by a local agent executing on a local machine an icon associated with a resource provided by the remote machine block . The local agent incorporates the icon associated with the resource provided by the remote machine into a local window displaying a plurality of icons in a local desktop environment wherein the plurality of icons includes at least one icon associated with a resource provided by the local machine block . The local agent re parents the local window displaying the plurality of icons in the local desktop environment to a window displaying to a user of the local machine a desktop environment maintained by the remote machine and providing integrated access to both resources provided by the local machine and resources provided by the remote machine block .

In more detail a local agent executing on a local machine receives an icon associated with a resource provided by the remote machine block . In some embodiments the local agent receives the icon from a remote agent executing on the remote machine .

The local agent incorporates the icon associated with the resource provided by the remote machine into a local window displaying a plurality of icons in a local desktop environment wherein the plurality of icons includes at least one icon associated with a resource provided by the local machine block . In some embodiments the local window is a system tray window on the local machine .

The local agent re parents the local window displaying the plurality of icons in the local desktop environment to a window displaying to a user of the local machine a desktop environment maintained by the remote machine and providing integrated access to both resources provided by the local machine and resources provided by the remote machine block . In some embodiments the local agent replaces the display by over painting and dynamically anchoring the local window over the top of the remote one as described in greater detail below.

In some embodiments the local agent redirects to a remote icon handler a request for access to the resource provided by the remote machine and associated with the icon . In some of these embodiments the remote icon handler provides access to the resource provided by the remote machine and associated with the icon . In yet another embodiment the local agent may receive from a local proxy icon handler an identification of a user interaction with the icon associated with the resource provided by the remote machine .

In one embodiment the local proxy icon handler receives a notification of a user interaction with a representation of the identified icon. In another embodiment the local proxy icon handler receives the notification from a shell. In still another embodiment the local proxy icon handler receives the notification from the remote agent . In still even another embodiment the local proxy icon handler is associated with a window and message loop for receiving window messages notifying the local proxy icon handler of the user interaction. In yet another embodiment the local proxy icon handler redirects the received notification to a corresponding icon handler on the remote machine .

In one embodiment an icon may provide functionality when a user interacts with a display of a data object for example by clicking on the icon or using a keyboard to interact with the icon. In another embodiment the icon may provide functionality in response to a left click with a pointing device such as a mouse or pressing a key on the keyboard such as the space bar. In still another embodiment the icon may provide functionality in response to a right click with a pointing device or pressing a key combination or special key such as Shift F10 or the Context Menu key. In yet another embodiment the icon may provide functionality in response to interaction other a selection by the user of an icon by clicking on the icon with a pointing device for example the user may use a pointing device to hover a cursor icon over an icon without clicking on or selecting the icon in any way.

In some embodiments the user interacts with the icon in different ways depending on what version of what operating system the remote machine executes. For example MICROSOFT WINDOWS 95 notifications appear to be essentially raw user interaction messages window mouse and keyboard messages while some applications appear to respond in non standard ways to various user inputs MICROSOFT WINDOWS 2000 sends higher level notification messages such as WM CONTEXTMENU or NIN SELECT for certain types of user interaction rather than raw mouse or keyboard messages MICROSOFT WINDOWS XP added explicit notification messages for icons with balloon tooltips e.g. NIN BALLOONSHOW MICROSOFT WINDOWS VISTA added notification messages for rich icon pop up UIs e.g. NIN POPUPOPEN . In one of these embodiments the remote machine provides different notification messages than the local machine provides. In another of these embodiments the local proxy icon handler translates the messages into a format expected by the local machine .

In one embodiment once an icon is displayed within the system tray user interactions with the icon are reported as windows messages with a given message ID to the given handler HWND. In another embodiment a window such as a remote system tray window transmits a notification of a user interaction with the icon to a shell . In still another embodiment the proxy icon handler receives from a shell a notification of a user interaction with the icon. In yet another embodiment the proxy icon handler receives from a window such as a remote system tray window a notification of a user interaction with the icon.

In one embodiment the proxy icon handler processes a notification of a user interaction with an icon. In another embodiment the proxy icon handler identifies a request for functionality in the notification of the user interaction. In still another embodiment the proxy icon handler provides the requested functionality for example the proxy icon handler may retrieve from a cache on the remote machine data for use in generation of a dynamic display of information associated with the icon such as text for display in a pop up window generated when a user hovers a pointing device over the icon . In still even another embodiment the proxy icon handler redirects the notification of the user interaction to the remote machine for example the proxy icon handler may redirect the notification to a local icon handler or to the local agent . In yet another embodiment the proxy icon handler includes data associated with the notification to the remote machine .

In one embodiment a local icon handler receives a notification of a user interaction with an icon associated with the local icon handler . In another embodiment the local icon handler receives the notification from the local agent . In still another embodiment the local icon handler receives the notification from the proxy icon handler . In yet another embodiment the local icon handler receives the notification from a shell extension invoker on the local machine . In some embodiments the notification is of a user interaction via a keyboard with an icon. In other embodiments the notification is of a user interaction via a mouse or other pointing device with an icon.

In one embodiment the local icon handler identifies a data object such as a window associated with the icon identified in the received notification. In another embodiment the local icon handler retrieves an identification of the data object from a local registry. In still another embodiment the local icon handler identifies a type of functionality requested by the user. In still even another embodiment the local icon handler determines that the user has requested a dynamic display of information in a window associated with the icon for example the local icon handler may determine that the user positioned a display of a pointing device cursor over an icon without selecting the icon i.e. the user may have hovered a mouse cursor over an icon without clicking on the icon . In yet another embodiment the local icon handler determines that the user has requested execution of a resource associated with the icon for example the local icon handler may determine that the user clicked on the icon.

In some embodiments the local icon handler directs the execution of a resource responsive to processing a received notification of a user interaction with an icon associated with the local icon handler . In one of these embodiments the local icon handler directs a shell executing on the local machine to execute the resource . In another of these embodiments the local icon handler transmits to the resource an initialization message in a format expected by the resource . In other embodiments an icon is hidden and the functionality requested by the user is the display of the icon. In one of these embodiments the local icon handler receives a notification of a user interaction with a first icon and determines that the user interaction is a request for a display of a second icon.

In one embodiment the local icon handler generates a data object such as a window for dynamic display of data associated with an icon. In another embodiment the local icon handler identifies within a notification of a user interaction with the icon window coordinates identifying a location on a screen at which the user interaction occurred for example the notification may include an identification of the coordinates at which the user positioned the display of the cursor. In still another embodiment the local icon handler directs the display of the generated data object at or near the coordinates identified in the notification. In yet another embodiment the local agent receives an identification of the screen coordinates and directs the relocation of the displayed data object generated by the local icon handler .

Referring now to a block diagram depicts one embodiment of a system for providing by a remote machine access to a desk band associated with a resource executing on a local machine. In brief overview the system includes a remote machine a first agent executing on the remote machine a shell executing on the remote machine a local machine a second agent executing on the local machine a resource provided by the local machine and a desk band associated with the local resource .

Referring now to and in greater detail a first agent executing on a remote machine receives an identification of a desk band associated with a resource provided by a local machine . The first agent in communication with a shell executing on the remote machine maintains a taskbar window in a desktop environment on the remote machine . The taskbar window includes at least one window associated with a resource provided by the remote machine . The taskbar window includes a window region representing the desk band by using graphical data stored on the remote machine . The taskbar window includes a window region representing the desk band by using graphical data received from the local machine .

In one embodiment the first agent in communication with the shell executing on the remote machine maintains a taskbar window in a desktop environment on the remote machine the taskbar window including a window region representing the desk band on the local machine by using graphical data received from the local machine . In another embodiment the first agent transmits an identification of the window region to the second machine . In still another embodiment the first agent transmits an identification of a parent or ancestor window of the taskbar window including the window region representing the desk band. In yet another embodiment the first agent transmits an identification of a z order entry for the task bar window in a z order list maintained by the remote machine . In some embodiments the first agent monitors the remote desktop environment communicates with other components of system and transmits data to the local machine as described previously in connection with .

A second agent executing on the local machine receives window attribute data and output data associated with the taskbar window in the desktop environment on the remote machine . The second agent displays at least a portion of the received output data in a local window on a desktop environment on the local machine . In one embodiment the window attribute data includes a z order entry for the taskbar window . In another embodiment output data may include any human perceptible data e.g. graphical data audio data etc. . In yet another embodiment output data may be generated by execution of the local resource .

In some embodiments the local window on the desktop environment on the local machine is a local display of the desktop environment on the remote machine . In other embodiments the local window on the desktop environment on the local machine is a local display of the taskbar window in the desktop environment on the remote machine .

In other embodiments the second agent includes an interception component intercepting a user interaction with a local display of the received output data. In some of these embodiments the interception component redirects the user interaction to the desk band associated with the resource provided by the local machine . In yet other embodiments the first agent includes an interception component that intercepts and redirects the user interaction to at least one of the shell and the second agent .

In one embodiment a resource provides at least a portion of its user interface via a user interface element referred to as a desk band. In another embodiment a desk band is provided as a toolbar. In still another embodiment a desk band is provided as a toolbar that that can be added to the WINDOWS taskbar. In yet another embodiment a desk band may allow or prohibit itself to be dragged off the taskbar onto a desktop environment. In some embodiments a toolbar is associated with a media player. In one of these embodiments for example a mini player provided by a resource such as WINDOWS MEDIA player or an ITUNES player.

In some embodiments where a remote machine maintains a full screen desktop environment for display to a user by a local machine the display of the full screen desktop environment may prevent the user from viewing or easily accessing the desk band . In other embodiments where a remote machine transmits at least a portion of a desktop environment for display to a user by a local machine the display of the portion of the desktop environment may prevent the user from viewing or easily accessing the desk band . In one of these embodiments for example the remote machine transmits graphical data and window attribute data associated with a window in the desktop environment and the local machine displays the graphical data in a local window formed according to the received window attribute the local window displaying the received graphical data may block the display of a locally generated desk band. In still other embodiments implementing the methods and systems described herein allow a user to view and interact with an integrated desktop environment providing access to resources provided by a remote machine and to resources such as a desk band provided by a local machine. In one of these embodiments a display of the local desk band toolbar is integrated into a display of a remote taskbar.

In some embodiments the methods and systems describe herein apply to applications and functionality other than desk bands or media player toolbars. In one of these embodiments for example the methods and systems described herein apply also to configuration panels and bars such as without limitation the Microsoft WINDOWS language bar the Quick Launch toolbar Desktop toolbar and the Tablet PC Input Panel . In another of these embodiments the methods and systems described herein apply also to configuration panels and areas such as without limitation the Microsoft VISTA System Control Area . In still another of these embodiments the methods and systems described herein provide functionality for integrating a system tray such as without limitation a MICROSOFT system tray in its entirety.

In one embodiment a desk band is a mini player toolbar which is enabled when a user right clicks on a blank area of a WINDOWS taskbar and enables the mode by interacting with a context menu associated with the task bar. In another embodiment for example a mini player toolbar is enabled by interacting with a Toolbars context menu to enable the WINDOWS MEDIA Player mini player toolbar. In still another embodiment with the mini player toolbar enabled the mini player toolbar is shown instead of a taskbar button whenever the media player is in the minimized state. In some embodiments there is a separate mini player mode that shows a larger version of the mini player in a regular top level window. In one of these embodiments the integration of the window displaying the larger version of the mini player is performed as described above in connection with .

In some embodiments where a desk band is a mini player associated with a media player resource the desk band provides a user interface allowing a user to request access to functionality provided by the media player resource . In one of these embodiments the functionality includes the ability to restore a window displaying the media player stop the playing of an audio or visual track play an audio or visual track and adjust a level of volume of the track. In another of these embodiments the functionality includes the ability to display output data generated by an execution of the media player resource for example a user may request the display of an image associated with the media player resource. In still another of these embodiments a user positions a pointing device over the desk band for example hovering a cursor icon over the desk band and this results in a display of a window associated with the resource for example a pop up status window may display.

In one embodiment a desk band is hosted by a shell on the local machine and implemented by a COM object referred to as a desk band object. In another embodiment multiple desk bands may be created and registered thus making them available for integration into the taskbar window . In still another embodiment a desk band initially appears in the taskbar but can be dragged to the desktop where it appears as a separate window. In yet another embodiment a desk band is a kind of toolbar.

In some embodiments a desk band object is a COM object that implements interfaces including but not limited to IDeskBand IObjectWithSite and IPersistStream. In one of these embodiments the desk band object is in communication with a container object which may also be a COM object. In another of these embodiments an interface such as IDeskBand is used by the container object to obtain display information title min max preferred sizes display flags from the desk band object. In still another of these embodiments an interface such as IObjectWithSite is used to set up bi directional communication between a desk band object and its site within the container object including defining the parent window for the desk band object s window . In this embodiment the desk band object informs the container object when it wishes to change size show hide itself or other bands trigger a chevron pop up menu and more. In still even another of these embodiments an interface such as IPersistStream is used for persisting a desk band and the implementation may be empty if no persistence is required. In yet another of these embodiments an interface such as IInputObject is used to handle focus change notifications and to translate accelerator keys. In other embodiments a desk band object implements an interface IInputObject to accept user input and IContextMenu in order to provide a context menu.

In one embodiment the desk band object requests an identification of a parent window. In another embodiment the desk band object receives the identification from a container object. In still another embodiment the desk band object displays in the identified parent window output data generated by an execution of a resource with which the desk band object is associated. In still even another embodiment the desk band object displays in the identified parent window a child window displaying output data generated by an execution of a resource with which the desk band object is associated. In yet another embodiment the desk band object communicates with its container object its site and a shell to direct the display of data including modifications to displayed data such as changes to display parameters window focus and accelerators.

In some embodiments and by way of example a toolbar associated with a WINDOWS MEDIA player is hosted as follows where window captions are enclosed in double quotes and window classnames are unquoted similar to Microsoft Spy dimensions are shown in square brackets and indentation is used to show parent child relationships 

In one embodiment a visualization and video window has substantially the same high level structure as the media info window described above. In another embodiment the visualization and video window has a different size from the media info window described above. In still another embodiment the visualization and video window is created on demand hidden shown thereafter as needed and destroyed when the media player resource is restored. In still even another embodiment the visualization and video window is dynamically anchored to the mini player toolbar when visible. In yet another embodiment the visualization and video window has additional child windows as follows 

In some embodiments a desk band implements a COM interface IObjectWithSite through which the container can pass the IUnknown pointer for the site object. In one of these embodiments the container may pass new site pointers at any time and the desk band handles updated site information upon receipt. In another of these embodiments when a new site is passed a desk band object implementation of the desk band calls a function such as IOleWindow GetWindow on the new site to obtain and store a handle for a parent window. In still another of these embodiments the desk band object may create the desk band object s window as child of the identified parent window. In still another of these embodiments in which the desk band implements an interface such as IInputObject the desk band object may retrieve and save a site interface such as IInputObjectSite.

In some embodiments the methods and systems described herein provide mechanisms for integrating a toolbar such as a mini player toolbar desk band toolbar and other types of toolbars. In one of these embodiments for example a mechanism is provided for displaying a proxy toolbar on the desktop environment displayed on the remote machine and redirecting user interface interactions with the proxy toolbar to the toolbar on the local machine. In another of these embodiments a mechanism is provided for transmitting toolbar graphical data from the local machine to the remote machine for display on the remote machine and redirecting user interface interactions from the remote machine back to the corresponding toolbar on the local machine. In still another of these embodiments a mechanism is provided for re parenting a window displaying a toolbar window on a desktop environment provided by a local machine. In yet another of these embodiments a mechanism is provided for proxying the container site desk band interaction between the local machine and the remote machine .

Referring now to a flow diagram depicts one embodiment of a method for providing by a remote machine access to a desk band associated with a resource executing on a local machine. In brief overview the method includes receiving by a first agent executing on a remote machine an identification of a desk band associated with a resource provided by a local machine block . The method includes maintaining by the first agent in communication with a shell executing on the remote machine a taskbar window in a desktop environment on the remote machine the taskbar window including at least one window associated with a resource provided by the remote machine and including a window region representing the desk band by using graphical data stored on the remote machine block . The method includes transmitting by the first agent to a second agent executing on the local machine window attribute data and output data associated with the taskbar window in the desktop environment on the remote machine block . The method includes displaying by the second agent executing on the local machine at least a portion of the received output data in a local window on a desktop environment on the local machine block .

Referring now to and in greater detail a first agent executing on a remote machine receives an identification of a desk band associated with a resource provided by a local machine block . In one embodiment the first agent receives the identification of the desk band from the second agent executing on the local machine . In another embodiment the second agent transmits graphical data associated with the desk band to the first agent . In still another embodiment the local agent captures periodically a snapshot of graphical data displayed by the desk band object. In still another embodiment the local agent transmits graphical data associated with the desk band to the remote agent according to a presentation layer protocol.

The first agent maintains a taskbar window in a desktop environment on the remote machine the taskbar window including at least one window associated with a resource provided by the remote machine and including a window region representing the desk band by using graphical data stored on the remote machine block . In some embodiments the first agent maintains a taskbar window in a desktop environment on the remote machine the taskbar window including at least one window associated with a resource provided by the remote machine and including a window region representing the desk band on the local machine by using graphical data received from the local machine .

In one embodiment a display of a local taskbar on a local machine is obscured by a display of a full screen integrated desktop received from the remote machine . In another embodiment a taskbar window maintained on the remote machine and displayed in the full screen integrated desktop is modified to provide space to show the toolbar when required and functionality is provided to ensure that various other user interface features work.

In some embodiments the taskbars on both the remote machine and the local machine have the same orientation. In one of these embodiments where the taskbars are both horizontal the remote agent directs a display of at least one new row on the taskbar on the remote machine . In another of these embodiments the remote agent anchors a proxy taskbar window representing a taskbar window maintained on the local machine to the at least one new row in the desktop environment maintained on the remote machine. In other embodiments the taskbars on both the remote machine and the local machine have different orientations for example the remote machine may display a vertical taskbar and the local machine displays a horizontal taskbar. In one of these embodiments taskbar orientations need not be synchronized as a proxy desk band handler can specify the orientation required by the remote machine even if that differs from the taskbar orientation of a taskbar on the local machine . In still other embodiments if a toolbar on the local machine is hidden the window region representing the desk band on the remote machine is also hidden thus increasing available space on the taskbar. In further embodiments if a toolbar on the local machine is visible the window region representing the desk band on the remote machine is also visible.

In one embodiment where the remote desktop taskbar orientation changes the window size of the local desk band and the location relative to the parent window change to match the location and size of the updated representation of window region . In another embodiment the local agent changes an orientation of a local taskbar window to match that of the taskbar window maintained on the remote machine . In still another embodiment the change of the taskbar on the local machine triggers a change in the orientation of the toolbar user interface to conform to that of the window region .

The first agent transmits to a second agent executing on the local machine window attribute data and output data associated with the taskbar window in the desktop environment on the remote machine block . In one embodiment the first agent transmits the output data to the second agent according to a presentation layer protocol such as ICA RDP or any of the protocols described above in connection with . In some embodiments a window attribute data may relate to an ancestor or parent window of taskbar window .

In some embodiments the remote agent receives a notification of a transition between a hidden desk band and a visible desk band on the local machine and automates the same transition for a window region on the remote desktop. In one of these embodiments the local agent notifies the remote agent . In another of these embodiments the local agent detects a transition using a MICROSOFT Active Accessibility hook. In still another of these embodiments a component such as the local agent or the remote agent monitors for a top level window state transition and or the appearance or disappearance of a desk band object in the shell for example the component may monitor for top level WMP window state transitions class WMPlayerApp and or the appearance disappearance of the WMP9DeskBand under Shell TrayWnd. In yet another of these embodiments for generic desk bands the system may include a component monitoring for desk band windows under Shell TrayWnd s RebarWindow32.

The second agent executing on the local machine displays at least a portion of the received output data in a local window on a desktop environment on the local machine block . In one embodiment the second agent displays in a taskbar window on a desktop environment on the local machine at least a portion of the received output data.

In one embodiment the local agent receives coordinates that define an apparent location of a window region representing desk band on the taskbar window in the desktop environment maintained on the remote machine . In another embodiment the local agent uses graphical indicators displayed in the window region and transmitted as part of the output data sent by the remote agent to detect the location of the presentation of window region within the local display of the remotely maintained desktop environment. In still another embodiment the local agent uses the received coordinates to identify a location within a local display of the remotely maintained desktop environment. In still another embodiment the local agent uses the identified location in directing a display of the local toolbar such that the toolbar display overlays the presentation of the window region . In still even another embodiment the local agent dynamically monitors local windows to identify a change to a toolbar window or a window associated with the toolbar window such as a fly out window for example the local agent may determine when a user has minimized a resource to or restored from a toolbar mode. In yet another embodiment the local agent notifies the remote agent when the local agent detects a change to window attribute data including a visual state of the toolbar.

In one embodiment an operating system provides an interface that may be called to enable a toolbar. In another embodiment enabling the toolbar need only be done once to enable a proxy desk band thereafter automation can be achieved by having the desk band ask its container control to show or hide itself. In still another embodiment one may automate a remote desktop taskbar s context menu. In yet another embodiment automation can be achieved via the keyboard as there are hotkeys to set focus to a system tray and to invoke its context menu from which the Toolbars submenu is accessed. In some embodiments the AutoHotKey program may be used to perform context menu automation. In one of these embodiments an AutoHotKey script including compiled versions for those without AutoHotKey provides several working methods to toggle a toolbar. In other embodiments a hot key command a particular keystroke combination for example is intercepted by the local agent . In one of these embodiments a user interaction with a keyboard for example striking a particular combination of keys is detected and sent from the remote agent to the local agent . In another of these embodiments the local agent then displays the local taskbar context menu.

In some embodiments a user may still desire functionality for enabling and disabling a toolbar while interacting with a local display of a remotely maintained desktop environment. In one of these embodiments a user may enable or disable a toolbar on the local machine via a taskbar context menu integrated into a remotely maintained desktop environment.

In one embodiment an interaction between a container site and a desk band hosting a toolbar is redirected to the local agent for processing. In another embodiment the system provides functionality supporting container desk band collaboration including dynamically changing display info and collaborative focus accelerator handling.

In some embodiments the first agent receives a request for execution of a command associated with a user interface element displayed by the desk band associated with the resource provided by a local machine . In one of these embodiments a desk band provides access to functionality provided by the resource executing on the local machine and the request for execution of the command is a request to execute the provided functionality. In another of these embodiments where the resource is a multimedia application the desk band may provide functionality for without limitation stopping playing pausing or muting a display of audio or visual media for restoring a display of the resource itself for modifying a level of volume of an audio track and for showing a visualization associated with the media. In still another of these embodiments the first agent redirects the request to the second agent on the local machine. In still even another of these embodiments the second agent transmits the request received from the first agent to the resource executing on the local machine. In another one of these embodiments the first agent intercepts a user interaction with the window region . In still another of these embodiments the second agent intercepts a user interaction with the window region . In one of these embodiments the second agent redirects the user interaction to the desk band associated with the resource provided by the local machine . In yet another of these embodiments the local resource directs the display on the desktop environment on the local machine of output data generated in response to receiving the request. In some embodiments the first agent transmits to the second agent a z order entry for the task bar window .

In one embodiment a proxy toolbar window is displayed in a window region on the desktop environment maintained on the remote machine. In another embodiment the proxy toolbar redirects user interface interactions with the proxy toolbar to the toolbar on the local machine.

In one embodiment a proxy desk band object not shown on the remote machine adds an entry to a taskbar window context menu to allow itself to be enabled or disabled . In another embodiment this entry has text e.g. WINDOWS MEDIA Player on client or on client associated with the resource and displayed to a user. In still another embodiment the proxy desk band object redirects the setting to the local machine .

In some embodiments the first agent receives a request for display of additional data associated with the resource provided by the local machine . In one of these embodiments a user of the local machine uses a pointing device such as a mouse to initiate the display of a local window associated with the desk band such as a pop up window the local window displaying additional details associated with the functionality of the resource provided by the local machine . In another of these embodiments the local window associated with the desk band displays a user interface for requesting access to functionality provided by the resource executing on the local machine . In still another of these embodiments the local window is anchored to the local representation of the remote taskbar in which the desk band is displayed. In still even another of these embodiments the first agent generates the requested display. In yet another of these embodiments the first agent transmits the request to the second agent executing on the local machine and the second agent directs the display.

In some embodiments the system emulates the look and feel of a toolbar. In one of these embodiments the remote agent creates a proxy toolbar window and graphical data associated with the desk band is shown on the taskbar window in the desktop environment maintained on the remote machine . In another of these embodiments when a corresponding toolbar window appears on a taskbar window of the local machine the remote agent displays the proxy toolbar window on the desktop environment on the remote machine . In still another of these embodiments the remote agent provides access to individual controls associated with the desk band just as the desk band on the local machine does. In still even another of these embodiments the remote agent changes a vertical horizontal orientation of the displayed proxy toolbar window to synchronize the display of the proxy toolbar window with a display of the toolbar window on the local machine. In yet another of these embodiments the remote agent changes a vertical horizontal orientation of the displayed proxy toolbar window without synchronizing the display of the proxy toolbar window with that of the displayed window on the local machine .

In one embodiment user interactions with the proxy toolbar window are redirected to the local machine to automate the toolbar on the local machine . In another embodiment MICROSOFT Active Accessibility is used to automate the toolbar on the local machine and each control on the toolbar on the local machine is accessible. In still another embodiment the local agent emulates mouse clicks at the same point relative to the toolbar on local machine as was clicked relative to the proxy toolbar window on remote machine .

In some embodiments the remote agent and the local agent integrate a display of a dynamically generated window associated with an integrated toolbar for example a fly out window . In one of these embodiments the remote agent monitors a window region displaying a toolbar on at least one of the local machine and the remote machine . In another of these embodiments the local agent monitors a window region displaying a toolbar on at least one of the local machine and the remote machine . In still another of these embodiments when a user interacts with the display of the integrated toolbar to request a display of data in a dynamically generated window such as a fly out window the remote agent directs the creation of a new window. In still even another of these embodiments when a user interacts with the display of the integrated toolbar to request a display of data in a dynamically generated window such as a fly out window the local agent directs the creation of a new window. In yet another embodiment at least one of the remote agent and the local agent maintain a dynamically generated window for example an agent may modify or remove the dynamically generated window.

In one embodiment a local agent integrating a toolbar associated with a resource provided by the local machine into a display of a desktop environment maintained by the remote machine modifies the form or the apparent form of the toolbar during integration. In another embodiment the local agent detects that a display of a toolbar window on the local machine is obscured by a display of a full screen desktop environment maintained by the remote machine . In still another embodiment the local agent displays the toolbar window as floating on the display of the desktop environment on the local machine instead of displaying the toolbar window as integrated into a local taskbar window for example the local agent may automate a user interface use window messages or use programmatic means to reposition the toolbar window. In still even another embodiment the local agent integrates a floating toolbar as described herein in connection with integration of taskbar bound toolbars. In yet another embodiment the local agent does not re parent any windows instead relying on the toolbar having an always on top setting and dynamically anchoring the floating toolbar to the current location of the taskbar s reserved space.

In one embodiment when using a remote full screen desktop a user may want to use multiple languages or multiple keyboards or at least keyboard layouts and to switch between them on demand. In another embodiment an operating system provides a desk band for assisting a user in handling these configuration settings. In still another embodiment for example when keyboards are connected to the local machine should the user wish to use a different keyboard layout and or different language then the local machine may be a preferable place to manage those settings rather than the remote machine . In still even another embodiment for example a MICROSOFT Language Bar which may be a toolbar in the taskbar assists with handling at least one of these configuration settings for WINDOWS. In yet another embodiment a language bar toolbar is a top level window and can be moved anywhere on the desktop rather than being bound to the taskbar. In some embodiments a user activates a language bar toolbar. In one of these embodiments the methods and systems described herein in connection with desk band integration provide functionality for integrating all types of toolbars including language bar toolbars.

In some embodiments a user interacting with a local display of an integrated desktop environment may access functionality associated with a global restore from toolbar hotkey ALT SHIFT P . In one of these embodiments a local agent detecting the user interaction for example identifying that the user has pressed a combination of keys on the keyboard does not transmit an identification of the detected user interaction to the remote machine sending it instead to the resource . In another of these embodiments the local agent leverages code that determines whether to pass identifications of certain interaction to the remote machine or to process the interaction on the local machine . In other embodiments a modification to the remote agent provides a user with access to the functionality associated with a global restore from toolbar hotkey. In still other embodiments a hooking component intercepts a global keyboard interaction with the remote machine and sends an identification of the keystroke back to the local agent for processing.

In some embodiments the methods and systems described above take a client side toolbar or the entire taskbar and create the appearance of a floating toolbar on the desktop environment maintained on the remote machine by creating the appearance of graphics anchored to a window region other than that containing the remote display of a taskbar window. In other embodiments the methods and systems described above provide functionality for displaying toolbars and window maintained on the local machine as always on top fly out windows or floating toolbars integrated into the local display of the remotely maintained desktop environment.

In one embodiment the methods and systems described above in connection with desk band toolbars associated with resources on a local machine and integrated into remotely maintained desktop environments also apply to keyboard related toolbars. In another embodiment a method and system for integration of a toolbar such as a keyboard related toolbar or a client side mouse control toolbar or a Tablet PC Input toolbar causes a graphical data associated with a toolbar maintained on the local machine to display at a window region that would otherwise display a local representation of a remotely maintained taskbar.

Referring now to a block diagram depicts one embodiment of a system for providing by a remote machine access to a desk band associated with a resource executing on a local machine . In brief overview the system includes a remote machine a taskbar window maintained by the remote machine a local machine a local agent executing on the local machine a shell executing on the local machine a resource provided by the local machine and a desk band associated with the local resource .

In some embodiments a desk band window can be re parented to a local window displaying the remote full screen desktop. In one of these embodiments a component on the remote machine can monitor for and communicate updates of a window region that reserves space on the remote taskbar for a local display of a desk band on the local machine. In another of these embodiments a component on the local machine receives at least one such update. In still another of these embodiments the component on the local machine moves a re parented desk band window so that it is drawn over top of an image of the window region . In yet another of these embodiments the component on the local machine directs a display of the image of the desk band graphics over the top of the image of the window region .

Referring now to and in greater detail a local agent executing on a local machine includes a receiver receiving window attribute data associated with a taskbar window maintained by a remote machine . The local agent displays a first local window representing the taskbar window maintained on the remote machine responsive to the received window attribute data. In some embodiments the receiver receives output data representing a window associated with a resource provided by the remote machine and displayed in a taskbar window on the remote machine . In one of these embodiments the local agent further displays the output data representing the window associated with the remote resource in a local taskbar window displaying displaying at least one desk band associated with a resource provided by the local machine .

In another embodiment the desk band displays in a window region identified by the received window attribute data output data generated by an execution of the resource provided by the local machine .

In one embodiment the remote agent generates a window region by creating a proxy toolbar or desk band in the taskbar window . In another embodiment the remote agent generates a window region by resizing another window inside the taskbar window . In still another embodiment the remote gent generates a window region by adding a child window to a toolbar control window in the taskbar and resizing the child control or window.

Referring now to a flow diagram depicts one embodiment of a method for providing by a remote machine access to a desk band associated with a resource executing on a local machine . In brief overview the method includes receiving by a local agent executing on a local machine window attribute data associated with a taskbar window maintained by a remote machine block . The local agent displays to a user of the local machine a first local window representing the taskbar window maintained on the remote machine responsive to the received window attribute data block . The local agent re parents a second local window displaying a desk band associated with a resource provided by the local machine to the first local window representing the taskbar window maintained on the remote machine block .

In some embodiments a desk band window can be re parented to a local window displaying the remote full screen desktop. In one of these embodiments a component on the remote machine can monitor for and communicate updates of the screen location of a window region that reserves space on the remote taskbar for a local display of a desk band on the local machine. In another of these embodiments a component on the local machine receives at least one such update. In still another of these embodiments the component on the local machine moves a re parented desk band window so that it is drawn over top of an image of the window region . In yet another of these embodiments the component on the local machine directs a display of the image of the desk band graphics over the top of the image of the window region .

In one embodiment a local agent uses an aspect of window re parenting that displays the toolbar graphics over the top of the window region . In this embodiment the toolbar is a top level window and is relocated periodically for example every 20 ms or every time the proxy band location changes and kept above the window displaying the window region in a z order list. In some embodiments this functionality is provided for either the actual toolbar on the local machine or to the corresponding proxy window on the remote machine. In one of these embodiments the corresponding proxy window is displayed as a top level window even if the actual toolbar window is not a top level window. In another of these embodiments the toolbar window is kept above the proxy band display in the z order on the remote machine . In still another of these embodiments the corresponding proxy window is kept above the proxy on the remote machine .

Referring now to and in greater detail a local agent executing on a local machine receives window attribute data associated with a taskbar window maintained by a remote machine block . In one embodiment the received window attribute data includes an identification of a window region on the taskbar window reserved for a display by the remote machine of the desk band . The local agent displays to a user of the local machine a first local window representing the taskbar window maintained on the remote machine responsive to the received window attribute data block . In some embodiments the local agent further receives output data representing a window associated with a resource provided by the remote machine and displayed in a taskbar window on the remote machine . In one such embodiment output data may include any human perceptible data e.g. graphical data audio data etc. . In yet another such embodiment output data may be generated by execution of the local resource . In one of these embodiments the local agent may display the received output data in a local taskbar window also displaying at least one desk band associated with a resource provided by the local machine . In some embodiments the second local window is the local taskbar window.

The local agent re parents a second local window displaying a desk band associated with a resource provided by the local machine to the first local window representing the taskbar window maintained on the remote machine block . In one embodiment output data is generated by an execution of the local resource . In such an embodiment the desk band displays in the second local window the generated output data. In another embodiment the local agent on the local machine to paint an image of a local toolbar at a location identified by the window attribute data identifying the window region . In yet another embodiment the local agent directs a display of the second local window displaying a desk band associated with the local resource the second local window displayed at a window region identified responsive to the received window attribute data.

In some embodiments a method for toolbar window re parenting is provided. In one of these embodiments no graphics or user input redirection are necessary as all graphics are painted on the local machine by the resource and relevant user interactions are sent directly to the resource . In one of these embodiments re parenting eliminates a round trip for toolbar graphics in which the local agent transmits the graphical data to the remote agent which later sends the graphical data to the local agent with window attribute data and output data associated with the integrated desktop environment. In another of these embodiments toolbar graphics captured on the client are applied directly to a local display of the taskbar window maintained by the remote machine . In still another of these embodiments for example the local agent displays the taskbar window including a window region and painting over the display an image of the local desk band .

In one embodiment the local agent identifies a child window that provides a display of a toolbar associated with a resource on the local machine . In another embodiment the local agent changes a parent window and location of the child window to a window displaying locally the taskbar window maintained by the remote machine . In still another embodiment the local agent dynamically changes a location of the child window so that it lies over the top of the representation of the corresponding window region . In still even another embodiment the local agent uses an identification of a window region received from the remote agent to change the location of the child window. In yet another embodiment re parenting the child window to the local representation of the remote taskbar displays an integrated taskbar to a user.

In one embodiment the local agent re parents the child window to a top level window generated or maintained on the local machine . In another embodiment the top level window is then positioned over the top of the local representation of . In still another embodiment the local agent re parents the child window so that it is a top level window that may be positioned over the top of the local representation of . In yet another embodiment the local agent paints the image of the child window over the top of the local representation of desk band .

In some embodiments a user manually re parents a window on a local machine to a window displaying locally a remotely maintained desktop environment. In other embodiments a display of the re parented window is modified. In one of these embodiments for example the re parented window is drawn with a border.

In some embodiments graphical data may be periodically obtained from a local desk band by various means e.g. by screen scraping directing the window to paint or print itself to an off screen surface and then painted at the location occupied by the local representation of the window region . In one of these embodiments this mechanism has a substantially similar result as that of transmitting toolbar graphics from a local desk band window to a second local window on the local machine avoiding a round trip to the server.

In some embodiments graphical data created on the local machine for the toolbar on associated with the resource are intercepted and transmitted to the remote machine . In one of these embodiments the remote agent displays the received graphical data displayed in the corresponding window region on the desktop environment on the remote machine . In another of these embodiments the remote agent directs a display of the received graphical data in a taskbar window in the desktop environment. In still another of these embodiments the remote agent transmits graphical data for the desktop environment to the local agent including graphical data received from the local agent . In yet another of these embodiments the remote agent handles changes in user interface orientation providing the local taskbar orientation is synchronized to that of the remote desktop taskbar.

Referring now to a block diagram depicts one embodiment of a system for providing by a remote machine access to a desk band associated with a resource executing on a local machine . In brief overview the system includes a local agent and a local shell executing on a local machine a resource provided by the local machine a proxy container object on the local machine a desk band object associated with the local resource a remote agent executing on a remote machine and a proxy handler on the remote machine .

Referring now to and in greater detail a local agent executing on a local machine detects a request by a local shell for creation of a desk band object associated with a resource provided by the local machine and instantiates a proxy container object responsive to detecting the request. In some embodiments the local agent detects in communication with a registry on the local machine the request by the shell for creation of a desk band object with a local resource .

The proxy container object instantiates the desk band object and identifies a window region e.g. as a desk band site. In one embodiment the proxy container object is a COM object. In some embodiments the proxy container object passes the same window region to the desk band as its site.

In one embodiment a proxy container object acts as a virtual desk band to a container and as a container for a desk band. In another embodiment such a proxy container object implements a different form of re parenting by dynamically changing the site instead of the parent window. In still another embodiment for each site change the desk band object modifies its display to conform to the new site.

In one embodiment the proxy container object is registered on the local machine instead of the desk band object actually associated with the resource . In another embodiment desk band registration information is modified to allow the registration of the proxy container object . In other embodiments a component on the local machine hooks calls to COM interfaces in the container in one embodiment the shell and redirects requests to create an instance of the desk band COM object to request creation of an instance of the proxy container instead.

In one embodiment such a proxy container object running on the local machine acts as a transparent proxy. In another embodiment the proxy container object passes a call from the container to the desk band and passes the desk band calls to the container. In still another embodiment the proxy container object does not modify a call before passing it to the desk band from the container. In yet another embodiment the proxy container object does not modify a call before passing it to the container from the desk band.

A remote agent executing on a remote machine receives an identification of a desk band object associated with the local resource . The remote agent maintains a window region in a taskbar on a desktop environment maintained on the remote machine wherein the window region represents the identified desk band object . In some embodiments the proxy container object includes a translation component translating an identification of a window region received from the remote agent into an identification of a window region on a display on the local machine .

A proxy handler is instantiated by the remote agent and is associated with the identified desk band object . The proxy handler transmits to the proxy container object an identification of a window region associated with the identified desk band object . In one embodiment the proxy container object uses this information to specify a new or updated site to the desk band object .

A desk band object directs a display of output data in the identified window region in a display on the local machine of the desktop environment maintained on the remote machine.

Referring now to a flow diagram depicts one embodiment of a method for providing by a remote machine access to a desk band associated with a resource executing on a local machine . In brief overview the method includes detecting by a local agent executing on a local machine a request by a first shell on the local machine for creation of a desk band object associated with a resource provided by the local machine block . The local agent instantiates a proxy container object responsive to detecting the request block . The proxy container object instantiates the desk band object block . A remote agent executing on a remote machine receives an identification of the desk band object associated with the resource provided by the local machine block . The remote agent maintains a window region in a taskbar on a desktop environment maintained on the remote machine the window region representing the identified desk band object block . The remote agent instantiates a proxy handler on the remote machine the proxy handler being associated with the identified desk band object block . The proxy container object receives from the proxy handler an identification of a window region associated with the identified desk band object block . The proxy container object identifies for the desk band object the identified window region as a desk band site block . The desk band object directs a display of output data in the identified window region in a display on the local machine of the desktop environment maintained on the remote machine block .

Referring now to and in greater detail a local agent executing on a local machine detects a request by a shell on the local machine for creation of a desk band object associated with a resource provided by the local machine block . In one embodiment the local agent in communication with a registry on the local machine detects a request by the shell on the local machine for creation of a desk band object associated with a local resource .

The local agent instantiates a proxy container object responsive to detecting the request block . The proxy container object instantiates the desk band object block . A remote agent executing on a remote machine receives an identification of the desk band object associated with the local resource block . In one embodiment the remote agent receives the identification of the desk band object from the local agent . In another embodiment the remote agent receives the identification of the desk band object from the proxy container object .

The remote agent maintains a window region in a taskbar on a desktop environment maintained on the remote machine the window region representing the identified desk band object block . In one embodiment the remote agent in communication with a shell on the remote machine maintains a window region in a taskbar on a desktop environment on the remote machine the window region representing the identified desk band object .

The remote agent instantiates a proxy handler on the remote machine the proxy handler being associated with the identified desk band object block . In one embodiment the proxy handler is provided as part of the remote agent . The proxy container object receives from the proxy handler an identification of a window region associated with the identified desk band object block . The proxy container object identifies for the desk band object the identified window region as a desk band site block . In one embodiment the proxy container object translates an identification of a window region received from the proxy handler into an identification of a window region on a display on the local machine .

In some embodiments the proxy container object on the local machine is in communication with a proxy desk band handler on the remote machine . In one of these embodiments the proxy container object on the local machine redirects calls including site information received from the proxy desk band handler on the remote machine to the desk band on the local machine . In another of these embodiments the proxy container object on the local machine translates window attribute data received from the proxy desk band handler on the remote machine and redirects the translated data to the desk band on the local machine for example the proxy container object on the local machine may translate data including but not limited to an identification of a parent window and coordinates identifying a window region . In still another of these embodiments the proxy container object on the local machine redirects calls received from the desk band on the local machine to the proxy desk band handler on the remote machine . In still even another of these embodiments the proxy container object provides integration between a desk band maintained on the local machine and a taskbar maintained on the remote machine . In still even another of these embodiments the proxy container object integrates the handling of dynamically changing display information collaborative focus and accelerator handling.

The desk band object directs a display of output data in the identified window region in a display on the local machine of the desktop environment maintained on the remote machine block . In one embodiment the desk band object directs a display of output data in the identified window region in a display on the local machine of the desktop environment maintained on the remote machine .

Referring now to a flow diagram depicts one embodiment of a method for providing by a remote machine access to a desk band associated with a resource executing on a local machine . In brief overview the method includes installing by a local agent executing on a local machine a proxy container object associated with a resource provided by the local machine block . A remote agent executing on a remote machine receives an identification of the desk band object associated with the local resource block . The remote agent maintains a window region in a taskbar on a desktop environment maintained on the remote machine the window region representing the identified desk band object block . The remote agent instantiates a proxy handler on the remote machine the proxy handler being associated with the identified desk band object block . The proxy container object receives from the proxy handler an identification of a window region associated with the identified desk band object block . The proxy container object identifies for the desk band object the identified window region as a desk band site block . The desk band object directs a display of output data in the identified window region in a display on the local machine of the desktop environment maintained on the remote machine block .

Referring now to and in greater detail in one embodiment the remote agent receives the identification of the desk band object from the local agent . In another embodiment the remote agent receives the identification of the desk band object from the proxy container object . In still another embodiment the remote agent in communication with a second shell on the remote machine maintains a window region in a taskbar on a desktop environment on the remote machine the window region representing the identified desk band object . In one embodiment the proxy container object translates an identification of a window region received from the proxy handler into an identification of a window region on a display on the local machine . The desk band object directs a display of output data in the identified window region in a display on the local machine of the desktop environment maintained on the remote machine block . In one embodiment the desk band object directs a display of output data in the identified window region in a display on the local machine of the desktop environment maintained on the remote machine .

The systems and methods described above may be provided as one or more computer readable programs embodied on or in one or more articles of manufacture. The article of manufacture may be a floppy disk a hard disk a CD ROM a flash memory card a PROM a RAM a ROM or a magnetic tape. In general the computer readable programs may be implemented in any programming language LISP PERL C C PROLOG or any byte code language such as JAVA. The software programs may be stored on or in one or more articles of manufacture as object code.

Having described certain embodiments of methods and systems for providing by a remote machine access to a desk band associated with a resource executing on a local machine it will now become apparent to one of skill in the art that other embodiments incorporating the concepts of the disclosure may be used. Therefore the disclosure should not be limited to certain embodiments but rather should be limited only by the spirit and scope of the following claims.

