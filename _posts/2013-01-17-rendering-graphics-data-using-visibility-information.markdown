---

title: Rendering graphics data using visibility information
abstract: In some examples, aspects of this disclosure relate to a method for rendering an image. For example, the method includes generating visibility information indicating visible primitives of the image. The method also includes rendering the image using a binning configuration, wherein the binning configuration is based on the visibility information.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09087410&OS=09087410&RS=09087410
owner: QUALCOMM Incorporated
number: 09087410
owner_city: San Diego
owner_country: US
publication_date: 20130117
---
A device that provides content for visual presentation on an electronic display generally includes a graphics processing unit GPU . The GPU renders pixels that are representative of the content on a display. The GPU generates one or more pixel values for each pixel on the display and performs graphics processing on the pixel values for each pixel on the display to render each pixel for presentation.

The techniques of this disclosure generally relate to rendering graphics data. For example the techniques of this disclosure include utilizing visibility information to optimize rendering. According to some aspects the manner in which rendering is performed e.g. direct rendering or tile based rendering may be dynamically determined using visibility information associated with the primitives being rendered. For example tile based rendering may be used to render areas of an image that include occluded primitives to skip rendering of the invisible primitives. In addition direct rendering may be used to render areas of an image having few or no occluded primitives.

In an example aspects of this disclosure relate to a method for rendering an image that includes generating visibility information indicating visible primitives of an image and rendering the image using a binning configuration wherein the binning configuration is based on the visibility information.

In another example aspects of this disclosure relate to an apparatus for rendering an image that includes one or more processors configured to generate visibility information indicating visible primitives of an image and to render the image using a binning configuration wherein the binning configuration is based on the visibility information.

In another example aspects of this disclosure relate to an apparatus for rendering an image that includes means for generating visibility information indicating visible primitives of an image and means for rendering the image using a binning configuration wherein the binning configuration is based on the visibility information.

In another example aspects of this disclosure relate to a non transitory computer readable storage medium having instructions stored thereon that when executed cause one or more processors to generate visibility information indicating visible primitives of an image and render the image using a binning configuration wherein the binning configuration is based on the visibility information.

In another example aspects of this disclosure relate to a method for rendering an image that includes receiving visibility information indicating visible primitives of the image and determining a binning configuration comprising a distribution of a plurality of primitives to one or more bins based on the visibility information.

In another example aspects of this disclosure relate to an apparatus for rendering an image that includes one or more processors configured to receive visibility information indicating visible primitives of the image and determine a binning configuration comprising a distribution of a plurality of primitives to one or more bins based on the visibility information.

In another example aspects of this disclosure relate to an apparatus for rendering an image that includes means for receiving visibility information indicating visible primitives of the image and means for determining a binning configuration comprising a distribution of a plurality of primitives to one or more bins based on the visibility information.

In another example aspects of this disclosure relate to a non transitory computer readable storage medium having instructions stored thereon that when executed cause one or more processors to receive visibility information indicating visible primitives of the image and determine a binning configuration comprising a distribution of a plurality of primitives to one or more bins based on the visibility information.

The details of one or more examples of the disclosure are set forth in the accompanying drawings and the description below. Other features objects and advantages will be apparent from the description and drawings and from the claims.

Traditional graphics processing unit GPU architectures may require a relatively large amount of data to be read from and written to system memory when rendering a frame of graphics data which may be referred to as an image . Mobile architectures may lack the bandwidth capacity required for processing entire frames of data. Accordingly tile based architectures have been developed that break an image into multiple tiles. The tiles are sized so that they can be processed using a small amount e.g. 256 kB of high bandwidth on chip graphics memory. That is the size of each tile may depend on the amount of available on chip graphics memory. The image is then reconstructed after processing each tile individually.

Tile based rendering may be described with respect to a number of processing passes. For example when performing tile based rendering a GPU may perform a binning pass and a rendering pass. With respect to the binning pass the GPU may process an entire frame and sort rasterized primitives such as triangles into tile sized areas called bins. That is the GPU processes a command stream for an entire image and assigns the rasterized primitives of the image to bins.

In some examples the GPU generates one or more visibility streams during the binning pass. A visibility stream indicates the primitives that are visible in the final image and the primitives that are invisible in the final image. For example a primitive may be invisible if it is obscured by one or more other primitives such that the primitive cannot be seen in the shaded finished image.

A visibility stream may be generated for an entire image or may be generated on a per bin basis e.g. one visibility stream for each bin . In general a visibility stream may include a series of 1 s and 0 s with each 1 or 0 being associated with a particular primitive. Each 1 indicates that the primitive is visible in the final image. Each 0 indicates that the primitive is invisible in the final image. The visibility stream may control the rendering pass described below . For example the visibility stream may be used to skip sequences of invisible primitives during rendering. Accordingly only the primitives that actually contribute to a bin i.e. that are visible in the final image are rendered and shaded thereby reducing shading operations.

Each rendering pass may include a clear unresolve stage a rendering stage and a resolve stage. During the clear unresolve stage the GPU may initialize on chip memory for a new tile to be rendered. For example the GPU may initialize the on chip memory to a certain value clear or read values from external memory to the on chip memory unresolve . During the rendering stage the GPU may process the tile and store the processed tile to the on chip memory. That is the GPU may implement a graphics processing pipeline to determine pixel values and write the pixel values to the on chip memory. During the resolve stage the GPU may transfer the finished pixel values of the tile from the on chip memory to external memory. After finishing all of the tiles of an image the image is ready to be output e.g. displayed .

While tile based rendering with a visibility stream may allow fewer primitives to be processed by skipping invisible primitives there is a computational cost associated with rendering an image bin by bin. Each bin may be referred to as a chunk of data. With tile based rendering as described above each chunk is loaded into local on chip GPU memory load rendered render and stored to system memory store .

In contrast a GPU may perform direct rendering which does not use visibility information. When performing direct rendering the GPU shades and writes each and every primitive directly to system memory regardless of whether the primitives are visible. That is invisible primitives may be written to system memory only to be later written over by other primitive information. Accordingly direct rendering does not require an entire chunk to be loaded to on chip memory prior to rendering and transferred from on chip memory to system memory after rendering.

Accordingly the process of determining visibility information and performing tile based rendering also referred to herein as bin based rendering is typically most beneficial in situations in which at least a portion of an image has a relatively large amount of overdraw. Overdraw refers to drawing one primitive over another primitive such that at least a portion of the overdrawn primitive is not visible. In instances in which there is little overdraw the extra data transfer between local memory and system memory associated with tile based rendering may introduce latencies.

However a driver for the GPU typically executed by another processing unit such as a central processing unit CPU may typically be responsible for determining the configuration of the bins. In addition once generated the GPU typically cannot alter visibility streams and is locked into rendering the image according to the visibility streams. That is the GPU must load each chunk render the chunk and store the chunk to memory. Accordingly the GPU generally may not choose between tile based rendering and directed rendering based on the image being rendered. That is for example the GPU is not typically capable of dynamically selecting tile based rendering for areas having a relatively large amount of overdraw and direct rendering for areas having a relatively small amount of overdraw. Rather as noted above the GPU is generally locked into performing either tile based rendering or direct rendering for an entire image.

The techniques of this disclosure generally relate to utilizing visibility information to optimize rendering. For example according to aspects of this disclosure the manner in which rendering is performed e.g. direct rendering or tile based rendering may be dynamically determined based on visibility information. In some instances visibility information may include data describing which primitives are visible as well as data describing a complexity of the image. For example visibility information may include a visibility stream as well as heuristic data associated with the visibility stream. The heuristic data may include for example a number of primitives in a bin a number of visible primitives in a bin the number of invisible primitives in a bin a size of the primitives and the like. In some instances a score may be assigned to a bin based on the visibility information indicating an overall complexity of a bin an amount of overdraw for a bin and the like.

Based on this visibility information a determination may be made whether to directly render a bin or render the bin using a visibility stream tile based rendering . That is for example assume an initial binning configuration is determined for an image and all of the bins are initially set to be rendered using tile based rendering. In this example bins that were initially set to be tile based rendered having a relatively small amount of overdraw may be switched to direct rendering. Additionally or alternatively a new binning configuration may be determined and implemented. For example the manner in which primitives are distributed to bins for tile based rendering may be altered based on visibility information.

Accordingly according to aspects of this disclosure tile based rendering with visibility streams may be used to render portions of an image that may benefit from the visibility information e.g. relatively complex areas having numerous primitives and or a large amount of overdraw . In addition direct rendering may be used to render portions of an image in which tile based rendering would result in latencies associated with the transfer of data from local on chip memory to system memory. Implementing such techniques may increase the efficiency with which an image is rendered.

As described in greater detail below a binning configuration may be determined by a GPU a GPU driver e.g. as executed by a central processing unit CPU or a combination thereof. That is in one example a GPU driver may generate an initial binning configuration. The GPU may process the initial binning configuration and generate visibility information based on the initial binning configuration. The GPU may send the visibility information to the GPU driver which may generate a revised binning configuration based on the visibility information. In another example rather than sending the visibility information to the GPU driver the GPU may determine a revised binning configuration based on the visibility information. In still another example the GPU driver and the GPU may share the responsibility of determining a revised binning configuration based on the visibility information.

In the example of computing device includes a central processing unit CPU having CPU memory a graphics processing unit GPU having GPU memory and one or more shading units a display unit a display buffer unit storing rendered data ren. data a user interface unit and a data storage unit . In addition storage unit may store GPU driver having compiler GPU program and locally compiled GPU program .

Examples of CPU include but are not limited to a digital signal processor DSP general purpose microprocessor application specific integrated circuit ASIC field programmable logic array FPGA or other equivalent integrated or discrete logic circuitry. Although CPU and GPU are illustrated as separate units in the example of in some examples CPU and GPU may be integrated into a single unit. CPU may execute one or more applications. Examples of the applications may include web browsers e mail applications spreadsheets video games audio and or video capture playback or editing applications or other applications that initiate the generation for image data to be presented via display unit .

In the example shown in CPU includes CPU memory . CPU memory may represent on chip storage or memory used in executing machine or object code. CPU memory may each comprise a hardware memory register capable of storing a fixed number of digital bits. CPU may be able to read values from or write values to local CPU memory more quickly than reading values from or writing values to storage unit which may be accessed e.g. over a system bus.

GPU represents one or more dedicated processors for performing graphical operations. That is for example GPU may be a dedicated hardware unit having fixed function and programmable components for rendering graphics and executing GPU applications. GPU may also include a DSP a general purpose microprocessor an ASIC an FPGA or other equivalent integrated or discrete logic circuitry.

GPU also includes GPU memory which may represent on chip storage or memory used in executing machine or object code. GPU memory may each comprise a hardware memory register capable of storing a fixed number of digital bits. GPU may be able to read values from or write values to local GPU memory more quickly than reading values from or writing values to storage unit which may be accessed e.g. over a system bus.

Display unit represents a unit capable of displaying video data images text or any other type of data for consumption by a viewer. Display unit may include a liquid crystal display LCD a light emitting diode LED display an organic LED OLED an active matrix OLED AMOLED display or the like.

Display buffer unit represents a memory or storage device dedicated to storing data for presentation of imagery such as computer generated graphics still images video frames or the like rendered data for display unit . Display buffer unit may represent a two dimensional buffer that includes a plurality of storage locations. The number of storage locations within display buffer unit may be substantially similar to the number of pixels to be displayed on display unit . For example if display unit is configured to include 640 480 pixels display buffer unit may include 640 480 storage locations storing pixel color and intensity information such as red green and blue pixel values or other color values.

Display buffer unit may store the final pixel values for each of the pixels processed by GPU . Display unit may retrieve the final pixel values from display buffer unit and display the final image based on the pixel values stored in display buffer unit .

User interface unit represents a unit with which a user may interact with or otherwise interface to communicate with other units of computing device such as CPU . Examples of user interface unit include but are not limited to a trackball a mouse a keyboard and other types of input devices. User interface unit may also be or include a touch screen and the touch screen may be incorporated as a part of display unit .

Storage unit may comprise one or more computer readable storage media. Examples of storage unit include but are not limited to a random access memory RAM a read only memory ROM an electrically erasable programmable read only memory EEPROM CD ROM or other optical disk storage magnetic disk storage or other magnetic storage devices flash memory or any other medium that can be used to store desired program code in the form of instructions or data structures and that can be accessed by a computer or a processor.

In some example implementations storage unit may include instructions that cause CPU and or GPU to perform the functions ascribed to CPU and GPU in this disclosure. Storage unit may in some examples be considered as a non transitory storage medium. The term non transitory may indicate that the storage medium is not embodied in a carrier wave or a propagated signal. However the term non transitory should not be interpreted to mean that storage unit is non movable. As one example storage unit may be removed from computing device and moved to another device. As another example a storage unit substantially similar to storage unit may be inserted into computing device . In certain examples a non transitory storage medium may store data that can over time change e.g. in RAM .

Storage unit stores a GPU driver and compiler GPU program and locally compiled GPU program . GPU driver represents a computer program or executable code that provides an interface to access GPU . CPU executes GPU driver or portions thereof to interface with GPU and for this reason GPU driver is shown in the example of as a dash lined box labeled GPU driver within CPU . GPU driver is accessible to programs or other executables executed by CPU including GPU program .

GPU program may include code written in a high level HL programming language e.g. using an application programming interface API . Examples of APIs include Open Computing Language OpenCL Open Graphics Library OpenGL and DirectX as developed by Microsoft Inc. In general an API includes a predetermined standardized set of commands that are executed by associated hardware. API commands allow a user to instruct hardware components of a GPU to execute commands without user knowledge as to the specifics of the hardware components.

GPU program may invoke or otherwise include one or more functions provided by GPU driver . CPU generally executes the program in which GPU program is embedded and upon encountering GPU program passes GPU program to GPU driver . CPU executes GPU driver in this context to process GPU program . That is for example GPU driver may process GPU program by compiling GPU program into object or machine code executable by GPU . This object code is shown in the example of as locally compiled GPU program .

In some examples compiler may operate in real time or near real time to compile GPU program during the execution of the program in which GPU program is embedded. For example compiler generally represents a unit that reduces HL instructions defined in accordance with a HL programming language to low level LL instructions of a LL programming language. After compilation these LL instructions are capable of being executed by specific types of processors or other types of hardware such as FPGAs ASICs and the like including e.g. CPU and GPU .

In the example of compiler may receive GPU program from CPU when executing HL code that includes GPU program . Compiler may compile GPU program to generate locally compiled GPU program that conforms to a LL programming language. Compiler then outputs locally compiled GPU program that includes the LL instructions.

GPU generally receives locally compiled GPU program as shown by the dashed lined box labeled locally compiled GPU program within GPU whereupon in some instances GPU renders one or more images and outputs the rendered images to display buffer unit . For example GPU may generate a number of primitives to be displayed at display unit . Primitives may include one or more of a line including curves splines etc. a point a circle an ellipse a polygon where typically a polygon is defined as a collection of one or more primitives or any other two dimensional 2D primitive. The term primitive may also refer to three dimensional 3D primitives such as cubes cylinders sphere cone pyramid torus or the like. Generally the term primitive refers to any basic geometric shape or element capable of being rendered by GPU for display as an image or frame in the context of video data via display unit .

GPU may transform primitives and other attributes e.g. that defines a color texture lighting camera configuration or other aspect of the primitives into a so called world space by applying one or more model transforms which may also be specified in the state data . Once transformed GPU may apply a view transform for the active camera which again may also be specified in the state data defining the camera to transform the coordinates of the primitives and lights into the camera or eye space. GPU may also perform vertex shading to render the appearance of the primitives in view of any active lights. GPU may perform vertex shading in one or more of the above model world or view space although it is commonly performed in the world space .

Once the primitives are shaded GPU may perform projections to project the image into a unit cube with extreme points as one example at 1 1 1 and 1 1 1 . This unit cube is commonly referred to as a canonical view volume. After transforming the model from the eye space to the canonical view volume GPU may perform clipping to remove any primitives that do not at least partially reside within the view volume. In other words GPU may remove any primitives that are not within the frame of the camera. GPU may then map the coordinates of the primitives from the view volume to the screen space effectively reducing the 3D coordinates of the primitives to the 2D coordinates of the screen.

Given the transformed and projected vertices defining the primitives with their associated shading data GPU may then rasterize the primitives. During rasterization GPU may apply any textures associated with the primitives where textures may comprise state data . GPU may also perform a Z buffer algorithm also referred to as a depth test during rasterization to determine whether any of the primitives and or objects are occluded by any other objects. The Z buffer algorithm sorts primitives according to their depth so that GPU knows the order in which to draw each primitive to the screen. When binning e.g. for tile based rendering shading may not be performed during rasterization. When rendering the primitives however GPU may compute and set colors for the pixels of the screen covered by the primitives. GPU then outputs rendered pixels to display buffer unit .

Display buffer unit may temporarily store the rendered pixels of the rendered image until the entire image is rendered. Display buffer unit may be considered as an image frame buffer in this context. Display buffer unit may transmit the rendered image to be displayed on display unit . While shown and described separately in some instances display buffer unit may form a portion of storage unit .

In some examples GPU may implement tile based rendering to render an image. For example GPU may implement a tile based architectures that renders an image by breaking the image into multiple portions referred to as tiles. The tiles may be sized based on the size of GPU memory . For example GPU may render a tile to GPU memory . Upon completion of the tile GPU may transfer the tile from GPU memory to storage unit and or display buffer unit as rendered data . After GPU has rendered all of the tiles associated with a frame in this way display buffer unit may output the finished image to display unit . Rendering images using multiple tiles may reduce the amount and or frequency of data transfer between GPU memory and storage unit .

When performing tile based rendering GPU driver may initially determine a binning configuration for rendering an image. For example GPU driver may determine a bin size based on the size of GPU memory . In addition GPU driver may apply a predetermined bin layout. For example GPU driver may set an initial bin in the upper left corner of an image. GPU driver may add bins from left to right and top to bottom of the image until the entire image has been divided into bins.

GPU driver also generates a command stream using GPU program . For example the command stream may contain instructions for rendering images from GPU program . GPU driver may add instructions to the command stream which are executed by GPU in the order in which they appear in the stream. The command steam may define the primitives that make up images from GPU program .

After the initial binning configuration and command stream has been set by GPU driver GPU may perform a binning pass and a rendering pass. With respect to the binning pass GPU may process an entire frame and sort rasterized primitives into the bins of the initial binning configuration set by GPU driver . GPU may also generate a visibility stream during the binning pass which may be separated according to bin. For example each bin may be assigned a corresponding portion of the visibility stream for the image.

GPU driver may access the visibility stream and generate command streams for rendering each bin. Accordingly the command streams may be set according to the initial binning configuration. That is the command streams may be generated and ordered so that GPU renders tiles of an image in the order of the initial binning configuration.

When rendering a tile GPU may perform a clear unresolve stage a rendering stage and a resolve stage. During the clear unresolve stage GPU initializes GPU memory for a new tile to be rendered. During the rendering stage GPU may render the tile and store the rendered tile to GPU memory . That is GPU may determine pixel values for each pixel of the tile and write the pixel values to GPU memory . During the resolve stage GPU may transfer the finished pixel values of the tile from GPU memory to display buffer unit or storage unit .

While tile based rendering with a visibility stream may allow fewer primitives to be processed by skipping primitives that are not visible there is a computational cost associated with loading and storing data to GPU memory and transferring an entire tile from GPU memory to display buffer unit . For example in contrast to tile based rendering GPU may directly render data by storing pixel values to display buffer unit or storage unit following rendering rather than storing the pixel values to GPU memory . With direct rendering GPU driver does not use a visibility stream to identify and skip primitives that are not visible in the final image. Rather the command stream includes instructions to render all primitives regardless of whether the primitives are visible. Accordingly invisible primitives in storage unit and or display buffer unit may eventually be written over by pixel values associated with one or more other primitives.

The process of determining visibility information and performing tile based rendering also referred to herein as bin based rendering is typically most beneficial in situations in which at least a portion of an image has a relatively large amount of overdraw. Overdraw refers to drawing one primitive over another primitive such that at least a portion of the overdrawn primitive is not visible. In instances in which there is little overdraw the extra data transfer between local memory and system memory associated with tile based rendering may introduce latencies.

However as noted above GPU driver determines the initial configuration of the bins. In addition GPU sorts visible primitives to bins to create the visibility streams based on the initial configuration of the bins. Accordingly once the visibility streams are generated based on the initial configuration of the bins GPU driver cannot alter the command streams for rendering the primitives. That is for example GPU driver is typically not capable of generating a command stream for directly rendering areas that do not have a large amount of overdraw while also generating a tile based rendering command stream for areas that have a relatively large amount of overdraw. Rather GPU driver and GPU are typically locked into performing either tile based rendering or direct rendering for an entire image.

The techniques of this disclosure generally relate to utilizing visibility information to optimize rendering. For example according to aspects of this disclosure GPU and GPU driver may dynamically determine how to render a particular image based on visibility information associated with the image. In this way GPU and GPU driver may perform direct rendering without using a visibility stream and storing data directly to display buffer unit in some areas of an image while performing tile based rendering using a visibility stream and storing data to GPU memory in other areas of the same image.

Accordingly according to aspects of this disclosure GPU may use tile based rendering to render portions of an image that may benefit from the visibility information e.g. relatively complex areas having numerous primitives and or a large amount of overdraw . In addition GPU may use direct rendering to render portions of an image in which tile based rendering would result in latencies associated with the transfer of data from local on chip memory to system memory. Implementing such techniques may increase the efficiency with which an image is rendered.

It should be understood that computing device is provided as merely an example and other computing devices performing the techniques of this disclosure may be arranged differently. For example while display buffer unit is shown and described separately from storage unit in other examples display unit buffer and storage unit may be incorporated into the same component.

Moreover it should be understood that computing device may include additional modules or units not shown in for purposes of clarity. For example computing device may include a transceiver unit for transmitting and receiving data and may include circuitry to allow wireless or wired communication between computing device and another device or a network. Computing device may also include a speaker and a microphone neither of which are shown in to effectuate telephonic communications in examples where computing device is a mobile wireless telephone such as a smartphone or a speaker and or a microphone where computing device is a media player or tablet computer. In some instances user interface unit and display unit may be external to computing device in examples where computing device is a desktop computer or other device that is equipped to interface with an external user interface or display.

Components of GPU may access GPU memory with relatively lower latency than accessing an external memory such as storage unit . For example GPU memory may be an on chip memory that is on chip with GPU and in relatively close proximity with GPU components and may be associated with a dedicated memory bus within GPU . To access data stored in storage unit in contrast GPU may have to share a memory bus with other components of computing device such as CPU which may result in a more limited available bandwidth.

To take advantage of the high bandwidth low latency GPU memory as described above GPU may render graphics using a tile based rendering architecture. GPU may break an image which may also be referred to as a scene into smaller portions e.g. tiles . GPU memory may store data associated with a tile while GPU renders the tile. After rendering the tile GPU may resolve or copy the rendered pixel data from GPU memory to storage unit via a memory bus.

Command processor may be responsible for reading a command stream from GPU driver . For example as described above with respect to GPU driver may issue instructions for execution by GPU which may be referred to as a command stream. Command processor may read and or decode the instructions of the command stream. In some examples command processor may read from a buffer containing the instructions of the command stream. Command processor may also initiate execution of the instructions at GPU . For example command processor may feed instructions to a thread scheduler that schedules the instructions to be executed by shader processors .

Shader processors may be responsible for executing instructions. For example shader processors may be programmable shading units responsible for vertex geometry and pixel shading operations. For example one or more of shader processors may be responsible for determining vertex positions of primitives e.g. triangles that make up a scene to produce a triangle mesh of the scene. In addition one or more of shader processors may be responsible for generating primitives from the triangle mesh as well as pixel filling and shading operations.

Shader processors may be configured identically or may be individually configured to perform a specific task. For example one of shader processors may be designated as a binning shader that is responsible for binning operations while the remaining shader processors may be responsible for performing the vertex geometry or pixel shading operations described above.

Rasterizer may receive vertex information and may generate a representation of primitives of a scene. In some examples rasterizer applies predefined rules to received vertex information to determine which primitives are visible in the final scene. Rasterizer may cull or remove any invisible primitives of the scene. For example rasterizer may perform z buffering to identify primitives that are covered by other primitives and therefore not visible in the final scene.

Visibility unit may include any combination of fixed function hardware components and or programmable processing units. Visibility unit may receive the rasterized data from rasterizer and generate one or more visibility streams. To generate the visibility stream visibility unit may distribute each of the visible primitives as determined by rasterizer to bins. Each bin may represent a tile of the finished scene.

In some examples visibility unit may generate a separate visibility stream for each of the bins. For example visibility unit may generate a visibility stream for a particular bin by setting flags to indicate which primitives of the particular bin are visible and which primitives of the particular are invisible. According to some aspects visibility unit may set a flag value of 1 to indicate that a primitive is visible in the final scene and a flag value of 0 to indicate that a primitive is not visible in the final scene.

Accordingly visibility unit may generate a plurality of visibility streams comprising flags that indicate the visible primitives of each of the bins. In some examples visibility unit may compress the visibility streams. For example visibility unit may apply a compression scheme to reduce large strings of 0 flags and reduce the amount of memory required to restore the visibility streams.

According to aspects of this disclosure visibility unit may also generate heuristic data for each bin of a scene. In general the heuristic data describes characteristics of a bin. For example visibility unit may generate on a per visibility stream basis to describe visibility characteristics of the bin. In some examples the heuristic data may include data describing the number of primitives in a bin a number of visible primitives in a bin a number of invisible or occluded primitives in a bin a size of the primitives in a bin and the like.

In some instances according to aspects of this disclosure visibility unit may assign a score to each bin based on the visibility stream and or heuristic data. For example visibility unit may assign a score to each bin indicating an overall complexity of each bin an amount of overdraw for each bin and the like. In an example for purposes of illustration visibility unit may numerically rank each bin according to an amount of overdraw for each bin where a 0 ranking indicates that there are no overlapping primitives in a bin and a 10 ranking indicates that there are numerous overlapping primitives.

In some examples the one or more visibility streams the heuristic data and the visibility score may all generally be referred to as visibility information. That is visibility information may include any subset of visibility streams heuristic data and visibility scores.

According to aspects of this disclosure visibility unit may prepare the visibility information to be sent to GPU driver . For example visibility unit may in some instances append the heuristic data and or visibility scores to the end of the visibility streams. In other examples visibility unit may provide the heuristic data and or visibility scores separately from the visibility streams.

In any case in the example shown in the visibility information may be received by command stream reconfiguration unit . While shown separately from GPU driver for purposes of explanation it should be understood that command stream reconfiguration unit may be integrated with GPU driver such that GPU driver carries out the techniques ascribed in this disclosure to command stream reconfiguration unit .

Command stream reconfiguration unit may receive visibility information from visibility unit . As described in greater detail below command stream reconfiguration unit may reconfigure a command stream based on the visibility information. For example command stream reconfiguration unit may designate some bins originally set to be tile based rendered to be directly rendered. In another example command stream reconfiguration unit may change the binning configuration to form new bins. That is command stream reconfiguration unit may merge one or more or portions of one or more visibility streams to create new bins.

In an example for purposes of illustration GPU driver may generate a command stream defining an image for rendering in accordance with a program executed at CPU . The command stream may indicate an initial binning configuration. For example GPU driver may determine a bin size based on the size of GPU memory . In addition GPU driver may use a predetermined bin arrangement relative positions of the bins to break the image into the appropriate number of bins.

The command stream may be received by command processor of GPU . GPU may perform a binning pass as described above with respect to and generate one or more visibility streams for primitives of the image. That is for example visibility unit may generate one or more visibility streams indicating which primitives of the image are visible in the initial binning configuration.

In addition according to aspects of this disclosure visibility unit may generate heuristic data and or visibility scores for the visibility streams. For example as described above visibility unit may determine the number of primitives in each of the bins the number of visible primitives in each of the bins the number of invisible primitives in each of the bins the size of the primitives and the like and visibility unit may assign a visibility score to the bins based on the visibility information.

In some examples visibility unit may append the heuristic data and or scores to the end of the visibility streams. In other examples visibility unit may provide the heuristic data and or scores separately from the visibility streams. In any case visibility unit may send the visibility information e.g. visibility streams heuristic data and or scores to command stream reconfiguration unit at CPU .

According to aspects of this disclosure command stream reconfiguration unit may receive the visibility streams as well as the additional data describing the visibility streams e.g. heuristic data and or visibility scores which may be referred to as decoded visibility information . Command stream reconfiguration unit may use the received data to reconfigure the command stream based on the visibility information. That is command stream reconfiguration unit determines a command stream for rendering the image based on the visibility information.

In some examples command stream reconfiguration unit may drop one or more bins from the tile based rendering passes. That is command stream reconfiguration unit may designate one or more bins from the initial binning configuration to be directly rendered rather than tile based rendered. In another example command stream reconfiguration unit may determine a revised distribution of primitives to one or more bins for rendering. That is command stream reconfiguration unit may dynamically generate a new modified binning configuration for tile based rendering passes based on the visibility information.

In some examples command stream reconfiguration unit may merge one or more of the generated visibility streams to create a new binning arrangement. That is command stream reconfiguration unit may alter the binning configuration by altering the boundaries of one or more bins to encompass an alternative set of primitives. In such examples bins may no longer be evenly distributed rather bins may be arranged based on the complexity of the image. For example bins may be used to encompass relatively complex areas of an image having overdraw while other portions of the image may be directly rendered.

According to some examples command stream reconfiguration unit may use the heuristic data to merge visibility streams until a predetermined complexity metric is attained. For example command stream reconfiguration unit may merge portions of the initial configuration of bins using the visibility streams based on a restricted region growing algorithm. In this way command stream reconfiguration unit may group the most complex areas of an image which may benefit most from tile based rendering together. In addition command stream reconfiguration unit may mix and match direct and tile based rendering according to regions of interest within an image. Such an approach allows GPU to achieve a well balanced rendering load for each pass while simultaneously eliminating empty batches.

Certain techniques above have been described as being performed by particular components of computing device . It should be understood however that such examples are provided merely for purposes of explanation. Accordingly techniques ascribed to one component of computing system may be performed by one or more other components. For example while visibility unit is described as generating heuristic data and visibility scores from visibility streams such functions may in some instances be carried out by CPU such as by command stream reconfiguration unit or GPU driver .

In another example while described with respect to a separate unit it should be understood that command stream reconfiguration unit may be highly integrated with other components of CPU and or GPU . For example command stream reconfiguration unit may be integrated with GPU driver such that CPU via GPU driver is responsible for reconfiguring a command stream based on visibility information. In this example CPU may be responsible for generating the initial command stream as well as the reconfigured command stream. The reconfigured command stream may drop one or more bins from tile based rendering passes associated with the initial command stream or may include a new binning arrangement that includes new different bins and or designated areas for direct rendering.

In other examples command stream reconfiguration module may be integrated with GPU such that GPU is responsible for reconfiguring a command stream based on visibility information. In such examples visibility information may be generated and utilized wholly by GPU . That is while CPU via GPU driver may be responsible for generating an initial command stream GPU may be responsible for reconfiguring the initial command stream. As noted above the reconfigured command stream may drop one or more bins from tile based rendering passes associated with the initial command stream or may include a new binning arrangement that includes new different bins and or designated areas for direct rendering.

For example GPU driver may generate a command stream defining image for rendering by GPU . The command stream may include instructions for rendering primitives of objects as well as an initial binning configuration containing bin bin . In some examples as noted above GPU driver may determine the size of bins based on a size of GPU memory . For example GPU driver may size bins such that data associated with each of the bins may be stored at GPU memory . In addition GPU driver may use a predetermined bin arrangement to break image into bins . That is in the example GPU driver may arrange the bins from left to right and top to bottom of image . Accordingly GPU may render image from left to right and top to bottom initially rendering bin followed by bin bin and bin . GPU driver may be preconfigured to determine the initial binning configuration.

As noted above there is a tradeoff between direct rendering and tile based rendering. Tile based rendering with visibility information may allow some occluded primitives to be skipped reducing the load of shader processors . However there is a cost associated with loading an entire bin of data to local GPU memory load and transferring a finished tile from local GPU memory to storage unit resolve . In contrast direct rendering eliminates these load and resolve costs by shading and writing all primitives directly to storage unit . However some primitives may be written to storage unit only to be written over by one or more other primitives causing unnecessary shading to be carried out by shader processors .

Accordingly the process of determining visibility information and performing tile based rendering is typically most beneficial in situations in which at least a portion of an image has a relatively large amount of overdraw. That is the ability to skip invisible primitives and reduce the shading load may outweigh latencies associated with the load and resolve stages of tile based rendering in areas of an image exhibiting a relatively large amount of overdraw. Conversely in instances in which there is a small amount of overdraw the ability to directly store data to storage unit direct rendering may outweigh the latencies associated with the load and resolve stages of tile based rendering.

As shown in most of objects are positioned toward the left side of image . In addition only certain portions of objects are subject to overdraw. For example only the top portions of objects e.g. the tops of the trees in bin are subject to overdraw. The remaining portions of image are not subject to a significant amount of overdraw.

By implementing tile based rendering for rendering bins with a visibility stream GPU may render fewer primitives than would be required for direct rendering. That is in the areas of bin having overdraw GPU may use visibility streams to skip primitives associated with the occluded portions of objects . However the portions of objects associated with bins have little or no overdraw.

In general GPU driver cannot alter visibility streams generated by GPU and is locked into generating a command stream to render image according to the initial binning configuration. That is despite bins having little or no overdraw GPU driver may not switch from tile based rendering to direct rendering on the fly. Moreover GPU driver may not change the arrangement of the bins.

The techniques of this disclosure generally relate to utilizing visibility information to optimize rendering. For example as described below with respect to the manner in which to render image may be dynamically determined based on visibility information.

According to aspects of this disclosure GPU may generate heuristic data in addition to the visibility streams when performing the initial binning pass. The heuristic data may include for example the number of primitives in each of the bins the number of visible primitives in each of the bins the number of invisible primitives in each of the bins the size of the primitives and the like. In some examples GPU may also generate a visibility score based on the heuristic data and or visibility streams. The visibility score may indicate a complexity of a bin a relative amount of overdraw of a bin and the like.

GPU may send the visibility information e.g. visibility streams heuristic data and or visibility scores to GPU driver . According to aspects of this disclosure GPU driver may revise the binning configuration based on the visibility information. For example rather than being locked into the initial binning configuration GPU driver may dynamically determine a revised binning configuration to optimize rendering.

In the example of the revised binning configuration includes directly rendering bins from the initial binning configuration shown in . For example GPU driver may determine characteristics of the original bins based on the visibility information. That is GPU driver may determine that bin bin and bin of the original binning configuration have few primitives to be rendered and do not include a large amount of overdraw.

GPU driver may revise the binning configuration to render bin bin and bin of the original binning configuration using direct rendering. For example GPU driver may generate instructions for rendering bin which includes objects with overdraw using tile based rendering and rendering bins which have few primitives and little overdraw using direct rendering. Accordingly GPU driver drops bins from the tile based rendering passes and instead issues instructions for GPU to render such bins using direct rendering.

In this way GPU driver optimizes the rendering pass of image . For example tile based rendering is used to render portions of image in which the benefit of occluded primitive skipping outweighs the costs associated with the load and resolve stages. In addition direct rendering is used to render portions of image in which the load and resolve stages introduce unnecessary latency.

As noted above with respect to according to aspects of this disclosure GPU driver may revise a binning configuration based on received visibility information. For example rather than being locked into the initial binning configuration GPU driver may dynamically determine a revised binning configuration to optimize rendering.

GPU driver may initially determine characteristics of the original bins based on the visibility information. That is GPU driver may determine that bin bin and bin of the original binning configuration have few primitives to be rendered and do not include a large amount of overdraw. GPU driver may then generate a new binning configuration with an alternative arrangement of bins.

In the example of GPU driver may determine a new bin that includes objects . For example GPU driver may merge portions of the visibility streams for original bins to generate a visibility stream for new bin . In this way GPU driver may alter the boundaries of original bins to encompass objects .

Accordingly GPU driver may position new bin to encompass the most complex area of image while designating other portions of image to be directly rendered direct . In some examples GPU driver may use the visibility information to merge visibility streams until a predetermined complexity metric is attained. For example GPU driver may merge portions of the initial configuration of bins based on a restricted region growing algorithm. If the complexity metric cannot be attained GPU driver may designate the remaining portions of the bins to be directly rendered.

In the example of GPU driver may implement a region growing algorithm that begins growing a region around objects . GPU driver may continue growing the region until a predetermined bin size has been achieved thereby creating new bin . GPU driver may then begin another region growing algorithm. Because the remaining portion of image is not complex e.g. has relatively few primitives with relatively little overdraw GPU driver may designate the remaining portion of image to be directly rendered with no binning and or visibility information .

In this way GPU driver optimizes the rendering pass of image . For example tile based rendering is used to render portions of image in which the benefit of occluded primitive skipping outweighs the costs associated with the load and resolve stages. In addition direct rendering is used to render portions of image in which the load and resolve stages introduce unnecessary latency.

According to some examples GPU driver may utilize a particular binning arrangement for more than one image frame . For example with respect to upon optimizing the rendering pass for image GPU driver may apply the optimized binning configuration associated with image to one or more other images in a sequence of images. That is in recognition that portions of an image may not change significantly in a sequence of images e.g. background objects GPU driver may utilize the optimized binning configuration for image as an initial binning configuration for one or more subsequent images. In this way GPU driver may only perform the optimization described with respect to for a subset of images in a sequence of images.

While the examples shown in are described with respect to computing device it should be understood that the techniques may be performed by a variety of other computing devices having a variety of other components.

In the example of GPU driver executed by CPU initially generates an initial command stream with an initial binning configuration for rendering graphics data . For example GPU driver may be configured to determine a bin size based on the configuration of GPU such as a size of GPU memory . GPU driver may also be configured to apply a predetermined bin arrangement using bins of the determined bin size.

GPU may then determine visibility streams for the initial binning configuration . For example GPU may process the command stream to generate primitives of the image being rendered. GPU may also distribute the primitives to the bins of the initial binning configuration. GPU may generate visibility streams to indicate which primitives are visible in each bin.

According to aspects of this disclosure GPU may also generate heuristic data for the bins of the initial binning configuration . The heuristic data may include for example the number of primitives in each of the bins the number of visible primitives in each of the bins the number of invisible primitives in each of the bins the size of the primitives and the like. In some examples GPU may use the visibility streams and or heuristic data to assign a visibility score to each bin. The visibility score may indicate a complexity of the bin an amount of overdraw of the bin and the like.

GPU driver may receive the visibility streams and heuristic data and may analyze the visibility information . For example GPU driver may determine the complexity of the image identify areas of the image having overdraw and the like. GPU driver may also use the visibility information to generate a second command stream different form the initial command stream for rendering the data based on visibility streams and or heuristic data . For example GPU driver may designate one or more of the bins from the initial binning configuration to be directly rendered. In another example GPU driver may generate a new binning configuration different from the initial binning configuration that includes one or more new bins.

GPU may receive the second command stream and render the image based on the second command stream . That is GPU may determine pixel values for pixels of the image using the second command stream and may output the image for presentation.

It should be understood that the steps shown in are provided as merely one example. That is the steps shown in need not necessarily be performed in the order shown and fewer additional or alternative steps may be performed. Moreover while certain functions are ascribed to GPU driver and GPU such functions may be performed by different components. For example according to an alternative aspect GPU driver may be responsible for generating heuristic data from raw visibility streams rather than GPU as described above.

In addition is described with respect to an initial binning configuration and a revised binning configuration. The techniques of this disclosure are not limited in this way. For example GPU may generate visibility information for an entire image without considering an initial binning configuration. In this example GPU driver may generate an optimal command stream for rendering the data based on visibility information for the entire image.

In the example of a GPU such as GPU receives a command stream having an initial binning configuration for rendering an image of graphics data . The command stream may include instructions describing the image. GPU may generate one or more visibility streams for the initial binning configuration . For example GPU may generate primitives for the image using the command stream. GPU may identify visible primitives in the image and indicate the visible primitives in a command stream using a series of flags. Visibility streams may be generated on a bin by bin basis or for the entire image.

GPU may also decode the generated visibility streams . For example GPU may generate data describing the bins. That is GPU may indicate a number of primitives in each bin a number of visible primitives in each bin a number of invisible primitives in each bin a size of the primitives and the like. In some instances GPU may also assign a score to the bins. The score may indicate an overall complexity of each bin an amount of overdraw for each bin and the like. GPU may provide this decoded visibility data with the visibility streams e.g. appended to the end of the visibility streams or may provide the decoded visibility data separately.

GPU may determine whether to render the image using the initial binning configuration or whether to use a revised binning configuration during rendering . For example GPU may receive a command stream for rendering the image that has a different binning configuration than the initial binning configuration. The different binning configuration may be based on the visibility streams and or the data describing the bins decoded visibility streams . The determination may be made based on an instruction from a driver issuing the command stream for rendering the image such as GPU driver .

If a revised binning configuration is used the yes branch of step GPU may receive a revised binning configuration based on the visibility streams and decoded visibility stream data . GPU may then render the image using the revised binning configuration . If a revised binning configuration is not used the no branch of step GPU may render the image using the initial binning configuration .

It should be understood that the steps shown in are provided as merely one example. That is the steps shown in need not necessarily be performed in the order shown and fewer additional or alternative steps may be performed.

In the example of a GPU driver such as GPU driver may receive visibility information associated with bins of an image being rendered by a GPU such as GPU . The visibility information may include for example one or more visibility streams as well as decoded visibility data. For example GPU driver may receive data indicating a number of primitives in each bin data indicating a number of visible primitives in each bin data indicating a number of invisible primitives in each bin data indicating a size of the primitives and the like. In some instances GPU driver may also receive a score for each bin. The score may indicate an overall complexity of each bin an amount of overdraw for each bin and the like.

GPU driver may analyze the visibility information . In some examples GPU driver may merge visibility streams until a predetermined complexity metric is attained. For example GPU driver may merge portions of visibility streams based on a restricted region growing algorithm. In other examples GPU driver may compare a received visibility score to a threshold.

GPU driver may also determine a distribution of primitives to bins based on the analysis . For example GPU driver may designate areas of an image having a relatively large amount of overdraw for tile based rendering. In this example GPU driver may generate one or more bins encompassing the designated areas. In addition GPU driver may generate one or more visibility streams for the bins. These bins may be used by GPU to perform tile based rendering for the designated areas. GPU driver may also designate areas having a relatively small amount of overdraw for direct rendering. In these areas GPU driver may not generate visibility streams as such information is not required for direct rendering.

GPU driver may in some instances generate an initial binning configuration upon which the received visibility information from step is generated. In this example GPU driver may determine whether to implement the initial binning configuration or whether to revise the binning configuration based on the analysis.

For example GPU driver may designate one or more bins of the initial binning configuration for direct rendering based on the analysis above. That is GPU driver may designate bins to be directly rendered or tile based rendered based on the complexity metric or visibility scores described above. In an example for purposes of illustration if a visibility score is above a predetermined threshold e.g. indicating high complexity and or a large amount of overdraw GPU driver may designate the bin to be tile based rendered. In contrast if the visibility score is below the threshold e.g. indicating few primitives and or little overdraw GPU driver may designate the bin to be directly rendered.

In another example GPU driver may discard the initial binning configuration in favor of a new binning configuration. In this example GPU driver may generate one or more new bins based on the analysis. In addition GPU driver may generate one or more visibility streams for the bins as noted above.

After determining the distribution of primitives to bins GPU driver may generate a command stream with instructions for rendering the image according to the determined binning configuration . The command stream may be executed by GPU to render the image.

It should be understood that the steps shown in are provided as merely one example. That is the steps shown in need not necessarily be performed in the order shown and fewer additional or alternative steps may be performed.

It should also be understood that depending on the example certain acts or events of any of the methods described herein can be performed in a different sequence may be added merged or left out all together e.g. not all described acts or events are necessary for the practice of the method . Moreover in certain examples acts or events may be performed concurrently e.g. through multi threaded processing interrupt processing or multiple processors rather than sequentially.

In one or more examples the functions described may be implemented in hardware software firmware or any combination thereof. If implemented in software the functions may be stored as one or more instructions or code on an article of manufacture comprising a non transitory computer readable medium. Computer readable media may include computer data storage media. Data storage media may be any available media that can be accessed by one or more computers or one or more processors to retrieve instructions code and or data structures for implementation of the techniques described in this disclosure. By way of example and not limitation such computer readable media can comprise RAM ROM EEPROM CD ROM or other optical disk storage magnetic disk storage or other magnetic storage devices flash memory or any other medium that can be used to carry or store desired program code in the form of instructions or data structures and that can be accessed by a computer. Disk and disc as used herein includes compact disc CD laser disc optical disc digital versatile disc DVD floppy disk and blu ray disc where disks usually reproduce data magnetically while discs reproduce data optically with lasers. Combinations of the above should also be included within the scope of computer readable media.

The code may be executed by one or more processors such as one or more DSPs general purpose microprocessors ASICs FPGAs or other equivalent integrated or discrete logic circuitry. In addition in some aspects the functionality described herein may be provided within dedicated hardware and or software modules. Also the techniques could be fully implemented in one or more circuits or logic elements.

The techniques of this disclosure may be implemented in a wide variety of devices or apparatuses including a wireless handset an integrated circuit IC or a set of ICs e.g. a chip set . Various components modules or units are described in this disclosure to emphasize functional aspects of devices configured to perform the disclosed techniques but do not necessarily require realization by different hardware units. Rather as described above various units may be combined in a codec hardware unit or provided by a collection of interoperative hardware units including one or more processors as described above in conjunction with suitable software and or firmware.

Various examples have been described. These and other examples are within the scope of the following claims.

