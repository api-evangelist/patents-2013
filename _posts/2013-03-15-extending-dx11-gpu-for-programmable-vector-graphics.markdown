---

title: Extending DX11 GPU for programmable vector graphics
abstract: The present disclosure provides for path rendering including receiving, with a graphics processing unit (GPU), data indicative of a path segment of a path to be rendered. The systems and methods render the path segment by performing a fill of the path segment, which includes tessellating the path segment into a first plurality of primitives including a triangle per primitive, storing a first plurality of primitives in a stencil buffer, and drawing a bounding box of the path segment and rendering the bounding box with a stencil test enabled. The systems and methods also stroke the path segment, including tessellating the path into a second plurality of primitives, re-tessellating the second plurality of primitives, cutting the second plurality of primitives according to a dash pattern, creating a cap at a location of a cut, and creating a triangulation of a stroke and rasterizing the stroke based on the triangulation.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09330495&OS=09330495&RS=09330495
owner: QUALCOMM Incorporated
number: 09330495
owner_city: San Diego
owner_country: US
publication_date: 20130315
---
This application claims the benefit of U.S. Provisional Application No. 61 681 498 filed Aug. 9 2012 U.S. Provisional Application No. 61 713 377 filed Oct. 12 2012 U.S. Provisional Application No. 61 723 274 filed Nov. 6 2012 U.S. Provisional Application No. 61 755 312 filed Jan. 22 2013 U.S. Provisional Application No. 61 755 359 filed Jan. 22 2013 and U.S. Provisional Application No. 61 755 391 filed Jan. 22 2013 the entire content each of which is incorporated herein by reference.

This disclosure relates to techniques for graphics processing and more particularly to techniques for path rendering with a graphics processing unit.

Visual content for a display may be generated using path rendering techniques for vector graphics. Path rendering may refer to the rendering of two dimensional 2D vector graphics paths alternatively referred to herein as paths each of which may include one or more path segments. When a path includes two or more path segments the individual path segments may be of the same type or of different types. The types of path segments may include for example a line an elliptic arc a quadratic B zier curve and a cubic B zier curve. In some examples the path segment types may be defined in accordance with a standard vector graphics application programming interface API such as e.g. the Open Vector Graphics OpenVG API.

Path rendering is typically implemented by a central processing unit CPU . However such an approach may be CPU intensive and may therefore limit the amount of CPU processing cycles available for other CPU tasks. Conventional techniques for vector graphics including path rendering may be implemented entirely in a CPU or partially in the CPU and partially in a GPU.

The present disclosure provides for systems and method of for path rendering including drawing a path segment filling the path segment including 1 tessellating the path into line segments 2 rasterizing and scan filling using a cell buffer and 3 drawing a bounding box of the path using a fill color and a stencil from the cell buffer and stroking the path segment including 1 tessellating the path into line segments 2 cutting the line segments according to a dash pattern and 3 creating a triangulation of a stroke and rasterize the stroke.

In one example the disclosure describes a method that includes receiving with a graphics processing unit GPU data indicative of a path segment of a path to be rendered rendering the path segment with the GPU by performing a fill of the path segment filling the path segment including tessellating the path segment into a first plurality of primitives including a triangle per primitive storing a first plurality of primitives in a stencil buffer and drawing a bounding box of the path segment and rendering the bounding box with a stencil test enabled and stroking the path segment including tessellating the path into a second plurality of primitives re tessellating the second plurality of primitives cutting the second plurality of primitives according to a dash pattern creating a cap at a location of a cut and creating a triangulation of a stroke and rasterizing the stroke based on the triangulation.

In another example the disclosure an apparatus configured to perform graphics processing including a graphics processing unit configured to receive data indicative of a path segment of a path to be rendered and render the path segment by performing a fill of the path segment the fill including tessellate the path segment into a first plurality of primitives including a triangle per primitive storing a first plurality of primitives in a stencil buffer and draw a bounding box of the path segment and render the bounding box with a stencil test enabled and stroke the path segment including tessellate the path into a second plurality of primitives re tessellate the second plurality of primitives cut the second plurality of primitives according to a dash pattern create a cap at a location of a cut create a triangulation of a stroke and rasterizing the stroke based on the triangulation.

In another example the disclosure describes an apparatus including means for receiving data indicative of a path segment of a path to be rendered means for rendering the path segment by performing a filling of the path segment the means for filling the path segment including means for tessellating the path segment into a first plurality of primitives including a triangle per primitive means for storing a first plurality of primitives in a stencil buffer and means for drawing a bounding box of the path segment and means for rendering the bounding box with a stencil test enabled and means for stroking the path segment including means for tessellating the path into a second plurality of primitives means for re tessellating the second plurality of primitives means for cutting the second plurality of primitives according to a dash pattern means for creating a cap at a location of a cut and means for creating a triangulation of a stroke and rasterizing the stroke based on the triangulation.

In another example the disclosure describes a computer readable storage medium. The computer readable storage medium having stored thereon instructions that upon execution cause one or more processors to receive data indicative of a path segment of a path to be rendered and render the path segment by perform a fill of the path segment the fill including tessellate the path segment into a first plurality of primitives including a triangle per primitive storing a first plurality of primitives in a stencil buffer and draw a bounding box of the path segment and render the bounding box with a stencil test enabled and tessellating the path into a second plurality of primitives re tessellate the second plurality of primitives cutting the second plurality of primitives according to a dash pattern create a cap at a location of a cut and creating a triangulation of a stroke and rasterizing the stroke based on the triangulation.

In one example the disclosure describes a method that includes receiving with a graphics processing unit GPU data indicative of a path segment of a path to be rendered and rendering the path segment with the GPU by performing a fill of the path segment filling the path segment including tessellating the path segment into a first plurality of primitives rasterizing and scan filling the path segment based on the first plurality of primitives using a cell buffer and drawing a bounding box of the path segment and a stencil from the cell buffer.

The details of one or more examples are set forth in the accompanying drawings and the description below. Other features objects and advantages will be apparent from the description and drawings and from the claims.

This disclosure is directed to techniques for using a graphics processing unit GPU to perform path rendering. Path rendering may refer to the rendering of two dimensional 2D vector graphics paths alternatively referred to herein as paths each of which may include one or more path segments. When a path includes two or more path segments the individual path segments may be of the same type or of different types. The types of path segments may include for example a line an elliptic arc a quadratic B zier curve and a cubic B zier curve. In some examples the path segment types may be defined in accordance with a standard vector graphics application programming interface API such as e.g. the Open Vector Graphics OpenVG API.

As discussed above conventional techniques for vector graphics including path rendering are implemented entirely in a CPU or partially in the CPU and partially in a GPU. Neither of these implementations allow for a single pass in the GPU. Additionally neither implementation completely offloads vector graphics processing from the CPU. One is entirely based in the CPU while the other uses both the CPU and the GPU.

As discussed it can be undesirable to perform vector graphics processing in the CPU because such processing may be processor intensive and accordingly may limit the number of processing cycles in the CPU available to perform other functions. Additionally in many cases CPUs may consume more power when compared to GPUs. As many mobile devices may be battery powered lower power consumption may be advantageous. Further CPUs may not allow for as much parallel processing e.g. for a comparable priced GPU . Generally CPUs may also be more expensive when compared to GPUs.

Examples described herein provide systems and methods that may be applied to for example existing Microsoft DirectX11 compliant hardware or equivalent hardware supporting tessellation for example by modifying the example system as described herein to allow for path rendering which may be used in vector graphics processing. In an example this disclosure provides for a single pass solution using the DirectX11 pipeline stages. Such an example may completely offload vector graphics processing from the CPU. Additionally the disclosed techniques provide for programmable vector graphics processing as existing shader in the GPU and may be used to support other primitive types and joint end rules.

GPUs typically implement a three dimensional 3D graphics pipeline that is designed to be compliant with one or more 3D graphics APIs. Because the prevailing 3D graphics APIs in use today do not require that compliant devices support path rendering commands modern GPUs often provide little to no hardware acceleration for path rendering commands. For example a typical 3D graphics pipeline implemented in a modern GPU may include a rasterizer that is designed to rasterize low order non curved 3D graphics primitives such as e.g. points lines and triangles but is not capable of directly rendering curved path rendering primitives such as e.g. elliptic arcs and B zier curves .

One approach for path rendering uses a GPU pipeline to provide partial GPU hardware acceleration for the execution of path rendering commands. Some examples may avoid pre processing completely. In an example implementation a first vertex of a path may be used as the pivot point for filling. Additional hardware may be added to a GPU in a setup engine to compute minimum coordinates and maximum coordinates of path vertices. These minimum and maximum values may be used to determine the bounding box shape.

One approach for path rendering uses a modern 3D GPU pipeline to provide partial GPU hardware acceleration for the execution of path rendering commands. This approach involves preprocessing a path segment with a central processing unit CPU in order to convert the path segment into one or more low order non curved 3D graphics primitives that can be rasterized by the GPU. For example a CPU may tessellate a curved path segment e.g. an elliptical arc or a B zier curve into a set of relatively small triangles that approximates the curvature of the path segment and may cause the set of triangles to be rendered using the GPU. Such an approach however may be CPU intensive and may therefore limit the amount of CPU processing cycles available for other CPU tasks. Moreover in some cases a relatively large amount of triangles may be needed to render the path segment at a desired level of detail. The relatively large amount of triangles may consume a significant amount of memory storage space when storing the data and may consume a significant amount of memory bandwidth when transferring the data to the GPU.

Another approach for providing partial to total GPU hardware acceleration for the execution of path rendering commands may involve modifying the architecture of the GPU to support a dedicated hardware accelerated path rendering pipeline. However because the prevailing 3D graphics APIs e.g. the Microsoft DirectX 11 API do not require a GPU architecture to include a dedicated path rendering pipeline such an approach does not result in a cross platform hardware accelerated path rendering solution that would be guaranteed to be supported by all GPUs which are compliant with a particular 3D graphics API e.g. the DirectX DX 11 API .

The path rendering techniques in this disclosure may provide a GPU hardware accelerated path rendering solution where the GPU is configured to tessellate a received indication of a path segment into a plurality of line segments and to render the tessellated line segments using a 3D graphics pipeline. By using the GPU to tessellate a path segment into line segments the burden of preprocessing path segments is lifted from the CPU thereby freeing up processing resources for other CPU tasks. Moreover the GPU may in some examples utilize a highly parallel modern GPU tessellation architecture to perform the tessellation operations which may in some examples allow the GPU to tessellate a path segment in a more efficient manner than the CPU. In addition because the tessellation occurs in the GPU rather than in the CPU a multitude of tessellated primitives do not need to be stored in system memory and do not need to be passed from the CPU to the GPU thereby reducing the memory footprint needed for path rendering as well as the memory bandwidth needed for path rendering.

Tessellating the path segment may include tessellating the path segment using a fixed function tessellation engine of the GPU and a domain shader program executing on a shader unit of the GPU. Additionally in an example a cell buffer may be used. The cell buffer may be a memory that includes a number of cells. For example the cell buffer may be a sixteen by sixteen grid of sub pixels. One cell may represent one pixel in a final image. The cell buffer may contain a matrix of x y cells with one cell representing one pixel in a final image each cell in the cell buffer storing winding counter information and wherein the cell buffer is the same size as a frame buffer.

In one example every cell in the cell buffer represents one pixel in the final image. Every cell may store a winding counter information. Cell buffer size may be as big as the frame buffer size but memory requirements may limit some examples. Accordingly the frame buffer may be split into a number x y of tiles of pixels with the cell buffer size is x y cells. A device may draw one tile at a time and then carry the winding counter information on the last column rightmost to the next tile the one to the right . If the current tile is the first one in a row there is no previous tile hence there is no carryover. For these tiles rasterized lines may be clamped to the first column.

In some examples the GPU may be configured to tessellate and render a path segment using a graphics architecture that is specified by a particular 3D graphics API such as e.g. the DirectX 11 API without requiring any additional hardware components and or modifications to the graphics architecture. By utilizing only architectural features likely or guaranteed to be present by a particular 3D graphics API when performing path rendering in such examples a cross platform hardware accelerated path rendering solution may be realized that is capable of being implemented on any device that is compliant with the 3D graphics API. For example the techniques of this disclosure may in some examples provide a path rendering solution that is capable of being used on any DirectX 11 compliant graphics hardware. In some examples some path rendering techniques e.g. dashing and cusp handling may be disabled in order to implement a DirectX 11 path rendering solution that utilizes the DirectX 11 architecture without any modifications.

Path rendering may be divided into two main operations 1 filling a path segment and 2 stroking a path segment. In some examples one or both of the filling and stroking operations may be performed to completely render a path. The filling operation may be configured to fill the interior region of a path segment with a specified fill color. The stroking operation may be configured to widen the edges of a path segment by working outward perpendicularly to the path. In addition to the main operations path rendering may also involve applying various types of end caps to the ends of a path and applying various types of joins between the endpoints of interior path segments of a path to create a smooth path.

After a path segment has been tessellated a GPU that implements the path rendering techniques of this disclosure may be configured to generate 3D geometry corresponding to the tessellated path segment that allows one or both of a fill area for the path segment and a stroke area for the path segment to be rendered by the GPU. The 3D geometry may include low order non curved 3D graphics primitives e.g. triangles that are capable of being rasterized by existing 3D rasterization engines. By rendering the fill areas and or stroke areas for a path segment based on the 3D geometry that is generated by a GPU from a plurality of tessellated line segments that approximate a path to be rendered a 3D GPU pipeline may be used to provide either a 100 or a nearly 100 GPU solution for the execution of filling and stroking operations.

In some examples to implement these methods in for example a DirectX11 pipeline architecture or other similar 3D graphics pipelines may be modified according to the techniques of this disclosure to include a number of extensions. For example the DirectX11 pipeline may be modified to include a path primitive. The path primitive may allow the DirectX11 pipeline to process vector graphics by allowing for path rendering directly in a GPU implementing DirectX11 without using a separate CPU. For example the path primitive may allow for filling stroking or both using the methods described herein.

As illustrated in the example of computing device includes a user interface a CPU a memory controller a memory a graphics processing unit GPU a GPU cache a display interface a display and bus . User interface CPU memory controller GPU and display interface may communicate with each other using bus . It should be noted that the specific configuration of buses and communication interfaces between the different components illustrated in is merely exemplary and other configurations of computing devices and or other graphics processing systems with the same or different components may be used to implement the techniques of this disclosure.

CPU may comprise a general purpose or a special purpose processor that controls operation of computing device . A user may provide input to computing device to cause CPU to execute one or more software applications. The software applications that execute on CPU may include for example an operating system a word processor application an email application a spread sheet application a media player application a video game application a graphical user interface application or another program. The user may provide input to computing device via one or more input devices not shown such as a keyboard a mouse a microphone a touch pad or another input device that is coupled to computing device via user interface .

The software applications that execute on CPU may include one or more graphics rendering instructions that instruct GPU to cause the rendering of graphics data to display . In some examples the software instructions may conform to a graphics application programming interface API such as e.g. an Open Graphics Library OpenGL API an Open Graphics Library Embedded Systems OpenGL ES API a Direct3D API a DirectX API a RenderMan API a WebGL API or any other public or proprietary standard graphics API. In order to process the graphics rendering instructions CPU may issue one or more graphics rendering commands to GPU to cause GPU to perform some or all of the rendering of the graphics data. In some examples the graphics data to be rendered may include a list of graphics primitives e.g. points lines triangles quadralaterals triangle strips patches etc. In further examples the graphics data to be rendered may include one or more path rendering primitives such as e.g. a line segment an elliptic arc a quadratic B zier curve and a cubic B zier curve.

The present disclosure provides for systems and method of for path rendering including drawing a path segment filling the path segment including 1 tessellating the path into line segments 2 rasterizing and scan filling using a cell buffer and 3 drawing a bounding box of the path using a fill color and a stencil from the cell buffer and stroking the path segment including 1 tessellating the path into line segments 2 cutting the line segments according to a dash pattern and 3 creating a triangulation of a stroke and rasterize the stroke. In some examples one or more of these functions may be performed by GPU . For example in various implementations none of these are performed in the CPU.

Memory controller facilitates the transfer of data going into and out of memory . For example memory controller may receive memory read requests and memory write requests from CPU and or GPU and service such requests with respect to memory in order to provide memory services for the components in computing device . Memory controller is communicatively coupled to memory . Although memory controller is illustrated in the example computing device of as being a processing module that is separate from both CPU and memory in other examples some or all of the functionality of memory controller may be implemented on one or more of CPU GPU and memory .

Memory may store program modules and or instructions that are accessible for execution by CPU and or data for use by the programs executing on CPU . For example memory may store user applications and graphics data associated with the applications. Memory may also store information for use by and or generated by other components of computing device . For example memory may act as a device memory for GPU and may store data to be operated on by GPU as well as data resulting from operations performed by GPU . For example memory may store any combination of path data path segment data surfaces texture buffers depth buffers cell buffers vertex buffers frame buffers or the like. In addition memory may store command streams for processing by GPU . For example memory may store path rendering commands 3D graphics rendering commands and or general purpose GPU computing commands. Memory may include one or more volatile or non volatile memories or storage devices such as for example random access memory RAM static RAM SRAM dynamic RAM DRAM synchronous dynamic random access memory SDRAM read only memory ROM erasable programmable ROM EPROM electrically erasable programmable ROM EEPROM Flash memory a magnetic data media or an optical storage media.

GPU may be configured to execute commands that are issued to GPU by CPU . The commands executed by GPU may include graphics commands draw call commands GPU state programming commands memory transfer commands general purpose computing commands kernel execution commands etc. The memory transfer commands may include e.g. memory copy commands memory compositing commands and block transfer blitting commands.

In some examples GPU may be configured to perform graphics operations to render one or more graphics primitives to display . In such examples when one of the software applications executing on CPU requires graphics processing CPU may provide graphics data to GPU for rendering to display and issue one or more graphics commands to GPU . The graphics commands may include e.g. draw call commands GPU state programming commands memory transfer commands blitting commands etc. The graphics data may include vertex buffers texture data surface data etc. In some examples CPU may provide the commands and graphics data to GPU by writing the commands and graphics data to memory which may be accessed by GPU .

In further examples GPU may be configured to perform general purpose computing for applications executing on CPU . In such examples when one of the software applications executing on CPU decides to off load a computational task to GPU CPU may provide general purpose computing data to GPU and issue one or more general purpose computing commands to GPU . The general purpose computing commands may include e.g. kernel execution commands memory transfer commands etc. In some examples CPU may provide the commands and general purpose computing data to GPU by writing the commands and graphics data to memory which may be accessed by GPU .

GPU may in some instances be built with a highly parallel structure that provides more efficient processing of vector operations than CPU . For example GPU may include a plurality of processing elements that are configured to operate on multiple vertices control points pixels and or other data in a parallel manner. The highly parallel nature of GPU may in some instances allow GPU to render graphics images e.g. GUIs and two dimensional 2D and or three dimensional 3D graphics scenes onto display more quickly than rendering the images using CPU . In addition the highly parallel nature of GPU may allow GPU to process certain types of vector and matrix operations for general purposed computing applications more quickly than CPU .

GPU may in some examples be integrated into a motherboard of computing device . In other instances GPU may be present on a graphics card that is installed in a port in the motherboard of computing device or may be otherwise incorporated within a peripheral device configured to interoperate with computing device . In further instances GPU may be located on the same microchip as CPU forming a system on a chip SoC . GPU may include one or more processors such as one or more microprocessors application specific integrated circuits ASICs field programmable gate arrays FPGAs digital signal processors DSPs or other equivalent integrated or discrete logic circuitry.

In some examples GPU may be directly coupled to GPU cache . Thus GPU may read data from and write data to GPU cache without necessarily using bus . In other words GPU may process data locally using a local storage instead of off chip memory. This allows GPU to operate in a more efficient manner by eliminating the need of GPU to read and write data via bus which may experience heavy bus traffic. In some instances however GPU may not include a separate cache but instead utilize memory via bus . GPU cache may include one or more volatile or non volatile memories or storage devices such as e.g. random access memory RAM static RAM SRAM dynamic RAM DRAM erasable programmable ROM EPROM electrically erasable programmable ROM EEPROM Flash memory a magnetic data media or an optical storage media.

CPU and or GPU may store rendered image data in a frame buffer that is allocated within memory . The rendered image data may include rendered fill areas and stroke areas for a path segment to be rendered. Display interface may retrieve the data from the frame buffer and configure display to display the image represented by the rendered image data. In some examples display interface may include a digital to analog converter DAC that is configured to convert the digital values retrieved from the frame buffer into an analog signal consumable by display . In other examples display interface may pass the digital values directly to display for processing.

Display may include a monitor a television a projection device a liquid crystal display LCD a plasma display panel a light emitting diode LED array a cathode ray tube CRT display electronic paper a surface conduction electron emitted display SED a laser television display a nanocrystal display or another type of display unit. Display may be integrated within computing device . For instance display may be a screen of a mobile telephone handset or a tablet computer. Alternatively display may be a stand alone device coupled to computer device via a wired or wireless communications link. For instance display may be a computer monitor or flat panel display connected to a personal computer via a cable or wireless link.

Bus may be implemented using any combination of bus structures and bus protocols including first second and third generation bus structures and protocols shared bus structures and protocols point to point bus structures and protocols unidirectional bus structures and protocols and bidirectional bus structures and protocols. Examples of different bus structures and protocols that may be used to implement bus include e.g. a HyperTransport bus an InfiniBand bus an Advanced Graphics Port bus a Peripheral Component Interconnect PCI bus a PCI Express bus an Advanced Microcontroller Bus Architecture AMBA Advanced High performance Bus AHB an AMBA Advanced Peripheral Bus APB and an AMBA Advanced eXentisible Interface AXI bus. Other types of bus structures and protocols may also be used.

According to this disclosure GPU may be configured to provide partial to total GPU hardware acceleration for the execution of various path rendering commands. For example CPU may issue one or more path rendering commands to GPU and GPU may execute the path rendering commands. As one example CPU may issue to GPU one or more path filling commands that instruct GPU to perform a path filling operation and GPU may execute the path filling commands. As another example CPU may issue to GPU one or more path stroking commands that instruct GPU to perform a path stroking operation and GPU may execute the path stroking commands.

In some examples GPU may be configured to receive data indicative of a path segment of a path to be rendered tessellate the path segment into a plurality of primitives and render at least one of a fill area and a stroke area for the path segment based on the plurality of primitives. The GPU may render a fill area for the path segment when performing a fill operation and may render a stroke area for the path segment when performing a stroke operation. The plurality of primitives in some examples may be a plurality of line segments.

In some examples GPU may use a two pass rendering approach to perform a path filling operation. For example as part of a first rendering pass GPU may receive data indicative of a path segment of a path to be rendered tessellate the path segment into a plurality of line segments and generate a plurality of triangle primitives based on the plurality of lines segments. GPU may generate each of the plurality of triangle primitives based on a respective one of the plurality of line segments. GPU may render each of the plurality of triangle primitives into a cell buffer such that the cell buffer stores data indicative of which pixels are inside of the fill area for the path segment. After rendering the primitives into the common cell buffer GPU may perform a second rendering pass. During the second rendering pass GPU may render one or more primitives that encompass the pixels that are inside the fill area for the path segment based on the data stored in the cell buffer and a fill color to generate a rasterized version of the fill area for the path segment. In this manner GPU may provide GPU hardware acceleration for the performance of path filling operations.

To generate the plurality of triangle primitives GPU may in some examples generate the plurality of triangle primitives such that each of the triangle primitives has a common vertex that is common to i.e. the same for all of the triangle primitives for a path segment. In such examples GPU may generate the plurality of triangle primitives such that each of the triangle primitives has two additional vertices i.e. two vertices in addition to the common vertex that correspond to the endpoints of a respective one of the plurality of line segments. Each additional vertex may correspond to a respective one of the endpoints of a corresponding line segment.

To render each of the plurality of triangle primitives into a cell buffer GPU may use one of the following techniques. According to a first technique GPU may for each of the plurality of triangle primitives invert one or more values in stencil buffer that correspond to the respective triangle primitive. According to a second technique GPU may for each of the plurality of triangle primitives increment one or more values in stencil buffer that correspond to the respective triangle primitive if a vertex order for the respective triangle primitive is oriented in a clockwise direction.

In some cases GPU may be configured to use one or both of the following techniques to perform the path filling operation. According to a first technique GPU may tessellate the path segment into a plurality of line segments using a fixed function tessellation engine of GPU and a domain shader program executing on a programmable shader unit of GPU . According to as second technique GPU may generate the plurality of triangle primitives using a geometry shader program executing on a programmable shader unit of GPU . Using one or more of the tessellation engine domain shader and the geometry shader of GPU to perform the path filling operation may allow the path filling operation to be performed in some examples using a GPU that is compliant with an on chip tessellation enabled 3D graphics API e.g. the DX 11 API without requiring modification of the API or modification of the graphics architecture specified by the API.

In further examples GPU may use a single pass rendering approach to perform a path stroking operation. For example GPU may receive data indicative of a path segment of a path to be rendered tessellate the path segment into a plurality of line segments and generate a plurality of triangle primitives based on the plurality of lines segments. For each of the plurality of line segments GPU may generate one or more primitives e.g. triangle primitives that spatially correspond to a stroke area for the respective line segment and render the one or more primitives for the respective line segment based on a stroke color to generate a rasterized version of the stroke area for the path segment. In this manner GPU may provide GPU hardware acceleration for the performance of path stroking operations.

To generate one or more primitives e.g. triangle primitives that spatially correspond to a stroke area for the respective line segment GPU may in some examples generate a plurality of normal vertices for the respective line segment. Each of the normal vertices may be indicative of a normal vector that corresponds to a respective one of a plurality of points along the path segment. Each of the plurality of points along the path segment may correspond to a respective one of the endpoints of the respective line segment. GPU may determine corner points of a stroke area for the respective line segment based on the plurality of normal vertices and a stroke width. GPU may generate the one or more primitives that spatially correspond to the stroke area for the respective line segment based on the corner points of the stroke area.

In some cases GPU may use one or more of the following techniques to perform the path stroking operation. According to a first technique GPU may tessellate the path segment into a plurality of line segments using a fixed function tessellation engine of GPU and a domain shader program executing on a programmable shader unit of GPU . According to as second technique GPU may generate the one or more primitives using a geometry shader program executing on a programmable shader unit of GPU . According to a third technique GPU may generate the plurality of normal vertices using a domain shader program executing on a programmable shader unit of GPU . Using one or more of the tessellation engine domain shader and the geometry shader of GPU to perform the path stroking operation may allow the path stroking operation to be performed in some examples using a GPU that is compliant with an on chip tessellation enabled 3D graphics API such as e.g. the DX 11 API without requiring modification of the API or modification of the graphics architecture specified by the API.

The path rendering techniques described in this disclosure may be implemented in any of the components in computing device illustrated in including e.g. CPU GPU and memory . In some examples all or almost all of the path rendering techniques may be implemented in GPU e.g. in a graphics pipeline of GPU . In additional examples CPU may implement techniques for configuring the state of the graphics pipeline and binding shader programs to the graphics pipeline to implement a path rendering pipeline in GPU that performs the path rendering techniques of this disclosure. In further examples CPU may be configured to place data indicative of a path to be rendered into one or more buffers e.g. one or more vertex buffers that may be accessed by GPU to render one or more paths.

In some examples GPU may be configured for 1 tessellating the path into line segments 2 rasterizing and scan filling using a cell buffer and 3 drawing a bounding box of the path using a fill color and a stencil from the cell buffer and stroking the path segment including 1 tessellating the path into line segments 2 cutting the line segments according to a dash pattern and 3 creating a triangulation of a stroke and rasterize the stroke.

In some examples a relatively large amount of data may need to be transferred to a graphics processing unit GPU to render the path segment at a desired level of detail. The relatively large amount of data may consume a significant amount of memory storage space when storing the data and may consume a significant amount of memory bandwidth when transferring the data to the GPU.

CPU is configured to execute software application a graphics API a GPU driver and an operating system . Software application may include one or more instructions that cause graphics images to be displayed and or one or more instructions that cause a non graphics task e.g. a general purposed computing task to be performed on GPU . Software application may issue instructions to graphics API . Graphics API may be a runtime service that translates the instructions received from software application into a format that is consumable by GPU driver . GPU driver receives the instructions from software application via graphics API and controls the operation of GPU to service the instructions. For example GPU driver may formulate one or more commands place the commands into memory and instruct GPU to execute the commands . In some examples GPU driver may place the commands into memory and communicate with GPU via operating system e.g. via one or more system calls.

GPU includes a command engine and one or more processing units . In some examples the one or more processing units may form and or implement a 3D graphics rendering pipeline e.g. a DX 11 graphics rendering pipeline i.e. a 3D graphics pipeline that is compliant with the DX 11 graphics API. In one example in accordance with this disclosure may include a new primitive types supported in the GPU line quadratic cubic Bezier elliptic arc . Different types of primitives should be able to be packed into the same vertex buffer hence rendering them all in a single draw call. Dash pattern may be used as is new tessellator logic may be used to handle preprocessing the dash pattern. Having new primitive types and being able to pack different types of primitives into a single draw call will decrease the GPU input size and significantly increase the performance because of vertex reuse. Creating joins caps at IA stage may require some hardware modifications. The resulting join primitives may be use many indices due to potential repeated knots. This may also require primitive type as a system generated value available in different shader stages.

Command engine is configured to receive commands from CPU e.g. via memory and to cause GPU to execute the commands. In response to receiving a state command command engine may be configured to set one or more state registers in GPU to particular values based on the state command and or to configure one or more of the fixed function processing units based on the state command. In response to receiving a draw call command command engine may be configured to cause processing units to render the geometry represented by vertices in memory based on data indicative of the type of path to be rendered which may be contained in the vertex data structures of the vertex buffers to be rendered. Command engine may also receive shader program binding commands and load particular shader programs into one or more of the programmable processing units based on the shader program binding commands.

Processing units may include one or more processing units each of which may be a programmable processing unit or a fixed function processing unit. A programmable processing unit may include for example a programmable shader unit that is configured to execute one or more shader programs that are downloaded onto GPU from CPU . A shader program in some examples may be a compiled version of a program written in a high level shading language such as e.g. an OpenGL Shading Language GLSL a High Level Shading Language HLSL a C for Graphics Cg shading language etc. In some examples a programmable shader unit may include a plurality of processing units that are configured to operate in parallel e.g. an SIMD pipeline. A programmable shader unit may have a program memory that stores shader program instructions and an execution state register e.g. a program counter register that indicates the current instruction in the program memory being executed or the next instruction to be fetched. The programmable shader units in processing units may include for example vertex shader units pixel shader units geometry shader units hull shader units domain shader units compute shader units and or unified shader units.

A fixed function processing unit may include hardware that is hard wired to perform certain functions. Although the fixed function hardware may be configurable via one or more control signals for example to perform different functions the fixed function hardware typically does not include a program memory that is capable of receiving user compiled programs. In some examples the fixed function processing units in processing units may include for example processing units that perform raster operations such as e.g. depth testing scissors testing alpha blending etc.

In some examples a stencil buffer may be added to GPU implementing for example the DirectX11 architecture In an example output merger stage may be configured to populate stencil buffer such that stencil buffer stores values which are indicative of a fill area for the path segment according to one or more stencil buffer filling techniques.

In other examples a cell buffer that contains x y cells may be used. A cell buffer may be added to GPU implementing for example the DirectX11 architecture. Cell buffer may be a sixteen by sixteen grid of sub pixels e.g. x y 16. One cell may represent one pixel in the final image but cell name may be used to distinguish the cells and pixels as they store different information. In the example each cell in cell buffer stores sixteen bytes of winding counter information. Cell buffer may be the size of the frame buffer but normally the memory requirements of cell buffer would become too big. So the frame buffer may be split in to tiles of x y pixels and cells . This allows the drawing of the primitive one tile at a time.

Memory may store path data and one or more commands . In some examples path data may be stored as a plurality of vertices or control points in one or more vertex buffers allocated in memory . In some examples the path data may be stored in a patch list data structure e.g. a four control point patch list . Commands may be stored in one or more command buffers e.g. a ring buffer . CPU e.g. GPU driver via operating system may place path data and commands into memory for consumption by GPU . GPU e.g. command engine may retrieve and execute commands stored in memory .

In examples where path data is stored as vertices the vertices may include one or more attributes that geometrically define a path to be rendered. For example for a line the vertices in the patch control list may include data indicative of coordinates for the endpoints of the line e.g. x0 y0 and x1 y1 . For a cubic B zier curve the vertices in the patch control list may include data indicative of the coordinates of the four control points that define the curve e.g. x0 y0 x1 y1 x2 y2 x3 y3 . For a quadratic B zier curve the vertices in the patch control list may include data indicative of coordinates for three control points instead of four control points. For elliptic arcs the vertices in the patch control list may include data indicative of an endpoint parameterization of the elliptic arc or data indicative of a center parameterization of the elliptic arc.

CPU may also place data indicative of the type of path to be rendered i.e. path type data into one or more otherwise unused vertex coordinates in the vertex buffer. In some examples the different path types may correspond to a set of path types that are defined by a vector graphics API and are available for use by software application . In some examples the different path types may correspond to a set of path types that are defined by the OpenVG API.

In some cases the one or more attributes that geometrically define the path to be rendered may be resolution independent. In other words the attributes that geometrically define the path may be independent of the amount of tessellation to be performed to render the path segment and or the amount of vertices to be generated to render the path segment.

Commands may include one or more state commands and or one or more draw call commands. A state command may instruct GPU to change one or more of the state variables in GPU such as e.g. the draw color the fill color the stroke color etc. In some examples the state commands may include path rendering state commands that are configured to set one or more state variables associated with rendering a path. For example the state commands may include a paint mode command that is configured to indicate whether a path to be rendered is to be filled stroked or both. As another example the state commands may include a fill color command that specifies a color to be used for filling operations and or a stroke color command that specifies a color to be used for stroking operations. As a further example the state commands may specify one or more parameters for the stroke operation such as e.g. a stroke width an end cap style e.g. butt round square a line join style e.g. miter round bevel a miter limit etc. In some examples in addition to or in lieu of using a state command to set one or more state parameters the one or more of the state parameters may be set using one or more parameter values in a draw call command.

A draw call command may instruct GPU to render the geometry defined by a group of one or more vertices e.g. defined in a vertex buffer stored in memory . In some examples the draw call command may invoke GPU to render all of the vertices stored in a defined section e.g. buffer of memory . In other words once GPU receives the draw call command control is passed to GPU for rendering the geometry and primitives represented by the vertices in the defined section e.g. buffer of memory .

The draw call commands may include one or both of 3D draw call commands and path rendering draw call commands. For 3D rendering draw call commands the geometry defined by the group of one or more vertices in the vertex buffer may correspond to one or more 3D graphics primitives to be rendered e.g. points lines triangles quadralaterals triangle strips patches etc and the 3D rendering draw call command may instruct GPU to render the one or more 3D graphics primitives. For path rendering draw call commands the geometry defined by the group of one or more vertices in the vertex buffer may correspond to one or more path primitives to be rendered e.g. a line segment an elliptic arc a quadratic B zier curve and a cubic B zier curve etc and the path rendering draw call command may instruct GPU to render the one or more path primitives.

In some examples the path rendering techniques described in this disclosure may be implemented in any of the components illustrated in including e.g. graphics API GPU driver command engine and processing units . In some examples all or almost all of the path rendering techniques may be implemented in a graphics pipeline in GPU formed by processing units . In additional examples software application graphics API and or GPU driver of CPU may implement techniques for configuring the state of the graphics pipeline and binding shader programs to the graphics pipeline to implement a path rendering pipeline in GPU that performs the path rendering techniques of this disclosure. In further examples software application graphics API and or GPU driver of CPU may be configured to place data indicative of a path to be rendered into one or more buffers e.g. one or more vertex buffers that may be accessed by GPU to render one or more paths. In some examples GPU may be configured for 1 tessellating the path into line segments 2 rasterizing and scan filling using a cell buffer and 3 drawing a bounding box of the path using a fill color and a stencil from the cell buffer.

As illustrated in many of the pipeline stages may also be communicatively coupled to resources block. The resources block may include memory resources such as buffers and textures. The remaining blocks indicate pipeline stages. The blocks with straight corners represent fixed function pipeline stages and the blocks with rounded corners represent programmable stages. Each of the programmable stages may be configured to execute a shader program of a particular type. For example vertex shader may be configured to execute a vertex shader program hull shader may be configured to execute a hull shader program etc. Each of the different types of shader programs may execute either on a common shader unit of the GPU or on one or more dedicated shader units that are dedicated to executing shader programs of one or more particular types. Hull shader stage tessellator and domain shader stage may be collectively referred to as tessellation stages .

Additional background information regarding the general operation of the DirectX 11 graphics pipeline may be found at http msdn.microsoft.com en us library windows desktop ff476882 28v vs.85 29.aspx as of Nov. 26 2012 and is hereby incorporated by reference. Further information regarding the general operation of the DirectX 11 graphics pipeline may be found in Zink et al. Practical Rendering Computation with Direct3D 11 CRC Press 2011 the entire contents of which is incorporated herein by reference.

As illustrated in in some examples hull shader converts elliptical arcs from an endpoint representation to a parametrical representation. The input assembly IA stage creates endcaps and joins. IA may create join primitives where two path segments meet. IA may also create starting and ending caps for open paths. An open path is a path that does not enclose a region. To successfully create a join the join position and tangents of two path segments at the join position may be used. For a cap the position and tangents at the first and last points of the path may be used. Tangents of path segments may be found by simply subtracting control points however in case of repeated control points all control points may be processed to determine an endpoint tangent. In an example IA may have to put both path segments vertices into a join primitive. The worst case scenario may be where two cubic curves meet each having 4 vertices control points 1 shared so total of 7 vertices required for a join primitive from IA.

As discussed above the two main path rendering operations are 1 filling a path segment and 2 stroking a path segment. Solutions for performing each of these operations with a graphics rendering pipeline e.g. the DirectX 11 graphics pipeline will now be described.

In an example the path segment comprises a line and stroking comprises widening the line by thickening the line in two directions perpendicular to the line. Alternatively the path segment comprises a curve and stroking further may include splitting the curve into line segments determining a stroke width and creating a pair of triangle strips positioned to widen at least one of the line segments.

An example system of this disclosure provides an approximately 100 GPU solution for path rendering. Using the current GPU architecture e.g. an architecture operating in accordance with DirectX11 this may be inefficient. Using a modified GPU architecture may provide for an efficient GPU solution for path rendering.

As used herein a path comprises a number of path segments which may be for example a line an elliptic arc a quadratic B zier or a cubic B zier curve. A B zier curve is a type of parametric curve that can be scaled indefinitely. Additionally a path may or may not be closed. A closed path is one in which the last vertex of the path is connected to the first vertex of the path via a line and forms a closed shape. A path can overlap itself numerous times.

Path rendering can be divided into two main tasks 1 filling and 2 stroking. In some examples these tasks may be handled separately. Filling a path is defined as filling the interior region of a given path by the fill color. Stroking a path comprises widening the edges of the path using a straight line pen held perpendicularly to the path.

When filling a path the interior region of a given path may be filled by a color. The interior region of a path may be defined using either of the odd even or non zero fill rules. The odd even rule is an algorithm implemented in vector based graphics software which determines how a graphical shape with more than one closed outline will be filled. The odd even rule determines the insideness of a point by drawing a ray from the point to infinity in any direction and counting the number of path segments from the given shape that the ray crosses. If this number is odd the point is considered inside the curve and will be filled if even the point is considered outside the curve and will not be filled. Accordingly an area inside a curve is an area that will be filled to form a shape and an area outside a curve is an area that will not be filled to form a shape at least not for that particular shape . In two dimensional computer graphics the non zero winding rule is a means of determining whether a given point falls within an enclosed curve.

Some examples may use pre processing while other examples may include no pre processing. Centroid pivot point in pre processing may give us a slight increase in filling performance over first vertex pivot point. Determining bounding box in the GPU may require some hardware modifications. Converting elliptic arcs to parametrical form in hull shader will result in the conversion being done at every frame. An elliptic arc will need to go through hull shader conversion up to three times in a frame arc itself and two joins caps at arc endpoints .

Vertices may define a path consisting of a line segment a cubic segment another line segment and a quadratic segment. It may be a closed path i.e. encloses a region . Some examples may make the following API draw call 1 drawNonIndexedPrimType numIndices 7 closed true 2 primitive types will be the following list line cubic line quadratic 3 IA will start generating primitives based on the primitive types. Since this is a closed path there are no caps.

In an example the output may be as follows 1 PrimType Indices 2 line 0 1 3 Join Line Cubic 0 1 2 3 4 4 Cubic 1 2 3 4 5 Join Cubic Line 1 2 3 4 5 6 Line 4 5 7 Join Line Quadratic 4 5 6 0 8 Quadratic 5 6 0 9 Join Quadratic Line 5 6 0 1. Since we have 4 different types of path segments line quadratic cubic elliptic we have 4 different cap types and 4 4 16 different join primitive types.

In an example filling a path means filling the interior region of a given path by a given fill color. The interior region may be defined using either of the even odd or non zero fill rules. One example algorithm to handle filling a path is as follows 1 tessellate a given path into line segments 2 create a triangle per line segment using Geometry Shader by connecting the pivot point to line segments while honoring winding order. The clockwise or counterclockwise triangles are then rendered to stencil buffer . For Even Odd filling every triangle regardless of winding order will flip the stencil value of the interior region. For Non Zero filling clockwise triangles will increase and counterclockwise triangles will decrease the stencil value of the interior region. For both rules outer region remain unaffected. 3 pass 2 render the bounding box area with stencil test enabled. Stencil pass condition is stencil value 0 regardless of the fill rule. Passing stencil values are then reset to zero pass operation hence leaving us with a fresh stencil buffer of all zeros.

One example of filling may include the following flow 1 load constant buffer with fill color and pivot point per path 2 set appropriate stencil state even odd or non zero and 3 pass one draw call 4 Control Point Patch . Passing one draw call may include using vertex shader to transform vertices using hull shader Domain Isoline Output Type Line to determine optimum tessellation level or use fixed level tessellation using domain shader to compute tessellated vertices position only and using geometry shader to connect the input lines to the pivot point coordinates from the constant buffer to create clockwise and counterclockwise triangles. In some examples the pixel shader may be null.

An example may include a set to cover the stencil state. A second pass draw call may use a vertex shader to bypass the output from the vertex shader VS . In this instance the output from the VS is same as the input no operation is being done in the VS . The pixel shader may return fill color from the constant buffer. Additionally vertex shader VS may transform vertices using world view and projection matrices. Hull shader HS may determine tessellation level by using joins and caps collapsed cubics and degenerate ellipses with 0.0f Drop and lines 1.0f Note that a tessellation level of 0 indicates that primitive is dropped. For example in some cases some caps joins may be dropped. For line primitives tessellation level 1 may be used. A line does not need to tessellated into a plurality of new lines.

In an example the HS performs a transform. For arcs part of the vertex information are ellipse parameters to which it may be advantageous to avoid appling a transformation matrix. Some examples may calculate optimum tessellation level for cubics and elliptic arcs or use fixed tessellation.

In some examples the tessellation engine may be a Dx11 tessellator unit with isoline domain integer partitioning line output. In an example domain shader v may be ignored . Domain shader may evaluate tessellated vertices locations for lines cubics and elliptic arcs. For lines u is either 0.0f or 1.0f. In an example the tessellator may output two domain coordinates u and v. In some examples coordinate v may be ignored and coordinate u may be used to tessellate our primitive. The coordinate u is the parametrization from 0.0 to 1.0. If the tessellation factor is n u will be 0 n 1 n 2 n . . . n n.

Endpoints may be outputted directly. For curves u will range from 0.0f to 1.0f in equal increments depending on the tessellation level. For all u s position will be found using the curve representation equation. For elliptic arcs u will range from 0.0f to 1.0f in equal increments depending on the tessellation level. For all u s positions will be found using the arc parametric representation. In an example geometry shader connects the input lines to the pivot point coordinates from the constant buffer to create triangles. Winding order will determine whether to increase or decrease stencil value for triangle coverage in non zero fill mode. In odd even fill mode triangle coverage will flip stencil values regardless of the triangle winding. In an example vertex shader may be bypassed and the pixel shader may return fill color. One example 2 pass flow for filling is 

If Target Independent Rendering TIR can be used to resolve stencil buffer directly to the frame buffer the need for the extra bypass vertex shader may be eliminated. The bounding box calculation may no longer be needed at the pre process stage. Additionally an extra stencil state for the cover pass may not be needed because there will be no cover pass. In some examples this may increase filling performance. An example flow is as follows 

Stroking of a path may include widening the edges of the path along a straight line perpendicularly to the path. Some examples tessellate and evaluate the path at each evaluated point we widen the point according to the normal at that point and create triangulation to form segments. The union of all segments is the stroke line.

An example algorithm for stroking a path is as follows 1 tessellate the path into line segments with normal at endpoints 2 if re tessellation is enabled re tessellate the line segments where endpoint normals deviate too much in direction to create new line segments 3 if dashing is enabled cut line segments according to the dash pattern 4 create caps at cut locations tessellate round joins and caps 5 create triangulation to represent stroke lines caps and joins 5 render triangles with depth test enabled.

An example flow is as follows 1 update constant buffer with stroke color stroke width miter limit join rule cap rule dash pattern inverse of round tessellation factor may be constant 2 enable depth testing 3 first pass 4 second pass. The first pass may be a draw call to vertex shader to transform vertices to hull shader to convert collapsed cubics and degenerate ellipses to lines no pre processing and determine optimum tessellation level or use fixed level tessellation. In first pass domain shader may determine tessellated vertices locations and determine tessellated vertices normals converted to angle representation . Geometry shader may stream out lines for second rendering pass. The pixel shader may not be used in some examples.

The second pass may be a draw call bypassing the using vertex shader and using hull shader to compute tessellator inputs for tessellation delta segment length inverse of length and SV PrimType. An example may use a modified tessellator to tessellate joins cut re tessellate line segments and create cap tessellations at cut locations. Domain shader SV PrimType may linear interpolate position and normal from original line segment join and convert normal from angular form to coordinates. Geometry shader may increase the width of line segments create triangles for joins caps. The pixel shader may return stroke color.

In an example after the cell buffer contents are determined if the filling rule is non zero take the absolute value of the contents and clamp every value to sample count. For odd even filling take the 2 sample count modular of every value and if a value is greater than the sample count set it to be the distance from 2 sample count. This is illustrated in the code excerpt below 

Unlike the similar odd even rule the non zero winding rule relies on determining the direction of stroke for each part of the curve. For a given curve C and a given point P the non zero winding rule is determined as follows 1 construct a straight line out from P in any direction towards infinity 2 find all the intersections of C with this ray and 3 score up the winding number. Scoring the winding number includes 1 for every clockwise intersection the curve passing through the ray from left to right as viewed from P subtract 1 2 for every counter clockwise intersection curve passing from right to left as viewed from P add 1. If the total winding number is zero P is outside C otherwise it is inside.

A simple non self intersecting closed path divides the plane into two regions a bounded inside region and an unbounded outside region. Note that knowing the orientation of the outermost path i.e. clockwise or counter clockwise is not necessary to differentiate between the inside and outside regions.

A path that self intersects or that has multiple overlapping subpaths requires additional information in order to define the inside region. Two rules that provide different definitions for the area enclosed by such paths known as the non zero and even odd fill rules are supported by OpenVG. To determine whether any point in the plane is contained in the inside region imagine drawing a line from that point out to infinity in any direction such that the line does not cross any vertex of the path. For each edge that is crossed by the line add 1 to the counter if the edge crosses from left to right as seen by an observer walking along the line towards infinity and subtract 1 if the edge crosses from right to left. In this way each region of the plane will receive an integer value.

The non zero fill rule says that the point is inside the shape if the resulting sum is not equal to 0. The even odd rule says that the point is inside the shape if the resulting sum is odd regardless of sign e.g. 7 is odd 0 is even . Consider the star shaped path shown in below indicated with solid lines. The orientation of the lines making up the path is indicated with arrows. An imaginary line to infinity starting in the central region of the star is shown as a dashed line pointing to the right. Two edges of the star cross the line to infinity going left to right indicated by the downward pointing arrows. The central region therefore has a count of 2. According to the even odd rule it is outside the path whereas according to the non zero rule it is inside. Implementations must be able to deal with paths having up to 255 crossings along any line. The behavior of more complex paths is undefined.

In an example of cell buffer rasterization after the line segments are produced in domain shader they are sent to the cell buffer. Stroking a path comprises widening the edges of the path using a straight line pen held perpendicularly to the path. The path may then be tessellated and evaluated. At each evaluation point the point may be widened according to the normal at that point. Triangulation may be used to form segments as discussed below with respect to . The union of all segments is the stroke line.

To implement these methods in for example a DirectX11 pipeline architecture or other similar 3D graphics pipelines may be modified according to the techniques of this disclosure to include a number of extensions. For example the DirectX11 pipeline may be modified to include a path primitive. The path primitive may allow the DirectX11 pipeline to process vector graphics by allowing for path rendering directly in a GPU implementing DirectX11 without using a separate CPU. For example the path primitive may allow for filling stroking or both using the methods described herein.

In some examples the GPU implements a DirectX11 application programming interfaces for handling graphics tasks. The GPU further implements a draw call function configured to process a number of indices and path segment types. The GPU may also further implement an information primitive type.

For the first pass the CPU may place data indicative of a path segment to be rendered into one or more vertices of a vertex buffer. The primitive topology for the vertices in the vertex buffer may be for example a patch control list. For a line the vertices in the patch control list may include data indicative of coordinates for the endpoints of the line e.g. x0 y0 and x1 y1 . For a cubic B zier curve the vertices in the patch control list may include data indicative of the coordinates of the four control points that define the curve e.g. x0 y0 x1 y1 x2 y2 x3 y3 . For a quadratic B zier curve the vertices in the patch control list may include data indicative of coordinates for three control points instead of four control points. For elliptic arcs the vertices in the patch control list may include data indicative of an endpoint parameterization of the elliptic arc or data indicative of a center parameterization of the elliptic arc. The CPU may also place data indicative of the type of path to be rendered into an otherwise unused vertex coordinate.

One example of an input format for rendering path primitives will now be described. It should be understood that this is merely one example of how data indicative of a path to be rendered may be provided to the GPU and that other examples are possible and within the scope of this disclosure. In this example the GPU receives each path segment as a four 4 control point patch list primitive. Each of the vertices e.g. control points in the path list in this example includes three 3 float vectors that define attributes for the respective vertex e.g. control point .

In some examples stroking operations may use 3 additional fields on the vertex input to handle endcaps joins and open paths. For example certain vertex coordinates may store data indicative of whether the path segment is the beginning of a new open path the end of an open path and whether the primitive may be dropped. The following is an example template that includes the above described vertex coordinates 

The input assembler obtains the vertices from the vertex buffer and passes the vertices to vertex shader stage for processing. In some examples vertex shader stage may execute a pass through shader program that simply outputs the input vertex for each instance of the shader program. In an example vertex shader stage may transform vertices using world view and projection matrices.

Tessellator stages i.e. hull shader tessellator and domain shader stages may tessellate the path segment defined by the input data into a plurality of line segments. The plurality of line segments may approximate the curvature of the path to be rendered. In general tessellator may determine values at which one or more parametric equations that represent a particular type of path segment should be evaluated. Domain shader may evaluate the parametric equations at the values determined by tessellator and output a vertex for each evaluation. Some examples may use a Dx11 tessellator unit with isoline domain integer partitioning line output. Tessellator may cut the line segment according to the dash pattern and re tessellation delta using u coordinates. It may then create caps at every cut location using v coordinates and set the type to be cap or line segment.

Domain shader may output the vertices in an ordered sequence where each set of adjacent vertices represents a tessellated line segment. The line segments may collectively approximate the path segment that was defined in the vertex buffer. For example domain shader may output the following set of vertices 0 1 2 3 4 5 that define the following line segments 0 1 1 2 2 3 3 4 4 5.

In some examples tessellator processing stage and domain shader processing stage may be configured to uniformly tessellate a path segment into a plurality of line segments according to the following technique. Specifically tessellator unit may output coordinates for parametric evaluation e.g. t 0 T 1 T 2 T . . . T T where T is the tessellation factor . Depending on the type of primitive domain shader may evaluate one or more parametric equations at the values that are output by tessellator .

In another example domain shader may evaluate tessellated vertices locations and normals for lines cubics and elliptic arcs. Domain shader may also convert normals to angular form and mark output as line segment. For lines u is either 0.0f or 1.0f. Endpoints may be outputted directly. For normal i.e. lines meeting perpendicularly both will be found from endpoints difference and will be the same. Curves u will range from 0.0f to 1.0f in equal increments depending on the tessellation level. For all u s position will be found using the curve representation equation. For u 0.0f or 1.0f normals will be found by control point differences repeated control points will be checked for other u values normals will be found by the derivative of the curve equation.

Elliptic arcs u will range from 0.0f to 1.0f in equal increments depending on the tessellation level. For all u s positions and normals will be found using the arc parametric representation and its derivative respectively. For linear interpolation the normal angle for cap and joins convert back to Cartesian representation. Mark output as cap or join as appropriately. Round caps joins u will range from 0.0f to 1.0f in equal increments depending on the round tessellation level. Position will be the same for all u values. When u 0.0f or 1.0f we take the Cartesian representation of the endpoint tangents to calculate normals. For other u values angular tangents will be lerped to find new tangents and then converted to normals. Other caps joins u will be 0.0f or 1.0f. Position will be the same both. We take the Cartesian representation of the endpoint tangents to calculate normals.

Another domain shader DS not shown may provide for dashes and cusps in a line segment. Linear interpretation of normals and positions at tessellation locations. Domain shader may convert normals from angular form back to Cartesian form. In an example u of a line from point u to point v may be used to linear interpolate position and normal angle. The point v may be used to rotate the normal angle used to create round caps . If no dashing and re tessellation is required one can use the following one rendering pass flow VS HS Tess DS GS PS

If dashing or re tessellation is desired the following 2 pass flow will need to be used VS HS MTess DS Streamout Existing tessellator is enough here .

In such an example only two additional shaders marked with an apostrophe are required on top of the minor tessellator hardware addition.

For a line T may in some examples be always equal to 1. In such examples domain shader may not necessarily need to perform any evaluation to generate vertices that correspond to the line path segment.

For a cubic B zier curve domain shader stage may evaluate the curve and generate output vertices according to the following parametric equation 0 1 1 3 1 2 3 1 33 where C0 C1 C2 C3 correspond to the control points for the cubic B zier curve and t corresponds to the coordinates provided by domain shader to be used for performing parametric evaluation.

Alternatively for the cubic B zier curve domain shader stage may evaluate the curve and generate output vertices according to the following parametric equations 0 1 1 3 1 2 3 1 3 0 1 1 3 1 2 3 1 3 where X0 Y0 X1 Y1 X2 Y2 X3 Y3 correspond to the control points for the cubic B zier curve and t corresponds to the coordinates provided by domain shader to be used for performing parametric evaluation.

For a quadratic B zier curve domain shader stage may evaluate the curve and generate output vertices according to the following parametric equation 0 1 1 2 1 2 where C0 C1 C2 correspond to the control points for the quadratic B zier curve and t corresponds to the coordinates provided by domain shader to be used for performing parametric evaluation.

Alternatively for the quadratic B zier curve domain shader stage may evaluate the curve and generate output vertices according to the following parametric equations 0 1 1 1 2 0 1 1 1 2 where X0 Y0 X1 Y1 X2 Y2 correspond to control points for the quadratic B zier curve and t corresponds to the coordinates provided by domain shader to be used for performing parametric evaluation.

For an elliptic arc path segment domain shader stage may evaluate the curve and generate output vertices according to the following parametric equations CenterCos cos angle Sin sin angle CenterSin cos angle Cos sin angle where the parameterization angle angleis determined from tessellator output t where rh represents the horizontal radius of the unrotated ellipse rv represents the vertical radius of the unrotated ellipse rv Cos rv Sin rh Cos and rh Sin represent rv Cos angle rv Sin angle rh Cos angle and rh Sin angle respectively and angle represents the counter clockwise angle of the ellipse relative to the x axis measured prior to scaling by rh rv . In some examples hull shader stage may be configured to determine e.g. precompute cos angle and sin angle and or to determine e.g. precompute the rv Cos rv Sin rh Cos and rh Sin values and to provide these values to the domain shader stage for use in evaluating the above recited parametric equations for ellipses.

As discussed above with respect to elliptic arcs the vertices in the patch control list in some examples may include data indicative of an endpoint parameterization. In such examples a hull shader program executing on a shader unit of the GPU may be used to convert the data indicative of an endpoint parameterization of the elliptic arc to a data indicative of a center parameterization of the elliptic arc.

In an example another hull shader program HS not shown may be added and may save an angular representations of round join and cap tangents into primitive data and determine tessellation level. For lines non round joins and caps collapsed cubics and degenerate ellipses 1.0f calculate optimum tessellation level for cubics and elliptic arcs or use fixed tessellation and calculate optimum tessellation level for round joins and caps or use fixed tessellation. Hull shader program may compute tessellator inputs such as segment length re tessellation delta inverse of length. In an example segment length is the length of the line segment. Re tessellation delta is the length of the line segment divided by re tessellation amount. The maximum length of a line segment to come out of tessellator. Inverse of length is 1.0f Segment Length.

An example technique for finding the correct center of an ellipse when converting an endpoint parameterization of an elliptic arc to a center parameterization of the elliptic arc is now described. The example technique may determine a center point cx cy and the initial and final angles 1 and 2 of an ellipse and or elliptic arc based on an endpoint representation of an ellipse defined by the set of parameters x0 y0 x1 y1 rh rv f and f. An ellipse with center point cx cy radii rh and rv and rotation angle rot may satisfy the implicit equation x y 1 where x x cx cos rot y cy sin rot rh and y x cx sin rot y cy cos rot rv. The transformation from x y to x y maps the desired ellipse into a unit circle centered at the origin.

To determine the center points of the pair of ellipses with common radii and rotation angle that pass through the two given points x y and x y a plane is first transformed into a suitably scaled and rotated coordinate system such that the equation of each ellipse becomes x cx y cy 1. Then the centers i.e. cx cy and cx cy of the two unit circles whose circumferences pass through two given points may be found. Finally the center points are placed through an inverse transformation to obtain solutions in the original coordinate system.

The center points of the two unit circles that pass through points x y and x y are given by x y d y x d where x x x 2 y y y 2 x x x y y y and d 1 x y . . If d is infinite or imaginary no solution exists due to the input points being coincident or too far apart respectively. The angles 1 and 2 may be found by finding the slope of the endpoints on the circle and computing arctangents.

The following pseudo code illustrates the process of computing ellipse centers according to the above described technique. The findUnitCircles function is called by findEllipses following inverse transformation of the original ellipse parameters.

Further details regarding converting an endpoint parameterization of an elliptic arc to a center parameterization of the elliptic arc may be found in the OpenVG Specification Version 1.1 Dec. 3 2008 available at http www.khronos.org registry vg specs openvg 1.1.pdf the entire content of which is incorporated herein by reference. In particular Section 18.4 of the OpenVG specification describes a technique for converting an endpoint parameterization of an elliptic arc to a center parameterization of the elliptic arc incorporated herein by reference

Geometry shader may be invoked once for each of the line segments produced by the domain shader . For each line segment geometry shader may generate a triangle primitive using a common control point as a first vertex of the triangle and using the two endpoints of the respective line segment as the second and third vertices of the triangle. For example an example was provided above where the domain shader generated the following set of vertices 0 1 2 3 4 5 that define the following line segments 0 1 1 2 2 3 3 4 4 5. For the above listed sequence of line segments geometry shader may generate the following triangles C 0 1 C 1 2 C 2 3 C 3 4 C 4 5 C 4 5 where C is any single vertex.

In an example geometry shader may increase the width of a line type segments in both normal directions at endpoints to create stroke area. In some cases this may result in a quad for which we output two triangles. In some other cases where the curvature is high compared to line length and or stroke width is thick a butterfly may result. Butterflies require two triangles but there may be rare bleeding issue due to t joints. To eliminate t joints an extra teo triangles may be output which can be packed into 8 vertices using triangle strip primitive type. It is an extremely rare phenomenon so it is up to the programmer to use whether two triangle maxvertices 6 or 4 triangle maxvertices 8 approach. An example may 1 create one triangle for round caps joins tessellated and bevel joins 2 create two triangles for square caps and miter joins and 3 add z coordinate from the constant buffer to every output vertex.

In an example of preprocessing the path and packing of the vertex data may perform minimal preprocessing of path data prior to rendering. In some examples preprocessing happens only once per path and the result is not affected by world user perspective transformations. Preprocessing can be avoided and an alternative solution without pre processing is explained in the next section.

An example may iterate through all the vertices of a path tracking the total maximum and minimum values of vertices x and y coordinates. The average of all vertices centroid will be used as the pivot point when performing filling. In some examples the centroid of all vertices of a path is a good pivot point. The maximum and minimum coordinates define the bounding box for our path. This bounding box speeds up the filling process dramatically. Although not a very tight one this is the quickest way to find a bounding box for a path. Some examples may implement different bounding boxes or any other shape algorithm depending on the needs of particular systems.

An example may convert elliptic arcs from endpoint representation to parametric representation. One way to represent an arc is the endpoint representation Endpoints radii and the rotation angle of the ellipse are defined. This representation may need to be converted to parametric representation before sending path data to GPU. The example may also need to find tangents at endpoints to find joins and caps corresponding to these locations. Hence to be able to pre process joins and caps elliptic arcs need to be pre processed as well. Some examples may create starting and ending Caps for open paths and Joins where path segments meet. Endpoint tangents need to be calculated to create cap and join primitives. Example systems may avoid finding starting and ending caps and they can be handled when we are handling dashing. This may negligibly increase the modified tessellator unit size.

An example may pack the data into the format that will be understood by our DX11 program and create the vertex buffers per path. This means embedding the primitive type line quadratic curve cubic curve elliptic arc cap join into the first vertices z coordinate. Every primitive is a 4 control point patch regardless of whether all 4 control points are used or not. Below is an example line primitive packed into a 4 control point patch. Note the z coordinate of the first vertex defining the primitive type 

Every primitive may be conditioned to be unique even though they share vertices between adjacent primitives. Hence it is strictly patch 4 primitive type which results in no vertex reuse. The dash pattern may need to be pre processed for stroke paths. The system may handle negative and zero dash pattern entries remove last entry for odd number of entries find the current dash pattern entry and how much dash is left based on the dash offset. Sometimes although a dash pattern may be defined there is no dashing all zero entries or a single entry in dash pattern . This pre process may allow for the determination of such cases and skip dashing. Below is an example dash pattern and offset combination that shows the dash pattern pre processing steps.

The above dash pattern has 7 entries. We remove the last entry to have a dash pattern with even number of entries 

We take the absolute value of the negative entries and zero entries are removed by adding the following entry to the previous entry 

An example system may compute the dash pattern length which is 53 and add 53 to the negative offset value until we reach an offset greater than or equal to 0. The offset then becomes 120 53 53 53 39. Now the example system may find what entry it points to. First entry is 30 which is less than the offset value 39. The example system may advance to the next entry and subtract 30 from the offset. New offset is 39 30 9. Current entry is 5 which is again less than the offset value 9. The example system may advance to the next entry and subtract 5 from the offset. New offset is 9 5 4. Current entry 8 is greater than the offset value 4. The offset may be subtracted from the current entry which gives us the value 8 4 4. The index for the entry whose value is 8 becomes the dash index and the remainder value of 4 on that entry becomes the dash left . Hence the result of the pre processing is as follows 

The rasterizer may rasterize each of the triangles into a cell buffer e.g. a buffer stored in the resources block of . During the first pass the pixel shader may be disabled or set to a pass through mode to pass input pixels directly to the output merger stage . The output merger stage may be configured to populate stencil buffer such that stencil buffer stores values which are indicative of a fill area for the path segment according to one or more stencil buffer filling techniques. In various examples in accordance with this disclosure a cell buffer might be used rather than stencil buffer as illustrated in . Generally if a stencil buffer is used a second rendering pass with bounding box to render the path fill using stencil data may be needed. In some examples using a cell buffer may allow for a single pass solution rather than a solution requiring multiple passes. In some examples a cell buffer may be a dedicated hardware unit that may allow for 1 pass rendering. The cell buffer may be part of the rasterizer in some examples. In an example pixel shader may return stroke color.

According to a first stencil buffer filling technique for each of the rasterized primitives the output merger stage may invert the values in stencil buffer that correspond to pixels which are covered by the rasterized primitive. With this technique after all of the primitives have been rasterized to stencil buffer any inverted values in stencil buffer may represent a fill area for the path segment to be rendered.

According to a second stencil buffer filling technique for each of the rasterized primitives the output merger stage may increment values in stencil buffer that correspond to pixels which are covered by the rasterized primitive if a vertex order for the rasterized primitive is oriented in a clockwise direction and decrement values in stencil buffer that correspond to pixels which are covered by the rasterized primitive if a vertex order for the rasterized primitive is oriented in a counter clockwise direction. With this technique after all of the primitives have been rasterized to stencil buffer any non zero values in stencil buffer may represent a fill area for the path segment to be rendered.

The DirectX11 pipeline may include a draw call that includes a number of indices and a number of path segment types. Indices may be used to for example fetch the control points in the same way as a vertex buffer. The draw call may for example fetch both indices and path segment types. Path segment types may include line quadratic curve cubic curve arc etc. In some examples primitives may be added to allow for computing the tessellation level e.g. in the hardware shader. Additionally in some examples an information primitive type also referred to as a generating primitive type may be added to allow for the production of triangles for strokes and lines for fill in for example geometry shader .

Accordingly hardware in a GPU implementing DirectX11 and the systems and methods described herein may include hardware to process the path and information primitive types. Additionally a cell buffer may be added to the GPU implementing the DirectX11 architecture. In an example the cell buffer may be a sixteen by sixteen grid of sub pixels.

If i N end 1 for water tightness Else end start cos start sin end start sin start cos Triangle start end 

It is to be recognized that depending on the example certain acts or events of any of the techniques described herein can be performed in a different sequence may be added merged or left out altogether e.g. not all described acts or events are necessary for the practice of the techniques . Moreover in certain examples acts or events may be performed concurrently e.g. through multi threaded processing interrupt processing or multiple processors rather than sequentially.

In some examples point p1 illustrated in may be selected as the common point C for generating a triangle fan and a triangle fan may be generated that includes the following triangles p1 p2 p3 p1 p3 p4 p1 p4 p5 p1 p5 p6 p1 p6 p7. The target fill region for the path illustrated in is the union of regions A D and F.

As illustrated in regions A D and F are the only regions that are within an odd number of the triangles formed by the triangle fan. Thus if these triangles are rendered according to the first stencil buffer filling technique where the values in stencil buffer that correspond to pixels which are covered by the rasterized primitive are inverted then after all of the primitives have been rasterized to stencil buffer any inverted values in stencil buffer may correspond to the union of regions A D and F i.e. the fill area for the path segment to be rendered .

In addition regions A D and F are the only regions that are within an unbalanced number of clockwise and counter clockwise triangles formed by the triangle fan. Regions that are within an unbalanced number of clockwise and counter clockwise triangles may refer to regions where the total number of triangles of which the region is inside is not equal to the total number of triangles of which the region is outside. Thus if these triangles are rendered according to the second stencil buffer filling technique where the values in stencil buffer are either incremented or decremented depending on whether the triangle is oriented in a clockwise or counter clockwise direction then after all of the primitives have been rasterized to stencil buffer any non zero values in stencil buffer may correspond to the union of regions A D and F i.e. the fill area for the path segment to be rendered .

Further details regarding the use of a stencil buffer to fill a polygon may be found in the OpenGL Programming Guide The Official Guide to Learning OpenGL Version 1.1 available at http www.glprogramming.com red chapter14.html name13 the entire contents of which is incorporated herein by reference.

The first pass completes after rendering all of the primitives generated by geometry shader into stencil buffer . During the second pass a bounding box e.g. formed from two triangle primitives that encompasses the fill area is rendered into a render target e.g. the frame buffer with the stencil test enabled. The data in stencil buffer may cause pixels inside of the fill area to light up with a fill color specified by the CPU prior to the second rendering pass and cause pixels that are outside of the fill area to remain dark. During the second pass the tessellation stages and geometry shader may be disabled. The vertex shader may be configured to perform standard vertex shader operations e.g. transforms for rendering 3D graphics primitives. The pixel shader may be configured to perform standard operations and or configured to operate in a pass through mode. Once the second pass is complete the render target e.g. the frame buffer may store a rasterized version of the fill area for the path segment.

The stroking operation may utilize a single pass approach that may generally involve the following steps 

The input processing and tessellation operations are substantially similar to the input processing and tessellation operations described with respect to the filling operation and therefore will not be described in further detail.

In addition to domain shader evaluating parametric equations to generate vertices as described above with respect the filling operation domain shader may also generate normals for the endpoints of the line segments during the stroking operation. To generate the normals domain shader may evaluate additional parametric equations for each of the values generated by tessellator and output a normal vertex for each evaluation. The normal vertex may be indicative of a normal vector for a point on the path segment that corresponds to the parameter value generated by tessellator .

In general the tangent formulae for curves and elliptic arcs which may be used to determine the normal are the derivatives of the parametric formulas described above with respect to generating the vertices for the curves and arcs. For example for a cubic B zier curve domain shader stage may generate normals for the output vertices of the curve according to the following parametric equation 0 3 1 1 6 1 3 1 2 3 6 1 3 3 where C0 C1 C2 C3 correspond to the control points for the cubic B zier curve and t corresponds to the coordinates provided by domain shader to be used for performing parametric evaluation. A derivative of the parametric equation for the quadratic B zier curve provided above may be used to generate normals for a quadratic B zier curve in a similar fashion.

Alternatively for the cubic B zier curve domain shader stage may generate normals for the output vertices of the curve according to the following parametric equations 0 3 1 1 6 1 3 1 2 3 6 1 3 3 0 3 1 1 6 1 3 1 2 3 6 1 3 3 where X0 Y0 X1 Y1 X2 Y2 X3 Y3 correspond to the control points for the cubic B zier curve and t corresponds to the coordinates provided by domain shader to be used for performing parametric evaluation. A derivative of the parametric equations for the quadratic B zier curve provided above may be used to generate normals for a quadratic B zier curve in a similar fashion.

For an elliptic arc path segment domain shader stage may generate normals for the output vertices of the curve according to the following parametric equations TanCos sin angle Sin cos angle TanSin sin angle Cos cos angle where the parameterization angle angleis determined from tessellator output t where rh represents the horizontal radius of the unrotated ellipse rv represents the vertical radius of the unrotated ellipse rv Cos rv Sin rh Cos and rh Sin represent rv Cos angle rv Sin angle rh Cos angle and rh Sin angle respectively and angle represents the counter clockwise angle of the ellipse relative to the x axis measured prior to scaling by rh rv . In some examples hull shader stage may be configured to determine e.g. precompute cos angle and sin angle and or to determine e.g. precompute the rv Cos rv Sin rh Cos and rh Sin values and to provide these values to domain shader stage for use in evaluating the above recited parametric equations for ellipses.

After finding the tangent the normal vector may be found according to the following equation normal normalize Tan Tan .

As discussed above with respect to elliptic arcs the vertices in the patch control list in some examples may include data indicative of an endpoint parameterization. In such examples a hull shader program executing on a shader unit of the GPU may be used to convert the data indicative of an endpoint parameterization of the elliptic arc to a data indicative of a center parameterization of the elliptic arc.

Geometry shader may receive the line segments and the normals produced by domain shader and generate primitives e.g. triangles that spatially correspond to the stroke area for each of the line segments. The stroke area for each of the line segments may collectively approximate the stroke area for the original path segment.

In general each line segment may be defined by two consecutive points p0 p1 on a path and the normals n0 n1 at each of point respectively. To determine the stroke area for a line segment geometry shader may calculate the four corner points u0 l0 u1 l1 of the stroke area for the line segment according to the following equations 0 00 StrokeWidth 0 0 0 StrokeWidth 1 1 1 StrokeWidth 1 1 1 StrokeWidth where p0 and p1 are endpoints of the line segment for which the stroke area is being calculated n0 is the normal vector corresponding to p0 n1 is the normal vector corresponding to p1 and StrokeWidth is the stroke width defined by the user application and passed to the GPU.

Geometry shader may determine whether the intersection point is outside of the stroke area e.g. or inside of the stroke area e.g. and generate one or more primitives that spatially correspond to the stroke area based on the determination. To determine whether the intersection point is outside of the stroke area geometry shader may determine whether strokewidth

If the intersection point is outside of the stroke area e.g. then geometry shader may generate two triangles to form a quad that spatially corresponds to the stroke area. For example geometry shader may generate two triangles using the following combinations of vertices u0 u1 l1 and l1 l0 u0.

If the intersection point is inside of the stroke area e.g. then geometry shader may generate two triangles to form a butterfly that spatially corresponds to the stroke area. For example geometry shader may generate two triangles using the following combinations of vertices u0 u1 c and c l0 l1 if the u0 u1 c triangle is oriented in a clockwise direction and generate two triangles using the following combinations of vertices u0 u1 c and c l1 l0 if the u0 u1 c triangle is oriented in a counter clockwise direction.

To determine if the u0 u1 c triangle is oriented in a clockwise direction geometry shader may determine whether sin a0 a1 0 in the equations defined below. If sin a0 a1 0 then geometry shader may determine that the u0 u1 c triangle is oriented in a clockwise direction. Otherwise geometry shader may determine that the u0 u1 c triangle is oriented in a counter clockwise direction. The distances u0c and u1c which may be used to determine the shape of the quad and also find out the coordinate of the center point C may be determined based on the following formulas 

If strokewidth min u0c u1c then there are 2 cases. If sin a0 a1 0 which means triangle u0 u1 c is clockwise then the triangles to be drawn is u0 u1 c and c l0 l1 . If sin a0 a1 

In some cases when primitives corresponding to the stroke areas of line segments are generated e.g. by geometry shader the neighboring line segments may form a T junction if one or both of the stroke areas forms a butterfly shape e.g. . This is because the center point C is not at the same position for the different line segments.

In addition to the path rendering operations of filling and stroking the techniques of this disclosure may include applying various types of end caps to the ends of a path and applying various types of joins between the endpoints of interior path segments of a path. In some examples these operations may be able to be implemented using the techniques of this disclosure on a DX11 pipeline.

Techniques are now described for rendering joins. Joins may be applied at where different path segments meet. In some examples there may be three different types of joins 1 bevel 2 miter and 3 round.

In an example the cell buffer contains x y cells. One cell represents one pixel in the final image but cell name is used to distinguish the cells and pixels as they store different information. Each cell in the cell buffer stores sixteen bytes of winding counter information. The cell buffer may be the size of the frame buffer but normally the memory requirements of the cell buffer would become too big. So the frame buffer can be split in to tiles of x y pixels and cells . This allows the drawing of the primitive one tile at a time.

Each of the sixteen sample points of a pixel are an eight bit counter value. In one example the counter may be a winding counter. The winding counter values may be incremented or decremented during the edge drawing phase. Once all the edges have been drawn the fill process examines the value of these counter values and calculates the pixel coverage value for anti aliasing. The worst case storage requirement is x y 16 bytes where x and y are the dimensions of the tile. However there are ways to reduce the required bandwidth to access the winding counters as in most of the cases the winding counter values are very small either positive or negative . This information may be used compress the data for example by storing the least significant bits of each winding counter 16 bits as two bytes and have internal per pixel flags to determine the pixel type. The pixel type can be for example empty negative 16 bit positive 16 bit fully expanded 16 bytes. In other examples more compression levels could be added.

The result of the sampling is collected as sixteen bit values e.g. masks . Internally there are left side and right side masks which are flushed out with certain rules. As the masks are flushed out it means that the set bits affect the corresponding winding counters of that pixel. If the edge is upward the winding counters are incremented. If the edge is downward the winding counters are decremented. As the edge sub pixels are being generated it is checked if the next sub pixel is within the current pixel to the left to the right or on different pixel row. If the new sub pixel is on a different pixel row then the both left and right side masks are flushed out. If the new sub pixel is to the pixel right of the current pixel the left side mask is flushed and then replaced by the right side mask. If the new sub pixel is to the pixel left of the current pixel the right side mask is flushed and then replaced by the left side mask. This may be done to reduce the amount of flushing. Basically in the above example the left side and right side masks are each other s inverse. In other examples that may not always be true. For example very short edges or almost horizontal edges don t cover the whole pixel in vertical direction. In those examples the left and right side masks are not each other s inverse.

GPU generates edge samples and determines if the samples are in the current pixel as will be discussed with respect to . If the sample are in the current the GPU determines if it is the left most tile if not then GPU determines if the new pixel is left right or up down . If the new pixel is right the GPU replaces the right sample mask with the left sample mask and flushes e.g. deletes the left sample mask . If the new pixel is left the GPU replaces the left sample mask with the right sample mask and flushes e.g. deletes the right sample mask . If the new pixel is up or down then GPU flushed and clears both sample masks .

If the new tile is the left most tile then GPU may clamp the sample inside the tile with x max x tx0 . If not GPU sampling updates the left or right mask . This is also performed if the tile is not the left most tile .

If the edge is not finished GPU again generates edge samples otherwise GPU determines if all edges are done . When all the edges are done the process completes i.e. is done . If all of the edges are not complete then one edge is input .

The diagram illustrates the first two pixels of the cell buffer after one upward edge the edge drawing example above has been drawn. As the edge was upward the winding counters are positive ones in the cell buffer on samples marked red. The winding counters from the cell buffer may be added to the internal winding counters before the coverage calculation. The column on the left edge of the pixel shows the value of internal winding counters after the cell buffer winding counters have been added. The first pixel in the illustrated example has ten samples having one in their winding counter. The final coverage value of the first pixel may be 10 16. The second pixel has six samples having one in their winding counter. As these are added to the internal winding counters it may be seen that now all sixteen internal winding counters are one so the final coverage of the second pixel is 16 16 fully covered .

In an example all primitives may be a path 4 type and the programmer makes a drawAutoIndexed API call.

In an example without pre processing as illustrated in five vertices may define the path primitive types are as follows Line Cubic . The path is not closed. An example process may make following API call 1 drawNonIndexedPrimType numIndices 5 closed false 2 IA will start generating primitives based on the primitive types. Since this is an open path there are caps at the beginning and end of the path.

An example may have four different types of path segments line quadratic cubic elliptic we have 4 4 16 join primitive types. In an example a vertex shader may process X and Y coordinates that may have appropriate world view projections applied. For simplicity we assume identity transformation hence the input remains unchanged. A control point hull shader may perform the following process for caps and join 

Control points 1 and 2 for joins and control point 1 for caps contain the tangent data. We convert these tangents to angular representation and save them in the z coordinate which was not used previously. Hence the input to tessellator then will be the following 

An example may include constant HS will determine tessellation levels. For example assume fixed tessellation 4 for the cubic 4 for round caps joins and 1 for lines. Domain shader may output is a vertex position normal and type and evaluate tessellated vertices locations and normals for lines cubics and elliptic arcs. Domain shader may convert normals to angular form and mark output as line segment. For curves domain shader may repeated control points might cause us to have zero tangents at curve start and end locations. To correctly determine tangents there domain shader may treat u 0.0f and 1.0f differently and linear interpolate intermediate values. Linear interpellation of the normal angle for cap and joins convert back to Cartesian representation. Domain shader may mark output as cap or join as appropriately. For u 0.0f and 1.0f we directly use the tangents Cartesian representation instead of angular representation to ensure water tightness. Again domain shader may treat u 0.0f and 1.0f differently than intermediate values.

In an example output position may be 0.4f 0.8f start point output norm may be 0.8f 0.0f tangent may be end point start point normal may be tan y tan x and output. type may be line. For curves position may be the first control point. Normal may be the difference of first two nonrepeating control points.

In an example output position may be 0.4f 0.8f first control point output norm may be 0.2f 0.2f tangent may be the difference between first two non equal control points normal may be tan y tan x and output type may be line. Caps can be the position of the first vertex. Normal may be the Cartesian representation of the tangent vector rotated 90 degrees counterclockwise.

In another example output position may be 0.4f 0.8f cap position output norm may be 0.0f 0.8f. The example may use tangent Cartesian representation normal tan y tan x and output type may be cap.

In another example output position may be 0.0f 0.0f cap position output norm may be 0.2f 0.6f. The example may use tangent Cartesian representation normal tan y tan x and have output type equal to cap. For joins the position is the first vertex. Normal it is the Cartesian representation of the first tangent vector rotated 90 degrees counterclockwise.

In another example output position may be 0.4f 0.8f join position output norm may be 0.0f 0.8f and the example may use the first tangent Cartesian representation normal tan y tan x with an output type join. For this example u 1.0f with lines in the position of the last vertex. Normal is the endpoints difference.

In another example output position may be 0.4f 0.8f end point and output norm may be 0.8f 0.0f. In the example the tangent may be the end point start point and the normal may be tan y tan x . The output type may be line. For curves the position may be the last control point. Normal is the difference of last two nonrepeating control points.

In another example output position may be 0.0f 0.0f last control point and output norm 0.2f 0.6f. In the example the tangent may be difference between first two non equal control points and the normal tan y tan x . The output type may be line. A caps position may be the first vertex. Normal may be the Cartesian representation of the tangent vector rotated 90 degrees clockwise.

In another example output position may be 0.4f 0.8f cap position output norm may be 0.0f 0.8f and the example may use tangent Cartesian representation with normal tan y tan x and an output type that may be cap.

In another example output position may be 0.0f 0.0f cap position with output norm that is 0.2f 0.6f and with a use tangent Cartesian representation normal tan y tan x and an output type that is cap. For joins the position is the first vertex. Normal is the Cartesian representation of the second tangent vector rotated 90 degrees counterclockwise.

In another example output position may be 0.4f 0.8f join position with output norm that is 0.2f 0.2f. The example may use second tangent Cartesian representation with a normal that is tan y tan x and an output type that is type join.

In the example u i T intermediate values lines may have no intermediate tessellation values for lines and a curve s position may be found using the equation 0 1 31 1 32 1 3 Tangent are found using the derivative of the position equation 30 1 61 1 31 1 32 62 1 33

In another example output pos may use cubic Bezier formula and output norm may use cubic Bezier formula derivative to find tangent. The normal may be tan y tan x and the output type may be line. Caps Round only may have no intermediate values for square caps. For round caps position may be the first vertex. Normal may be found by first linear interpolating the angular tangent with its opposite direction add PI then rotating 90 degrees counterclockwise.

In another example output position may be 0.4f 0.8f cap position . The output norm may be sin lerpedAngle cos lerpedAngle with lerp angle with angle PI 1 u angle u angle PI tangent cos lerpedAngle sin lerpedAngle normal tan y tan x and output type cap.

In another example output position may be 0.0f 0.0f cap position output norm may be sin lerpedAngle cos lerpedAngle lerp angle with angle PI 1 u angle u angle PI tangent cos lerpedAngle sin lerpedAngle normal tan y tan x and output type cap. For joins position may be the first vertex. Normal may be the Cartesian representation of the second tangent vector rotated 90 degrees counterclockwise.

In another example output position may be 0.4f 0.8f join position output norm may be sin lerpedAngle cos lerpedAngle lerp first tangent angle with second tangent angle 1 u firstAngle u secondAngle tangent may be cos lerpedAngle sin lerpedAngle and normal tan y tan x . The output type may be join.

The example of may have the illustrated line segments caps and joins to feed into geometry shader . In examples without dashing and in which re tessellation cusps are not needed a single pass method may be used and the inputs discussed below may be sent to geometry shader 

In this example input coordinates are still two dimensional. Output will be 4 dimensional SV Position . The line type segments in both normal directions at endpoints to create stroke area may be thickened as illustrated in . In some examples a quad may be determined for which the output may be two triangles. In some other examples where the curvature is high compared to line length and or stroke width is thick a butterfly may be determined as illustrated in . In the example strokewidth is not too high to cause butterflies. In the butterfly case the center c and send two triangles u0 u1 c and l0 l1 c may be found. There may be rare bleeding issue due to t joints. To eliminate t joints two extra triangles u0 l0 c and u1 l1 c may be output. These four triangles can be packed into eight vertices using triangle strip primitive type. It may be a rare phenomenon. Some examples may use the two triangle maxvertices 6 while other examples may use the 4 triangle maxvertices 8 approach.

In an example the pixel shader may return stroke color. The result may be round cap join used as illustrated in . For the pixel shader on single pass solution the result may be cut locations that may not accurately match as illustrated in

In an example a modified tessellator may be used. Caps from first rendering pass will essentially bypass the tessellation on second pass. They go all the way to the GS unchanged. Joins will either be dropped or sent unchanged depending of if they land on a dash on empty space. In the example the only join we have lands on a dash are so it is kept. The modified tessellator may cut the line segment according to the dash pattern and re tessellation delta using u coordinates. Cut locations are marked with dots as illustrated in . U coordinates to be sent to domain shader will be the ratio of cut location distance from starting point divided by the segment length. If a dash cut happens to be longer than re tessellation delta we would cut first at the re tessellation delta length. In other words no new line segment can be longer than the re tessellation delta of its parent segment. Set primitive type to be line.

The modified tessellator may then create caps at every cut location using v coordinates. Round caps will be generated in a similar fashion to round caps from the first rendering pass. The modified tesselator may use v coordinates to handle the normal rotation at cap locations. Following illustrates the round cap on the first cut location. Every dash cut location will have a cap. Re tessellation cuts will not have dashes as illustrated in B.

In an example a DS Dash Cusp Domain Shader Line Segment u v may be used. Linear interpretation of normals and positions at tessellation locations may be performed by the Dash Cusp Domain Shader. The Dash Cusp Domain Shader may convert normals from angular form back to Cartesian form with u is used to lerp position and normal angle and v coordinate is used to rotate the normal so as to create round cap tessellation as illustrated in . Geometry shader may use a single pass solution. The pixel shader may use a single pass solution. Result may be cut locations that may not accurately match above illustrations which are only examples.

For an ellipse the parameterized equation is sin cos assume It could be treated as a circle scaled along the x direction by a factor of a b which is smaller than 1. So it s safe to say that the error of the tessellated ellipse will be smaller than the error of a tessellated circle of radius b using the same tessellation factor. So w the same formula of arc may be used 

In another example the tessellation factor for cubic and quadratic Bezier curves may be found. Quadratic curves can be converted to cubics before processing. A technique called subdividable linear efficient variety enclosure SLEVEs may be used to estimate the tessellation factor of cubic curves as illustrated in .

Given a polynomial function and the number of segments tessellation factor SLEVEs can efficiently compute a piecewise linear bound of the curve with uniform knots. So with SLEVEs we can estimate the error of the piecewise linear approximation of a curve. In addition SLEVEs guarantee that as the tessellation factor increase the bounding width error will decrease quadratically. So given a required error we can estimate a safe tessellation factor. The whole algorithm follows 

For more detail about the computing of SLEVEs and its error please refer to these 2 papers Efficient Pixel Accurate Rendering of Curved Surfaces. Young In Yeo Lihan Bin and J rg Peters 13D 2012 and Mid structures of subdividable linear efficient function enclosures linking curved and linear geometry. PETERS J. 2004. In Proceedings of SIAM conference Seattle November 2003 each of which is incorporated herein by reference.

Tessellation factor for Stroke for Arc and Ellipse may simply add the stroke width to the radius to calculate the tessellation factor. For Cubic the stroke line is no longer a polynomial curve. It has square root and it s a rational function. So we can no longer using SLEVEs to bound it. Actually theoretically there may not exist a big enough tessellation factor for cubic. Imagine a cubic with a sharp cusp where the normal is no longer continuous through the curve. For this case not matter what tessellation factor we set the error will be big. In our implementation in order to solve this problem we re tessellate the curve and interpolate the normal if we found the two normal at the endpoints of a segment is too different. We think this also will help in other case even if we don t have a safe tessellation factor so for stoke we use the same tessellation factor as filling.

Comparing the optimal tessellation to reference implementation in the conformance test the reference implementation uses a fixed tessellation factor 256 for all curves which is very high considering all the test case is smaller than 64 by 64 pixel. In our implementation a fixed tessellation factor 64 can pass all the tests.

After applying the above optimized tessellation factor estimation with required error equals to half pixel size much smaller tessellation factor in most of the conformance test are calculated. In some cases the test may be failed because the small bounded error doesn t guarantee the output to be exactly same. It can only guarantee the difference will be no more than 1 pixel along the boundary. Consider the illustration of .

For the lower right pixel the center of the pixel sits right between the real curve and the tessellated curve. So the output will have 1 pixel difference. We try to decrease the required error from half pixel to a pixel and we pass almost all the test case only for one test case we fail by one pixel .

In addition to smaller tessellation factor the optimized tessellation factor can adaptively change to guarantee the render quality when use zoom in which cannot be achieved by fixed tessellation factor. So if there is a curve that requires more than 256 tessellated line segments to be pixel accurate we will actually beat the reference implementation.

As illustrated in an example may include re tesselation on these line segments to correct this problem. In the example a maximum angular deviation in normals determines the re tessellation level. Then the line length may be divided by this re tessellation level to find the length of the desired re tessellated lines tessDelta . New normal are found by linear interpolating angular representation of the endpoint normals then converting back to Cartesian representation.

In the example line segments may also be according to a dash pattern as illustrated in . By start cutting according to the dash pattern but if a new line segment is larger than tessDelta it is cut at tessDelta lengths too as illustrated in .

In some examples the first plurality of primitives and the second plurality of primitives may be the same primitives. The plurality of primitives may include a plurality of line segments. Additionally the path segment comprises one of a line an elliptic arc a quadratic B zier curve and a cubic B zier curve.

In an example the GPU may further be configured to determine how a graphical shape with more than one closed outline will be filled based on an odd even rule. The odd even rule determines if a point should be considered inside by drawing a ray from the point to infinity in any direction and counting the number of path segments from the given shape that the ray crosses if the number of path segments is odd the point is considered inside the curve if the number of path segments is even the point is considered outside the curve.

GPU may determine how a graphical shape with more than one closed outline will be filled based on a non zero rule. The non zero winding rule determines the direction of stroke for each part of the curve for a given curve C and a given point P the non zero winding rule determines if a point should be considered inside by 1 construct a straight line out from P in any direction towards infinity 2 find all the intersections of C with this ray and 3 score up the winding number and wherein scoring the winding number includes 1 for every clockwise intersection the curve passing through the ray from left to right as viewed from P subtract 1 2 for every counter clockwise intersection curve passing from right to left as viewed from P add 1 if the total winding number is zero P is outside C otherwise it is inside.

The techniques described in this disclosure may be implemented at least in part in hardware software firmware or any combination thereof. For example various aspects of the described techniques may be implemented within one or more processors including one or more microprocessors digital signal processors DSPs application specific integrated circuits ASICs field programmable gate arrays FPGAs or any other equivalent integrated or discrete logic circuitry as well as any combinations of such components. The term processor or processing circuitry may generally refer to any of the foregoing logic circuitry alone or in combination with other logic circuitry or any other equivalent circuitry such as discrete hardware that performs processing.

Such hardware software and firmware may be implemented within the same device or within separate devices to support the various operations and functions described in this disclosure. In addition any of the described units modules or components may be implemented together or separately as discrete but interoperable logic devices. Depiction of different features as modules or units is intended to highlight different functional aspects and does not necessarily imply that such modules or units must be realized by separate hardware or software components. Rather functionality associated with one or more modules or units may be performed by separate hardware firmware and or software components or integrated within common or separate hardware or software components.

The techniques described in this disclosure may also be stored embodied or encoded in a computer readable medium such as a computer readable storage medium that stores instructions. Instructions embedded or encoded in a computer readable medium may cause one or more processors to perform the techniques described herein e.g. when the instructions are executed by the one or more processors. Computer readable storage media may include random access memory RAM read only memory ROM programmable read only memory PROM erasable programmable read only memory EPROM electronically erasable programmable read only memory EEPROM flash memory a hard disk a CD ROM a floppy disk a cassette magnetic media optical media or other computer readable storage media that is tangible.

Computer readable media may include computer readable storage media which corresponds to a tangible storage medium such as those listed above. Computer readable media may also comprise communication media including any medium that facilitates transfer of a computer program from one place to another e.g. according to a communication protocol. In this manner the phrase computer readable media generally may correspond to 1 tangible computer readable storage media which is non transitory and 2 a non tangible computer readable communication medium such as a transitory signal or carrier wave.

Various aspects and examples have been described. However modifications can be made to the structure or techniques of this disclosure without departing from the scope of the following claims.

