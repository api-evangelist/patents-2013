---

title: Simulation control techniques
abstract: Simulation control techniques include shutting down peer processes and user code modules, storing an image of a simulation as a checkpoint after the peer processes and user code modules are shutdown, and re-starting user code modules and peer processes after storing an image of the simulation. The resulting checkpoint and processes can be used for restoring from a checkpoint or restarting a new simulation environments having peer processes such as debuggers coupled to the simulation.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08856756&OS=08856756&RS=08856756
owner: Synopsys, Inc.
number: 08856756
owner_city: Mountain View
owner_country: US
publication_date: 20130308
---
This application is a continuation of U.S. patent application Ser. No. 12 030 192 filed on Feb. 12 2008 now allowed which claims the benefit of U.S. Provisional Patent Application No. 60 889 523 filed Feb. 12 2007 both of which are herein incorporated by reference.

A checkpoint is a collection of data on a computing device readable medium such as a hard disk drive which contains an image of a running process on a computing system for the time when the checkpoint was created. By restoring a checkpoint the process is restarted and set into the state at the time that the checkpoint was created. The behavior of the process that was restored from a checkpoint is equivalent to the original process just after creating the checkpoint.

There are checkpoint and restore solutions for interpretive languages such as Verilog and VHDL. For example the hardware simulation environments of Cadence and Mentor Graphics support checkpoint restore of simulation for the Verilog and VHDL interpretive languages. However there are currently only limited checkpoint restore solutions available for compiled languages e.g. C C programs SystemC etc. . For example GNU Emacs create a checkpoint during its build procedure to shorten the setup time of the GNU Emacs. When GNU Emacs is started it is actually restored from that checkpoint. The checkpoint however does not contain the state of the stack of the process. In addition GNU Emacs checkpoint restore procedure does not support multi threading or inter process connectivity.

Other compiled language checkpoint restore libraries do not support restoring connectivity to debuggers or other external applications. The compiled language solutions also do not fully support operating system dependent resources like multi threading mutexes shared memory and or the like.

Embodiments of the present technology are directed toward techniques for checkpointing restoring and restarting simulations with peer e.g. debugger connectivity. In one embodiment the start of checkpointing includes notifying the peer processes on start of the checkpointing. The inter process communication channels are dosed in response to the start of checkpoint notice. After closing inter process communication channels the peers notify the simulation control process that they are ready for checkpointing. In addition the user code modules are notified on start of checkpointing. In response operating system dependent resources are shut down by the user code modules in response to the start of checkpoint notice. The user code modules then notify the simulation control process that they are ready for checkpointing after shutting down operating system dependent resources. The connection between the simulation control process and the simulation is then closed. The state of the simulation is then saved to a checkpoint directory on a computing device readable medium.

After storing an image of the simulation the connection between the simulation control process and the simulation is restored. Thereafter user code modules are notified of the end of checkpointing. The operating system dependent resources are then restored by the user code modules. Thereafter the simulation control process is notified that the user code modules are ready. Similarly the peer processes are notified of the end of checkpointing. The inter process communication channels are restored by the peer processes in response to the end of checkpoint notice. Thereafter the peer processes notifying the simulation control process that they are ready after restoring the inter process communication channels. The simulation is then continued.

In another embodiment a simulation is started in response to a restore event. The environment and arguments are restored to the ones of the simulation process when the checkpoint was created. The new simulation is suspended before initialization of global constructs and each peer processes receives an end of the restoring notice. Each user code module is notified of the restore. The operating system dependent resources are restored by the user code modules in response to the end of restoring notice. Thereafter the simulation control process is notified that the one or more user code modules are ready. The inter process communication channels are also restored by the peer processes in response to the end of restore notice. Thereafter the simulation control process is notified that the peer processes are ready. After the user code modules and peer processes are ready the simulation is continued from the checkpoint.

In yet another embodiment a simulation is started in response to a simulation restart event. The new simulation is suspended before initialization of global constructs. Each peer process is notified on restart of the simulation. Inter process communication channels are re established by the peer processes in response to the restart notice. After re establishing the inter process communication channels the peer processes notify the simulation control process that they are ready. Thereafter the simulation is continued.

Reference will now be made in detail to the embodiments of the present technology examples of which are illustrated in the accompanying drawings. While the present technology will be described in conjunction with these embodiments it will be understood that they are not intended to limit the invention to these embodiments. On the contrary the invention is intended to cover alternatives modifications and equivalents which may be included within the scope of the invention as defined by the appended claims. Furthermore in the following detailed description of the present technology numerous specific details are set forth in order to provide a thorough understanding of the present technology. However it is understood that the present technology may be practiced without these specific details. In other instances well known methods procedures components and circuits have not been described in detail as not to unnecessarily obscure aspects of the present technology.

Embodiments of the present technology are directed toward techniques that enable the creation of checkpoints and the restoring from such checkpoints for SystemC simulation processes. The techniques provide for the connectivity of other processes like debuggers visualization applications and or the like external applications during the creation of checkpoints and the restoring from checkpoints. Thus when a SystemC simulation is restored from a checkpoint the connectivity of the external applications are also restored. The debuggers are also enabled to save information on control instances like breakpoints and watchpoints into the checkpoint and to restore such control structures when the simulation is restored.

Referring to a simulation architecture in accordance with one embodiment of the present technology is shown. The simulation architecture includes a simulation process one or more user code modules one or more peer processes a temporary checkpoint saver restorer process a notification framework and a simulation controller . The simulation controller controls the procedures for creating checkpoints restoring from checkpoints and restarting simulations. During checkpoint restore and restart procedures the simulation controller creates the temporary checkpoint saver restorer process that executes some parts of the checkpoint restore and restart procedures that require reading and writing to the memory of the simulation from outside the simulation process .

Peer processes associated with the simulation process register with the simulation controller . The notification framework inside the simulation process provides for the registration of user code modules . SystemC modules and other user code modules register with the notification framework to get notifications about the start and end of checkpoints and restore and restart events. The notification framework also provides for un registration of user modules from notification events. The notification framework provides notifications to all registered user modules on the start of checkpoint events on the end of checkpoint event and end of restore events. Similarly the simulation controller provides for the registration with the notification framework of peers to notification events. The simulation controller also provides RN un registration of peers from the notification events. The simulation controller also provides a list of available checkpoints provides for peer requests for creation of checkpoints peer requests to delete checkpoints peer requests for renaming checkpoints and peer requests for restoring checkpoints.

The peers register with the simulation controller . The peers provide a class name and may optionally define an image that may be used during restore to start a new process of the peer. In one implementation all peers of a certain class register with the same image. If peers of the same class register with different image or one peer registers with an image and another of the same class registers without an image then the first given image may be used for all peers of the given class.

During a restore procedure the collection of peers will usually differ from that during creation of a checkpoint. Therefore the restore procedure executes a mapping mechanism of available peers to the original role of peers during checkpointing. The original peers as used herein are the peers that have been connected to the simulation controller during creation of a checkpoint. A given peer may be assigned a different instance identifier during each checkpoint procedure. Therefore each peer is characterized by its peer class and an instance identifier. The instance identifier is valid during a given checkpointing procedure. It is assigned by a beginning of checkpointing notification routine. Active peers are the peers that are registered with the simulation controller when a restore procedure is initiated.

During checkpointing the simulation controller assigns identifiers to the peers. Peers of the same class may be numbered by ascending number starting with zero. Peers may use the class name and the instance identifier for saving their own checkpoint data into the checkpoint directory. For example a peer having peer class RVD and id 1 may save its data to a file such as Checkpoints MyCheckpoint RVD.1.

During restoring from a checkpoint the simulation controller again assigns identifiers to the peers. Peers of the same class may again be identified by ascending numbers starting with zero. The peers then read checkpoint data from the file created by the corresponding class instance during checkpointing. As shown in the case where the same or the same type of debuggers are registered to the simulation controller during creation of a checkpoint and a restore of the checkpoint is illustrated. In such case there is a one to one mapping of the peers.

If there are less active peers of a certain class registered during restoring a checkpoint than during creation of checkpoint and if the peer class is associated with an image specified during the registration of the peer before checkpointing the simulation controller automatically tries to start the number of missing peers. For example the simulation controller sets the environment variable CWR RESTORE SIMCONTROL SIOR to it s SIOR to inform the newly started client about how to register to the servicing simulation controller instance. The case where there are fewer peers during restore then at checkpoint time is illustrated in . As shown the missing peer cannot be started since the original peer did not specify an image. The debugger in the example may have been closed before restore the debugger may not have had an executable image or the like and therefore the debugger is not restarted.

If there are more active peers of a certain class registered than during creation of the checkpoint they are notified about the end of restore with an identifier such as 1 indicating that they shall not be reconnected to the simulation. The case where there are more peers during restore then at checkpoint time is illustrated in . In such case the missing peer can be restarted because the original peer specified an executable image. The application in the example may have closed before restore but registered an executable image. Therefore the image is executed to replace the missing application.

The simulation environments provides for saving checkpoints restoring from check points and restarting with a new simulation. Saving a checkpoint includes a start checkpoint process and an end checkpoint process. The start checkpoint process begins with the simulation controller suspending the simulation . The simulation controller notifies peers about start of checkpointing. The peers are notified to disconnect from the simulation . The peers close their respective inter process communication channels to the simulation . A parameter in the notification identifies the memory area where checkpoint data is to be saved. After the peer processes close their inter process communication channels the peer processes signal to the simulation controller that they are ready for checkpointing. The simulation controller may also notify registered peers that the simulation temporarily does not support checkpointing and when the simulation again supports checkpointing. The simulation controller expects a ready for checkpointing notification from all registered peers . All registered user modules are then notified about the start of checkpointing by the simulation controller via the notification framework . If the simulation includes user code the user code is responsible for shutting down all operating system dependent resources used by the user code modules. In particular all files and sockets are closed all semaphores mutexes and condition variables are released certain DLLs are detached all threads except for the main thread are closed and the like. Thereafter the user code modules notify the simulation controller via the notification framework that they are ready for checkpointing. In addition a user code modules may notify the simulation controller it temporarily does not support checkpointing and when it supports checkpointing again. The simulation controller expects a ready for checkpointing notification from user modules . Thereafter the simulation controller triggers checkpointing inside the simulation and disconnects from the simulation.

The simulation process starts the temporary checkpoint saver restorer process and suspends itself. The checkpoint saver restorer process saves the state of the simulation to a checkpoint area e.g. file and or directory on a computing device readable medium CDRM such as a hard disk drive. The state of the simulation saved to the CDRM includes the stack heap global variable DLL data environment and thread context. The peers are also enabled to save information on control instances like breakpoints or watchpoints into the checkpoint and to restore such control structure when the simulation is restored from the checkpoint.

The checkpoint saver restorer process resumes the simulation process and terminates itself during the end checkpoint process. All operating system dependent resources are re established. Connection between the simulation and the simulation controller is re established. All registered user modules are notified about the end of checkpointing by the notification framework . The user modules open sockets and other operating system dependent resources used by the user code modules. After all registered user module signal to the notification framework that they are ready after checkpointing the notification framework sends a checkpoint procedure finished notification to the simulation controller . In turn the simulation controller notifies registered peers about the end of checkpointing. The peers re establish inter processes communication channels with the simulation and notify the simulation controller that they have re established all connection and are ready after checkpointing. The simulation controller expects ready after checkpointing notification from all registered peers . Thereafter the simulation continues.

The processes performed by the simulation controller may be realized by a remote C R control protocol. The implementation of the protocol can be based on any inter process communication platform such as pipes TCP RCP CORBA or the like. The protocol is operated by the simulation controller so that the communication channel with the peers is not interrupted by the checkpoint restore or restart procedures.

The restore checkpoint procedure is controlled by the simulation controller . If a simulation is running when the restore process starts it is shutdown. Before the initialization of the global constructors a hook drives the simulation into the restore procedure. There can be any number of peers that are registered with the simulation controller as during the normal operation of a simulation. A new simulation process is started when the restore checkpoint procedure starts. A simulation attribute indicates the simulation that shall be restored from a specific checkpoint. A parameter also identifies the memory area e.g. HDD where checkpoint data can be read. The environment and arguments are restored to the ones of the simulation process when the checkpoint was created. The simulation is in a state where all operating system dependent resources are comparable to the state during checkpointing. In particular only the main thread is running and all DLLs that have been loaded during checkpointing are loaded. The simulation process starts the temporary checkpoint saver restorer process and suspends itself. The checkpoint saver restorer process restores the state of the simulation from the checkpoint information on the CDRM. In particular memory locations are allocated process memory including the stack head global variable DLL data and environment are restored and the thread context is recovered. The checkpoint restorer process resumes the simulation process and terminates itself. All operating system dependent resources are re established to the state before checkpointing. All registered user modules are notified about end of restoring. After receiving the end of restoring notification from the notification framework the user modules notify the notification framework that they are ready after restoring. Connection between the simulation and the simulation controller is re established. The simulate controller is also notified about end of restoring and in turn the simulation controller notifies peers about the end of restoring. The peers re establish inter process communication channels to the restored simulation . After all peer processes signal ready after restoring to the simulation controller the simulation controller signals ready after restoring to the simulation . In response thereto the restored simulation continues.

In addition to restoring from a checkpoint the simulation controller allows restarting a simulation. The restarting simulation procedure is a modification of the restore checkpoint procedure. It is controlled by the simulation controller . If a simulation referred to as the current simulation is running when the restart procedure starts it is closed. There can be any number of peers registered with the simulation controller as during the normal operation of a simulation. A new simulation is started when the restarting simulation process starts. A parameter identifies the new simulation process. The simulation image environment and arguments may be reused from the last start of a simulation. The new simulation suspends immediately after start. The connection between the new simulation process and the simulation controller is established. The simulation controller notifies the peers about restart of simulation. The peers re establish inter process communication channels to the re started simulation. Thereafter the peers notify the simulation controller that they have re established all connection to the new simulation and are ready after restart. After all peer processes signal to the simulation controller that they are ready after restarting the simulation controller continues the new simulation. Furthermore it is to be noted that the new simulation process may still be halted by any of the attached debuggers.

If the simulation includes GNU GDB debuggers the GDB communicates with the simulation by the GDB remote serial protocol over TCP IP. This enables usage of the GDB in its original state without any modification to its source code. For that reason the GDB does not understand the C R control protocol and cannot register to the C R control process . Therefore the connections between the simulation and GNU GDB debuggers are handled in a specific way.

Referring now to the process of handling GDB connections during checkpointing and restoring in accordance with one embodiment of the present technology is shown. Generally a GDB is coupled to a simulation through a GDB remote serial protocol bridge in the simulation controller using TCP connections . When the GDB contacts a listening socket TCP server socket to open a TCP connection a new TCP socket and a first instance of a GDB stub is created. The simulation controller is a mirror of the TCP sockets in the simulation . Thus when a GDB connects to a socket the simulation controller creates a TCP socket that connects a second instance of the GDB stub for the simulation . The GDB remote serial protocol bride transparently forwards the remote serial protocol driven by the GDB . An instance of the GDB remote serial protocol bridge is created per such TCP connection .

There is always a TCP server socket even if no GDB is connected. The GDB stub is the owner of its respective TCP connection and the TCP connection sockets are the end points of the respective TCP connections . There may be multiple such TCP server sockets in a simulation providing GDBs different gates to connect to the simulation . Furthermore if multiple GDBs are attached to the simulation controller in order to be forwarded to the simulation there is one instance of the GDB remote serial protocol bridge per attached GDB .

During checkpointing restoring or restarting the simulation controller is detached from the GDB stub in the simulation as depicted in . First while the simulation controller is preparing for checkpointing it closes the TCP connection . The simulation controller then requests checkpointing and the notification framework notifies all user modules to shutdown OS resources. As a consequence the TCP server socket is shutdown. The simulation controller terminates the GDB remote serial protocol by answering delaying and or aborting commands issued by the GDB in such a way that the GDB does not close the TCP connection and detach from the simulation controller as illustrated in .

The embodiments of the present technology advantageously provide full support for multithreading usage of operating system dependent resources or inter process communication channels as required for checkpointing restoring and restarting of SystemC simulations with debugger connectivity. The checkpointing techniques include closing connections to peer processes shutting down operating system resources in user code modules storing an image of a simulation as checkpoint after the user code modules and peer processes have been prepared for checkpointing and re establishing the state of user code modules and peer processes after storing an image of the simulation. The resulting checkpoint can be used for restoring from a checkpoint or restarting a new simulation.

The foregoing descriptions of specific embodiments of the present technology have been presented for purposes of illustration and description. They are not intended to be exhaustive or to limit the invention to the precise forms disclosed and obviously many modifications and variations are possible in light of the above teaching. The embodiments were chosen and described in order to best explain the principles of the present technology and its practical application to thereby enable others skilled in the art to best utilize the present technology and various embodiments with various modifications as are suited to the particular use contemplated. It is intended that the scope of the invention be defined by the Claims appended hereto and their equivalents.

