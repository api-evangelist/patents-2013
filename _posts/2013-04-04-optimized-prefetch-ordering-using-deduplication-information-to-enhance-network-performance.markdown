---

title: Optimized pre-fetch ordering using de-duplication information to enhance network performance
abstract: A computer determines a degree of information duplication between at least two files included in an original pre-fetch list. The computer generates a re-ordered pre-fetch list by re-ordering the files included in the original pre-fetch list. The re-ordering is based, at least in part, on the degree of information duplication between the two files included in the original pre-fetch list. The files included in the original pre-fetch list are re-ordered by grouping files containing higher degrees of duplicate information closer together in the re-ordered pre-fetch list.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09471582&OS=09471582&RS=09471582
owner: International Business Machines Corporation
number: 09471582
owner_city: Armonk
owner_country: US
publication_date: 20130404
---
The present invention relates generally to the field of network performance and more particularly to enhancing network performance by optimizing pre fetch ordering.

Geographically distributed entities such as a business with multiple local offices in different geographic locations frequently desire to maintain a logically unified proprietary network that is accessible by all of the geographically distributed entities. To accomplish this a wide area network WAN may be used to link the different locations.

Information technology IT managers within geographically distributed entities face the conflicting requirements of keeping costs in check while providing users with new and faster applications. This conflict is most acute on the WAN where costs can be high and obtaining applications to perform well is hampered by limited bandwidth and high latency.

A computer determines a degree of information duplication between at least two files included in an original pre fetch list. The computer generates a re ordered pre fetch list by re ordering the files included in the original pre fetch list. The re ordering is based at least in part on the degree of information duplication between the two files included in the original pre fetch list. The files included in the original pre fetch list are re ordered by grouping files containing higher degrees of duplicate information closer together in the re ordered pre fetch list.

In computing data de duplication is a specialized data compression technique for eliminating duplicate copies of repeating data. Related and somewhat synonymous terms are intelligent data compression and single instance data storage. The technique is used to improve storage utilization and can also be applied to network data transfers to reduce the number of bytes that must be sent. In the de duplication process unique chunks of data or byte patterns are identified and stored during a process of analysis. As the analysis continues other chunks are compared to the stored copy and whenever a match occurs the redundant chunk is replaced with a small reference that points to the stored chunk. Given that the same byte pattern may occur dozens hundreds or even thousands of times the match frequency is dependent on the chunk size the amount of data that must be stored or transferred can be greatly reduced.

This type of de duplication is different from that performed by standard file compression tools identify short repeated substrings inside individual files. The goal of storage based data de duplication is to inspect large volumes of data and identify large sections such as entire files or large sections of files which are identical in order to store only one copy. The copy may be additionally compressed by single file compression techniques.

One of the most common forms of data de duplication implementations works by comparing chunks of data to detect duplicates. For that to happen each chunk of data is assigned an identification calculated by the software typically using cryptographic hash functions. In many implementations the assumption is made that if the identification is identical the data is identical even though this cannot be true in all cases due.

Other implementations do not assume that two blocks of data with the same identifier are identical but actually verify that data with the same identification is identical. If the software either assumes that a given identification already exists in the de duplication namespace or actually verifies the identity of the two blocks of data depending on the implementation then the software will replace that duplicate chunk with a link. Once the data has been de duplicated upon read back of the file wherever a link is found the system simply replaces that link with the referenced data chunk.

A clustered file system is a file system which is shared by being simultaneously mounted on multiple servers. Many computer clusters use clustered file systems. Servers are often underpinned by a clustered file system to control the complexity of the underlying storage environment used by the servers which typically increases as servers are added to the computer cluster.

A shared disk file system uses a storage area network SAN to provide direct disk access from multiple computers at the block level. Translation from file level operations which applications use to block level operations used by the SAN must take place on the client node. A shared disk file system a common type of clustered file system adds a mechanism for concurrency control that gives a consistent view of the file system which can be serialized. The serialization of the file system reduces data corruption and unintended data loss even when multiple clients try to access the same files at the same time. Often shared disk file systems further employ a data fencing mechanism to prevent data corruption in case of node failures.

There are different architectural approaches to a shared disk file system since the underlying storage area network might use any of a number of known block level protocols. Some shared disk file systems distribute file information across all the servers in a cluster fully distributed . Other shared disk file systems utilize a centralized metadata server. Both approaches achieve the same result i.e. enabling all servers to access all the data on a shared storage device.

In common with typical cluster file systems a General Parallel File System GPFS is a high performance shared disk clustered file system. A GPFS provides concurrent relatively high speed file access to applications executing on multiple nodes of clusters. In addition to providing file system storage capabilities GPFS provides tools for management and administration of the GPFS cluster and allows for shared access to file systems from remote GPFS clusters.

GPFS introduced the concept of file partitioning to accommodate the needs of parallel applications that run on high performance multi computers with parallel I O subsystems. With partitioning a file is not a sequence of bytes but rather multiple disjoint sequences that may be accessed in parallel. The partitioning is such that it abstracts away the number and type of I O nodes hosting the file system and the partitioning allows a variety of logical partitioned views of files regardless of the physical distribution of data within the I O nodes. The disjoint sequences are arranged to correspond to individual processes of a parallel application allowing for improved scalability.

GPFS has been successfully deployed for many commercial applications including digital media grid analytics and scalable file service. GPFS provides high performance by allowing data to be accessed over multiple computers at once. Many existing file systems are designed for a single server environment and adding more file servers does not improve performance. In general GPFS provides higher input output performance by striping blocks of data from individual files over multiple disks and reading and writing these blocks in parallel.

There are many approaches to help improve performance over the WAN portion of a network. These solutions may be based on a number of technologies including data compression data caching application specific acceleration policy based bandwidth allocation and data pre fetching.

Data pre fetching in particular may be used to reduce the perceived latency response time of data being accessed over a WAN. In general the phrase data pre fetching may include requesting and retrieving data in advance of an actual user or application level request. One problem encountered when pre fetching data is the determination of what data to pre fetch as well as when and how frequently to perform the pre fetching operation. Pre fetching unnecessary data can result in wasted resources while pre fetching too infrequently can result in decreased performance for system users.

As will be appreciated by one skilled in the art aspects of the present invention may be embodied as a system method or computer program product. Accordingly aspects of the present invention may take the form of an entirely hardware embodiment an entirely software embodiment including firmware resident software micro code etc. or an embodiment combining software and hardware aspects that may all generally be referred to herein as a circuit module or system. Furthermore aspects of the present invention may take the form of a computer program product embodied in one or more computer readable medium s having computer readable program code instructions embodied thereon.

Any combination of computer readable media may be utilized. Computer readable media may be a computer readable signal medium or a computer readable storage medium. A computer readable storage medium may be for example but not limited to an electronic magnetic optical electromagnetic infrared or semiconductor system apparatus or device or any suitable combination of the foregoing. More specific examples a non exhaustive list of a computer readable storage medium would include the following an electrical connection having one or more wires a portable computer diskette a hard disk a random access memory RAM a read only memory ROM an erasable programmable read only memory EPROM or Flash memory an optical fiber a portable compact disc read only memory CD ROM an optical storage device a magnetic storage device or any suitable combination of the foregoing. In the context of this document a computer readable storage medium may be any tangible medium that can contain or store a program for use by or in connection with an instruction execution system apparatus or device.

A computer readable signal medium may include a propagated data signal with computer readable program code embodied therein for example in baseband or as part of a carrier wave. Such a propagated signal may take any of a variety of forms including but not limited to electro magnetic optical or any suitable combination thereof. A computer readable signal medium may be any computer readable medium that is not a computer readable storage medium and that can communicate propagate or transport a program for use by or in connection with an instruction execution system apparatus or device.

Program code embodied on a computer readable medium may be transmitted using any appropriate medium including but not limited to wireless wireline optical fiber cable RF etc. or any suitable combination of the foregoing.

Computer program code for carrying out operations for aspects of the present invention may be written in any combination of one or more programming languages including an object oriented programming language such as Java Smalltalk C or the like and conventional procedural programming languages such as the C programming language or similar programming languages. The program code may execute entirely on a user s computer partly on the user s computer as a stand alone software package partly on the user s computer and partly on a remote computer or entirely on the remote computer or server. In the latter scenario the remote computer may be connected to the user s computer through any type of network including a local area network LAN or a wide area network WAN or the connection may be made to an external computer for example through the Internet using an Internet Service Provider .

Aspects of the present invention are described below with reference to flowchart illustrations and or block diagrams of methods apparatus systems and computer program products according to embodiments of the invention. It will be understood that each block of the flowchart illustrations and or block diagrams and combinations of blocks in the flowchart illustrations and or block diagrams can be implemented by computer program instructions. These computer program instructions may be provided to a processor of a general purpose computer special purpose computer or other programmable data processing apparatus to produce a machine such that the instructions which execute via the processor of the computer or other programmable data processing apparatus create means for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

These computer program instructions may also be stored in a computer readable medium that can direct a computer other programmable data processing apparatus or other devices to function in a particular manner such that the instructions stored in the computer readable medium produce an article of manufacture including instructions which implement the function act specified in the flowchart and or block diagram block or blocks.

The computer program instructions may also be loaded onto a computer other programmable data processing apparatus or other devices to cause a series of operational steps to be performed on the computer other programmable apparatus or other devices to produce a computer implemented process such that the instructions which execute on the computer or other programmable apparatus provide processes for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

The present invention will now be described in detail with reference to the Figures. The exemplary embodiments described herein are typically adapted for use in a GPFS cluster file system. However this is not to be interpreted as a limitation. Other embodiments can be adapted for integration and use by different types of file systems.

In this exemplary embodiment computing device is connected to computing device through network . Computing device includes list reordering program physical block set generator weighted graph generator and original data . Computing device includes application programming interface API interface initial list and copied data . In exemplary embodiments computing device and computing device may be included in General Parallel File System GPFS not shown which is included in data trafficking environment .

In various embodiments of the present invention computing device and computing device are computing devices that can be standalone devices servers laptop computers tablet computers netbook computers personal computers PCs or desktop computers. In another embodiment computing device and computing device represent computing systems utilizing clustered computers and components to act as a single pool of seamless resources. In general computing device can be any computing device or a combination of devices with access to list reordering program physical block set generator weighted graph generator and original data and is capable of running list reordering program . In general computing device can be any computing device or a combination of devices with access to API interface initial list and copied data and is capable of running API interface . Computing device and computing device may include internal and external hardware components as depicted and described in further detail with respect to .

In this exemplary embodiment list reordering program physical block set generator weighted graph generator and original data are stored on computing device . However in other embodiments list reordering program physical block set generator and weighted graph generator may be stored externally and accessed through a communication network such as network . Network can be for example a local area network LAN a wide area network WAN such as the Internet or a combination of the two and may include wired wireless fiber optic or any other connection known in the art. In general network can be any combination of connections and protocols that will support communications between computing device and list reordering program physical block set generator weighted graph generator original data and computing device in accordance with a desired embodiment of the present invention.

Computing device is in exemplary embodiments a home site included in a GPFS cluster file system. A home site is the source of an original data that is sent to other computing devices in response to a request for the original data which is included in original data . Original data includes in general original data such as original pre fetch file lists virtual block lists and physical block sets that are used by other programs as well as other data such as re ordered pre fetch lists and other data used by list reordering program physical block set generator and weighted graph generator .

Computing device is in exemplary embodiments a cache site included in a GPFS cluster file system. Computing device caches data locally in persistent data storage i.e. saves the data as part of copied data for use by other programs for example client applications. The other programs or client applications can be included in computing device but are typically located externally on other computing devices that are in contact with computing device via network . If a program such as a client application is requesting access to a file for the first time then the file is fetched from the home site e.g. computing device and copied to GPFS file system at the cache site. Subsequent requests for the file are served from local cache site thereby reducing the need for additional WAN bandwidth to transfer the same data repeatedly.

In exemplary embodiments computing device includes API interface . API interface is an application programming interface API program that determines which requested files have overlaps. Since de duplication is performed only on computing device computing device uses API interface to re order the pre fetch list based on which requested files have overlaps. API interface eliminates the need to perform de duplication on the both the home site e.g. computing device and the cache site e.g. computing device for the same requested file.

In exemplary embodiments in general list reordering program receives an initial list of requested files which are included in initial list from computing device . In response list reordering program activates physical block set generator and weighted graph generator . Physical block set generator generates a physical block set and weighted graph generator generates a weighted graph for the blocks of data included in the requested files. The physical block set and weighted graph are utilized by list reordering program to generate a re ordered pre fetch list for the requested files. The re ordered pre fetch list is then passed to computing device which then reads the files following the order indicated by the re ordered pre fetch list.

A more detailed description of how list reordering program re orders a pre fetch list is now described in accordance with an exemplary embodiment. In general list reordering program re orders the files included in an original pre fetch list by grouping files that contain higher degrees of duplicate information closer together in a re ordered pre fetch list. After receiving a pre fetch file list list reordering program determines a list of virtual blocks that are associated with the requested file. List reordering program queries an integral de duplication engine i.e. the de duplication engine is included in list reordering program to generate a list of associated unique physical blocks. These associated unique physical blocks are added to a block set associated with the file. The block set for each file is compared with other file block sets included in the pre fetch list to identify sets of common blocks. List reordering program determines the degree of separation between at least two files included in the original pre fetch list i.e. number of files separating two given files included in the original pre fetch list and re orders the pre fetch file list to minimize the sending of duplicate physical blocks. In certain embodiments the de duplication engine is not integral to but is accessible by list reordering program .

A weighted graph is generated by weighted graph generator with a node representing a given file and the edges extending from the node representing the blocks shared with other files. The weight of an edge is assigned based on the number of common blocks shared among given pair of files. In the case of connected sub trees weight is assigned which is sum of weights of all edges in the sub tree. For each sub tree ordered sub lists are created considering nodes in descending order of weight of edges associate with the given node. A new pre fetch list is created by list reordering program merging all the ordered sub lists. In general sub lists are considered in the descending order of weights of their associated sub trees while adding to a re ordered pre fetch list. The re ordered pre fetch list is passed to the cache site computing device which can read files in the specified file sequence indicated by the re ordered pre fetch list.

In an exemplary embodiment physical block set generator receives an original pre fetch file list in step . Typically the pre fetch file list is sent from computing device to computing device which passes the original pre fetch file list to physical block set generator and saves a copy of the original pre fetch file list to original data . In other embodiments physical block set generator can generate the original pre fetch file list after receiving a set of criteria from the cache site. The criteria can include information such as the file names and preferences for sending the files.

In an exemplary embodiment in step physical block set generator identifies the files included in the original pre fetch file list and then generates a virtual block list in step which is saved as part of original data . The virtual block list is a list of the pieces of data i.e. virtual blocks that are included in the files included in the original pre fetch file list. Physical block set generator queries the de duplication engine included in list reordering program to retrieve the physical blocks associated with each virtual block in step . Then in step physical block set generator populates a physical block set with all the unique physical blocks that were identified in step . In other words only one copy of each physical block is added to the physical block set even if the physical block exists in multiple files. For example if files A and B both include virtual block PT1567c then only one copy of the physical block corresponding to virtual block PT1567c is added to the physical block set.

In an exemplary embodiment in decision step physical block set generator determines if all the files have been processed i.e. all the virtual and physical blocks have been processed for each file. If all the files have not been processed decision step no branch i.e. the physical blocks included in each file exist have not been added to the physical block set then physical block set generator returns to step . If all the files have been processed decision step yes branch i.e. the physical blocks included in each file exist have been added to the physical block set then physical block set generator proceeds to step . In step physical block set generator generates a file that includes the physical block set and saves the file as part of original data .

In an exemplary embodiment weighted graph generator begins creating a weighted graph by adding a node to the graph for each file in step . In step weighted graph generator retrieves the virtual block list for each file from original data . Weighted graph generator identifies the common blocks i.e. virtual blocks included in both files included in each file and sums them to create a weight between two respective files in step . For example files A and B both include virtual blocks XY8904mH GT6754sR and WS3456dS which each carry a weight of 1. Therefore weighted graph generator determines that the sum of the weights of the common virtual blocks is 3. The weight of three represents a numerical value applied the degree of overlap or number of virtual blocks that are common between the two files.

In an exemplary embodiment weighted graph generator determines if the sum from step of the virtual blocks is a non zero value in decision step . If the sum of the virtual blocks is a non zero value i.e. a number greater than zero decision step yes branch then weighted graph generator proceeds to step . In step weighted graph generator adds an edge to the weighted graph that connects the two files. The edge has an assigned weight that corresponds to the sum value generated in step . After the edges have been added to connect the files weighted graph generator proceeds to decision step .

If the sum of the virtual blocks is not a non zero value i.e. is equal to zero decision step no branch then weighted graph generator proceeds to decision step . In decision step weighted graph generator determines if all the virtual blocks included in files which are included as part of original data have been analyzed. In other words weighted graph generator determines if all the virtual blocks included in all the files have been analyzed i.e. had edges assigned and added to the weighted graph where applicable. If there are still files i.e. virtual blocks that have not been analyzed decision step no branch then weighted graph generator returns to step . If all the virtual blocks that have been analyzed decision step yes branch then weighted graph generator proceeds to step . In step weighted graph generator generates a file for the physical block set that includes the weighted graph and saves the file as part of original data .

In an exemplary embodiment list reordering program creates an empty re ordered pre fetch list in step . Then list reordering program retrieves the weighted graph from original data and determines a weight of the sub tree s in step . In other words list reordering program sums the edges connected to each node i.e. each file to determine the weight for that sub tree. List reordering program ranks the sub tree s according to descending order of weight in step .

In an exemplary embodiment list reordering program then creates an empty sub list for each sub tree in step . To fill an empty sub list for a sub tree in step list reordering program adds the node with the highest rank to the sub list followed by the connected node s i.e. nodes that share an edge with the added node according to highest edge weight. For example a sub tree for node A includes nodes B E which are connected to node A via weighted edges. The sub tree for node A has the highest weight of all the sub trees and node A is connected to node D with an edge that has the highest weight of all edges connected to node A. Therefore list reordering program adds node A into the first slot of the sub list and node D into the second slot. The remaining nodes i.e. nodes B C and E are then added to the sub list according their associated edge weight i.e. the node with the highest associated edge weight to node A being added first. As such if edge A B has a weight of 4 edge A C has a weight of 3 and edge A E has a weight of 6 then the slots of the sub list would be filled as follows A D E B and C.

In an exemplary embodiment list reordering program determines if all the edges and nodes included in the weighted graph have been processed in decision step . If all the edges and nodes have been processed decision step yes branch then list reordering program proceeds to step . If there are any edges or nodes that have not been processed decision step no branch then list reordering program proceeds to decision step .

In an exemplary embodiment list reordering program determines if the unprocessed item is an edge in decision step . If the unprocessed item is not an edge decision step no branch i.e. the unprocessed item is a node then list reordering program returns to step . If the unprocessed item is an edge decision step yes branch then list reordering program determines if both of the nodes connected by the edge have both been processed in decision step . If either of the nodes have not been processed decision step no branch then list reordering program returns to step . If both nodes have been processed decision step yes branch then list reordering program proceeds to step .

In an exemplary embodiment in step list reordering program adds the sub lists to the empty re ordered pre fetch list. Then list reordering program saves a copy of the filled re ordered pre fetch list as part of original data in step .

In some embodiments the re ordering of data writes can also be performed using a substantially similar approach to that of re ordering of a pre fetch list i.e. reads . Based on de duplication information the blocks in a write request can be re ordered as seen in the read request e.g. the generation of a re ordered pre fetch list.

However to perform a re ordering of writes when utilizing file groups the issue of write after write WAW data hazard must be addressed. File groups expect updates to a set of independent files to be applied in a specific order. The issue of write order can be addressed through the inclusion of an appropriate set of techniques which can re order the writes before they are written e.g. by applying a set of techniques for memory disambiguation.

For example writes for files A B and C are supposed to be written into respective slots and within a file group environment. List reordering program is applied and the files are thus sent in the order of B C and A. If a write were to be performed at this point then the files would not be written into their correct slots. However through the application of techniques for memory disambiguation the files can be written in the appropriate slot as they are received. In other words file B is received first and is written to slot then file C is received and written to slot finally file A is received and is written to slot .

The exemplary embodiment s disclosed are not to be interpreted as a limitation to only those techniques and methods utilized by those exemplary embodiment s . There are many possible ways in which a pre fetch list and or write list can be re ordered. In other embodiments the methods and techniques used to re order a pre fetch list and or a write list can vary.

Computing device and computing device include respective communications fabric which provides communications between computer processor s memory persistent storage communications unit and input output I O interface s . Communications fabric can be implemented with any architecture designed for passing data and or control information between processors such as microprocessors communications and network processors etc. system memory peripheral devices and any other hardware components within a system. For example communications fabric can be implemented with one or more buses.

Memory and persistent storage are computer readable storage media. In this embodiment memory includes random access memory RAM and cache memory . In general memory can include any suitable volatile or non volatile computer readable storage media.

List reordering program physical block set generator weighted graph generator original data API interface initial list and copied data are stored in persistent storage for execution and or access by one or more of the respective computer processors via one or more memories of memory . In this embodiment persistent storage includes a magnetic hard disk drive. Alternatively or in addition to a magnetic hard disk drive persistent storage can include a solid state hard drive a semiconductor storage device read only memory ROM erasable programmable read only memory EPROM flash memory or any other computer readable storage media that is capable of storing program instructions or digital information.

The media used by persistent storage may also be removable. For example a removable hard drive may be used for persistent storage . Other examples include optical and magnetic disks thumb drives and smart cards that are inserted into a drive for transfer onto another computer readable storage medium that is also part of persistent storage .

Communications unit in these examples provides for communications with other data processing systems or devices including resources of computing device . In these examples communications unit includes one or more network interface cards. Communications unit may provide communications through the use of either or both physical and wireless communications links. List reordering program physical block set generator weighted graph generator original data API interface initial list and copied data may be downloaded to persistent storage through communications unit .

I O interface s allows for input and output of data with other devices that may be connected to computing device . For example I O interface may provide a connection to external devices such as a keyboard keypad a touch screen and or some other suitable input device. External devices can also include portable computer readable storage media such as for example thumb drives portable optical or magnetic disks and memory cards. Software and data used to practice embodiments of the present invention e.g. list reordering program physical block set generator weighted graph generator original data API interface initial list and copied data can be stored on such portable computer readable storage media and can be loaded onto persistent storage via I O interface s . I O interface s also connect to a display .

Display provides a mechanism to display data to a user and may be for example a computer monitor or a television screen.

The programs described herein are identified based upon the application for which they are implemented in a specific embodiment of the invention. However it should be appreciated that any particular program nomenclature herein is used merely for convenience and thus the invention should not be limited to use solely in any specific application identified and or implied by such nomenclature.

The flowchart and block diagrams in the Figures illustrate the architecture functionality and operation of possible implementations of systems methods and computer program products according to various embodiments of the present invention. In this regard each block in the flowchart or block diagrams may represent a module segment or portion of code which comprises one or more executable instructions for implementing the specified logical function s . It should also be noted that in some alternative implementations the functions noted in the block may occur out of the order noted in the figures. For example two blocks shown in succession may in fact be executed substantially concurrently or the blocks may sometimes be executed in the reverse order depending upon the functionality involved. It will also be noted that each block of the block diagrams and or flowchart illustration and combinations of blocks in the block diagrams and or flowchart illustration can be implemented by special purpose hardware based systems that perform the specified functions or acts or combinations of special purpose hardware and computer instructions.

