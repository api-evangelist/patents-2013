---

title: Ordered kernel queue for multipathing events
abstract: An improved technique for handling events in a multipathing driver employs an event queue and a queue manager that run in the kernel of a computing system. The queue manager receives events raised by the multipathing driver, as well as events raised by software constructs, such as application programs. Records of events are added to the event queue in the order the queue manager receives them. Event records may be consumed chronologically by external software. Preferably, the event queue is sufficiently large to store all events arising out of most predicted fault scenarios. Also, the queue manager is sophisticated and can perform certain diagnostic and analysis tasks without the aid of external software.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08904063&OS=08904063&RS=08904063
owner: EMC Corporation
number: 08904063
owner_city: Hopkinton
owner_country: US
publication_date: 20130429
---
Host computing systems or simply hosts such as data servers web servers and enterprise computing systems typically employ storage arrays for storing large amounts of data. Hosts generally connect to respective storage arrays through multiple paths. Multiple paths allow for redundant connections parallel data transmission load balancing and failover.

A typical host employs a multipathing driver to manage the various paths connecting the host to the storage array. The multipathing driver is installed as a kernel extension in the host s operating system. Typical roles of the multipathing driver include selecting paths for optimal load balancing between the host and the storage array and responding to faults by routing data around inoperative paths. An example of a multipathing driver is the PowerPath driver from EMC Corporation of Hopkinton Mass.

Multipathing drivers are generally configured to raise events. As is known events are occurrences in or pertaining to hosts paths or storage arrays which can be detected and recorded. Most conventional multipathing drivers are configured to store records of events in a system log. The system log typically resides in a file accessible in a file system of the host. Software programs can obtain information about events by accessing the system log e.g. log scraping and applying intelligent algorithms to diagnose or predict problems. In addition to using system logs the PowerPath driver also stores a single record of an event in kernel memory. A software interface provided with this driver allows applications such as data storage administration programs to direct the driver to return the next event that occurs. If an event occurs within a designated timeout interval a record of the event is sent to the application through the software interface. The application can then examine the event record to obtain information about the host paths or storage array.

The ability of data storage administrators to access records of events from the system log and from the multipathing driver affords data storage administrators an opportunity to diagnose and predict problems with the host paths or storage array. For example information from the log file can be used forensically to reconstruct a series of events that led to a particular failure thus explaining the failure. Also information from the log file that indicates that multiple paths have become inoperative can be used to predict that a data storage request might imminently fail or become unacceptably slow e.g. if even more paths become inoperative . In addition event records from the multipathing driver can be used for testing purposes e.g. to determine whether a particular stimulus applied to a path causes an expected response to occur in the form of a raised event.

The conventional approach to managing events among hosts paths and storage arrays involves certain drawbacks. For example the conventional approach relies heavily upon use of the system log. It has been observed however that access to the system log is not always easily obtained. Multipathing drivers are generally designed to function with many different operating systems. Each operating system typically requires configuring its own system specific daemon for exchanging information between the multipathing driver and the system log. System specific daemons are often burdensome to maintain as operating systems are updated. In addition new daemons must be configured when new operating systems come online. Indeed some operating systems such as embedded operating systems often prohibit use of these daemons altogether significantly compromising the ability of a computing system to obtain useful information about events.

In addition storage of event records in the system log can involve unpredictable delays which undermine the timing accuracy of event records. In the conventional scheme an event is written to the system log by the multipathing driver through various operating system constructs. However logging of the event can be variably delayed based on other activities that the operating system is performing at the same time. Although the system log generally applies a timestamp to each incoming event the timestamp reflects the time when the system log actually receives the event which can differ substantially and variably from the time the event actually occurs. Information about time critical events can therefore be lost or distorted.

In contrast with the above described conventional approach which often involves burdensome maintenance of different software daemons for use with different operating systems and introduces unpredictable latency when timestamping events an improved technique for handling events employs an event queue running within a multipathing driver installed in an operating system kernel. As the event queue is located within the multipathing driver there is no need for operating system specific daemons that communicate with system logs to obtain event records. Burdensome activities associated with maintaining different daemons for different operating systems can be therefore avoided. The multipathing driver adds events to the event queue in the order received and timestamps events upon receipt. As timestamps are applied locally within the multipathing driver itself variable delays inherent in timestamping events at the system log can be avoided as well. The multipathing driver is preferably sophisticated and can provide support to external software for performing diagnostic and analysis tasks.

One embodiment of the improvement hereof is directed to a method of managing events pertaining to input output I O activities in a computing system coupled to a storage array through multiple paths. The method includes receiving multiple first events by a queue manager that manages an event queue. The queue manager and the event queue are parts of a multipathing driver running within a kernel of the computing system. The first events originate from within the multipathing driver. The method further includes receiving multiple second events by the queue manager. The second events originate from a software construct running outside the kernel of the computing system. The method still further includes storing records of the first events and the second events in the event queue including chronologically ordering the records of events in the order received by the queue manager.

Other embodiments are directed to computerized apparatus and computer program products. Furthermore some embodiments involve activity that is performed at a single location while other embodiments involve activity which is distributed over a computerized environment e.g. over a network .

Improved techniques for managing events employ an event queue running within a multipathing driver installed in an operating system kernel. The multipathing driver adds events to the event queue in the order received and timestamps events upon receipt. The multipathing driver is preferably sophisticated and can perform certain analysis tasks without the aid of external software.

A multipathing driver which includes an event queue runs within the operating system kernel . The multipathing driver generally runs in volatile memory. A software interface such as an API application programming interface runs in the memory for interfacing application programs e.g. and with the multipathing driver . It is understood that the set of processors and the memory function cooperatively and can be regarded as forming a specialized circuit which performs the various processes and functions described herein.

In some embodiments the memory also includes a system log for storing event records. The system log is generally stored in a file in non volatile memory e.g. on a disk drive . However the role of the system log is generally reduced relative to conventional approaches.

As indicated the multipathing driver runs within the kernel and is equipped with an event queue for maintaining events raised or received by the multipathing driver . The presence of the event queue within the kernel reduces and in many cases completely avoids reliance on the system log as a source of information about events.

The host also includes a number of host bus adapters . The host bus adapters connect the host to the storage array via the transmission medium and enable the host to send and receive large amount of data at high speed to and from the storage array . Multiple host bus adapters afford redundancy parallelism failover and high throughput. Occurrences within the host bus adapters can cause events to be raised within the multipathing driver which are stored in the event queue .

The transmission medium includes Initiator Target nexi I T s or buses . Each bus aggregates multiple Initiator Target LUNs I T L s i.e. paths and can extend over arbitrarily long distances. In an example the computing environment follows a SCSI communications standard SCSI is an acronym for Small Computer System Interface . Accordingly the host bus adapters perform the role of SCSI initiators aggregating paths from the host onto the buses . As with the host bus adapters occurrences within the transmission medium can cause events to be raised within the multipathing driver which are stored in the event queue .

The storage array is preferably a disk array or some other array of non volatile storage elements. In the example shown the storage array includes SCSI targets . Individual paths I T L s branch from the SCSI targets and extend to various logical storage units or LUNs . Any number of LUNs may be provided and many LUNs can be accessed by the host through each bus I T . Each LUN is a separately identifiable storage volume which is logically but not necessarily physically distinct from other LUNs . Various switches and computing nodes may also be included in the transmission medium or within the storage array however these are omitted from the figure for the sake of clarity. As with the host bus adapters and the transmission medium occurrences within the storage array can also cause events to be raised within the multipathing driver which are stored in the event queue .

The host is typically a server with high data throughput to the storage array . However the host can be any type of computing device such as a server desktop computer laptop computer or even a computing pad smart phone PDA or similar device. The operating system can be any type of operating system that supports the installation of the multipathing driver as a kernel extension. These may include conventional GUI based operating systems embedded operating systems real time operating systems and so forth. Non limiting examples include the Windows operating system Unix or Red Hat Linux or vSphere from VMware for instance. In some examples the operating system is provided in the form of a hypervisor that supports multiple virtual machines.

In operation the host reads data from and writes data to the storage array via the transmission medium . The host itself can initiate read and write operations and or the host can receive read and write requests from an external computing device. For example the host can be configured as a data server and numerous external computing devices can connect to the host to access data in the storage array .

As the host operates events can be raised. These events are stored in the event queue . The data storage management program and complex event processor as well as other application programs can access the event queue via the API to perform high level event processing such as auditing notification fault diagnosis and fault prediction. Generally events are logged to the system log contemporaneously with the events being stored in the event queue . In some implementations the data storage management program and complex event processor can also access the system log to perform event processing.

The event queue includes numerous records. These records are preferably associated in the form of a linked list such as a FIFO i.e. a linked list administered with a first in first out policy . Event records are pushed onto the FIFO in the order the queue manager receives them. Each event record in the event queue preferably includes multiple fields such as an event ID a timestamp an event type and a message .

The event ID field stores a number such as a 64 bit integer which uniquely identifies each event. The event ID is incremented for each new event record pushed onto the event queue . The queue manager manages wrapping of event IDs.

The timestamp field designates the date and time that each event is received by the queue manager . The timestamp may be acquired locally e.g. within the driver or it may be obtained from elsewhere within the operating system kernel .

The event type field designates the type of event received. Events are classified according to various predetermined types where different event types pertain to different kinds of occurrences. Some event types relate to lifecycle occurrences e.g. Create Path Create Bus Remove Bus Add Volume . Others relate to the condition of various components e.g. Path Up Path Down Volume Down . Still others relate to notices created by software constructs and expressed as events so that they can be available for consumption on the queue . The set of possible event types may change as computing systems acquire new hardware or software as hardware and software become obsolete and or as capabilities change.

The message field contains additional information about an event. The information can include hardware details such as path bus or volume information. It may also include messages generated by the queue manager or messages generated by the application programs . Messages from application programs include a wide range of content including notes for the queue as well as designations of I O policies that the application programs can set for the multipathing driver e.g. SymOpt CLARopt or round robin for example .

The queue manager performs a wide range of functions such as receiving events recording events and managing the event queue . The queue manager includes a number of kernel level software constructs. These include an Append Construct a Prune Construct a Summary Construct a Pool Construct and a Query Construct

The Append Construct appends new event records to the event queue in the order the queue manager receives them. The Append Construct assigns event IDs and timestamps to events. Event IDs are produced using a software counter which is incremented for each new event record pushed onto the event queue . Timestamps are acquired internally to the multipathing driver or via a system call.

The Prune Construct implements a policy for removing event records from the event queue when the event records are no longer needed or when the event queue becomes full. The policy may simply be to allow the oldest event records in the event queue to expire and fall off the event queue . A more sophisticated policy may preserve records of more important events while allowing records of less important events to expire. For example events pertaining to buses are generally deemed more important that events pertaining to paths since each bus contains multiple paths . In some examples the Prune Construct may thus preserve bus events while allowing path events arising out of the same faults to expire.

The Summary Construct performs local kernel based event processing which may include for example correlation of events aggregation of related events and filtering of redundant events. The Summary Construct can itself produce events which provide summary information about the condition of the host transmission medium and or storage array . These events are conveyed to the Append construct where they are given event IDs and timestamps and where they are ordered in the event queue along with other events e.g. events and . Each event record produced by the Summary Construct generally has a message that summarizes results of any event processing in textual form.

The Pool Construct performs memory allocation functions. In particular the Pool Construct allocates a pool of kernel memory for use by the event queue . The pool may be expanded or contracted based on the number of event records the event queue is desired to maintain. The Pool Construct can compute the size of the pool based on various factors such as the amount of available kernel memory the number of events that are expected to arise out of an expected set of circumstances or the number of paths used to connect the computing system to the storage array .

The Query Construct performs queries of the event queue . Queries can be received from the API e.g. from the Select Interface or may be produced internally within the multipathing driver . The Query Construct tests the contents of the event queue against various criteria to produce sets of matching records for use by application programs or other software constructs.

In some examples the query construct operates in connection with a client table . The client table is preferably an array or other data structure within the multipathing driver which stores client specific information in connection with client identifiers client IDs . Each client ID identifies a software construct and or user that accesses the multipathing driver . The client table stores for example the event ID of the last event record of the event queue consumed by the client identified by the client ID. The client table also stores for example an event mask that can be applied to any queries made by the client designated by the client ID. The event mask operates to further narrow any queries received from the client based on the client s previous interactions with the multipathing driver so that records returned from queries have greater relevance to the client. In one example the client table is populated with information over time as the multipathing driver interacts with different clients. Client IDs and information extracted from client interactions with the multipathing driver are stored in the client table for later use when the clients again interact with the multipathing driver to query the event queue . The client table is preferably maintained using minimal memory resources. For example the client ID and associated event ID and mask for a client are typically purged or pruned after a prolonged period of inactivity of the client.

Events fall broadly into two categories first events and second events. First events are those which originate within the multipathing driver . These include events and events . The events arise from event detecting code of the multipathing driver and the events arise from the Summary construct as described above. Events result from the multipathing driver detecting certain conditions relating to the host the transmission medium the storage array the multipathing driver itself or other components of the computing environment . For example if a path becomes inoperative the multipathing driver can detect the inoperative state via the event detecting code and raise a Path Down event. The event is then conveyed to the Append construct for storage on the event queue . It is understood the events originate within the driver even though the circumstances on which they are based can occur anywhere in the computing environment .

The second events arise from software constructs outside the kernel such as the data storage management program and the complex event processor and are conveyed to the multipathing driver via the Push Interface of the API . These events include messages that can be added to or pushed onto the event queue . The messages can take any form but typically include summary messages and audit messages. Summary messages provide high level diagnostic or prognostic information. Audit messages report actions taken by an application program or other software construct and explain or put into context other events. For example an application program can disable a particular path for testing purposes. Disabling the path typically causes a Path Down event to be created automatically by the multipathing driver . In this situation an audit message can be pushed onto the event queue to inform other users or programs that the contemporaneous Path Down event does not indicate a fault in the system but rather a proper response to a test.

The second events conveying summary and audit messages are received by the queue manager assigned event IDs timestamped and pushed onto the event queue . Second events are stored in the event queue along with first events and where events are stored in the order the queue manager receives them irrespective of their origin.

In contrast with the Push Interface which causes event records to be written to the multipathing driver the Wait Interface and the Select Interface cause event records to be read from the multipathing driver .

The Wait Interface sends requests to the multipathing driver calling upon it to return records of the next respective event to occur after the requests are received. A request typically originates from a software construct e.g. an application program . A timeout is specified. If an event occurs within the timeout period the queue manager records the event and returns a copy of the event record to the Wait Interface of the API which then returns the copy to the software construct that requested the record. Often application programs or other software constructs access the Wait Interface in a loop so that they can obtain records of multiple events as they occur.

The Select Interface operates more flexibly. The Select Interface is arranged to receive a query from a software construct. The query specifies one or more criteria which relate to the fields of the event records. The query is transferred to the queue manager which invokes the Query Construct to run the query on the records of the event queue . Queries may be further limited based on event masks or other information stored in the client table . Copies of any records that satisfy the query criteria are then returned to the Select Interface which returns the records to the software construct that requested the records.

As with prior implementations a system log may be provided for long term storage of event records. Unlike the event queue which is typically volatile and has a limited size the system log is non volatile and can grow indefinitely. Therefore the system log can include a very long history of events pertaining to the computing environment .

The different interfaces and of the API generally communicate with the multipathing driver using IOCTL I O Control commands or variants thereof. The software constructs such as the application programs the API and the multipathing driver may be written using any of a number of suitable programming languages and or programming or scripting tools and also may be compiled as executable machine language code or intermediate code that is executed on a framework or virtual machine.

The software constructs of the multipathing driver e.g. the queue manager and event detection code are preferably implemented in two sections a platform independent section and a platform dependent section. The platform independent section employs a collection of software primitives i.e. code that is not specific to any operating system but that can be readily mapped to operating system code of any operating system. The platform dependent section maps each of the primitives to operating system specific code. The use of primitives simplifies the development and deployment of the multipathing driver across multiple operating system platforms.

The software of the multipathing driver generally includes both a control path and a data path . Features relating to event storage maintenance and analysis are parts of the control path of the multipathing driver . Features relating to actual data storage to the storage array and data retrieval from the storage array are parts of the data path . For example the data path conveys I O requests from the operating system to the storage array by processing I O requests and sending the processed requests to the storage array . Similarly the data path receives I O responses from the storage array by processing I O responses and providing processed I O responses to the operating system . The I O responses can include payload i.e. data read from the storage array and or acknowledgements that data has been successfully written to or read from the storage array .

The arrangement shown in allows records of events originating from the multipathing driver to be stored along with events originating from various software constructs e.g. . Event records are stored in chronological order and can be readily consumed in chronological order by the software constructs or any other consumer with access to the driver . Patterns among the event records can be examined within the driver and messages can be added to the event queue to summarize activities.

At step the queue manager receives second events . The second events originate from software constructs e.g. from outside the kernel and include messages to be pushed onto the queue .

At step the queue manager stores records of the first events and the second events received at steps and . The records are stored chronologically in the order the queue manager receives them.

Step includes multiple sub steps . These sub steps are typically conducted by the Append Construct . At sub step the event ID is calculated i.e. by the software counter within the Append Construct . The Append Construct also obtains a timestamp sub step . The Append Construct then stores the event ID and timestamp as well as the event type and any included message in the event record and appends the event record to the event queue sub step .

At step the Prune Construct determines the maximum available size of the event queue e.g. by requesting the information from the Pool Construct .

At step the Prune Construct accesses a policy for pruning events from the event queue . The policy is generally stored within the Prune Construct and includes a set of rules for assigning different priorities to different event records based on factors such as age of the record and diagnostic or prognostic significance of the record.

At step event records are pruned from the event queue according to the policy as the event queue reaches the maximum allowable size as determined at step . In some examples the Prune Construct does not wait for the event queue to become full but rather prunes event records as part of maintenance activity to keep the size of the event queue manageable and to ensure that event records that are maintained are relevant to ongoing activities.

At step a software construct running outside the kernel such as an application program issues an instruction to wait for an event from the multipathing driver and receive the next event to occur. At step the Wait Interface receives the instruction from the software construct. The instruction is accompanied by a timeout which defines an interval of time beyond which the software construct will cease to wait for an event.

At step the Wait Interface converts the instruction from the software construct into lower level code e.g. IOCTL instructions and conveys the lower level code including the instruction and timeout to the multipathing driver . If the multipathing driver does not record an event within the timeout interval tested at step processing for the instruction is terminated and no event is returned. If another event is requested step control returns to step where another instruction to obtain another event record may be issued. If the multipathing driver does record an event during the timeout interval a record of the event is returned from the multipathing driver to the Wait Interface step and then returned to the software construct that issued the instruction step . The multipathing driver records the event on the event queue in the usual fashion. If another event record is desired step control returns to step where another instruction to obtain an event is issued. Otherwise the process may complete at step

The multipathing driver preferably supports access from multiple application programs multiple instances of each application program and multiple users. Many application program instances can therefore be waiting for an event from the multipathing driver at the same time. In this circumstance the multipathing driver responds to each application instance returning the same event record to each application instance that issued an instruction to return the next event record if the event occurs within the respective session s timeout.

At step the Select Interface translates the instruction into IOCTL commands and submits the instruction to the multipathing driver . The multipathing driver invokes the Query Construct . At step the Query Construct may access the client table to obtain additional query criteria from the client table which are particular to the client that issued the query. The additional query criteria may include for example filters for certain event IDs certain intervals of time as designated by timestamps or certain event types . These filters may be applied for clients even without the clients explicitly specifying the filters to improve the relevance of event records returned in response to the clients queries. In a particular example the client table stores the event ID of the last record consumed by a client. When a query is later received by that client results are filtered to include only those event records having event IDs greater than the event ID of the last record consumed. In this manner the client is not required to store the last record consumed and only receives event records relevant to ongoing processes.

The query as modified by the client table is run at step a set of matching records is identified at step and the set of matching records is returned to the Select Interface at step . The matching records are then returned to the software construct that issued the instruction at step .

The improvements described herein reduce reliance upon the system log for processing multipathing events. For legacy purposes a system log may continue to be provided however it no longer serves any unique purpose for multipathing other than to permanently store event records which cannot be permanently retained by the event queue . With the role of the system log diminished the criticality of maintaining log daemons for different operating systems is similarly diminished. Some platforms such as embedded operating systems for virtual machines eliminate these daemons altogether.

In addition with timestamps applied to events at the level of the multipathing driver the variable latency involved in applying timestamps at the system log is avoided. Timestamps applied at the driver level are nearly instantaneous. Therefore timestamping errors are substantially reduced.

Further the ability of the queue manager to gather events from different sources e.g. and and to store the events in the chronological order received creates a clear record in the event queue of sequences of events which can be consumed from the event queue by application programs or other software constructs. Accurate information about events can be used to compute accurate diagnoses of problems in the computing environment . They can also be used to notify system administrators of potential faults before they become critical thus preventing failures and reducing system down time.

Further still the improvement or portions thereof may be embodied as a non transient computer readable storage medium such as a magnetic disk magnetic tape compact disk DVD optical disk flash memory Application Specific Integrated Circuit ASIC Field Programmable Gate Array FPGA and the like shown by way of example as medium in . Multiple computer readable media may be used. The medium or media may be encoded with instructions which when executed on one or more computers or other processors perform methods that implement the various processes described herein. Such medium or media may be considered an article of manufacture or a machine and may be transportable from one machine to another.

As used throughout this document the words comprising including and having are intended to set forth certain items steps elements or aspects of something in an open ended fashion. Although certain embodiments are disclosed herein it is understood that these are provided by way of example only and the invention is not limited to these particular embodiments.

Having described one embodiment numerous alternative embodiments or variations can be made. For example it is shown and described that software constructs that access the multipathing driver such as application programs are installed within the host . This is merely an example however. The software constructs that access the multipathing driver can be both on the host and off the host e.g. on one or more other computing devices connected to the host via a network .

Also although the software constructs described herein have been disclosed for the purpose of managing events in multipathing drivers the same constructs can be used for managing events relating to other aspects of a computing system.

Those skilled in the art will therefore understand that various changes in form and detail may be made to the embodiments disclosed herein without departing from the scope of the invention.

