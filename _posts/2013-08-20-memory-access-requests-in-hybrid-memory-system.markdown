---

title: Memory access requests in hybrid memory system
abstract: Incoming memory access requests are routed in a set of incoming queues, the incoming memory access requests comprise a range of host logical block addresses (LBAs) that correspond to a memory space of a primary memory. The host LBA range is directly mapped to clusters of secondary memory, the secondary memory corresponding to a memory space of a secondary memory. Each incoming memory access request queued in the set of incoming queues is transformed into one or more outgoing memory access requests that include a range of secondary memory clusters or one or more clusters of secondary memory clusters. The outgoing memory access requests are routed in a set of outgoing queues. The secondary memory is accessed using the outgoing memory access requests.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09367247&OS=09367247&RS=09367247
owner: SEAGATE TECHNOLOGY LLC
number: 09367247
owner_city: Cupertino
owner_country: US
publication_date: 20130820
---
According to some embodiments a memory device includes a hybrid controller configured to manage data transfers between a host processor and a secondary memory. The secondary memory is configured to serve as a cache for a primary memory that includes a memory space corresponding to host logical block addresses LBAs . The hybrid controller is arranged to receive incoming memory access requests from the host processor the memory access requests including a range of host LBAs route the incoming memory access requests to a set of incoming queues directly map the range of host LBAs into clusters of secondary memory transform each incoming memory access requests into one or more outgoing memory access requests each outgoing memory access request including a range or cluster of secondary memory route the outgoing memory access requests from the incoming queues into a set of outgoing queues and access the secondary memory using the outgoing memory access requests.

Some embodiments involve a method of operating a hybrid memory system that includes a primary memory and a secondary memory. Incoming memory access requests are routed in a set of incoming queues the incoming memory access requests comprise a range of host logical block addresses LBAs that correspond to a memory space of the primary memory. The host LBA range is directly mapped to clusters of secondary memory the secondary memory clusters corresponding to a memory space of the secondary memory. Each incoming memory access request queued in the set of incoming queues is transformed into one or more outgoing memory access requests. The outgoing memory access requests include a range of secondary memory or one or more clusters of secondary memory. The outgoing memory access requests are routed in a set of outgoing queues. The secondary memory is accessed using the outgoing memory access requests.

Some embodiments involve a controller for a hybrid memory system that includes a hybrid controller configured to manage data transfers between a host processor and a flash memory the flash memory configured to serve as a cache for a magnetic disk. The hybrid controller includes multiple layers including a flash content and transfer management FCTM layer. The FCTM layer is configured to receive the incoming memory access requests from a higher layer of the hybrid controller route the incoming data access requests in a set of incoming queues transform each of the memory access requests from the set of incoming queues into a plurality of outgoing memory access requests route the plurality of outgoing memory access requests in a set of outgoing queues send the outgoing memory access requests to a lower layer of the hybrid controller.

These and other features and aspects of the various embodiments disclosed herein can be understood in view of the following detailed discussion and the accompanying drawings.

Some memory devices use at least two types of memory in a hybrid or tiered memory system where at least one type of memory is used as a primary memory and at least one other type of memory is used as a secondary memory that operates as a cache. The primary memory may have greater storage capacity but slower access times than the secondary memory for example. In this arrangement the secondary memory can serve as a read cache and or a write cache for the primary memory. One example of such a tiered memory device is a hybrid drive in which the primary memory may comprise nonvolatile memory such as magnetic disk magnetic tape and or optical disk and the secondary memory may comprise solid state flash memory and or the secondary memory may be a nonvolatile or volatile memory with or without battery backup. Note that the terms primary memory and secondary memory are used herein for identification of components used in a hybrid memory system and to denote differences in memory e.g. usage capacity performance memory class or type etc. and not necessarily order or preference. Furthermore although examples provided herein refer to the primary memory as magnetic disk and to secondary memory as flash memory the disclosed approaches are applicable to any types of primary and secondary memory.

Embodiments described herein relate to systems and methods for transfers to and from the primary memory and the secondary memory. The transfers are used to manage memory access requests. The memory access requests may involve reading the secondary memory writing to the secondary memory and so forth. In various embodiments management and implementation of the memory access requests is accomplished by using a set of incoming queues and a set of outgoing queues.

The host sends memory access requests to the hybrid drive to read or write data. The memory access requests may specify a host LBA range used for the operation of the memory access request. For example a memory access request from the host may request that a host LBA range be written to the hybrid drive and or a memory access request may request that a host LBA range be read from the hybrid drive . The memory access requests received from the host are managed by the hybrid controller to cause data to be written to and or read from the hybrid drive with optimal efficiency. The second cache in this example may optionally be a type of read cache referred to as read only in that only data marked for read operations by the host are placed in the second cache . In such a configuration data marked for writing to the main memory are sent to the main storage either directly or via the first cache . According to some embodiments the hybrid memory device also denoted hybrid drive may be implemented using a controller configured as a hierarchy of abstraction layers. Pairs of the abstraction layers are communicatively coupled through application programming interfaces APIs . The organization of the hybrid controller into abstraction layers to some extent allows each layer to work relatively independently and or can reduce potential conflicts that arise from processing multiple threads of execution. For purposes of discussion some examples provided below are based on the use of a magnetic disk as the main memory dynamic random access memory as the first or primary cache and solid state flash memory as the second or secondary cache. It will be apparent to those skilled in the art that the various memory components are not restricted to these types of memory and may be implemented using a wide variety of memory types.

In some configurations the cache may be configured as a secondary cache and may be faster and smaller than the main storage . The cache is a primary cache and may be faster and smaller than the secondary cache . For example current read write requests from the host may be processed first via the primary cache e.g. identified by the data s logical block address . This enables host commands to complete quickly should the requested data be stored in the primary cache . For host read requests if there is a miss in the primary cache i.e. the requested data is not present in the primary cache the requested data may be searched for in the secondary cache . If not found in either requested data may be accessed via the main storage .

Some of the data stored in the primary cache may either be copied or moved to the secondary cache as new requests come in. The copying movement from primary cache to secondary cache may also occur in response to other events e.g. a background scan. Both copying and moving involve placing a copy of data associated with an LBA range in the secondary cache and moving may further involve freeing up some the LBA range in the primary cache for other uses e.g. storing newly cached data.

The host processor communicates with the hybrid memory device also referred to herein as hybrid drive through a host interface . As previously discussed the main memory includes a memory space that corresponds to a number of memory sectors each sector addressable using a unique a logical block address LBA . The sectors of the main memory are directly accessible by the host using the LBAs and thus the corresponding LBAs of the main memory are referred to herein as host LBAs.

The host sends memory access requests to the hybrid memory device for example the host may request that data be written to and or read from the hybrid memory device. The host interface is configured to transfer memory access requests from the host to other components of the hybrid memory device and to transfer data between the host and the hybrid memory device.

The hybrid controller illustrated in includes number of layers wherein each layer communicates to its nearest neighboring layer s e.g. through a set of requests. For example each layer may only communicate to its nearest neighboring layer s without communicating to other layers. As an example the layer may only communicate directly to layer and the host interface without communicating directly with the layer or to the flash . As an operation such as a memory access request from the host is being carried out each layer is configured to pass control to the next lower layer as the operation is implemented.

The example illustrated in includes three layers which are described in terms applicable to the use of flash memory as a cache. It will be appreciated that these terms are not restrictive and if other types of memory were used as the secondary memory if desired different terminology could be used to reflect the type of secondary memory. Nevertheless the basic functions of the layers can be similar regardless of the type of memory used for primary and or secondary memory and or the terminology used to describe the layers.

The layers illustrated in include the flash cache interface FCI layer the flash cache control and transfer management FCTM layer and the programmable state machine PSM layer . Requests and or data may be passed between the layers as indicated by arrows from a higher layer to the next lower layer starting with the FCI layer and proceeding to the PSM layer which interacts directly with the flash memory . The layered architecture of the hybrid controller described herein allows for handling host memory access requests which can be serviced from either the magnetic memory or one of the caches The layered structure used in conjunction with the flash cache can be configured to achieve specified rates and response times for servicing memory access requests.

The FCI layer decides whether a host read request should be serviced from the primary magnetic memory or from one of the caches . The FCI layer implements processes to determine which data should be promoted to the flash secondary cache and or the primary cache based on various criteria to achieve optimal workload for the hybrid memory device. The flash content and transfer management FCTM layer maintains a mapping e.g. a fully associative mapping as discussed below of the host LBAs to a memory space corresponding to the flash memory space arranged in clusters. The FCTM layer interacts with programmable state machine PSM layer and performs tasks such as optimal scheduling of promotion requests among dies of the flash referred to as die scheduling wear leveling garbage collection and so forth. . The PSM layer programs hardware controllers to generate the required signals to read from and write to the flash for example.

In some cases one or more of the layers of the hybrid controller may be implemented by circuitry and or by one or more processors e.g. such as reduced instruction set computer RISC processors available from ARM. In some cases each layer may be implemented by a separate processor. The processes discussed herein are implementable in hardware interconnected electronic components that carry out logic operations and or by a processor implementing software instructions e.g. stored in a computer readable medium and or by any combination of hardware and software.

As described previously the HDD host LBA space and flash physical address space are partitioned into units of clusters that may be sized to contain a whole number of sectors of data. Protection Information PI and error correction data may be stored in the cluster. The flash geometry determines the cluster size. In flash geometry according to some embodiments a cluster is defined to contain one or more map units MU . A MU can be defined to be the maximum amount of data that can be transferred to or from the flash in a single flash operation. For example the MU for a dual plane flash may be two pages and for quad plane may be four pages. illustrates a way to partition the flash into clusters for a four die dual plane system. Each cluster spans two planes and two MUs. There are two garbage collection units GCUs per die. Clusters and GCUs are intentionally defined not to span die in order to be able to handle full die failures.

Embodiments described herein involve processes implemented by the FCTM layer to manage memory access requests received from the FCI layer translated through the FCTM layer and sent to the PSM layer. The memory access requests may involve reading the flash memory writing to the flash memory and so forth. In various embodiments management and implementation of the memory access requests is accomplished in the FCTM layer using a set of incoming queues and a set of outgoing queues.

The overall structure of the incoming queues and the outgoing queues is illustrated in . The incoming queues include an incoming free queue a wait queue and an execute queue . The incoming free queue includes nodes which are used to control the flow of memory access requests into the execute queue . Generally the FCTM scheduler routes incoming memory access requests from the FCI layer into the wait queue only if a node is available in the incoming free queue . The number of nodes in the incoming free queue represent the capacity of the FCTM layer at any particular time to process incoming memory access requests.

If a node is available in the incoming free queue that node becomes occupied by an incoming memory access request when the memory access request is routed into the wait queue . When a node is occupied by a memory access request information about the memory access request is stored in the node. For example the node may store information about the type of memory access request the host LBAs involved in the memory access request information about the progress of the memory access request such as how much data has been transferred in conjunction with the memory access request how much work to complete the memory access request is pending and so forth. If a node is not available in the incoming free queue then the FCTM layer does not have the capacity to process the incoming memory access request and an error message is generated.

In some cases when a particular memory access request in the execute queue is transformed into a number of PSM interface requests. Each of the PSM interface requests represents outstanding work to the PSM layer. As nodes become available in the outgoing free queue to execute a memory access request in the execute queue those available outgoing nodes become occupied by the PSM interface requests associated with the memory access request which is being executed. The PSM interface requests associated with the memory access request being executed are transferred to an outgoing ready queue . The memory access request being executed may remain in the ready queue occupying a node from the incoming free queue until execution of the memory access request by the FCTM layer is complete. Execution of a memory access request in the FCTM layer may be deemed to be complete when the responsibility for processing the memory access request is transferred from the FCTM layer to the PSM layer. This occurs after all the PSM interface requests associated with a memory access request are issued to the PSM layer. For example responsibility may be transferred when the last PSM interface request associated with a memory access request is successfully transferred to the PSM layer or when the last PSM interface request associated with the memory access request has been successfully completed by the PSM layer and acknowledgement of the successful completion of the PSM interface request has been received by the FCTM layer and the PSM request is places in the completed queue

When execution of a memory access request is complete the node from the incoming free queue that was previously occupied by the incoming memory access request in the execute queue is returned to the incoming free queue . The previously occupied node becomes available again for being occupied by subsequent memory access requests. Each of the nodes in the PSM execute queue associated with the memory access request being executed are returned to the outgoing free queue as the PSM interface requests occupying these nodes are completed. The previously occupied PSM nodes become available again to be occupied by subsequent PSM interface requests. In some cases an error occurs when one or more PSM interface requests are transferred to the PSM layer. When an error occurs in the processing of PSM interface requests associated with a memory access request the node used to process the incoming memory access request may be returned to the incoming free queue and the PSM nodes used to process the outgoing PSM interface requests may be returned to the outgoing free queue. In other words the processing of the incoming memory access request is cancelled and not completed when an error occurs.

In some implementations incoming memory access requests from the FCI layer to the FCTM layer is restricted meaning that during a time that the FCTM layer is processing a memory access request then the FCI layer is barred from issuing another memory access request to the FCTM layer. Implementations that restrict additional incoming memory access requests from the FCI layer protects the FCTM layer from excessive combinations of possible events affecting the FCTM layer and enhances the thread safety of the layer. In some implementations the code e.g. all of the code that manages the queues is executed on a single thread and none of the data structures of the FCTM layer e.g. the queues can be used are manipulated by external entities e.g. other layers of the hybrid controller.

The FCTM layer can process a number of types of memory access requests received from the FCI layer. illustrates the process for three types of memory access requests read requests promotion requests and invalidate requests that can come from the FCI layer to the FCTM layer. As explained in more detail herein read requests are requests from the FCI layer to read host LBAs from the flash promotion requests are requests from the FCI layer to promote write host LBAs into the flash and invalidate requests are requests from the FCI layer to mark certain host LBAs in the flash as invalid not containing valid data .

According to various implementations user reads have a higher priority than any of the other types of requests and system area requests have the lowest priority. According to some aspects user reads get the highest priority since the host is waiting for the request to complete. According to some priority schemes requests that require the least resources and or are faster to execute may be selected for execution before requests that require more resources and or are slower to execute. For example invalidate requests may be selected for execution before read or promotion requests because invalidate requests are the faster to execute. Some priority schemes use a combination of factors when determining the priority level of a request. For example in a system in which shorter requests are generally executed first GC erases may still be implemented before GC reads and or writes even though the erase requests take longer to complete. Choosing GC erases as having a higher priority may be done to free up additional resources. According to various aspects system area requests do not have the lowest priority to reduce the likelihood that resources are depleted during busy times. In some cases the garbage collection requests and the system area requests are completed when there are no pending user requests.

The flow diagram of conceptually illustrates an overview of one priority scheme that may be implemented by the FCTM scheduler for routing memory access requests from the ready queues to the execute queue. As previously discussed for each incoming memory access request the FCTM scheduler routes the memory access request to the wait queue if there is a node available in the incoming free queue . If there are no nodes available in the incoming free queue the FCTM scheduler generates an error response which is sent to the FCI layer.

The FCTM overlap checker determines if the address range host LBA range of the memory access request that is routed to the receive queue overlaps with the address range of other memory access requests. If an overlap is not detected it is determined whether resources are available to execute the request. If an overlap is detected the memory access request is kept in the wait queue. Data access requests routed to the wait queue due to an overlap wait there until the overlap is resolved. If the overlap is resolved it is determined whether there are resources available to complete the request.

Data access requests wait in the wait queue until at least one PSM node in the outgoing free queue is available for execution of the memory access request. Once an PSM node is available the priority scheme for routing memory access requests to the execute queue is implemented. If there is an invalidate request in the ready queue the invalidate request is routed to the execute queue and the process returns to the implementation of the priority scheme at step . According to the priority scheme if multiple invalidate requests are present in the invalidate ready queue these invalidate requests would be processed until the invalidate ready queue is empty. If the invalidate ready queue is empty and there is a read request in the read ready queue the read request is routed to the execute queue and the process returns to the implementation of the priority scheme at step . If there are no invalidate requests or read requests in their respective ready queues and there is a promotion request in the promotion ready queue the promotion request is routed to the execute queue and the process returns to the implementation of the priority scheme at step .

In some scenarios a priority scheme may be pre emptive involving pre empting requests in the execute queue with requests in the ready queue. In some implementations such a pre emption takes place if the request in the ready queue would take less time resources for execution than the request in the execute queue. In one example invalidate requests in the ready queue preempt promotion requests in the execute queue. Execution of the invalidate requests may cause a delay in the completion of the execution of the promotion request however this delay may be minimal because the invalidate requests can be executed very quickly if there is no I O to the flash.

One possible implementation of a pre emptive priority scheme is conceptually illustrated by the flow diagram of . Such a priority scheme may be implemented alone or as a second level of priority in conjunction with another priority scheme e.g. the priority scheme discussed in connection with . After the work associated with a PSM interface request occupying a PSM node is completed the PSM node is returned to the outgoing free queue and becomes available again. A priority scheme is implemented that determines the memory access request to which this available PSM node is next assigned. According to the priority scheme of if there is an invalidate request in the execute queue the PSM node is assigned to the invalidate request. If there is a read request in the execute queue the PSM node is assigned to the read request. If there is an invalidate request in the ready queue the invalidate request is moved to the execute queue and the PSM node is assigned to the invalidate request. If there is a read request in the wait queue the read request is moved to the execute queue and the PSM node is assigned to the read request. If there is a promotion request in the execute queue the PSM node is assigned to the promotion request. If there is a promotion request in the wait queue the promotion request is moved to the execute queue and the PSM node is assigned to the promotion request. The priority scheme illustrated in provides for an optimal ordering in the execution of requests to achieve minimal host request latency.

Note that the priority scheme illustrated in may mean that a request in the execute queue may be pre empted by a request for which execution has not yet started. The preempting request may be in the ready queue and if so the pre empting request would be moved to the execute queue and the available PSM node would be assigned to it. Thus the pre empting request may delay the execution of a request in the execute queue that is currently being executed.

In some scenarios the flash memory may be full when a promotion request is executed. If so the FCTM may cause some data stored in flash to be evicted. To implement evictions as illustrated in the FCTM layer maintains a most valuable least valuable MVLV list of clusters which ranks the value of the clusters according to some criteria which may be based on one or a number of factors such as which of the clusters was most least recently used and or which of the clusters is most frequently least frequently used for example. One end of the MVLV list is referred to herein as the head which is the position of the currently most valuable cluster and the opposite end of the MVLV is referred to as the tail which is the position of the currently least valuable cluster. If the flash memory is full and a promotion request is executed the cluster at the tail of the MVLV list is selected for eviction. In some implementations when a cluster is read or written that cluster becomes the most valuable cluster because it was most recently used and is moved to the head of the MVLV list .

The FCTM layer maintains list e.g. linked list of free clusters in the flash denoted the free list and or maintains a list e.g. linked list of in use flash clusters denoted the use list . The free list includes flash clusters that are available for use. The free list may include GCUs that are not yet erased and are ready for new data. A defect list may include clusters that are defective. A ready list comprises erased clusters that have not been programmed. A GC ready list includes clusters that are ready for garbage collection. The GC ready list may be used to differentiate between user programs and garbage collection programs due to user data having a higher priority than garbage collection programs. The FCTM may also include a reserved chain that is used to track clusters that are not to be used for user data. The reserved state may be used to prevent use of reserved areas of the flash such as system areas. In some cases one or more flash clusters may be in a detached state during which the flash clusters are not in either the free state the defect state the ready state the GC ready state or the reserved state. An flash cluster may be in a detached state for example during the time that the clusters are involved in execution of a request e.g. during the time that data is written to the clusters.

If the clusters in the ready state list or the clusters in the garbage collection ready state list are selected for programming the clusters are moved into the detached state list . A program is attempted on the clusters in the detached state list . If the program fails or and or a garbage collection program fails the clusters are moved into the defect state list . If the program passes and or a garbage collection program passes the clusters are moved to an in use state list .

A read is attempted on the clusters in the in use state list . If the read passes the clusters remain in the in use state list . If the read fails the clusters are moved into the defect state list . The in use clusters may also be invalidated in a defective GCU and are moved into the defect state list . According to various embodiments clusters in the free state list may also be moved to the reserved state list for clusters that are not meant for normal use. In some cases the clusters in the reserved state list can be used to destroke the flash part. Destroking the flash can be used to reduce the user available capacity of the flash memory to provide more space for system functions as the device ages for example.

The flow diagrams of conceptually illustrate some steps involved in the execution of invalidate read and promotion requests respectively performed by the FCTM layer. As previously discussed each incoming memory access request includes a command portion and a host LBA range. The command portion identifies the type of request and the host LBA range indicates the host LBAs involved in the request. In addition a promotion request is associated with the data to be written to the LBA range specified in the promotion request.

An invalidate request issued by the FCI layer identifies a cluster aligned range of host LBAs to be invalidated. A cluster aligned LBA range means that the start of the LBA range and the end of the LBA range are not arbitrary but are multiples of n which is the number of sectors per cluster. The invalidate request is transferred to the execute queue. The FCTM layer maps the cluster aligned LBA range of the incoming memory access request to the flash clusters and determines the flash clusters involved in the invalidate request. The flash clusters are invalidated marked as containing invalid data in the FCTM metadata.

A read request involves reading data corresponding to an arbitrary range of LBAs from the flash memory. The host LBA range of a read request from the FCI is not necessarily cluster aligned. There may be an upper bound on the number of LBAs that can be included in the read request. In the example illustrated in the FCTM layer initially performs a check to determine if the range of host LBAs specified by the read request is fully present in the flash. If the range of host LBAs is not fully present the read request is rejected and an error response to the FCI layer is generated . The error response notifies the FCI layer to obtain the data requested from the primary memory e.g. the magnetic disk. If the range of LBAs specified by the read request is fully present in the flash memory then the read request is moved to the execute queue. The FCTM maps the host LBA range to the flash clusters. A list of flash clusters in the read request is created . The list of flash clusters that include the flash clusters of the read request may be made most valuable e.g. moved to the head of the MVLV list.

A promotion request involves writing a cluster aligned range of host LBAs to the flash memory. There may be an upper bound imposed on the number of LBAs that can be included in one promotion request. The promotion request is moved to the execute queue . A list of the flash clusters corresponding to the cluster aligned host LBA range specified in the promotion request that are already present in the flash is created . The clusters already present in the flash are denoted overlapped clusters. A bitmap is created to skip over the flash clusters that are already present in the flash. The process of determining the clusters already present in the flash and creating the bitmap mask facilitates conservative use of the flash memory space by maintaining a single copy of any host LBA in the flash. The overlapped flash clusters and the non overlapped flash clusters are made most valuable by moving these clusters to the head of the MVLV list. The FCTM determines if there are a sufficient number of clusters available to store the clusters to be written into the flash. The clusters to be written to the flash are the clusters implicated by the promotion request that are not already present in the flash. If there are a sufficient number of clusters available then clusters for storing the data are allocated and the flash clusters to be stored are transferred to the flash. The metadata of the FCTM layer i.e. the use list is updated to indicate that these clusters are in use. If a sufficient number of clusters is not available then the FCTM layer will perform evictions to free up a sufficient number of clusters.

Eviction overlap may lead to data errors. Eviction overlap can occur when the address range being evicted overlaps with the address range of an outstanding command that is in the ready queue or the execute queue. The FCTM scheduler described in various embodiments discussed herein is arranged to operate so that eviction overlap is avoided. To prevent clusters with outstanding reads in the execute queue from being moved during garbage collection an in use bit may be set per cluster when outstanding reads exist for them. The garbage collector suspends operations on clusters with this bit set and resumes when the bit is cleared.

If the flash memory is not saturated i.e. there is a sufficient free space in the flash for promotion without evictions being performed non overlapping requests from the FCI layer can execute in any order. For an unsaturated flash only overlapped requests are placed in the overlap queue. If the flash is saturated evictions must take place in order to make room for promotion requests to be implemented.

As illustrated in certain steps are carried out during the ready queue to execute transition for read promotion and invalidate requests. These steps may be implemented as atomic operations that are completed without interruption. Performing these steps atomically without interruption ensures that no other requests remove these flash clusters from the flash address space before the request has executed. For example if an invalidate request is received while a read request is executing the invalidate request will move to the overlap queue so that the invalidate request does not interfere with the execution of the read request. If the invalidate request were serviced during execution of the read request there is a possibility that the invalidate request would invalidate some LBAs involved in the read request.

For read requests during the ready queue to execute queue transition the FCTM scheduler verifies if the LBA range in specified in the request is fully present in the flash. If the range is not fully present the read request is not executed and an error response is generated. The flash clusters that correspond to the host LBA range of the read request whether or not fully present are made most valuable by moving these clusters to the head of the MVLV list. If the flash clusters that correspond to the host LBA range of the read request are fully present in the flash the FCTM scheduler creates a list the flash clusters and implements the read request as previously discussed in connection with .

For promotion requests during the ready queue to execute queue transition the FCTM scheduler checks to determine which flash clusters are already present in the flash and creates a bitmap of the overlapped flash clusters already present in the flash. The bitmap is used to skip writing the overlapped clusters to the flash. If the flash is saturated the required number of clusters may be evicted to make room for the new clusters to be written as part of the promotion request.

For invalidate requests implemented during the ready queue to execute queue transition the FCTM scheduler migrates the flash clusters being invalidated into the free list of flash clusters.

The mapping of the host LBA clusters to the flash clusters by the FCTM layer is fully associative meaning that any host LBA cluster can be mapped to any of the flash clusters so long as there is room in the cache. diagrammatically depicts mapping of the host LBA space to the flash address space . In the FCTM layer the host LBA space is partitioned into clusters of host LBAs and the flash address space is partitioned into clusters. In the host LBA space each cluster of host LBAs is uniquely identified by a number between 0 and N 1 and each cluster includes n contiguous sectors. In the flash address space each flash cluster is uniquely identified by a number between 0 and K 1 K is typically less than N and each cluster includes n sectors. The number of sectors per cluster n may be fixed and can depend on the size of a host sector the geometry of the flash memory the error correction code ECC used to store data in the flash memory and or other factors. In the example illustrated in n 32 however in other implementations n may be greater than or less than 32. Furthermore in general n need not be a power of two.

The mapping from host LBA space to flash address space is accomplished by a hash function . As previously discussed the hash function can support fully associative caching with regard to clusters. In other words the hash function allows any host cluster to be mapped to any flash cluster as indicated by arrows . However the mapping may be constrained such that any host LBA can exist in only one flash cluster at any given time. The offset within a cluster where an LBA is located within a cluster is fixed and is can be determined by the host LBA modulo the number of host LBAs per cluster i.e. the remainder resulting from dividing the host LBA by n. Allowing a host LBA cluster to be mapped into any flash cluster and ensuring that promotes and invalidates implemented by the FCTM layer are aligned to cluster boundaries avoids cache fragmentation.

The hash function is used to convert the tag upper L bits of the host LBA into a hash table index in the hash table . The entry in the hash table indicated by the hash table index the tag converted by the hash function points to one or more clusters in the flash address space. For example for a host LBA of L M bits the lower M bits can be used as a sector offset to identify the sector within an flash cluster. The remaining L bits are used for the tag. The hash function operates on the tag to generate the index into the hash table . For example the hash function may discard the upper L H bits of the tag and use the lower H bits as the hash table index. Discarding a portion of the tag means that in some cases a number of different host LBAs will map to the same entry in the hash table and a collision will occur. An entry in the hash table is associated with more than one cluster identification ID only if a collision occurs. In this scenario 2host LBAs mapped to a cluster will all have the same tag. If the hash function discards the upper bits leaving only H lower bits for the hash table index the theoretical maximum number of possible collisions i.e. the number of clusters that map into the same flash address space is 2. The L H bits of the tag identify the cluster ID. The collisions are resolved using a linked list . The linked list contains the cluster IDs that are hashed to the same entry in the hash table i.e. have the same hash index . To access a particular cluster the linked list is scanned for an entry with the correct cluster ID. For example when the FCI layer requests a look up involving a particular host LBA cluster the FCTM layer applies the hash function and if there is a collision two clusters that map to the same space then the FCTM layer traverses through the linked list to locate the requested cluster.

The above description assumes that the number of host sectors per cluster is a power of two. However non power of two sector sizes may also be used. A representative set of host sector sizes that are supportable by the fully associative cache structure described herein include but is not limited to the following sector sizes 512 520 524 528 4096 4192 and 4224 bytes. For example based on sector to cluster mapping calculations there may be 30 5XX byte sectors per cluster assuming a cluster is 16 KB of the flash such as an 8 KB flash page size with dual plane support .

Non powers of two can be handled by modifying the mapping described above as follows The tag is determined as tag host LBA sectors per cluster where indicates an integer division via truncation and the host sector offset within the cluster is determined by host LBA modulo the sectors per cluster i.e. the remainder after dividing the host LBA by the sectors per cluster.

The division and modulo operations can be implemented by executing a multiply instruction e.g. a 64 bit multiply instruction on the FCTM processor assuming the FCTM processor supports 64 bit multiple instructions. To facilitate the multiply the value p 0xFFFFFFFF sectors per cluster is pre computed is a constant value. The tag is now determined by tag host LBA p 32 where indicates a 64 bit multiply operation and where 32 means that the result of host LBA p is right shifted 32 times. Using this process there is a possibility that the tag is off by one. To correct for this occurrence the tag is incremented by one if the following condition is satisfied Host LBA tag sectors per cluster sector per cluster. The remainder can be similarly determined.

The hybrid flash management system described herein may not need to expose a fixed capacity. Blocks that are defected are moved into the defect chain. All remaining blocks may be in play at all times. According to various embodiments the length of the free chain remains above a predetermined threshold. The predetermined threshold may be adjusted according to a desired write amplification. The length of the free chain may be accomplished by forcing evictions when the length gets below a second threshold.

Program and erase errors cause blocks to be defected. All clusters within the block are moved to the defect chain and a bitmap is used to remember the location of defects. This bitmap may be periodically saved to the reserved system area in the flash so that it can be restored at the next power on.

It is to be understood that this detailed description is illustrative only and various additions and or modifications may be made to these embodiments especially in matters of structure and arrangements of parts and or processes. Accordingly the scope of the present disclosure should not be limited by the particular embodiments described above but should be defined by the claims set forth below and equivalents thereof.

