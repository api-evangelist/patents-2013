---

title: Restricted instructions in transactional execution
abstract: Restricted instructions are prohibited from execution within a transaction. There are classes of instructions that are restricted regardless of type of transaction: constrained or nonconstrained. There are instructions only restricted in constrained transactions, and there are instructions that are selectively restricted for given transactions based on controls specified on instructions used to initiate the transactions.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09448797&OS=09448797&RS=09448797
owner: INTERNATIONAL BUSINESS MACHINES CORPORATION
number: 09448797
owner_city: Armonk
owner_country: US
publication_date: 20130304
---
This application is a continuation of co pending U.S. Ser. No. 13 524 765 entitled RESTRICTED INSTRUCTIONS IN TRANSACTIONAL EXECUTION filed Jun. 15 2012 which is hereby incorporated herein by reference in its entirety.

One or more aspects relate in general to multiprocessing computing environments and in particular to transactional processing within such computing environments.

An enduring challenge in multiprocessor programming is that of updates to the same storage location by multiple central processing units CPUs . Many instructions that update storage locations including even simple logical operations such as AND do so with multiple accesses to the location. For instance first the storage location is fetched and then the updated result is stored back.

In order for multiple CPUs to safely update the same storage location access to the location is serialized. One instruction the TEST AND SET instruction introduced with the S 360 architecture formerly offered by International Business Machines Corporation provided an interlocked update of a storage location. Interlocked update means that as observed by other CPUs and the input output I O subsystem e.g. channel subsystem the entire storage access of the instruction appears to occur atomically. Later the S 370 architecture offered by International Business Machines Corporation introduced the COMPARE AND SWAP and COMPARE DOUBLE AND SWAP instructions that provide a more sophisticated means of performing interlocked update and allow the implementation of what is commonly known as a lock word or semaphore . Recently added instructions have provided additional interlocked update capabilities including COMPARE AND SWAP AND PURGE and COMPARE AND SWAP AND STORE. However all of these instructions provide interlocking for only a single storage location.

More complex program techniques may require the interlocked update of multiple storage locations such as when adding an element to a doubly linked list. In such an operation both a forward and backward pointer are to appear to be simultaneously updated as observed by other CPUs and the I O subsystem. In order to effect such a multiple location update the program is forced to use a separate single point of serialization such as a lock word. However lock words may provide a much courser level of serialization than is warranted for example the lock words may serialize an entire queue of millions of elements even though only two elements are being updated. The program may structure the data to use finer grained serialization e.g. a hierarchy of lock points but that introduces additional problems such as potential deadlock situations if the hierarchy is violated and recovery issues if the program encounters an error while holding one or more locks or if the lock cannot be acquired.

In addition to the above there are numerous scenarios where a program may execute a sequence of instructions that may or may not result in an exception condition. If no exception condition occurs then the program continues however if an exception is recognized then the program may take corrective action to eliminate the exception condition. Java as one example can exploit such execution in for instance speculative execution partial in lining of a function and or in the re sequencing of pointer null checking.

In classic operating system environments such as z OS and its predecessors offered by International Business Machines Corporation the program establishes a recovery environment to intercept any program exception condition that it may encounter. If the program does not intercept the exception the operating system typically abnormally terminates the program for exceptions that the operating system is not prepared to handle. Establishing and exploiting such an environment is costly and complicated.

Shortcomings of the prior art are overcome and advantages are provided through the provision of a method of performing processing associated with transactional execution in a computing environment. The method includes for instance obtaining by a processor an instruction to be executed as part of a transaction the transaction effectively delaying committing transactional stores to main memory until completion of a selected transaction computing one or more effective controls from one or more controls set by one or more transaction begin instructions determining by the processor whether the instruction is a selectively restricted instruction that is prohibited from execution within the transaction the determining being based on the computed one or more effective controls and performing processing associated with the instruction based on whether the instruction is selectively restricted.

Computer program products and systems relating to one or more embodiments are also described and may be claimed herein. Further services relating to one or more embodiments are also described and may be claimed herein.

Additional features and advantages are realized. Other embodiments and aspects are described in detail herein and are considered a part of the claimed invention.

In accordance with one aspect a transactional execution TX facility is provided. This facility provides transactional processing for instructions and in one or more embodiments offers different execution modes as described below as well as nested levels of transactional processing.

The transactional execution facility introduces a CPU state called the transactional execution TX mode. Following a CPU reset the CPU is not in the TX mode. The CPU enters the TX mode by a TRANSACTION BEGIN instruction. The CPU leaves the TX mode by either a an outermost TRANSACTION END instruction more details on inner and outer to follow or b the transaction being aborted. While in the TX mode storage accesses by the CPU appear to be block concurrent as observed by other CPUs and the I O subsystem. The storage accesses are either a committed to storage when the outermost transaction ends without aborting i.e. e.g. updates made in a cache or buffer local to the CPU are propagated and stored in real memory and visible to other CPUs or b discarded if the transaction is aborted.

Transactions may be nested. That is while the CPU is in the TX mode it may execute another TRANSACTION BEGIN instruction. The instruction that causes the CPU to enter the TX mode is called the outermost TRANSACTION BEGIN similarly the program is said to be in the outermost transaction. Subsequent executions of TRANSACTION BEGIN are called inner instructions and the program is executing an inner transaction. The model provides a minimum nesting depth and a model dependent maximum nesting depth. An EXTRACT TRANSACTION NESTING DEPTH instruction returns the current nesting depth value and in a further embodiment may return a maximum nesting depth value. This technique uses a model called flattened nesting in which an aborting condition at any nesting depth causes all levels of the transaction to be aborted and control is returned to the instruction following the outermost TRANSACTION BEGIN.

During processing of a transaction a transactional access made by one CPU is said to conflict with either a a transactional access or nontransactional access made by another CPU or b a nontransactional access made by the I O subsystem if both accesses are to any location within the same cache line and one or both of the accesses is a store. In other words in order for transactional execution to be productive the CPU is not to be observed making transactional accesses until it commits. This programming model may be highly effective in certain environments for example the updating of two points in a doubly linked list of a million elements. However it may be less effective if there is a lot of contention for the storage locations that are being transactionally accessed.

In one model of transactional execution referred to herein as a nonconstrained transaction when a transaction is aborted the program may either attempt to re drive the transaction in the hopes that the aborting condition is no longer present or the program may fall back to an equivalent non transactional path. In another model of transactional execution referred to herein as a constrained transaction an aborted transaction is automatically re driven by the CPU in the absence of constraint violations the constrained transaction is assured of eventual completion.

When initiating a transaction the program can specify various controls such as a which general registers are restored to their original contents if the transaction is aborted b whether the transaction is allowed to modify the floating point register context including for instance floating point registers and the floating point control register c whether the transaction is allowed to modify access registers ARs and d whether certain program exception conditions are to be blocked from causing an interruption. If a nonconstrained transaction is aborted various diagnostic information may be provided. For instance the outermost TBEGIN instruction that initiates a nonconstrained transaction may designate a program specified transaction diagnostic block TDB . Further the TDB in the CPU s prefix area or designated by the host s state description may also be used if the transaction is aborted due to a program interruption or a condition that causes interpretative execution to end respectively.

Indicated above are various types of registers. These are further explained in detail herein. General registers may be used as accumulators in general arithmetic and logical operations. In one embodiment each register contains 64 bit positions and there are 16 general registers. The general registers are identified by the numbers and are designated by a four bit R field in an instruction. Some instructions provide for addressing multiple general registers by having several R fields. For some instructions the use of a specific general register is implied rather than explicitly designated by an R field of the instruction.

In addition to their use as accumulators in general arithmetic and logical operations 15 of the 16 general registers are also used as base address and index registers in address generation. In these cases the registers are designated by a four bit B field or X field in an instruction. A value of zero in the B or X field specifies that no base or index is to be applied and thus general register is not to be designated as containing a base address or index.

Floating point instructions use a set of floating point registers. The CPU has 16 floating point registers in one embodiment. The floating point registers are identified by the numbers and are designated by a four bit R field in floating point instructions. Each floating point register is 64 bits long and can contain either a short 32 bit or a long 64 bit floating point operand.

A floating point control FPC register is a 32 bit register that contains mask bits flag bits a data exception code and rounding mode bits and is used during processing of floating point operations.

Further in one embodiment the CPU has 16 control registers each having 64 bit positions. The bit positions in the registers are assigned to particular facilities in the system such as Program Event Recording PER discussed below and are used either to specify that an operation can take place or to furnish special information required by the facility. In one embodiment for the transactional facility CR bits and and CR bits are used as described below.

The CPU has for instance 16 access registers numbered . An access register consists of 32 bit positions containing an indirect specification of an address space control element ASCE . An address space control element is a parameter used by the dynamic address translation DAT mechanism to translate references to a corresponding address space. When the CPU is in a mode called the access register mode controlled by bits in the program status word PSW an instruction B field used to specify a logical address for a storage operand reference designates an access register and the address space control element specified by the access register is used by DAT for the reference being made. For some instructions an R field is used instead of a B field. Instructions are provided for loading and storing the contents of the access registers and for moving the contents of one access register to another.

Each of access registers can designate any address space. Access register designates the primary instruction space. When one of access registers is used to designate an address space the CPU determines which address space is designated by translating the contents of the access register. When access register is used to designate an address space the CPU treats the access register as designating the primary instruction space and it does not examine the actual contents of the access register. Therefore the 16 access registers can designate at any one time the primary instruction space and a maximum of 15 other spaces.

In one embodiment there are multiple types of address spaces. An address space is a consecutive sequence of integer numbers virtual addresses together with the specific transformation parameters which allow each number to be associated with a byte location in storage. The sequence starts at zero and proceeds left to right.

In for instance the z Architecture when a virtual address is used by a CPU to access main storage a.k.a. main memory it is first converted by means of dynamic address translation DAT to a real address and then by means of prefixing to an absolute address. DAT may use from one to five levels of tables page segment region third region second and region first as transformation parameters. The designation origin and length of the highest level table for a specific address space is called an address space control element and it is found for use by DAT in a control register or as specified by an access register. Alternatively the address space control element for an address space may be a real space designation which indicates that DAT is to translate the virtual address simply by treating it as a real address and without using any tables.

DAT uses at different times the address space control elements in different control registers or specified by the access registers. The choice is determined by the translation mode specified in the current PSW. Four translation modes are available primary space mode secondary space mode access register mode and home space mode. Different address spaces are addressable depending on the translation mode.

At any instant when the CPU is in the primary space mode or secondary space mode the CPU can translate virtual addresses belonging to two address spaces the primary address space and the second address space. At any instant when the CPU is in the access register mode it can translate virtual addresses of up to 16 address spaces the primary address space and up to 15 AR specified address spaces. At any instant when the CPU is in the home space mode it can translate virtual addresses of the home address space.

The primary address space is identified as such because it consists of primary virtual addresses which are translated by means of the primary address space control element ASCE . Similarly the secondary address space consists of secondary virtual addresses translated by means of the secondary ASCE the AR specified address spaces consist of AR specified virtual addresses translated by means of AR specified ASCEs and the home address space consists of home virtual addresses translated by means of the home ASCE. The primary and secondary ASCEs are in control registers and respectively. AR specified ASCEs are in ASN second table entries that are located through a process called access register translation ART using control registers and . The home ASCE is in control register .

One embodiment of a computing environment to incorporate and use one or more aspects of the transactional facility described herein is described with reference to .

Referring to in one example computing environment is based on the z Architecture offered by International Business Machines IBM Corporation Armonk N.Y. The z Architecture is described in an IBM Publication entitled z Architecture Principles of Operation Publication No. SA22 7932 08 9Edition August 2010 which is hereby incorporated herein by reference in its entirety.

Z ARCHITECTURE IBM and Z OS and Z VM referenced below are registered trademarks of International Business Machines Corporation Armonk N.Y. Other names used herein may be registered trademarks trademarks or product names of International Business Machines Corporation or other companies.

As one example computing environment includes a central processor complex CPC coupled to one or more input output I O devices via one or more control units . Central processor complex includes for instance one or more central processors one or more partitions e.g. logical partitions LP a logical partition hypervisor and an input output subsystem each of which is described below.

Central processors are physical processor resources allocated to the logical partitions. In particular each logical partition has one or more logical processors each of which represents all or a share of a physical processor allocated to the partition. The logical processors of a particular partition may be either dedicated to the partition so that the underlying processor resource is reserved for that partition or shared with another partition so that the underlying processor resource is potentially available to another partition.

A logical partition functions as a separate system and has one or more applications and optionally a resident operating system therein which may differ for each logical partition. In one embodiment the operating system is the z OS operating system the z VM operating system the z Linux operating system or the TPF operating system offered by International Business Machines Corporation Armonk N.Y. Logical partitions are managed by a logical partition hypervisor which is implemented by firmware running on processors . As used herein firmware includes e.g. the microcode and or millicode of the processor. It includes for instance the hardware level instructions and or data structures used in implementation of higher level machine code. In one embodiment it includes for instance proprietary code that is typically delivered as microcode that includes trusted software or microcode specific to the underlying hardware and controls operating system access to the system hardware.

The logical partitions and logical partition hypervisor each comprise one or more programs residing in respective partitions of central storage associated with the central processors. One example of logical partition hypervisor is the Processor Resource System Manager PR SM offered by International Business Machines Corporation Armonk N.Y.

Input output subsystem directs the flow of information between input output devices and main storage a.k.a. main memory . It is coupled to the central processing complex in that it can be a part of the central processing complex or separate therefrom. The I O subsystem relieves the central processors of the task of communicating directly with the input output devices and permits data processing to proceed concurrently with input output processing. To provide communications the I O subsystem employs I O communications adapters. There are various types of communications adapters including for instance channels I O adapters PCI cards Ethernet cards Small Computer Storage Interface SCSI cards etc. In the particular example described herein the I O communications adapters are channels and therefore the I O subsystem is referred to herein as a channel subsystem. However this is only one example. Other types of I O subsystems can be used.

The I O subsystem uses one or more input output paths as communication links in managing the flow of information to or from input output devices . In this particular example these paths are called channel paths since the communication adapters are channels.

The computing environment described above is only one example of a computing environment that can be used. Other environments including but not limited to non partitioned environments other partitioned environments and or emulated environments may be used embodiments are not limited to any one environment.

In accordance with one or more aspects the transactional execution facility is a CPU enhancement that provides the means by which the CPU can execute a sequence of instructions known as a transaction that may access multiple storage locations including the updating of those locations. As observed by other CPUs and the I O subsystem the transaction is either a completed in its entirety as a single atomic operation or b aborted potentially leaving no evidence that it ever executed except for certain conditions described herein . Thus a successfully completed transaction can update numerous storage locations without any special locking that is needed in the classic multiprocessing model.

The transactional execution facility includes for instance one or more controls one or more instructions transactional processing including constrained and nonconstrained execution and abort processing each of which is further described below.

In one embodiment three special purpose controls including a transaction abort Program Status Word PSW a transaction diagnostic block TDB address and a transaction nesting depth five control register bits and six general instructions including TRANSACTION BEGIN constrained and nonconstrained TRANSACTION END EXTRACT TRANSACTION NESTING DEPTH TRANSACTION ABORT and NONTRANSACTIONAL STORE are used to control the transactional execution facility. When the facility is installed it is installed for instance in all CPUs in the configuration. A facility indication bit in one implementation when one indicates that the transactional execution facility is installed.

When the transactional execution facility is installed the configuration provides a nonconstrained transactional execution facility and optionally a constrained transactional execution facility each of which is described below. When facility indications and as examples are both one the constrained transactional execution facility is installed. Both facility indications are stored in memory at specified locations.

As used herein the instruction name TRANSACTION BEGIN refers to the instructions having the mnemonics TBEGIN Transaction Begin for a nonconstrained transaction and TBEGINC Transaction Begin for a constrained transaction . Discussions pertaining to a specific instruction are indicated by the instruction name followed by the mnemonic in parentheses or brackets or simply by the mnemonic.

One embodiment of a format of a TRANSACTION BEGIN TBEGIN instruction is depicted in . As one example a TBEGIN instruction includes an opcode field that includes an opcode specifying a transaction begin nonconstrained operation a base field B a displacement field D and an immediate field I . When the Bfield is nonzero the contents of the general register specified by B are added to D to obtain the first operand address.

When the Bfield is zero no access exceptions are detected for the first operand and for the outermost TBEGIN instruction the TDBA is invalid.

General Register Save Mask GRSM Bits of the Ifield contain the general register save mask GRSM . Each bit of the GRSM represents an even odd pair of general registers where bit represents registers and bit represents registers and and so forth. When a bit in the GRSM of the outermost TBEGIN instruction is zero the corresponding register pair is not saved. When a bit in the GRSM of the outermost TBEGIN instruction is one the corresponding register pair is saved in a model dependent location that is not directly accessible by the program.

If the transaction aborts saved register pairs are restored to their contents when the outermost TBEGIN instruction was executed. The contents of all other unsaved general registers are not restored when a transaction aborts.

Allow AR Modification A The A control bit of the Ifield controls whether the transaction is allowed to modify an access register. The effective allow AR modification control is the logical AND of the A control in the TBEGIN instruction for the current nesting level and for all outer levels.

If the effective A control is zero the transaction will be aborted with abort code 11 restricted instruction if an attempt is made to modify any access register. If the effective A control is one the transaction will not be aborted if an access register is modified absent of any other abort condition .

Allow Floating Point Operation F The F control bit of the Ifield controls whether the transaction is allowed to execute specified floating point instructions. The effective allow floating point operation control is the logical AND of the F control in the TBEGIN instruction for the current nesting level and for all outer levels.

If the effective F control is zero then a the transaction will be aborted with abort code 11 restricted instruction if an attempt is made to execute a floating point instruction and b the data exception code DXC in byte of the floating point control register FPCR will not be set by any data exception program exception condition. If the effective F control is one then a the transaction will not be aborted if an attempt is made to execute a floating point instruction absent any other abort condition and b the DXC in the FPCR may be set by a data exception program exception condition.

Program Interruption Filtering Control PIFC Bits of the Ifield are the program interruption filtering control PIFC . The PIFC controls whether certain classes of program exception conditions e.g. addressing exception data exception operation exception protection exception etc. that occur while the CPU is in the transactional execution mode result in an interruption.

The effective PIFC is the highest value of the PIFC in the TBEGIN instruction for the current nesting level and for all outer levels. When the effective PIFC is zero all program exception conditions result in an interruption. When the effective PIFC is one program exception conditions having a transactional execution class of 1 and 2 result in an interruption. Each program exception condition is assigned at least one transactional execution class depending on the severity of the exception. Severity is based on the likelihood of recovery during a repeated execution of the transactional execution and whether the operating system needs to see the interruption. When the effective PIFC is two program exception conditions having a transactional execution class of 1 result in an interruption. A PIFC of 3 is reserved.

Bits of the Ifield bits of the instruction are reserved and should contain zeros otherwise the program may not operate compatibly in the future.

One embodiment of a format of a Transaction Begin constrained TBEGINC instruction is described with reference to . In one example TBEGINC includes an opcode field that includes an opcode specifying a transaction begin constrained operation a base field B a displacement field D and an immediate field I . The contents of the general register specified by B are added to D to obtain the first operand address. However with the transaction begin constrained instruction the first operand address is not used to access storage. Instead the Bfield of the instruction includes zeros otherwise a specification exception is recognized.

The end of a Transaction Begin instruction is specified by a TRANSACTION END TEND instruction a format of which is depicted in . As one example a TEND instruction includes an opcode field that includes an opcode specifying a transaction end operation.

A number of terms are used with respect to the transactional execution facility and therefore solely for convenience a list of terms is provided below in alphabetical order. In one embodiment these terms have the following definition 

Abort A transaction aborts when it is ended prior to a TRANSACTION END instruction that results in a transaction nesting depth of zero. When a transaction aborts the following occurs in one embodiment 

A transaction may be aborted due to a variety of reasons including attempted execution of a restricted instruction attempted modification of a restricted resource transactional conflict exceeding various CPU resources any interpretive execution interception condition any interruption a TRANSACTION ABORT instruction and other reasons. A transaction abort code provides specific reasons why a transaction may be aborted.

One example of a format of a TRANSACTION ABORT TABORT instruction is described with reference to . As one example a TABORT instruction includes an opcode field that includes an opcode specifying a transaction abort operation a base field B and a displacement field D . When the Bfield is nonzero the contents of the general register specified by B are added to D to obtain a second operand address otherwise the second operand address is formed solely from the Dfield and the Bfield is ignored. The second operand address is not used to address data instead the address forms the transaction abort code which is placed in a transaction diagnostic block during abort processing. Address computation for the second operand address follows the rules of address arithmetic in the 24 bit addressing mode bits are set to zeros in the 31 bit addressing mode bits are set to zeros.

Commit At the completion of an outermost TRANSACTION END instruction the CPU commits the store accesses made by the transaction i.e. outermost transaction and any nested levels such that they are visible to other CPUs and the I O subsystem. As observed by other CPUs and by the I O subsystem all fetch and store accesses made by all nested levels of the transaction appear to occur as a single concurrent operation when the commit occurs.

The contents of the general registers access registers floating point registers and the floating point control register are not modified by the commit process. Any changes made to these registers during transactional execution are retained when the transaction s stores are committed.

Conflict A transactional access made by one CPU conflicts with either a a transactional access or non transactional access made by another CPU or b the non transactional access made by the I O subsystem if both accesses are to any location within the same cache line and one or more of the accesses is a store.

A conflict may be detected by a CPU s speculative execution of instructions even though the conflict may not be detected in the conceptual sequence.

Constrained Transaction A constrained transaction is a transaction that executes in the constrained transactional execution mode and is subject to the following limitations 

In the absence of repeated interruptions or conflicts with other CPUs or the I O subsystem a constrained transaction eventually completes thus an abort handler routine is not required. Constrained transactions are described in detail below.

When a TRANSACTION BEGIN constrained TBEGINC instruction is executed while the CPU is already in the nonconstrained transaction execution mode execution continues as a nested nonconstrained transaction.

Constrained Transactional Execution Mode When the transaction nesting depth is zero and a transaction is initiated by a TBEGINC instruction the CPU enters the constrained transactional execution mode. While the CPU is in the constrained transactional execution mode the transaction nesting depth is one.

Nested Transaction When the TRANSACTION BEGIN instruction is issued while the CPU is in the nonconstrained transactional execution mode the transaction is nested.

The transactional execution facility uses a model called flattened nesting. In the flattened nesting mode stores made by an inner transaction are not observable by other CPUs and by the I O subsystem until the outermost transaction commits its stores. Similarly if a transaction aborts all nested transactions abort and all transactional stores of all nested transactions are discarded.

One example of nested transactions is depicted in . As shown a first TBEGIN starts an outermost transaction TBEGIN starts a first nested transaction and TBEGIN starts a second nested transaction. In this example TBEGIN and TEND define an innermost transaction . When TEND executes transactional stores are committed for the outermost transaction and all inner transactions.

Nonconstrained Transaction A nonconstrained transaction is a transaction that executes in the nonconstrained transactional execution mode. Although a nonconstrained transaction is not limited in the manner as a constrained transaction it may still be aborted due to a variety of causes.

Nonconstrained Transactional Execution Mode When a transaction is initiated by the TBEGIN instruction the CPU enters the nonconstrained transactional execution mode. While the CPU is in the nonconstrained transactional execution mode the transaction nesting depth may vary from one to the maximum transaction nesting depth.

Non Transactional Access Non transactional accesses are storage operand accesses made by the CPU when it is not in the transactional execution mode that is classic storage accesses outside of a transaction . Further accesses made by the I O subsystem are non transactional accesses. Additionally the NONTRANSACTIONAL STORE instruction may be used to cause a non transactional store access while the CPU is in the nonconstrained transactional execution mode.

One embodiment of a format of a NONTRANSACTIONAL STORE instruction is described with reference to . As one example a NONTRANSACTIONAL STORE instruction includes a plurality of opcode fields specifying an opcode that designates a nontransactional store operation a register field R specifying a register the contents of which are called the first operand an index field X a base field B a first displacement field DL and a second displacement field DH . The contents of the general registers designated by the Xand Bfields are added to the contents of a concatenation of contents of the DHand DLfields to form the second operand address. When either or both the Xor Bfields are zero the corresponding register does not take part in the addition.

The displacement formed by the concatenation of the DHand DLfields is treated as a 20 bit signed binary integer.

The second operand is to be aligned on a double word boundary otherwise specification exception is recognized and the operation is suppressed.

Outer Outermost Transaction A transaction with a lower numbered transaction nesting depth is an outer transaction. A transaction with a transaction nesting depth value of one is the outermost transaction.

An outermost TRANSACTION BEGIN instruction is one that is executed when the transaction nesting depth is initially zero. An outermost TRANSACTION END instruction is one that causes the transaction nesting depth to transition from one to zero. A constrained transaction is the outermost transaction in this embodiment.

Program Interruption Filtering When a transaction is aborted due to certain exception conditions the program can optionally prevent the interruption from occurring. This technique is called program interruption filtering. Program interruption filtering is subject to the transactional class of the interruption the effective program interruption filtering control from the TRANSACTION BEGIN instruction and the transactional execution program interruption filtering override in control register .

Transaction A transaction includes the storage operand accesses made and selected general registers altered while the CPU is in the transaction execution mode. For a nonconstrained transaction storage operand accesses may include both transactional accesses and non transactional accesses. For a constrained transaction storage operand accesses are limited to transactional accesses. As observed by other CPUs and by the I O subsystem all storage operand accesses made by the CPU while in the transaction execution mode appear to occur as a single concurrent operation. If a transaction is aborted transactional store accesses are discarded and any registers designated by the general register save mask of the outermost TRANSACTION BEGIN instruction are restored to their contents prior to transactional execution.

Transactional Accesses Transactional accesses are storage operand accesses made while the CPU is in the transactional execution mode with the exception of accesses made by the NONTRANSACTIONAL STORE instruction.

Transactional Execution Mode The term transactional execution mode a.k.a. transaction execution mode describes the common operation of both the nonconstrained and the constrained transactional execution modes. Thus when the operation is described the terms nonconstrained and constrained are used to qualify the transactional execution mode.

When the transaction nesting depth is zero the CPU is not in the transactional execution mode also called the non transactional execution mode .

As observed by the CPU fetches and stores made in the transactional execution mode are no different than those made while not in the transactional execution mode.

In one embodiment of the z Architecture the transactional execution facility is under the control of bits of control register bits of control register the transaction nesting depth the transaction diagnostic block address and the transaction abort program status word PSW .

Following an initial CPU reset the contents of bit positions of control register bit positions of control register and the transaction nesting depth are set to zero. When the transactional execution control bit of control register is zero the CPU cannot be placed into the transactional execution mode.

As indicated the transactional execution facility is controlled by two bits in control register zero and three bits in control register two. For instance 

It is model dependent whether TDC value is implemented. If not implemented a value of 1 acts as if 2 was specified.

A valid transaction diagnostic block address TDBA is set from the first operand address of the outermost TRANSACTION BEGIN TBEGIN instruction when the Bfield of the instruction is nonzero. When the CPU is in the primary space or access register mode the TDBA designates a location in the primary address space. When the CPU is in the secondary space or home space mode the TDBA designates a location in the secondary or home address space respectively. When DAT Dynamic Address Translation is off the TDBA designates a location in real storage.

The TDBA is used by the CPU to locate the transaction diagnostic block called the TBEGIN specified TDB if the transaction is subsequently aborted. The rightmost three bits of the TDBA are zero meaning that the TBEGIN specified TDB is on a doubleword boundary.

When the Bfield of an outermost TRANSACTION BEGIN TBEGIN instruction is zero the transactional diagnostic block address is invalid and no TBEGIN specified TDB is stored if the transaction is subsequently aborted.

During execution of the TRANSACTION BEGIN TBEGIN instruction when the nesting depth is initially zero the transaction abort PSW is set to the contents of the current PSW the instruction address of the transaction abort PSW designates the next sequential instruction that is the instruction following the outermost TBEGIN . During execution of the TRANSACTION BEGIN constrained TBEGINC instruction when the nesting depth is initially zero the transaction abort PSW is set to the contents of the current PSW except that the instruction address of the transaction abort PSW designates the TBEGINC instruction rather than the next sequential instruction following the TBEGINC .

When a transaction is aborted the condition code in the transaction abort PSW is replaced with a code indicating the severity of the abort condition. Subsequently if the transaction was aborted due to causes that do not result in an interruption the PSW is loaded from the transaction abort PSW if the transaction was aborted due to causes that result in an interruption the transaction abort PSW is stored as the interruption old PSW.

The transaction abort PSW is not altered during the execution of any inner TRANSACTION BEGIN instruction.

The transaction nesting depth is for instance a 16 bit unsigned value that is incremented each time a TRANSACTION BEGIN instruction is completed with condition code 0 and decremented each time a TRANSACTION END instruction is completed. The transaction nesting depth is reset to zero when a transaction is aborted or by CPU reset.

In one implementation when the CPU is in the constrained transactional execution mode the transaction nesting depth is one. Additionally although the maximum TND can be represented as a 4 bit value the TND is defined to be a 16 bit value to facilitate its inspection in the transaction diagnostic block.

When a transaction is aborted various status information may be saved in a transaction diagnostic block TDB as follows 

The TBEGIN specified TDB is only stored in one embodiment when the TDB address is valid that is when the outermost TBEGIN instruction s Bfield is nonzero .

For aborts due to unfiltered program exception conditions only one of either the PI TDB or Interception TDB will be stored. Thus there may be zero one or two TDBs stored for an abort.

TBEGIN Specified TDB The 256 byte location specified by a valid transaction diagnostic block address. When the transaction diagnostic block address is valid the TBEGIN specified TDB is stored on a transaction abort. The TBEGIN specified TDB is subject to all storage protection mechanisms that are in effect at the execution of the outermost TRANSACTION BEGIN instruction. A PER Program Event Recording storage alteration event for any portion of the TBEGIN specified TDB is detected during the execution of the outermost TBEGIN not during the transaction abort processing.

One purpose of PER is to assist in debugging programs. It permits the program to be alerted to the following types of events as examples 

The program can selectively specify that one or more of the above types of events be recognized except that the event for STORE USING REAL ADDRESS can be specified only along with the storage alteration event. The information concerning a PER event is provided to the program by means of a program interruption with the cause of the interruption being identified in the interruption code.

Program Interruption TDB Real locations 6 144 6 399 1800 18FF hex . The program interruption TDB is stored when a transaction is aborted due to program interruption. When a transaction is aborted due to other causes the contents of the program interruption TDB are unpredictable.

The program interruption TDB is not subject to any protection mechanism. PER storage alteration events are not detected for the program interruption TDB when it is stored during a program interruption.

Interception TDB The 256 byte host real location specified by locations of the state description. The interception TDB is stored when an aborted transaction results in a guest program interruption interception that is interception code 8 . When a transaction is aborted due to other causes the contents of the interception TDB are unpredictable. The interception TDB is not subject to any protection mechanism.

As observed by other CPUs and the I O subsystem storing of the TDB s during a transaction abort is a multiple access reference occurring after any non transactional stores.

A transaction may be aborted due to causes that are outside the scope of the immediate configuration in which it executes. For example transient events recognized by a hypervisor such as LPAR or z VM may cause a transaction to be aborted.

The information provided in the transaction diagnostic block is intended for diagnostic purposes and is substantially correct. However because an abort may have been caused by an event outside the scope of the immediate configuration information such as the abort code or program interruption identification may not accurately reflect conditions within the configuration and thus should not be used in determining program action.

In addition to the diagnostic information saved in the TDB when a transaction is aborted due to any data exception program exception condition and both the AFP register control bit of control register and the effective allow floating point operation control F are one the data exception code DXC is placed into byte of the floating point control register FPCR regardless of whether filtering applies to the program exception condition. When a transaction is aborted and either or both the AFP register control or effective allow floating point operation control are zero the DXC is not placed into the FPCR.

In one embodiment as indicated herein when the transactional execution facility is installed the following general instructions are provided.

When the CPU is in the transactional execution mode attempted execution of certain instructions is restricted and causes the transaction to be aborted.

When issued in the constrained transactional execution mode attempted execution of restricted instructions may also result in a transaction constraint program interruption or may result in execution proceeding as if the transaction was not constrained.

In one example of the z Architecture restricted instructions include as examples the following non privileged instructions COMPARE AND SWAP AND STORE MODIFY RUNTIME INSTRUMENTATION CONTROLS PERFORM LOCKED OPERATION PREFETCH DATA RELATIVE LONG when the code in the Mfield is 6 or 7 STORE CHARACTERS UNDER MASK HIGH when the Mfield is zero and the code in the Rfield is 6 or 7 STORE FACILITY LIST EXTENDED STORE RUNTIME INSTRUMENTATION CONTROLS SUPERVISOR CALL and TEST RUNTIME INSTRUMENTATION CONTROLS.

In the above list COMPARE AND SWAP AND STORE and PERFORM LOCKED OPERATION are complex instructions which can be more efficiently implemented by the use of basic instructions in the TX mode. The cases for PREFETCH DATA and PREFETCH DATA RELATIVE LONG are restricted as the codes of 6 and 7 release a cache line necessitating the commitment of the data potentially prior to the completion of a transaction. SUPERVISOR CALL is restricted as it causes an interruption which causes a transaction to be aborted .

The above list includes instructions that may form trace entries. If these instructions were allowed to execute transactionally and formed trace entries and the transaction subsequently aborted the trace table pointer in control register would be advanced but the stores to the trace table would be discarded. This would leave an inconsistent gap in the trace table thus the instructions are restricted in the cases where they would form trace entries.

When the CPU is in the transactional execution mode it is model dependent whether the following instructions are restricted CIPHER MESSAGE CIPHER MESSAGE WITH CFB CIPHER MESSAGE WITH CHAINING CIPHER MESSAGE WITH COUNTER CIPHER MESSAGE WITH OFB COMPRESSION CALL COMPUTE INTERMEDIATE MESSAGE DIGEST COMPUTE LAST MESSAGE DIGEST COMPUTE MESSAGE AUTHENTICATION CODE CONVERT UNICODE 16 TO UNICODE 32 CONVERT UNICODE 16 TO UNICODE 8 CONVERT UNICODE 32 TO UNICODE 16 CONVERT UNICODE 32 TO UNICODE 8 CONVERT UNICODE 8 TO UNICODE 16 CONVERT UNICODE 8 TO UNICODE 32 PERFORM CRYPTOGRAPHIC COMPUTATION RUNTIME INSTRUMENTATION OFF and RUNTIME INSTRUMENTATION ON.

Each of the above instructions is either currently implemented by the hardware co processor or has been in past machines and thus is considered restricted.

When the effective allow AR modification A control is zero the following instructions are restricted COPY ACCESS LOAD ACCESS MULTIPLE LOAD ADDRESS EXTENDED and SET ACCESS.

Each of the above instructions causes the contents of an access register to be modified. If the A control in the TRANSACTION BEGIN instruction is zero then the program has explicitly indicated that access register modification is not to be allowed.

When the effective allow floating point operation F control is zero floating point instructions are restricted.

Under certain circumstances the following instructions may be restricted EXTRACT CPU TIME EXTRACT PSW STORE CLOCK STORE CLOCK EXTENDED and STORE CLOCK FAST.

Each of the above instructions is subject to an interception control in the interpretative execution state description. If the hypervisor has set the interception control for these instructions then their execution may be prolonged due to hypervisor implementation thus they are considered restricted if an interception occurs.

When a nonconstrained transaction is aborted because of the attempted execution of a restricted instruction the transaction abort code in the transaction diagnostic block is set to restricted instruction and the condition code is set to 3 except as follows when a nonconstrained transaction is aborted due to the attempted execution of an instruction that would otherwise result in a privileged operation exception it is unpredictable whether the abort code is set to 11 restricted instruction or 4 unfiltered program interruption resulting from the recognition of the privileged operation program interruption . When a nonconstrained transaction is aborted due to the attempted execution of PREFETCH DATA RELATIVE LONG when the code in the Mfield is 6 or 7 or STORE CHARACTERS UNDER MASK HIGH when the Mfield is zero and the code in the Rfield is 6 or 7 it is unpredictable whether the abort code is set to 11 restricted instruction or 16 cache other . When a nonconstrained transaction is aborted due to the attempted execution of MONITOR CALL and both a monitor event condition and a specification exception condition are present it is unpredictable whether the abort code is set to 11 or 4 or if the program interruption is filtered 12.

Additional instructions may be restricted in a constrained transaction. Although these instructions are not currently defined to be restricted in a nonconstrained transaction they may be restricted under certain circumstances in a nonconstrained transaction on future processors.

Certain restricted instructions may be allowed in the transactional execution mode on future processors. Therefore the program should not rely on the transaction being aborted due to the attempted execution of a restricted instruction. The TRANSACTION ABORT instruction should be used to reliably cause a transaction to be aborted.

In a nonconstrained transaction the program should provide an alternative non transactional code path to accommodate a transaction that aborts due to a restricted instruction.

In operation when the transaction nesting depth is zero execution of the TRANSACTION BEGIN TBEGIN instruction resulting in condition code zero causes the CPU to enter the nonconstrained transactional execution mode. When the transaction nesting depth is zero execution of the TRANSACTION BEGIN constrained TBEGINC instruction resulting in condition code zero causes the CPU to enter the constrained transactional execution mode.

Except where explicitly noted otherwise all rules that apply for non transactional execution also apply to transactional execution. Below are additional characteristics of processing while the CPU is in the transactional execution mode.

When the CPU is in the nonconstrained transactional execution mode execution of the TRANSACTION BEGIN instruction resulting in condition code zero causes the CPU to remain in the nonconstrained transactional execution mode.

As observed by the CPU fetches and stores made in the transaction execution mode are no different than those made while not in the transactional execution mode. As observed by other CPUs and by the I O subsystem all storage operand accesses made while a CPU is in the transactional execution mode appear to be a single block concurrent access. That is the accesses to all bytes within a halfword word doubleword or quadword are specified to appear to be block concurrent as observed by other CPUs and I O e.g. channel programs. The halfword word doubleword or quadword is referred to in this section as a block. When a fetch type reference is specified to appear to be concurrent within a block no store access to the block by another CPU or I O program is permitted during the time that bytes contained in the block are being fetched. When a store type reference is specified to appear to be concurrent within a block no access to the block either fetch or store is permitted by another CPU or I O program during the time that the bytes within the block are being stored.

Storage accesses for instruction and DAT and ART Access Register Table table fetches follow the non transactional rules.

The CPU leaves the transactional execution mode normally by means of a TRANSACTION END instruction that causes the transaction nesting depth to transition to zero in which case the transaction completes.

When the CPU leaves the transactional execution mode by means of the completion of a TRANSACTION END instruction all stores made while in the transactional execution mode are committed that is the stores appear to occur as a single block concurrent operation as observed by other CPUs and by the I O subsystem.

A transaction may be implicitly aborted for a variety of causes or it may be explicitly aborted by the TRANSACTION ABORT instruction. Example possible causes of a transaction abort the corresponding abort code and the condition code that is placed into the transaction abort PSW are described below.

Execution of a TRANSACTION ABORT instruction causes the transaction to abort. The transaction abort code is set from the second operand address. The condition code is set to either 2 or 3 depending on whether bit of the second operand address is zero or one respectively.

In one embodiment and as mentioned above the transactional facility provides for both constrained transactions and nonconstrained transactions as well as processing associated therewith. Initially constrained transactions are discussed and then nonconstrained transactions

A constrained transaction executes in transactional mode without a fall back path. It is a mode of processing useful for compact functions. In the absence of repeated interruptions or conflicts with other CPUs or the I O subsystem i.e. caused by conditions that will not allow the transaction to complete successfully a constrained transaction will eventually complete thus an abort handler routine is not required and is not specified. For instance in the absence of violation of a condition that cannot be addressed e.g. divide by 0 a condition that does not allow the transaction to complete e.g. a timer interruption that does not allow an instruction to run a hot I O etc. or a violation of a restriction or constraint associated with a constrained transaction the transaction will eventually complete.

A constrained transaction is initiated by a TRANSACTION BEGIN constrained TBEGINC instruction when the transaction nesting depth is initially zero. A constrained transaction is subject to the following constraints in one embodiment.

If a constrained transaction violates any of constraints 1 7 listed above then either a a transaction constraint program interruption is recognized or b execution proceeds as if the transaction was not constrained except that further constraint violations may still result in a transaction constrained program interruption. It is unpredictable which action is taken and the action taken may differ based on which constraint is violated.

In the absence of constraint violations repeated interruptions or conflicts with other CPUs or the I O subsystem a constrained transaction will eventually complete as described above.

Note that both registers and are not restored in this example. Also note that on some models the count in general register may be low if the CPU detects the abort condition following the completion of the TBEGINC instruction but before the completion of the AHI instruction.

As observed by the CPU fetches and stores made in the transactional execution mode are no different than those made while not in the transaction execution mode.

In one embodiment the user i.e. the one creating the transaction selects whether or not a transaction is to be constrained. One embodiment of the logic associated with the processing of constrained transactions and in particular the processing associated with a TBEGINC instruction is described with reference to . Execution of the TBEGINC instruction causes the CPU to enter the constrained transactional execution mode or remain in the nonconstrained execution mode. The CPU i.e. the processor executing TBEGINC performs the logic of .

Referring to based on execution of a TBEGINC instruction a serialization function is performed STEP . A serialization function or operation includes completing all conceptually previous storage accesses and for the z Architecture as an example related reference bit and change bit settings by the CPU as observed by other CPUs and by the I O subsystem before the conceptually subsequent storage accesses and related reference bit and change bit settings occur. Serialization affects the sequence of all CPU accesses to storage and to the storage keys except for those associated with ART table entry and DAT table entry fetching.

As observed by a CPU in the transactional execution mode serialization operates normally as described above . As observed by other CPUs and by the I O subsystem a serializing operation performed while a CPU is in the transactional execution mode occurs when the CPU leaves the transactional execution mode either as a result of a TRANSACTION END instruction that decrements the transaction nesting depth to zero normal ending or as a result of the transaction being aborted.

Subsequent to performing serialization a determination is made as to whether an exception is recognized INQUIRY . If so the exception is handled STEP . For instance a special operation exception is recognized and the operation is suppressed if the transactional execution control bit of control register is 0. As further examples a specification exception is recognized and the operation is suppressed if the Bfield bits of the instruction is nonzero an execute exception is recognized and the operation is suppressed if the TBEGINC is the target of an execute type instruction and an operation exception is recognized and the operation is suppressed if the transactional execution facility is not installed in the configuration. If the CPU is already in the constrained transaction execution mode then a transaction constrained exception program exception is recognized and the operation is suppressed. Further if the transaction nesting depth when incremented by 1 would exceed a model dependent maximum transaction nesting depth the transaction is aborted with abort code . Other or different exceptions may be recognized and handled.

However if there is not an exception then a determination is made as to whether the transaction nesting depth is zero INQUIRY . If the transaction nesting depth is zero then the transaction diagnostic block address is considered to be invalid STEP the transaction abort PSW is set from the contents of the current PSW except that the instruction address of the transaction abort PSW designates the TBEGINC instruction rather than the next sequential instruction STEP and the contents of the general register pairs as designated by the general register save mask are saved in a model dependent location that is not directly accessible by the program STEP . Further the nesting depth is set to 1 STEP . Additionally the effective value of the allow floating point operation F and program interruption filtering controls PIFC are set to zero STEP . Further the effective value of the allow AR modification A control bit field of the Ifield of the instruction is determined STEP . For example the effective A control is the logical AND of the A control in the TBEGINC instruction for the current level and for any outer TBEGIN instructions.

Returning to INQUIRY if the transaction nesting depth is greater than zero then the nesting depth is incremented by 1 STEP . Further the effective value of the allow floating point operation F is set to zero and the effective value of the program interruption filtering control PIFC is unchanged STEP . Processing then continues with STEP . In one embodiment a successful initiation of the transaction results in condition code 0. This concludes one embodiment of the logic associated with executing a TBEGINC instruction.

In one embodiment the exception checking provided above can occur in varying order. One particular order for the exception checking is as follows 

As described herein in one aspect a constrained transaction is assured of completion assuming it does not contain a condition that makes it unable to complete. To ensure it completes the processor e.g. CPU executing the transaction may take certain actions. For instance if a constrained transaction has an abort condition the CPU may temporarily 

As described above in addition to constrained transaction processing which is optional in one embodiment the transactional facility also provides nonconstrained transaction processing. Further details regarding the processing of nonconstrained transactions and in particular the processing associated with a TBEGIN instruction are described with reference to . Execution of the TBEGIN instruction causes the CPU either to enter or to remain in the nonconstrained transactional execution mode. The CPU i.e. the processor that executes TBEGIN performs the logic of .

Referring to based on execution of the TBEGIN instruction a serialization function described above is performed STEP . Subsequent to performing serialization a determination is made as to whether an exception is recognized INQUIRY . If so then the exception is handled STEP . For instance a special operation exception is recognized and the operation is suppressed if the transactional execution control bit of control register is zero. Further a specification exception is recognized and the operation is suppressed if the program interruption filtering control bits of the Ifield of the instruction contains the value or the first operand address does not designate a double word boundary. An operation exception is recognized and the operation is suppressed if the transactional execution facility is not installed in the configuration and an execute exception is recognized and the operation is suppressed if the TBEGIN is the target of an execute type instruction. Additionally if the CPU is in the constrained transactional execution mode then a transaction constrained exception program exception is recognized and the operation is suppressed. Further if the transaction nesting depth when incremented by 1 would exceed a model dependent maximum transaction nesting depth the transaction is aborted with abort code .

Yet further when the Bfield of the instruction is nonzero and the CPU is not in the transactional execution mode i.e. the transaction nesting depth is zero then the store accessibility to the first operand is determined. If the first operand cannot be accessed for stores then an access exception is recognized and the operation is either nullified suppressed or terminated depending on the specific access exception condition. Additionally any PER storage alteration event for the first operand is recognized. When the Bfield is nonzero and the CPU is already in the transactional execution mode it is unpredictable whether store accessibility to the first operand is determined and PER storage alteration events are detected for the first operand. If the Bfield is zero then the first operand is not accessed.

In addition to the exception checking a determination is made as to whether the CPU is in the transactional execution mode i.e. transaction nesting depth is zero INQUIRY . If the CPU is not in the transactional execution mode then the contents of selected general register pairs are saved STEP . In particular the contents of the general register pairs designated by the general register save mask are saved in a model dependent location that is not directly accessible by the program.

Further a determination is made as to whether the Bfield of the instruction is zero INQUIRY . If the Bfield is not equal to zero the first operand address is placed in the transaction diagnostic block address STEP and the transaction diagnostic block address is valid. Further the transaction abort PSW is set from the contents of the current PSW STEP . The instruction address of the transaction abort PSW designates the next sequential instruction that is the instruction following the outermost TBEGIN .

Moreover a determination is made of the effective value of the allow AR modification A control bit of the Ifield of the instruction STEP . The effective A control is the logical AND of the A control in the TBEGIN instruction for the current level and for all outer levels. Additionally an effective value of the allow floating point operation F control bit of the Ifield of the instruction is determined STEP . The effective F control is the logical AND of the F control in the TBEGIN instruction for the current level and for all outer levels. Further an effective value of the program interruption filtering control PIFC bits of the Ifield of the instruction is determined STEP . The effective PIFC value is the highest value in the TBEGIN instruction for the current level and for all outer levels.

Additionally a value of one is added to the transaction nesting depth STEP and the instruction completes with setting condition code 0 STEP . If the transaction nesting depth transitions from zero to one the CPU enters the nonconstrained transactional execution mode otherwise the CPU remains in the nonconstrained transactional execution mode.

Returning to INQUIRY if Bis equal to zero then the transaction diagnostic block address is invalid STEP and processing continues with STEP . Similarly if the CPU is in transactional execution mode INQUIRY processing continues with STEP .

In one embodiment the exception checking provided above can occur in varying order. One particular order to the exception checking is as follows 

In one embodiment the TBEGIN instruction implicitly sets the transaction abort address to be the next sequential instruction following the TBEGIN. This address is intended to be a conditional branch instruction which determines whether or not to branch depending on the condition code CC . A successful TBEGIN sets CC0 whereas an aborted transaction sets CC1 CC2 or CC3.

In one embodiment the TBEGIN instruction provides an optional storage operand designating the address of a transaction diagnostic block TDB into which information is stored if the transaction is aborted.

The A F and PIFC controls can be different at various nesting levels and restored to the previous level when inner transaction levels are ended.

Moreover the TBEGIN or in another embodiment TBEGINC is used to form a transaction token. Optionally the token may be matched with a token formed by the TEND instruction. For each TBEGIN or TBEGINC instruction as an example a token is formed from the first operand address. This token may be formed independent of whether the base register is zero unlike TDB address setting which only occurs when the base register is nonzero . For each TRANSACTION END instruction executed with a nonzero base register a similar token is formed from its storage operand. If the tokens do not match a program exception may be recognized to alert the program of an unpaired instruction.

Token matching provides a mechanism intended to improve software reliability by ensuring that a TEND statement is properly paired with a TBEGIN or TBEGINC . When a TBEGIN instruction is executed at a particular nesting level a token is formed from the storage operand address that identifies this instance of a transaction. When a corresponding TEND instruction is executed a token is formed from the storage operand address of the instruction and the CPU compares the begin token for the nesting level with the end token. If the tokens do not match an exception condition is recognized. A model may implement token matching for only a certain number of nesting levels or for no nesting levels . The token may not involve all bits of the storage operand address or the bits may be combined via hashing or other methods. A token may be formed by the TBEGIN instruction even if its storage operand is not accessed.

As indicated above a transaction either constrained or nonconstrained may be ended by a TRANSACTION END TEND instruction. Further details regarding the processing of a transaction end TEND instruction are described with reference to . The CPU i.e. the processor executing the TEND performs the logic of .

Referring to initially based on the processor obtaining e.g. fetching receiving etc. the TEND instruction various exception checking is performed and if there is an exception INQUIRY then the exception is handled STEP . For instance if the TRANSACTION END is the target of an execute type instruction the operation is suppressed and an execute exception is recognized and a special operation exception is recognized and the operation is suppressed if the transactional execution control bit of CR is zero. Yet further an operation exception is recognized and the operation is suppressed if the transactional execution facility is not installed in the configuration.

Returning to INQUIRY if an exception is not recognized then the transaction nesting depth is decremented e.g. by one STEP . A determination is made as to whether the transactional nesting depth is zero following the decrementing INQUIRY . If the transaction nesting depth is zero then all store accesses made by the transaction and other transactions within the nest of transactions if any of which this transaction is a part are committed STEP . Further the CPU leaves the transactional execution mode STEP and the instruction completes STEP .

Returning to INQUIRY if the transaction nesting depth is not equal to zero then the TRANSACTION END instruction just completes.

If the CPU is in the transaction execution mode at the beginning of the operation the condition code is set to 0 otherwise the condition code is set to 2.

It is noted that the effective allow floating point operation F control allow AR modification A control and program interruption filtering control PIFC are reset to their respective values prior to the TRANSACTION BEGIN instruction that initiated the level being ended. Further a serialization function is performed at the completion of the operation.

The PER instruction fetching and transaction end events that are recognized at the completion of the outermost TRANSACTION END instruction do not result in the transaction being aborted.

In one example the TEND instruction also includes a base field Band a displacement field D which are combined e.g. added to create a second operand address. In this example token matching may be performed. For instance when Bis nonzero selected bits of the second operand address are matched against a transaction token formed by the corresponding TBEGIN. If there is a mismatch there is an exception e.g. PIC .

In accordance with an aspect execution of certain instructions within a transaction is restricted. That is in one embodiment allowing every instruction to execute transactionally is not practical since for instance 

Because of this certain instructions are restricted during transactional execution. Further due to the assurance of eventual completion in a constrained transaction additional instructions are restricted in a constrained transaction. Additional details regarding these restrictions are described above with the description of TBEGIN and TBEGINC.

In one embodiment the restricted instructions may be classified into a plurality of classes including for instance control and I O instructions i.e. privileged and semi privileged instructions instructions causing tracing or monitor event counting SUPERVISOR CALL instruction instructions that employ hardware coprocessor assistance e.g. message security assists compression call and instructions that are intercepted by the hypervisor. Further some types of instructions are selectively restricted based on controls on TBEGIN TBEGINC. These instructions include instructions that modify access registers and floating point instructions. If a restricted instruction is encountered in a transaction the transaction is aborted e.g. abort code 11 .

One embodiment of the logic associated with managing restricted instructions in transactional processing is described with reference to . This logic is performed by a processor. The operations performed may be performed in a differing order and or one or more of the operations may be optionally or implicitly performed.

Referring initially to execution of a transaction is initiated by for instance a TBEGIN or TBEGINC instruction STEP . A determination is made as to the type of transaction being initiated i.e. a nonconstrained or constrained transaction as indicated by for instance the operation code of the TRANSACTION BEGIN instruction STEP . Thereafter an instruction is initiated within the transaction STEP . A determination is then made as to whether the instruction is restricted regardless of the type of transaction that is the nonconstrained or constrained transaction as described in further detail below INQUIRY . If the instruction is restricted regardless of the type of transaction then a further determination is made as to whether the transaction is a constrained transaction e.g. initiated by TBEGINC INQUIRY . If it is a constrained transaction then the transaction is aborted with a transaction constraint non filtered program interruption abort code and an interrupt is presented STEP . Otherwise the transaction is aborted with a restricted instruction abort code STEP .

Returning to INQUIRY if the instruction is not restricted regardless of type of transaction then a further determination is made as to whether the instruction is restricted only for constrained transactions INQUIRY . This determination may be made by comparing the opcode of the instruction with a list of restricted opcodes for constrained transactions or by other mechanisms. If the instruction is not restricted for either type of transaction then the instruction is executed STEP . Otherwise if the instruction is restricted for only constrained transactions a determination is made as to whether the transaction is a constrained transaction INQUIRY . If it is a nonconstrained transaction then the instruction is executed. However if it is a constrained transaction then a check is made as to whether the constrained transaction can be executed as if it were a nonconstrained transaction INQUIRY . If the constrained transaction can be treated as a nonconstrained transaction then the instruction is executed STEP . Otherwise processing continues with STEP and the instruction is aborted.

Further details of determining whether an instruction is restricted regardless of type of transaction is described with reference to . Initially a determination is made as to whether the instruction is in a class of restricted instructions INQUIRY i.e. is the instruction indicated as a restricted instruction regardless of transaction type. In one embodiment the classes of restricted instructions include control and I O instructions instructions causing tracing or monitor event counting the Supervisor Call instruction instructions that employ hardware co processor assistance and instructions that are intercepted by the hypervisor. This determination may be made by comparing the opcode of the instruction to opcodes within the classes of restricted instructions or opcodes within a list of restricted instructions. Other mechanisms are also possible.

If the instruction is in a class of restricted instructions then it is restricted STEP . However if the instruction is not in the class of restricted instructions then a further determination is made as to whether the instruction is selectively indicated as restricted based on controls of one or more TRANSACTION BEGIN instructions INQUIRY . That is a determination is made as to whether the effective allow access register modification control or the effective allow floating point operation control indicates that the instruction is restricted. If it is so indicated then the transaction is restricted STEP . Otherwise the instruction is not considered restricted regardless of type of transaction STEP and processing continues with INQUIRY to determine if the instruction is restricted for only constrained transactions.

As indicated above one or more controls of the TRANSACTION BEGIN instruction are used to selectively determine whether particular types of instructions may be executed within a given transaction. For instance since certain types of registers such as access registers floating point registers and or the floating point control register are not restored on an abort of the transaction the transaction s abort handler recovery routine may not be able to accommodate the modification of such registers or even the execution of instructions of a floating point context. As used herein a floating point context includes any instruction that can inspect or alter the floating point registers or the floating point control register. Thus a mechanism is employed to indicate whether such modification access is tolerated. In particular since the abort handler represents processing at the outermost level and since access register modification or a floating point operation may have occurred at an inner nesting level a mechanism is provided of indicating whether modification of the registers or execution of the context instructions is permitted. This mechanism includes for instance controls on the TRANSACTION BEGIN instruction.

In one embodiment the controls include the A control which is the allow access register modification control and the F control which is the allow floating point operation control. Transactions may be nested and therefore there is a set of controls for each level of nesting. The effective A and F control is a logical AND of all controls of the same type at all nesting levels. Thus the effective control is the least permissive of current nesting level and all lower levels. However in a nested transaction the effective control is restored to that of the lower nesting level each time a TRANSACTION END instruction is executed. For example a series of nested TBEGIN instructions may have the A control set to 1 1 0 1 and 0 in nesting levels and . Thus at nesting depths and access register modification is permitted but at nesting level and higher access register modification is not permitted. As the program transitions back from nesting level to access register modification again becomes permitted. Similar operation applies to the F control.

One embodiment of updating the controls as the nesting level decreases is described with reference to . In one example a processor performs this logic. Initially a transaction is initiated based on for instance executing a TRANSACTION BEGIN instruction STEP . This transaction may or may not be part of a nest of transactions. The TRANSACTION BEGIN instruction includes one or more controls used to indicate whether certain registers can be updated and therefore whether certain instructions can be executed. For instance a TBEGIN instruction includes the A and F controls each of which is respectively set to a 0 if the appropriate modification access is not allowed or a 1 if the modification access is allowed. Further the TBEGINC instruction includes the A control which is similarly set to 0 or 1. The values of these controls are used based on execution of the TRANSACTION BEGIN instruction to determine the effective value of the A control and or the effective value of the F control as described above STEP .

At some point a transaction may end STEP . A determination is made as to whether this is the end of the outermost transaction i.e. the outermost transaction of a nest of transactions or the end of a transaction that is not part of a nest of transactions INQUIRY . If it is not the end of the outermost transaction then the one or more effective controls are updated STEP . In one example the controls are updated by re computing the effective controls without including the controls from the transaction that has ended. Returning to INQUIRY if it is the end of the outermost transaction then processing is complete.

Described above is a mechanism to restrict execution of certain instructions within a transaction. As examples certain classes of instructions are restricted and or controls are provided that selectively indicate whether a particular type of instruction is allowed to execute. For instance a control is provided that indicates whether access registers may be modified and therefore whether an instruction that modifies such registers can be executed. As a further example a control is provided that indicates whether floating point operations can be performed.

Further provided above is an efficient means of updating multiple discontiguous objects in memory without classic course grained serialization such as locking that provides a potential for significant multiprocessor performance improvement. That is multiple discontiguous objects are updated without the enforcement of more course grained storage access ordering that is provided by classic techniques such as locks and semaphores. Speculative execution is provided without onerous recovery setup and constrained transactions are offered for simple small footprint updates.

Transactional execution can be used in a variety of scenarios including but not limited to partial inlining speculative processing and lock elision. In partial inlining the partial region to be included in the executed path is wrapped in TBEGIN TEND. TABORT can be included therein to roll back state on a side exit. For speculation such as in Java nullchecks on de referenced pointers can be delayed to loop edge by using a transaction. If the pointer is null the transaction can abort safely using TABORT which is included within TBEGIN TEND.

As for lock elision one example of its use is described with reference to and the code fragment provided below.

In one example if the transaction is used for lock elision but the fallback path uses a lock the transaction is to at least fetch the lock word to see that it is available. The processor ensures that the transaction aborts if another CPU accesses the lock non transactionally.

As used herein storage central storage main storage memory and main memory are used interchangeably unless otherwise noted implicitly by usage or explicitly. Further while in one embodiment a transaction effectively delaying includes delaying committing transactional stores to main memory until completion of a selected transaction in another embodiment a transaction effectively delaying includes allowing transactional updates to memory but keeping the old values and restoring memory to the old values on abort.

As will be appreciated by one skilled in the art one or more aspects may be embodied as a system method or computer program product. Accordingly one or more aspects may take the form of an entirely hardware embodiment an entirely software embodiment including firmware resident software micro code etc. or an embodiment combining software and hardware aspects that may all generally be referred to herein as a circuit module or system . Furthermore one or more embodiments may take the form of a computer program product embodied in one or more computer readable medium s having computer readable program code embodied thereon.

Any combination of one or more computer readable medium s may be utilized. The computer readable medium may be a computer readable storage medium. A computer readable storage medium may be for example but not limited to an electronic magnetic optical electromagnetic infrared or semiconductor system apparatus or device or any suitable combination of the foregoing. More specific examples a non exhaustive list of the computer readable storage medium include the following an electrical connection having one or more wires a portable computer diskette a hard disk a random access memory RAM a read only memory ROM an erasable programmable read only memory EPROM or Flash memory an optical fiber a portable compact disc read only memory CD ROM an optical storage device a magnetic storage device or any suitable combination of the foregoing. In the context of this document a computer readable storage medium may be any tangible medium that can contain or store a program for use by or in connection with an instruction execution system apparatus or device.

Referring now to in one example a computer program product includes for instance one or more non transitory computer readable storage media to store computer readable program code means or logic thereon to provide and facilitate one or more embodiments.

Program code embodied on a computer readable medium may be transmitted using an appropriate medium including but not limited to wireless wireline optical fiber cable RF etc. or any suitable combination of the foregoing.

Computer program code for carrying out operations for one or more embodiments may be written in any combination of one or more programming languages including an object oriented programming language such as Java Smalltalk C or the like and conventional procedural programming languages such as the C programming language assembler or similar programming languages. The program code may execute entirely on the user s computer partly on the user s computer as a stand alone software package partly on the user s computer and partly on a remote computer or entirely on the remote computer or server. In the latter scenario the remote computer may be connected to the user s computer through any type of network including a local area network LAN or a wide area network WAN or the connection may be made to an external computer for example through the Internet using an Internet Service Provider .

One or more embodiments are described herein with reference to flowchart illustrations and or block diagrams of methods apparatus systems and computer program products. It will be understood that each block of the flowchart illustrations and or block diagrams and combinations of blocks in the flowchart illustrations and or block diagrams can be implemented by computer program instructions. These computer program instructions may be provided to a processor of a general purpose computer special purpose computer or other programmable data processing apparatus to produce a machine such that the instructions which execute via the processor of the computer or other programmable data processing apparatus create means for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

These computer program instructions may also be stored in a computer readable medium that can direct a computer other programmable data processing apparatus or other devices to function in a particular manner such that the instructions stored in the computer readable medium produce an article of manufacture including instructions which implement the function act specified in the flowchart and or block diagram block or blocks.

The computer program instructions may also be loaded onto a computer other programmable data processing apparatus or other devices to cause a series of operational steps to be performed on the computer other programmable apparatus or other devices to produce a computer implemented process such that the instructions which execute on the computer or other programmable apparatus provide processes for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

The flowchart and block diagrams in the figures illustrate the architecture functionality and operation of possible implementations of systems methods and computer program products according to various embodiments. In this regard each block in the flowchart or block diagrams may represent a module segment or portion of code which comprises one or more executable instructions for implementing the specified logical function s . It should also be noted that in some alternative implementations the functions noted in the block may occur out of the order noted in the figures. For example two blocks shown in succession may in fact be executed substantially concurrently or the blocks may sometimes be executed in the reverse order depending upon the functionality involved. It will also be noted that each block of the block diagrams and or flowchart illustration and combinations of blocks in the block diagrams and or flowchart illustration can be implemented by special purpose hardware based systems that perform the specified functions or acts or combinations of special purpose hardware and computer instructions.

In addition to the above one or more aspects may be provided offered deployed managed serviced etc. by a service provider who offers management of customer environments. For instance the service provider can create maintain support etc. computer code and or a computer infrastructure that performs one or more aspects for one or more customers. In return the service provider may receive payment from the customer under a subscription and or fee agreement as examples. Additionally or alternatively the service provider may receive payment from the sale of advertising content to one or more third parties.

In one aspect an application may be deployed for performing one or more embodiments. As one example the deploying of an application comprises providing computer infrastructure operable to perform one or more embodiments.

As a further aspect a computing infrastructure may be deployed comprising integrating computer readable code into a computing system in which the code in combination with the computing system is capable of performing one or more embodiments.

As yet a further aspect a process for integrating computing infrastructure comprising integrating computer readable code into a computer system may be provided. The computer system comprises a computer readable medium in which the computer medium comprises one or more embodiments. The code in combination with the computer system is capable of performing one or more embodiments.

Although various embodiments are described above these are only examples. For example computing environments of other architectures can be used to incorporate and use one or more embodiments. Further different instructions instruction formats instruction fields and or instruction values may be used. Moreover different other and or additional restrictions constraints may be provided used. Many variations are possible.

Further other types of computing environments can benefit and be used. As an example a data processing system suitable for storing and or executing program code is usable that includes at least two processors coupled directly or indirectly to memory elements through a system bus. The memory elements include for instance local memory employed during actual execution of the program code bulk storage and cache memory which provide temporary storage of at least some program code in order to reduce the number of times code must be retrieved from bulk storage during execution.

Input Output or I O devices including but not limited to keyboards displays pointing devices DASD tape CDs DVDs thumb drives and other memory media etc. can be coupled to the system either directly or through intervening I O controllers. Network adapters may also be coupled to the system to enable the data processing system to become coupled to other data processing systems or remote printers or storage devices through intervening private or public networks. Modems cable modems and Ethernet cards are just a few of the available types of network adapters.

Referring to representative components of a Host Computer system to implement one or more embodiments are portrayed. The representative host computer comprises one or more CPUs in communication with computer memory i.e. central storage as well as I O interfaces to storage media devices and networks for communicating with other computers or SANs and the like. The CPU is compliant with an architecture having an architected instruction set and architected functionality. The CPU may have access register translation ART which includes an ART lookaside buffer ALB for selecting an address space to be used by dynamic address translation DAT for transforming program addresses virtual addresses into real addresses of memory. A DAT typically includes a translation lookaside buffer TLB for caching translations so that later accesses to the block of computer memory do not require the delay of address translation. Typically a cache is employed between computer memory and the processor . The cache may be hierarchical having a large cache available to more than one CPU and smaller faster lower level caches between the large cache and each CPU. In some implementations the lower level caches are split to provide separate low level caches for instruction fetching and data accesses. In one embodiment for the TX facility a transaction diagnostic block TDB and one or more buffers may be stored in one or more of cache and memory . In one example in TX mode data is initially stored in a TX buffer and when TX mode ends e.g. outermost TEND the data in the buffer is stored committed to memory or if there is an abort the data in the buffer is discarded.

In one embodiment an instruction is fetched from memory by an instruction fetch unit via a cache . The instruction is decoded in an instruction decode unit and dispatched with other instructions in some embodiments to instruction execution unit or units . Typically several execution units are employed for example an arithmetic execution unit a floating point execution unit and a branch instruction execution unit. Further in one embodiment of the TX facility various TX controls may be employed. The instruction is executed by the execution unit accessing operands from instruction specified registers or memory as needed. If an operand is to be accessed loaded or stored from memory a load store unit typically handles the access under control of the instruction being executed. Instructions may be executed in hardware circuits or in internal microcode firmware or by a combination of both.

In accordance with an aspect of the TX facility processor also includes a PSW e.g. TX and or abort PSW a nesting depth a TDBA and one or more control registers .

As noted a computer system includes information in local or main storage as well as addressing protection and reference and change recording. Some aspects of addressing include the format of addresses the concept of address spaces the various types of addresses and the manner in which one type of address is translated to another type of address. Some of main storage includes permanently assigned storage locations. Main storage provides the system with directly addressable fast access storage of data. Both data and programs are to be loaded into main storage from input devices before they can be processed.

Main storage may include one or more smaller faster access buffer storages sometimes called caches. A cache is typically physically associated with a CPU or an I O processor. The effects except on performance of the physical construction and use of distinct storage media are generally not observable by the program.

Separate caches may be maintained for instructions and for data operands. Information within a cache is maintained in contiguous bytes on an integral boundary called a cache block or cache line or line for short . A model may provide an EXTRACT CACHE ATTRIBUTE instruction which returns the size of a cache line in bytes. A model may also provide PREFETCH DATA and PREFETCH DATA RELATIVE LONG instructions which effects the prefetching of storage into the data or instruction cache or the releasing of data from the cache.

Storage is viewed as a long horizontal string of bits. For most operations accesses to storage proceed in a left to right sequence. The string of bits is subdivided into units of eight bits. An eight bit unit is called a byte which is the basic building block of all information formats. Each byte location in storage is identified by a unique nonnegative integer which is the address of that byte location or simply the byte address. Adjacent byte locations have consecutive addresses starting with 0 on the left and proceeding in a left to right sequence. Addresses are unsigned binary integers and are 24 31 or 64 bits.

Information is transmitted between storage and a CPU or a channel subsystem one byte or a group of bytes at a time. Unless otherwise specified in for instance the z Architecture a group of bytes in storage is addressed by the leftmost byte of the group. The number of bytes in the group is either implied or explicitly specified by the operation to be performed. When used in a CPU operation a group of bytes is called a field. Within each group of bytes in for instance the z Architecture bits are numbered in a left to right sequence. In the z Architecture the leftmost bits are sometimes referred to as the high order bits and the rightmost bits as the low order bits. Bit numbers are not storage addresses however. Only bytes can be addressed. To operate on individual bits of a byte in storage the entire byte is accessed. The bits in a byte are numbered 0 through 7 from left to right in e.g. the z Architecture . The bits in an address may be numbered 8 31 or 40 63 for 24 bit addresses or 1 31 or 33 63 for 31 bit addresses they are numbered 0 63 for 64 bit addresses. In one example bits and apply to addresses that are in a location e.g. register that is 32 bits wide whereas bits and apply to addresses that are in a 64 bit wide location. Within any other fixed length format of multiple bytes the bits making up the format are consecutively numbered starting from 0. For purposes of error detection and in preferably for correction one or more check bits may be transmitted with each byte or with a group of bytes. Such check bits are generated automatically by the machine and cannot be directly controlled by the program. Storage capacities are expressed in number of bytes. When the length of a storage operand field is implied by the operation code of an instruction the field is said to have a fixed length which can be one two four eight or sixteen bytes. Larger fields may be implied for some instructions. When the length of a storage operand field is not implied but is stated explicitly the field is said to have a variable length. Variable length operands can vary in length by increments of one byte or with some instructions in multiples of two bytes or other multiples . When information is placed in storage the contents of only those byte locations are replaced that are included in the designated field even though the width of the physical path to storage may be greater than the length of the field being stored.

Certain units of information are to be on an integral boundary in storage. A boundary is called integral for a unit of information when its storage address is a multiple of the length of the unit in bytes. Special names are given to fields of 2 4 8 16 and 32 bytes on an integral boundary. A halfword is a group of two consecutive bytes on a two byte boundary and is the basic building block of instructions. A word is a group of four consecutive bytes on a four byte boundary. A doubleword is a group of eight consecutive bytes on an eight byte boundary. A quadword is a group of 16 consecutive bytes on a 16 byte boundary. An octoword is a group of 32 consecutive bytes on a 32 byte boundary. When storage addresses designate halfwords words doublewords quadwords and octowords the binary representation of the address contains one two three four or five rightmost zero bits respectively. Instructions are to be on two byte integral boundaries. The storage operands of most instructions do not have boundary alignment requirements.

On devices that implement separate caches for instructions and data operands a significant delay may be experienced if the program stores into a cache line from which instructions are subsequently fetched regardless of whether the store alters the instructions that are subsequently fetched.

In one example the embodiments may be practiced by software sometimes referred to licensed internal code firmware micro code milli code pico code and the like any of which would be consistent with one or more embodiments . Referring to software program code which embodies one or more aspects may be accessed by processor of the host system from long term storage media devices such as a CD ROM drive tape drive or hard drive. The software program code may be embodied on any of a variety of known media for use with a data processing system such as a diskette hard drive or CD ROM. The code may be distributed on such media or may be distributed to users from computer memory or storage of one computer system over a network to other computer systems for use by users of such other systems.

The software program code includes an operating system which controls the function and interaction of the various computer components and one or more application programs. Program code is normally paged from storage media device to the relatively higher speed computer storage where it is available for processing by processor . The techniques and methods for embodying software program code in memory on physical media and or distributing software code via networks are well known and will not be further discussed herein. Program code when created and stored on a tangible medium including but not limited to electronic memory modules RAM flash memory Compact Discs CDs DVDs Magnetic Tape and the like is often referred to as a computer program product . The computer program product medium is typically readable by a processing circuit preferably in a computer system for execution by the processing circuit.

The system may communicate with other computers or networks of computers by way of a network adapter capable of communicating with a network . Example network adapters are communications channels token ring Ethernet or modems. Alternatively the system may communicate using a wireless interface such as a CDPD cellular digital packet data card. The system may be associated with such other computers in a Local Area Network LAN or a Wide Area Network WAN or the system can be a client in a client server arrangement with another computer etc. All of these configurations as well as the appropriate communications hardware and software are known in the art.

Still referring to the networks may also include mainframe computers or servers such as a gateway computer client server or application server remote server which may access a data repository and may also be accessed directly from a workstation . A gateway computer serves as a point of entry into each individual network. A gateway is needed when connecting one networking protocol to another. The gateway may be preferably coupled to another network the Internet for example by means of a communications link. The gateway may also be directly coupled to one or more workstations using a communications link. The gateway computer may be implemented utilizing an IBM eServer System z server available from International Business Machines Corporation.

Referring concurrently to and software programming code which may embody one or more aspects may be accessed by the processor of the system from long term storage media such as a CD ROM drive or hard drive. The software programming code may be embodied on any of a variety of known media for use with a data processing system such as a diskette hard drive or CD ROM. The code may be distributed on such media or may be distributed to users from the memory or storage of one computer system over a network to other computer systems for use by users of such other systems.

Alternatively the programming code may be embodied in the memory and accessed by the processor using the processor bus. Such programming code includes an operating system which controls the function and interaction of the various computer components and one or more application programs . Program code is normally paged from storage media to high speed memory where it is available for processing by the processor . The techniques and methods for embodying software programming code in memory on physical media and or distributing software code via networks are well known and will not be further discussed herein. Program code when created and stored on a tangible medium including but not limited to electronic memory modules RAM flash memory Compact Discs CDs DVDs Magnetic Tape and the like is often referred to as a computer program product . The computer program product medium is typically readable by a processing circuit preferably in a computer system for execution by the processing circuit.

The cache that is most readily available to the processor normally faster and smaller than other caches of the processor is the lowest L1 or level one cache and main store main memory is the highest level cache L3 if there are 3 levels . The lowest level cache is often divided into an instruction cache I Cache holding machine instructions to be executed and a data cache D Cache holding data operands.

Referring to an exemplary processor embodiment is depicted for processor . Typically one or more levels of cache are employed to buffer memory blocks in order to improve processor performance. The cache is a high speed buffer holding cache lines of memory data that are likely to be used. Typical cache lines are 64 128 or 256 bytes of memory data. Separate caches are often employed for caching instructions than for caching data. Cache coherence synchronization of copies of lines in memory and the caches is often provided by various snoop algorithms well known in the art. Main memory storage of a processor system is often referred to as a cache. In a processor system having 4 levels of cache main storage is sometimes referred to as the level 5 L5 cache since it is typically faster and only holds a portion of the non volatile storage DASD tape etc that is available to a computer system. Main storage caches pages of data paged in and out of the main storage by the operating system.

A program counter instruction counter keeps track of the address of the current instruction to be executed. A program counter in a z Architecture processor is 64 bits and can be truncated to 31 or 24 bits to support prior addressing limits. A program counter is typically embodied in a PSW program status word of a computer such that it persists during context switching. Thus a program in progress having a program counter value may be interrupted by for example the operating system context switch from the program environment to the operating system environment . The PSW of the program maintains the program counter value while the program is not active and the program counter in the PSW of the operating system is used while the operating system is executing. Typically the program counter is incremented by an amount equal to the number of bytes of the current instruction. RISC Reduced Instruction Set Computing instructions are typically fixed length while CISC Complex Instruction Set Computing instructions are typically variable length. Instructions of the IBM z Architecture are CISC instructions having a length of 2 4 or 6 bytes. The Program counter is modified by either a context switch operation or a branch taken operation of a branch instruction for example. In a context switch operation the current program counter value is saved in the program status word along with other state information about the program being executed such as condition codes and a new program counter value is loaded pointing to an instruction of a new program module to be executed. A branch taken operation is performed in order to permit the program to make decisions or loop within the program by loading the result of the branch instruction into the program counter .

Typically an instruction fetch unit is employed to fetch instructions on behalf of the processor . The fetch unit either fetches next sequential instructions target instructions of branch taken instructions or first instructions of a program following a context switch. Modern Instruction fetch units often employ prefetch techniques to speculatively prefetch instructions based on the likelihood that the prefetched instructions might be used. For example a fetch unit may fetch 16 bytes of instruction that includes the next sequential instruction and additional bytes of further sequential instructions.

The fetched instructions are then executed by the processor . In an embodiment the fetched instruction s are passed to a dispatch unit of the fetch unit. The dispatch unit decodes the instruction s and forwards information about the decoded instruction s to appropriate units . An execution unit will typically receive information about decoded arithmetic instructions from the instruction fetch unit and will perform arithmetic operations on operands according to the opcode of the instruction. Operands are provided to the execution unit preferably either from memory architected registers or from an immediate field of the instruction being executed. Results of the execution when stored are stored either in memory registers or in other machine hardware such as control registers PSW registers and the like .

Virtual addresses are transformed into real addresses using dynamic address translation and optionally using access register translation .

A processor typically has one or more units for executing the function of the instruction. Referring to an execution unit may communicate with architected general registers a decode dispatch unit a load store unit and other processor units by way of interfacing logic . An execution unit may employ several register circuits to hold information that the arithmetic logic unit ALU will operate on. The ALU performs arithmetic operations such as add subtract multiply and divide as well as logical function such as and or and exclusive or XOR rotate and shift. Preferably the ALU supports specialized operations that are design dependent. Other circuits may provide other architected facilities including condition codes and recovery support logic for example. Typically the result of an ALU operation is held in an output register circuit which can forward the result to a variety of other processing functions. There are many arrangements of processor units the present description is only intended to provide a representative understanding of one embodiment.

An ADD instruction for example would be executed in an execution unit having arithmetic and logical functionality while a floating point instruction for example would be executed in a floating point execution having specialized floating point capability. Preferably an execution unit operates on operands identified by an instruction by performing an opcode defined function on the operands. For example an ADD instruction may be executed by an execution unit on operands found in two registers identified by register fields of the instruction.

The execution unit performs the arithmetic addition on two operands and stores the result in a third operand where the third operand may be a third register or one of the two source registers. The execution unit preferably utilizes an Arithmetic Logic Unit ALU that is capable of performing a variety of logical functions such as Shift Rotate And Or and XOR as well as a variety of algebraic functions including any of add subtract multiply divide. Some ALUs are designed for scalar operations and some for floating point. Data may be Big Endian where the least significant byte is at the highest byte address or Little Endian where the least significant byte is at the lowest byte address depending on architecture. The IBM z Architecture is Big Endian. Signed fields may be sign and magnitude 1 s complement or 2 s complement depending on architecture. A 2 s complement number is advantageous in that the ALU does not need to design a subtract capability since either a negative value or a positive value in 2 s complement requires only an addition within the ALU. Numbers are commonly described in shorthand where a 12 bit field defines an address of a 4 096 byte block and is commonly described as a 4 Kbyte Kilo byte block for example.

Referring to branch instruction information for executing a branch instruction is typically sent to a branch unit which often employs a branch prediction algorithm such as a branch history table to predict the outcome of the branch before other conditional operations are complete. The target of the current branch instruction will be fetched and speculatively executed before the conditional operations are complete. When the conditional operations are completed the speculatively executed branch instructions are either completed or discarded based on the conditions of the conditional operation and the speculated outcome. A typical branch instruction may test condition codes and branch to a target address if the condition codes meet the branch requirement of the branch instruction a target address may be calculated based on several numbers including ones found in register fields or an immediate field of the instruction for example. The branch unit may employ an ALU having a plurality of input register circuits and an output register circuit . The branch unit may communicate with general registers decode dispatch unit or other circuits for example.

The execution of a group of instructions can be interrupted for a variety of reasons including a context switch initiated by an operating system a program exception or error causing a context switch an I O interruption signal causing a context switch or multi threading activity of a plurality of programs in a multi threaded environment for example. Preferably a context switch action saves state information about a currently executing program and then loads state information about another program being invoked. State information may be saved in hardware registers or in memory for example. State information preferably comprises a program counter value pointing to a next instruction to be executed condition codes memory translation information and architected register content. A context switch activity can be exercised by hardware circuits application programs operating system programs or firmware code microcode pico code or licensed internal code LIC alone or in combination.

A processor accesses operands according to instruction defined methods. The instruction may provide an immediate operand using the value of a portion of the instruction may provide one or more register fields explicitly pointing to either general purpose registers or special purpose registers floating point registers for example . The instruction may utilize implied registers identified by an opcode field as operands. The instruction may utilize memory locations for operands. A memory location of an operand may be provided by a register an immediate field or a combination of registers and immediate field as exemplified by the z Architecture long displacement facility wherein the instruction defines a base register an index register and an immediate field displacement field that are added together to provide the address of the operand in memory for example. Location herein typically implies a location in main memory main storage unless otherwise indicated.

Referring to a processor accesses storage using a load store unit . The load store unit may perform a load operation by obtaining the address of the target operand in memory and loading the operand in a register or another memory location or may perform a store operation by obtaining the address of the target operand in memory and storing data obtained from a register or another memory location in the target operand location in memory . The load store unit may be speculative and may access memory in a sequence that is out of order relative to instruction sequence however the load store unit is to maintain the appearance to programs that instructions were executed in order. A load store unit may communicate with general registers decode dispatch unit cache memory interface or other elements and comprises various register circuits and ALUs and control logic to calculate storage addresses and to provide pipeline sequencing to keep operations in order. Some operations may be out of order but the load store unit provides functionality to make the out of order operations to appear to the program as having been performed in order as is well known in the art.

Preferably addresses that an application program sees are often referred to as virtual addresses. Virtual addresses are sometimes referred to as logical addresses and effective addresses . These virtual addresses are virtual in that they are redirected to physical memory location by one of a variety of dynamic address translation DAT technologies including but not limited to simply prefixing a virtual address with an offset value translating the virtual address via one or more translation tables the translation tables preferably comprising at least a segment table and a page table alone or in combination preferably the segment table having an entry pointing to the page table. In the z Architecture a hierarchy of translation is provided including a region first table a region second table a region third table a segment table and an optional page table. The performance of the address translation is often improved by utilizing a translation lookaside buffer TLB which comprises entries mapping a virtual address to an associated physical memory location. The entries are created when the DAT translates a virtual address using the translation tables. Subsequent use of the virtual address can then utilize the entry of the fast TLB rather than the slow sequential translation table accesses. TLB content may be managed by a variety of replacement algorithms including LRU Least Recently used .

In the case where the processor is a processor of a multi processor system each processor has responsibility to keep shared resources such as I O caches TLBs and memory interlocked for coherency. Typically snoop technologies will be utilized in maintaining cache coherency. In a snoop environment each cache line may be marked as being in any one of a shared state an exclusive state a changed state an invalid state and the like in order to facilitate sharing.

I O units provide the processor with means for attaching to peripheral devices including tape disc printers displays and networks for example. I O units are often presented to the computer program by software drivers. In mainframes such as the System z from IBM channel adapters and open system adapters are I O units of the mainframe that provide the communications between the operating system and peripheral devices.

Further other types of computing environments can benefit from one or more aspects. As an example an environment may include an emulator e.g. software or other emulation mechanisms in which a particular architecture including for instance instruction execution architected functions such as address translation and architected registers or a subset thereof is emulated e.g. on a native computer system having a processor and memory . In such an environment one or more emulation functions of the emulator can implement one or more embodiments even though a computer executing the emulator may have a different architecture than the capabilities being emulated. As one example in emulation mode the specific instruction or operation being emulated is decoded and an appropriate emulation function is built to implement the individual instruction or operation.

In an emulation environment a host computer includes for instance a memory to store instructions and data an instruction fetch unit to fetch instructions from memory and to optionally provide local buffering for the fetched instruction an instruction decode unit to receive the fetched instructions and to determine the type of instructions that have been fetched and an instruction execution unit to execute the instructions. Execution may include loading data into a register from memory storing data back to memory from a register or performing some type of arithmetic or logical operation as determined by the decode unit. In one example each unit is implemented in software. For instance the operations being performed by the units are implemented as one or more subroutines within emulator software.

More particularly in a mainframe architected machine instructions are used by programmers usually today C programmers often by way of a compiler application. These instructions stored in the storage medium may be executed natively in a z Architecture IBM Server or alternatively in machines executing other architectures. They can be emulated in the existing and in future IBM mainframe servers and on other machines of IBM e.g. Power Systems servers and System x Servers . They can be executed in machines running Linux on a wide variety of machines using hardware manufactured by IBM Intel AMD and others. Besides execution on that hardware under a z Architecture Linux can be used as well as machines which use emulation by Hercules UMX or FSI Fundamental Software Inc where generally execution is in an emulation mode. In emulation mode emulation software is executed by a native processor to emulate the architecture of an emulated processor.

The native processor typically executes emulation software comprising either firmware or a native operating system to perform emulation of the emulated processor. The emulation software is responsible for fetching and executing instructions of the emulated processor architecture. The emulation software maintains an emulated program counter to keep track of instruction boundaries. The emulation software may fetch one or more emulated machine instructions at a time and convert the one or more emulated machine instructions to a corresponding group of native machine instructions for execution by the native processor. These converted instructions may be cached such that a faster conversion can be accomplished. Notwithstanding the emulation software is to maintain the architecture rules of the emulated processor architecture so as to assure operating systems and applications written for the emulated processor operate correctly. Furthermore the emulation software is to provide resources identified by the emulated processor architecture including but not limited to control registers general purpose registers floating point registers dynamic address translation function including segment tables and page tables for example interrupt mechanisms context switch mechanisms Time of Day TOD clocks and architected interfaces to I O subsystems such that an operating system or an application program designed to run on the emulated processor can be run on the native processor having the emulation software.

A specific instruction being emulated is decoded and a subroutine is called to perform the function of the individual instruction. An emulation software function emulating a function of an emulated processor is implemented for example in a C subroutine or driver or some other method of providing a driver for the specific hardware as will be within the skill of those in the art after understanding the description of the preferred embodiment. Various software and hardware emulation patents including but not limited to U.S. Pat. No. 5 551 013 entitled Multiprocessor for Hardware Emulation by Beausoleil et al. and U.S. Pat. No. 6 009 261 entitled Preprocessing of Stored Target Routines for Emulating Incompatible Instructions on a Target Processor by Scalzi et al and U.S. Pat. No. 5 574 873 entitled Decoding Guest Instruction to Directly Access Emulation Routines that Emulate the Guest Instructions by Davidian et al and U.S. Pat. No. 6 308 255 entitled Symmetrical Multiprocessing Bus and Chipset Used for Coprocessor Support Allowing Non Native Code to Run in a System by Gorishek et al and U.S. Pat. No. 6 463 582 entitled Dynamic Optimizing Object Code Translator for Architecture Emulation and Dynamic Optimizing Object Code Translation Method by Lethin et al and U.S. Pat. No. 5 790 825 entitled Method for Emulating Guest Instructions on a Host Computer Through Dynamic Recompilation of Host Instructions by Eric Traut each of which is hereby incorporated herein by reference in its entirety and many others illustrate a variety of known ways to achieve emulation of an instruction format architected for a different machine for a target machine available to those skilled in the art.

In an example of an emulated host computer system is provided that emulates a host computer system of a host architecture. In the emulated host computer system the host processor CPU is an emulated host processor or virtual host processor and comprises an emulation processor having a different native instruction set architecture than that of the processor of the host computer . The emulated host computer system has memory accessible to the emulation processor . In the example embodiment the memory is partitioned into a host computer memory portion and an emulation routines portion. The host computer memory is available to programs of the emulated host computer according to host computer architecture. The emulation processor executes native instructions of an architected instruction set of an architecture other than that of the emulated processor the native instructions obtained from emulation routines memory and may access a host instruction for execution from a program in host computer memory by employing one or more instruction s obtained in a sequence access decode routine which may decode the host instruction s accessed to determine a native instruction execution routine for emulating the function of the host instruction accessed. Other facilities that are defined for the host computer system architecture may be emulated by architected facilities routines including such facilities as general purpose registers control registers dynamic address translation and I O subsystem support and processor cache for example. The emulation routines may also take advantage of functions available in the emulation processor such as general registers and dynamic translation of virtual addresses to improve performance of the emulation routines. Special hardware and off load engines may also be provided to assist the processor in emulating the function of the host computer .

The terminology used herein is for the purpose of describing particular embodiments only and is not intended to be limiting. As used herein the singular forms a an and the are intended to include the plural forms as well unless the context clearly indicates otherwise. It will be further understood that the terms comprises and or comprising when used in this specification specify the presence of stated features integers steps operations elements and or components but do not preclude the presence or addition of one or more other features integers steps operations elements components and or groups thereof.

The corresponding structures materials acts and equivalents of all means or step plus function elements in the claims below if any are intended to include any structure material or act for performing the function in combination with other claimed elements as specifically claimed. The description of one or more embodiments has been presented for purposes of illustration and description but is not intended to be exhaustive or limited to the form disclosed. Many modifications and variations will be apparent to those of ordinary skill in the art. The embodiment was chosen and described in order to best explain various aspects and the practical application and to enable others of ordinary skill in the art to understand various embodiments with various modifications as are suited to the particular use contemplated.

