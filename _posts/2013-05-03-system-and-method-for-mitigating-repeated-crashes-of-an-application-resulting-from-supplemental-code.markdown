---

title: System and method for mitigating repeated crashes of an application resulting from supplemental code
abstract: Provided is a method for mitigating the effects of an application which crashes as the result of supplemental code (e.g., plug-in), particularly a plug-in from a source other than the source of the operating system of the device or the source of the application that crashes. The method includes executing the application. As the application is running, it may be monitored to determine if normal execution of instructions ceases. When that occurs, the system will make a determination if code from a supplemental code module was the cause of the crash, and will make an evaluation if that supplemental code module is from a source other than the source(s) of the operating system and application in question. In some implementations, remedial steps may be provided, such as providing information on subsequent executions of the application.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08930915&OS=08930915&RS=08930915
owner: Apple Inc.
number: 08930915
owner_city: Cupertino
owner_country: US
publication_date: 20130503
---
This application is a continuation and claims the benefit of priority under 35 U.S.C. 120 of U.S. patent application Ser. No. 13 205 827 filed Aug. 9 2011 now allowed which is a divisional of U.S. patent application Ser. No. 11 462 641 filed on Aug. 4 2006 now U.S. Pat. No. 8 020 149 issued Sep. 13 2011. Both of these prior applications are incorporated by reference herein in their entirety.

The present application relates generally to computer programs. More specifically example embodiments are directed to a system method and machine readable medium for mitigating repeated crashes of an application resulting from supplemental code e.g. plug ins utilized by the application.

A modern general purpose computer system uses an operating system OS to manage the hardware and software resources of the computer. The OS is a software program that performs basic tasks such as controlling and allocating memory prioritizing the processing of instructions controlling input and output devices facilitating networking and managing files. The OS also provides application program interfaces APIs or interfaces to enable the application programs applications to interact with the hardware and software resources as well as with other application programs.

An application as well as one or more libraries which are linked either statically or dynamically to the application may use supplemental code e.g. plug ins to perform certain functionality that the application and the libraries have not been programmed to perform. A plug in is a code module that is not part of the application or library but which can be accessed by the application or library to extend its respective functionality. Although a variety of different plug ins exist a typical example may include a plug in that provides display capabilities for a certain graphics format that a web browsing application does not support natively. The application typically provides a way for a plug in to register with the application and the application and the plug in provide respective interfaces via which data is exchanged between the application and the plug in. Other types of supplemental code are also possible.

The circumstance and terminology of an application crashing is well known to those familiar with computers and with the art of computer programming. As used herein the term crash will refer to any instance in which the execution of the application is halted abnormally whether as a result of the application freezing or as a result of the application aborting. In such cases an application will unexpectedly not in response to system or user control cease normal execution of its instructions.

The aforementioned variety of plug ins may be provided by different developers. More specifically plug ins may be provided by the OS developer the application developer or any other third party developer. Although it is possible that plug ins provided by the OS developer and by the application developer may cause the application to crash the more typical case arises when a crash of the application is caused by a plug in of a third party developer e.g. developer other than the OS developer and application developer . This occurs in part because the OS developer and the application developer cannot typically test the OS or the application against all third party plug ins. For example an application crash may be caused because the third party authored plug ins may use application program interfaces APIs that are not authorized or documented by the developer of the application or by the developer of the OS and these unauthorized or undocumented APIs may behave differently in newer versions of the OS or application. Similarly an application may inadvertently rely on undocumented or unsupported APIs in a plug in and newer versions of that plug in may remove or change these APIs in such a way that may cause an application crash. It is also noted that generic programming errors in the plug in may also cause the application to crash.

In such circumstances determination of which plug in has caused the application to crash is important in order for a user to take appropriate corrective action. Certain applications e.g. crash reporters exist which provide the user with a description of why the application has crashed. However it is often difficult for most users to determine information from crash reporters. In particular it is typically difficult for the user to determine whether the application has crashed because of a plug in and if so to identify the offending plug in. Furthermore it is often difficult for the user to take appropriate corrective action to make sure that the application does not crash again.

Embodiments described herein enable a determination of whether an application crash was caused in part by a supplemental code module e.g. plug in to the application from a source other than the source of the application and or a source other than the source of the operating system. When a supplemental code module is determined to be from a source other than the source of the application and the source of the operating system of the computing device on which the supplemental code module is installed it is characterized as being of third party origin. As will be apparent to those skilled in the art a determination of a status such as third party origin or an event such as a cause of an application crash as referenced herein does not necessarily represent a determination with precise accuracy. The precise cause or causes of a crash for example may or may not be discernable. Thus a determination as used herein such as of a status or event encompasses an estimated or a probable conclusion as to matter at issue.

Once such a determination is made the system may undertake mitigating steps or it may interact with the user to determine what steps if any to take on subsequent executions of the application. In selected embodiments when an application crash occurs the system will examine code modules accessed by addresses in a call stack and will determine if one or more code modules is from a source other than the source of the application and or from a source other than the source of the operating system. As described herein the method may be implemented with existing applications which are not aware of the crash determinations as described in selected embodiments herein. However applications may also be customized such as to initiate new API calls to improve the effectiveness of the determinations by using the methods described herein.

As an example of one selected embodiment there is provided a method for deciding whether to load one or more supplemental code modules into an application the method including executing the application and determining whether the application has crashed since its last execution because of a third party supplemental code module. In one implementation the method will also cause a user interface to be presented to a user in response to that determination. For example such a user interface may identify the third party supplemental code module which was determined to be responsible for crashing the application and in some implementations may query the user in relation to taking one or more possible actions or no action. The user s input may be received in response to the query and one or more actions may be selectively performed such as for example uninstalling disabling or loading of the third party supplemental code module in accordance with the user s input.

As an example of one system in accordance with the present invention there is provided a system for deciding whether to load one or more supplemental code modules into an application. In one implementation the system includes an operating system adapted to execute the application a crash determination module adapted to determine whether the application has crashed since its last execution because of a third party supplemental code module. The system may optionally further include an application presentation module adapted to present a user interface to a user as discussed above.

Further embodiments include a machine readable medium including a set of instructions executable by the machine for performing the methods disclosed herein such as the example identified above.

Mitigation of repeated crashes failures of an application resulting from third party code e.g. plug ins is described. In the following description for the purposes of explanation numerous specific details are set forth in order to provide a thorough understanding of example embodiments. It will be evident however to one skilled in the art that an example embodiment may be practiced without these specific details.

Example embodiments described herein include systems methods and a machine readable mediums for mitigating repeated crashes of an application resulting from third party code e.g. plug ins .

The system of includes a general purpose computer system on which an operating system OS may be loaded at start or boot time of the computer system . The OS may include Mac OS X Windows XP Linux and UNIX as well as any other operating system not explicitly enumerated herein that facilitates the subject matter described herein. Within the OS a crash reporting application e.g. Crash Reporter in Mac OS X may be executed or instantiated for reporting to a user a probable cause of a crash of the application as will be described herein below with reference to .

Furthermore within the OS an application may be executed which may load supplemental code for example supplemental code A . Although only supplemental code A is described for brevity and clarity the application may load a variety of different supplemental code e.g. multiple plug ins . The application may link to an application library and may execute one or more functions from the application library . Just like the application the application library may also load supplemental code for example supplemental code B . Although only supplemental code B is described for brevity and clarity the application library may load a variety of different supplemental code e.g. multiple plug ins . Furthermore although only one application library is described for brevity and clarity the application may link to a plurality of libraries with each library capable of loading a variety of different supplemental code. The application library may be a statically linked library linked at compilation time or a dynamically linked library linked at runtime .

Further with reference to the supplemental code loading module may load supplemental code A e.g. a plug in into the application and the application may execute one or more functions therefrom to extend its built in functionality. Similarly the supplemental code loading module may load supplemental code B e.g. a plug in into the application library which is linked to the application and the application library may execute one or more functions from supplemental code B to extend its built in functionality.

Once loaded communication between the application and supplemental code A may be accomplished via application programming interface API and communication between application library and supplemental code B may likewise be accomplished via API . For the purposes of the description of the embodiments herein it should be understood that supplemental code A and or supplemental code B may cause the application to crash upon loading or upon communication between the application or application library and the respective supplemental code . Other components of the application and the application library will be described in greater detail later herein with reference to .

Yet further with reference to the crash detection module of the crash reporting application is adapted to detect if the application that is executed within the OS crashes and is further adapted to generate a crash report for the application . The crash report includes state information relating to the application as will be described in greater detail herein below with reference to . More specifically in some implementations the OS will monitor to recognize if an application has crashed. Upon a crash of the application the crash detection module of the crash reporting application receives notification from the OS that the application has crashed and generates the crash report that includes a list of modules that the application loaded during execution including an address range where each module was loaded and a backtrace of stack frames instantiated during execution of the application including an address for each frame.

The crash detection module is connected to the probable crash cause decision module which is invoked by the crash detection module upon detecting a crash of the application . The probable crash cause decision module determines a probable cause of a crash of the application . More specifically the probable crash cause decision module determines 1 which code module is likely to have been a cause of the crash of the application and 2 whether that code module is a supplemental code module produced by a third party developer. The probable crash cause decision module is connected to a presentation module that presents to a user the probable cause of the crash of the application as determined by the probable crash cause decision module .

Still further with reference to the probable crash cause decision module stores an entry related to the probable cause of the crash of the application determined by the probable crash cause decision module into a crash information data store . Crash information data store may be queried by the application upon restarting. The probable crash cause decision module is also connected to a supplemental code origin determination module and to a hints storage .

Supplemental code origin determination module will determine a developer of the supplemental code module that was a probable cause of the crash of the application . The application origin determination module will determine whether the source of the application is the same as either the source of the OS or the source of the application .

Additionally in some implementations an application may be particularly configured for use in embodiments as described herein and to be aware of the crash cause identification capability. In such embodiments hints storage also connected to the probable crash cause decision module may provide one or more hints to aid the probable crash cause decision module in determining the source of a supplemental code module determined to be a cause of a crash relative to the sources of the OS and the application . Such a hint may include a descriptive name for the determined supplemental code module. Hints storage may also provide a hint such as source related information provided by the hint module of the supplemental code loading module upon loading of supplemental code e.g. supplemental code A .

The crash reporting application includes a crash reporting application API providing an interface to the application and the application library . Such crash reporting application API will typically be used by an application provided with functionality to be aware of the crash identification capability as described herein in reference to crash reporting application . Again in some embodiments in which an application and or application library are aware of the crash identification functionality the crash reporting application API provides a path for querying the crash information data store upon an execution of the application to determine whether the application crashed previously. Lastly the crash reporting application also includes a supplemental code hints API providing an interface to the hint module of the code loading module and the hint module of the supplemental code loading module to establish an interface by which to provide hints about supplemental code modules that are loaded as described earlier herein.

Now further with reference to the application in upon execution of the application within the OS the crash determination module determines whether the application has previously crashed. The crash determination module is connected to the restart history data store and may query the crash information data store via the crash reporting application API . For example upon execution of the application the crash determination module may query the crash information data store to determine the date and time that the application crashed previously and may query the restart history data store to determine the date and time of the previous execution of the application . The crash determination module may then compare the dates times to determine whether the crash occurred after the previous execution of the application.

The crash determination module is further connected to a response determination module adapted to determine a response to the cause of a crash of the application via the presentation module . It is possible that a response may be made automatically by the response determination module . However in some implementations the presentation module will present the cause of the crash e.g. a supplemental code module name causing the crash and query the user as to an action to be taken if any. For example the user may be presented with a user interface and queried whether the user would like to 1 load the offending supplemental code module 2 to disable the supplemental code module from loading for this execution of the application or 3 to uninstall the supplemental code module to prevent it from ever loading into the application . The response determination module is also connected to the supplemental code loading module . Therefore based on user selection the supplemental code loading module may load disable or uninstall the offending supplemental code module e.g. supplemental code module A which has caused the application to crash. If the crash determination module determines that there was no prior crash of the application or that a crash did not occur after the prior execution time and date of the application or the response determination module determines to load the offending supplemental code module the supplemental code loading module may load the supplemental code modules including the offending supplemental code module in a normal fashion.

Lastly with reference to it is noted that the application library which may be linked to the application may also load supplemental code e.g. supplemental code B . Components of the application library correspond to similarly named components of the application . Consequently these components will not be described in detail herein instead the description of components is referred to for a description of the relative functionality of component .

The depicted method starts at operation upon being invoked by the crash detection module after receiving notification that the application has crashed. At operation a backtrace and a list of code modules is received from the crash detection module . The list of code modules and the backtrace may be provided in a crash report e.g. crash report in generated by the crash detection module after a crash of an application or may be provided in any other fashion such as by using data structures or objects that include the code module and the backtrace. At operation a third party code TPC counter is initialized to zero for each code module in the list. A frame is retrieved from the backtrace at operation and at operation an address associated with the frame is determined. At operation the address of the frame is used to find a start address of a code module in the list of code modules that includes the address of the frame in an address range of the code module e.g. from a start address to an end address . At operation an origin of the code module is determined using the start address. More particularly operation is performed by supplemental code origin determination module which is described with reference to the flowchart in later herein. At this point it is sufficient to describe that operation sets a code module origin flag for the code module which identifies whether the code module was provided by a developer of the OS by a developer of the application or by a third party developer e.g. not the OS developer or the application developer . It is noted that any sort of flag may be used for this purpose e.g. numeric flag string flag or any other flag .

Further with reference to at operation it is determined whether the code module origin flag from operation is set to identify a third party developer. If it is determined that the code module is not by a third party developer the method continues at operation in which the method increments to a next frame in the backtrace. At operation it is further determined whether a predetermined frame number was reached. More specifically the predetermined frame number depends on a particular implementation and may be represent any predetermined number of frames e.g. 10 frames which may be in the backtrace provide by the crash detection module . If the predetermined number has not been reached at operation the method continues at operation in which a next frame from the backtrace is retrieved. Alternatively if the predetermined number has been reached at operation the method continues at operation in which name of the code module is set to null. At operation a path of the application is retrieved. The path may be retrieved from the crash report e.g. crash report in generated by the crash detection module . Thereafter at operation an entry is recorded in the crash information data store including the path of the application the code module name null a code module origin flag of Not Third Party Code and a date time stamp. At operation a user interface is presented to a user identifying the cause of the crash of the application . More specifically as the cause of the crash was caused either by the developer of the OS or by the developer of the application the user interface may present to the user that the application quit unexpectedly and may further direct the user to contact the developer of the OS or of the application for further assistance. An example user interface will be described hereinafter in reference to .

Now further with reference to operation of if it is determined that the code module is by a third party developer the method continues at operation in which the third party code TPC counter is incremented for the module determined at operation . At operation it is further determined whether the TPC counter has reached a predetermined number. The predetermined number depends upon a particular implementation but may be one or greater e.g. one three and the like but less than or equal to the predetermined number in operation . If it is determined at operation that TPC counter for the module does not equal the predetermined number the method continues at operation in which the method increments to a next frame.

Alternatively if the TPC counter for the module is equivalent to the predetermined number the method continues at step in which a hint is checked in hints storage for a descriptive name of the determined code module using its address. An example hint will be described in greater detail hereinafter in reference to . As noted in reference to the availability of such hints will in most embodiments be dependent upon the application in questions having been enabled to be aware of crash identification functionality of the crash reporting application though many embodiments may be practiced without such application awareness. 

At operation it is determined whether the descriptive name is null. If descriptive name is determined to be null the method continues at operation in which the name of the code module is retrieved from the list of code modules. If the descriptive name is not null the method continues at operation in which the descriptive name of the code module is retrieved from the hint. In either case the method continues at operation in which the path of the application is retrieved. The path may be retrieved from the crash report e.g. crash report in generated by the crash detection module . At operation an entry is recorded in the crash information data store including the path of the application the code module name from operation or a descriptive name from operation a code module origin flag of Third Party Code and a date time stamp. Finally at operation a user interface is presented to a user identifying the cause of the crash of the application . More specifically a supplemental code module having code module name or descriptive name is identified as the cause of the crash of the application in operation . An example user interface will be described hereinafter with reference to .

Further with reference to if at operation it is determined that the code module origin flag is null the method continues at operation in which a descriptive attribute for the code module is retrieved using the address of the code module. A descriptive attribute may be retrieved by any of several measures as may be contemplated by those of skill in the art for example a by querying the OS using the address of the code module b by examining structures stored in memory within the code module s address range c by querying the OS for a path from which the code module was loaded and reading a descriptive attribute from resources associated with the path from which the code module was loaded or d using the path from which the code module was loaded as a descriptive attribute. A descriptive attribute may be one or more of many types of attributes including for example a cryptographic signature or a hash code a developer string or numeric code a globally unique identification GUID a copyright string a recognizable symbolic name for a memory address or a function within the code module as well as any other descriptive attribute that describes the code module. At operation the origin of the application is determined using its path. Operation is performed by the application origin determination module the method of which is described in flowchart of and which returns an application origin flag. The application origin flag returned may be set to OS developer or Application Developer. At operation it is determined whether the application is by an OS developer and if so at operation a descriptive attribute corresponding to descriptive attribute for the code module is retrieved for the OS . This may be accomplished by a call to the OS . The descriptive attribute for the code module is compared to the descriptive attribute for the OS . At operation it is determined whether the attributes match. If there is a match of the attributes then at operation the code module origin flag is set to OS Developer. If at operation there is no match then at operation the code module origin flag is set to Third Party Developer. 

Yet further with reference to and now referring back to operation if it is determined that the application is not by OS Developer the method continues at operation in which a corresponding descriptive attribute is retrieved for the application using its path. The descriptive attribute may be retrieved by querying the OS using the path of the application by examining data structures stored within the application s memory by querying the OS for the path from which the application was loaded and then reading the attribute from resources associated with the path from which the application was loaded. At operation the descriptive attribute for the code module is compared to the descriptive attribute for the application. At operation it is determined whether the descriptive attributes match. If there is a match of the attributes then at operation the code module origin flag is set to Application Developer. Alternatively if there is no match at operation then the method continues at operation in which a descriptive attribute corresponding to the descriptive attribute for the code module is retrieved for the OS . Once the code module origin flag has been set at operations and or provided from operation method continues at operation in which the code module origin flag is returned. The method ends at operation .

Now referring back to operation of if the application was loaded before at operation the last date and time of the execution is retrieved from the restart history data store . A sample entry in restart history data store is illustrated in herein below. At operation an entry is retrieved from crash information data store of the most recent application crash using the application s path. An entry in the crash information data store is illustrated in . At operation it is determined whether there was an entry retrieved. If an entry was not retrieved the method continues at operation . Alternatively if an entry was retrieved the method continues at operation in which the date and time of the most recent crash of the application are retrieved from the entry from crash information data store . The date and time of the last execution of the application are compared to the date and time of the last crash of the application . At operation it is determined whether the crash of the application occurred after the last execution of the application. If the application crashed after its last execution at operation the current date and time are retrieved. This may be accomplished by a call to the OS or in any other fashion. At operation an entry having the current date and time is recorded in the restart history data store . At operation the response to the crash is determined. The determination of the response to the crash is described with reference to method in herein below.

Now referring back to operation of if the crash of the application did not occur after the last execution of the application the method continues at operation in which the current date and time are retrieved. At operation an entry having the current date and time is recorded in the restart history data store . As already described above a do not load DNL flag is set to null and uninstall flag is set to false at operation . At operation supplemental code modules are loaded using the DNL flag and uninstall flag. The loading of supplemental code modules will be described with reference to flowchart in herein below.

Now referring back to operation of if the number of occurrences of the code module name from the most recent entry is greater or equal to the predetermined threshold the method continues at operation in which a user interface is presented to a user including a suggestion to contact the developer of the supplemental code module having the code module name. Additionally as described previously a query may be presented to the user as to whether the user would like to take one or more possible actions relative to the identified code module. These actions may include uninstalling disabling or loading the code module having the code module name. An example user interface will be described hereinafter in reference to . User selection is received in response to the presented query at operation . At operation the user selection is determined. More specifically if the user selection is to uninstall the code module the method continues at operation in which the DNL name is set to the code module name and the uninstall flag is set to true. If the user selection is to disable the code module the method continues at operation in which the DNL name is set to the code module name and the uninstall flag is set to false. If the user selection is to load the code module the method continues at operation in which the DNL name is set to null and the uninstall flag is set to false. From any of the operations or the method continues at operation at which supplemental code modules are loaded using the DNL flag and uninstall flag. Thereafter the method ends at operation .

Further with reference to at operation the supplemental code modules in the list are loaded into the application . At operation a hint is generated for a supplemental code module in the list a first code module using the address into which the code module was loaded. At operation it is determined whether the supplemental code module was produced by the developer of the application . The developer information may be obtained from the application or the supplemental code module may be queried and may return this information. More specifically developer information may be obtained using APIs that are part of an interface specification particular to the application and the supplemental code module or by comparing a name or a path of the supplemental code module being loaded to a predetermined list of supplemental code modules provided by the application . If the supplemental code module is produced by the application developer then at operation the code origin module flag is set to Application Developer in the hint generated at operation . If the supplemental code module is not produced by the application developer then at operation it is further determined whether the supplemental code module is from a recognized Third Party Developer. The third party developer may be recognized by using supplemental code APIs that are part of an interface specification particular to the application and the supplemental code module or by comparing a name or path of the supplemental code module being loaded to a predetermined list of common third party supplemental code modules provided by the application . If the supplemental code module is from a recognized third party developer then at operation the code origin module flag is set to Third Party Developer in the hint generated at operation . If the supplemental code module is not from a recognized third party developer then at operation the code origin module flag is set to null in the hint generated at operation .

Still further with reference to from any of the operations and the method continues at operation at which it is determined whether a descriptive name is available for the supplemental code module. The descriptive name may be predefined in the application for the supplemental code module or the supplemental code module may be queried to obtain a descriptive name using APIs that are part of an interface specification particular to this application and its supplemental code module. If the descriptive name is not available at operation the descriptive name of supplemental code module in the hint is set to null. Alternatively if the descriptive name is available the descriptive name of supplemental code module is retrieved at operation and at operation the descriptive name of supplemental code module in the hint is set to the retrieved descriptive name. Thereafter from any of the operations and the method continues at operation at which the hint is transmitted to hints storage of the crash reporting application for storage and later use by the modules and of the crash reporting application . At operation the method increments to the next supplemental code module in the list of supplemental code modules. At operation it is further determined whether it was the last supplemental code module. If the last supplemental code module in the list of supplemental code modules was processed then the method ends at operation . Alternatively if there is a next supplemental code module in the list the method continues at operation to process that supplemental code module in order to generate a hint.

Further with reference to the backtrace section includes frames which represent memory addresses or memory locations on a call stack during execution of the application and before the crash of the application . Generally the call stack is implemented on a last in first out LIFO basis. That is frame may represent an entry point to application code of the application at execution of the application . It is noted that the address or memory location is within entry . As represented in frame the address or memory location of is also within entry and may represent execution of a function in the application code. As represented in frame the address or memory location of is within entry and may represent a function executed in the application library . As represented in frame the address or memory location of is within entry and may represent a function executed in a third party supplemental code B by the application library . Lastly as represented in frame the address or memory location of is within entry and may represent the address of a last instruction executed in the third party supplemental code B by the application library . The third party supplemental code B called by the application library may represent the offending supplemental code module that may have cause the crash of the application in accordance with .

Further with reference to the example computer system includes a processor e.g. a central processing unit CPU a graphics processing unit GPU or both a main memory and a static memory which communicate with each other via a bus . The computer system may further include a video display unit e.g. a liquid crystal display LCD or a cathode ray tube CRT . The computer system also includes an alphanumeric input device e.g. a keyboard a user interface UI navigation device e.g. a mouse a disk drive unit a signal generation device e.g. a speaker and a network interface device .

Still further with reference to the disk drive unit includes a machine readable medium on which is stored one or more sets of instructions and data structures e.g. software embodying or utilized by any one or more of the methodologies or functions described herein. The software may also reside completely or at least partially within the main memory and or within the processor during execution thereof by the computer system the main memory and the processor also constituting machine readable media. The software may further be transmitted or received over a network via the network interface device utilizing any one of a number of well known transfer protocols e.g. HTTP .

Lastly with reference to while the machine readable medium is shown in the example embodiment to be a single medium the term machine readable medium should be taken to include a single medium or multiple media e.g. a centralized or distributed database and or associated caches and servers that store the one or more sets of instructions. The term machine readable medium shall also be taken to include any medium that is capable of storing encoding or carrying a set of instructions for execution by the machine and that cause the machine to perform any one or more of the methodologies of an example embodiment or that is capable of storing encoding or carrying data structures utilized by or associated with such a set of instructions. The term machine readable medium shall accordingly be taken to include but not be limited to solid state memories optical and magnetic media and carrier wave signals.

Thus a method a system and a machine readable medium for mitigating repeated crashes of an application resulting from supplemental code e.g. plug ins utilized by the application have been described. Although specific example embodiments have been described it will be evident that various modifications and changes may be made to these embodiments without departing from the broader spirit and scope of the invention. Accordingly the specification and drawings are to be regarded in an illustrative rather than a restrictive sense. The accompanying drawings that form a part hereof show by way of illustration and not of limitation specific embodiments in which the subject matter may be practiced. The embodiments illustrated are described in sufficient detail to enable those skilled in the art to practice the teachings disclosed herein. Other embodiments may be utilized and derived therefrom such that structural and logical substitutions and changes may be made without departing from the scope of this disclosure. This Detailed Description therefore is not to be taken in a limiting sense and the scope of various embodiments is defined only by the appended claims along with the full range of equivalents to which such claims are entitled.

Such embodiments of the inventive subject matter may be referred to herein individually and or collectively by the term invention merely for convenience and without intending to voluntarily limit the scope of this application to any single invention or inventive concept if more than one is in fact disclosed. Thus although specific embodiments have been illustrated and described herein it should be appreciated that any arrangement calculated to achieve the same purpose may be substituted for the specific embodiments shown. This disclosure is intended to cover any and all adaptations or variations of various embodiments. Combinations of the above embodiments and other embodiments not specifically described herein will be apparent to those of skill in the art upon reviewing the above description.

