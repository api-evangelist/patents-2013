---

title: Managing nodes in a distributed computing environment
abstract: Various embodiments of systems and methods for managing a plurality of nodes in a distributed computing environment are described herein. Initially a request to process a to-be-processed request is received. Next one or more nodes from a plurality of nodes, included in a cluster, is identified to process the to-be-processed request. Next the to-be-processed request is divided into a plurality of sub-requests. Next the plurality of sub-requests are assigned to the identified one or more nodes and the generated additional node. A node failure of one of the one or more identified nodes is identified. Finally, one or more of the plurality of sub-requests assigned to the failed node is re-assigned to another node of the plurality of nodes.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09348709&OS=09348709&RS=09348709
owner: SYBASE, INC.
number: 09348709
owner_city: Dublin
owner_country: US
publication_date: 20131227
---
Cloud computing providers deliver computing infrastructures as a fully outsourced service enabling companies to reduce capital expenditure on hardware software and support services by paying a provider only for what they use. Cloud computing services may be offered at various layers of the software stack. At lower layers Infrastructure as a Service IaaS systems allow users to have access to virtual machines VMs hosted by the provider and the users are responsible for providing the entire software stack running inside a VM. At higher layers Software as a Service SaaS systems offer online applications that can be directly executed by the users. With the increase of clients in cloud based computing the load on various VM nodes providing the cloud computing services may increase manifold.

Embodiments of techniques for managing nodes in a distributed computing environment are described herein. In the following description numerous specific details are set forth to provide a thorough understanding of embodiments of the invention. One skilled in the relevant art will recognize however that the invention can be practiced without one or more of the specific details or with other methods components materials etc. In other instances well known structures materials or operations are not shown or described in detail to avoid obscuring aspects of the invention.

Reference throughout this specification to one embodiment this embodiment and similar phrases means that a particular feature structure or characteristic described in connection with the embodiment is included in at least one embodiment. Thus the appearances of these phrases in various places throughout this specification are not necessarily all referring to the same embodiment. Furthermore the particular features structures or characteristics may be combined in any suitable manner in one or more embodiments.

In one embodiment the cloud computing environment may include a cluster . A cluster may include several nodes that are connected. The nodes in the cluster may include a manager node and several request processing nodes and . In one embodiment the request processing nodes and may include several servers and respectively for processing a request. For example the servers may include an enrollment server for enrolling portable electronic devices to a managed device environment and a package server for serving application packages to portal electronic devices using application policies etc. In one embodiment the nodes and in the cluster are virtual machines VM provided by the Infrastructure as a Service IaaS framework. In other embodiment the nodes and may be physical machines.

The manager node includes several modules for managing the request processing nodes and . In one embodiment the manager node allows scaling up or scaling down of the nodes in the cluster. In one embodiment scaling up includes adding new nodes to the cluster. In one embodiment scaling down includes reducing the number of nodes in the cluster by removing some nodes from the cluster. The manager node also ensures a seamless execution of requests during node failures. The manager node includes several modules for managing the request processing nodes. For example the manager node includes a signal handler that receives signals to increase or decrease the number of nodes in the cluster . The signals may be received based on the different conditions for example user defined signals may be received when a user wants to increase or decrease the number of nodes in the cluster or an external signal may be received to scale up the number of nodes when the memory and network usage based parameters for any of the nodes in the cluster is above a pre determined limit. The signal handler may then forward the request to a cluster controller . The cluster controller then instructs a cloud manager to increase the number of nodes based on the received signal.

In one embodiment a cloud manager communicates with the underlying IaaS framework to create new VM instances. The new VM instances include servers and a node controller to communicate with the manager node . The manager node therefore allows scale up or scale down the number of request processing nodes in the cluster . Further the request processing nodes and include a node controller and respectively that sends node status information to the cluster controller of the manager node . The node status information informs the manager node about the status of the request processing nodes and i.e. whether the request processing nodes and are working properly or have failed. In case the cluster controller identifies a node failure of any of the request processing nodes or then the manager node re distributes the requests that are being processed by the failed node to any other node in the cluster. The request manager therefore ensures a seamless execution of the requests.

In one embodiment the requests may be categorized in different request types. The different request types may include outbound request i.e. requests from the distributed computing environment to any device or system outside the environment or an inbound request i.e. requests from an outside device or system to the distributed computing environment. The different outbound request type may include for example Configuration policies packages session policies simple messages Emails SMS. The different inbound request type may include for example feedback service response device inventory detail etc. The to be processed request may be received at a request manager module included in the manager node. The status of the to be processed request received at the request manager may be new .

In one embodiment the request manager then executes admission control logic to determine whether the received to be processed request can be processed by the request processing nodes. During admission control the request manager identifies whether the received number of to be processed requests is greater than the maximum request limit . The maximum request limit is the maximum number of requests that may be serviced by the different request processing nodes in the cluster at a particular time. When the number of to be processed requests is greater than the maximum request limit then the request manager may identify the maximum request limit number of requests from the received to be processed requests as the to be processed request . In this case the request manager may admit the maximum request limit number of to be processed request for processing. The remaining to be processed requests may be terminated by the request manager. In one embodiment the request manager sends a return code for the requests that were terminated by the request manager. For example consider that 65 enrollment requests is received by the request manager and the maximum number of requests that may be serviced by the request manager is 40 then 40 enrollment requests from the 65 enrollment requests are admitted for processing by the enrollments servers included in the request processing nodes of the cluster. The remaining 25 requests are then terminated and a return code is then sent to a source from where these 25 requests were received.

In one embodiment the request manager may also perform a request validation during the admission control. During the request validation the request manager validates the requests by checking whether the request is well formed etc. The request manager also provides methods to register validation handlers. A validation handler contains code to validate requests for different request types. In one embodiment the validation handlers are then used to validate a request of a particular request type.

Next request processing nodes for processing the to be processed requests is identified. In one embodiment the request manager identifies the to be processed requests based on several node level parameters of the request processing nodes. The node level parameters may include CPU usage cache memory usage network traffic average delay in request processing and cumulative load CL . CPU usage is the amount of actively used virtual CPUs as a percentage of total available CPU. CPU usage is the average CPU utilization over the available virtual CPUs in the virtual machine. For example if a VM with one virtual CPU is running on a host that has four physical CPUs and the CPU usage is 100 the virtual machine is using one physical CPU. A cache memory is a cache used by the central processing unit CPU of a computer to reduce the average time to access memory. The cache is a smaller faster memory which stores copies of the data from frequently used main memory locations. CPUs may have different independent caches including instruction and data caches where the data cache is usually organized as a hierarchy of more cache levels L1 L2 etc. . In one embodiment the cache memory may also include primary memory. Network usage indicates the network resources used by a particular node. In one embodiment the average delay in request processing by a node may be determined based on the following formula 1 where IPTri Ideal processing time for a request type r and PTri Processing time taken by i request of type r and n number of requests received in a pre determined time.

A negative value of for a given request type r indicates that the node is processing data faster than the pre determined ideal processing time. A cumulative load CL of a node is a tuning parameter and provides a way to specify effect of a request on the total load on a node. Cumulative load for a node may be calculated by the following formula CL CPU CPU Cache Cache Network Network Where CL Cumulative load on a given node at time t 

In one embodiment the cumulative load may be determined by another formula e.g. by removing one or more parameters from the formula. To identify the request processing nodes initially a list of request processing node in the cluster is received by the request manager . The request manager then compares the node parameter values CPU Cache and Networkof the node with the pre determined maximum node parameter values CPU usage upper limit primary memory usage upper limit and network traffic usage upper limit respectively . In one embodiment pre determined values of CPU usage upper limit primary memory usage upper limit and network traffic usage upper limit for a particular node type may be provided by an end user. Further the system allows a user to modify these values and during runtime. In case any one of the node parameter values for a particular node is greater than the corresponding pre determined maximum node values then that node is identified as a loaded node and is removed from the list of request processing nodes .

For the remaining request processing nodes in the list a comparison is performed between the cumulative load values of a request processing node in the list with another request processing node in the list . In case the cumulative load of a particular node is lesser than the cumulative load of another node then the particular node and another node are re arranged in the list . In one embodiment re arranging the list includes moving the particular node ahead of another node in the list of request processing nodes. For example assume that there are four request processing nodes node 1 node 2 node 3 and node 4 in the list with cumulative load values 65 71 62 and 75 respectively. In this case the nodes are re arranged according to the cumulative values to identify nodes node 3 node 1 node 2 and node 4. Next based on the arranged list of the nodes the request processing nodes for processing the to be processed request is determined . Identifying the request processing nodes for processing the to be processed request based on the cumulative load of the nodes ensures balancing of load across the nodes and avoids overloading of an already loaded node i.e. a node having a high cumulative load value.

Further in case the cumulative node values of the node and the another node is same then the average delay in request processing of the node are compared with the another node to determine whether the average delay in request processing by the node is less than the average delay in request processing of the another node . When the average delay in request processing of node is less than the average delay in request processing of another node then the particular node and another node are re arranged in the list. In one embodiment re arranging the list includes moving the particular node ahead of another node in the list of request processing nodes.

Next a check is performed to determine whether the to be processed request can be divided into sub requests . In one embodiment some of the to be processed requests can be divided into sub requests. For example a package push request using an application policy to 10000 devices can be handled separately by a package server included in different nodes. Therefore the package push request is a request that can be divided into sub requests. Alternatively some of the requests cannot be divided into sub requests. For example content push to a mobile device which is of size 500 MB is a request that cannot be divided into sub requests. In case the to be processed request cannot be divided into sub requests then the to be processed request is assigned to the nodes identified at . Once the node starts processing the to be processed request then the status of the request are changed to in progress request. In one embodiment the to be processed request is assigned according to the order of the request processing nodes in the list of request processing nodes. For example in case a request cannot be divided then the request would be assigned to the first node in the list of request processing nodes identified at .

In case the request can be divided then the request is divided into several sub requests . In one embodiment a request divider divides the request into several sub requests. A check is then performed to determine whether a summation of maximum number of requests Xit is greater than the number of sub requests n of the to be processed requests . In one embodiment Xit may be the maximum number of requests that may be processed by a node i from the identified request processing nodes. For example consider that three request processing nodes node node and node are identified for processing a to be processed request. Assume that maximum number of requests Xit that may be processed by node node and node are 30 50 and 90 respectively. In this case the sum of the Xit 30 50 90 that may be processed by the nodes 1 2 and 3 respectively is 170. Further assume that the number of sub requests of the to be processed request is 120. In this case as the summation of Xit 170 is greater than the number of sub requests therefore the sub requests can be processed by the nodes.

In one embodiment the node i is a virtual machine VM of a particular type. A VM type may categorize VMs according to the processor CPU and network performance of a particular VM. For example the VM type may be small medium and large corresponding to the processor CPU and network performance of the VMs. In one embodiment Xit may be the maximum number of requests that may be processed by a node i of a particular VM type. In one embodiment for determining whether maximum number of requests Xit is greater than the number of sub request n initially a pre determined cumulative load CL value for a particular VM type is received. A cumulative load CL value is a load generated by a single request of particular request type r on a node for a particular VM type in the underlying IaaS framework. In one embodiment the CLvalue may be re written by a user. For example the pre determined CLvalue for a VM type small may be 4 . Next the maximum number of requests Xit that may be processed by a particular node i is determined using the formula 1 CL CL where CL Cumulative load by the sub requests on node i at time t 

In case the determined maximum number of to be processed requests Xit is greater than the number of sub requests n of the to be processed requests then the sub requests can be processed by the nodes identified at . In this case the sub requests are assigned to the identified nodes 

In case the summation of the maximum number of requests Xit is less than or equal the number of sub requests of the to be processed request then a request is sent to generate additional request processing nodes for the cluster . In one embodiment when the maximum number of requests that may be processed is less than the number of sub requests indicates that additional request processing nodes are required for processing the sub requests of the request. A number of additional request processing nodes to be added to the cluster is then determined . In one embodiment an additional cumulative load may be calculated to identify the number of additional nodes that are to be added to the cluster. The additional cumulative load is the additional load that may be generated in case the sub requests are submitted to the request processing nodes for processing after utilizing the CPU and cache memory of the identified request processing nodes VMs. In one embodiment when the number of request processing nodes identified is m and the number of sub requests to be processed request is n then the additional cumulative load ACL is calculated using the following formula ACL CL

In the above formula n Xit represents the number of pending sub requests that are remaining after utilizing the CPU and cache memory of the identified request processing nodes VMs. A number of additional nodes for processing the sub requests is then determined based on the determined additional cumulative load. In one embodiment determining the number of additional nodes to be added includes determining the number of additional VMs that are to be added for processing the additional cumulative load. In one embodiment the signal handler module determines the number of additional VMs based on the additional cumulative load ACL for a particular VM type and the pre determined cumulative load value CL for a particular VM type in the IaaS framework. For example consider the ACL for processing sub requests of a request is determined as 320 and the CLr for a small VM type is 4 and a large VM type is 2 . In case the signal handler assumes 80 utilization as full utilization of VM then the signal handler determines the number of small type VMs as 4 80 4 320 . Further the ACL for processing sub requests would be determined as 160 when the IaaS framework includes VM of type large . In this case the number of large type VMs is determined as 2 to service the additional cumulative load.

In one embodiment when the summation of the maximum number of requests Xit is equal to the number of sub requests of the to be processed request then the number of additional nodes may be determined based on a pre determined buffer cumulative load instead of the ACL. A predetermined buffer cumulative load is a parameter which implies a pre determined additional amount of load that the cluster should be able to accommodate at any point of time.

Next the determined number of additional nodes is generated . In one embodiment the signal handler transfers the determined number of additional request processing nodes to a cluster controller that then calls a cloud manager to generate and add the determined number of additional nodes for the cluster. A cloud manager is a module included in the manager node. The cloud manager facilitates communication between the cluster controller and the underlying IaaS framework. In one embodiment the cloud manager provides APIs to manage node instances in the cluster. The cloud manager also stores endpoints of the IaaS framework and configures different cloud brokers to provide different cloud based services including cluster management services such as increasing or decreasing the number of nodes in the cluster snapshot management services maintaining block or object storage etc. A cloud broker is an intermediary between the cloud manager and the underlying IaaS framework provided by different vendors. In one embodiment the cloud broker may be provided to communicate with the IaaS framework provided by different vendors for example an Amazon Web Service AWS broker may be provided to communicate with an IaaS framework provided by Amazon .

In one embodiment the underlying IaaS framework includes a virtual machine VM template for the different type of nodes for example request processing node manager node manager helper node etc. The VM template is a template including different modules included in a request processing module. A VM template is a master copy of a request processing node VM and may be used to create instances of the request processing node VM. In one embodiment a request processing node includes a node controller module a node metrics notify module and a node update module and servers. The node controller module may provide status information of the request processing node to cluster controller included in the manager node. The status information may provide information about the availability of the request processing node to the cluster controller. A node metric notify module provides the request processing node specific information for example CPU usage primary memory usage and network usage related to a particular network. The node metric notify module provides the node information to the node controller. The node update module is a module that is used for upgrading the servers included in the request processing node. In one embodiment the VM template includes a pre installed node controller module node metrics notifier module node update module and the servers. The cloud manager using the cloud broker generates the determined number of request processing node VMs.

Next the sub requests are assigned to the nodes identified at and the additional nodes generated at . In one embodiment the added nodes are included in the list of nodes identified for processing the sub requests. In one embodiment the Request Manager persists the requests or the sub requests to back end system before the requests are assigned to the identified nodes and the additional nodes. After the request has been assigned a check is performed to determine whether a processing success message is received from the identified nodes and the additional nodes . The processing success message may indicate that the message has been successfully processed by the identified nodes and the additional nodes.

In one embodiment after receiving the processing success message a request may be received for displaying the processed request report . In one embodiment a success message is received after the processing success. In one embodiment the processed request report is a report displaying the requests that have been successfully processed. The requests may also be received for displaying in progress request report that includes information related to the different requests that are being processed by the different request processing nodes at a particular time request rejection report that includes information related to the different requests that have been rejected request processing time report average delay in request processing report etc. In one embodiment the manager node also allows creation of snapshot of the cluster. A snapshot includes details of the cluster for example manager node snapshot request processing node snapshot etc. In one embodiment the manager node also includes an alert manager that generates alert depending on events raised by different modules. For example the alert manager generates an alert message when the number of nodes in the cluster reaches the maximum node limit defined for the cluster.

Next in case a processing success message is not received then a check is performed to determine whether node status information is received from the nodes . In one embodiment the check at may be performed anytime during the process for managing the nodes. For example the check may be performed before receiving a request during comparison of cumulative loads of nodes during the assignment of requests to nodes etc. In one embodiment the node controller included in the request processing nodes processing the to be processed requests or the sub requests of the to be processed request sends node status signal at regular intervals to the cluster controller. The node status signal informs the manager node that the request processing node is available and has not failed. When the node status information is received from the nodes processing the to be processed request a check is performed to determine whether the difference between current time and request submission time is greater than a predetermined request timeout period . In case the condition in is true then the request is identified as a strangled request . For example consider that the current time is 10 pm. The request was submitted to a node at 8 pm. The difference between current time and request submission 2 hours 10 pm 8 pm time is greater than the request time out period 1 hour. Therefore the request is identified as a strangled request .

Next a request type of the strangled request is identified . In one embodiment a request is categorized in two types atomic request and composite request. Atomic requests are requests which can be terminated without affecting any other node or process i.e. there is no side effects created by an in progress request. An in progress atomic request may be terminated at any stage and then re submitted for processing. Composite request is a request that is in different intermediate states during the processing of the request. The composite request creates side effects during the processing of the request. In order to terminate an in progress composite request the different actions for example deletion or modification of entries made in tables creation or update of configuration files etc. performed by the in progress composite request is undone.

Next a check is performed to determine whether the request type of strangled request is atomic request . In case the strangled request is of type atomic request then the status of the strangled atomic request is modified . In one embodiment the request manager changes the status of the strangled atomic request from in progress to pending status. In case the strangled request is a composite request condition in is false then a determination is made whether a rollback handler for the request type of the composite request is registered . In one embodiment a rollback handler rolls back the side effects created due to the in progress composite request. In case a roll back handler is registered corresponding to the request type of the composite request then the rollback handler is executed to reverse the side effects create due to the in progress composite request . Next the status of the strangled composite request is modified . In one embodiment the request manager changes the status of the strangled composite request from in progress to pending .

Next steps are repeated to re assign the atomic requests or the composite request having pending status to other nodes. In one embodiment the requests atomic or composite stored in the backend system are used for re assigning the requests to the nodes. In one embodiment when a rollback handler is not registered for the request type of the strangled request then a live migration of the node executing the strangled request is executed . In one embodiment the live migration is initiated after a predetermined rollback timeoutperiod. In one embodiment live migration refers to the process of moving a running virtual machine node executing the strangled composite request between different physical machines without disconnecting the client or application. Memory storage and network connectivity of the virtual machine are transferred from the original host machine to the destination.

In one embodiment a check is then performed to determine whether a process success message is received from the nodes executing the strangled request . In one embodiment the check is performed to determine whether the strangled request has been processed by the re assigned node or the migrated node within a pre determined repeated requested timeout period. In case the strangled request has been processed then a success message is forwarded to the sender of the request . In case the strangled request has not been processed then the request is identified as failed request .

In one embodiment when a failure message is received condition in is false then are repeated to re assign the failed requests to other nodes.

In one embodiment when node status information has not been received from the request processing nodes processing the requests or sub requests then initially a check may be performed to determine whether the difference between current time and last node status information receiving time is greater than a predetermined node timeout period . In case the condition is true it indicates that the node has become un responsive. In one embodiment a node may become un responsive due to several reasons for example host machine error IaaS framework exceptions etc. Next when the condition is true then the requests or sub requests assigned to the un responsive node are identified as a strangled request .

Next a request type of the strangled request is identified . In case the request type of the strangled request is identified as atomic then the status of the strangled atomic request is changed from in progress to pending . In case the request is a composite request then roll back handlers are executed to reverse the side effects created due to the in progress strangled composite request . Next the status of the strangled composite request is modified . In one embodiment the request manager changes the status of the strangled composite request from in progress to pending .

Next steps are repeated to re assign the atomic requests or the composite request having pending status to other nodes. In one embodiment the requests atomic or composite stored in the backend system are used for re assigning the requests to the nodes. Next a request is received to generate a replacement node . In one embodiment the request is received for generating a replacement node corresponding to the strangled node. Next based on the received request the replacement node is generated . In one embodiment a signal handler initially identifies set of services that were exposed by the strangled node. Next the signal handler calls cluster controller to generate a new node and also pass the set of platform services that should be started in the replacement node. The set of platform services to be started in the replacement node is same as the set of services provided by the strangled node. Finally the cluster controller provides this information to a cloud manager which using the cloud brokers to generate a virtual machine instance as the replacement node. In this way seamless availability for processing the requests is provided.

In one embodiment seamless availability for processing is also provided when the manager node fails. To provide seamless availability the cluster includes a manager shadow node that includes the modules for example request manager cluster controller etc. included in the manager node. When the manager node failure is detected then the IP address configured to manager node is re assigned to the manager shadow node.

In one embodiment the cluster also includes a manager helper node that shares the load of manager node when the manager node becomes loaded. The manager helper node includes a subset of modules included in the manager node. In one embodiment the manager helper node includes modules related to pre processing a request for example a request divider and a request dispatcher to assign the requests or sub requests to several nodes a node controller a request balancer which performs a load balancing when a particular node becomes loaded. The manager helper node also includes distributed caching framework and runs a cache server within it. It enables the platform to cache objects in multiple master helper nodes simultaneously and provides a unified way to access those objects.

In one embodiment the manager node also upgrades the servers running in different request processing node from one version to another version. For upgrading the node the virtual machine template that is used for generating request processing node virtual machine is first upgraded. This ensures that further request processing node VM instances are created using the upgraded virtual machine template. Next the running request processing node VMs in the cluster is upgraded. The running request processing node VMs represents the request processing nodes that are included in the cluster. Upgrading the running request processing nodes instead of individually creating new upgraded nodes corresponding to the nodes in the cluster reduces the number of instance creation requests for performing the upgrade operation.

Next user defined signals are identified at pre determined intervals . In one embodiment a signal handler included in the manager node checks for any user defined signals at regular intervals. In case a user defined signal is identified then a check is performed to determine whether the user defined signal is to increase the number of nodes in the cluster . In one embodiment the user defined signal may be to trigger a snapshot generation at a pre determined time or applying upgrade. In case the user defined signal is to increase the number of nodes in the cluster then a check is performed to determine whether sum of requested number of nodes in the user define signal and existing number of nodes in cluster is greater than a pre determined maximum node limit . The pre determined maximum node limit defines the maximum nodes that can exist in the cluster. In case the condition is true then a message may be sent to the user that the user defined signal cannot be processed .

In case the sum is less than the pre determined maximum node limit then the requested number of node instances is generated . In one embodiment the signal handler transfers the user defined signal to cluster controller. The cluster controller then forwards the user defined signal to cloud manager that generates instances from the request processing node template stored in the IaaS framework. In one embodiment a node instance is generated corresponding to the number of nodes that are to be added to the cluster. Finally the generated node instances are added to the cluster.

In one embodiment when the user defined signal is for decreasing the number of nodes in the cluster then a check is performed to determine whether the difference between the existing number of nodes in the cluster and the number of nodes to be removed from the cluster is less than the pre determined minimum node limit . In case the condition in is true then a message may be sent to the user that the user defined signal cannot be processed . Next the nodes that are to be removed from the cluster are identified . In one embodiment the signal handler identifies the nodes that are to be removed from the cluster for decreasing the cluster size. Allocation of new requests to the identified node is then stopped. In one embodiment the signal handler stops allocating new requests to the identified node .

Next in case the identified nodes are processing some requests a check is performed to determine whether the processing of these in progress requests is completed . When the processing of the request is completed then the identified nodes are removed from the cluster . In one embodiment the signal handler transfers the user defined signal to cluster controller. The cluster controller then forwards the user defined signal to cloud manager that removes the instances of the identified nodes from the cluster. A cluster with a reduced number of nodes is obtained after the node instances are removed from the cluster.

In one embodiment when the node parameters for nodes in a cluster is not greater than the predetermined maximum node parameter values then the nodes that have node parameters values less than the predetermined maximum node parameter values are identified . Next the identified nodes are determined as the nodes that are to be removed . Finally the nodes identified at are removed to scale down the cluster . In one embodiment the steps discussed with respect to are executed to remove the identified nodes from the cluster.

Some embodiments may include the above described methods being written as one or more software components. These components and the functionality associated may be used by client server distributed or peer computer systems. These components may be written in a computer language corresponding to one or more programming languages such as functional declarative procedural object oriented lower level languages and the like. They may be linked to other components via various application programming interfaces and then compiled into one complete application for a server or a client. Alternatively the components may be implemented in server and client applications. Further these components may be linked together via various distributed programming protocols. Some example embodiments may include remote procedure calls being used to implement one or more of these components across a distributed programming environment. For example a logic level may reside on a first computer system that is remotely located from a second computer system containing an interface level e.g. a graphical user interface . These first and second computer systems can be configured in a server client peer to peer or some other configuration. The clients can vary in complexity from mobile and handheld devices to thin clients and on to thick clients or even other servers.

The above illustrated software components are tangibly stored on a computer readable storage medium as instructions. The term computer readable storage medium should be taken to include a single medium or multiple media that stores one or more sets of instructions. The term computer readable storage medium should be taken to include any physical article that is capable of undergoing a set of physical changes to physically store encode or otherwise carry a set of instructions for execution by a computer system which causes the computer system to perform any of the methods or process steps described represented or illustrated herein. A computer readable storage medium may be a non transitory computer readable storage medium. Examples of a non transitory computer readable storage media include but are not limited to magnetic media such as hard disks floppy disks and magnetic tape optical media such as CD ROMs DVDs and holographic devices magneto optical media and hardware devices that are specially configured to store and execute such as application specific integrated circuits ASICs programmable logic devices PLDs and ROM and RAM devices. Examples of computer readable instructions include machine code such as produced by a compiler and files containing higher level code that are executed by a computer using an interpreter. For example an embodiment may be implemented using Java C or other object oriented programming language and development tools. Another embodiment may be implemented in hard wired circuitry in place of or in combination with machine readable software instructions.

A data source is an information resource. Data sources include sources of data that enable data storage and retrieval. Data sources may include databases such as relational transactional hierarchical multi dimensional e.g. OLAP object oriented databases and the like. Further data sources include tabular data e.g. spreadsheets delimited text files data tagged with a markup language e.g. XML data transactional data unstructured data e.g. text files screen scrapings hierarchical data e.g. data in a file system XML data files a plurality of reports and any other data source accessible through an established protocol such as Open DataBase Connectivity ODBC produced by an undeCLying software system e.g. ERP system and the like. Data sources may also include a data source where the data is not tangibly stored or otherwise ephemeral such as data streams broadcast data and the like. These data sources can include associated data foundations semantic layers management systems security systems and so on.

In the above description numerous specific details are set forth to provide a thorough understanding of embodiments. One skilled in the relevant art will recognize however that the embodiments can be practiced without one or more of the specific details or with other methods components techniques etc. In other instances well known operations or structures are not shown or described in detail.

Although the processes illustrated and described herein include series of steps it will be appreciated that the different embodiments are not limited by the illustrated ordering of steps as some steps may occur in different orders some concurrently with other steps apart from that shown and described herein. In addition not all illustrated steps may be required to implement a methodology in accordance with the one or more embodiments. Moreover it will be appreciated that the processes may be implemented in association with the apparatus and systems illustrated and described herein as well as in association with other systems not illustrated.

The above descriptions and illustrations of embodiments including what is described in the Abstract is not intended to be exhaustive or to limit the one or more embodiments to the precise forms disclosed. While specific embodiments of and examples for the invention are described herein for illustrative purposes various equivalent modifications are possible within the scope of the invention as those skilled in the relevant art will recognize. These modifications can be made in light of the above detailed description. Rather the scope is to be determined by the following claims which are to be interpreted in accordance with established doctrines of claim construction.

