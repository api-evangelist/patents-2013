---

title: Unique primitive identifier generation
abstract: A system, method, and computer program product are provided for generating unique primitive identifiers. A specified scope and geometry for a scene is received. A primitive identifier is generated for each primitive of a particular type, where each of the primitive identifiers is unique within the specified scope, and where the primitives are generated as the geometry for the 3D graphics scene is processed by a graphics processing unit. Different types may include patches, triangles, and vertices. The specified scope may be one of a frame, region, pixel, or draw call.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09177413&OS=09177413&RS=09177413
owner: NVIDIA Corporation
number: 09177413
owner_city: Santa Clara
owner_country: US
publication_date: 20130626
---
The present invention relates to graphics processing and more particularly to generating identifiers for graphics primitives.

Some graphics processing techniques that improve performance benefit from an ability to uniquely identify primitives or enumerate primitives within a scene or within a three dimensional 3D object. For example deferred shading renders a scene in a first processing pass to perform hidden surface removal i.e. z buffering without shading the pixels. Then the scene is rendered in a second processing pass to shade the visible pixels. To shade the pixels the graphics processor determines which primitive is visible for each pixel by comparing data generated and stored during the first pass with data generated during the second pass e.g. normal vector texture map parameters and z or depth .

When the data generated for the second pass is not guaranteed to be the same as the data generated for the first pass determination of the visible primitives by comparing the data can be unreliable. When multiple samples are used to generate an anti aliased image comparing the data can also be unreliable because more than one primitive may be visible for a single pixel and it may not be possible to determine which primitives are the visible primitives. The data that is compared does not necessarily distinguish between two primitives. In other words the data that is stored during the first pass does not provide a unique identifier for a primitive.

Thus there is a need for addressing the issue of uniquely identifying primitives and or other issues associated with the prior art.

A system method and computer program product are provided for generating unique primitive identifiers. A specified scope and geometry for a scene is received. A primitive identifier is generated for each primitive of a particular type where each of the primitive identifiers is unique within the specified scope and where the primitives are generated as the geometry for the 3D graphics scene is processed by a graphics processing unit. Different types may include patches triangles and vertices. The specified scope may be one of a frame region pixel or draw call.

A unique primitive identifier may be used to be able to unequivocally determine within the specified scope and for geometric primitives of a particular type the geometric primitive from which data that is stored to an output surface originated. In the context of the following description a unique primitive identifier is an identifier that is associated with any geometric primitive of a particular type that is unique within a specified scope among all geometric primitives of the particular type that are also within the specified scope and that are being processed or have been already processed. In the context of the following description a type of geometric primitive may include but not limited to a patch mesh triangle vertex and a fragment. In the context of the following description a specified scope of the unique primitive identifiers is defined as any set of rules that bounds the generation of the unique primitive identifiers. For example the specified scope may be related to a display surface that geometry for a scene is being rendered to e.g. the scope may be specified as an entire display surface a region of the display surface or a single pixel within the display surface. The specified scope may be the region in graphics processor unit GPU video memory GPU cache or random access memory RAM . The specified scope may be a geometric object or a drawcall a set of drawcalls or an instance within an instanced drawcall. Furthermore a scope can be specified as a combination of other scopes.

More illustrative information will now be set forth regarding various optional architectures and features with which the foregoing framework may or may not be implemented per the desires of the user. It should be strongly noted that the following information is set forth for illustrative purposes and should not be construed as limiting in any manner. Any of the following features may be optionally incorporated with or without the exclusion of other features described.

A unique primitive identifier may enable a processor to be able to unequivocally determine within the specified scope and for geometric primitives of a particular type the geometric primitive from which data that is stored to an output or display surface originated. In one embodiment the scope may be specified as a region of a frame and a unique primitive identifier may be generated for each triangle primitive that intersects the region. The number of unique triangle primitives that intersect the region may be determined based on the unique primitive identifiers. When the region is a single pixel of a multi sampled surface the unique primitive identifiers may be stored to the multi sampled output surface during a first processing pass. The unique primitive identifiers may be read during a second processing pass to calculate the number of different triangle primitives that are visible for the pixel. The number of different triangle primitives may then be used to simplify the shading operations while also producing an anti aliased image when deferred shading is used.

As the geometry for a scene is processed by each of the processing units within the pipeline the geometry is decomposed into simpler geometric primitives forming a hierarchy of primitives. A high order geometric primitive such as a surface is decomposed into successively simpler geometric primitives.

For example a vertex processing unit may receive a surface definition from an input assembly stage and execute a vertex shader program to generate one or more patches and associated vertex parameters. Then each patch may be tessellated by the tessellation processing unit to generate indexed vertices that represent the patches. The indexed vertices are grouped by the geometry processing unit to construct primitives such as line segments triangles and points that may then be subdivided to generate additional line segments triangles and points. Between the geometry processing unit and a rasterization processing unit the primitives are transformed from world space to screen space. When the primitives are represented in screen space a scope may be specified for generating primitive identifiers where the scope relates to a region in screen space as described further herein.

The rasterization processing unit scan converts the primitives by intersecting the triangles with pixels to generate low order primitive fragments and pixel coverage information. A fragment processing unit is configured to execute fragment shader programs to generate shaded pixels. The shaded pixels are received by a raster operations unit that performs raster operations such as stencil z test blending and the like and outputs pixel data for storage in a memory . The rasterization processing unit may be configured to compute per sample z values and perform z testing so that primitives that are not visible are not shaded.

When deferred shading is performed fragments including z data that are output by the rasterization processing unit may bypass the fragment processing unit so that z testing can be performed by the raster operations unit without shading the fragments. The fragments that survive z testing i.e. hidden surface removal are stored in the memory . Per sample z values may be computed by the rasterization processing unit . During a second pass the surviving fragments are shaded as described in conjunction with B C and D. One or more of the processing units shown in may be configured to generate primitive identifiers for one or more primitive types and for one or more specified scopes.

The input assembly stage may be configured to generate unique primitive identifiers for each primitive within a single drawcall or within each instance of an instanced drawcall. At the input assembly stage the geometric primitives are high order primitives such as surfaces. Consequently a unique identifier that is generated at the input assembly stage according to a drawcall scope will be shared by all geometric primitives that are generated from the high order primitive during subsequent processing. For example when a patch is tessellated by the tessellation processing unit all of the indexed vertices that are produced are assigned the same identifier the identifier that was generated by the input assembly stage for the surface. The primitive identifiers that are generated by the input assembly stage are not necessarily unique within the entire screen space output surface e.g. render target display surface or frame buffer any region of the output surface or even within a single pixel. The input assembly stage also generates primitive identifiers for all input primitives regardless of the particular primitive type so that a particular primitive identifier is associated with only one primitive of only one type. In contrast a geometry processing unit may generate the same primitive identifier for a triangle primitive and a line primitive because the two primitives are different types.

To guarantee that the primitive identifier is unique between different drawcalls a global primitive counter may be used and after each drawcall the counter is adjusted by the number of primitives output by the drawcall. The adjustment may be performed by a processor such as a central processing unit CPU that issues the drawcalls to the input assembly stage within a graphics processing unit GPU . A buffer within the GPU may contain a copy of the primitive counter that is updated to reflect each adjustment. Similarly a counter may also be adjusted in the CPU and the GPU for the number of primitives in each instance for an instanced drawcall.

The input assembly stage may be configured to generate primitive identifiers for surface type primitives but the primitive identifiers are not necessarily unique within a scope associated with the screen space output surface. Because the processing performed by the input assembly stage the vertex processing unit the tessellation processing unit and the geometry processing unit occurs in world space it may not be possible for those processing units to generate primitive identifiers that are unique within a scope associated with the output surface that is in screen space. However the different processing units that operate in world space are able to generate primitive identifiers for different primitive types in terms of the primitive hierarchy. The scope may be specified relative to the different primitive types. For example during execution of a vertex shading program the vertex processing unit may generate primitive identifiers that are unique within a specified scope such as a patch that is a lower level primitive compared with a surface that is processed by the input assembly stage . Also the primitive identifiers generated by the vertex processing unit may be generated for vertex type primitives that define a patch whereas the input assembly stage can only generate primitive identifiers for high level surface type primitives.

During tessellation the tessellation processing unit may generate primitive identifiers that are unique within a specified scope such as a triangle or line that is a lower level primitive compared with a surface or patch. Also the primitive identifiers generated by the tessellation processing unit may be generated for indexed vertices that define triangle and line type primitives. During execution of a geometry shading program processing of one constructed primitive may generate multiple primitives and a unique identifier may be generated for each one of the multiple primitives. The geometry processing unit may generate primitive identifiers that are unique within a specified scope such as a triangle or line that is a lower level primitive compared with a surface or patch. Also the primitive identifiers generated by the geometry processing unit may be separately generated for different primitive types such as triangle type primitives and line type primitives.

The rasterizaton processing unit may generate primitive identifiers that are unique within a screen space output surface region for each triangle or line primitive type. Any of the processing units that may generate primitive identifiers may include a counter for each combination of primitive type and specified scope. The different primitive types that a processing unit may generate primitive identifiers for is determined by the type of primitives processed by the particular processing unit. For example the rastization processing unit may generate identifiers for triangles line segments and points. The specified scope used by the rasterization processing unit to generate the identifiers may be any region of the output surface. The rasterization processing unit cannot generate identifiers for patch type primitives and the specified scope cannot be a drawcall patch or surface.

A primitive identifier that is generated by the fragment processing unit may be unique within a pixel when the specified scope is a pixel. An identifier that is unique within a pixel may be represented by fewer bits than an identifier that is unique within an entire output surface that typically includes thousands of pixels. The numerical range of the identifiers should be sufficient to encode all possible unique primitives of a type within the specified scope. When the specified scope is a pixel that includes 4 samples the range of possible unique primitives of the fragment type is 4 and a range of 4 can be represented by 2 bits. When 32 bit values are used for primitive identifiers up to 4 294 967 296 unique identifiers may be generated. The amount of memory needed to store the primitive identifiers may be reduced by specifying a scope that limits the number of unique identifiers as described in conjunction with .

In one embodiment atomic operations are used to generate unique fragment identifiers. A pixel shader that is executed for every fragment can execute an atomic operation to generate and either return or store the unique fragment identifier. The fragment identifier is returned when a fragment that will not be overwritten in the output surface already is associated with the generated fragment identifier so a different fragment identifier should be generated by the pixel shader. The raster operations unit may also be configured to generate unique identifiers for each fragment primitive type when depth and or color data of a given fragment is written into the output surface.

The G buffer is processed to generate shaded pixels for an image that is suitable for display. However a conventional G buffer that does not also store a primitive identifier for each sample lacks sufficient geometric pixel coverage data to produce an anti aliased image. In one embodiment one or more of the attributes surface normal vector depth value coverage and shading data are not stored in the G buffer and the primitive identifier is used to obtain the attribute s from a portion of memory that stores the attributes for each primitive.

The multi sample G buffer may be allocated as a single contiguous portion of memory or a separate sample G buffer may be allocated for each of the different sample locations within a pixel. Similarly one or more of the attributes stored in the G buffer may be allocated separately. A frame buffer is allocated to store a single shaded color for each pixel. Unlike the G buffer the size of the frame buffer does not increase as the number of samples per pixel increases. In contrast a conventional anti aliasing technique may require allocation of a single color buffer to store multiple samples for each pixel or separate color buffers for each sample.

In contrast with the multi sample G buffer the frame buffer only stores a single value for each pixel. Four separate color values i.e. shaded samples may be computed that each correspond to locations A B C and D and the shaded samples are modulated before being accumulated into the single value for a pixel. For example when four samples are used each shaded sample is scaled by to modulate the shaded sample. In general each shaded sample is divided by the number of samples per pixel to modulate the shaded sample. During deferred shading the shaded samples for each pixel are computed and are accumulated i.e. summed or added directly into the frame buffer during a second processing pass to generate the anti aliased color value for the pixel.

As shown in the primitive covers samples A C and D and does not cover sample B. The attributes including the primitive identifier associated with the primitive are stored in the G buffer for samples A C and D during the first processing pass.

During the second processing pass when the G buffer is processed to generate shaded samples the primitive identifiers for samples A C and D indicate that the samples are covered by a single primitive. Therefore the shading attributes stored for one of the covered samples A C or D may be processed to compute the shaded sample for each of the covered samples. Typically the shading attributes for a primitive are computed at a single sample location e.g. the center for a pixel. Therefore the shading attributes that are stored in the G buffer for the pixel are the same for sample A C and D. Instead of separately computing a shaded sample for each sample a single shaded sample can be computed and used for samples A C and D reducing the number of shading computations from 3 to 1. However without the primitive identifiers it is not possible to determine that samples A C and D are covered by the same primitive and the shading computations need to be performed for each sample to ensure a correct result.

In one embodiment an ordering requirement may be applied during the generation of the unique primitive identifiers. For example if the specified scope is a particular patch an ordering requirement can ensure that every time a patch is rendered triangles generated by processing the patch are assigned the same primitive identifiers. The ordering requirement may be used when the G buffer or a memory accessed by the primitive identifiers does not store the data e.g. at least shading attributes needed to generate shaded samples.

At step a full screen primitive is received for processing in a second processing pass. In the context of this description a full screen primitive covers all of the pixels in the display surface. At step during processing of the full screen primitive shaded samples are computed for each pixel that is covered by the full screen primitive. The shaded samples are computed using the per sample primitive identifiers and the shaded samples are accumulated to generate shaded pixels. The details of step are described in conjunction with . At step one shaded color value is stored in a frame buffer for each pixel to generate an anti aliased image.

At step the fragment processing unit determines if another unique HD was identified at step and if so step is repeated. However if shaded samples have been generated for all of the unique PIDs for the pixel then at step the fragment processing unit accumulates the shaded samples to generate a shaded pixel color. At step the fragment processing unit determines if another pixel is covered by the full screen primitive and if so then the fragment processing unit returns to step . Otherwise the fragment processing unit proceeds to step of .

As previously explained when the scope is specified as a pixel the number of bits needed to represent a primitive identifier for each fragment within the pixel is reduced. Every pixel can contain a maximum of N unique fragments where N is the number of samples in a pixel according to a multi sample mode. Therefore to assign every fragment in a pixel a unique identifier only Lg N bits are required. When the primitive identifiers are generated for each fragment using a scope specified as a pixel an atomic operation may be used to compare a generated primitive identifier with the primitive identifiers stored for the pixel that will not be overwritten by the generated primitive identifier to ensure that each identifier is unique.

Some deferred shading techniques do not generate a G buffer that can be processed to generate the shaded pixel colors. The amount of memory needed to store the G buffer may be significantly reduced by storing less data and instead regenerating the data needed to produce the shaded pixel colors during the second processing pass. For example a semi deferred shading technique processes the geometry for a scene two times during the first and the second processing pass. During the first processing pass the z values are computed and z testing is performed to store the closest z values for each sample in the G buffer. Primitive identifiers are also computed and stored in the G buffer. During the first processing pass the normal vector may also be computed and stored in the G buffer or in another memory that can be accessed using the primitive identifiers. Between the first and the second processing pass operations may be performed to implement lighting shadowing and other effects. For example an intervening processing pass may be performed to compute a scalar intensity of light reflecting from each pixel over all interior light sources. A camera matrix and the depth values can be used to restore the world space 3D position of a surface point visible in the pixel and a world space normal vector in the restored surface point can be fetched from the G buffer .

During the second processing pass the geometry for the scene is resubmitted for processing with the z test mode set to equal or less than or equal so that only the visible fragments pass the z test. The fragment processing unit reads the lighting data generated during the intervening pass and stored in the G buffer combines the lighting data with material properties for the surface and adds a lighting contribution from sunlight. Because the material properties of the surface are available during the second processing pass a reflected sunlight color contribution may be computed for each sample or pixel. The reflected sunlight color contribution may be computed using the per sample normal vector stored in the G buffer during the first processing pass. In contrast with the deferred shading technique described in conjunction with A and B during the first processing pass the G buffer need not store all of the material attributes that are needed to compute the shaded samples. Accordingly all of the material attributes are not necessarily generated during the first processing pass.

However when semi deferred shading is implemented an ordering requirement should be applied during the generation of the primitive identifiers so that the primitive identifier for each primitive processed during the first processing pass matches the primitive identifier generated for the primitive during the second processing pass. Therefore during the second processing pass the regenerated primitive identifiers may be compared with the stored primitive identifiers to compute per sample attributes such as the shaded samples. When data or attributes for a primitive such as material properties are stored outside of the G buffer either the stored or the regenerated primitive identifier may be used to fetch primitive data or attributes.

At step the geometry for a scene is processed in a second processing pass during which shaded samples are computed for each pixel that is covered by a primitive. The shaded samples are computed based on the per sample primitive identifiers stored in the G buffer and per sample primitive identifiers that are regenerated during the second processing pass. The shaded samples are accumulated to generate shaded pixels. The details of step are described in conjunction with . At step one shaded color value is stored in a frame buffer for each pixel to generate an anti aliased image.

When none of the stored PIDs matches the regenerated PID the fragment processing unit proceeds to step . Otherwise at step the fragment processing unit fetches the primitive attributes needed to shade the pixel using either the stored PID or the regenerated PID. One or more of the primitive attributes may be fetched from the G buffer or from another memory. At step the fragment processing unit shades the sample s that share the stored PID using the fetched primitive attributes.

At step the fragment processing unit accumulates the shaded samples to generate a shaded pixel color. Additional shaded samples may be accumulated to produce a final shaded pixel color value when subsequent primitives are processed that cover the pixel. At step the rasterization processing unit determines if another pixel is covered by the primitive and if so then the rasterization processing unit provides another fragment to the fragment processing unit and the fragment processing unit returns to step . Otherwise the rasterization processing unit determines if another primitive should be processed. When another primitive should be processed the method proceeds to step . Otherwise if another primitive does not need to be processed then the rasterization processing unit proceeds to step of .

In one embodiment the PPU includes an input output unit configured to transmit and receive communications i.e. commands data etc. from a central processing unit CPU not shown over the system bus . The I O unit may implement a Peripheral Component Interconnect Express PCIe interface for communications over a PCIe bus. In alternative embodiments the I O unit may implement other types of well known bus interfaces.

The PPU also includes a host interface unit that decodes the commands and transmits the commands to the grid management unit or other units of the PPU e.g. memory interface as the commands may specify. The host interface unit is configured to route communications between and among the various logical units of the PPU .

In one embodiment a program encoded as a command stream is written to a buffer by the CPU. The buffer is a region in memory e.g. memory or system memory that is accessible i.e. read write by both the CPU and the PPU . The CPU writes the command stream to the buffer and then transmits a pointer to the start of the command stream to the PPU . The host interface unit provides the grid management unit GMU with pointers to one or more streams. The GMU selects one or more streams and is configured to organize the selected streams as a pool of pending grids. The pool of pending grids may include new grids that have not yet been selected for execution and grids that have been partially executed and have been suspended.

A work distribution unit that is coupled between the GMU and the SMs manages a pool of active grids selecting and dispatching active grids for execution by the SMs . Pending grids are transferred to the active grid pool by the GMU when a pending grid is eligible to execute i.e. has no unresolved data dependencies. An active grid is transferred to the pending pool when execution of the active grid is blocked by a dependency. When execution of a grid is completed the grid is removed from the active grid pool by the work distribution unit . In addition to receiving grids from the host interface unit and the work distribution unit the GMU also receives grids that are dynamically generated by the SMs during execution of a grid. These dynamically generated grids join the other pending grids in the pending grid pool.

In one embodiment the CPU executes a driver kernel that implements an application programming interface API that enables one or more applications executing on the CPU to schedule operations for execution on the PPU . An application may include instructions i.e. API calls that cause the driver kernel to generate one or more grids for execution. In one embodiment the PPU implements a SIMD Single Instruction Multiple Data architecture where each thread block i.e. warp in a grid is concurrently executed on a different data set by different threads in the thread block. The driver kernel defines thread blocks that are comprised of k related threads such that threads in the same thread block may exchange data through shared memory. In one embodiment a thread block comprises related threads and a grid is an array of one or more thread blocks that execute the same stream and the different thread blocks may exchange data through global memory.

In one embodiment the PPU comprises X SMs X . For example the PPU may include 15 distinct SMs . Each SM is multi threaded and configured to execute a plurality of threads e.g. 32 threads from a particular thread block concurrently. Each of the SMs is connected to a level two L2 cache via a crossbar or other type of interconnect network . A color blend unit is configured to perform blend functions such as the blend function used to accumulate shaded sample color values into a color buffer that may be stored in the memory and cached in the L2 cache .

The L2 cache is connected to one or more memory interfaces . Memory interfaces implement 16 32 64 128 bit data buses or the like for high speed data transfer. In one embodiment the PPU comprises U memory interfaces U where each memory interface U is connected to a corresponding memory device U . For example PPU may be connected to up to 6 memory devices such as graphics double data rate version 5 synchronous dynamic random access memory GDDR5 SDRAM .

In one embodiment the PPU implements a multi level memory hierarchy. The memory is located off chip in SDRAM coupled to the PPU . Data from the memory may be fetched and stored in the L2 cache which is located on chip and is shared between the various SMs . In one embodiment each of the SMs also implements an L1 cache. The L1 cache is private memory that is dedicated to a particular SM . Each of the L1 caches is coupled to the shared L2 cache . Data from the L2 cache may be fetched and stored in each of the L1 caches for processing in the functional units of the SMs .

In one embodiment the PPU comprises a graphics processing unit GPU . The PPU is configured to receive commands that specify shader programs for processing graphics data. Graphics data may be defined as a set of primitives such as points lines triangles quads triangle strips and the like. Typically a primitive includes data that specifies a number of vertices for the primitive e.g. in a model space coordinate system as well as attributes associated with each vertex of the primitive. The PPU can be configured to process the graphics primitives to generate a frame buffer i.e. pixel data for each of the pixels of the display . The driver kernel implements a graphics processing pipeline such as the graphics processing pipeline defined by the OpenGL API.

An application writes model data for a scene i.e. a collection of vertices and attributes to memory. The model data defines each of the objects that may be visible on a display. The application then makes an API call to the driver kernel that requests the model data to be rendered and displayed. The driver kernel reads the model data and writes commands to the buffer to perform one or more operations to process the model data. The commands may encode different shader programs including one or more of a vertex shader hull shader geometry shader pixel shader etc.

For example the GMU may configure one or more SMs to execute a vertex shader program that processes a number of vertices defined by the model data. In one embodiment the GMU may configure different SW to execute different shader programs concurrently. For example a first subset of SMs may be configured to execute a vertex shader program while a second subset of SMs may be configured to execute a pixel shader program. The first subset of SMs processes vertex data to produce processed vertex data and writes the processed vertex data to the L2 cache and or the memory . After the processed vertex data is rasterized i.e. transformed from three dimensional data into two dimensional data in screen space to produce fragment data the second subset of SMs executes a pixel shader to produce processed fragment data which is then blended with other processed fragment data and written to the frame buffer in memory . The vertex shader program and pixel shader program may execute concurrently processing different data from the same scene in a pipelined fashion until all of the model data for the scene has been rendered to the frame buffer. Then the contents of the frame buffer are transmitted to a display controller for display on a display device.

A pixel shader program may be configured to generate anti aliased images according to the techniques described in conjunction with when executed by one or more SMs . The multi sample z buffer multi sample stencil buffer and accumulated color buffer may be stored in the memory . In addition to reducing the amount of memory allocated for storing color data when the two pass technique is used to generate the anti aliased image the bandwidth that is consumed to generate the accumulated color buffer is reduced compared with generating a multi sample color buffer. Reducing the amount of space needed for storing the color buffer and reducing the memory bandwidth that is consumed may improve processing performance of the PPU when anti aliased images are generated.

The PPU may be included in a desktop computer a laptop computer a tablet computer a smart phone e.g. a wireless hand held device personal digital assistant PDA a digital camera a hand held electronic device and the like. In one embodiment the PPU is embodied on a single semiconductor substrate. In another embodiment the PPU is included in a system on a chip SoC along with one or more other logic units such as a reduced instruction set computer RISC CPU a memory management unit MMU a digital to analog converter DAC and the like.

In one embodiment the PPU may be included on a graphics card that includes one or more memory devices such as GDDR5 SDRAM. The graphics card may be configured to interface with a PCIe slot on a motherboard of a desktop computer that includes e.g. a northbridge chipset and a southbridge chipset. In yet another embodiment the PPU may be an integrated graphics processing unit iGPU included in the chipset i.e. Northbridge of the motherboard.

As described above the work distribution unit dispatches active grids for execution on one or more SMs of the PPU . The scheduler unit receives the grids from the work distribution unit and manages instruction scheduling for one or more thread blocks of each active grid. The scheduler unit schedules threads for execution in groups of parallel threads where each group is called a warp. In one embodiment each warp includes 32 threads. The scheduler unit may manage a plurality of different thread blocks allocating the thread blocks to warps for execution and then scheduling instructions from the plurality of different warps on the various functional units i.e. cores DPUs SFUs and LSUs during each clock cycle.

In one embodiment each scheduler unit includes one or more instruction dispatch units . Each dispatch unit is configured to transmit instructions to one or more of the functional units. In the embodiment shown in the scheduler unit includes two dispatch units that enable two different instructions from the same warp to be dispatched during each clock cycle. In alternative embodiments each scheduler unit may include a single dispatch unit or additional dispatch units .

Each SM includes a register file that provides a set of registers for the functional units of the SM . In one embodiment the register file is divided between each of the functional units such that each functional unit is allocated a dedicated portion of the register file . In another embodiment the register file is divided between the different warps being executed by the SM . The register file provides temporary storage for operands connected to the data paths of the functional units.

Each SM comprises L processing cores . In one embodiment the SM includes a large number e.g. 192 etc. of distinct processing cores . Each core is a fully pipelined single precision processing unit that includes a floating point arithmetic logic unit and an integer arithmetic logic unit. In one embodiment the floating point arithmetic logic units implement the IEEE 754 2008 standard for floating point arithmetic. Each SM also comprises M DPUs that implement double precision floating point arithmetic N SFUs that perform special functions e.g. copy rectangle pixel blending operations and the like and P LSUs that implement load and store operations between the shared memory L1 cache and the register file . In one embodiment the SM includes 64 DPUs 32 SFUs and 32 LSUs .

Each SM includes an interconnect network that connects each of the functional units to the register file and the shared memory L1 cache . In one embodiment the interconnect network is a crossbar that can be configured to connect any of the functional units to any of the registers in the register file or the memory locations in shared memory L1 cache .

In one embodiment the SM is implemented within a GPU. In such an embodiment the SM comprises texture units . The texture units are configured to load texture maps i.e. a 2D array of texels from the memory and sample the texture maps to produce sampled texture values for use in shader programs. The texture units implement texture operations such as anti aliasing operations using mip maps i.e. texture maps of varying levels of detail . In one embodiment the SM includes 16 texture units .

The PPU described above may be configured to perform highly parallel computations much faster than conventional CPUs. Parallel computing has advantages in graphics processing data compression biometrics stream processing algorithms and the like.

The system also includes input devices a graphics processor and a display i.e. a conventional CRT cathode ray tube LCD liquid crystal display LED light emitting diode plasma display or the like. User input may be received from the input devices e.g. keyboard mouse touchpad microphone and the like. In one embodiment the graphics processor may include a plurality of shader modules a rasterization module etc. Each of the foregoing modules may even be situated on a single semiconductor platform to form a graphics processing unit GPU .

In the present description a single semiconductor platform may refer to a sole unitary semiconductor based integrated circuit or chip. It should be noted that the term single semiconductor platform may also refer to multi chip modules with increased connectivity which simulate on chip operation and make substantial improvements over utilizing a conventional central processing unit CPU and bus implementation. Of course the various modules may also be situated separately or in various combinations of semiconductor platforms per the desires of the user.

The system may also include a secondary storage . The secondary storage includes for example a hard disk drive and or a removable storage drive representing a floppy disk drive a magnetic tape drive a compact disk drive digital versatile disk DVD drive recording device universal serial bus USB flash memory. The removable storage drive reads from and or writes to a removable storage unit in a well known manner.

Computer programs or computer control logic algorithms may be stored in the main memory and or the secondary storage . Such computer programs when executed enable the system to perform various functions. For example a compiler program that is configured to examiner a shader program and enable or disable attribute buffer combining may be stored in the main memory . The compiler program may be executed by the central processor or the graphics processor . The main memory the storage and or any other storage are possible examples of computer readable media.

In one embodiment the architecture and or functionality of the various previous figures may be implemented in the context of the central processor the graphics processor an integrated circuit not shown that is capable of at least a portion of the capabilities of both the central processor and the graphics processor a chipset i.e. a group of integrated circuits designed to work and sold as a unit for performing related functions etc. and or any other integrated circuit for that matter.

Still yet the architecture and or functionality of the various previous figures may be implemented in the context of a general computer system a circuit board system a game console system dedicated for entertainment purposes an application specific system and or any other desired system. For example the system may take the form of a desktop computer laptop computer server workstation game consoles embedded system and or any other type of logic. Still yet the system may take the form of various other devices including but not limited to a personal digital assistant PDA device a mobile phone device a television etc.

Further while not shown the system may be coupled to a network e.g. a telecommunications network local area network LAN wireless network wide area network WAN such as the Internet peer to peer network cable network or the like for communication purposes.

While various embodiments have been described above it should be understood that they have been presented by way of example only and not limitation. Thus the breadth and scope of a preferred embodiment should not be limited by any of the above described exemplary embodiments but should be defined only in accordance with the following claims and their equivalents.

