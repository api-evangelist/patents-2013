---

title: Simulation observability and control of all hardware and software components of a virtual platform model of an electronics system
abstract: Aspects of the present invention describe a system and method for a user of an event-driven simulation environment and/or embedded software debugger interface to step through the source code of components modeled by the environment/debugger, including the embedded software or hardware model source code. In a virtual platform modeling hardware components, bare-metal software programs, and high-level software applications or processes, the source code of each modeled component may be stepped through during simulation. Insertion points for breakpoints or watchpoints may be detected during a traversal of the source code of each component being modeled in the virtual platform and such breakpoints inserted automatically.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09262305&OS=09262305&RS=09262305
owner: Cadence Design Systems, Inc.
number: 09262305
owner_city: San Jose
owner_country: US
publication_date: 20130531
---
Aspects of the present invention relate generally to the field of system development and test and more specifically to event driven simulation of electronics.

Simulation of hardware components can be modeled at various levels of abstraction using event driven simulation. Processor models implementing Instruction Set Simulators ISS in combination with hardware simulators can be used to simulate cross compiled embedded software for example an operating system OS . A collection of hardware models running such embedded software is known as a Virtual Platform VP . However when developing VPs and the corresponding actual systems which they model issues with incorrect or unexpected interactions between the hardware and software components of the system can occur. Debugging these issues is often complicated by VP environment limitations which typically restrict observability and controllability of the hardware models and embedded software simulation. Furthermore because a separate debugger is often required for each processor core with the rapid expansion of the number of cores in modern platforms connecting separate debuggers to each modeled processor is often not feasible.

Additionally applications running on top of the embedded software may create unexpected errors and require verification and testing. However application verification and testing is often done separately and with application specific debuggers typically requiring execution of a debugger application or debug server for each software application being tested. Furthermore because these debuggers typically run on the same operating system on which the application is being tested this can create atypical system conditions and reduce the effectiveness of the test and debug process.

Conventionally to debug an issue which spans various levels of the hardware and software components of the system a hardware simulator control interface is used to view and debug the hardware components of the system a separate software debugger with its own user control interface is connected to each processor model to debug the bare metal software of interest in the system and one or more debug servers must be run on any embedded OS to connect additional debuggers each debugger having a control interface.

Using multiple debuggers and therefore multiple control interfaces can cause additional difficulties. For example when a simulation is stopped at one control interface other control interfaces can be either blocked or may not have accurate state information if they are unblocked. Additionally the user must switch between different tools and control languages to see the state of different aspects of a system controlled with multiple different interfaces. Furthermore command scripting to reproduce debug scenarios is awkward and sometimes impossible as it can require separate scripts for each control interface.

Additionally when using multiple control interfaces elements across multiple hardware states bare metal software states OS process states and or high level application states cannot be easily specified retrieved or identified. Then using these elements as part of a breakpoint condition or action is nearly impossible. Conventionally a user must manually record needed software or hardware state information as it is available during a simulation and mentally or externally evaluate the condition of the simulation from the information recorded. This may require coordinating multiple breakpoints in different control interfaces. Similarly in the conventional environment a user must manually set breakpoints in order to step through the instructions of the modeled components.

Accordingly there is a need in the art for a system to efficiently debug and analyze components of a virtual platform including by allowing a user to control and observe the state of the various hardware and software components including high level application software modeled in the virtual platform.

Additionally there is a need in the art for a system that allows a user to step through the source code of the embedded software at various levels of the software stack as well as the source code representing the hardware models as the modeled components are executed in the simulation.

Additionally there is a need in the art for a system that allows a user to manage breakpoints including by inserting breakpoints that stop the simulation and or the embedded software running on the processor models and return to a control interface within the simulation to evaluate elements of the hardware and the software states or to perform other breakpoint operations.

Aspects of the present invention describe a system and method for providing a single integrated simulation interface running in a single host operating system OS thread to observe and control multiple disparate software and hardware components. Aspects of the present invention extend the control mechanisms of a conventional virtual platform to include the hardware models the embedded software components modeled on the bare hardware elements or an ISS and the software applications processes and threads which are themselves running on embedded software.

Aspects of the present invention provide a system and method for a user of an event driven simulator to specify complex breakpoint conditions and actions which allow both hardware and software states to be accessed.

Aspects of the present invention describe a system and method for a user of an event driven simulation environment and or embedded software debugger interface to step through the source code of components modeled by the environment debugger including the embedded software or hardware model source code.

A modeled component as described herein refers to either a hardware component a bare metal software program or OS running within the context of a processor hardware component or a process running on an OS running within the context of a processor hardware component. According to an embodiment of the present invention the VP may run multiple hardware component models in sequence with each modeled hardware component using separate host platform resources. Platform resources can include a simulator thread or process or a call stack that is maintained for each modeled component. A simulator thread as used herein refers to a hardware component modeled within an event driven simulator which has its own call stack context.

Simulator interface runs in a control thread separate from the modeled components of the virtual platform. State information and other simulation related information for the modeled components is then made available via simulation commands executed by the control thread when control of the simulation returns to the control thread .

In each modeled component is executed on a simulator thread. For example each hardware model is executed on a simulator thread of the virtual platform. When a modeled component is executed in the course of the event driven simulation the simulator thread for that model will become active. When a breakpoint or watchpoint in the source code implementing the modeled component is reached the active simulator thread will yield control to the control thread .

The VP may use a processor model ISS . .X to access state information for the modeled components via an application programming interface API . For example function calls to the API allow the system to display the embedded software view of the memory and the registers of the modeled system. Function calls of the API may also be used to set breakpoints and or watchpoints which return control from the active simulator thread to the control thread . Other APIs may access the state information of the various modeled components. Control mechanisms like stepping breakpoints and watchpoints are implemented by causing the active simulator thread implementing the modeled component currently being simulated to yield control from the simulator thread associated with the component model back to the control thread .

Each of the modeled components of the VP is simulated using individual platform resources as described above. Each of the multiple modeled hardware components . .N is executed with individual simulator threads. An OS . .L may be simulated with reference to an ISS . .X modeling a processor instruction set running on a modeled hardware component. Then each software application . .K and . .J or application process running on the OS will be executed as an OS process as necessary. Software applications . .K and . .J may be any process or application designed to run on the OS. For example applications . .K and . .J may include a document editor a game a digital camera an electronics design application or other high level application.

The ISS models . .X may additionally interface with the control thread via a request manager . The request manager as directed by the control thread may read the registers memory or other components modeled by the VP via an ISS API to extract state and other information from the simulator.

According to an embodiment of the present invention the simulator interface in combination with the request manager provides control and observability for all hardware and software components in the VP . Representations of the OS data structures and entry points may be used by the simulation interface or request manager to provide improved observability and control over the simulation. For example a breakpoint of a function in the OS source code that causes a switch between processes can be used to effect the addition of breakpoints or watchpoints specific to the process which is to be started or resumed while removing breakpoints or watchpoints specific to the OS or to a prior process. Additionally because the API is used to access memory registers or state information this requires only a function call not the creation or use of a new process. Consequently the debugging itself does not utilize a process on the OS that might interfere with the execution of the application.

A user may access a virtual platform simulator interface in a standalone client system client server environment or a networked environment. is a simple block diagram illustrating components of an exemplary system according to an embodiment. As shown in a system may comprise a client executing a simulator and having a memory storage . The client may be any computing system that executes a simulator or otherwise facilitates access to memory storage for example a personal computer. The client may include a processor that performs a method in accordance with the disclosed embodiments. Such a client would be part of an overall simulation system in accordance with the disclosed embodiments.

Hardware models instruction sets software packages instances of the modeled components state information for the modeled components and other objects used by the simulator may be stored in memory storage . A user may access the objects stored in memory storage with the client via the simulator where the simulator is capable of accessing memory storage and displaying the objects and the data associated with the simulation. The simulator may include a user interface for example a program application or middleware that acts as a frontend to and facilitates access to objects in memory storage . The simulator may facilitate control over and observability into the simulation of the components implemented in a virtual platform using the display and edit tools and procedures described herein. The user may interact with the simulator through a number of input devices such as by inputting a selection as with a mouse or inputting a request as with a keyboard. The user may observe the simulation results on an output device or display. The simulator may run in an application window controlled by the user.

As shown in a client may be a stand alone system as may be of particular interest where the components being simulated are highly confidential. Additionally according to an aspect of an embodiment as shown in a client may be part of a networked environment.

A user may access a simulator at the server via the client having a user interface capable of accessing and displaying the components implemented as part of a virtual platform and the results of the simulation of those components. The client may be any computing system that facilitates the user accessing storage device for example a personal computer. The network may be a wired or wireless network that may include a local area network LAN a wireless area network WAN the Internet or any other network available for accessing storage device from the client .

The server may be a network server accessible to the client via the network that may manage access to storage device . The user interface may receive instructions regarding a simulation from the user and utilizing the objects stored in memory storage facilitate a display of the simulation or the information gathered during the simulation. Multiple different clients not shown may access storage device via the network and request access to the objects stored therein.

In another networked environment the simulator may be executed on a network capable client and access the models packages and other objects stored in one or more storage devices via a network and communications server.

As shown in a client may be a stand alone system as may be of particular interest where the components being simulated are highly confidential. Additionally according to an aspect of an embodiment as shown in a client may be part of a networked environment.

During execution if the source code for any component reaches a breakpoint a watchpoint or other stop point e.g. an error block control of the simulation will transfer to a control thread. The control thread will then allow a controller or event manager of the system to access state information of one or more modeled components or other information or otherwise execute an additional command as part of the simulation and verification process block . The information or other simulation results may then be displayed in a simulation interface block . Once the conditions of the breakpoint have been handled the simulation may return to the simulator thread that was executing when the breakpoint was reached or otherwise continue the simulation by sequentially stepping through the application procedures block .

According to an embodiment of the present invention in order to insert or create complex breakpoint conditions within the virtual platform identifiers are constructed which unambiguously designate a particular state or element associated with a particular instance of a modeled hardware component or a particular instance element or object of a modeled software component in the context of the entire simulation. Implementing global identifiers for each instance of a modeled element allows such identifiers to appear in condition expressions and action statements in the simulator interface or request manager and defines mechanisms for the simulator interface to query or set hardware or software states as appropriate. Hardware and software breakpoints yield control from the active simulator threads associated with individual models back to the control thread potentially subject to conditions or implying additional actions. Software breakpoints similarly yield control from the executing embedded software to the control thread.

According to an aspect of an embodiment an identifier for a hardware object is constructed using an unambiguous hierarchical path name that references the associated modeled component in the system. The hierarchical path name may use a path name separator for example . to distinguish each element within the domain. For example a register named R1 in a direct memory access DMA controller instance named DMA which is part of a processor subsystem instance named proc which is itself part of a larger electronics system instance being simulated named phone might be named phone.proc.DMA.R1 .

Similarly an unambiguous identifier for a software object is also constructed within the context of a particular software program using a unique hierarchical name. For example a variable i declared within a function start kernel declared in a program called Linux would have the hierarchical name Linux start kernel.i .

The hierarchical path names within either the hardware or software domains can then be hierarchically combined to form an unambiguous identifier for each hardware or software state element in the entire system. An identifier may use a hierarchical separator for example between each software and hardware domain to construct the unambiguous identifier where the path name separator and the domain name separator are distinct. For example to reference a variable i within a function main within a program app running under an OS Linux which is running on a processor called phone.proc the identifier phone.proc Linux app main.i unambiguously refers to that software element.

The modeled phone also includes multiple hardware models . .N one of which is a direct memory access controller named DMA . The DMA model has multiple modeled subcomponents . .M including a register named R1 . Again to reference the R1 register of the DMA model the unambiguous identifier would be phone.proc.DMA.R1 .

Referring back to a controller of virtual platform for example the simulator interface or the request manager can use the described identifiers to access or set state information of the identified elements. For example the simulator interface can define the unambiguous identifier syntax described above in its command language and then use the API previously described to collect information about the identified element or set states for the identified elements via function calls within the same host process and address space.

Although described primarily with reference to a unified simulation system the unambiguous naming scheme may be implemented in other simulation environments. For example if used with a conventional simulator having a different debugger or debug server and a unique interface for each application being simulated in the environment an unambiguous identifier can be constructed by separately modifying each control user interface for each debugger to allow the use of the unambiguous identifier syntax described above. Then the hardware and software components of the system can share state information through a shared memory writing to disk storage or an alternate mechanism and actions can be directed to the appropriate control interfaces to be executed when that interface regains control.

The ability to unambiguously identify elements of the virtual platform allows the system to automatically monitor and track the states of the elements and the actions of the modeled components. This will reduce mistakes and make the simulation and debugging processes more efficient.

According to an embodiment of the present invention to facilitate stepping through the source code of the modeled components implemented in a virtual platform the system may insert breakpoints at certain common actions. For a simulator running multiple hardware models in sequence with each model having a separate simulator execution thread hardware stepping yields control from the simulator threads associated with individual models back to the control thread after a predetermined number of source lines of the model have been executed. Similarly software stepping yields execution control from the embedded software to the control thread after a predetermined amount of software source code has been executed. Aspects of the present invention allow a stepping operation to cross the software and hardware domains so that either the next software or hardware source code line as appropriate will be executed in sequence before returning to the control thread.

To step between domains in the virtual platform breakpoints at known domain context switches may be added. For example a processor model will generally execute a minimum portion of instructions representing lines of source code for an embedded software application at a time. Setting a hardware breakpoint at the point that the portion of instructions starts or expires allows stepping between the software domain to the hardware domain. Similarly setting breakpoints in the OS routines that manage the context switches between processes threads running on the OS allows the stepping between the embedded software and the applications and processes running on the OS.

For example referring to the simulator interface request manager or other controller can traverse the source code for the modeled components of the virtual platform and set appropriate breakpoints at the identifiable context switches and then use an API to implement stepping support by using function calls within the same host process and address space. Then the breakpoints may be used to monitor the states of the modeled components or may provide the opportunity to change a state of hardware and or software at that breakpoint or upon resuming execution of the simulation.

Although described primarily with reference to breakpoints the simulator can also traverse the source code for proper watchpoints for example by detecting when a particular variable is written read or changed.

Although described primarily with reference to a unified simulation system the insertion of breakpoints may be utilized in other simulation environments. For example if used with a conventional simulator having a different debugger or debug server and a unique interface for each application being simulated in the environment context switches may be detected by directing each individual control interface to traverse the associated source code and set appropriate breakpoints as described above. Control of the source stepping operation then progresses from one control interface to the next as each control interface successively gains control of the simulation.

The ability to insert appropriate breakpoints in the software of the modeled components allows the system to automatically identify proper breakpoints in the source code of the modeled components. Additionally the system may identify breakpoints that are not obvious or not accessible to a user manually inserting breakpoints. This will reduce mistakes and make the simulation and debugging processes more efficient.

In some applications the modules described hereinabove may be provided as elements of an integrated software system in which the blocks may be provided as separate elements of a computer program. Some embodiments may be implemented for example using a non transitory computer readable storage medium or article which may store an instruction or a set of instructions that if executed by a processor may cause the processor to perform a method in accordance with the embodiments. Other applications of the present invention may be embodied as a hybrid system of dedicated hardware and software components. Moreover not all of the modules described herein need be provided or need be provided as separate units. Additionally the arrangement of the blocks in do not necessarily imply a particular order or sequence of events nor are they intended to exclude other possibilities. For example the operations depicted at blocks and may occur in any order or substantially simultaneously with each other. Such implementation details are immaterial to the operation of the present invention unless otherwise noted above.

The exemplary methods and computer program instructions may be embodied on a non transitory computer readable storage medium that may include any medium that can store information. Examples of a computer readable storage medium include electronic circuits semiconductor memory devices ROM flash memory erasable ROM EROM floppy diskette CD ROM optical disk hard disk fiber optic medium or any electromagnetic or optical storage device. In addition a server or database server may include computer readable media configured to store executable program instructions. The features of the embodiments of the present invention may be implemented in hardware software firmware or a combination thereof and utilized in systems subsystems components or subcomponents thereof.

While the invention has been described in detail above with reference to some embodiments variations within the scope and spirit of the invention will be apparent to those of ordinary skill in the art. Thus the invention should be considered as limited only by the scope of the appended claims.

