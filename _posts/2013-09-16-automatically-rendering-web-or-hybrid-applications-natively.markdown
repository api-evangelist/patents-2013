---

title: Automatically rendering web or hybrid applications natively
abstract: An embodiment includes causing elements to be recognized that correspond to one or more browser-supported programming languages in an application. The recognized elements are those elements that can be converted to native user interface elements in the operating system and rendered on a display of a computing device. The elements in the one or more browser-supported programming languages are converted to native user interface elements. The native user interface elements are caused to be rendered on the display of the computing device. Apparatus and computer program products are disclosed.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09471553&OS=09471553&RS=09471553
owner: International Business Machines Corporation
number: 09471553
owner_city: Armonk
owner_country: US
publication_date: 20130916
---
This patent application is a continuation of U.S. patent application Ser. No. 13 675 056 filed on Nov. 13 2012 which is incorporated herein by reference in its entirety to provide continuity of disclosure.

This invention relates generally to rendering web or hybrid applications on computer systems and more specifically relates to rendering those applications natively.

This section is intended to provide a background or context to the invention disclosed below. The description herein may include concepts that could be pursued but are not necessarily ones that have been previously conceived implemented or described. Therefore unless otherwise explicitly indicated herein what is described in this section is not prior art to the description in this application and is not admitted to be prior art by inclusion in this section. Acronyms that appear in the text or drawings are defined below prior to the claims.

Many computing systems such as personal computers mobile devices and tablets run applications that are based on Web applications. For instance calendar applications and webmail applications are commonplace. These types of applications have become more prevalent because of the explosion of mobile devices and other types of smaller computing systems such as tablets. Since Web browsers are ubiquitous on all of these computing systems Web applications are also ubiquitous.

One benefit to a Web application is if the application is updated then each client automatically accesses the updated application. Contrast this with a native application where updates to the native application require each device to download and install the updates.

A native application is an application written using native languages specific to the particular platform. For instance an application intended to run on a personal computer running a Microsoft Windows operating system would be written using a Windows software driver development kit. An application intended to run on a mobile device would be written using a corresponding platform specific programming model.

One detriment of Web applications is that they are not native and therefore are slower and cannot perform many functions that may be performed by native applications. Such functions include accessing native functions and resources including accessing the UI. One way to improve upon Web applications is by using hybrid applications which combine features of Web applications with some features of native applications. However these hybrid applications still have limitations such as using Web views instead of native UI views.

On the other hand if an application is created in native languages for one platform the application has to be rewritten into native languages for another platform. This process is time consuming and also tends to fracture the application into two or more different versions which may be relatively incompatible over time.

An exemplary embodiment is a method performed on a computing device comprising an operating system. The method includes causing elements to be recognized that correspond to one or more browser supported programming languages in an application. The recognized elements are those elements that can be converted to native user interface elements in the operating system and rendered on a display of the computing device. The method further includes converting the elements in the one or more browser supported programming languages to native user interface elements and causing the native user interface elements to be rendered on the display of the computing device.

An exemplary apparatus includes means for causing elements to be recognized that correspond to one or more browser supported programming languages in an application wherein the recognized elements are those elements that can be converted to native user interface elements in the operating system and rendered on a display of a computing device means for converting the elements in the one or more browser supported programming languages to native user interface elements and means for causing the native user interface elements to be rendered on the display of the computing device.

A further exemplary embodiment is a computing device comprising an operating system and comprising one or more memories comprising computer readable code and one or more processors. The one or more processors are configured in response to executing the computer readable code to cause the computing device to perform causing elements to be recognized that correspond to one or more browser supported programming languages in an application wherein the recognized elements are those elements that can be converted to native user interface elements in the operating system and rendered on a display of the computing device converting the elements in the one or more browser supported programming languages to native user interface elements and causing the native user interface elements to be rendered on the display of the computing device.

An additional exemplary embodiment is a computer program product comprising a computer readable storage medium having computer readable program code embodied therewith the computer readable program code comprising code for causing elements to be recognized that correspond to one or more browser supported programming languages in an application wherein the recognized elements are those elements that can be converted to native user interface elements in the operating system and rendered on a display of the computing device code for converting the elements in the one or more browser supported programming languages to native user interface elements and code for causing the native user interface elements to be rendered on the display of the computing device.

Reference is made to which shows a block diagram of a computing device and a server in communication via a network in accordance with an exemplary embodiment of the instant invention. is used to provide an overview of a system in which exemplary embodiments may be used and to provide an overview of an exemplary embodiment of instant invention. In there is a computer system server which is operational with numerous other general purpose or special purpose computing system environments or configurations. Examples of well known computing systems environments and or configurations that may be suitable for use with computer system server include but are not limited to personal computer systems server computer systems thin clients thick clients handheld or laptop devices multiprocessor systems microprocessor based systems set top boxes programmable consumer electronics network PCs minicomputer systems mainframe computer systems and distributed cloud computing environments that include any of the above systems or devices and the like.

As shown in computer system server is shown in the form of a general purpose computing device. The components of computer system server may include but are not limited to one or more processors or processing units a system memory and a bus that couples various system components including system memory to one or more processing units . Bus represents one or more of any of several types of bus structures including a memory bus or memory controller a peripheral bus an accelerated graphics port and a processor or local bus using any of a variety of bus architectures. By way of example and not limitation such architectures include Industry Standard Architecture ISA bus Micro Channel Architecture MCA bus Enhanced ISA EISA bus Video Electronics Standards Association VESA local bus and Peripheral Component Interconnect PCI bus. Computer system server typically includes a variety of computer system readable media such as memory . Such media may be any available media that is accessible by computer system server and such media includes both volatile and non volatile media removable and non removable media. System memory can include computer system readable media in the form of volatile memory such as random access memory RAM and or cache memory . Computer system server may further include other removable non removable volatile non volatile computer system storage media. By way of example only storage system can be provided for reading from and writing to a non removable non volatile magnetic media not shown and typically called a hard drive . Although not shown a removable non volatile memory such as a memory card or stick may be used and an optical disk drive for reading from or writing to a removable non volatile optical disk such as a CD ROM DVD ROM or other optical media can be provided. In such instances each can be connected to bus by one or more I O Input Output interfaces .

Computer system server may also communicate with one or more external devices such as a keyboard a pointing device a display etc. one or more devices that enable a user to interact with computer system server and or any devices e.g. network card modem etc. that enable computer system server to communicate with one or more other computing devices. Such communication can occur via e.g. I O interfaces . Still yet computer system server can communicate with one or more networks such as a local area network LAN a general wide area network WAN and or a public network e.g. the Internet via network adapter . As depicted network adapter communicates with the other components of computer system server via bus . It should be understood that although not shown other hardware and or software components could be used in conjunction with computer system server . Examples include but are not limited to microcode device drivers redundant processing units external disk drive arrays RAID systems tape drives and data archival storage systems etc.

The computing device also comprises a memory one or more processing units one or more I O interfaces and one or more network adapters interconnected via bus . The memory may comprise non volatile and or volatile RAM cache memory and a storage system . Depending on implementation memory may include removable or non removable non volatile memory. The computing device may include or be coupled to the display which has a UI . Depending on implementation the computing device may or may not be coupled to external devices . The display may be a touchscreen flatscreen monitor television projector as examples. The bus may be any bus suitable for the platform including those buses described above for bus . The memories and may be those memories respectively described above. The one or more network adapters may be wired or wireless network adapters. The I O interface s may be interfaces such as USB universal serial bus SATA serial AT attachment HDMI high definition multimedia interface and the like.

In this example the computer system server is connected to the computing device via network and links . The computing device connects to the computer system server in order to access the browser based application . A browser application is e.g. an application designed to enable users to access retrieve and view documents and other resources on a network and particularly on the Internet. However the network may be an internal network such as used in many corporations.

Once the computing device downloads downloads the browser based application the native renderer translates information in the browser based application into native elements shown as rendered native output . In the examples below the rendered native output is output produced on the UI on the display .

The native renderer in an example is a program that executes on the processing unit s . The processing unit s and may be any processing units suitable use in a corresponding platform such as single or multi core processors digital signal processors application specific integrated circuits and the like.

Thus exemplary embodiments of the invention provide an exemplary benefit that the browser based application needs only be written or updated once and all computing devices will have an up to date version once the computing devices access and download the browser based application . Furthermore the native renderer renders native output which means the browser based application run via the native renderer will be faster than will the browser based application if the browser based application is run in a browser.

Turning to a networked environment is illustrated according to an exemplary embodiment of the present invention. In this example the computer system server is shown separate from network but could be part of the network. There are A through E different computing devices shown smartphone A desktop computer B laptop C tablet D television E and automobile computer system E. Not shown but equally applicable are set top boxes and game consoles. These are merely exemplary and other devices may also be used. The native renderer can be configured to execute on each computing device .

It is noted that the examples provided below place primary emphasis on mobile devices such as the smartphone A or the tablet D. However the instant techniques may be applied to many other computing devices.

Now that an overview of a system and an exemplary embodiment has been provided more detail about programming models is provided. Mobile applications running on devices such as smartphones and tablets can be of one of three different types depending on the programming model used to write the applications 

1. Web applications the client side of these applications is written using Web programming languages mainly HTML and JavaScript which is a lightweight interpreted object oriented language with first class functions .

2. Native applications the client side of these applications is written using native languages Java for the Android platform Objective C for the iOS platform .

3. Hybrid applications the client side of these applications is written as a combination of Web and native languages.

Web hybrid and native applications can be positioned on a spectrum of capabilities. In the diagram shown in Web applications have been split into two subcategories the applications made merely of mobile Web pages and those that are based on HTML5. It is noted that is also applicable to applications for other computing systems such as desktop laptop and embedded systems e.g. in television E . There are tradeoffs with each approach 

1. Web applications can run in a browser. This is a very appealing solution because the ability to run in a browser allows developers to stick to the write once run everywhere paradigm. Just using HTML and JavaScript a developer can write a mobile application that runs on any browser on any platform. However Web applications are considerably slower than native applications and cannot access native resources except for those allowed by HTML5. Most importantly a Web language based UI is not as appealing as a high fidelity native interface and cannot provide the high fidelity user experience expected from mobile devices.

2. Hybrid applications are more powerful than purely Web applications because hybrid applications can access native resources in the devices in which they run. However hybrid applications typically use Web views and so from a UI perspective these applications are very limited since they do not provide the high fidelity experience that users expect.

3. Native applications run directly on the operating system of the device. For this reason native applications are not portable across ecosystems. Developing native applications can be cumbersome because each application has to be developed on each platform. Nevertheless native applications are very fast and can make use of the native features including the UI of the device on which they run. The fidelity of a native application is unsurpassed.

The chart in shows the exemplary advantages and disadvantages of each programming model in detail. For web applications a browser operates on top of a security model which operates on top of an operating system which operates on top of a hardware layer . The hardware layer provides access to hardware such as a camera disk network microphone and speakers . The pages include HTML JS JavaScript . For the hybrid applications the browser operates on top of a native application comprising JavaScript APIs and the pages access the JavaScript APIs as shown by reference . For the native application native application operates on top of the operating system .

The following information may be used to guide developers as to how to choose one programming model over another. For web applications the following are exemplary and non limiting reasons why a developer may choose this programming model over hybrid or native applications programming models 

6 The platform native like HTML5 capabilities for managing local storage accessing geolocation and create advanced graphics are sufficient for the purposes of the application.

7 If an even richer look and feel is desired along with mitigation of feature discrepancies among platforms one can use advanced frameworks such as jQuery a JavaScript library and Dojo Mobile an HTML5 mobile JavaScript framework .

8 It is desired that security and manageability of the application should mirror regular applications.

For hybrid applications the following are exemplary and non limiting reasons why a developer may choose this programming model over web or native applications programming models 

1 A Web application already exists and only incremental additions to the application are required to handle device platform services not available through HTML5 such as camera contacts at the like

6 For an enterprise a container may be used for integrated management of specific applications and isolation of all those applications from the rest of the platform.

For native applications the following are exemplary and non limiting reasons why a developer may choose this programming model over web or hybrid applications programming models 

4 The focus is on platform features for example UI or Game Center that are not available through the hybrid container.

The table in illustrates exemplary tradeoffs between the Web hybrid and native programming models. The twelve parts through are those parts that make a given programming model more attractive than the others. The exemplary embodiments presented in this invention assemble all the advantages highlighted by the parts the table of .

Consumers of applications including mobile applications are used to high fidelity interfaces and expect nothing less in enterprise applications. User interfaces vary significantly across devices and their operating systems. Web and hybrid applications that render well on desktops and laptops often render very poorly on smartphones for instance and even more poorly on tablets where each UI inconsistency is magnified. The user interface needs to reflect the degree of literacy of the potential users. User experience is affected by connectivity and should be optimized for such connectivity. Therefore the best solution would be one that would allow a developer to write an application using the Web programming model while the application renders natively on any device on which the application runs. This is exactly what exemplary embodiments of the instant invention do. In fact the exemplary embodiments of the instant invention present a framework for dynamically rendering Web applications natively on any device and platform on which the application runs. Implementation may be made to work on mobile platforms such as iOS an operating system by the Apple company and Android an operating system by Google or non mobile platforms such as Windows an operating system by Microsoft or other non mobile platforms for televisions set top boxes and the like. This solution indeed allows developers to write mobile applications using a Web programming model and have those applications render natively on any operating system and device through a dynamic translation.

Thus in an exemplary embodiment a framework is proposed that takes any application written using a combination of Web languages e.g. HTML5 and JavaScript and dynamically translates its rendering making the application native. A web application is an application that is accessed by users over a network such as the Internet or an intranet. Specifically a web application is coded in a browser supported programming language such as JavaScript combined with a browser rendered markup language like HTML and reliant on a web browser to render the application executable. With an exemplary solution developers can write an application using Web programming languages which are portable across the various platforms . This helps developers write applications once and have then run everywhere. At runtime our solution dynamically translates the UI of the application and makes it native regardless of the platform on which the application is executed. For example on an Android device the application will render natively using the Android user experience model and similarly the application will render natively on an iOS device using the iOS user experience model.

The technical approach of an exemplary embodiment of the instant invention includes a JavaScript based generation of a native user interface combined with a dynamic native UI rendering engine and JavaScript API access to the UI rendering engine.

3 There is no proprietary language to learn or it not required to port existing applications to provide a user with native look and feel gesturing transitions navigation layout animation rubber banding better performance preloading caching.

Turning to a block diagram is shown of an architecture of an exemplary embodiment of the instant invention. This example includes a number of Web programming models a JavaScript API layer and a native UI renderer . In an example the native UI renderer includes a hybrid container that allows for dynamic and automatic native UI generation. There are a number of entry points of which entry points and are shown from the JavaScript API layer to the native UI renderer . In the following examples the native renderer shown in is illustrated as placing primary emphasis on UI interactions and therefore is referred to therefore as native UI renderer .

The native UI renderer is implemented in an exemplary embodiment as a layer operating above and with the operating system which operates above and with the hardware layer see . The layer is a native UI rendering engine decoupled from the Web programming models . The layer is a JavaScript based library providing access to a dynamic UI rendering model the native UI renderer . This can be used to apply a native UI rendering engine to any supported hybrid container programming model. Finally the top layer allows for multiple Web programming models to be plugged on top of this exemplary embodiment for maximum flexibility and reusability.

There are a number of use cases two of which are illustrated by . illustrates the entry point to the native UI renderer can happen directly through the JavaScript API layer . In fact the JavaScript API layer may be a general purpose JavaScript API that can very flexibly auto generate native controls with or without any specific Web programming model. illustrates that the entry points to the native UI renderer happen through a Web programming model for example the Dojo programming model . Dojo and Dojo style extensions allow for dynamically rendering Web applications with native controls.

Turning to this figure is a block diagram of a generalized architecture for automatically rendering web or hybrid applications natively in accordance with an exemplary embodiment. In this example the application see also comprises HTML and JavaScript source code that defines the application . The native UI renderer comprises a JavaScript library a bridge also called a JavaScript bridge herein a page registry a page a node and a renderable . The JavaScript library walks a DOM as explained in more detail below to create native nodes from DOM nodes. As is known a DOM is a cross platform and language independent convention for representing and interacting with objects in HTML XHTML and XML. The JavaScript bridge connects a Web view to the native view. The page registry keeps track of all the views of the application. The page represents a screen and maintains all child widgets. The node has a one to one 1 to 1 relationship with a model component i.e. from the DOM . The renderable is a native rendering of a node and correspond to native user interface elements that can be rendered on a display.

Turning to in block an application is launched. The application may be launched by a user selecting a launching element such as an icon link or any other suitable element as indicated in block . The launching of the application may include downloading all or a portion of the application .

In an exemplary embodiment the launching of the application creates an instance of a native application controller. The native application controller in this example includes or at least controls the native UI renderer . The native application controller may perform or cause to be performed the downloading in block . The native application controller can perform block to launch a layout engine and to hide the layout engine. The hiding of the engine is described in more detail below. In block the native application controller loads e.g. a portion of the application including browser supported programming language s as indicated by into the layout engine. The layout engine is an engine that performs web rendering of the application . The layout engine may be represented by other names depending on platform such as WebView or web rendering engine.

The layout engine in block parses the browser supported programming language s examples of which are shown in and creates the DOM. An example of a DOM is illustrated in and described below. In block the JavaScript library walks that is traverses the DOM to create a native object tree an example of which is shown in and described below . It is noted that both the DOM and the native object tree are dynamic and may be modified during web application rendering e.g. based on user input. In block if the JavaScript library finds a recognized element block Yes in the browser supported language the JavaScript library bridges block a callback into the native code e.g. a portion of the native UI renderer performing the native rendering process via a JavaScript bridge . That is the callback occurs from the JavaScript library through the bridge to the native code. The recognized elements can be any renderable element often called widgets in the browser supported languages. The JavaScript library is used in the traditional meaning of a computer software library. The library encapsulates the JavaScript needed to communicate from a layout engine to the native version of the application. In the native object tree the JavaScript library creates block a native element and a renderable type both of which correspond to the recognized element. If there is no recognized element at a current walking position block No or if block has been performed it is determined if the walk is complete in block . If the walk is not complete block No the flow continues in block . If the walk is complete block Yes the flow continues in block .

Before proceeding with additional description of it is helpful at this point to refer to an example of a DOM tree created in block and a native object tree created via blocks . Referring to this shows an example of a shadow tree native object tree that is created from a DOM tree . It is noted that the DOM tree may also be referred to as the DOM herein. In response to the DOM tree being created or at the same time the DOM tree is created the JavaScript bridge performs the operations as described in of walking the DOM tree and creating new native instances of objects. The native instances include in an example a model illustrated by the tree and a renderable view object e.g. as defined by a native element and renderable type .

In this example the DOM tree includes an HTML object a head object and a body object . The body object has a number of view objects and . The view node additionally has button objects and . The exemplary native object tree is an exemplary result that occurs after JavaScript bridge scans the DOM tree and creates new native instances. The native object tree has a tree object and a number of view objects and each of which corresponds to an object . Each of the view objects has a corresponding renderable type of view . Renderable types correspond to UI elements in the DOM and all HTML JavaScript UI elements should have a one to one mapping with native UI elements in the native object tree . Native UI elements in this example are the views e.g. pages and the buttons . Once these are rendered the views will be rendered as pages and the buttons will be rendered as buttons per the formatting of the platform as defined by e.g. the operating system . The view object has three button objects each of which corresponds to a button and each of which has a corresponding renderable type of button . In this example the nodes are nodes and . This simple example illustrates four views the first view has three buttons and the other three views are blank.

The JavaScript bridge also inserts callbacks in the DOM to callback elements e.g. objects in the native object tree . This is explained in more detail below.

Returning to blocks through are considered to be a tree creation phase as this phase creates at least a portion of the DOM tree and native object tree . Once the trees and are created or some portion of them is created then in block the web and native renderings are performed in parallel in an exemplary embodiment. In an exemplary embodiment the layout engine is hidden see block i.e. from a user using the computing device while the rendered native output is shown to the user via a display and the UI . Techniques for hiding the layout engine may vary by platform but suitable techniques include rendering in a video scratch area rendering outside the viewable area of the screen or disabling output from the layout engine to the display . In another exemplary embodiment the layout engine could be executed on a device different e.g. the computer system server from the computing device while the rendered native output is shown to the user via a display and the UI .

Regarding the parallel renderings for block is a logic flow diagram of a process for DOM traversal and corresponding web rendering and its effect on native rendering for a web or hybrid application while is a logic flow diagram of a process for native rendering and event handling and the effect on web rendering for a web or hybrid application. For ease of reference first will be described and then will be described. However both flows occur generally at the same time. In flow is performed by a layout engine and flow is performed by native renderer . The layout engine performs web layout the output of which is hidden in an exemplary embodiment in accordance with block of .

In block the layout engine traverses a DOM tree . In block the layout engine determines if a callback is found. If so block Yes a callback is performed via JavaScript bridge to be described below in reference to flow . If a callback is not found block No the flow continues in block were it is determined if the DOM traversal is complete e.g. for this portion of a browser based application . If not block No the flow continues in block . If DOM traversal is complete block Yes the layout engine waits for an event block . If an event occurs that does not modify the DOM block No the flow continues in block . If an event occurs that modifies the DOM block Yes in block the layout engine modifies the DOM and flow proceeds to block . For examples of possible events that might occur see Document Object Model DOM Level 3 Events Specification W3C Working Draft 6 Sep. 2012.

If the web layout changes the native layout must also change. In an exemplary embodiment this may be considered roughly to be a model view controller where the DOM is the model and the view layout is derived from the DOM for renderable elements. In order to change the native layout for flow a callback is performed via the JavaScript bridge . The callback starts a process whereby a renderable is positioned block the renderable is marked as ready to draw block and the computing device is caused to render the renderable according to its internal algorithms e.g. as per the OS .

Regarding the layout engine the layout engine reacts to the injected event by determining if the event that occurs is one that modifies the DOM block . If not block No the layout engines waits in block for such an event. Otherwise if an event has occurred that modifies the DOM block Yes in block the layout engine handles the event e.g. by traversing the DOM tree and in block notifies the native renderer via a callback performed by the JavaScript Bridge .

Turning now to this figure shows an example of a split rendering in accordance with an exemplary embodiment and is another way to view portions of . The split rendering shown in shows an example of the main modules and operations that could perform the flows shown in B and C. Reference indicates modules or operations that occur in the native programming model and reference indicates the modules or operations that occur in the web hybrid rendering model. The native programming model includes a native application controller a native object tree and a native rendering process . The web hybrid rendering model includes an add JS interface e.g. to add a JavaScript interface for the application a loader the DOM tree a JavaScript tree traversal operation and a web rendering process . The native application controller implements a load which causes a load e.g. by loader of the source e.g. JavaScript into the layout engine and starts at least the loader and subsequent operations shown in web hybrid rendering model .

In an example a custom JavaScript object i.e. a version of the JavaScript library of and incorporated into or controlled by the native application controller traverses block the DOM after the markup e.g. HTML in the application is parsed and the DOM tree is created. JavaScript callbacks are made e.g. via the create to the native code in native object tree as renderable types are found in the DOM . The call backs are realized through objects registered with the layout engine owned in an object oriented programming sense by the client application .

In native event targets are realized by a custom JavaScript library calling back through the JavaScript bridge as indicated by the execute call . Application developers can accept the default behavior on the event tree or stop event propagation using standard JavaScript. The complete set of native events are defined by the JavaScript library and implemented by the native renderer.

Turning now to a generalized class diagram is shown of an application controller that incorporates the native UI renderer see in accordance with an exemplary embodiment of the instant invention. In this example the Application Controller corresponds to the native hybrid application . In this example when the web vies is instantiated by the controller object of the application i.e. an instantiated version of Application Controller the controller object loads a custom JavaScript library that walks through the DOM calling back through the bridge to the native renderer to perform basic layout and rendering. The buildRendering method of the Bridge object performs the functions of the JavaScript library in this example. BuildRendering and performTransition are the actual callbacks on the native side of the renderer. Layout is the operation that is called once all of the renderings are done e.g. meaning the DOM traversal on the web side is finished and buildRendering is no longer being called . HashMap and the like are standard functions known in the field.

The exemplary embodiments are very flexible because these allow for mixing native and Web views as is shown in . Broadly a continuum of possible configurations are supported 

1 Web UI components can be completely replaced by native UI components as illustrated by 5. Completely native full translation in .

2 Web components can host native components see 3 of and native components can host Web components see 4 of .

The screen shots in show how the same application written in pure HTML5 and JavaScript can render natively on both the Android platform illustrated by and the iOS platform illustrated by . The rendered native user interface elements are the rendered buttons Send Request and Reset the rendered page entitled Information and the rendered information boxes for Last Name First Name Serial Number and Email Address .

This simple form based Web application if implemented natively would require 353 lines of Objective C code for the iOS platform and 137 lines of Java code for the Android platform for a total of 490 lines of native code. With the instant approach just HTML code is necessary since that code will be dynamically translated into native UI code. The total amount of code to write this application using HTML and JavaScript is only 27 lines. Therefore the exemplary embodiments herein as in this example allows for writing code that is 18 times smaller which corresponds to a 94.5 decrease. Another advantage of the exemplary embodiments herein is that natively the code would need to be designed and developed using native proprietary tools. With the instant approach instead applications are written in simple Web languages or even auto generated and deployed on a Web application server No deep native programming skills are required.

As will be appreciated by one skilled in the art aspects of the present invention may be embodied as a system method or computer program product. Accordingly aspects of the present invention may take the form of an entirely hardware embodiment an entirely software embodiment including firmware resident software micro code etc. or an embodiment combining software and hardware aspects that may all generally be referred to herein as a circuit module or system. Furthermore aspects of the present invention may take the form of a computer program product embodied in one or more computer readable medium s having computer readable program code embodied thereon.

Any combination of one or more computer readable medium s may be utilized. The computer readable medium may be a computer readable signal medium or a computer readable storage medium. A computer readable storage medium may be for example but not limited to an electronic magnetic optical electromagnetic infrared or semiconductor system apparatus or device or any suitable combination of the foregoing. More specific examples a non exhaustive list of the computer readable storage medium would include the following an electrical connection having one or more wires a portable computer diskette a hard disk a random access memory RAM a read only memory ROM an erasable programmable read only memory EPROM or Flash memory an optical fiber a portable compact disc read only memory CD ROM an optical storage device a magnetic storage device or any suitable combination of the foregoing. In the context of this document a computer readable storage medium may be any tangible medium that can contain or store a program for use by or in connection with an instruction execution system apparatus or device.

A computer readable signal medium may include a propagated data signal with computer readable program code embodied therein for example in baseband or as part of a carrier wave. Such a propagated signal may take any of a variety of forms including but not limited to electro magnetic optical or any suitable combination thereof. A computer readable signal medium may be any computer readable medium that is not a computer readable storage medium and that can communicate propagate or transport a program for use by or in connection with an instruction execution system apparatus or device.

Program code embodied on a computer readable medium may be transmitted using any appropriate medium including but not limited to wireless wireline optical fiber cable RF etc. or any suitable combination of the foregoing.

Computer program code for carrying out operations for aspects of the present invention may be written in any combination of one or more programming languages including an object oriented programming language such as Java Smalltalk C or the like and conventional procedural programming languages such as the C programming language or similar programming languages. The program code may execute entirely on the user s computer partly on the user s computer as a stand alone software package partly on the user s computer and partly on a remote computer or entirely on the remote computer or server. In the latter scenario the remote computer may be connected to the user s computer through any type of network including a local area network LAN or a wide area network WAN or the connection may be made to an external computer for example through the Internet using an Internet Service Provider .

Aspects of the present invention are described above with reference to flowchart illustrations and or block diagrams of methods apparatus systems and computer program products according to embodiments of the invention. It will be understood that each block of the flowchart illustrations and or block diagrams and combinations of blocks in the flowchart illustrations and or block diagrams can be implemented by computer program instructions. These computer program instructions may be provided to a processor of a general purpose computer special purpose computer or other programmable data processing apparatus to produce a machine such that the instructions which execute via the processor of the computer or other programmable data processing apparatus create means for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

These computer program instructions may also be stored in a computer readable medium that can direct a computer other programmable data processing apparatus or other devices to function in a particular manner such that the instructions stored in the computer readable medium produce an article of manufacture including instructions which implement the function act specified in the flowchart and or block diagram block or blocks.

The computer program instructions may also be loaded onto a computer other programmable data processing apparatus or other devices to cause a series of operational steps to be performed on the computer other programmable apparatus or other devices to produce a computer implemented process such that the instructions which execute on the computer or other programmable apparatus provide processes for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

The terminology used herein is for the purpose of describing particular embodiments only and is not intended to be limiting of the invention. As used herein the singular forms a an and the are intended to include the plural forms as well unless the context clearly indicates otherwise. It will be further understood that the terms comprises and or comprising when used in this specification specify the presence of stated features integers steps operations elements and or components but do not preclude the presence or addition of one or more other features integers steps operations elements components and or groups thereof.

The corresponding structures materials acts and equivalents of all means or step plus function elements in the claims below are intended to include any structure material or act for performing the function in combination with other claimed elements as specifically claimed. The description of the present invention has been presented for purposes of illustration and description but is not intended to be exhaustive or limited to the invention in the form disclosed. Many modifications and variations will be apparent to those of ordinary skill in the art without departing from the scope and spirit of the invention. The embodiment was chosen and described in order to best explain the principles of the invention and the practical application and to enable others of ordinary skill in the art to understand the invention for various embodiments with various modifications as are suited to the particular use contemplated.

