---

title: System for module selection in software application testing including generating a test executable based on an availability of root access
abstract: Systems and methods are described for generating a test executable used for testing an application locally on a host device. A user interface allows selection of particular test modules for use. Based on the selected modules a test executable is generated. The test executable functionality may integrated with the application or be independent of the application. The host device executes the test executable which enables testing and debugging on the local device.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09268670&OS=09268670&RS=09268670
owner: Google Inc.
number: 09268670
owner_city: Mountain View
owner_country: US
publication_date: 20130808
---
With the growing popularity of computing devices there is an increasing demand for applications or apps to run on such devices. These devices may include smartphones tablet computers televisions set top boxes in vehicle computer systems home entertainment systems wearable devices and so forth. To satisfy this demand programmers are constantly building testing and maintaining applications. To ensure high quality and to identify problems many app developers test their apps before launching them to the public.

Certain implementations and embodiments will now be described more fully below with reference to the accompanying figures in which various aspects are shown. However various aspects may be implemented in many different forms and should not be construed as limited to the implementations set forth herein. Like numbers refer to like elements throughout.

U.S. patent application Ser. No. 13 619 867 filed on Sep. 14 2012 titled Remote Control of a Mobile Device to Manish Lachwani et al. is incorporated by reference into this disclosure.

U.S. patent application Ser. No. 13 680 671 filed on Nov. 19 2012 titled Configurable Network Virtualization to Manish Lachwani et al. is incorporated by reference into this disclosure.

U.S. patent application Ser. No. 13 631 919 filed on Sep. 29 2012 titled Application Validation Through Object Level Hierarchy Analysis to Manish Lachwani et al. is incorporated by reference into this disclosure.

U.S. patent application Ser. No. 13 655 667 filed on Oct. 19 2012 titled Application Auditing Through Object Level Code Inspection to Manish Lachwani et al. is incorporated by reference into this disclosure.

U.S. patent application Ser. No. 13 721 632 filed on Dec. 20 2012 titled System For Testing Markup Language Applications to Manish Lachwani et al. is incorporated by reference into this disclosure.

U.S. patent application Ser. No. 13 741 989 filed on Jan. 15 2013 titled Application Testing System With Application Programming Interface to Manish Lachwani et al. is incorporated by reference into this disclosure.

U.S. patent application Ser. No. 13 862 240 filed on Apr. 12 2013 titled Test Automation API For Host Devices to Manish Lachwani et al. is incorporated by reference into this disclosure.

U.S. patent application Ser. No. 13 868 560 filed on Apr. 23 2013 titled Test Script Generation to Manish Lachwani et al. is incorporated by reference into this disclosure.

A wide variety of applications or apps are developed for execution on host devices such as smartphones tablet computers televisions set top boxes in vehicle computer systems home entertainment systems wearable devices and so forth. There is an increasing demand for software users to build apps to run on such devices. Software users build test and maintain applications using a variety of development and build tools. Testing provides many benefits including finding and correcting errors improving performance and so forth. Testing may include observing processor usage observing memory allocation programmatic debugging determining usability validating functionality identifying regressions and so forth.

Application testing may involve the use of testing applications using a client device or server. For example a client device may execute the testing applications and an emulator to simulate the host device operation and execute the application undergoing test. Application testing may also use one or more host devices tethered to client devices or servers with the host devices executing the application under test. The testing applications may run and gather information about or otherwise interact with the application under test using the tethered connection.

With an increasingly mobile workforce and users who may develop software full or part time the time and place for application development and testing may be anywhere. The user may have the time desire or the need to test debug update bug tracking information and so forth from an office while flying on an airplane at a client site and so forth. Traditional application testing systems have used resources external to the host device during operation. For example the user may need to have a laptop or other client device able to tether the host device for testing. Or the user may need to have network access to access and remotely control host devices in a host device farm.

Described in this application are systems and techniques for providing application functionality to a host device. The user may use a user interface to select a subset of one or more test modules from available test modules. These test modules provide one or more functions associated with application testing. Once selected these modules are used to construct a test executable for deployment to and execution on the host device. For example the user may be testing an application such as a calculator which executes natively on the host device and has no network connectivity features. The subset of test modules selected may include a native debugger while omitting a hypertext markup language version 5 HTML5 debugger and network capture module.

With the user interface the user is able to select desired or useful test modules to designate tools or functions relevant to the particular application or applications under test. This reduces the size and complexity of the test executable compared to a test executable which includes all test modules. This further minimizes the resources used by the test executable on the host device. These resources may include memory storage space processor usage and so forth. As a result the test executable may be used on resource constrained host devices such as smartphones tablets in vehicle systems and so forth.

The operating system of the host device may be configured to segregate executing applications into different virtual compartments sometimes known as sandboxes or jails . Each sandbox provides restricted access to system resources such as the filesystem hardware and so forth. Applications executing in different sandboxes may be unable to access shared memory operating system state information and so forth. These techniques may be used to improve stability of the host device reduce the likelihood or severity of security breaches and so forth.

The operating system may be configured to provide root access to applications. Root access may include permissions rights and so forth which enable the application to interact with other applications bypassing the sandboxes . With root access the operating system may be modified log information may be accessible filesystem access may be unrestricted and so forth. The root access may also be known as superuser admin administrator and so forth.

A jailbroken device is a host device in which root access is available. The root access may be available by the manufacturer of the operating system or may be provided using third party tools. A non jailbroken or jailed device is one in which root access is unavailable.

A test executable generation module is configured to generate a test executable. The test executable may be selected based on user input information indicative of root access being available on the host device and so forth. The test executable includes the selected one or more test modules. The test executable is provided to and executed on the host device as a standalone application. During execution the test executable is configured to perform one or more functions associated with application testing. The test executable in this implementation is able to provide application testing to one or more other applications executing on the host device. For example the test executable may be used to gather information for comparison of two applications executing on the host device. This information may be used for benchmarking evaluation and so forth of the application under test with another application.

In comparison when root access is unavailable on the host device the sandboxing may prevent the test executable from interacting with the application under test. In this situation or upon user selection the test executable generation module may assemble one or more static libraries which provide the functionality associated with the one or more selected test modules. The static libraries are provided to the user and are configured to be linked or otherwise included during compiling of the application to be tested. Additional code may also be provided which allows the user to invoke a user interface to manipulate the functions provided by the static libraries. The user may use a compiler on the client device or the host device to generate the test executable which includes the application and the static libraries. The test executable may then be executed on the host device including the testing functionalities associated with the static libraries. Because root access is unavailable the test executable may be unable to analyze other applications in different sandboxes.

The testing functionality may include code debugging tools bug tracking functions performance assessment information test case creation tools and so forth. For example a recording module may be configured to record user inputs and full motion video of screenshots.

The user may thus tailor the test executable to the needs of the particular application testing situation project requirements and so forth. The test executable may omit any functions which are unused or unnecessary in a particular situation. Because the test executable is easily generated using the user interface as the needs of the user change the test executable may be readily updated and test modules added or removed. Furthermore the test executable may be self contained allowing the user to continue development when other hardware or network resources are unavailable. For example the user may be testing a smartphone application while on a train with no internet access and carrying nothing more than the smartphone itself.

When the user desires such as upon arriving at the office where network connectivity is available test results bug information test scripts and so forth may be transferred to the client device a server and so forth. For example the user may send a test script generated on the host device to a server for use on a plurality of host devices in a host device farm coupled to the server. Thus the user is able to take advantage of the standalone and connected operation.

The application may be a native application or app a markup language application hybrid app or a browser based application. Native applications are those which are written and compiled for execution on the particular device. For example native applications may be written in a programming language such as C or Objective C and compiled into native code such as a binary executable for use on the device. Markup language applications include one or more instructions in a markup language which may be rendered by a layout engine and one or more instructions in a scripting language which may be interpreted by a scripting language engine during execution. For example a hypertext markup language HTML version 5 or greater markup language application may include HTML cascading style sheets CSS and JavaScript. In some implementations the markup language application may have multiple instances of the UIWebView class references. Hybrid applications include native code and markup language application portions. Browser based applications are processed within a web browser application and are limited in execution. The browser based applications may have only a single UIWebView instance.

The host device may also include a test executable . The test executable may comprise a binary suitable for execution on the host device . The test executable is configured to provide one or more functions associated with testing evaluating monitoring and so forth of the application . These functions may include runtime debuggers performance monitoring test script generation automated testing and so forth. Functionality generation and other details about the test executable are discussed below in more detail. The test executable may be configured to generate output such as local results . The local results may include bug reports crash logs input data input event data and so forth. The local results may include diagnostic output testing outputs screenshots of one or more of the displays of the host device and so forth. The screenshots may be stored as still images or combined to form a video stream representative of information presented on the display of the host device . The screenshots generated as the host device executes the application may be accessed for analysis presentation to the user stored and so forth. The local results may include information about one or more of the applications executing on the host device .

The test executable may also be configured to generate one or more test scripts . The test scripts may be based on input data of the interaction of the user with the application on the host device . The input data comprises information which is provided as input to the application . The input data may include touches on a touchscreen of the host device button presses on the host device or information from other sensors which is used by the application . Input event data is generated from the input data. The input event data comprises information indicative of input to the host device and associated application objects. The test scripts may be provided in various formats such as the Ruby language as created by Yukihiro Matsumoto and derivatives the UIAutomation framework promulgated by Apple Corp. of Cupertino Calif. and so forth.

The devices in the system may communicate with one another using one or more networks . The networks may include public networks such as the Internet private networks such as an institutional and or personal intranet or some combination of private and public networks. The networks may also include any type of wired and or wireless network including but not limited to local area networks LANs wide area networks WANs Wi Fi WiMax and mobile communications networks e.g. 3G 4G and so forth . The networks may utilize communications protocols including packet based and or datagram based protocols such as internet protocol IP transmission control protocol TCP user datagram protocol UDP or other types of protocols.

A build server may be used by the developer user to assist in development of the application . In some implementations one or more of the functions associated with the build server may be provided by the client device .

The build server may comprise one or more modules. These modules are discussed below in more detail with regard to . In some implementations the application as built may include executable binaries markup language applications and so forth. In some implementations the users may use the build server to implement a continuous integration methodology of software development in which workspaces of the users are merged frequently such as several times per day.

The build server may be configured to implement or work in conjunction with systems implementing one or more of the Rational ClearCase family of tools from IBM Corp the Hudson tool developed at least in part by Kohsuke Kawaguchi and available at hudson ci.org the Jenkins tool as forked from Hudson and promulgated by Kohsuke Kawaguchi which is available at jenkins ci.org Perforce from Perforce Software Inc. of Alameda Calif. or GitHub from GitHub Inc. of San Francisco Calif.

The build server may communicate with a test server using the network . The build server is configured to generate the application for execution on the host device . In some implementations the build server may also be configured to generate and send a test package to the test server . In some implementations the test package may include an access token. The test package may comprise tests test scripts configuration data build information and so forth. The build server may send the application and test package using a uniform resource locator URL which is associated with a particular account on the test server . The URL used by the build server to send the test package may be unique to a particular user group of users build server entity organization and so forth. Alternatively the build server may indicate a raw file path corresponding to the location of the application and the test package on a client device .

The test server comprises a test server interface module . The test server interface module may be configured to accept and respond to the application and the test package sent by the build server . The exchange of information between the build server and the test server may be encrypted. For example transfers of the application and the test package may use hypertext transport protocol secure HTTPS .

The test server interface module may also be configured to receive selection data from the user such as from the client device or the host device and provide the selection data to a test executable generation module . The selection data is described below in more detail. In one implementation the test server interface module may provide a web interface to the user . below depict an example web interface.

As described above the build server may be configured to implement or work in conjunction with various systems to support development. In one implementation the build server may implement a Hudson Jenkins build server system with plugins configured to interface with the test server using the test server interface module . The plugins may allow for opening a specific host device with an installed specific build of the application as a post build option. The plugins may also allow for automated calls to the test server to interact with particular builds.

In some implementations the test server may be configured to work with various tools such as ClearCase Jenkins Hudson Perforce GitHub and so forth. Similarly the test server and the services provided by the test server may be configured to integrate with various SDK. For example integration may be provided for SDKs promulgated by Sencha Inc. of Redwood City Calif. PhoneGap by Adobe Systems of San Jose Calif. AppGyver by AppGyver Inc. of San Francisco Calif. Eclipse by the Eclipse Foundation of Ottawa Ontario and so forth. The test server or portions thereof such as the test server interface module may be customized to allow for integration with particular users or entities.

The selection data provides information indicative of selection of one or more test modules for inclusion in the test executable . The selection data may also indicate a preference for an integrated test application separate test application and so forth.

The test modules are configured to be operable on the host device and provide one or more functions. The test modules may include but are not limited to a native application debugger module a hypertext markup language application debugger module a network capture module a function tracing module a metric module a statistic module a test case creation module a display capture module a hypertext transport protocol server module a remote debugger module or a remote control module.

In some implementations the selection data may include information indicative of the availability of root access on the host device information about characteristics of the host device and so forth. The characteristics of the host device may include one or more of an operating system version a processor type an available memory availability of an input device universally unique identifier UUID processor identifier device identifier and so forth.

The test executable generation module generation module is configured to accept the selection data and access the test modules indicated in the selection data . In one implementation the generation module may be configured to generate the test executable incorporating these test modules also known as the separate test executable . For example where root access is available on the host device the test executable may be provided to the host device as a binary file ready for execution on the host device . This test executable may be used to analyze other applications executing on the host device .

In another implementation based on the selection data the generation module provides one or more static libraries . These static libraries are configured for compiling by the build server or another device. The static libraries may be provided to the user using the network . The static library may be locked for use on the particular host device . For example the static library may incorporate the UUID which is associated with the hardware of the host device . The user may then compile the code for their application with the static libraries to generate the test executable . The test executable which includes the application and the static libraries may be known as an integrated test application. This test executable may then be executed on the host device . For example because the testing functionality is available within the test executable testing may take place on the host device for which root access is unavailable in the operating system.

In yet another implementation the source code for the application may be provided to the test server which may then generate the test executable using the static libraries . For example the user may upload the application source code using the test server interface module and initiate generation of the test executable by compiling the application source code and including the static libraries .

An application validation module generates an object level hierarchy for the application based on the assembly code generated by the assembly code generation module on the host device . In some cases the test server may iteratively query the assembly code on the host device to determine parent child hierarchical relationships between various objects associated with the application. The object level hierarchy may then be built based on these determined parent child relationships. In some embodiments the objects employed to build the object level hierarchy include those objects associated with a particular object type aspect or feature set of the application and may also be known as application objects . For example embodiments may provide an object level hierarchy of objects associated with UI elements of the application under validation or associated with memory management features of the application. The application validation module may also be configured to validate and verify that the application meets design and development requirements.

The application validation module is discussed in more detail with regard to U.S. patent application Ser. No. 13 631 919 filed on Sep. 29 2012 titled Application Validation Through Object Level Hierarchy Analysis to Manish Lachwani et al. which is incorporated by reference into this disclosure. In some implementations the object level hierarchy information may be provided to an input event module executing on the host device . This information may be used to generate the input event data.

A test script generation module accepts the input event data containing the input and the associated application objects and generates one or more test scripts . The test scripts may be provided in various formats such as the Ruby language as created by Yukihiro Matsumoto and derivatives the UIAutomation framework promulgated by Apple Corp. of Cupertino Calif. and so forth.

A test result module may be configured to use the one or more test scripts to exercise the application using a host device farm . The host device farm comprises a plurality of host devices under the control of the test server . The host device farm may include a plurality of host devices which differ from one another. For example the host device farm may have host devices with different operating systems operating system versions hardware configurations and so forth. The test result module may use the test script such as received from the host device of the user against the devices in the host device farm to generate test results . The test server interface module may be used to provide the test results to one or more of the build server the client devices or the host device .

The test server may also include a bug tracking module . The bug tracking module is configured to maintain information about bugs or issues associated with the application . In some implementations the test modules may include a bug tracking module configured to enable the test executable to interact with the bug tracking module . For example the user while testing on the host device may detect a bug. Without leaving the test executable using the functionality in the test executable the user may report that bug along with pertinent information such as system state input data and so forth associated with manifestation of the bug. For example the bug tracking module may implement at least a portion of the JIRA tools by Atlassian Inc. of Sydney Australia.

An application lifecycle management module may provide additional functions associated with governance development maintenance and so forth of the application . For example the application lifecycle management module may implement the HP Application Lifecycle Management tools by Hewlett Packard Company of Palo Alto Calif. In some implementations the test modules may include one or more modules configured to interact with the application lifecycle management module . For example the test executable may include a user interface to view application status as maintained by the application lifecycle management module of the test server .

The host devices may include smartphones tablet computers televisions set top boxes in vehicle computer systems home entertainment systems and so forth. The host device farm may include different varieties of host devices . These varieties may reflect differences in hardware software configuration and so forth. For example the host device farm may include host devices from manufacturer A manufacturer B and so forth. Furthermore these host devices may be of different generations capabilities and so forth. Continuing the example the host devices from the manufacturer A may include tablet computers smartphones and so forth.

In some embodiments the test server may employ one or more input output I O interfaces comprising an electrical or optical connection to couple to the one or more host devices in the host device farm . In one embodiment a universal serial bus USB 2.0 or better connection may be used to communicatively couple the host device to the test server . The USB connection may be used to transfer data from the host device to the test server or another test server using TCP as a communication protocol. The data may include the application testing applications screenshots test results diagnostic data and so forth.

The test server may incorporate other modules. These modules are discussed below in more detail with regard to . For example the test server may also incorporate a test validation module a test result module and so forth. The test validation module may be executed to validate and verify that the test package is a valid file type for the particular framework that is used for testing the application .

The client device the host device the build server or another device may receive the test results access the local results and so forth. The build server may provide at least a portion of the local results the test results or information based at least in part thereon to the client device or the host device for presentation to the users . In some implementations the information may be used to indicate portions of the application which have passed or failed testing on the host device the test server or both. The user may also specify how the information is to be presented to the user . For example at least a portion of the local results may be emailed to an email address provided by a user posted to the URL specified by a user and so forth.

The modules of the client device the host device the build server the test server and so forth are described in this disclosure as separate modules. In some implementations at least a portion of the functionality of these modules may be combined into a single module or incorporated into another module. Additionally the functionality may be distributed across the various devices. For example the client device may provide at least a portion of the functionality described by the build server .

In some implementations the build server the test server and the host device farm may be operated within an organization particular network and so forth. For example a software development company may choose to implement the system for their internal use only.

Using the system the user may select particular test modules of interest. Based on this selection the test executable may be generated which incorporates those test modules . By using this test executable on the host device the user may readily test their application using hardware they already have access to. Capabilities to use resources external to the host device such as the host device farm the bug tracking module the application lifecycle management module and so forth may be included in the test executable and accessed as desired by the user . As the needs of the user change new test modules become available and so forth the test executable may be easily regenerated.

By way of illustration and not as a limitation various options are provided with checkboxes allowing for selection. In other implementations spinners radio buttons text input fields and so forth may be used to acquire the selection data . The various options presented in the user interface reflect functions provided by one or more of the test modules . The user interface allows the user to select a subset of these test modules for use in the test executable .

The user interface may be configured as shown at to provide controls configured to accept information indicative of the root access to the host device . As illustrated here the user has checked the box indicating that they have a jailbroken device in which root access is available. In some implementations the determination of availability of root access may be made automatically. For example an application configured to detect root access may be installed on the host device executed determine root access availability and return this information to the test server .

Controls allow the user to specify runtime debugger options. Runtime debuggers may be provided for native applications HTML5 apps hybrid apps mobile web apps and so forth. By selecting runtime debugger options corresponding to the application the overall size and complexity of the test executable may be reduced relative to including all of the debugger options. For example in this illustration the user is testing an HTML5 app and so chooses only the HTML5 app runtime debugger. As a result the generation module will include the HTML5 runtime debugger and omit the native app debugger. Other debugging options may also be selected such as options for tethered execution when coupled to the client device forcing app crash to debug crash reporting viewing the application object level hierarchy and so forth.

The user may also use performance optimization controls to select options associated with performance optimization. For example as shown here the user may select to enable server side network capture of data for hypertext transport protocol HTTP traffic and use the PCAP packet capture functionality. The user has also selected to gather performance metrics such as the client side load time. The user has also selected to gather statistics including memory usage processor CPU usage battery condition thermal data frames per second of video delivered and network usage.

Other controls may be provided to allow access to other miscellaneous functions. For example an option may be provided for the application executing on the host device to be remotely controlled by another device such as the client device . As illustrated here the controls are selected to provide the built in HTTP server and to enable WebGL and Cookie toggles in the HTML5 webviews. These toggles allow the user to set various conditions in the execution environment.

The options selected by the user in the user interface are expressed in the selection data . In some implementations the test server interface module may implement an application programming interface API . This API may be used to receive the selection data . For example software executing on the build server may generate the selection data and provide the selection data to the test server using the API.

The test modules may include but are not limited to runtime debugger modules performance assessment modules testing modules miscellaneous modules and so forth. These modules may in turn comprise additional modules.

The runtime debugger modules provide runtime debugging functions. These may include a native debugger module configured to debug native applications an HTML5 debugger module configured to debug HTML5 applications and so forth. Other debugger modules may also be provided as well as modules supporting runtime debugging operations.

The performance assessment modules provide functions associated with assessing the performance and operation of the application the operating system the host device and so forth. Illustrated here is a network capture module . The network capture module is configured to store information exchanged between the host device and other devices using the network . The function tracing module allows for tracing of function entry and exit during execution of the application . A metric module is configured to gather performance metrics associated with the application . These metrics may include client side load time time to interact and so forth. The client side load time indicates amount of time required for the application to load. The time to interact provides an indication of how long until the application is responsive to user input. A statistic module is configured to acquire one or more statistics associated with the operation and state of the host device . For example the statistics may include memory usage CPU usage battery condition thermal status frames per second delivered to the display network usage and so forth.

The test module provides functionality associated with building maintaining and executing tests of the application . The test module may include a local test script generation module . The local test script generation module is configured to operate on the host device and generate one or more test scripts using inputs received on the host device . These test scripts may then be replayed on the host device or provided to the test server for execution on the host device farm . A display capture module allows for the capture of screenshots made to the display during execution of the test executable the application or both. By combining these screenshots video of interactions may be acquired. The screenshot data may be generated using a hardware based video encoder decoder of the host device . Use of the hardware based video encoder decoder allows for the high fidelity capture and presentation of images presented on the display of the host device . This high fidelity is based on the ability to capture the screenshots at the full resolution and at the full frame rate or redraw rate of the display.

The miscellaneous modules may include an HTTP server module remote control module and so forth. The HTTP server module provides an HTTP server which is configured to execute on the host device . This HTTP server may provide functionality to support the testing of the application which is configured to interact with an external server. By loading the HTTP server locally the user may test the application on the host device without using external resources. For example while on the train with no network access the user may continue to run tests on the application which make calls to the external server which is replaced by the HTTP server module . The remote control module allows another device to remotely control the host device . For example the client device another host device and so forth may use the remote control module to provide inputs and view outputs even when not physically present at the host device .

Based at least in part on the selection data the generation module is configured to generate the test executable one or more static libraries or both. For clarify of illustration and not by way of limitation the test executable is illustrated here.

A subset of test modules is made from the test modules based on the selection data . The test executable depicted in show the modules which were selected by the user in the user interface and as expressed in the selection data . The test executable in this illustration includes the HTML5 debugger module the network capture module the metric module the statistic module the display capture module and the HTTP server module . The other test modules not included in the selection data are not included in the subset of test modules and are thus not included in the test executable .

As described above in some implementations the static libraries associated with the subset of test modules may be provided for use. For example the static libraries may be delivered to the build server or another device for compiling. The device may generate the test executable which incorporates the application and the static libraries .

The following user interface controls may upon activation by the user provide additional information present one or more additional controls and so forth. The following controls are provided by way of illustration and not as a limitation. This illustration depicts a full set of the available controls. During actual deployment depending upon the selection data one or more of the following controls may be omitted or unavailable.

The user interface may include a title which may provide information to the user that they are not viewing the user interface associated with the application . Some of the controls may be associated with the host device . A device detail control may provide information about the host device upon activation. For example hardware version operating system and version memory available list of executing applications and so forth. A battery capacity control allows for presentation of information about the power state of the host device . A processor usage control provides information about the processors. An available memory control provides information about storage space on the host device . An app memory usage control provides information about the memory used by the application . An app thread count control provides information about the threads executing which are associated with the application . An FPS calculation control enables functionality to determine how many frames per second are being presented to the display of the host device .

Some controls allow the user to gather information about the application testing and so forth. A test management control allows the user to manage test information such as test cases test scripts and so forth. A test case may include one or more conditions or variables under which the application is determined to be working as intended. For example the test management control may be configured to enable the user to list existing test cases generate new test cases run test cases and so forth.

A bug tracking control allows the user to access the functionality associated with the bug tracking module . An application environment control allows the user to view modify or otherwise interact with environment variables in use by the application . An element hierarchy control allows for the inspection of user interface elements of the application .

An event playback recorder control allows the user to store and replay events occurring on the host device . A set playback rate control allows the user to change a speed of the playback.

A native debugger control allows the user to interact with the native debugger such as provided by the native debugger module . Likewise an HTML5 debugger control allows for interaction with the HTML5 debugger such as provided by the HTML5 debugger module . An HTML5 WebViews control allows the user to interact with the WebViews associated with the application .

A quick acceptance stress test control is configured to execute a predefined set of tests to stress the application . These tests may be defined by the user provided by the test server or another entity.

A default test bundle allows for execution of predefined tests. An exceptions reporter control allows for the control over crash reporting and handling. A control to send to host device farm may be provided. Upon activation one or more of information about the application current test case test scripts and so forth may be sent to the test server for execution on the host device farm .

Some controls may be provided which are associated with networking. A trace network calls control manipulates the tracing of network calls by the application . A reachability control is configured to generate an HTTP GET or other command to one or more addresses associated with the application . A resulting response or lack thereof from these addresses is used to determine whether the service called is reachable.

A network statistics control allows for the viewing of information about performance of a networking stack information about data transfer involving the host device and so forth. An HTTP server control allows the user to enable disable configure and otherwise interact with the HTTP server executing on the host device such as provided by the HTTP server module .

A network address control may provide information about how the network interface is configured gateway information and so forth. A packet capture control allows the user to manipulate package capture of data to and from the network by the host device .

A set random location control sets the host device to report a geographic location which differs from that as detected by an onboard positioning system of the host device . For example the global positioning system receiver of the host device may report a location of N 49.123 W 119.112 but after activation of the set random location control the location may change to N 48.002 W 118.921. The set random location control may be configured to operate within predetermined boundaries such as within a radius of a specified point within limits of a particular city and so forth.

An induce shake control is configured to simulate the host device being shaken and the corresponding output from sensors onboard the host device . For example the user may use the induce shake while remotely controlling the host device to simulate picking up and shaking the host device . Other controls may allow for inducing touch inputs and so forth.

A reload WebViews control allows for manually refreshing the WebViews. Likewise a repaint debug borders control allows the user to manually repaint borders in the application and so forth.

A JavaScript JS control allows for manipulation of how JavaScript is processed by the application . For example the JS control may allow for configuration of local storage control over access to the data of the application and so forth.

A delete caches and cookie control is configured to allow manipulation of the caches and cookies stored on the host device . The user may use a disable cache control to turn off caches on the host device . An enable remote debugging control may be configured to enable support for remote debugging. During remote debugging the host device is tethered to the client device and one or more of the test modules of the test executable support interaction between a debugger executing on the client device and the application executing on the host device .

The build server may include one or more input output I O interface s to allow the build server to communicate with other devices. The I O interface s may couple to one or more I O devices . In some embodiments the I O device s may be physically incorporated with the build server or be externally placed.

The build server may also include one or more network interfaces to enable communications between the build server and other networked devices. Such network interface s may include one or more network interface controllers NICs or other types of transceiver devices configured to send and receive communications over the network s . For example the network interface s may be configured to provide a Wi Fi connection compliant with one or more IEEE 802.11 standards such as 802.11g or 802.11n. The build server may also include one or more busses or other internal communications hardware or software that allow for the transfer of data between the various modules and components of the build server .

The build server includes one or more memories . The memory comprises one or more computer readable storage media CRSM . The CRSM may be any one or more of an electronic storage medium a magnetic storage medium an optical storage medium a quantum storage medium a mechanical computer storage medium and so forth. The memory provides storage of computer readable instructions data structures program modules and other data for the operation of the build server .

The memory may include at least one operating system OS module . The OS module is configured to manage hardware resources such as the I O interface s and network interface s and to provide various services to applications or modules executing on the processor s .

The memory may include a user interface module a source code control module the application one or more static libraries a build module or other module s . The user interface module is configured to provide a user interface to the one or more client devices . In some implementations the user interface may comprise a graphical user interface and may be delivered as hypertext markup language HTML data configured for presentation on the client devices .

The source code control module may be configured to provide control of source code check in check out of source code to users and so forth. The build module is configured to take associated source code and generate a build of the application . The application as built comprises source code configured for execution on the host device . In some implementations the test executable may be generated using the source code for the application and one or more static libraries from the test server . As described above the static libraries may be provided based on the selection data received from the user .

In some implementations the functionality of the build server may exist across one or more devices. For example a first build server may provide the user interface module while a second build server provides the source code control module a third build server provides the build module and so forth.

The memory may also include a datastore to store information for operations of the build server . The datastore may comprise a database array structured list tree or other data structure. In some implementations the datastore may store the test package before transmission to the test server the test results received from the test server and so forth.

The test package may include information including build information executable files custom tests or other data P such as testing configuration data. The build information may provide information indicative of libraries used host devices supported build version number information and so forth for a particular application build. For example the build information may indicate that the test package includes build 1229.203.23.1 which is configured for execution on a particular computing device model from manufacturer A . The executable files may include executable binaries markup language applications and so forth which are configured for execution on the host devices .

The custom tests comprise information indicative of tests test scripts designation portions of the application to test and so forth. For example the user may generate a custom test to exercise particular functionality of the application . These custom tests may comprise unit tests configured for use on the host devices in the host device farm . For example the custom tests may include those developed in the OCUnit testing framework promulgated by sente.ch from Sen te of Switzerland Calabash as promulgated by lesspainful.com of Denmark Frank as promulgated by testingwithfrank.com as associated with ThoughtWorks Inc. of Chicago Ill. The test package may include other data P such as user identification account information and so forth.

The custom tests may be based at least in part on previously generated test scripts . For example the test script based on input data from earlier use may be modified by the developer user and resubmitted as a custom test . Likewise the test results local results and so forth may also be stored.

Other data may also be stored such as the API URL associated with the test server historical test results version information code check in check out information build status and so forth. To this end the datastore may be configured to store and maintain information relating to the testing of the application including test success rates as well as failure reports augmented with context screenshots to pinpoint causes and activities at various crash times.

The I O interface s may couple to one or more I O devices such as described above. In some embodiments the I O device s may be physically incorporated with the test server or be externally placed.

The test server may also include one or more network interfaces to enable communications between the test server and other networked devices such as those depicted in . Such network interface s may include one or more NICs or other types of transceiver devices configured to send and receive communications over the network s . For example the network interface s may be configured to provide a Wi Fi connection compliant with one or more IEEE 802.11 standards such as 802.11g or 802.11n. The test server may also include one or more busses or other internal communications hardware or software that allow for the transfer of data between the various modules and components of the test server .

The test server may include one or more memories . The memory comprises one or more CRSM as described above. The memory provides storage of computer readable instructions data structures program modules and other data for the operation of the test server .

The memory may include at least one OS module . The OS module is configured to manage hardware resources such as the I O interface s and network interface s and to provide various services to applications or modules executing on the processor s .

The memory may store one or more of the test server interface module the application validation module the test script generation module the test result module the bug tracking module the application lifecycle management module and so forth.

The test server interface module is configured to accept and respond to the test package the input data or other information sent by the client device the host device the build server or both. The test server interface module may be configured to provide a user interface indicative of the one or more test modules such as shown above with regard to . The test server interface module may receive the user input provided through the user interface. The user input may be stored in the datastore with the user input indicative of one or more test modules . The selection data may be the user input from the datastore .

In another implementation the test server interface module may be configured to provide an application programming interface API . The API may be configured to receive data indicative of one or more test modules . This data may be stored in the datastore and accessed as the selection data .

The test server interface module may also be configured to send the test results or other information to the client device host device build server or a combination thereof. Use of the test server interface module allows the client device the host device and the build server to integrate the testing functionality of the test server into the automated or semi automated testing processes associated with the application build.

The generation module is configured to accept the selection data and access the test modules indicated therein. In one implementation the generation module may be configured to generate the test executable incorporating these test modules . For example where root access is available on the host device the test executable may be provided to the host device as a binary file ready for execution on the host device . This test executable may be used to analyze other applications executing on the host device .

When root access is unavailable on the host device the generation module may provide one or more static libraries based on the selection data . These static libraries are configured for compiling by the build server or another device. The user may then compile the code for their application with the static libraries to generate the test executable . The test executable may then be executed on the host device .

Other modules such as an unpack module and a test file validation module may also be present. The unpack module may be configured to unpack the test package . The unpacking may include one or more of separating out the application build tests configuration data build information and so forth.

An application validation module may be configured to generate an object level hierarchy for the application based on the assembly code generated by the assembly code generation module on the host device . In some cases the test server may iteratively query the assembly code on the host device to determine parent child hierarchical relationships between various objects associated with the application. The object level hierarchy may then be built based on these determined parent child relationships. In some embodiments the objects employed to build the object level hierarchy include those objects associated with a particular object type aspect or feature set of the application and may also be known as application objects .

The application validation module may also be configured to validate and verify that the application meets design and development requirements. The test file validation module may be configured to validate and verify that test package is a valid file type for the particular framework that is used for testing the application .

The test script generation module uses the input event data to generate one or more test scripts . This test script may be deployed to the host devices in the host device farm for use in testing the application . By using the test script the user inputs may be replayed to exercise the application without human intervention. As described above in some implementations the test script may have been modified by the developer user after creation. This replay may occur on the host device or on one or more of the devices in the host device farm .

The test result module is configured to generate test results based at least in part on information provided by one or more of the host devices . This information may be gathered during execution of the application .

The bug tracking module is configured to maintain information about bugs or issues associated with the application . The application lifecycle management module may provide additional functions associated with governance development maintenance and so forth of the application . In some implementations the bug tracking module the application lifecycle management module or both may be executed on a different server.

The memory may also include a datastore to store information for operations of the test server . The datastore may comprise a database array structured list tree program code or other data structure.

The datastore may also include the test package as received from the client device or the build server using the test server interface module . The selection data may also be stored.

Testing frameworks may also be stored in the datastore . Examples of various frameworks include OCUnit UIAutomation KIF Calabash Frank and so forth. These testing frameworks enable users to create tests that automate tasks of testing functionality of the application on one or more host devices . The one or more test scripts may also be stored in the memory . Host device output may also be stored. The host device output comprises information received from the host devices in the host device farm . The host device output is discussed in more detail below with regard to .

The test results may also be stored in the datastore along with other data . In some implementations the local results may also be received from the host device and stored. The test results local results or both may include failure reports screenshots for all of the test frameworks logs of each of the host devices user interface information and any additional files that the test creates. Additionally the test results may include information related to anomalous occurrences during testing of the application that have occurred by various causes other than by defects or bugs in the application . In order to follow up the causes of the failures detailed information on operating environments statuses of the system in use and so forth may also be included in the test results .

Similar to the devices described above the host device may include one or more I O interface s to allow the host device to communicate with other devices. The I O interface may be configured to provide a USB connection.

The I O interface may couple to one or more I O devices . The I O devices may include user input devices such as one or more of a keyboard a mouse a pen a game controller a voice input device a touch input device accelerometers motion sensors gestural input device and so forth. The I O devices may include output devices such as one or more of a display a printer audio speakers haptic output device and so forth. In some embodiments the I O devices may be physically incorporated with the host device or be externally placed.

The host device may also include one or more network interfaces configured to send and receive communications over the one or more networks . The host device may also include one or more busses or other internal communications hardware or software that allow for the transfer of data between the various modules and components of the host device .

The host device may include a hardware based video encoder decoder . While a hardware based video encoder decoder is described in some implementations a hardware based video encoder may be used. The video encoder decoder may be incorporated into a common die with the one or more processors or may be on a separate die. The video encoder decoder may be configured to enable the capture of screenshot data in the H.264 or MPEG 4 Part 10 compliant format.

The host device includes one or more memories . The memory comprises one or more CRSM as described above. The memory may include at least one OS module . The OS module is configured to manage hardware resources such as the I O interfaces and provide various services to applications or modules executing on the one or more processors . The OS module may comprise mobile operating systems configured for execution on mobile computing devices. The operating systems module may implement one or more of iOS from Apple Corp. of Cupertino Calif. Windows Mobile from Microsoft Corp. of Redmond Wash. Android from Google Corp. of Mountain View Calif. and its derivatives from various sources Palm OS from Palm Computing Inc. of Sunnyvale Calif. and its derivatives from various sources BlackBerry OS from Research In Motion Ltd. of Waterloo Ontario Canada or other operating systems such as VxWorks from Wind River Systems of Alameda Calif.

The memory may also include one or more of the application the test executable and other modules . The application is configured to execute on the host device . For example this may be the application received from the client device or the build server .

As described above the generation module may be configured to provide the test executable or one or more static libraries which may be included when compiling test executable . The test executable may thus be separate from the application under test or integrated with the application under test.

The test executable is depicted here as separate from the application and may be known as a separate test executable . When root access is available in the OS of the host device the test executable is able to acquire information about the application during execution. However when root access is unavailable the functionality of the test executable with respect to the application is curtailed due to the OS. In comparison the test executable incorporates the static libraries which are as well as the application . The test executable may be known as an integrated test executable . As a result even when the test executable is sandboxed the functionality provided by the static libraries are operational within the same sandbox as the application and thus at least some functionality is available.

The other modules may also be included in the host device . These other modules may include but are not limited to other applications not under test.

The memory also includes a datastore to store information for operations of host device . The datastore may comprise a database array structured list tree or other data structure. The datastore may store the local results . These local results may include host device output such as screenshot data generated by the test executable . The local results may also include device performance and or debug data and other information gathered by the test executable . Other local results L may also be stored. The local results may be presented to the user by the host device provided to the client device the build server the test server or a combination thereof.

In some implementations at least a portion of the input event data may be stored in the memory . One or more of the test scripts may also be stored in the memory . Other data may also be stored in the datastore .

Block accesses host device data indicative of one or more or more characteristics of the host device . The characteristics of the host device comprising one or more of an operating system version a processor type an available memory an input device UUID processor identifier device identifier and so forth. For example the user interface may provide inputs for the user to specify whether root access is available on the host device .

Block provides a user interface indicative of a plurality of test modules operable on the host device . In some implementations the user interface may present those test modules which are operable on the host device based on accessing the one or more characteristics. For example based on the operating system processor and so forth of the host device particular test modules may be available. The user interface may also accept a user preference as to whether to generate a separate test executable or provide the static libraries for creation of an integrated test executable.

Block stores selection data indicative of one or more of the test modules. As described above the selection data may be received by the user interface. For example the test server may store user inputs to the user interface . In other implementations the selection data may be received from another device such as from the build server using an API.

Block accesses the selection data . For example the selection data may be retrieved from the memory of the test server .

Block determines whether the integrated test executable or the separate test executable has been selected. In one implementation the separate test executable may be selected when root access to the host device is determined to be available. This determination may be based on an automated process inspecting the host device user input such as in the user interface with the control and so forth. The root access is configured to allow access and changes to an operating system executing on the host device the root access comprising one or more of at least one administrative permission or at least one administrative right. When block determines the preference for the separate test module the process proceeds to block .

Based at least in part on the selection data block generates a test executable that includes the selected test modules . The test modules may be configured to provide functions including but not limited to runtime debugging of the application performance assessment of the application generating a test script associated with execution of the application running the test script to exercise the application application bug tracking or recording the application during execution. As described above the test modules may include one or more of a native application debugger module a hypertext markup language application debugger module a network capture module a function tracing module a metric module a statistic module a test case creation module a display capture module a hypertext transport protocol server module a remote control module and so forth. The test executable may be configured with one or more digital rights techniques to limit operability to a particular user account host device and so forth. For example during generation the test executable may be configured such that the particular UUID of the host device is required for execution. As a result the test executable may execute on one host device having the UUID associated during generation by the test executable generation module but not on another with a different UUID.

The display capture module may be configured to record the application during execution. The recording may include one or more of storing screenshots of images presented for display by the host device storing user input to the host device storing audio for presentation by one or more speakers of the host device storing audio detected by a microphone storing output of the host device or storing input gathered by one or more sensors of the host device .

Block provides the test executable to the host device . As described above this is a separate test executable in that it is an application which is separate from the application under test. For example the test server may send the test executable to the host device using the network . In another implementation the test executable may be provided to another device which in turn provides the test executable to the host device .

In some implementation the test executable may have one or more references to one or more dynamic libraries configured to be linked to the test executable at load time or run time. The test server or another device may provide the one or more dynamic libraries to the host device .

Returning to block when the selection is to generate an integrated test executable the process proceeds to block . For example root access may be unavailable on the host device resulting in a selection of the integrated test executable. Block assembles one or more static libraries based at least in part on the selection data . The assembly may include retrieval of the static libraries from storage generation of the static libraries incorporation of digital rights techniques and so forth. For example the static libraries may be configured to be executable only on the particular host device .

Block provides the one or more static libraries . The one or more static libraries may be sent to the client device the host device the build server or another device. For example the static libraries may be sent using the network to a receiving device. As described above the receiving device may use the static libraries in conjunction with the source code of the application to generate the test executable .

As described above the test executable may be configured to provide a user interface to access one or more functions provided by the selected test modules . For example the test executable may include instructions configured to present the user interface . Instructions may be provided which are configured to be compiled into source code of the application wherein the instructions are configured to initiate presentation of a user interface associated with the selected test modules .

The determination of block as to whether the process proceeds to block or may be made based on availability of the root access on the host device or regardless of the availability of root access. For example the user may choose to integrate the test modules with the application using the static libraries to generate the test executable for execution on the host device which has root access available.

After block or block the process may proceed to block . Block receives the test script from the test executable executing on the host device . The test script may be based on input event data and comprise one or more instructions configured to when executed operate one or more application objects in the application .

Block executes a plurality of instances of the application on a plurality of host devices in a host device farm testing at least a portion of the plurality of instances of the application in the host device farm using the test script .

Block receives the test executable . The test executable comprises a subset of test modules . In some implementations the subset may include a display capture module configured to record a plurality of screenshots associated with the application during execution.

The subset of test modules may also include the test script generation module configured to generate one or more test scripts on the host device . Using the test script generation module the host device may generate one or more test scripts based at least in part on the execution of the application .

As described above the subset may be based on the selection data . The selection data may be based on user input such as to the user interface to select one or more test modules from a plurality of test modules .

Block executes the test executable on the host device . For example the user may launch the test executable . The test executable may be executed with root access to the operating system. Block executes one or more applications on the host device .

Block acquires local results associated with the one or more applications executing on the host device . As described above the local results may include the plurality of screenshots associated with the application during execution of the one or more applications . Data associated with the execution of the one or more applications may thus be included in the local results . For example the local results may include data from a first application and a second application which are indicative of the execution of the respective applications . A comparison may then be generated between at least a portion of the data from each of the applications . This comparison may be used to assessment benchmarking evaluation and so forth. For example performance of the application may be tested against a prior version of the application .

Block stores the local results in the memory . As described above the local results may be provided to the client device the build server the test server or another device.

Block receives an input invoking a user interface associated with functions provided by the one or more test modules . For example a particular touch gesture or keyboard input may be configured to present the user interface on the display of the host device . Block presents the user interface. With the user interface the user is able to interact with the testing and associated functionality provided by the test modules .

In some implementations additional blocks may send the one or more test scripts generated by the test script generation module to the test server . The test server may then send the test script to the plurality of host devices in the host device farm for testing.

Block receives one or more static libraries . The one or more static libraries are associated with one or more test modules . The static libraries may be received from the test server .

Block accesses source code of the application undergoing test. For example the source code may be stored on the build server .

Block links the one or more static libraries to the source code of the application . Block modifies the source code to include one or more instructions configured to invoke a user interface associated with the functions provided by the one or more static libraries . For example a particular touch sensor gesture may be configured to open the user interface .

Block compiles the source code to generate the test executable which includes the one or more static libraries . The test executable now includes the original functions of the application as designed by the developer as well as the test functions provided for in the test modules indicated by the selection data .

Block sends the test executable to the host device . For example the build server may use the network to send the test executable to the client device . The client device may then be connected via a tether to the host device and install the test executable . The test executable may be configured to provide local results when root access to the host device is unavailable.

Block receives the test executable including one or more test modules . For example the build server using the static libraries as described above with regard to may have generated the test executable .

Block executes the test executable . Block acquires the local results of the test executable . As described above where the test executable is sandboxed the information may be limited to that which is accessible from within the sandbox.

Block stores the local results . For example the local results may be stored in the memory . As described above the local results may be provided to the client device the build server the test server or another device.

Block receives an input invoking a user interface associated with functions provided by the one or more test modules . For example a particular touch gesture or keyboard input may be configured to present the user interface on the display of the host device . Block presents the user interface. With the user interface the user is able to interact with the testing and associated functionality provided by the test modules .

In some implementations additional blocks may send the one or more test scripts generated by the test script generation module to the test server . The test server may then send the test script to the plurality of host devices in the host device farm for testing.

As development continues the test modules are updated needs of the user change and so forth the system may be used to easily provide test executables tailored for the evolving situation. The test executable allows the user to implement comprehensive testing on the host device itself while retaining the ability to leverage resources such as the host device farm for additional testing. The user is thus able to take advantage of the ability to implement standalone testing as well as integrating with external resources.

Those having ordinary skill in the art will readily recognize that certain steps or operations illustrated in the figures above can be eliminated combined subdivided executed in parallel or taken in an alternate order. Moreover the methods described above may be implemented as one or more software programs for a computer system and are encoded in a computer readable storage medium as instructions executable on one or more processors.

Separate instances of these programs can be executed on or distributed across separate computer systems. Thus although certain steps have been described as being performed by certain devices software programs processes or entities this need not be the case and a variety of alternative implementations will be understood by those having ordinary skill in the art.

Additionally those having ordinary skill in the art readily recognize that the techniques described above can be utilized in a variety of devices environments and situations. Although the present disclosure is written with respect to specific embodiments and implementations various changes and modifications may be suggested to one skilled in the art and it is intended that the present disclosure encompass such changes and modifications that fall within the scope of the appended claims.

