---

title: Graph oriented programming and execution
abstract: Graph oriented programming and execution. According to one embodiment of the invention, execution of a program includes automatically discovering and building a graph. The graph is to represent parent child relationships between combinations. Each combination is a specific method and a specific object-oriented instance. Based on a first of the combinations, other combinations are determined by iteratively discovering the child combinations for already discovered parent combinations. The graph is built of nodes coupled with links. Each of the plurality of combinations is identified by one of the nodes. Each of the parent child relationships is represented by one of the links. Execution of the program also includes executing the graph in an order indicated by the links until the root node is reached. Execution of each of the parent nodes includes executing the combination identified by that parent node to generate an output using the outputs of its child node(s).
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08607207&OS=08607207&RS=08607207
owner: Murex S.A.S.
number: 08607207
owner_city: Paris
owner_country: FR
publication_date: 20130315
---
This application is a continuation of application Ser. No. 13 455 756 filed Apr. 25 2012 which is a continuation of application Ser. No. 11 633 098 filed Dec. 1 2006 which issued as U.S. Pat. No. 8 191 052 on May 29 2012 which are hereby incorporated by reference.

Embodiments of the invention relate to the field of computers and more specifically to the field of programming and executing code with a runtime.

Object oriented programming is a computer programming paradigm. The idea behind object oriented programming is that a computer program may be seen as comprising a collection of individual units called objects or instances that act on each other as opposed to a traditional view in which a program may be seen as a collection of functions or simply as a list of instructions to the computer. An object is a language mechanism for binding data with methods that operate on that data. Each object is capable of being called through methods processing data and providing results to other objects. Each object can be viewed as an independent machine or actor with a distinct role or responsibility.

A reflective object oriented language is a programming language that has a particular set of characteristics e.g. classes objects instances inheritance reflection etc. whereas a reflective object based language is sometimes used to label a programming language that has some subset of those characteristics e.g. objects . For purposes of this document the phrases object oriented source code and object oriented code will be used to refer to code written in a language that has such characteristics e.g. code written in a reflective object oriented language code written in a reflective object based language . While procedural languages non reflective object oriented languages and non reflective object based languages are programming languages that do not typically support such characteristics transformation techniques may be used to provide such characteristics e.g. through emulation to code properly written in such languages and thus such techniques transform such languages into a reflective object based language or reflective object oriented language. These techniques need not emulate all characteristics of object oriented or based languages but may emulate only those characteristics which are of interest to the rest of this document For purposes of this document the phrases object oriented source code and object oriented code will also be used to refer to such transformed procedural non reflective object oriented and non reflective object based language code. By way of example and not limitation this document primarily describes object oriented source code written in a reflective object oriented language. Also the terms object and instance are used interchangeably herein.

Used mainly in object oriented programming the term method refers to a piece of code that is exclusively associated either with a class called class methods static methods or factory methods or with an object called instance methods . Like a procedure in procedural programming languages a method usually consists of a sequence of statements to perform an action a set of input parameters to parameterize those actions and possibly an output value of some kind that is returned.

When programmers write a program using an object oriented language the resulting code can be conceptually viewed as including four basic types of code. The first type includes commands that operate on input instance s to provide output instance s referred to herein as transformation code typically written as methods referred to herein as transformation methods . The second type includes instance instantiation commands that cause the runtime to instantiate instances of classes referred to herein as instance instantiation code . The third type includes property manipulation commands referred to herein as data preparation code to invoke property methods accessors mutators etc. of the above instances. The fourth type includes sequences of commands that cause method invocation sequencing using the appropriate instances where the appropriate instances include the instances to use as arguments the instances to be used by instance methods and the meta class instances used by class methods to specify what transformation methods of what instances to invoke in which order and with which parameters of which instances responsive to the changes made by data preparation code referred to herein as manual invocation sequencing code . The manual invocation sequencing code is sometimes written as methods separate from the transformation methods and thus the manual invocation sequencing code includes sequences of invocation commands for the transformation methods. A program typically iterates between data preparation code and manual invocation sequencing code which may also dip into the instance instantiation code which in turn invokes transformation code which may also dip into the instance instantiation code and data preparation code types . It should be noted that this is a conceptual representation of a program and thus should not be taken as an absolute with regard to how to view a program.

The term runtime is used herein to refer to a program or library of basic code that runs other code written in the same and or a different language. Thus a runtime is a collection of utility functions that support a program while it is running including working with the operating system to provide facilities such as mathematical functions input and output. These make it unnecessary for programmers to continually rewrite basic capabilities specified in a programming language or provided by an operating system. Since the demarcation between a runtime and an operating system can be blurred the term runtime is used herein to refer to code separate from the operating system and or code that is part of the operating system.

Early runtimes such as that of FORTRAN provide such features as mathematical operations. Other languages add more sophisticated features e.g. memory garbage collection often in association with support for objects. More recent languages tend to have considerably larger runtimes with considerably more functionality. Many object oriented languages also include a system known as the dispatcher and class loader. The Java Virtual Machine JVM is an example of such a runtime it also interprets or compiles the portable binary Java programs byte code at run time. The common language runtime CLR framework is another example of a runtime.

One framework within which applications are provided to end users includes three basic divisions. The first division includes the creation of the operating system and runtime. This first division is performed by programmers with highly advanced programming skills. When working in this division programmers are respectively referred to as operating system programmers and runtime programmers. When creating a runtime for an object oriented language the runtime programmers include support for executing the various types of commands used in transformation code instance instantiation code data preparation code and manual invocation sequencing code e.g. instance instantiation commands data preparation commands and method invocation commands .

The second division includes the creation of object oriented application source code to be run by the runtime. The second division is again performed by programmers with highly advanced programming skills as well as an understanding of the business objectives of the application. When working in this division programmers are referred to as application programmers. When creating an application in an object oriented programming language the application programmers write the specific transformation code instance instantiation code data preparation code and manual invocation sequencing code for the specific application being created. As part of this if the application requires a graphical user interface the application programmers also design and code the graphical user interface for the specific application and thus are also referred to as application designers.

The third division includes the use of application programs being run by the runtime. The third division is performed by end users that need not have any programming skills.

The greatest costs typically associated with the creation of an application involve the debugging and or optimization of the manual invocation sequencing code. For each opportunity for data to change the application programmer must consider its effect and write manual invocation sequencing code to cause the appropriate transformation methods of the appropriate instances to be invoked in the appropriate order with the appropriate inputs. Exemplary mistakes made by application programmers include 1 invoking the appropriate transformation methods of the appropriate instances in the wrong order 2 forgetting to include commands to cause the one or more required transformation methods of instances to be invoked responsive to some data being changed 3 including commands to cause unnecessary transformation methods of instances to be invoked responsive to some data being changed e.g. including commands to invoke transformation methods of instances that are not affected by the change in data etc.

By way of example one technique of generating manual invocation sequencing code is the use of the observer pattern sometimes known as publish subscribe to observe the state of an instance in a program. In the observer pattern one or more instances called observers or listeners are registered or register themselves to observe an event which may be raised by the observed object the subject . The observed instance which may raise an event generally maintains a collection of the registered observers. When the event is raised each observer receives a callback from the observed instance the observed instance invokes a notify method in the registered observers . The notify function may pass some parameters generally information about the event that is occurring which can be used by the observers. Each observer implements the notify function and as a consequence defines its own behavior when the notification occurs.

The observed instance typically has a register method for adding a new observer and an unregister method for removing an observer from the list of instances to be notified when the event is raised. Further the observed instance may also have methods for temporarily disabling and then reenabling calls to prevent inefficient cascading of a number of related updates. Specifically callbacks called in response to a property value change often also change values of some other properties triggering additional callbacks and so on.

When using the observer pattern technique application programmers writing manual invocation sequencing code specify what methods of what instances to call in which order and with which inputs by registering unregistering disabling and reenabling observers to different observed instances as well as writing the notify and callback methods for each. More specifically the relationship between observer and observed instances is locally managed by the observed instance alone without synchronization with other observed instances within the observer pattern and thus the manual invocation sequencing code needed to synchronize events from multiple observed instances is typically part of the specific callback methods of each observer.

Typical runtimes use an overwriting volatile call stack to track currently invoked uncompleted calls. An overwriting volatile call stack is overwriting in that it pops off and discards entries as each call is completed and volatile in that it is discarded and rebuilt on every execution. Typical runtimes use overwriting volatile call stacks because typical runtimes combine the building of the overwriting volatile call stack with the actual invocation of the appropriate transformation methods of the appropriate instances with the appropriate inputs responsive to execution of the manual invocation sequencing code. In sum responsive to execution of manual invocation sequencing code a typical runtime determines the transformation method instance sequencing call by call as each call is made and maintains the overwriting volatile call stack to track only currently invoked uncompleted calls.

Object Relational mapping is a programming technique that links relational databases to object oriented language concepts creating in effect a virtual object database. Some object relational mappers automatically keep the loaded instances in memory in constant synchronization with the database. Specifically after construction of an object to SQL mapping query first returned data is copied into the fields of the instances in question like any object SQL mapping package. Once there the instance has to watch to see if these values change and then carefully reverse the process to write the data back out to the database.

Hibernate 3.0 is an object relational mapping solution for Java and CLR Jboss Inc. of Atlanta Ga. . Thus Hibernate provides a framework for mapping an object oriented domain model to a traditional relational database. Its goal is to relieve the developer from some common data persistence related programming tasks. Hibernate takes care of the mapping from classes to database tables and from object oriented data types to SQL data types as well as providing data query and retrieval facilities. Hibernate is instance centric and builds graphs representing relationships between instances.

Inversion of Control also known as IOC is an object oriented programming principle that can be used to reduce coupling the degree to which each program module relies on each other module inherent in computer programs. IOC is also known as the Dependency Inversion Principle. In IOC a class X depends on class Y if any of the following applies 1 X has a Y and calls it 2 X is a Y or 3 X depends on some class Z that depends on Y transitivity . It is worth noting that X depends on Y does not imply Y depends on X if both happen to be true it is called a cyclic dependency X can t then be used without Y and vice versa.

In practice if an object x of class X calls methods of an object y of class Y then class X depends on Y. The dependency is inverted by introducing a third class namely an interface class I that must contain all methods that x might call on y. Furthermore Y must be changed such that it implements interface I. X and Y are now both dependent on interface I and class X no longer depends on class Y presuming that x does not instantiate Y . This elimination of the dependency of class X on Y by introducing an interface I is said to be an inversion of control or a dependency inversion . It must be noted that Y might depend on other classes. Before the transformation had been applied X depended on Y and thus X depended indirectly on all classes that Y depends on. By applying inversion of control all those indirect dependencies have been broken up as well. The newly introduced interface I depends on nothing.

The Spring Framework is an open source application framework for the Java platform that uses IOC and dependency inversion. Specifically central in the Spring Framework is its Inversion of Control container that provides a means of configuring and managing Java objects. This container is also known as BeanFactory ApplicationContext or Core container. Examples of the operations of this container are creating objects configuring objects calling initialization methods and passing objects to registered callback objects. Objects that are created by the container are also called Managed Objects or Beans. Typically the container is configured by loading XML files that contain Bean definitions. These provide all information that is required to create objects. Once objects are created and configured without raising error conditions they become available for usage. Objects can be obtained by means of Dependency lookup or Dependency injection. Dependency lookup is a pattern where a caller asks the container object for an object with a specific name or of a specific type. Dependency injection is a pattern where the container passes objects by name to other objects either via constructors properties or factory methods. Thus the Spring Framework is memory centric and builds graphs representing relationships between instances.

Javadoc is a tool that parses the declarations and documentation comments in a set of Java source files and produces a corresponding set of HTML pages describing by default the public and protected classes nested classes but not anonymous inner classes interfaces constructors methods and fields Sun Microsystems Inc. of Santa Clara Calif. . Javadoc can be used to generate the API Application Programming Interface documentation or the implementation documentation for a set of source files. Javadoc is class and method centric and builds graphs representing the relationships between the combination of classes and their methods.

Another system for designing software applications includes graphs of objects analyzed by an interpreter to represent and reproduce a computer application. This system utilizes prewritten programming classes stored in code libraries which can be written to follow the design patterns described in Design Patterns by Gamma et al Addison Wesley 1995 Patterns in Java by Grand Wiley Computer Publishing 1998 and or high level Computer Aided Software Engineering CASE tools. More specifically some such classes are based on the Observer behavioral pattern. The prewritten code libraries represent application state nodes processing logic and data flow of the system between various application states i.e. the pre written data elements of the application so that a user need not write edit or compile code when creating a software application. Instead a user manually edits a software application in a Graphical User Interface by editing visual objects associated with a current application state node such as data within the application state node or processes performed within the application state node. Then based on the changes made by the user to the current application state node the interpreter displays the updated application state to the user for the application state which has just been edited. The system may then transition along a user defined transitional edge to another application state where the user may optionally edit the next application state or the transitional edge. Changes to a graph may be made to instances of the graph which are implemented by the interpreter while the software application is running.

This system for designing software applications may include visual representations of a running software application that can be made usable with an application controller. When a user changes visual objects representing the running software application the controller uses the input to induce the interpreter to make the change to the graph. The controller then waits for more changes. Further visual representations of such software applications may be imported or exported as XML documents that describe the visual representation of the application and thereby the software application.

In order to edit and or create a software application in the form of a visual representation of nodes directed edges and application states an application program interface and an application editor may further be included in the system. Key words and associated definitions from the pre written code libraries enable application developers to manually define a software application processing steps as well as the visual representation of a software application by providing graphical representations within an editor of a graph application which closely correlates to the actual application structure. A user defines a new application through an application definition wizard which after certain preliminary matters are fulfilled displays the new application as a graph component within the editor workspace. A user further interacts with an application by making selections from displayed lists of pre created possible application components and dragging and dropping components onto the workspace using a PC s mouse and keyboard. A user may select components and drag them over existing components. When a new component is dropped on an existing component the new component becomes a child of the existing component within an application graph. The relationships of components within the application are manually defined by the user s selections within the editor. Thus a tree structure representing an application is built by the user. As the application is created a user can select an application navigator viewer to display a tree view of the constructed application making it possible to select and edit any component of the application. The editor interface processes user inputs and selections including creating or deleting application elements updating component attributes and updating display properties of an application.

The system described above while utilizing visual representations of software applications may also be used as a visual programming tool for defining and updating relational databases. The system utilizes XML descriptions of visual representation of software applications. A tool parses and interprets the XML descriptions to produces equivalent relational database table schemas as well as changes thereto. When data is changed within a visual representation of a software application a description of the change is stored along with other changes in a journal file and then processed as a group. An intermediate program a java application operating on its own thread performs transactions between the visual representation of the software application and the relational database. The java application polls i.e. checks the journal of changes to nodes of the visual representation i.e. data in database and if there are changes makes the changes to the database. Thus by altering data within the visual representation the system updates a database. A similar application stands between the visual representation of the software application and the database to handles requests for data from the database.

Another system for analyzing software is called a Code Tree Analyzer CTA . A CTA analyzes static source code written in an object oriented programming language. The CTA generates a symbol table and a call tree from the static source code. Using the symbol table the CTA generates a class diagram. Likewise using the call tree the CTA generates a sequence diagram. The class diagram illustrates the relationship between a user selected class and classes related to the user selected class. The sequence diagram illustrates the sequence in which different methods are called. Using both the class diagram and the sequence diagram the CTA generates a design artifact representative of the static source code. When the user modifies the design artifact the CTA identifies impacted portions of the source code using the sequence diagram. The design artifact is used for code maintenance and or reverse engineering of the static source code.

A method and apparatus for graph oriented programming and execution are described. According to one embodiment of the invention execution of an object oriented program includes automatically discovering and building in a computer a graph. The graph is to represent a number of combinations and parent child relationships between them. Each of the parent child relationships has one of the combinations as a parent combination and another of the combinations as a child combination. Each of the combinations is a combination of a specific object oriented instance and a specific method to be executed on that specific object oriented instance. Execution of a first of the combinations will generate a current output of interest. Based on the first combination the others of the combinations are determined by iteratively discovering the child combinations for already discovered parent combinations. A graph is built of nodes coupled with links. Each of the plurality of combinations is identified by one of the nodes. Each of the links identifies one of the nodes as a parent node and another of the nodes a child node for that link. Each of the parent child relationships is represented by one of the links such that the parent node of that link identifies the parent combination and the child node of that link identifies the child combination. The graph has a root node a number of intermediate nodes and a number of end nodes. The root node identifies the first combination and has a set of one or more child nodes. Each of the intermediate nodes has a set of one or more parent nodes and a set of one or more child nodes. At least one of the intermediate nodes has the root node as a parent node and at least one of the intermediate nodes has another of the intermediate nodes as a parent node. Execution of an object oriented program also includes executing the graph in the computer in an order indicated by the links until the root node is reached and executed. The executing of the graph includes executing each of the parent nodes and execution of each of the parent nodes includes executing the specific method on the specific object oriented instance of the combination identified by that parent node to generate an output for that parent node using as inputs the outputs for that parent node s set of child nodes.

In the following description numerous specific details such as logic implementations opcodes means to specify operands resource partitioning sharing duplication implementations types and interrelationships of system components and logic partitioning integration choices are set forth in order to provide a more thorough understanding of the invention. It will be appreciated however by one skilled in the art that the invention may be practiced without such specific details. In other instances control structures data structures and full software instruction sequences have not been shown in detail in order not to obscure the invention. Those of ordinary skill in the art with the included descriptions will be able to implement appropriate functionality without undue experimentation.

Unless otherwise specified dashed lines in the figures with the exception of dashed dividing lines are used to represent optional items in the figures. However it should not be presumed that all optional items are shown using dashed lines but rather those shown in dashed lines were chosen for a variety of reasons e.g. they could be easily shown to provide greater clarity etc. .

References in the specification to one embodiment an embodiment an example embodiment etc. indicate that the embodiment described may include a particular feature structure or characteristic but every embodiment may not necessarily include the particular feature structure or characteristic. Moreover such phrases are not necessarily referring to the same embodiment. Further when a particular feature structure or characteristic is described in connection with an embodiment it is submitted that it is within the knowledge of one skilled in the art to affect such feature structure or characteristic in connection with other embodiments whether or not explicitly described.

In the following description and claims the terms coupled and connected along with their derivatives may be used. It should be understood that these terms are not intended as synonyms for each other. Rather in particular embodiments connected may be used to indicate that two or more elements are in direct contact with each other. Coupled may mean that two or more elements are in direct contact. However coupled may also mean that two or more elements are not in direct contact with each other but yet still co operate or interact with each other.

In some cases the operations of flow diagrams are described with reference to the exemplary embodiments of the other block diagrams. However it should be understood that the operations of the flow diagrams can be performed by embodiments of the invention other than those discussed with reference to these other block diagrams and that the embodiments of the invention discussed with reference to these other block diagrams can perform operations different than those discussed with reference to the flow diagrams.

The techniques shown in the figures can be implemented using code and data stored and executed on one or more computers. Such computers store and communicate internally and with other computers over a network code and data using machine readable media such as machine storage media e.g. magnetic disks optical disks random access memory read only memory flash memory devices and machine communication media e.g. electrical optical acoustical or other form of propagated signals such as carrier waves infrared signals digital signals etc. . In addition such computers typically include a set of one or more processors coupled to one or more other components such as a storage device a number of user input output devices e.g. a keyboard and a display and a network connection. The coupling of the set of processors and other components is typically through one or more busses and bridges also termed as bus controllers . The storage device and network traffic respectively represent one or more machine storage media and machine communication media. Thus the storage device of a given computer system typically stores code and data for execution on the set of one or more processors of that computer. Of course one or more parts of an embodiment of the invention may be implemented using different combinations of software firmware and or hardware.

According to one aspect of the invention a producer is at least a specific instance or object and a specific method such that if the producer is executed during run time the specific method is executed on the specific instance. Thus a given producer is instantiated from a given instance and a given method associated with that instance. Like classes instances and methods producers are basic elements or constructs manipulated by the runtime. Thus the instantiation of a producer is interpreted and tracked by the runtime and thus the runtime tracks the combination of instances and methods represented by producers. In other words a producer is a runtime instantiatable construct that is tracked by the runtime that is executed by the runtime and that includes at least an instance and a method associated with that instance such that the runtimes execution of the producer results in the method of the producer being executed on the instance of the producer. Also the method of a producer has associated with it a producer dependency declaration that identifies with a set of zero or more producer dependencies a set of zero or more producers for the given producer. Specifically producer dependencies are declared for methods using producer dependency declarations the producer dependency declaration for a given method may include zero or more producer dependencies and each producer dependency identifies a set of zero or more producers. Thus producer dependency declarations and the producer dependencies they define are interpreted and tracked by the runtime and thus the runtime tracks the relationships between producers indicated by the producer dependency declarations.

Where a given producer is dependent on a set of one or more other producers the runtime will ensure execution of the set of other producers prior to the given producer. Thus the producer dependency declarations represent execution relationships between producers while producers represent operations to be performed methods and instances. While in some embodiments of the invention allow dependencies of parent producers on child producers to be declared in the producer dependency declaration associated with the method of the parent producer the producer dependency declaration of the parent producer identifies any child producers referred to herein as downwardly declared other embodiments of the invention also allow dependencies to be declared in the producer dependency declaration associated with the method s of child producer s the producer dependency declaration of the child producer identifies one or more parent producers referred to herein as upwardly declared .

In different embodiments of the invention a producer identifies additional things. For example while in some embodiments of the invention a producer is at least an instance and method associated with that instance in other embodiments of the invention a producer is a class an instance of that class and a method associated with that instance e.g. a producer may directly include a class instance and method a producer may directly include an instance and a method while indirectly identifying a class of that instance through a reference e.g. a reference in the instance . While the invention may be used in the context of code written in different programming languages e.g. object oriented code written in a reflective object oriented language object oriented code written in a reflective object based language code written in a procedural non reflective object oriented non reflective object based language and transformed into reflective object oriented language code embodiments of the invention will be described by way of example and not limitation with reference to reflective object oriented programming languages and with reference to producers that directly include classes instances and methods. Also while in one embodiment of the invention the method of a producer is an instance method a method that can use instance fields in addition to any inputs received as arguments alternative embodiments of the invention may also or alternatively support the method of a producer being a class method methods that receive all inputs as arguments and or uses instance independent variables where the method of a producer is an instance method the instance of that producer is an instance of a class while where the method of a producer is a class method the instance of that producer is a meta class instance representing the class .

During run time an instance of the class is instantiated. The instance includes the data of the fields of the class . In addition a producer is instantiated where the producer identifies the class the instance of the class which has associated with it the method of the class and the method of the class . The producer dependency declaration identifies to the runtime a set of zero or more producers referred to as child producers of the producer that must be executed before execution of the producer . In other words the producer depends on the set of zero or more producers . In addition to or instead of consuming outputs of the set of producer the producer may consume data of the instance . In addition the producer provides at least one output which output may be internal to the instance and thus modify the data of the instance and or may be external either way the output of the producer may be consumed by a set or zero or more other producers referred to as parent producers of the producer . As indicated previously and described in more detail later herein the producer dependency declaration in some embodiments of the invention may also identify to the runtime zero or more of the producers .

It should be understood that the inputs and outputs of producers are based on the inputs and outputs of the methods on which those producers are based. As such these input and outputs may represent multiple parameters having a variety of data structures.

The producer dependency declaration for a given method identifies at run time the set of zero or more producers to be instantiated and executed. By way of example where a producer dependency declaration e.g. producer dependency declaration for a given method e.g. method identifies a producer dependency on a given producer which given producer identifies a first class a first instance of that class and a first method of that first class e.g. one of the set of producers then the producer dependency declaration of the given method identifies to the runtime that the first instance is to be instantiated if not already and that the first method is to be used to instantiate the given producer for the first instance in these examples first does not mean location or order .

In operation when during run time a given set of one or more producers are designated as being of interest and have producer dependencies declared for them the runtime 1 automatically generates discovers builds and optionally resolves a set of one or more graphs which may be multi level and may be of a variety of shapes e.g. chain tree from the given set of producers designated as being of interest down to source producers based on the producer dependency declarations and 2 sequences execution of producers of the set of graphs to generate the output s of the given set of producers designated as being of interest. Thus the runtime uses the producer dependency declarations to determine what methods with what arguments to execute on what instances and when for synchronization purposes.

Thus producer dependencies represent the sequencing of execution of producers to the runtime. However in addition to indicating the sequencing of execution producer dependencies may represent different input to output relationships in different embodiments of the invention. For example different embodiments of the invention may support one or more of argument producer dependencies field producer dependencies and sequencing only producer dependencies sequencing only producer dependencies are referred to herein with the shorthand sequencing producer dependencies . While each of argument producer dependencies field producer dependencies and sequencing producer dependencies represent execution sequencing relationships between producers argument and field producer dependencies additionally represent data of which the runtime is aware. Specifically an argument producer dependency causes the runtime to map the output of a child producer as an input parameter to a parent producer whereas a field producer dependency indicates use of a field of an instance. Regardless of the input to output relationship represented by a producer dependency proper use of producer dependencies ensures that the producers accessing information are sequenced after the producers that impact that information.

Sequencing dependencies may be used for a variety of purposes including ensuring the order of execution between producers that modify data in a manner of which the runtime is not aware and producers that consume that data a child producer may write its outputs in a way that requires the method of the parent producer to include code to access that output e.g. a method that impacts the environment by affecting an output that is not the regular producer output and as such that is not detected by the runtime such as a method that sets a global variable that sets a field in an instance which is not the producer output that impacts an external data source etc. Thus a sequencing dependency reflects a dependency of a parent producer on a child producer but requires outputs that need to be provided if any from one to the other occur through the writing of code e.g. code in the method of the child producer to write an output to a given mechanism such as set a global variable impact an external data source set a field of an instance which is not the producer output etc. and code in the method of the parent producer to read that output from the given mechanism . In this way sequencing dependencies allow the runtime to synchronize execution of any parent producers that rely on an output that the runtime cannot detect.

In one embodiment of the invention the producer dependency declaration for a given method identifies only direct dependencies on producers e.g. direct descendents children in contrast with indirect descendents grand children great grand children etc. . In such an embodiment each producer dependency declaration provides only a single tier or layer of producers whose outputs may be used directly by a producer instantiated from the given method leaving discovery building resolution of additional layers of the producer graph s to the runtime s processing of other producer dependency declarations.

A producer can be viewed as a set of multiple identifiers one identifier for each additional level of granularity specified class instance method etc. . In addition some embodiments of the invention implement each identifier as a separate key while other embodiments have certain identifiers share a key. By way of example some embodiments of the invention implement a producer as a class instance and method triplet and implement keys such that each part of the triplet is identified by a separate key a class key instance key and method key and the producer is identified by the combination of the class key instance key and method key the producer key .

Embodiments of the invention that use keys may vary in the uniqueness of the keys used. For example in one embodiment of the invention each class key is unique each instance key is unique across all instances of all classes and each method key is unique across all methods of all classes. As another example in other embodiments of the invention each class has a unique key each instance of a given class has a unique key across the class instances and each method of a class has a unique key across the class methods but instances of different classes may have the same instance key and methods of different classes may have the same method key this later approach will be used in the remainder of the document by way of example and not limitation. For example assume a first class includes methods and has a key for each of these methods that is unique within the first class then the instances of this class which will each have a unique key as to each other have the same method keys associated with them. As another example assume a different second class includes methods be some all or none the same as the methods of the first class that have the same method keys as those used for the first class as such an instance of this different class may have associated with it the same method keys as associated with an instance of the first class.

The use of keys allow for a variety of features including 1 the tracking of each entity identified by a producer s identifiers e.g. the tracking of each class instance and method 2 several parent producers unaware of their mutual existence to connect to the same child producer based on their producer dependency declarations which specify producer dependencies using the producer keys etc. In one embodiment of the invention the instance key is an instance of a class InstanceKey holding two elements an instance key nature indicating if the key identifier is a reference to the instance or another object such as a string and a key identifier which can either be a reference to the instance or another object such as a string . The storing of an instance reference in the instance key spares the programmer from inventing a name to identify these instances.

In the context of the above discussion regarding a producer being viewed as a set of multiple identifiers with one identifier for each additional level of granularity specified in one embodiment of the invention the various supported relationships between a producer and its children and parents are those in which at least one such identifier is different between a producer and its set of zero or more parent producers and one such identifier is different between a producer and each of its set of zero or more child producers. By way of providing some exemplary relationships assume that a first producer is instantiated where the first producer is a first instance of a first class and a first method of that first class and assume that the producer dependency declaration for that first method identifies at run time a second producer as a child then the second producer may be 1 the first instance of the first class and a second method of that first class 2 a second instance of the first class and a second method of that first class 3 a second instance of the first class and the first method of the first class or 4 an instance of a second class and a method of that second class. In such case the first producer is dependent on the second producer thus representing an input to output relationship of the first producer on the second producer. Various relationships and combinations of those relationships are described below for one embodiment of the invention that uses an object oriented language and in which a producer identifies at least a class instance and method.

In addition shows producer dependency declarations for methods in object oriented source code a current set of one or more producers whose outputs are of interest also referred to here as the currently selected producers of interest and the outputs of source producers described later herein . The automated producer graph generation module receives the producer dependency declarations and the current set of producers of interest .

The automated producer graph generation module attempts to discover based on the producer dependency declarations child producers with outputs that contribute directly and indirectly to the input of the currently selected producers of interest and in some embodiments of the invention that support upwardly declared dependencies parent producers and builds a set of one or more current graphs of producers representing the dependency of these producers on each other from the currently selected producers of interest through any discovered producers that are non source producers to those of the discovered producers that are source producers. The current producer graphs s are stored in the producer graph s structure . While embodiments of the invention may store and manipulate the producer graph s as a collection of graphs other embodiments of the invention stores and manipulates the producer graph s as a collection of producers that are linked to each other to form graph s as opposed to a collection of graphs to facilitate merging and splitting of producer graphs. By way of example and not limitation embodiments of the invention which store and manipulate the producer graph s as a collection of producers are described herein.

The producer graph execution module receives the current producer graph s from the automated producer graph generation module and the outputs of source producers and executes the producers of the current producer graph s to determine the current output of the currently selected producers of interest. The producer graph execution module caches the current outputs of the producers in the producer graph s structure as illustrated by the producer output caching .

The caching of producer outputs of the producer graph during execution allows for synchronization. For instance the appropriate time to execute a parent producer that is dependent on multiple child producers is after all of the multiple child producers have been executed in other words it would be wasteful and in some cases not possible to execute the parent producer each time one of its child producers completed execution. The caching of the producer outputs allows for the execution of the parent producer to not only be postponed until all its child producers have been executed it also allows for a determination of the appropriate time for the execution of the parent producer when all of the child producers have been executed and their outputs have been cached. Thus the runtime makes this synchronization decision for the programmer by checking the execution status of its child producers in other words such synchronization is automated the programmer need not include separate source code that determines the appropriate time to identify an instance and execute a given method associated with that instance on that instance . By way of another example where several parent producers are dependent on the same child producer as well as on other different child producers the appropriate time to execute each of the several parent producers is typically different the runtime automatically determines the appropriate time to execute each of the several parent producers depending on the availability of the outputs of its set of child producers.

As will be described in more detail later herein since some parts of a producer graph may not be currently discoverable due to dynamic producer dependencies the automated producer graph generation module attempts to discover and build the entire producer graph but may not initially be able to complete the entire producer graph until some producers are executed. As such the producer graph execution module may invoke the automated producer graph generation module with needed producer outputs during execution of the current producer graph to complete any unresolved remainders of the current producer graph this is illustrated in by a dashed arrowed line from the producer graph execution module to the automated producer graph generation module a dashed arrowed line is used because such support is optional .

Thus the producer dependency declarations bound the possible producer graphs that may be generated while the currently selected set of producers of interest identify the beginning node s of the current producer graph to be generated. From these two the automated producer graph generation module discovers and builds the producer graph. The discovery and building is automated in that the automated producer graph generation module is not provided the producer graph e.g. it does not need to be manually identified by a programmer or even a list of the producers that will be in the producer graph. Rather the automated producer graph generation module parses the producer dependency declaration s of the current selected set of producers of interest to discover their child producers and in some embodiments of the invention that support upwardly declared dependencies parent producers then parses the producer dependency declarations of those discovered producers and so on down to the source producers in some embodiments of the invention described later herein this may be done with the assistance of the producer graph execution module . In the case where the producer graph is a tree a currently selected producer of interest will typically be the root node and the producer dependency declarations will be parsed until the leaf nodes source producers are discovered.

In a runtime with producer graph oriented programming support includes an automated producer graph generation module a producer graph execution module and an override producer output module . The runtime is to execute object oriented source code and thus includes additional modules not shown.

In addition shows the producer dependency declarations for methods in object oriented source code the current set of one or more producers whose outputs are of interest also referred to herein as the currently selected producers of interest and the output of source producers . The output of source producers includes the outputs of independent producers set in the source code e.g. constants default values etc. and the currently overridden producer outputs the outputs of the independent producers and or dependent producers whose outputs are currently overridden .

In some embodiments of the invention the outputs of producers may be explicitly overridden with a currently provided value i.e. rather than executing a producer to determine its output value based on its current inputs the output value for the producer is explicitly provided . In addition to any independent producers of a producer graph the source producers of a producer graph include any currently overridden producers.

The override producer output module receives the overridden producer outputs which identify which producers are being overridden and what output values they are being overridden with . In one embodiment of the invention producers can be classified as property producers or method producers. Property producers are those based on property methods e.g. get and set . Method producers are those based on non property methods. The override producer output module includes an override property producer output module for overridden property producers and an override method producer output module for overridden method producers. The override property producer output module causes the overridden value to be stored in the producer output caching and in the data of the instance whereas the override method producer output module causes the overridden value to be stored in the producer output caching . Depending on the embodiment of the invention this causation may be direct or indirect. illustrates an indirect causation through the use of an override log which collects the output of the override producer output module and which is consumed by the producer graph execution module . For optimization purposes the override log allows for the delaying of overrides in order to collect multiple overrides for batch processing.

Similar to the automated producer graph generation module the automated producer graph generation module 1 receives the producer dependency declarations and the current set of producers of interest and 2 attempts to discover based on the producer dependency declarations child producers with outputs that contribute directly and indirectly to the input of the currently selected producers of interest and in some embodiments of the invention that support upwardly declared dependencies parent producers and builds a set of one or more current graphs of producers representing the input dependency of these producers on each other from the currently selected producers of interest through any discovered non source producers to those of the discovered producers that are source producers independent producers and currently overridden producers . The producer graphs s are stored in the producer graph s structure .

Similar to the producer graph execution module the producer graph execution module receives the current producer graph from the automated graph module and the outputs of source producers and executes the producers of the current producer graph to determine the current output of the currently selected producers of interest. The producer graph execution module caches the current outputs of the producers in the producer graph structure as illustrated by the producer output caching .

As previously described the caching of producer outputs during execution allows for synchronization e.g. separate source code need not be written to determine when producer of should be executed but rather the runtime makes this synchronization decision for the programmer by checking the availability of the needed outputs in the producer output caching in other words such synchronization is automated . In addition this producer output caching is used for incremental execution. More specifically after a producer graph has been initially generated and executed the overriding of a producer in the current producer graph requires some level of reexecution. While some embodiments of the invention simply reexecute the entire graph alternative embodiments of the invention support incremental execution reexecuting only those parts of the producer graph that are affected by the override . Some exemplary embodiments that support incremental execution use incremental execution marking in the producer graph s structure to help determine which producers require reexecution. Thus maintaining the producer graph s refers to modifying the links of the producer graph s as necessary across multiple executions to keep them current up to date whereas incremental execution refers to both maintaining the producer graph s and using the current up to date producer graph s to reexecute only those parts of the producer graph s that are affected by an override.

Similar to there is a dashed arrowed line from the producer graph execution module to the automated producer graph execution module to represent optional support for dynamic dependencies. It should be noted that dynamic dependencies may change during reexecution of a producer graph.

The relatively simple example of illustrates that there can be a savings in processing resources as a result of incremental execution. Such savings depend on a number of factors e.g. the number of producers that do not need to be reexecuted the amount of processing those producers would have required etc. . While one embodiment of the invention is illustrated that performs incremental execution alternative embodiments may be implemented differently e.g. an alternative embodiment may reexecute all producers responsive to a modification .

While one embodiment of the invention that supports overriding producer outputs also supports unoverriding producer outputs alternative embodiments of the invention do not. While one embodiment of the invention that supports unoverriding producers leaves an overridden producer overridden until it is specifically unoverridden alternative embodiments of the invention may be implemented differently e.g. unoverriding an overridden producer when one of its progeny is overridden .

Different embodiments of the invention may be implemented to discover and build out a producer graph to different extents e.g. build the producer graph until all paths from the root node end at independent producers in which case the end nodes of a producer graph are independent producers with the possibility of any overridden producers being intermediate nodes build the producer graph out until each path from the root node ends in an overridden producer or an independent producer whichever is reached first in which case each end node of a producer graph is either an independent producer or an overridden producer .

 Execution start producers refers to the producers of a producer graph from which a given execution of the producer graph begins. For an initial execution of a producer graph different embodiments may start from different producers e.g. in embodiments of the invention that build the producer graph until all paths from the root node end at independent producers execution may start from the end nodes which would be the independent producers from the source producers which would include the independent producer nodes and any overridden producer nodes from a subset of the source producers consisting of the combination of any independent producers with at least one path between them and the root producer that does not include an overridden producer and any overridden producers or from a subset of the source producers consisting of the combination of any overridden producers without any descendents that are overridden and any independent producers with at least one path between them and the root producer that does not include an overridden producer in embodiments of the invention where the producer graph under overridden producers is not built if and until such a producer is un overridden execution may start from the end nodes which may be independent producers and or overridden producers etc .

For subsequent executions of a producer graph different embodiments may start from different producers e.g. from the independent producers of the producer graph e.g. in embodiments of the invention that do not support incremental execution from the source producers of the producer graph e.g. in embodiments of the invention that do not support incremental execution from a subset of the source producers that consists of those source producers that have been overridden and or added since the last execution e.g. in embodiments of the invention that do support incremental execution of the source producers that have been overridden and or added since the last execution from the combination of any such overridden producers without any descendents that are overridden and any such added producers with at least one path between them and the root producer that does not include an overridden producer e.g. in embodiments of the invention that do support incremental execution etc . By way of example and not limitation embodiments of the invention that perform the following will be described below 1 do not build the producer graph under overridden producers if and until such a producer is un overridden 2 for an initial execution of a producer graph start execution from the end nodes which may be independent producers and or overridden producers 3 implements incremental execution and 4 for subsequent executions of a producer graph start execution from a subset of the source producers that consists of those source producers that have been overridden and or added since the last execution.

With regard to the above concept of execution start producers the processing flow of execution of the producer graph also differs between different embodiments. For example in one embodiment of the invention the ancestry of the execution start producers are determined and placed in a collection the execution start producers are executed and the collection is iteratively scanned for producers for whom all dependencies have been executed eventually the root nodes are reached. As another example in one embodiment of the invention the execution start producers are executed the parents of the execution start producers are identified those parents are executed and their parents are identified and executed and so on. The later embodiment of the invention is used below by way of example and not limitation.

A dynamic producer dependency is a producer dependency that can change during run time. It should be understood that the criteria for resolving the producer dependency is present in the source code and thus the producers to which the producer dependency may be resolved are limited. With reference to the dashed arrowed line from the producer graph execution module to the automated producer graph generation module represents support for the execution of one or more producers in the current producer graph that are necessary to discover and build the entire current producer graph. In other words an embodiment of the invention that supports dynamic producer dependencies may iterate between the automated producer graph generation module and the producer graph execution module until the entire producer graph is discovered built resolved and executed that is iterate between 1 invoking the automated producer graph generation module to discover and build those parts of the current producer graph that can be resolved at that time and 2 invoking the producer graph execution module to execute producers of the current producer graph . In this sense discovering refers to the accessing of the producer dependency declarations and determining the producers they identify building refers to instantiating the producers and adding them to the producer graph and resolving refers to determining currently unresolved dynamic producer dependencies.

Thus automated reexecution of a producer graph is not limited to the producer being modified and its direct parent being reexecuted rather a change is automatically rippled through the producer graph by the runtime affecting any appropriate producers and dependencies because the producer graphs are maintained and incremental execution is used where supported . As such changes cause any necessary additional discovery building resolving and executing. Thus the reexecution of a producer graph is automated in the sense that a user programmer need not determine which producers of the producer graph are affected and possibly manually correct the graph.

A static dependency is one that cannot change during run time. Thus in an embodiment of the invention that supports contingent and subscription dynamic dependencies described later herein a non contingent non subscription dependency is a static dependency. The exemplary producer graph of illustrates a producer graph of static dependencies.

Since a producer is at least an instance and a method associated with that instance a producer graph is a graph representing instances and methods associated with those instances and thus producer graphs are at least instance and method centric. In embodiments of the invention in which a producer is at least a class instance and method producer graphs are at least class instance and method centric.

It should be understood that a producer graph may take a variety of different shapes e.g. a single chain of producers a tree etc. . The exemplary producer graph of is a tree with a root node of producer from which there are two branches one to each of producer and producer . Where producer is a leaf node producer has two branches extending from it one to each of producer and producer . Producer has two branches extending from it one to each of producer and producer A. The exemplary producer graph of is said to be multilevel with level including the rood node producer with level including producer and producer with level including producer and producer with level including producer and producer A in level includes producer B and level includes producer . When considering the branch from producer with producer the first producer of the branch is producer and the last producers of the branch are producer producer and producer A in .

While illustrates a producer graph in which the current set of producers of interest includes a single producer embodiments of the invention that support more than one current producer of interest would discover and build producer graphs for each. It should be understood that where there are simultaneously multiple producers of interest the resulting producer graphs may be independent or may intersect. Where producer graphs intersect embodiments of the invention may be implemented to 1 duplicate producers to maintain separate producer graphs or 2 avoid such duplication and maintain intersecting producer graphs. It should also be understood that such intersecting producer graphs may include a producer graph that is a subset of another producer graph. For instance if producer was included with producer in the current set of producers of interest then there would be a first producer graph with a root node of producer and a second producer graph with a root node of producer where the second producer graph includes the first producer graph. If for instance producer B was included with producer and producer in the current set of producers of interest there would be a third producer graph separate from the first and second producer graph with a root node of producer B in . Further if the dynamic dependency of producer changed from producer A to producer B then the change would result in the third producer graph becoming a subset of the second producer graph remaining and the second producer graph becoming a subset of the first producer graph. As previously stated while embodiments of the invention may store and manipulate the producer graph s as a collection of graphs other embodiments of the invention stores and manipulates the producer graph s as a collection of producers that are linked to each other to form graph s as opposed to a collection of graphs to facilitate merging and splitting of producer graphs. By way of example and not limitation embodiments of the invention which store and manipulate the producer graph s as a collection of producers are described herein.

The logical execution flow of the runtime client includes blocks and while the runtime with producer graph oriented support includes blocks and optionally . A solid arrowed line represents a direct causal relationship from block to block . In contrast dotted arrowed lines illustrate a causal relationship from blocks and in the logical execution flow of the runtime client to blocks and in the runtime with producer graph oriented support respectively depending on the embodiment of the invention this causal relationship may be direct or indirect. For example illustrates an optional indirect causation through the use of a command log in a dashed oval on the runtime with producer graph oriented support side of the dashed line . The command log collects commands resulting from blocks and of the logical execution flow of the runtime client and the command log is consumed responsive to block by processing block . Thus the command log allows for the delaying of commands in order to collect multiple ones together and batch process them for optimization purposes. Thus the command log is similar to the override log of and would actually include the override log in some embodiments of the invention.

In block the set of one or more producers of interest are determined as the current set of producers of interest and control passes to block . Responsive to the causal relationship between block and block block shows that the current set of producers of interest are instantiated and that an attempt is made to discover build and resolve if dynamic dependencies are supported and one or more are discovered in the producer graph the producer graph s for each including instantiating any instances and producers thereof as necessary based on the producer dependency declarations in the runtime client . With reference to the automated producer graph generation module and are invoked respectively.

In block it is determined if there are any producer output overrides. If so control passes to block otherwise control passes to block .

In block one or more producer output overrides are received for a set of one or more producers and control passes to block . Responsive to the causal relationship between block and block block shows that the current set of overridden producers are instantiated if not already instantiated in block their outputs are modified and they are tracked. An overridden producer may have already been instantiated because it was already discovered to be part of the producer graph s in block . However an overridden producer may not already be discovered in block because of an unresolved dynamic dependency. As such this overridden producer is instantiated and overridden with the expectation that it may be added to the producer graph s when dynamic dependencies are resolved. Also as previously indicated the override log of if implemented exists between block and block and is part of the command log . Further the set of overridden producers is tracked in some embodiments of the invention that support incremental execution. While in embodiments of the invention that support the override log command log the tracking is part of the log in alternative embodiments of the invention the tracking is separately performed in block with a different mechanism.

In block the producer graph execution module is invoked and control optionally returns to block and or block . Responsive to the causal relationship between block and block block shows that the current producer graph s are walked and any producers that require execution are executed based on the tracking Various techniques have been previously discussed for executing the producers of the producer graph and are applicable here. With reference to the producer graph execution module and are invoked respectively. In addition in embodiments of the invention in which the command log is implemented the causal relationship includes consuming the command log and performing the processing blocks and prior to block . Further in embodiments of the invention that support the possibility of unresolved dependencies control flows from block to block when necessary.

In block an attempt is made to resolve the unresolved dependencies and discover and build the remainder of the producer graph s including instantiating any instances and producers thereof. From block control flows back to block .

Different embodiments of the invention may use different syntaxes for declaring producer dependencies. For example different embodiments of the invention may include different syntaxes for use in producer dependency declaration statements that strongly constrain weakly constrain and or do not constrain the type of producer dependency that may be created. A strongly constrained producer dependency is one for which a syntax is used in the producer dependency declaration statement that substantially limits the type of producer dependency that may be created A weakly constrained producer dependency is one for which a syntax is used in the producer dependency declaration statement that is less limiting of the type of producer dependency that may be created and an unconstrained producer dependency is one for which a syntax is used in the producer dependency declaration statement that does not limit the type of producer dependency that may be created.

By way of example and not limitation embodiments of the invention described below that include the following 1 a syntax for a strongly constrained producer dependency for arguments ArgumentDependency strongly constrained downwardly declared argument static or dynamic and if dynamic contingent and or absorbing subscription dependency 2 a syntax for a strongly constrained producer dependency for fields FieldDependency Strongly constrained downwardly declared field static or dynamic and if dynamic contingent and or absorbing subscription dependency 3 a syntax for a strongly constrained producer dependency for sequencing dependencies SequencingDependency Strongly constrained downwardly declared sequencing static or dynamic and if dynamic contingent and or sticky subscription dependency 4 a syntax for a weakly constrained upwardly declared producer dependency for argument field or sequencing dependencies UpwardDependency Weakly constrained upwardly declared field argument or sequencing static or dynamic and if dynamic contingent dependency and 5 a syntax for a weakly constrained producer dependency WeaklyConstrainedDependency either a downwardly declared sequencing only static or dynamic and if dynamic contingent and or sticky subscription dependency or b upwardly declared argument field or sequencing static or dynamic and if dynamic contingent dependency . It should be understood that while some embodiments of the invention support a syntax for the producer dependency declaration statement that distinguishes downwardly declared argument dependencies downwardly declared field dependencies upwardly declared dependencies that can return upwardly declared argument field or sequencing dependencies and weakly constrained dependencies that can return downwardly declared sequencing dependencies upwardly declared argument field or sequencing dependencies alternative embodiments of the invention may adopt a different syntax e.g. have a syntax that has all dependencies be unconstrained dependencies with dependency determination producers that can return any supported dependencies downwardly and upwardly declared argument field and sequencing dependencies have a syntax distinguish all supported dependencies have a syntax that distinguishes downwardly and upwardly declared argument and field dependencies and that distinguishes a weakly constrained dependency that can only return upwardly and downwardly declared sequencing dependencies a syntax that distinguishes downwardly declared argument and field dependencies and that distinguishes upwardly declared dependencies that can return only upwardly declared sequencing dependencies a syntax that distinguishes downwardly declared argument field and sequencing dependencies sticky subscriptions and upwardly declared dependencies are not supported etc. 

It should be understood that the syntax of the producer dependency declaration statement does not necessarily equate to the producer dependency e.g. the link created in the producer graph e.g. ArgumentDependency creates an argument dependency but an UpwardDependency may create an argument field or sequencing dependency . As such where appropriate for understanding a space between a qualifier e.g. argument field or sequencing and the word dependency is used to refer to the dependency created by the runtime while lack of a space is used to refer to the syntax.

Thus illustrate embodiments of the invention in which producer dependency declaration code is part of another producer referred to as a dependency determination producer. While in the object oriented source code includes explicit producer dependency declaration code in methods from which dependency determination producers are instantiated at run time by the runtime for non shortcut declared dependencies alternative embodiments of the invention additionally or instead implement the runtime to include generic producer dependency declaration code that it invokes as one or more generic dependency determination producers on the fly for shortcut declared dependencies. Also while are illustrated with reference to ArgumentDependencies the techniques illustrated are applicable to the other types of downwardly declared dependencies. Further illustrate the use of a dependency determination producer for an UpwardDependency and a WeaklyConstrainedDependency.

As previously indicated sequencing dependencies may be used for a variety of purposes including ensuring the order of execution between producers that modify data in a manner of which the runtime is not aware and producers that consume that data a child producer may write its outputs in a way that requires the method of the parent producer to include code to access that output e.g. a method that impacts the environment by affecting an output that is not the regular producer output and as such that is not detected by the runtime such as a method that sets a global variable that sets a field in an instance which is not the producer output that impacts an external data source etc. etc.

Different embodiments may support one or more ways for declaring producer dependencies with respect to property producers. Specifically in some embodiments of the invention producers that read a field should be dependent on the get property producer while the get property producer should be dependent on any producers that set the field for which that get property method is responsible. One technique of handling this situation that may be used in embodiments of the invention that support sequencing producer dependencies is to provide for a get property method a producer dependency declaration statement that creates sequencing producer dependencies on every method that sets the field for which that get property method is responsible e.g. with respect to where the producer is a producer that sets a field and the producer is the get property producer responsible for that field the dependency determination producer would be written to return a downwardly declared sequencing dependency of the producer on the producer . A second technique of handling this situation that may be used in embodiments of the invention that support both sequencing producer dependencies and upwardly declared producer dependencies is to include in the producer dependency declaration statement code for any method that sets a field an upwardly declared sequencing producer dependency e.g. using an UpwardDependency or WeaklyConstrainedDependency on the get method responsible for that field e.g. with respect to where the producer is a producer that sets a field and the producer is the get property producer responsible for that field the dependency determination producer would written to return an upwardly declared sequencing dependency of the parent producer on the producer . This second technique allows the programmer of the method that sets the field to be responsible for providing a producer dependency to the appropriate get method as opposed to requiring that programmer to go to the get method and modify its producer dependency declaration statement code.

When using sequencing dependencies when a given producer relies on a given variable that variable should not be modified by more than one of that producer s descendant producers in a given execution of the producer graph s It should be noted that through contingent dependencies described later herein different descendant producers may modify that variable during different executions of the current producer graph s . For example a get property producer should only depend on one other producer that sets the filed for which the get property producer is responsible in a given execution of the current producer graph s .

It should be understood that different embodiments of the invention may implement one or more of the embodiments of the invention shown in . For example one embodiment of the invention supports shortcut and non shortcut declared dependencies both using dependency determination producers specifically in this embodiment of the invention 1 the object oriented source code includes explicit producer dependency declaration code in methods from which dependency determination producers are instantiated at run time by the runtime for non shortcut declared dependencies 2 the runtime includes generic producer dependency declaration code that it invokes as one or more generic dependency determination producers on the fly for shortcut declared contingent dependencies describer later herein and 3 the runtime includes support to directly link shortcut declared non contingent producer dependencies describer later herein .

As another example one embodiment of the invention supports non shortcut and shortcut declared producer dependencies using dependency determination producers specifically in this embodiment of the invention 1 the object oriented source code includes explicit producer dependency declaration code in methods from which dependency determination producer are instantiated at run time by the runtime for non shortcut declared dependencies and 2 the runtime includes generic dependency determination code that it invokes as one or more generic dependency determination producers on the fly for shortcut declared dependencies regardless of type . This later embodiment allows for consistent treatment of producer dependencies and thus simplifies the runtime.

In addition while in one embodiment of the invention the producer dependency declaration statement for a method is located just above that method in the object oriented source code in alternative embodiments of the invention it is located elsewhere e.g. the producer dependency declaration statements for all the methods for a class are grouped together within the class the producer dependency declaration statements for all the methods in all of the classes are grouped together as a separate data table etc. . Also while in one embodiment of the invention producer dependency declaration code is separate from the producer dependency declaration statements in alternative embodiments of the invention they are combined e.g. the producer dependency declaration code is within the parentheses of the producer dependency declaration statement the producer dependency declaration code is placed directly beneath the producer dependency declaration statement and is treated by the runtime as a single unit etc. .

The second division includes the creation of object oriented application source code to be executed by the runtime. The object oriented application source code includes two basic divisions 1 class definitions that include the business logic expressed in methods with producer dependency declarations this may optionally include other functionality such as a graphical user interface in which case the graphical user interface is written using producers and producer dependency declarations and 2 class definitions that include client code expressed in methods including instantiation code class instances and producer s of interest to cause generation of the producer graph s A data preparation code B e.g. set commands such as set commands that trigger the overriding of producer outputs global execute commands C to cause execution of the producer graph s e.g. execute and get commands and any required graphical user interface D not included in . The producer dependency declarations are used to define the ties between producers during the definition of the classes that include the business logic rather than after instances of those classes are created. The object oriented source code is hard coded class instance and methods that are compiled and executed.

While in one embodiment of the invention a global execute command is implemented execution of which causes the attempted execution of all producer graph s currently in the producer graph s structure alternative embodiments of the invention alternatively or also implement a graph specific execute command that requires identification of a given graph of the current producer graph s that is to be executed. Further the global execute command may be explicit e.g. set set set execute get get or implicit depending on the implementation of the runtime. For example an implicit global execute command could be 1 triggered by the first get command on a producer of interest e.g. set set set get implicit execute get 2 triggered by each data manipulation set implicit execute set implicit execute set implicit execute get get etc.

The second division is again performed by programmers with advanced programming skills as well as an understanding of the business objectives of the application. When working in this division programmers are referred to as application programmers. As part of this if the application requires a graphical user interface the application programmers also design and code the graphical user interface for the specific application and thus are also referred to as application designers.

The third division includes the use of application programs being run by the runtime. The third division is performed by end users that need not have any programming skills. The application program may be distributed in a variety of ways e.g. as source code a transformation of source code such as byte code as binary etc . In addition the application program may be distributed for stand alone use in which case the entire application program and runtime if not already present is provided to a computer system and or client server use. In one embodiment of the invention a client server distribution includes distributing the class definitions that include the business logic expressed in methods with producer dependency declarations and runtime if not already present for server use and the class definitions that include client code expressed in methods and runtime if not already present for client use where the client use on a computer system causes communication with the server use on a server system.

Regardless of the framework used in one embodiment of the invention the producer graph oriented programming framework offers the ability to interface with programs not written with producer dependency declarations. This ability to interface with programs not written with producer dependency declarations includes 1 a caller part such as a graphical user interface not written according to producer graph oriented programming and 2 a called part such as an external data source not written according to producer graph oriented programming . The caller part may through client code issues producer graph oriented programming commands. The called part is implemented as part of producers that wrap the called part referred to as wrapping producers . Executing the called part such as reading data from a data source or subscribing to changes of data in an external data source may in turn trigger instance modifications. These changes may occur by calling the property set methods in the code of the wrapping producers. Get property producers getters are caused to have dependencies on these wrapping producers in order to make sure that instance modifications triggered by the changes occurring in an external data source are properly propagated through the producer graph. As previously described different embodiments may support one or more ways for declaring producer dependencies with respect to property producers. For example in some embodiments of the invention that support sequencing producer dependencies SequencingDependencies may be used for declaring non subscription downwardly declared sequencing producer dependencies on the wrapping producers. As yet another example in some embodiments of the invention that support sequencing producer dependencies and non subscription upwardly declared producer dependencies UpwardDependencies and or WeaklyConstrainedDependencies may be may be placed in the producer dependency declaration of the wrapping producers to create non subscription upwardly declared sequencing producer dependencies for the property producers.

As in shows that cells of the viewer to which get property methods have been mapped may be overridden. By way of example shows that if the cell of the second row of the column to which the get property method DATEOFBIRTH is mapped is overridden then it will cause the overriding of the output of the producer whose output is currently populating that cell invocation of a global execute command which would result in a reexecution of the producer whose output is currently populating the cell to which the get property method AGE is mapped and any necessary updating of the display.

While embodiments are described in which the runtime has class loading dynamic class instantiation dynamic single method invocation and class method introspection alternative embodiments may include more or less features e.g. instance cloning dynamic proxies primitive type conversions etc. 

In one embodiment of the invention producer dependencies are declared for methods as a way to specify method invocation sequencing using the appropriate instances where the appropriate instances include the instances to use as arguments the instances to be used by instance methods and the meta class instances used by class methods without using manual invocation sequencing code. Effectively the work of generating some or all of manual invocation sequencing code is replaced with 1 work done by the application programmer to write the producer dependency declarations and 2 work done by the runtime to discover and build the producer graph s and execute the producers of those producer graph s . In other words the logic that was previously contained in the manual invocation sequencing code is discoverable by the runtime during run time based on the producer dependency declarations. Thus the producer dependency declarations inform the runtime what methods of what instances with what arguments to execute and when for synchronization purposes. Although the effort to write the runtime is relatively great it needs only be written once in that it can be used to execute any object oriented applications written for the runtime in contrast for a typical application the effort to write the producer dependency declarations is relatively low in comparison to writing manual invocation sequencing code.

Producer graph oriented programming typically reduces the costs associated with the debugging and or performance tuning of the manual invocation sequencing code. This is true for at least the reason that the infrastructure of an application program is conceptually a set of non formalized graphs of transformation methods of objects the output of one method associated with an object is the input to another and so on that operate on specific inputs. The producer dependency declarations and the runtime with producer graph oriented programming support formalizes these graphs as producer graphs. Thus for each opportunity for data to change the application programmer need not consider its effect and write manual invocation sequencing code to cause the appropriate transformation methods of the appropriate instances to be invoked in the appropriate order with the appropriate inputs. In other words for each opportunity for data to change an application programmer need not consider which graphs are affected as well as which transformation methods of instances within those graphs are affected. Rather the automated producer graph generation module discovers and builds the producer graphs and the producer graph execution module reexecutes the producer graphs as needed to reflect changes in the data. This automation helps application programmers avoid mistakes such as 1 invoking the appropriate transformation methods of the appropriate instances in the wrong order 2 forgetting to include commands to cause the one or more required transformation methods of instances in a graph to be invoked responsive to some data being changed 3 including commands to cause unnecessary transformation methods of instances to be invoked responsive to some data being changed e.g. including commands to invoke transformation methods of instances that are not part of a graph affected by the change in data including commands to invoke transformation methods of instances that are part of a graph affected by the change in the data but are not themselves affected etc. .

As previously described the caching of producer outputs during execution allows for synchronization. Thus in terms of comparison to the observer pattern the producer dependency declarations notify a runtime with producer graph oriented programming support of the dependencies and the runtime determines what producers and when to call back.

In one embodiment of the invention a drilling viewing module not shown is included as part of the runtime. The drilling viewing module provides a graphical user interface which through interaction by an end user allows for drilling down into the producer graph walking down a producer graph from the root node to view the outputs of the various producers of the producer graph. This allows an end user to see the various outputs that contributed to the output of the producer of interest including the data values and dependencies returned by dependency determination producers . Further in one embodiment of the invention this drilling viewing module provides the ability for the end user to view the code inside the methods of the producers the values of the instances of the producers and or the content of the classes of the producers.

Thus the drilling viewing module provides for a variety of post processing activities including debugging explanation of outputs etc.

There are a variety of exemplary practical applications of the different aspects and embodiments of the invention. For example the runtime as part of executing application programs causes the retrieval of information from a machine storage media e.g. accessing the object oriented source code including the producer dependency declarations the storage of information to a machine storage media e.g. storing data structures like the producer graph s structure etc. the operation of hardware processing resources the provision of the outputs of the producer s of interest e.g. through a graphical user interface storage to machine storage media transmission etc. etc. In one sense preprocessing activity includes the writing of such an application program and or the provision of data which data may represent any number of physical and or practical items such as financial values geographical values meteorological values actuarial values statistical values physical measures machine state values etc. while post processing activity includes the provision of results which results may represent any number of physical and or practical items such as financial analysis geographical analysis meteorological analysis actuarial analysis statistical analysis industrial measures machine control information etc. By way of specific example post processing activity may be provided by 1 the producer graph viewer module of for graphically displaying a representation of the current producer graph s generated by the runtime and or 2 the configurable interactive producer output layout graphical user interface module see also configurable interactive producer output layout graphical user interface module of for graphically displaying outputs from and interacting with the producer graphs.

As another example the application program with producer dependency declarations itself when executed by the runtime represents the physical practical items and causes the operations described above. By way of specific example these producer dependency declarations cause data structures to be formed in machine storage media responsive to their execution by the runtime. Also the producer dependency declarations are stored and retrieved from machine storage media along with the application program. Further these producer dependency declarations represent relationships between producers while producers represent operations to be performed methods and instances. The instances in object oriented programming may be used to represent physical and or practical items while the producers represent operations to be performed on these representations.

By way of another example a set of one or more application programs and the runtime implement cross asset risk management software covering foreign exchange equity interest rate credit inflation commodity and cross asset composite products. These products range from cash and physical plain vanilla products to exotic and complex derivative products. Also included is a set of mathematical valuation models for these products and their associated market data payment and accounting entries generation routines and their associated observables calibration models and their associated raw inputs.

By way of another example a set of one or more application programs and the runtime may implement a word processor a spreadsheet a communication e mail software a photo viewing software a virus scan software a media player a database server a game an industrial application a computer aided design tool application and or an operating system. Of course application programs can be implemented to perform a variety of other tasks.

By way of illustration exemplary embodiments of the invention will be described that support dependencies dynamic dependencies including contingent dependencies and subscription dependencies explicit dependency determination producers for shortcut declared dependencies and for non shortcut declared dependencies on the fly dependency determination producers for shortcut declared dependencies class keys instance keys method keys producer override unoverride commands which are types of set commands and global execute commands. In addition the exemplary embodiments optionally support a producer graph interactive viewer module and incremental execution. Of course alternative embodiments of the invention may implement more less and or different features.

The logical execution flow of the runtime client includes blocks and and the runtime with producer graph oriented programming support includes respectively corresponding blocks and while a solid arrowed line represents a direct causal relationship from block of the logical execution flow of the runtime client to block of the runtime with producer graph oriented support dotted arrowed lines illustrate a causal relationship from blocks and of the runtime client to blocks and of the runtime with producer graph oriented programming support . Depending on the embodiment of the invention these later causal relationships may be direct or indirect. For example similar to an optional indirect causation through the use of a command log not shown and or override log may be used. Further blocks and are dashed because they may optionally be part of a different block depending on the embodiment of the invention e.g. block may be part of block block may be part of block blocks and may be part of block . Similarly block is dashed because it may be optionally part of a different block depending on the embodiment of the invention e.g. block may be part of block .

In the runtime includes class definitions that include business logic having data methods producer dependency declarations and optionally class keys . The class definitions are classes in an object oriented programming language and thus include definitions for data and methods . In addition these class definitions include producer dependency declarations for the method as previously described. Further in one embodiment of the invention each class has a class key for tracking purposes.

The new class module of the runtime loads and introspects the class definitions e.g. responsive to new class commands . This loading and introspecting may be done using any number of well known or future developed techniques including those to selectively load classes for optimization purposes. The loading of the classes by the new class module is illustrated by classes of the runtime . As part of loading and introspecting the classes the new class module also loads and introspects the producer dependency declarations as illustrated by methods and producer dependency declarations in the classes . The new class module also maintains a class tracking structure that is used for tracking the classes using the class keys. Thus the class tracking structure maintains a correspondence between class keys and references into the classes . Further the new class module also maintains a method tracking structure that is used for tracking methods using the method keys. Thus the method tracking structure maintains a correspondence between method keys and references to the methods as well as information regarding the producer dependency declarations.

The runtime client also includes instance instantiation commands with instance keys . The new instance module of the runtime instantiates the instances designated by the instance instantiation commands with instance keys e.g. responsive to new instance commands . This instantiating of instances may be done using any number of well known or future developed techniques including those to selectively instantiate instances for optimization purposes. As part of this instantiating of instances the new instance module accesses the class tracking structure using a class key to access the appropriate class from the classes . The instantiating of instances by the new instance module is illustrated by instances of the runtime . The new instance module also maintains an instance tracking structure that is used for tracking the instances using the instance keys. Thus the instance tracking structure maintains a correspondence between instance keys and references into the instances . As previously indicated the new class module may be part of the new instance module in that the classes may be instantiated responsive to the instance instantiation commands as opposed to separate new class commands.

The runtime client also includes producer instantiation commands with producer keys . The automated producer graph generation module of the runtime instantiates producers designated by the producer instantiation commands with producer keys e.g. responsive to new producer commands designating the current set of producers of interest . In addition the automated producer graph generation module also discovers builds and optionally resolves the producer graph s responsive to the current set of producers of interest as previously described. In one embodiment of the invention a producer key is comprised of a class key instance key and method key. As part of this instantiating of producers the automated producer graph generation module 1 accesses the class tracking structure using the class key to access the appropriate class from the classes 2 accesses the instance tracking structure using the instance key to access the appropriate instance from the instances and 3 accesses the method tracking structure using the method key to access the appropriate producer dependency declaration statement. The instantiating of the producers designated by the producer instantiation commands with producer keys and instantiating of the any discovered producers and building the producer graph is illustrated by producer graph s structure of the runtime . Thus in one embodiment of the invention the producer keys identified by the producer instantiation commands with producer keys and those discovered through producer graph generation are stored in the producer graph s structure along with additional information to represent the current producer graph s .

As previously described the block and may be part of block and thus the decision regarding which classes instances and producers to load instantiate is driven by what producers are in the current producer graph s . In such an embodiment of the invention the loading instantiating of class instances and producers is optimized and is producer centric.

The runtime client also includes data preparation commands including producer output override unoverride commands . The override unoverride commands include the producer key of the producer to be overridden unoverridden as well as the override values when being overridden. The override producer output module of the runtime causes producers designated by the producer override unoverride commands to be overridden unoverridden. This causation may be indirect or direct.

In the case of indirect causation the override producer output module populates the override log for consumption by the producer graph execution module . In the case of direct causation the override producer output module accesses the producer output caching of the producer graph s structure and the instances . Specifically as described with reference to the override producer output module in one embodiment producers can be classified as property producers or method producers thus the override producer output module may include an override property producer output module not shown for overridden property producers and an override method producer output module not shown for overridden method producers the overriding of a property method causes the overridden value to be stored in the producer output caching of the producer graph s structure and to be stored in the data of the appropriate instance of the instances whereas the overriding of a method producer causes the overridden value to be stored in the producer output caching .

In one embodiment of the invention producers may not be overridden before a producer graph of which they will be part has been initially executed thus the producer will already be instantiated as a result of being designated as a producer of interest or as a result of being discovered by the automated producer graph generation module . However in the embodiment shown in producers may be overridden before the initial execution by being instantiated and overridden with a producer override command. Such an overridden producer will typically eventually become part of a producer graph through the discovery process e.g. when a dynamic dependency is resolved . In some embodiments of the invention this data preparation may also include other types of set commands. The override producer output module is shown as a dashed box because it may not be present in alternative embodiments of the invention.

The producer graph s structure also optionally includes incremental execution marking for some embodiments of the invention that support incremental execution. As previously described with reference to the incremental execution marking of the incremental execution markings is used to assist with incremental execution of the producer graph s on execution beyond that of the initial execution. Different embodiments of the invention that use the incremental execution marking use them in different ways. For example in one such embodiment of the invention that has a command log the log is used to track which producers have been added and or modified and the incremental execution marking are used to mark those producers that are affected ancestors of the modified or added producers and thus dependent on them . As another example in one such embodiment of the invention that does not have a command log the incremental execution marking are used to mark those producers that are added or modified as well as those that are ancestors of the modified or added producers and thus dependent on them . As another example in one such embodiment of the invention that does not have a command log modifications and additions of producers are done immediately and the incremental execution marking are used to mark those producers that are ancestors of the modified or added producers and thus dependent on them . While embodiments of the invention have been described that support incremental execution and use incremental execution marking other embodiments of the invention support incremental execution that do not use incremental execution marking e.g. a command log is used to track which producers were added or modified and a list of execution start producers is maintained in an execution start log where the producer graph execution module starts from the execution start producers and works its way up the ancestors of the producer graph s to the top by way of example and not limitation this embodiment of the invention is described later herein with regard to .

The runtime client also includes global execution commands . The producer graph execution module of the runtime executes the producer graph s . As such the producer graph execution module modifies the producer output caching in the case of property producers and method producers uses the incremental execution marking if present and modifies the data of the instances in the case of property methods . Various techniques have been previously discussed for executing the producers of the producer graph and are applicable here. For instance in embodiments in which a command log is implemented the command log is consumed and then the producer graph s are executed. Further in embodiments of the invention that support the possibility of unresolved dependencies producer graph execution module includes dynamic dependency module which can invoke the automated producer graph generation module .

In embodiments of the invention that use a command log different triggers may be use to trigger different actions. For instance the producer instantiation commands may be logged and batch processed responsive to an explicit command start logging and end logging an explicit global execute command logging starts automatically at startup and after each explicit global execute command and each log is processed responsive to the following explicit global execute command an explicit data preparation command etc. Similarly the data preparation commands may be logged and batch processed responsive to an explicit global execute command a first get command every get command etc.

In addition includes a parent producer s link s column including for each link a parent producer reference and a dependency determination producer reference and a child producer s link s column including for each link child producer reference s a dependency determination producer reference a link mode and a sticky link indicator . Each producer may have zero or more child producer links in column . Each child producer link in column includes 1 child producer reference s which are references to other rows of the producer graph s structure to represent a producer dependency according to the producer dependency declaration 2 a dependency determination producer reference which is a reference to another row of the producer graph s structure and represents the dependency determination producer that has created the child link and 3 a link mode with a producer dependency type that identifies whether the producer dependency is a result of an argument a field or a sequencing dependency see discussion regarding and if an argument the argument ID of the producer dependency and 4 a sticky indicator to indicate that the link mode is the result of an upwardly declared dependency in embodiments of the invention that support upwardly declared dependencies or the result of a sticky subscription in embodiments of the invention that support sticky subscriptions and should not be modified through the producer argument dependency declaration of this producer i.e. the producer stored in the row of the column containing the sticky indicator . Each producer may have zero or more parent producer links in column . Each parent producer link in column includes 1 a parent producer reference that stores back a reference in accordance with a child producer reference of another producer i.e. a reference to another row of the producer graph s structure to represent a parent producer dependent on this producer and 2 a dependency determination producer reference which is a reference to another row of the producer graph s structure and represents the dependency determination producer which has created the parent link. Thus when a link is created the parent producer link column of the child producer s row and the child producer link column of the parent producer s row are modified to represent the link and the dependency determination producer reference is the same in both . In one embodiment of the invention since multiple paths in a producer graph or different producer graphs may include a given producer there may be multiple parent producer links for a given producer.

Further includes a producer output caching and override producer output modification column to store the current producer outputs as well as an indication of whether the producer is overridden and the overridden output value. Also includes an incremental execution marking column to store incremental execution markings as previously described.

As previously described one embodiment of the invention supports non dynamic and dynamic producer dependencies. While different embodiments may support different types of dynamic producer dependencies one embodiment of the invention supports contingent and subscription types of dynamic producer dependencies. Thus a non contingent non subscription dependency is a non dynamic static dependency.

The following description of contingent and subscription dependencies is done in the context of an embodiment of the invention that uses a class DEP an abbreviation for dependency from which an instance is returned by dependency determination producers and is analyzed by the runtime with producer graph oriented programming support. The class DEP includes the following fields 1 TYPE which can be set to subscription non subscription downwardly declared child producers that are not subscriptions or non subscription upwardly declared parent producers that are not subscriptions 2 PROD which is used for non subscription downwardly declared dependencies and is a collection of child producers as such it can store zero or more producers 3 SUB TYPE which is used for subscription dependencies and is set to indicate the type of subscription dependency used in embodiments of the invention that support multiple types of subscription while the embodiment of the invention described here supports two types sticky and absorbing alternative embodiments may support more less and or different subscription types 4 SUB CRIT which is used for subscription dependencies and is set to indicate the subscription criteria 5 PAR LINK MODE which is used for sticky subscription dependencies and non subscription upwardly declared dependencies and is set to indicate what the link mode of the parent producer should be 6 PAR CLASS which is used for sticky subscription dependencies and non subscription upwardly declared dependencies and is set to indicate what the class of the parent producer e.g. the class key should be 7 PAR METHOD which is used for sticky subscription dependencies and non subscription upwardly declared dependencies and is set to indicate what the method of the parent producer e.g. the method key should be and 8 PAR INSTANCE which is used for sticky subscription dependencies and non subscription upwardly declared dependencies and is set to indicate what the instance of the parent producer e.g. the instance key should be If PAR INSTANCE is left blank the instance key of the child producer is then used for the parent producer . An alternative embodiment could use a collection of parent producers each item of the collection holding a PAR CLASS PAR INSTANCE PAR METHOD PAR LINK MODE in the case of sticky subscription dependencies and or non subscription upwardly declared dependencies. Of course other alternative embodiments of the invention could use a different structure to return dependencies.

In one embodiment of the invention both non contingent and contingent producer dependencies are supported. A non contingent producer dependency is one that is independent of the output of other producers while a contingent producer dependency is one that is dependent on the output of other producers. While one embodiment of the invention supports both non contingent and contingent producer dependencies alternative embodiments support only non contingent or contingent which contingent producer dependencies may be initially driven by default values .

As previously discussed a producer can be viewed as a set of multiple identifiers one identifier for each additional level of granularity specified. In one embodiment of the invention a contingent producer dependency can be contingent in the sense that any one or all of the set of identifiers can be conditionally determined based on current data values. For instance a first contingent producer dependency may have only the instance identifier be conditionally determined the class and method identifiers are fixed while a second contingent producer dependency may have the class instance and method identifiers be conditionally determined. While in one embodiment of the invention all of the plurality of identifiers of a contingent producer dependency may be conditional alternative embodiments of the invention may be implemented differently e.g. only allow a subset of the plurality of identifiers to be conditional .

Further circled numbers and letters are used in to illustrate the order in which operations are performed according to one embodiment of the invention. Also a notation X Y Z is used in to represent a producer key made up of a class key X an instance key Y and a method key Z . Further dashed circles and arrowed lines represent operations that are not performed in some embodiments of the invention. In particular where the execution of an independent dependency determination producer for a given dependency will always return the same dependency e.g. an independent dependency determination producer such dependency determination producer in some embodiments of the invention is executed but not instantiated and linked in the producer graph s .

In a circled indicates that the producer dependency declaration is accessed e.g. as a result of designation of a producer based on the method alpha as a producer of interest as a result of automated discovery of a producer based on the method alpha as a progeny of a producer of interest etc. . A circled in shows that a producer C0 I0 ALPHA is instantiated based on the method alpha . A circled in indicates that the producer dependency to producer CW IY BETA is processed to determine the producer dependency and as a result a circled indicates that the producer dependency declaration is accessed. A dashed circled in shows that a producer CW IY BETA is instantiated as a dependency determination producer . A dashed circled in indicates that the producer C0 I0 ALPHA is linked in the producer graph to indicate that producer CW IY BETA is a child producer. A circled in indicates that the producer CW IY BETA is executed and returns DEP to identify producer . A circled indicates producer is instantiated while a circled indicates the producer being linked as a child producer in the producer graph to the producer C0 I0 ALPHA. In producer C0 I0 ALPHA and producer are standard producers they are not dependency determination producers .

In a circled indicates that the producer dependency declaration is accessed e.g. as a result of designation of a producer based on the method alpha as a producer of interest as a result of automated discovery of a producer based on the method alpha as a progeny of a producer of interest etc. . A circled in shows that the producer is instantiated based on the method alpha . A circled in indicates that the producer dependency to producer CW IY BETA is processed to determine the producer dependency and as a result a circled indicates that the producer dependency declaration is accessed. A circled in shows that a producer CW IY BETA is instantiated as a dependency determination producer . A circled in indicates that the producer is linked in the producer graph to indicate that producer CW IY BETA is a child producer.

A circled in indicates that the producer dependency to producer CU IV DELTA is processed to determine the producer dependency and as a result a circled indicates that the producer dependency declaration is accessed. A dashed circled in shows that a producer CU IV DELTA is instantiated as a dependency determination producer . A dashed circled in indicates that the producer CW IY BETA is linked in the producer graph to indicate that producer CU IV DELTA is a child producer. A circled in indicates that the producer CU IV DELTA is executed and returns DEP to identify CX IZ GAMMA. A circled indicates that the producer CX IZ GAMMA is instantiated while a circled indicates the producer CX IZ GAMMA being linked as a child producer in the producer graph to the producer CW IY BETA.

In a circled A indicates that the producer CX IZ GAMMA is executed and returns X to producer CW IY BETA while a circled B indicates that the producer CW IY BETA returns DEP to identify producer A a circled C indicates that the unresolved remainder method beta is now resolved and producer A is instantiated while a circled D indicates the linking of the producer to the producer A. In producers CX IZ GAMMA and A are standard producers .

The on the fly generation by the runtime of the dependency determination producer CW IY FLY alleviates the application programmer from having to write explicit producer dependency declaration code and instantiate a dependency determination producer based thereon. Further it allows the application programmer to directly specify the dependency on producer CX IZ GAMMA in the producer dependency declaration statement for the method beta as opposed to specifying the dependency determination producer CU IV DELTA.

The shortcut technique can be used in a variety of situations and may additionally have a variety of formats. For example while in the shortcut declared dependency is for a non contingent dependency it directly identifies the child producer and is in a producer dependency declaration statement for a method on which a dependency determination producer is based other situations and formats are shown as follows 1 illustrate the use of two shortcuts where one is contingent and is part of a producer dependency declaration statement for a method on which a standard producer is based and the other is non contingent and is part of a producer dependency declaration statement for a method on which a dependency determination producer is based and 2 figures I J illustrate the use of a shortcut that is non contingent and that is in a producer dependency declaration statement for a method on which a standard producer is based.

The method FLY1 and its producer dependency declaration statement are provided by the runtime responsive to the shortcut declared dependency GETC1 I1 M1 which indicates that the shortcut is being used for the class key . The method fly1 includes producer dependency declaration code that sets DEP.TYPE to non subscription downwardly declared sets DEP.PROD to producer CX I1 M1 or CY I1 M1 depending on the value of C1 output by the producer C0 I0 GETC1 and returns DEP. While in the example of a is used to designate that it is the class key of the producer that is contingent alternative embodiments of the invention could use other syntaxes. Further while in the example of a is used to designate that it is the class key of the producer that is contingent one embodiment of the invention supports having more and or different ones of the identifiers that make up the producer key be indicated as contingent in this manner.

In a circled indicates that the producer dependency declaration is accessed e.g. as a result of designation of a producer based on the method alpha as a producer of interest as a result of automated discovery of a producer based on the method alpha as a progeny of a producer of interest etc. . A circled in shows that the producer C0 I0 ALPHA is instantiated based on the method alpha . A circled in indicates that the shortcut declared producer dependency is processed to determine the producer dependency and the runtime provides the method fly1 and as a result a circled indicates that the producer dependency declaration is accessed.

A circled in shows that a producer C0 I0 FLY1 is instantiated as a dependency determination producer . A circled in indicates that the producer C0 I0 ALPHA is linked in the producer graph to indicate that producer C0 I0 FLY1 is a child producer. A circled in indicates that the shortcut declared producer dependency to producer C0 I0 GETC1 is processed to determine the producer dependency and the runtime provides the method fly2 and as a result a circled indicates that the producer dependency declaration is accessed. A dashed circled in shows that a producer C0 I0 FLY2 is instantiated. A dashed circled in indicates that the producer C0 I0 FLY1 is linked in the producer graph to indicate that producer C0 I0 FLY2 is a child producer.

A circled in indicates that the producer C0 I0 FLY2 is executed and returns DEP to identify producer C0 I0 GETC1. A circled indicates that the producer C0 I0 GETC1 is instantiated while a circled indicates that the producer C0 I0 GETC1 being linked in the producer graph to the producer C0 I0 FLY1 as a child producer.

In a circled A indicates that the producer C0 I0 GETC1 is executed and returns C1 CX to producer C0 I0 FLY1 while a circled B indicates that the producer C0 I0 FLY1 is executed and returns DEP to identify producer CX I1 M1 a circled C indicates that the unresolved remainder method fly1 is now resolved and a circled D indicates the linking of the producer C0 I0 ALPHA to the producer CX I1 M1. In producers C0 I0 GETC1 C0 I0 ALPHA and CX I1 M1 are standard producers .

The on the fly generation by the runtime of the dependency determination producer C0 I0 FLY1 and C0 I0 FLY2 alleviates the application programmer from having to write explicit producer dependency declaration code and instantiate dependency determination producers based thereon. Further it allows the application programmer to directly specify the contingent dependency on a producer I1 M1 through the method getC1 in the producer dependency declaration statement for the method alpha as opposed to specifying the dependency determination producer CW IY BETA.

In a circled indicates that the producer dependency declaration is accessed e.g. as a result of designation of a producer based on the method alpha as a producer of interest as a result of automated discovery of a producer based on the method alpha as a progeny of a producer of interest etc. . A circled in shows that a producer C0 I0 ALPHA is instantiated based on the method alpha . A circled in indicates that the shortcut declared producer dependency is processed to determine the producer dependency and the runtime provides the method fly and as a result a circled indicates that the producer dependency declaration is accessed. A dashed circled in shows that a producer C0 I0 FLY is instantiated as a dependency determination producer . A dashed circled in indicates that the producer C0 I0 ALPHA is linked in the producer graph to indicate that producer C0 I0 FLY is a child producer.

A circled in indicates that the producer C0 I0 FLY is executed and returns DEP to identify producer . A circled indicates producer is instantiated while a circled indicates the producer C0 I0 ALPHA being linked in the producer graph to indicate that producer is a child producer. In producer C0 I0 ALPHA and producer are standard producers .

It should be understood that the runtime programmer in one embodiment of the invention writes a single fly method to interpret all supported syntaxes and combinations e.g. the method fly the method fly1 the method fly2 the method fly and includes it in the runtime. This not only allows applications programmers to avoid writing code for dependency determination producers where a fly method may be used the runtime programmer need only write the generic fly method the single fly for all supported situations once. Further it should be understood that shortcut declared dependencies allow for a runtime that uses dependency determination producers while at the same time allowing an application programmer to indicate standard producers in the producer dependency declarations e.g. .

Referring back to the method tracking structure of exemplary contents of the ArgumentDependencies column FieldDependencies column SequencingDependencies column UpwardDependencies column and WeaklyConstrainedDependencies column used in some embodiments of the invention will now be described. Specifically the ArgumentDependencies column stores a collection of items one for each ArgumentDependency. In one embodiment of the invention each item includes the following 1 the argument ID 2 a class key nature identifier being one of explicit class same class and contingent class 3 an explicit class key identifier populated when the class key nature identifier indicates explicit class 4 contingent class determination method key identifier populated when the class key nature identifier indicates contingent class 5 an instance key nature identifier being one of explicit instance same instance and contingent instance 6 an explicit instance key identifier populated when the instance key nature identifier indicates explicit instance 7 contingent instance determination method key identifier populated when the instance key nature identifier indicates contingent instance 8 a method key nature identifier being one of explicit method same method and contingent method 9 an explicit method key identifier populated when the method key nature identifier indicates explicit method 10 contingent method determination method key identifier populated when the method key nature identifier indicates contingent method and 11 a shortcut identifier that indicates if the producer dependency declaration for the argument in the producer dependency declaration statement contained an indication of shortcut i.e. the producer dependency declaration statement directly identifies a standard child producer instead of a dependency determination producer .

The . . . explicit indication of the various key nature identifiers is used where the explicit key is provided for the producer dependency in the producer dependency declaration statement. By way of example the producer dependency CW IY BETA of the producer dependency declaration statement of provides an explicit class instance and method key.

In some embodiments of the invention a shorthand technique is supported for the producer dependency declaration statements such that 1 if a class is not provided for a given producer dependency then the same class as the parent producer is used and 2 if a class and instance are not provided for a given producer dependency then the same class and instance as the parent producer are used. In other embodiments of the invention a syntax is used to allow any combination of class instance and method to be the same as the parent with the exception of all being the same e.g. a separator is used to designate each of class instance and method and an absence of such a separator indicates same as parent by way of specific example the syntax may be C I and M such that a producer dependency in a producer dependency declaration statement may be C class key I instance key M method key . where quotes indicate a placeholder for a value or variable The . . . same indication of the various key nature identifiers is used where this shorthand technique is used in the producer dependency declaration statement.

As previously indicated in some embodiments of the invention an indication of a contingent producer dependency is supported through a syntax e.g. used in the producer dependency declaration statement itself see of and such syntax can be used on one or more of the class instance and method of a producer dependency. The . . . contingent indication of the various key nature identifiers is used to identify when such a contingent producer dependency occurs while the contingent . . . determination method key identifier indicates the method key of the child producer the class and the instance are the same as that of the parent producer . By way of example the producer dependency GETC1 I1 M1 for the producer dependency declaration of provides a contingent class where the contingent class determination method key is GETC1 an explicit instance key and an explicit method key.

The SequencingDependencies column the UpwardDependencies column and the WeaklyConstrainedDependencies column each store a collection of items one for each SequencingDependency UpwardDependency and WeaklyConstrainedDependency. In one embodiment of the invention each such item has the same structure as an item of the collection for the ArgumentDependencies except that it does not include an argument ID. Further although illustrated non subscription downwardly declared dependencies originating from dependency determination producers it should be understood that in the case of an upwardly declared dependency or weakly constrained dependency the dependency determination producer may return the other dependencies discussed with reference to .

The FieldDependencies column stores a collection of items one for each FieldDependency. While in one embodiment of the invention each item includes the property method key in alternative embodiments of the invention may have the same structure as an item of the collection from SequencingDependencies.

In one embodiment of the invention both non subscription and subscription producer dependencies are supported. When a subscription producer dependency is declared for a given method and a given producer is instantiated from that given method the runtime can resolve during run time based upon the existence of other producers the set of zero or more producers that meet the criteria of the subscription. While one embodiment of the invention supports both non subscription and subscription producer dependencies alternative embodiments support only non subscription. In addition while in one embodiment of the invention two types of subscription dependencies are supported absorbing and sticky alternative embodiments of the invention support more less and or different types of subscription producer dependencies.

In a subscriber s producer key column a subscription type column and a subscription criteria for trigger producer s column are shown to respectively store the content corresponding to the column name. In addition shows a parent link mode column to store the link mode for the parent producer of the subscription dependency this information will be described in more detail with regard to .

In an absorbing subscription producer dependency the dependency is to the collection of all producers of the current producer graph s structure that meet the absorbing subscription criteria. With reference to a circled indicates a producer is instantiated e.g. as a result of designation of the producer as a producer of interest as a result of automated discovery of the producer as a progeny of a producer of interest etc. . The producer is based on a method for which the producer dependency declaration includes a producer dependency e.g. with argument ID X . A circled indicates the producer dependency of the producer is processed to identify a producer .

A circled indicates that the producer is linked in the above example through argument ID X in the producer graph to producer as a child producer. A circled indicates execution of the producer . The producer is a dependency determination producer that includes producer dependency declaration code indicating an absorbing subscription producer dependency and indicating the absorbing subscription criteria. As such the execution of the producer results in populating the subscription log. With regard to the example in the first row of the subscriber s producer key column the subscription type column the subscription criteria for trigger producers column the parent link mode column and the dependency determination producer reference column are respectively populated with the producer key of the producer an indication that the subscription is of the absorbing type the absorbing subscription criteria contained within the producer the link mode of the producer linked to the producer which in the case of an absorbing subscription will be an argument dependency and include an argument ID but whose sticky indicator will indicate not sticky in the above example argument ID X and a reference to the producer the dependency determination producer that cerates the subscription .

Circled A N indicates the instantiation of producer s A N. In this example the producer s A N meet the absorbing subscription criteria and thus are trigger producers. As such circled A N indicates the linking of the producer to the producer s A N in the above example through argument ID X . A circled indicates that the absorbing subscription dependency is completed for the current execution of the producer graph s and the producer is then executed.

In one embodiment of the invention the absorbing subscription criteria can be one or more of any of the keys making up a producer key. Thus in embodiments of the invention where a producer key comprises a class key instance key and a method key the subscription criteria could be one or more such keys. By way of example with reference to a scan through the instantiated producers for those that meet the subscription criteria is a scan through one or more of the first three columns of the producer graph s structure to determine if the keys of the instantiated producers match the keys of the absorbing subscription criteria. While in one embodiment of the invention the absorbing subscription criteria can be one or more of any of the keys making up a producer key in alternative embodiments of the invention the absorbing subscription criteria is limited to a subset of the keys making up a producer key.

In a sticky subscription producer dependency the dependency causes a parent producer to be instantiated for each producer that meets the sticky subscription criteria. With reference to a circled indicates a producer is instantiated e.g. as a result of designation of the producer as a producer of interest as a result of automated discovery of the producer as a progeny of a producer of interest through a sequencing dependency e.g. as a result of a SequencingDependency or WeaklyConstrainedDependency etc. . The producer is a dependency determination producer that includes producer dependency declaration code indicating a sticky subscription the sticky subscription criteria for the trigger producers and the sticky subscription characteristics for the parent producer to be created.

Execution of the producer results in populating the subscription log. With regard to the example in the second row of the subscriber s producer key column the subscription type column and the subscription criteria for trigger producers column are respectively populated with the producer key of the producer an indication that the subscription is of the sticky type and the sticky subscription criteria for the trigger producers contained within the producer . In addition the parent class column the parent method column the parent instance column and the link mode column of the parent producer to be linked to the trigger producer are populated with the sticky subscription characteristics for the parent producer to be created in this embodiment of the invention respectively the class of the parent producer to be instantiated the method of the parent producer to be instantiated the instance of the parent producer to be instantiated if left blank would be equal to the instance key of the trigger producer the link mode which in the case of sticky subscription may be 1 argument field or sequencing dependency 2 argument ID if an argument dependency the argument ID of the parent producer to be linked to the trigger producer e.g. argument ID Y . In addition the dependency determination producer reference column is populated with a reference to the dependency determination producer that created the subscription in the producer .

With reference to a circled indicates a producer is instantiated e.g. as a result of designation of the producer as a producer of interest as a result of automated discovery of the producer as a progeny of a producer of interest etc. . In addition it is determined if the producer meets the sticky subscription criteria for a trigger producer. A circled indicates that responsive to the trigger producer a producer is instantiated based on the sticky subscription characteristics for the parent producer to be created. With reference to the exemplary second row of the class key method key instance key and link mode are accessed from the parent class column the parent method column the instance column and the parent link mode column respectively. The parent producer has a producer key comprising the accessed class key the accessed instance key if left blank the instance key of the trigger producer in the producer and the accessed method key in the example of this is producer . A circled indicates that the instantiated parent producer is linked in the producer graph to the child trigger producer through the accessed link mode in the above example link mode type argument dependency link mode argument ID Y . Also at circled in the case of an argument dependency the sticky indicator is set to indicate sticky that the producer dependency in that position of the producer dependency declaration statement for the method on which the instantiated parent producer is based should be ignored for the producer this prevents the link created by the sticky subscription producer dependency from being overwritten by later automated producer graph generation operations.

In one embodiment of the invention the sticky subscription criteria for trigger producers can be one or more of the keys making up a producer key. Thus in embodiments where a producer key comprises a class key instance key and a method key the sticky subscription criteria for the trigger could be one or more of the class instance and method keys. By way of example with reference to a scan through the instantiated producers for those that meet the sticky subscription criteria for trigger producers is a scan through one or more of the first third columns of the producer graph s structure to determine if the keys of the instantiated producers match the keys of the sticky subscription criteria for trigger producers. While in one embodiment of the invention the sticky subscription criteria for trigger producers can be one or more of the keys making up a producer key in alternative embodiments of the invention the absorbing subscription criteria can be a more limited number of the keys making up a producer key.

It is worth nothing that sticky subscriptions and non subscription upwardly declared dependencies e.g. created through UpwardDependencies and or WeaklyConstrainedDependencies cause a bottom up building of a producer graph as opposed to the top down building described earlier herein . Further this bottom up building is not limited to the building of a single level but may be multiple level e.g. if due to a sticky subscription or non subscription upwardly declared dependency a parent producer is instantiated that same parent producer may also be a trigger producer for a sticky subscription or may include a non subscription upwardly declared dependency and cause the instantiation of another parent producer and so on . In this sense sticky subscriptions as well as non subscription upwardly declared dependencies reverse producer graph building.

While in some embodiments of the invention the parent producers identified by the sticky subscription characteristics are standard producers see alternative embodiments may be implemented to support the identification of other types of producers. For example in embodiments of the invention that allow the sticky subscription characteristics to identify a dependency determination producer see such a dependency determination producer may access the output of the trigger producer and may based on that output trigger the creation of a particular producer as a parent producer that needs to stick on the child this parent producer might already exist or not If it already exists it is simply linked and the child producer is added to its argument If is does not exist yet it is created . The case where the dependency determination producer returns a constant producer mimics an absorbing subscription. The case where the dependency determination producer returns a producer whose instance key is unique per trigger producer e.g. returns a producer whose instance key is the producer key of the trigger producer results in a separate parent producer per child producer and is referred to as a pure sticky subscription. The case where the dependency determination producer returns an instance key which is neither constant nor unique per trigger producer can mix the behaviors of pure sticky subscriptions and absorbing subscriptions and is referred to as a non pure sticky subscription.

As previously described in one embodiment of the invention producer dependencies are declared for methods as a way to specify method invocation sequencing using the appropriate instances where the appropriate instances include the instances to use as arguments the instances to be used by instance methods and the meta class instances used by class methods without using manual invocation sequencing code effectively the work of generating some or all of manual invocation sequencing code is replaced with 1 work done by the application programmer to write the producer dependency declarations and 2 work done by the runtime to discover and build the producer graph s and execute the producers of that producer graph s . Although the effort to write the runtime is relatively great it needs only be written once in that it can be used to execute any object oriented applications written for the runtime in contrast for a typical application the effort to write the producer dependency declarations is relatively low in comparison to writing manual invocation sequencing code.

Non dynamic producer dependencies provide for a way to specify unconditional method invocation sequencing code and thus avoid the need for writing unconditional manual invocation sequencing code. Contingent producer dependencies provide for a way to specify conditional processing and thus replace the need for writing conditional manual invocation sequencing code. Supporting producer dependencies that allow for a collection of producers to be returned provides for a way to specify the filling of a collection before it is passed as a parameter and thus avoid the need for writing multiple calls in manual invocation sequencing code to fill a collection before it is passed as a parameter. Supporting subscriptions provides an environment in which a programmer need not write specific listening code for each type of object to be listened to e.g. in a producer graph oriented programming spreadsheet an absorbing subscription may be used to compute an average of a range of cells each cell being a producer by having the absorbing subscription criteria identify cells within the range and re computing the average every time a new producer is added to the absorbing subscription in a producer graph oriented programming spreadsheet a sticky subscription may be used as a currency converter by having the sticky subscription criteria identify cells holding currency content and sticky subscription characteristics of sticky producer s to be instantiated that perform currency conversion the producers holding the converted amounts created by the sticky subscriptions would then be available for display in other cells .

Responsive to a new instance command block control passes to block . In block it is determined if the instance already exists. If not control passes to block otherwise the instance need not be instantiated and control passes to block in which the flow diagram ends. In one embodiment that supports instance keys block is performed by accessing the instance tracking structure of for the instance key and class key if instance keys need not be unique across classes provided as part of the new instance command.

In block it is determined if the class definition of the instance is already loaded. If not control passes to block otherwise control passes to block . In one embodiment that supports class keys block is performed by accessing the class tracking structure of for the class key provided as part of the new instance command.

In block the class is loaded and control passes to block . In block the class definition would be stored according to the class key and introspected including any producer dependency declaration statements stored by method key within the class see . From block control passes to block . With reference to the following is performed in blocks and 1 the class would be loaded from the class definitions that include business logic into the classes this loading results in the methods and producer dependency declarations of the class being stored in the method and producer dependency declarations 2 the class would be added to the class tracking structure and 3 the methods would be added to the method tracking structure . Further the output classes of the methods would be loaded.

In block an instance of the class would be instantiated and stored according to the instance key. With reference to the instance would be instantiated into the instances and the instance would be added to the instance tracking structure . From block control passes to block in which the flow diagram ends. In some embodiments of the invention in which an object relational mapping technique is used data may be loaded from an external data source to populate the field of the instance as part of block .

In some embodiments of the invention classes and instances may be loaded instantiated in a manner in which the runtime with producer graph oriented programming support is not aware e.g. in if the runtime loads instantiates without runtime being aware . In such cases embodiments of the invention which also support the instance key being an instance of the class InstanceKey which holds two elements an instance key nature indicating if the key identifier is a reference to the instance or another object such as a string and a key identifier which can either be a reference to the instance or another object such as a string blocks and inquire whether the instance and class were instantiated loaded in a manner in which the runtime with producer graph oriented programming support is aware. In cases where the runtime with producer graph oriented programming support is not aware of an already loaded class the class would not be loaded but the class would be added to the class tracking structure and the methods would be added to the method tracking structure . In cases where the runtime with producer graph oriented programming support is not aware of an already instantiated instance the instance would not be instantiated but the instance would be added to the instance tracking structure .

Responsive to a new producer command block control passes to block . In one embodiment of the invention a new producer command may execute responsive to a variety of situations. Table 2 below identifies the various situations and parameters passed according to one embodiment of the invention.

In block it is determined if the producer already exists. If not control passes to block otherwise control passes to block . Block is performed by accessing a class instance and method identified e.g. by key and or reference as part of the new producer command. In one embodiment that supports producer keys block is performed by accessing the producer graph s structure of for the producer key provided as part of the new producer command the producer key in the called producer column of Table 2 .

In block the new instance module is called with a new instance command and control passes to block . In one embodiment of the invention block is performed by calling the flow diagram of using the instance key from the producer key in the called producer column of Table 2.

In block the class definition of the instance of the producer is accessed and control passes to block . With reference to block is performed by using the class key from the producer key in the called producer column of Table 2 to access the appropriate one of the classes according to the class tracking structure .

In block the method and producer dependency declaration statement of the producer is accessed and control passes to block . With reference to block is performed by using the method key from the producer key in the called producer column of Table 2 to access the appropriate one of the methods and producer dependency declarations from the class located in block .

In block the producer is added to the producer graph and control passes to block . With reference to the embodiment of the invention in the first three columns are populated.

In block for each registered subscription the subscription filtering criteria is processed to determine if the producer matches. With reference to the embodiment of the invention in a subscription is considered registered when it is added to the subscription log. Exemplary operations to register subscription are described later herein. Block is an optional optimization that allows for the work of scanning the instantiated producers to be divided between automated producer graph generation and producer graph execution. As such an alternative embodiment of the invention may not perform block .

In block the producer is linked into the producer graph s if called due to a dependency. From block control passes to block . The manner of performing block depends on the situation which resulted in the new producer command being executed see . For example if the situation is that this is a producer of interest or a producer being overridden then it was not called due to a dependency and nothing is done. In contrast if the situation is non subscription downwardly declared then it was called due to a non subscription downwardly declared dependency and with reference to the embodiment of the invention in the following is performed 1 the parent producer s link s in column of the called child producer the called producer column of table 2 is modified with a parent producer reference to the row of the parent caller producer the caller producer column of table 2 and the dependency determination producer reference the dependency determination producer reference column of Table 2 and 2 the child producer s link s column of the row of the parent caller producer the caller producer column of table 2 is modified with a child producer reference to the row of the called child producer the called producer column of Table 2 a dependency determination producer reference the dependency determination producer reference column of Table 2 and a link mode set according to the link mode column of Table 2 .

In contrast if the situation is a sticky subscription then it was called due to a trigger producer being identified and with reference to the embodiment of the invention in the following is performed 1 the parent producer s link s column of the caller child producer the caller producer column of table 2 is modified with a parent producer reference to the row of the parent called producer the called producer column of table 2 and the dependency determination producer reference the dependency determination producer reference column of Table 2 and 2 the child producer s link s of the row of the parent called producer the called producer column of table 2 is modified with a child producer reference to the row of the caller child producer the caller producer column of Table 2 a dependency determination producer reference the dependency determination producer reference column of Table 2 a link mode set according to the link mode column of Table 2 and a sticky indicator set to indicate sticky. In this respect the situation of a non subscription upwardly declared is handled is a similar fashion to sticky subscription.

In block the producer is marked as unexecuted and control passes to block . With reference to the embodiment of the invention in the incremental execution marking column of the appropriate row is populated with an unexecuted indication.

In block it is determined if the producer has any dependencies and is not overridden. If so control passes to block otherwise control passes to block . Block is performed by checking the producer dependency declaration accessed in block and the call type column of Table 2.

In block for each dependency in the producer dependency declaration that is to be resolved now the number of producers is determined and a new producer command is invoked for each. From block control passes to block . Different embodiments of the invention determine different types of dependency at different times the manner of performing block in one exemplary embodiment of the invention will be described later herein.

In block the producer is added to the execution start log if all its dependent producers exist and have been executed. From block control passes to block . When for a given producer instantiated as part of the current iteration of this flow block is performed then the invocation of another iteration of this flow for a producer the given producer depends on will return the execution status of that producer see block e.g. with regard to the embodiment of the invention of the status from the incremental execution marking column of the appropriate row s . If all the dependent producer s exist and the execution status of all of the dependent producers is executed then the producer of the current iteration is added to the execution start log.

In block similar to block the producer is linked into the producer graph s if called due to a dependency. From block control passes to block . Block may be reached for a variety of reasons. For example block may be reached because the producer was previously instantiated responsive to a producer override command but not linked into the producer graph. As another example block may be reached because the producer is already part of a producer graph and is being added to another e.g. previously instantiated responsive to being a producer of interest a progeny of a producer of interest etc. .

In block it is determined if the new producer flow is called due to an override to a sticky subscription dependency or a non subscription upwardly declared dependency. If so control passes to block otherwise control passes to block . Block is performed by checking the call type column of Table 2 to see if this is a call for an overridden producer a sticky subscription dependency or a non subscription upwardly declared dependency.

In block similar to block the producer is marked as unexecuted and control passes to block . Block may be reached for a variety of reasons.

In block the producer is added to the execution start log if not already present and control passes to block .

Responsive to a producer unoverride command block control passes to block . In block the producer is marked as not overridden and control passes to block . With reference to the embodiment of the invention of the producer output caching and override producer output indications column of the row of the producer are accessed and altered to indicate that the producer is no longer overridden. Continuing this flow block would lead to block and if the producer had any dependencies to block which would cause the producer graph under the producer to be discovered and built if it was not already. If the producer graph under the producer is already discovered and built then the invoking of the new producer command will result in flows going from to to and so on further the returning of the execution status of the producers of the graph under the producer in block will determine if the producer is added to the execution start log in block . However if the producer graph under the producer is not discovered and built then the invoking of the new producer command will result in it being discovered and build with flows going from to to and so on.

In block it is determined if the dependency is an argument dependency linked already due to a sticky dependency. If so control passes to block where the flow is complete for this dependency otherwise control passes to block . With regard to the embodiment of the invention show in the sticky indicator is checked to determine if the argument ID of this dependency is subject to a sticky subscription argument dependency or an upwardly declared argument dependency.

In block it is determined if the dependency is a contingent dependency. If so control passes to block otherwise control passes to block . Block is performed by checking the producer dependency declaration of the child producer identified by the dependency to determine if it is empty the child producer is and independent producer . With regard to this would be true for producers with dashed circled numbers e.g. in producer CU IV DELTA but not true for the other producers e.g. in producer CW IY BETA . Thus with reference to block is represented by circled and . Block and the flow from it through blocks is an optimization that both avoid adding linking the producers with dashed circled numbers to the producer graph as well as dividing the work of executing producers between the automated producer graph generation and producer graph execution.

In block a new producer command for the dependency determination producer is invoked and the flow ends. For example with reference to block causes what is represented by circled and .

In block the dependency determination producer is executed and control passes to block . For example with reference to block is represented by circled thus the flow of illustrated the previously described embodiment in which circled and of are not performed .

In block it is determined if the dependency is a non subscription dependency. If so control passes to block otherwise control passes to block . In other words in block the producer dependency determination code in the method of the dependency determination producer which is part of the producer dependency declaration of the parent producer is executed. Having executed this producer dependency declaration code which code would identify if this dependency is a subscription dependency the type of producer dependency of the parent producer is determined. With regard to the example in circled would result in the flow of passing from block to block .

In block the number of producers returned by the execution of the dependency determination producer in block is determined and a new producer command is invoked for each using the arguments described in Table 2 including the dependency determination producer reference executed in . For example with reference to block would cause circled and and circled C and D.

With reference to the absorbing subscription example of block represents circled which causes the flow to pass through block to block .

In block the subscription is added to the subscription log and if the subscription is absorbing it is marked as incomplete. From block control passes to block . With reference to the embodiment of the invention shown in the subscription log is populated with the subscription as previously described.

In block all of the instantiated producers are scanned to see if they match the criteria of the subscription and thus are a trigger producer and any matches are processed.

In block it is determined if the producer meets the criteria of the subscription. If so control passes to block otherwise control passes to block where the flow ends for the producer currently being processed. With reference to the embodiments of the invention shown in the producer graph s are accessed to determine whether they include producers that meet the criteria of the subscription.

The manner of processing a matching producer depends on the type of subscription being processed. With reference to block if the subscription is of the absorbing type control passes to block otherwise control passes to block . Block would be performed responsive to the type of subscription added in block or .

In block the matching producer is added to the subscription log and the producer with the absorbing subscription is linked to the matching producer. From block control passes to block . With reference to the embodiments of the invention shown in FIGS. C and A B the following is performed 1 the subscription criteria from the subscription criteria for trigger producers column was used in block and a matching producer was located e.g. one of producer A N 2 the matching producer is added to the matching producer column at the row of the subscription and 3 the producer with the absorbing subscription e.g. producer is linked to the matching producer e.g. the one of the producers A N in the producer graph s structure of using the dependency determination producer reference extracted from the dependency determination producer reference column of the subscription log A for the given absorbing subscription .

In block a new producer command is invoked for the parent producer to be created. From block control passes to block where the flow diagram ends for the current produced selected in block . With reference to the embodiments of the invention shown in the following is performed 1 the subscription criteria from the subscription criteria for trigger producers column was used in block and a matching producer was located e.g. producer and 2 a new producer command is invoked with the parameters of table 2 set as follows a call type is sticky subscription b caller producer is the producer key of the caller child producer e.g. producer c called producer is the producer key of the called parent producer to be created e.g. producer that producer key being formed using the parent class instance and method key from the sticky subscription characteristics for the parent producer to be created columns and if the instance key is empty the instance key of caller child producer is used d the link mode for the called parent producer link mode column and e the dependency determination producer reference extracted from the dependency determination producer reference column of the subscription log A for the given sticky subscription.

Block indicates the flow is performed for each registered subscription whereas block indicates the flow is performed for each instantiated producer. Thus where the flow of is centered on a single subscription and scanning all producers the flow of is centered on a single producer and scanning all subscriptions.

Block is the same as block with the exception that the absorbing subscription is marked as incomplete. With reference to the embodiment of the invention shown in the completed column at the appropriate row is updated to indicate incomplete.

In block it is determined if the flow was called due to a sticky subscription or non subscription upwardly declared situation. If not control passes to block otherwise control passes to block . Block is performed by checking the call type parameter from Table 2 i.e. whether the call type is sticky subscription or non subscription upwardly declared or not . With reference to the embodiments of the invention shown in if the new producer command was invoked from blocks or .

In block the current parent producer is linked to the caller child producer. With reference to the embodiments of the invention shown in the called parent producer e.g. producer identified by the parameter from the called producer column of table 2 is linked in the producer graph s structure of to the caller child producer e.g. producer identified by the parameter from the caller producer column of table 2 using the link mode and dependency determination producer reference identified by the parameter from the link mode and dependency determination producer reference columns of table 2. If the parent existed previously the behavior of block mimics the behavior of an absorbing subscription dependency in the sense that a single argument can be mapped to zero or more child producers.

In block the caller parent producer is linked to the current called child producer. With reference to the embodiment of the invention shown in the caller parent producer identified by the parameter from the caller producer column of table 2 is linked in the producer graph s structure of to the called child producer identified by the parameter from the called producer column of table 2 using the dependency determination producer reference identified by the dependency determination producer reference column of table 2. From blocks and control passes to block or depending for where the flow was entered from block or .

Responsive to an override producer command block control passes to block . In block a new producer command is invoked for the producer identified by the override producer command and control passes to block . Block is performed in one embodiment of the invention in case the producer to be overridden has not yet been instantiated as well as to mark the producer as unexecuted block or and log it on the execution start log block . An alternative embodiment of the invention that does not allow the overriding of a producer that is not yet instantiated would perform an additional check between blocks and to determine if this new producer command was called responsive to an override producer command and to indicate an error if this new producer command was called responsive to an override producer command.

In block the output in the producer output cache and in the instance if a field is set and the producer is marked as overridden.

Responsive to a global execute command block shows that a set of candidate producers is selected to be executed based on the producers on the execution start log and control passes to block . In one embodiment of the invention the overridden producers are marked as unexecuted and execution thereof returns their overridden result as opposed to causing their method to be executed the current set of candidate producers is the producers on the execution start log. While one embodiment of the invention is described above in which overridden producers are marked as unexecuted and execution thereof returns their overridden result as opposed to causing their method to be executed alternative embodiments may operate differently e.g. mark overridden producers as executed and when selecting the current set of candidate producers the independent producers of the execution start log and the parents of overridden producers on the execution start log are selected .

In block a subset of producers ready for execution is selected from the set of candidate producers and control passes to block . An exemplary manner of performing block is described later herein.

In block the producers of the current set of ready producers are sorted by type standard producers go the block and dependency determination producers go to block . In one embodiment of the invention block is performed by checking the return class of the producer. With reference to the the method tracking structure is accessed to determine if the output class of the producer is DEP and thus this producer is a dependency determination producer.

In block any standard producers in the current set of ready producers are executed and control passes to block . In one embodiment of the invention block is performed by calling the method with any input parameters mapped from the outputs of any child producers resulting from argument dependencies for arguments the argument ID of the link mode is used to map the output of the appropriate child producer to the appropriate input argument of the method being executed . In some embodiments of the invention such execution may result in execution of code in the method of a child producer that writes an output to a given mechanism such as set a global variable sets a field in an instance which is not the producer output impacts an external data source etc. or code in the method of the parent producer that read that output from the given mechanism . In block for those parents if any that have an absorbing subscription on any of these executed standard producers the subscription is marked as incomplete. From block control passes to block . With reference to the appropriate row of the completed column is set to indicate incomplete.

In block any dependency determination producers in the current set of ready producers are prepared for execution and control passes to block . An exemplary manner of performing block is described later herein.

In block any dependency determination producers in the current set of ready producers are executed and control passes to block . In one embodiment of the invention block is performed in similar fashion to block .

In block a new producer command is executed for any discovered producers and subscription logging and processing is performed for any subscriptions. The new producer command part of block is performed in similar manner to block while the subscription logging and processing is performed in similar manner to blocks and .

In block add to the set of candidate producers newly added to the execution start log. From block control passes to block . Block is performed in similar manner to block except only producers newly added to the execution start log as a result of blocks and are added to the set of candidate producers.

In block the producers that were executed are marked as executed the producer output caching and instance caching are updated as necessary any parent producers of the producers that were executed are added to the current set of candidate producers and the producers that were executed are removed from the current set of candidate and ready producers. From block control passes to block .

In block it is determined if the set of candidate producers is empty. If not control passes back to block otherwise control passes to block .

In block it is determined in all subscriptions have been completed. If so control passes to block where the flow diagram ends otherwise control passes to block . With reference to the embodiment of the invention in the subscription type column and the complete column are scanned for any absorbing subscriptions that are not completed.

In block the incomplete absorbing subscriptions are processed and control passes back to block . An exemplary manner of performing block is described later herein.

In block it is determined if the producer has any absorbing subscription dependency that is incomplete. If so control passes to block otherwise control passes to block . With reference to the embodiment of the subscriber s producer key column and subscription type column is scanned for a matching to the current selected producer and absorbing subscription type and if a match is found the completed column at the appropriate row is checked to determine the status of that absorbing subscription dependency.

In block it is determined if the producers on which the currently selected producer depends are executed. If not control passes to block otherwise control passes to block . With regard to the embodiment of the invention shown in the incremental execution markings column for the rows of the child dependencies are checked to determined the execution status of the currently selected producer s children.

In block the currently selected candidate producer is added to the current set of ready producers and control passes to block .

In block the type of any previous dependencies generated by the currently selected dependency determination producer is determined. If the type of the dependency is non subscription then control passes to block if the type is absorbing subscription then control passes to block whereas if the type is sticky subscription then control passes to block . Block is determined by checking the current output of the producer stored in the producer output caching. With reference to the class DEP the output would indicate non subscription absorbing subscription and sticky subscription.

In both blocks and the entry is removed from the subscription log. With reference to the embodiment of the invention shown in the following is performed 1 for absorbing subscriptions block the dependency determination producer e.g. producer is used to determine its parent producer e.g. producer in the producer graph s and then the parent producer is looked up in the subscription log and its entry removed and 2 for sticky subscriptions block the dependency determination producer e.g. producer is looked up in the subscription log and its entry removed. From block control passes to block from block control passes to block .

In block the links already created by the currently selected dependency determination producer are cleared from the producer graph s and control passes to block . With reference to the embodiment of the invention shown in the following is performed. It is first determined if the dependency determination producer has sticked on an existing producer. This is done by scanning the dependency determination producer s child producer links column in and checking if one of the links has the sticky indicator indicating sticky.

If the dependency determination producer has not sticked on an existing producer then 1 for a dependency determination producer that has produced non subscription downwardly declared dependencies argument field or sequencing dependencies the parent of the dependency determination producer is accessed in the producer graph through the parent producer reference s column at the row of the currently selected dependency determination producer and in this parent producer entry the child producer s link s column is accessed to match the dependency determination producer reference and all references of child producers having that dependency determination producer reference are cleared 2 for a dependency determination producer that has produced non subscription upwardly declared dependencies the parent of the dependency determination producer is accessed in the producer graph through the parent producer link s column at the row of the currently selected dependency determination producer and in this parent producer entry the parent producer link s column is accessed to match the dependency determination producer reference and all references of parent producers having that dependency determination producer reference are cleared 3 for a dependency determination producer that has produced an absorbing subscription the same behavior as non subscription downwardly declared dependencies is performed and 4 for a dependency determination producer that has produced a sticky subscription the dependency determination producer reference extracted from column of the subscription log A prior to the removal of the subscription is looked up in the producer graph s structure in the parent producer link s column and all references of parent producers having that dependency determination producer reference are cleared.

If the dependency determination producer has sticked on an existing producer as a result of a non subscription upwardly declared dependency or a sticky subscription then the child producer that the dependency determination producer has sticked on is accessed the child producer in column with a sticky indicator indicating sticky and in this child producer entry the parent producer link s column is accessed to match the dependency determination producer reference and all references of parent producers having that dependency determination producer reference are cleared.

In block it is determined if all matching producers have been executed. If so control passes to block otherwise control passes to block . With reference to the embodiments of the matching producer s column at the appropriate row is accessed to determine the matching producers and the incremental execution column at the appropriate rows is checked for each of the matching producers.

In block the absorbing subscription is marked as complete and control passes to block . With reference to the embodiments of the complete column at the appropriate row is set to indicate complete.

In block the producer selected in block is added to the current set of candidate producers and control passes to block .

As previously indicated properly written procedural language non reflective object oriented language and non reflective object based language code may be transformed into reflective object oriented language code. By way of example a class may be emulated through a data structure and a set of static functions having as a first parameter a pointer to an instance of the data structure. Among these functions are the constructor and the destructor. The constructors are invoked by the runtime after allocation of a pointer to a data structure and provide defaults for elements in the data structure and the destructors are invoked by the runtime before the release of a pointer to the data structure. Each class has its description through a file that includes 1 the data structure 2 another structure describing the class holding the size of the structure and a set of pointers to functions 3 a list of static functions with their code for non reflective object oriented languages and non reflective object based languages the code of static functions would be generated automatically by scanning methods of the real class and creating for each method a static function that performs the effective invocation of the related method and 4 annotations on top of each function comments hold producer dependency declarations along with their type constructor destructor property etc. In addition to this definition of a class in the procedural non reflective object oriented or non reflective object based language dynamic invocation is also implemented. Specifically a compiler generates the following initialization code for each class code that is called once by the new class module to 1 instantiate the structure describing the class fill the pointers to functions with the effective static functions 2 register the instance of this structure with a map of classes the class tracking structure with a key corresponding to the class name and 3 register all pointers to functions in a map of functions the method tracking structure with a key corresponding to the function name along with ArgumentDependencies SequencingDependencies FieldDependencies UpwardDependencies WeaklyConstrainedDependencies output class key and additional annotations . The mapping allows for implements in the runtime of generic invocation functions capable of 1 instantiating an instance of a class by name by the new instance module specifically the runtime a allocates memory according to the size of the data structure and adds a header to the pointer in order to store a pointer to the structure describing the class and implements therefore smart pointers e.g. pointers capable of querying their types and b invokes the proper constructor functions after retrieval of the relevant pointer to the static function from the map and 2 invoking a method by name provided all parameters are passed properly after retrieval of the relevant pointer to the static function from the map. Passing properly parameters to functions identified by pointers to functions would be done through assembly language pushing and popping elements on from the stack for input and output parameters. The method described above assumes the existence of the notion of data structures and the existence of the notion of pointers to functions in the procedural non reflective object oriented or non reflective object based language.

In one embodiment of the invention the client code takes on the following syntax shown in header form 

In one embodiment of the invention the ArgumentID is omitted in the syntax and the order in which the argumentDependencies have been declared represents the ArgumentID. The ArgumentID is thus added to enhance readability.

The syntax is the same as for a non shortcut but usage of S prior to the producer key indicates a shortcut.

In this case the producer key indicated by the dependency is not a dependency determination producer. Other syntax implementations may assume that the shortcut is the default dependency for a certain dependency type such as field and omit the S In that case a DDP may be used to indicate the presence of a DDP.

Elements such as class instance or method that are considered to be identical to the parent producer elements are omitted. This is typically the case for shortcut fields. The examples given hereunder combine the shorthand technique and a shortcut declaration the shortcut is illustrated by a S 

While the flow diagrams in the figures show a particular order of operations performed by certain embodiments of the invention it should be understood that such order is exemplary e.g. alternative embodiments may perform the operations in a different order combine certain operations overlap certain operations etc. 

While the invention has been described in terms of several embodiments those skilled in the art will recognize that the invention is not limited to the embodiments described can be practiced with modification and alteration within the spirit and scope of the appended claims. The description is thus to be regarded as illustrative instead of limiting.

