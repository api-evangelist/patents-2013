---

title: Efficiently registering a relational schema
abstract: A method, device, and non-transitory computer-readable storage medium are provided for efficiently registering a relational schema. In co-compilation and data guide approaches, a subset of entities from schema descriptions are selected for physical registration, and other entities from the schema descriptions are not physically registered. In the co-compilation approach, a first schema description references a second schema description, and the subset includes a set of entities from the second schema description that are used by the first schema description. In the data guide approach, the subset includes entities that are used by a set of structured documents. In a pay-as-you-go approach, schema registration includes logically registering entities without creating relational database structures corresponding to the entities. A database server may execute database commands that reference the logically registered entities. A request to store data for the entities may be executed by creating relational database structures to store the data.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09330124&OS=09330124&RS=09330124
owner: ORACLE INTERNATIONAL CORPORATION
number: 09330124
owner_city: Redwood Shores
owner_country: US
publication_date: 20131003
---
This application claims benefit and priority under 35 U.S.C. 120 as a Continuation of application Ser. No. 12 956 264 filed Nov. 30 2010 the entire contents of which are hereby incorporated by reference as if fully set forth herein. The applicant s hereby rescind any disclaimer of claim scope in the parent application s or the prosecution history thereof and advise the USPTO that the claims in this application may be broader than any claim in the parent application s .

The present application is related to U.S. Pat. No. 7 024 425 entitled Method And Apparatus For Flexible Storage And Uniform Manipulation of XML Data In A Relational Database System filed on Sep. 6 2001 the entire contents of which are incorporated herein by reference.

The present application is related to U.S. Pat. No. 7 096 224 entitled Mechanism for Mapping XML Schemas to Object Relational Database Systems filed on Sep. 27 2002 the entire contents of which are incorporated herein by reference.

A database management system DBMS manages a database. A database management system may comprise one or more database servers. A database comprises database data and metadata that is stored on a persistent memory mechanism such as a set of hard disks. Database data may be stored in one or more data containers. Each container contains records. The data within each record is organized into one or more fields. In relational database management systems the data containers are referred to as tables the records are referred to as rows and the fields are referred to as columns. In object oriented databases the data containers are referred to as object classes the records are referred to as objects and the fields are referred to as attributes. Other database architectures may use other terminology.

Database applications and clients interact with a database server by submitting to the database server commands that cause the database server to perform operations on data stored in a database. A database command may be in the form of a database statement that conforms to database language statement. A language for expressing the database requests is the Structured Query Language SQL . There are many different versions of SQL some versions are standard and some proprietary and there are a variety of extensions. SQL data definition language DDL instructions are issued to a database server to create or configure database objects such as tables views or complex data types. SQL XML is a common extension of SQL used when manipulating XML data in an object relational database. Although the examples are described based on Oracle s SQL the techniques provided herein are not restricted to any particular version of SQL.

A multi node database management system is made up of interconnected nodes that share access to the same database. Typically the nodes are interconnected via a network and share access in varying degrees to shared storage e.g. shared access to a set of disk drives and data blocks stored thereon. The nodes in a multi node database system may be in the form of a group of computers e.g. work stations personal computers that are interconnected via a network. Alternately the nodes may be the nodes of a grid. A grid is composed of nodes in the form of server blades interconnected with other server blades on a rack.

Each node in a multi node database system hosts a database server. A server such as a database server is a combination of integrated software components and an allocation of computational resources such as memory a node and processes on the node for executing the integrated software components on a processor the combination of the software and computational resources being dedicated to performing a particular function on behalf of one or more clients.

Resources from multiple nodes in a multi node database system can be allocated to running a particular database server s software. Each combination of the software and allocation of the resources from a node is a server that is referred to herein as a server instance or instance .

Structured data includes nodes of data and contextual clues about the nodes of data. In a text document a context may be provided for a data value by tagging or labeling the data value within the text. The context for a data value may be provided by a single label or a combination of labels such as a hierarchical path of labels. In one example a value of Tom may be prefaced with a label of Name . Various markup signals may be used to distinguish between the data values and the labels themselves. For example a label may be marked with a such as in Name Tom or a such as in Name Tom . In many markup languages the label is provided within angle brackets such as in Tom. The end of the data value may also be marked. For example the end may be marked with . The end may also be marked by the beginning of another label for example Name Tom Age 25 . The marked up data may indicate a hierarchical structure such that a single data value falls under a path of labels such as in Tom where Tom falls under the path of CONTACT NAME. Alternately data values may be marked with individual labels that do not specify a hierarchical path such as in Name Tom Age 25. 

In one embodiment nodes of the structured data form a hierarchy. Nodes may have one or more values one or more attributes and one or more hierarchical relationships to one or more other nodes. The resulting hierarchical structure of the data is discussed in terms akin to those used to discuss a family tree. For example a node nested within another node may be described as the child node or sub node of the other node or parent node. Grandchildren grandparents and other descendants and ancestors may be similarly defined. Collectively a node along with its values attributes and sub nodes is referred to as a tree or a sub tree.

A complex node is a node that holds more than a mere scalar value. In other words data within the complex node is defined according to some structure. For example a parent node with one or more child nodes is a complex node. In another example a parent node with attributes may be described as a complex node. One example of a simple node is a child node with a value but no descendants.

Examples of structured data may be described herein in the context of data that conforms to the Extensible Markup Language XML . However structured data is not limited in that regard. Other forms of structured data where hierarchical positions are defined between nodes of data may also be used. For example structured data may include a collection or stream of Java objects.

Extensible Markup Language XML is an example markup language that is used to provide context for data that is stored in a document. XML is a World Wide Web Consortium W3C standard for representing data. Many applications are designed to output data in the form of XML documents. The techniques described herein relate to registering a schema for structured documents. XML is described herein as one example of providing context for nodes of data in a document but those of ordinary skill in the art would appreciate that there are an unlimited number of possible ways to provide context for nodes of data in a document. This description is intended to cover all possible ways in which context may be provided for nodes of data.

XML data comprises structured data items that form a hierarchy. In XML data items known as elements are delimited by an opening tag and a closing tag. An element may also comprise attributes which are specified in the opening tag of the element. Text between the tags of an element may represent any sort of data value such as a string date or integer. As a node of structured data an XML element may have one or more child elements. A complex element is an element that holds more than a data value. In other words one or more other elements or attributes are identified within the complex element. A simple element may have a data value but simple elements generally do not have attributes or sub elements.

A relational database may store structured documents as a single block of text or by splitting up the nodes of structured data and storing the nodes in separate relational database structures such as tables and types. To facilitate storage retrieval and modification of structure data users register schema descriptions with the relational database server. The schema descriptions define a structure to which the structured documents conform. During schema registration the relational database server may create separate relational database structures for every node or every complex node in the schema descriptions. The server uses Data Definition Language DDL commands such as the CREATE TABLE command to create relational database structures within the database. During registration the server also stores metadata that describes the relationships between relational database structures and provides context for the relational database structures.

As used herein the term relational database structures refer to database structures such as tables and types in an object oriented database. In an object oriented database objects classes inheritance and data types are supported in relational schemas and in the query language.

Once the relational schema has been registered the relational database server has relational database structures available to store any data that conforms to the schema descriptions. In one example relational database structures are created for every complex node and simple nodes and or attributes are stored in the relational database structure corresponding to a complex parent node. In another example separate relational database structures are also created for simple nodes and or attributes. After schema registration the relational database server may evaluate database commands to store retrieve and or modify structured data stored in the relational database structures. In one example a received command that references a node in a hierarchy of nodes is mapped to a relational database structure that stores the data for the node.

In a request to register schemas for a set of XML documents a database user may identify XML schemas to which a set of XML documents conform. During schema registration the relational database server registers the XML schemas by creating separate relational database structures for every complex element mentioned in the XML schemas. According to one technique once the XML schemas have been registered documents that conform to the XML schemas may be stored in an XMLType datatype column in the relational database as described in U.S. Pat. No. 7 024 425 entitled Method And Apparatus For Flexible Storage And Uniform Manipulation of XML Data In A Relational Database System which has been incorporated by reference herein. When an XML document is stored in the XMLType column the database server maps attributes and elements of the XML document to separate columns in the relational database and the database server stores mapping information that maps the attributes and elements of the XML document to the columns in the relational database where the attributes and elements are actually stored. Storage of data as the XMLType causes the data to be decomposed into relational database structures that represent nodes of XML content.

The approaches described in this section are approaches that could be pursued but not necessarily approaches that have been previously conceived or pursued. Therefore unless otherwise indicated it should not be assumed that any of the approaches described in this section qualify as prior art merely by virtue of their inclusion in this section.

In the following description for the purposes of explanation numerous specific details are set forth in order to provide a thorough understanding of the present invention. It will be apparent however that the present invention may be practiced without these specific details. In other instances well known structures and devices are shown in block diagram form in order to avoid unnecessarily obscuring the present invention.

A method device and non transitory computer readable storage medium are provided for efficiently registering a relational schema. In co compilation and data guide approaches a subset of entities from schema descriptions are selected for physical registration and other entities from the schema descriptions are not physically registered. In co compilation approaches a first schema description references a second schema description and the subset includes a set of entities from the second schema description that are used by the first schema description. In data guide approaches the subset includes entities that are used by a set of structured documents. In pay as you go approaches schema registration includes logically registering entities without creating relational database structures corresponding to the entities. A database server may execute database commands that reference the logically registered entities. A request to store data for the entities may be executed by creating relational database structures to store the data.

Once a relational schema has been registered a set of structured documents that conform to the schema descriptions may be stored in the relational database. If the relational schema was logically registered relational database structures are created as needed when data from the set of structured documents is stored in the relational database. If the relational schema was physically registered relational database structures were created in the relational database during physical registration and these relational database structures may be used to store data from the set of structured documents. In one embodiment the relational database structures include relational database tables and types. In one embodiment the set of structured documents is a set of XML documents and the schema descriptions are XML schemas.

Co compilation approaches include receiving a request to create relational database structures for storing in a relational database structured documents described by a first schema description that references a second schema description. In one embodiment the request is received on one or more machines running a schema registration server such as a database server. The request may specify one or more relational database structures that are to be created upon registration but the request does not need to specify the relational database structures to be created. The request may identify the first schema description from which the server determines a set of relational database structures to be created. In response to receiving the request the server automatically determines that the first schema description uses a first set of entities of the second schema description wherein the second schema description includes the first set of entities and a second set of entities that are not used by the first schema description. The server automatically creates relational database structures corresponding to the entities in the first schema description and the first set of entities of the second schema description without creating relational database structures corresponding to the second set of entities of the second schema description.

Data guide approaches include receiving a request to create unspecified relational database structures for storing in a relational database a set of structured documents described by one or more schema descriptions. The request may specify a set of structured documents and or a set of schema descriptions from which the server determines a set of relational database structures to be created. In response to receiving the request the server automatically uses selected structured documents and the schema descriptions to create a structural representation of entities in the schema descriptions that are used by the selected structured documents. In one embodiment the structural representation is a tree of nodes and each node in the tree corresponds to a different entity that is both present in the schema descriptions and used by the selected structured documents. The database server automatically creates relational database structures corresponding to the entities used by the selected structured documents without creating relational database structures corresponding to entities not used by the selected structured documents.

In one embodiment registration of the schema includes creating a structured index that indexes a subset of entities from the schema descriptions that are physically registered. For example indices may be created for entities in a first schema description and a subset of entities in a second schema description that are used by the first schema description. As another example indices may be created for entities in the schema descriptions that are used by the set of structured documents.

Pay as you go approaches include receiving a request to create an unspecified relational schema for storing in a relational database structured documents described by one or more schema descriptions. In one embodiment the request is received on one or more machines running a server. In response to receiving the request the database server stores in a relational database information that defines a set of entities included in the one or more schema descriptions without creating relational database structures for the set of entities. In one embodiment the database server uses the stored information to execute a database command that references one or more entities of the set of entities even though one or more relational database structures for the one or more entities have not been created. In one example the request to execute the one or more database commands is received from a client and the one or more database commands are executed without any indication to the client that the one or more relational database structures did not exist when the request was received. In this manner from the client s perspective database commands are executed as if the relational database structures already existed.

In another embodiment the database server receives a request to store data for one or more entities of the set of entities. In response to receiving the request to store the data for the one or more entities the database server uses the stored information to create one or more new relational database structures for the one or more entities. The data may then be stored in the one or more new relational database structures. In one embodiment the request to store data is received from a client and the request to store data is executed without any indication to the client that the one or more relational database structures did not exist when the request to store data was received. In this manner from the client s perspective the request to store the data is executed as if the relational database structures already existed.

A relational database stores nodes of data from structured documents in separate relational database structures such as tables and types. In one embodiment these relational database structures are created during schema registration by a database server in response to a request to create a relational schema for a set of structured documents that conform to one or more schema descriptions. The request is processed by the server to create relational database structures using information from one or more schema descriptions and or one or more sample structured documents even though at least some of the relational database structures created were not specified within the request. In this manner registration may be accomplished by referring to schema descriptions and or sample structured documents without specifying the DDL commands to be performed in order to create relational database structures for the entities referenced in the schema descriptions and or sample structured documents. In various other embodiments the request may also specify relational database structures to be created in addition to those created automatically using the one or more schema descriptions and or the one or more sample structured documents. The schema descriptions define a structure to which structured documents conform including for example hierarchical relationships between entities that are allowed optional or required in the structured documents. The server uses the one or more schema descriptions and or the one or more sample structured documents to determine which entities should be physically registered within the database.

Once the relational schema has been physically registered the relational database structures for the selected entities are available in the relational database to store nodes of data from the structured documents. In one embodiment the database server physically registers only a subset of entities from the one or more schema descriptions and or from the one or more sample structured documents and the one or more schema descriptions and or the one or more sample structured documents include other entities that are not physically registered in the relational database.

During schema registration the subset of entities are physically registered without registering one or more other sets of entities from the one or more schema descriptions. In one embodiment the server uses DDL commands such as CREATE TABLE to create relational database structures corresponding to the subset of entities without using the DDL commands for the other sets of entities. In one embodiment the server stores metadata describing the relationships between the relational database structures corresponding to the subset of entities without storing metadata describing relationships between entities from the other sets of entities. In one embodiment physical registration of the subset of entities stores mapping information for the subset of entities that allows database commands referencing the subset of entities to be mapped to the relational database structures storing the subset of entities. In this manner database commands referencing the subset of entities may be efficiently evaluated against the data stored in the relational database structures. Mapping information does not need to be created or stored for the other sets of entities.

In one example the relational database server presents XML documents stored in the relational database as single data items of the XMLType abstract datatype even though separate attributes and elements of the XML document are mapped to the separate relational columns and tables within the relational database. If an XML user submits a query to search XML documents for a value of a particular element then the XML user s query is rewritten to access the relational column that holds values for the particular element.

In co compilation approaches the subset of entities is selected such that once the relational schema has been registered the relational database server has relational database structures available to store any data that conforms to a user schema description that references one or more other schema descriptions such as library schemas. In one embodiment relational database structures are not created for entities in the one or more other schema descriptions unless those entities are used by the user schema description.

In data guide approaches the subset of entities is selected such that once the relational schema has been registered the relational database server has relational database structures available to store any data that includes elements from a set of sample structured documents. In one embodiment relational database structures are not created for entities that do not appear in the set of sample structured documents.

In one embodiment the subset of entities is selected prior to schema registration by a component outside of a database server. During schema registration a request may identify the subset of entities to be physically registered instead of or in addition to identifying the schema descriptions that are the subject of the schema registration.

Co compilation approaches involve selecting a subset of entities in a set of schema descriptions based on those entities actually used by one or more of the set of schema descriptions. A user or client submits a request to create relational database structures for storing in a relational database structured documents described by a first schema description that references one or more other schema descriptions. In one embodiment the request is received on one or more machines running a server. The request does not specify the relational database structures to be created but the request may identify one or more schema descriptions and or one or more structured documents to be stored in the relational database. In response to receiving the request the database server automatically determines that the first schema description uses a first set of entities of the one or more other schema descriptions wherein the one or more other schema descriptions include the first set of entities and a second set of entities that are not used by the first schema description. The server automatically creates relational database structures corresponding to the entities in the first schema description and the first set of entities of the one or more other schema descriptions without creating relational database structures corresponding to the second set of entities of the one or more other schema descriptions.

In one embodiment the method includes identifying the elements in the one or more other schema descriptions that are referenced or mentioned in the first schema description. Referencing means that the entities defined in the referenced schema are accessible to the referencing schema even though the referenced entities are not defined in the referencing schema. For example a customer schema may reference a set of library schemas. A referenced library schema might also reference other schemas which may also have referenced entities and be included in the set of referenced schemas.

In addition to the elements directly referenced by the first schema description ancestor elements along a path from a root node to the referenced elements may also be identified in a set of elements that are used by the first schema description. Further descendant elements that are optional or required under the referenced elements may be identified in the set of elements that are used by the first schema description. In one example indirect ancestors of the referenced element such as uncles and great uncles are not in the set of used elements. In another example indirect descendants of the referenced element such as nephews and great nephews are not in the set of used elements. In other examples siblings and cousins of the referenced element may be excluded from the set of used elements. The set of used elements may include each element in the one or more other schema descriptions that is used directly or indirectly by an element used or referenced in the first schema description. In one embodiment a directed graph is constructed to determine those elements in the one or more other schema descriptions that are used by the first schema description. The techniques described herein are not limited to a particular implementation for determining whether elements in one or more other schemas are used by the first schema and some implementations may include more distant relatives than other implementations.

In one embodiment the references between elements and types span a graph that connects a set of one or more customer schemas with a set of one or more library schemas. Each schema is regarded as a tree of nodes. The set of customer schemas and library schemas is a set of trees that are connected by references. The result is a graph with a list of entry points or global elements of the customer schema s .

In one embodiment a depth first search algorithm starts on every global element of the customer schema. If a reference to a type is encountered the traversal code marks this type as being used in the tree of nodes. The traversal code continues from this referenced node. If no more new references are found the recursion terminates for that level and continues for earlier levels.

In one embodiment a set of used entities in the schema descriptions is defined when all referenced nodes have been visited and marked. Types that are not used can be removed from the schema since they are not relevant for the customer s user case. If removal is not an option the types could be annotated in a way that no table will be created when the schema descriptions are registered in the database. As a result of registering fewer than all entities in a library schema registration of the library schema may be less complex and occur in less time with fewer tables being created. In one embodiment further simplification of the schema is performed when a customer selects one or more global elements from the total set of global elements as valid root elements.

In one example a request to register a relational schema is associated with a user schema description that references one or more other schema descriptions. The following user schema fragment is a non limiting example fragment of a user schema description for a set of XML documents.

The namespace for the user schema description is defined as http niem.gov niem recovery gov 2.0. In the example the user schema description imports one or more other schema descriptions including niem niem core 2.0 niem core.xsd which defines the entity rg AddressType for example in the following first library schema fragment 

The other schema description in the example niem core.xsd also defines other entities that the user may not use such as AircraftType in the following second library schema fragment 

In the example the AddressType entity is used by the user schema description but the AircraftType entity is not used by the user schema description. Accordingly the database server creates relational database structures in the relational database to represent the AddressType entity but the database server does not create relational database structures in the relational database to represent the AircraftType entity. For example the database server may create an AddressType table with columns associated with sub elements or attributes of the entity. Other user schema descriptions may use the AircraftType entity but not the AddressType entity. In various examples library schemas may include thousands or even hundreds of thousands of entities of which only a small subset of entities are used.

In one embodiment the library schema description is modified after the user schema description is created but before the relational schema is registered with the database server. Upon schema registration the used elements are determined from the library schema as modified which is referenced in the user schema description. In one embodiment the library schema description is referenced by several user schema descriptions each of which uses different elements from the library schema description. In one embodiment multiple library schema descriptions reference each other. The user schema description may also reference several library schema descriptions.

Data guide approaches involve selecting a subset of entities in a set of schema descriptions based on those entities actually used by a sample set of structured documents. A user or client submits a request to create unspecified relational database structures for storing in a relational database a set of structured documents described by one or more schema descriptions. In one embodiment the request is received on one or more machines running a server. In response to receiving the request the database server automatically uses sample structured documents and the schema descriptions to create a structural representation of entities in the schema descriptions that are used by the sample structured documents. In one embodiment the structural representation is a tree of nodes and each node in the tree corresponds to a different entity that is both present in the schema descriptions and used by the sample structured documents. The database server automatically creates relational database structures corresponding to the entities used by the sample structured documents without creating relational database structures corresponding to entities not used by the sample structured documents.

In one embodiment the method involves creating a structural representation of entities defined in the one or more schema descriptions. Sample structured documents are scanned and entities in the structural representation are marked when the entities appear in the structured documents. In one embodiment each marked entity is only marked once indicating that the entity is used by the set of sample structured documents. After scanning the set of sample structured documents a first set of entities in the structural representation are marked and a second set of entities in the structural representation are not marked. The database server automatically creates relational database structures corresponding to the marked entities without creating relational database structures corresponding to the unmarked entities.

In one embodiment registration of the schema includes creating a structured index that indexes one or more entities of the subset of entities from the schema descriptions that are physically registered. In one embodiment the structured index is a path index that facilitates a path based lookup of the entities. For example the path index may be an XML index used to evaluate an XQuery expression that uses XPath syntax to address one or more nodes in a set of XML documents. Indices can be costly to maintain in terms of time and resources. In one embodiment the techniques described herein reduce this cost by avoiding the creation of indices for unused entities.

In the co compilation approaches indices may be created for entities in a first schema description and a subset of entities in a second schema description that are used by the first schema description. In the data guide approaches indices may be created for entities in the schema descriptions that are used by the set of structured documents. In one example a count is maintained for each entity. The count indicates how many times the entity is used in the set of structured documents. In a particular embodiment indices are created only for those entities that are used above a threshold amount of times in the set of structured documents.

In one embodiment the structured documents are stored in an unstructured object in the database such as a Character Large Object CLOB or Binary Large Object BLOB column and the index is a structured index that indexes one or more entities of the subset of entities from in the structured documents. In this manner a structured index such as a path index may be provided for a subset of entities that are stored in an unstructured column. The structured index may be stored in association with the unstructured object. For example the structured index may be stored in a hidden column that is associated with the unstructured object.

Pay as you go approaches involve logically registering entities from schema descriptions thereby delaying or avoiding the cost of creating relational database structures that represent the entities until those relational database structures are actually needed to store data. A user or client submits a request to create an unspecified relational schema for storing in a relational database structured documents described by one or more schema descriptions. In one embodiment the request is received on one or more machines running a server. In response to receiving the request the database server stores in a relational database information that defines a set of entities included in the one or more schema descriptions without creating relational database structures such as tables and types for the set of entities. In one embodiment the database server uses the stored information to execute a database command that references one or more entities of the set of entities even though one or more relational database structures for the one or more entities have not been created. In one example the request to execute the one or more database commands is received from a client and the one or more database commands are executed without any indication to the client that the one or more relational database structures did not exist when the request was received. In this manner from the client s perspective database commands are executed as if the relational database structures that were referenced in the database commands had already existed when the database commands were submitted.

In another embodiment the database server receives a request to store data for one or more entities of the set of entities. In response to receiving the request to store the data for the one or more entities the database server uses the stored information to create one or more new relational database structures for the one or more entities. The data may then be stored in the one or more new relational database structures. In one embodiment the request to store data is received from a client and the request to store data is executed without any indication to the client that the one or more relational database structures did not exist when the request to store data was received. In this manner from the client s perspective the request to store the data is executed as if the relational database structures that were needed to store the data had already existed when the request was submitted.

In one example entities from the schema descriptions may be logically registered in the relational database by storing information about the entities in a dictionary table in the relational database. The stored information about the entities allows the database server to create relational database structures for the entities on demand when the relational database structures are needed to store data. In one embodiment the stored information includes object identifiers that are reserved for the relational database structures that have not yet been created. In an embodiment the stored information provides information about hierarchical relationships between entities which may be gleaned from the one or more schema descriptions.

In one embodiment the user provides table names and or type names during registration time and the stored information includes tables names and or type names specified by the user. In another embodiment the system generates table names and or type names during registration time and the stored information includes the table names and or type names generated by the system. In this manner table names and type names may be known for the purpose of query rewrites and for the purpose of reserving table names and type names in the event that they are later physically created. In one embodiment when creating a table or type the database server checks a dictionary of stored information to determine whether the table or type name is already reserved by a logically registered table. If the table or type name is already reserved then the logical reservation is held and the table or type is not created. When logically registered tables or types are later physically created in the database known names for the tables or types are available. In one embodiment table information is stored in one dictionary table and type information is stored in another dictionary table.

In one embodiment logically registering the entities avoids creating any storage infrastructure to store the structured documents. In one example logically registering the entities avoids allocating space that may later be allocated to store relational database structures when entities are physically registered with the database. In another embodiment logically registering the entities avoids making a plurality of calls to the storage layer of the database for creating the relational database structures that represent the entities. Logically registering the entities avoids creating physical tables and types to represent the entities.

In one embodiment an application programming interface is defined on top of the relational database structures such that a reference to a given relational database structure actually references a logical representation of the relational database structure. In one example a query received by the database server is rewritten to reference the logical representations that are defined by the dictionary table. For example if a query references a table that does not yet have a physical counterpart then a logical representation of the table may be treated as an empty table. The dictionary table may store in association with a logical representation of an object an indication of whether the object has a physical counterpart that has already been created in the relational database.

In one embodiment queries are executed against relational database structures that do not yet physically exist in the database as if they already existed. For example a user may submit database commands to the database server without knowledge of whether or not the underlying physical database structures exist and the database server may execute the commands without any indication to the user of whether or not the underlying physical database structures existed when the commands were submitted.

In another example in response to a request to store a document in a relational database an element of the document is mapped using the dictionary table to a logical table that represents the element. The logical tables may or may not have physical counterparts in the relational database. If the logical table has a physical counterpart then the data for the element is stored in the physical counterpart. If the logical table does not yet have a physical counterpart then the physical counterpart is created to store the data for the element. In one embodiment an application programming interface creates a physical relational database structure when an entity is inserted and a logical representation for the entity has no physical counterpart.

In one embodiment requests to store data are executed to store data in relational database structures that did not exist when the requests were received. A user may submit a request to store data to the database server without knowledge of whether or not the underlying physical database structures exist and the database server may execute the requests without any indication to the user of whether or not the underlying physical database structures existed when the requests were submitted.

The various approaches described herein may be used separately or in combination with each other. For example a co compilation approach may be used to determine a subset of entities that are used by a customer schema and a data guide approach may be used to determine which entities in the subset of entities are used by a sample set of structured documents. Further pruning of entities to be physically registered may be triggered by determining that above a certain threshold of entities are to be physically registered at the conclusion of one approach. In another example a subset of entities may be physically registered according to the co compilation approach and or the data guide approach and other entities from the one or more schema descriptions that are not physically registered are defined in a dictionary table according to the pay as you go approach. The other entities may be physically registered as needed but they do not need to be physically registered at the time of schema registration. In yet another example entities are initially logically registered and subsets of entities are physically registered as a background process. Subsets registered in the background may be determined using the co compilation approach and or the data guide approach. The background process may run on the database server whenever the database server is idle experiencing a low workload and or experiencing a low demand on resources.

According to one embodiment the techniques described herein are implemented by one or more special purpose computing devices. The special purpose computing devices may be hard wired to perform the techniques or may include digital electronic devices such as one or more application specific integrated circuits ASICs or field programmable gate arrays FPGAs that are persistently programmed to perform the techniques or may include one or more general purpose hardware processors programmed to perform the techniques pursuant to program instructions in firmware memory other storage or a combination. Such special purpose computing devices may also combine custom hard wired logic ASICs or FPGAs with custom programming to accomplish the techniques. The special purpose computing devices may be desktop computer systems portable computer systems handheld devices networking devices or any other device that incorporates hard wired and or program logic to implement the techniques.

For example is a block diagram that illustrates a computer system upon which an embodiment of the invention may be implemented. Computer system includes a bus or other communication mechanism for communicating information and a hardware processor coupled with bus for processing information. Hardware processor may be for example a general purpose microprocessor.

Computer system also includes a main memory such as a random access memory RAM or other dynamic storage device coupled to bus for storing information and instructions to be executed by processor . Main memory also may be used for storing temporary variables or other intermediate information during execution of instructions to be executed by processor . Such instructions when stored in non transitory storage media accessible to processor render computer system into a special purpose machine that is customized to perform the operations specified in the instructions.

Computer system further includes a read only memory ROM or other static storage device coupled to bus for storing static information and instructions for processor . A storage device such as a magnetic disk or optical disk is provided and coupled to bus for storing information and instructions.

Computer system may be coupled via bus to a display such as a cathode ray tube CRT for displaying information to a computer user. An input device including alphanumeric and other keys is coupled to bus for communicating information and command selections to processor . Another type of user input device is cursor control such as a mouse a trackball or cursor direction keys for communicating direction information and command selections to processor and for controlling cursor movement on display . This input device typically has two degrees of freedom in two axes a first axis e.g. x and a second axis e.g. y that allows the device to specify positions in a plane.

Computer system may implement the techniques described herein using customized hard wired logic one or more ASICs or FPGAs firmware and or program logic which in combination with the computer system causes or programs computer system to be a special purpose machine. According to one embodiment the techniques herein are performed by computer system in response to processor executing one or more sequences of one or more instructions contained in main memory . Such instructions may be read into main memory from another storage medium such as storage device . Execution of the sequences of instructions contained in main memory causes processor to perform the process steps described herein. In alternative embodiments hard wired circuitry may be used in place of or in combination with software instructions.

The term storage media as used herein refers to any non transitory media that store data and or instructions that cause a machine to operation in a specific fashion. Such storage media may comprise non volatile media and or volatile media. Non volatile media includes for example optical or magnetic disks such as storage device . Volatile media includes dynamic memory such as main memory . Common forms of storage media include for example a floppy disk a flexible disk hard disk solid state drive magnetic tape or any other magnetic data storage medium a CD ROM any other optical data storage medium any physical medium with patterns of holes a RAM a PROM and EPROM a FLASH EPROM NVRAM any other memory chip or cartridge.

Storage media is distinct from but may be used in conjunction with transmission media. Transmission media participates in transferring information between storage media. For example transmission media includes coaxial cables copper wire and fiber optics including the wires that comprise bus . Transmission media can also take the form of acoustic or light waves such as those generated during radio wave and infra red data communications.

Various forms of media may be involved in carrying one or more sequences of one or more instructions to processor for execution. For example the instructions may initially be carried on a magnetic disk or solid state drive of a remote computer. The remote computer can load the instructions into its dynamic memory and send the instructions over a telephone line using a modem. A modem local to computer system can receive the data on the telephone line and use an infra red transmitter to convert the data to an infra red signal. An infra red detector can receive the data carried in the infra red signal and appropriate circuitry can place the data on bus . Bus carries the data to main memory from which processor retrieves and executes the instructions. The instructions received by main memory may optionally be stored on storage device either before or after execution by processor .

Computer system also includes a communication interface coupled to bus . Communication interface provides a two way data communication coupling to a network link that is connected to a local network . For example communication interface may be an integrated services digital network ISDN card cable modem satellite modem or a modem to provide a data communication connection to a corresponding type of telephone line. As another example communication interface may be a local area network LAN card to provide a data communication connection to a compatible LAN. Wireless links may also be implemented. In any such implementation communication interface sends and receives electrical electromagnetic or optical signals that carry digital data streams representing various types of information.

Network link typically provides data communication through one or more networks to other data devices. For example network link may provide a connection through local network to a host computer or to data equipment operated by an Internet Service Provider ISP . ISP in turn provides data communication services through the world wide packet data communication network now commonly referred to as the Internet . Local network and Internet both use electrical electromagnetic or optical signals that carry digital data streams. The signals through the various networks and the signals on network link and through communication interface which carry the digital data to and from computer system are example forms of transmission media.

Computer system can send messages and receive data including program code through the network s network link and communication interface . In the Internet example a server might transmit a requested code for an application program through Internet ISP local network and communication interface .

The received code may be executed by processor as it is received and or stored in storage device or other non volatile storage for later execution.

In the foregoing specification embodiments of the invention have been described with reference to numerous specific details that may vary from implementation to implementation. The specification and drawings are accordingly to be regarded in an illustrative rather than a restrictive sense. The sole and exclusive indicator of the scope of the invention and what is intended by the applicants to be the scope of the invention is the literal and equivalent scope of the set of claims that issue from this application in the specific form in which such claims issue including any subsequent correction.

