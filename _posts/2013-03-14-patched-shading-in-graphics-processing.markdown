---

title: Patched shading in graphics processing
abstract: Aspects of this disclosure generally relate to a process for rendering graphics that includes performing, with a hardware shading unit of a graphics processing unit (GPU) designated for vertex shading, vertex shading operations to shade input vertices so as to output vertex shaded vertices, wherein the hardware unit is configured to receive a single vertex as an input and generate a single vertex as an output. The process also includes performing, with the hardware shading unit of the GPU, a geometry shading operation to generate one or more new vertices based on one or more of the vertex shaded vertices, wherein the geometry shading operation operates on at least one of the one or more vertex shaded vertices to output the one or more new vertices.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09412197&OS=09412197&RS=09412197
owner: QUALCOMM Incorporated
number: 09412197
owner_city: San Diego
owner_country: US
publication_date: 20130314
---
This application claims the benefit of U.S. Provisional Application 61 620 340 filed 4 Apr. 2012 U.S. Provisional Application 61 620 358 filed 4 Apr. 2012 and U.S. Provisional Application 61 620 333 filed 4 Apr. 2012 the entire contents of all of which are incorporated herein by reference.

A device that provides content for visual presentation generally includes a graphics processing unit GPU . The GPU renders pixels that are representative of the content on a display. The GPU generates one or more pixel values for each pixel on the display to render each pixel for presentation.

In some instances a GPU may implement a unified shader architecture for rendering graphics. In such instances the GPU may configure a plurality of similar computing units to execute a pipeline of different shading operations. The computing units may be referred to as unified shading units or unified shader processors.

The techniques of this disclosure generally relate to performing shading operations associated with shader stages of a graphics rendering pipeline. For example a graphics processing unit GPU may invoke one or more shading units to perform shading operations associated with a shader stage of the graphics rendering pipeline. According to aspects of this disclosure the GPU may then perform shading operations associated with a second different shader stage of the graphics rendering pipeline with the shading units that are designated for performing the first shading operations. For example the GPU may perform shading operations associated with the second stage while adhering to an input output interface associated with the first shader stage. In this way the GPU may emulate a GPU having greater shading resources by performing multiple shading operations with the same shading units.

In an example aspects of this disclosure relate to a method of rendering graphics that includes performing with a hardware shading unit of a graphics processing unit designated for vertex shading vertex shading operations to shade input vertices so as to output vertex shaded vertices wherein the hardware unit is configured to receive a single vertex as an input and generate a single vertex as an output and performing with the hardware shading unit of the graphics processing unit a geometry shading operation to generate one or more new vertices based on one or more of the vertex shaded vertices wherein the geometry shading operation operates on at least one of the one or more vertex shaded vertices to output the one or more new vertices.

In another example aspects of this disclosure relate to a graphics processing unit for rendering graphics that includes one or more processors configured to perform with a hardware shading unit of the graphics processing unit designated for vertex shading vertex shading operations to shade input vertices so as to output vertex shaded vertices wherein the hardware unit is configured to receive a single vertex as an input and generate a single vertex as an output and perform with the hardware shading unit of the graphics processing unit a geometry shading operation to generate one or more new vertices based on one or more of the vertex shaded vertices wherein the geometry shading operation operates on at least one of the one or more vertex shaded vertices to output the one or more new vertices.

In another example aspects of this disclosure relate to an apparatus for rendering graphics that includes means for performing with a hardware shading unit of a graphics processing unit designated for vertex shading vertex shading operations to shade input vertices so as to output vertex shaded vertices wherein the hardware unit is configured to receive a single vertex as an input and generate a single vertex as an output and means for performing with the hardware shading unit of the graphics processing unit a geometry shading operation to generate one or more new vertices based on one or more of the vertex shaded vertices wherein the geometry shading operation operates on at least one of the one or more vertex shaded vertices to output the one or more new vertices.

In another example aspects of this disclosure relate to a non transitory computer readable medium having instructions stored thereon that when executed cause one or more processors to with a hardware shading unit designated for vertex shading perform vertex shading operations to shade input vertices so as to output vertex shaded vertices wherein the hardware unit is configured to receive a single vertex as an input and generate a single vertex as an output and with the hardware shading unit that is designated for vertex shading perform a geometry shading operation to generate one or more new vertices based on one or more of the vertex shaded vertices wherein the geometry shading operation operates on at least one of the one or more vertex shaded vertices to output the one or more new vertices.

In another example aspects of this disclosure relate to a method for rendering graphics that includes performing with a hardware unit of a graphics processing unit designated for vertex shading a vertex shading operation to shade input vertices so as to output vertex shaded vertices wherein the hardware unit adheres to an interface that receives a single vertex as an input and generates a single vertex as an output and performing with the hardware unit of the graphics processing unit designated for vertex shading a hull shading operation to generate one or more control points based on one or more of the vertex shaded vertices wherein the one or more hull shading operations operate on at least one of the one or more vertex shaded vertices to output the one or more control points.

In another example aspects of this disclosure relate to a graphics processing unit for rendering graphics that includes one or more processors configured to perform with a hardware unit of the graphics processing unit designated for vertex shading a vertex shading operation to shade input vertices so as to output vertex shaded vertices wherein the hardware unit adheres to an interface that receives a single vertex as an input and generates a single vertex as an output and perform with the hardware unit of the graphics processing unit designated for vertex shading a hull shading operation to generate one or more control points based on one or more of the vertex shaded vertices wherein the one or more hull shading operations operate on at least one of the one or more vertex shaded vertices to output the one or more control points.

In another example aspects of this disclosure relate to an apparatus for rendering graphics that includes means for performing with a hardware unit of a graphics processing unit designated for vertex shading a vertex shading operation to shade input vertices so as to output vertex shaded vertices wherein the hardware unit adheres to an interface that receives a single vertex as an input and generates a single vertex as an output and means for performing with the hardware unit of the graphics processing unit designated for vertex shading a hull shading operation to generate one or more control points based on one or more of the vertex shaded vertices wherein the one or more hull shading operations operate on at least one of the one or more vertex shaded vertices to output the one or more control points.

In another example aspects of this disclosure relate to a non transitory computer readable medium having instructions stored thereon that when executed cause one or more processors to perform with a hardware unit of a graphics processing unit designated for vertex shading a vertex shading operation to shade input vertices so as to output vertex shaded vertices wherein the hardware unit adheres to an interface that receives a single vertex as an input and generates a single vertex as an output and perform with the hardware unit of the graphics processing unit designated for vertex shading a hull shading operation to generate one or more control points based on one or more of the vertex shaded vertices wherein the one or more hull shading operations operate on at least one of the one or more vertex shaded vertices to output the one or more control points.

In an example aspects of this disclosure relate to a method of rendering graphics that includes designating a hardware shading unit of a graphics processing unit to perform first shading operations associated with a first shader stage of a rendering pipeline switching operational modes of the hardware shading unit upon completion of the first shading operations and performing with the hardware shading unit of the graphics processing unit designated to perform the first shading operations second shading operations associated with a second different shader stage of the rendering pipeline.

In another example aspects of this disclosure relate to a graphics processing unit for rendering graphics comprising one or more processors configured to designate a hardware shading unit of the graphics processing unit to perform first shading operations associated with a first shader stage of a rendering pipeline switch operational modes of the hardware shading unit upon completion of the first shading operations and perform with the hardware shading unit of the graphics processing unit designated to perform the first shading operations second shading operations associated with a second different shader stage of the rendering pipeline.

In another example aspects of this disclosure relate to an apparatus for rendering graphics that includes means for designating a hardware shading unit of a graphics processing unit to perform first shading operations associated with a first shader stage of a rendering pipeline means for switching operational modes of the hardware shading unit upon completion of the first shading operations and means for performing with the hardware shading unit of the graphics processing unit designated to perform the first shading operations second shading operations associated with a second different shader stage of the rendering pipeline.

In another example aspects of this disclosure relate to a non transitory computer readable medium having instructions stored thereon that when executed cause one or more processors to designate a hardware shading unit of a graphics processing unit to perform first shading operations associated with a first shader stage of a rendering pipeline switch operational modes of the hardware shading unit upon completion of the first shading operations and perform with the hardware shading unit of the graphics processing unit designated to perform the first shading operations second shading operations associated with a second different shader stage of the rendering pipeline.

The details of one or more examples of the disclosure are set forth in the accompanying drawings and the description below. Other features objects and advantages will be apparent from the description and drawings and from the claims.

The techniques of this disclosure generally relate to performing shading operations associated with shader stages of a graphics rendering pipeline. For example a graphics processing unit GPU may invoke one or more shading units to perform shading operations associated with a shader stage of the graphics rendering pipeline. According to aspects of this disclosure the GPU may then perform shading operations associated with a second different shader stage of the graphics rendering pipeline with the shading units that are designated for performing the first shading operations. For example the GPU may perform shading operations associated with the second stage while adhering to an input output interface associated with the first shader stage. In this way the GPU may emulate a GPU having greater shading resources by performing multiple shading operations with the same shading units.

In the example of computing device includes a central processing unit CPU having CPU memory a graphics processing unit GPU having GPU memory and one or more shading units a display unit a display buffer unit a user interface unit and a storage unit . In addition storage unit may store GPU driver having compiler GPU program and locally compiled GPU program .

Examples of CPU include but are not limited to a digital signal processor DSP general purpose microprocessor application specific integrated circuit ASIC field programmable logic array FPGA or other equivalent integrated or discrete logic circuitry. Although CPU and GPU are illustrated as separate units in the example of in some examples CPU and GPU may be integrated into a single unit. CPU may execute one or more applications. Examples of the applications may include web browsers e mail applications spreadsheets video games audio and or video capture playback or editing applications or other applications that initiate the generation for image data to be presented via display unit .

In the example shown in CPU includes CPU memory . CPU memory may represent on chip storage or memory used in executing machine or object code. CPU memory may each comprise a hardware memory register capable of storing a fixed number of digital bits. CPU may be able to read values from or write values to local CPU memory more quickly than reading values from or writing values to storage unit which may be accessed e.g. over a system bus.

GPU represents one or more dedicated processors for performing graphical operations. That is for example GPU may be a dedicated hardware unit having fixed function and programmable components for rendering graphics and executing GPU applications. GPU may also include a DSP a general purpose microprocessor an ASIC an FPGA or other equivalent integrated or discrete logic circuitry.

GPU also includes GPU memory which may represent on chip storage or memory used in executing machine or object code. GPU memory may each comprise a hardware memory register capable of storing a fixed number of digital bits. GPU may be able to read values from or write values to local GPU memory more quickly than reading values from or writing values to storage unit which may be accessed e.g. over a system bus.

GPU also includes shading units . As described in greater detail below shading units may be configured as a programmable pipeline of processing components. In some examples shading units may be referred to as shader processors or unified shaders and may perform geometry vertex pixel or other shading operations to render graphics. Shading units may include a one or more components not specifically shown in for purposes of clarity such as components for fetching and decoding instructions one or more arithmetic logic units ALUs for carrying out arithmetic calculations and one or more memories caches or registers.

Display unit represents a unit capable of displaying video data images text or any other type of data for consumption by a viewer. Display unit may include a liquid crystal display LCD a light emitting diode LED display an organic LED OLED an active matrix OLED AMOLED display or the like.

Display buffer unit represents a memory or storage device dedicated to storing data for presentation of imagery such as photos or video frames for display unit . Display buffer unit may represent a two dimensional buffer that includes a plurality of storage locations. The number of storage locations within display buffer unit may be substantially similar to the number of pixels to be displayed on display unit . For example if display unit is configured to include 640 480 pixels display buffer unit may include 640 480 storage locations. Display buffer unit may store the final pixel values for each of the pixels processed by GPU . Display unit may retrieve the final pixel values from display buffer unit and display the final image based on the pixel values stored in display buffer unit .

User interface unit represents a unit with which a user may interact with or otherwise interface to communicate with other units of computing device such as CPU . Examples of user interface unit include but are not limited to a trackball a mouse a keyboard and other types of input devices. User interface unit may also be a touch screen and may be incorporated as a part of display unit .

Storage unit may comprise one or more computer readable storage media. Examples of storage unit include but are not limited to a random access memory RAM a read only memory ROM an electrically erasable programmable read only memory EEPROM CD ROM or other optical disk storage magnetic disk storage or other magnetic storage devices flash memory or any other medium that can be used to store desired program code in the form of instructions or data structures and that can be accessed by a computer or a processor.

In some example implementations storage unit may include instructions that cause CPU and or GPU to perform the functions ascribed to CPU and GPU in this disclosure. Storage unit may in some examples be considered as a non transitory storage medium. The term non transitory may indicate that the storage medium is not embodied in a carrier wave or a propagated signal. However the term non transitory should not be interpreted to mean that storage unit is non movable. As one example storage unit may be removed from computing device and moved to another device. As another example a storage unit substantially similar to storage unit may be inserted into computing device . In certain examples a non transitory storage medium may store data that can over time change e.g. in RAM .

As illustrated in the example of storage unit stores a GPU driver and compiler GPU program and locally compiled GPU program . GPU driver represents a computer program or executable code that provides an interface to access GPU . CPU executes GPU driver or portions thereof to interface with GPU and for this reason GPU driver is shown in the example of as a dash lined box labeled GPU driver within CPU . GPU driver is accessible to programs or other executables executed by CPU including GPU program .

GPU program may include code written in a high level HL programming language e.g. using an application programming interface API . Examples of APIs include Open Computing Language OpenCL Open Graphics Library OpenGL and DirectX as developed by Microsoft Inc. In general an API includes a predetermined standardized set of commands that are executed by associated hardware. API commands allow a user to instruct hardware components of a GPU to execute commands without user knowledge as to the specifics of the hardware components.

GPU program may invoke or otherwise include one or more functions provided by GPU driver . CPU generally executes the program in which GPU program is embedded and upon encountering GPU program passes GPU program to GPU driver e.g. in the form of a command stream . CPU executes GPU driver in this context to process GPU program . That is for example GPU driver may process GPU program by compiling GPU program into object or machine code executable by GPU . This object code is shown in the example of as locally compiled GPU program .

In some examples compiler may operate in real time or near real time to compile GPU program during the execution of the program in which GPU program is embedded. For example compiler generally represents a module that reduces HL instructions defined in accordance with a HL programming language to low level LL instructions of a LL programming language. After compilation these LL instructions are capable of being executed by specific types of processors or other types of hardware such as FPGAs ASICs and the like including e.g. CPU and GPU .

LL programming languages are considered low level in the sense that they provide little abstraction or a lower level of abstraction from an instruction set architecture of a processor or the other types of hardware. LL languages generally refer to assembly and or machine languages. Assembly languages are a slightly higher LL language than machine languages but generally assembly languages can be converted into machine languages without the use of a compiler or other translation module. Machine languages represent any language that defines instructions that are similar if not the same as those natively executed by the underlying hardware e.g. processor such as the x86 machine code where the x86 refers to an instruction set architecture of an x86 processor developed by Intel Corporation .

In any case compiler may translate HL instructions defined in accordance with a HL programming language into LL instructions supported by the underlying hardware. Compiler removes the abstraction associated with HL programming languages and APIs such that the software defined in accordance with these HL programming languages is capable of being more directly executed by the actual underlying hardware.

In the example of compiler may receive GPU program from CPU when executing HL code that includes GPU program . Compiler may compile GPU program to generate locally compiled GPU program that conforms to a LL programming language. Compiler then outputs locally compiled GPU program that includes the LL instructions.

GPU generally receives locally compiled GPU program as shown by the dashed lined box labeled locally compiled GPU program within GPU whereupon in some instances GPU renders an image and outputs the rendered portions of the image to display buffer unit . For example GPU may generate a number of primitives to be displayed at display unit . Primitives may include one or more of a line including curves splines etc. a point a circle an ellipse a polygon where typically a polygon is defined as a collection of one or more triangles or any other two dimensional 2D primitive. The term primitive may also refer to three dimensional 3D primitives such as cubes cylinders sphere cone pyramid torus or the like. Generally the term primitive refers to any basic geometric shape or element capable of being rendered by GPU for display as an image or frame in the context of video data via display unit .

GPU may transform primitives and other state data e.g. that defines a color texture lighting camera configuration or other aspect of the primitives into a so called world space by applying one or more model transforms which may also be specified in the state data . Once transformed GPU may apply a view transform for the active camera which again may also be specified in the state data defining the camera to transform the coordinates of the primitives and lights into the camera or eye space. GPU may also perform vertex shading to render the appearance of the primitives in view of any active lights. GPU may perform vertex shading in one or more of the above model world or view space although it is commonly performed in the world space .

Once the primitives are shaded GPU may perform projections to project the image into a unit cube with extreme points as one example at 1 1 1 and 1 1 1 . This unit cube is commonly referred to as a canonical view volume. After transforming the model from the eye space to the canonical view volume GPU may perform clipping to remove any primitives that do not at least partially reside within the view volume. In other words GPU may remove any primitives that are not within the frame of the camera. GPU may then map the coordinates of the primitives from the view volume to the screen space effectively reducing the 3D coordinates of the primitives to the 2D coordinates of the screen.

Given the transformed and projected vertices defining the primitives with their associated shading data GPU may then rasterize the primitives. For example GPU may compute and set colors for the pixels of the screen covered by the primitives. During rasterization GPU may apply any textures associated with the primitives where textures may comprise state data . GPU may also perform a Z buffer algorithm also referred to as a depth test during rasterization to determine whether any of the primitives and or objects are occluded by any other objects. The Z buffer algorithm sorts primitives according to their depth so that GPU knows the order in which to draw each primitive to the screen. GPU outputs rendered pixels to display buffer unit .

Display buffer unit may temporarily store the rendered pixels of the rendered image until the entire image is rendered. Display buffer unit may be considered as an image frame buffer in this context. Display buffer unit may then transmit the rendered image to be displayed on display unit . In some alternate examples GPU may output the rendered portions of the image directly to display unit for display rather than temporarily storing the image in display buffer unit . Display unit may then display the image stored in display buffer unit .

To render pixels in the manner described above GPU may designate shading units to perform a variety of shading operations as described in greater detail for example with respect to . However certain GPUs such as GPU designed to support a relatively shorter rendering pipeline may be unable to support APIs having expanded rendering pipelines. For example some GPUs may be prevented from designating shading units to perform more than two different types of shading operations.

In an example GPU may designate shading units to perform vertex shading and pixel shading operations. In this example GPU may lack the resources to designate shading units to perform operations associated with a hull shader a domain shader and or a geometry shader. That is hardware and or software restrictions may prevent GPU from designating shading units to perform hull shading domain shading and or geometry shading operations. Accordingly GPU may be unable to support shader stages associated with APIs that include such functionality.

For example predecessor GPUs that supported the previous DirectX 9 API developed by Microsoft which may include the Direct3D 9 API may be unable to support DirectX 10 API which may include the Direct3D 10 API . That is at least some of the features of the DirectX 10 API e.g. such as certain shader stages may be unable to be performed using predecessor GPUs. Moreover GPUs that supported the previous DirectX 9 API and the DirectX 10 API may be unable to support all features of the DirectX 11 API. Such incompatibilities may result in a large number of currently deployed GPUs that may no longer provide support for executing software or other applications that rely on DirectX 10 or DirectX 11. While the example above is described with respect to Microsoft s DirectX family of APIs similar compatibility issues may be present with other APIs and legacy GPUs .

In addition supporting a relatively longer graphics processing pipeline e.g. a rendering pipeline having additional shader stages may require a more complex hardware configuration. For example introducing a geometry shader stage to the rendering pipeline to perform geometry shading when implemented by a dedicated one of shading units may result in additional reads and writes to the off chip memory. That is GPU may initially perform vertex shading with one of shading units and store vertices to storage unit . GPU may also read vertices output by the vertex shader and write the new vertices generated when performing geometry shading by one of shading units . Including tessellation stages e.g. a hull shader stage and domain shader stage to a rendering pipeline may introduce similar complexities as described below.

Additional reads and writes to off chip memory may consume memory bus bandwidth e.g. a communication channel connecting GPU to storage unit while also potentially increasing the amount of power consumed considering that the reads and writes each require powering the memory bus and storage unit . In this sense implementing a graphics pipeline with many stages using dedicated shading units for each shader stage may result in less power efficient GPUs. In addition such GPUs may also perform slower in terms of outputting rendered images due to delay in retrieving data from storage unit .

Aspects of this disclosure generally relate to merging the function of one or more of shading units such that one of shading units may perform more than one shading function. For example typically GPU may perform a rendering process which may be referred to as a rendering pipeline having shader stages by designating shading units to perform particular shading operations where each of shading units may implement multiple instances of the same shader at the same time. That is GPU may designate one or more of shading units to perform vertex shading operations e.g. supporting up to 256 concurrent instances of a vertex shader. GPU may also designate one or more of shading units to perform pixel shading operations e.g. supporting up to 256 concurrent instances of a pixel shader. These hardware units may store the output from executing one of the three shaders to an off chip memory such as storage unit until the next designated hardware unit is available to process the output of the previous hardware unit in the graphics processing pipeline.

While aspects of this disclosure may refer to specific hardware shading units in the singular e.g. a hardware shading unit it should be understood that such units may actually comprise one or more shading units more than one shader processor as well as one or more other components of GPU for performing shading operations. For example as noted above GPU may have a plurality of associated shading units . GPU may designate more than one of shading units to perform the same shading operations with each of the shading units configured to perform the techniques of this disclosure for merging shading operations. In general a hardware shading unit may refer to a set of hardware components invoked by a GPU such as GPU to perform a particular shading operation.

In one example aspects of this disclosure include performing vertex shading operations and geometry shading operations with a single hardware shading unit. In another example aspects of this disclosure include performing vertex shading operations and hull shading operations with a single hardware shading unit. In still another example aspects of this disclosure include performing domain shading operations and geometry shading operations with a single hardware shading unit. Aspects of this disclosure also relate to the manner in which a hardware shading unit transitions between shading operations. That is aspects of this disclosure relate to transitioning between performing a first shading operation with the hardware shading unit and performing a second shading operation with the same hardware shading unit.

For example according to aspects of this disclosure GPU may perform with a shading unit designated to perform vertex shading operations vertex shading operations to shade input vertices so as to output vertex shaded vertices. In this example shading unit may be configured with an interface that receives a single vertex as an input and generates a single vertex as an output. In addition GPU may perform with the same shading unit a geometry shading operation to generate one or more new vertices based on one or more of the vertex shaded vertices. The geometry shading operation may operate on at least one of the one or more vertex shaded vertices to output the one or more new vertices. Again while described with respect to a single shading unit these techniques may be concurrently implemented by a plurality of shading units of GPU .

Certain APIs may require that a shading unit designated to perform vertex shading operations implements or adheres to a 1 1 interface which receives a single vertex as an input and generates a single vertex as an output. In contrast a shading unit designated to perform geometry shading operations may implement or adhere to a 1 N interface which receives one or more vertices as an input and generates one or more and often many hence the use of N above vertices as outputs.

According to aspects of this disclosure GPU may leverage the 1 1 interface of a shading unit designated to perform vertex shading operations to emulate this 1 N geometry shader interface by invoking multiple instances of a geometry shader program. GPU may concurrently execute each of these geometry shader programs to generate one of the new vertices that result from performing the geometry shader operation. That is shading units may be programmable using a HLSL e.g. with a graphics rendering API such that shading units may concurrently execute multiple instances of what is commonly referred to as a shader program. These shader programs may be referred to as fibers or threads both of which may refer to a stream of instructions that form a program or thread of execution . According to aspects of this disclosure and as described in greater detail below GPU may execute multiple instances of a geometry shader program using a hardware shading unit designated for vertex shading operations. GPU may append the geometry shader instructions to the vertex shader instructions so that the same shading unit executes both shaders e.g. the vertex shader and the geometery shader in sequence.

In another example according to aspects of this disclosure GPU may perform with a hardware shading unit designated to perform vertex shading operations vertex shading operations to shade input vertices so as to output vertex shaded vertices. The hardware shading unit may adhere to an interface that receives a single vertex as an input and generates a single vertex as an output. In addition GPU may perform with the same hardware shading unit designated for performing vertex shading operations one or more tessellation operations e.g. hull shading operations and or domain shading operations to generate one or more new vertices based on one or more of the vertex shaded vertices. The one or more tessellation operations may operate on at least one of the one or more vertex shaded vertices to output the one or more new vertices.

For example in addition to the shader stages described above some graphics rending pipelines may also include a hull shader stage a tessellator stage and a domain shader stage. In general the hull shader stage tessellator stage and domain shader stage are included to accommodate hardware tessellation. That is the hull shader stage tessellator stage and domain shader stage are included to accommodate tessellation by GPU rather than being performed by a software application being executed for example by CPU .

According to aspects of this disclosure GPU may perform vertex shading and tessellation operations with the same shading unit . For example GPU may perform vertex shading and tessellation operations in two passes. According to aspects of this disclosure and described in greater detail below GPU may store a variety of values to enable transitions between the different shading operations.

In an example in a first pass GPU may designate one or more shading units to perform vertex shading and hull shading operations. In this example GPU may append hull shader instructions to vertex shader instructions. Accordingly the same shading unit executes the vertex shading and hull shader instructions in sequence.

In a second pass GPU may designate the one or more shading units to perform domain shading and geometry shading operations. In this example GPU may append domain shader instructions to the geometry shader instructions. Accordingly the same shading unit executes the domain shading and geometry shading operations in sequence. By performing multiple shading operations in multiple passes GPU may use the same shading hardware to emulate a GPU having additional shading capabilities.

Aspects of this disclosure also relate to the manner in which GPU transitions between shading operations. For example aspects of this disclosure relate to the manner in which shading operations are patched together so that the operations are executed in sequence by the same hardware shading unit.

In an example according to aspects of this disclosure GPU may designate one or more shading units to perform first shading operations associated with a first shader stage of a rendering pipeline. GPU may switch operational modes of shading unit upon completion of the first shading operations. GPU may then perform with the same shading unit designated to perform the first shading operations second shading operations associated with a second different shader stage of the rendering pipeline.

According to some examples GPU may patch shading operations together using a plurality of modes with each mode having a particular set of associated shading operations. For example a first mode may indicate that a draw call includes only vertex shading operations. In this example upon executing the draw call GPU may designate one or more shading units to perform vertex shading operations in accordance with the mode information. In addition a second mode may indicate that a draw call includes both vertex shading and geometry shading operations. In this example upon executing the draw call GPU may designate one or more shading units to perform vertex shading operations. In addition according to aspects of this disclosure GPU may append geometry shader instructions to vertex shader instructions such that the same shading units execute both vertex and geometry shading operations. Additional modes may be used to indicate other combinations of shaders as described in greater detail below.

In some examples GPU driver may generate the mode information used by GPU . According to aspects of this disclosure the different shaders e.g. vertex shading operations geometry shading operations hull shading operations domain shading operations and the like do not have to be compiled in a particular manner in order to be executed in sequence by the same shading unit . Rather each shader may be independently compiled without reference to any other shader and patched together at draw time by GPU . That is upon executing a draw call GPU may determine the mode associated with the draw call and patch compiled shaders together accordingly.

The techniques of this disclosure may enable a GPU such as GPU having a limited number of shading units for performing shading operations to emulate a GPU having a greater number of shading units . For example while GPU may be prevented from designating shading units to perform more than two shading operations e.g. vertex shading operations and pixel shading operations the techniques of this disclosure may enable GPU to perform additional shading operations e.g. geometry shading operations hull shading operations and or domain shading operations without reconfiguring shading units . That is the techniques may allow shading units to adhere to input output constraints of certain shader stages while performing other shading operations.

Moreover by performing multiple shading operations with the same shading units the techniques may reduce memory bus bandwidth consumption. For example in the case of vertex shading being performed with other shading operations e.g. geometry shading shading units used for vertex shading do not need to store the vertex shading results to an off chip memory such as storage unit prior to performing the other shader operations. Rather vertex shading results may be stored to GPU memory and immediately used for geometry shading operations.

In this manner the techniques may reduce memory bus bandwidth consumption in comparison to GPUs having additional shading units which may reduce power consumption. The techniques may therefore promote more power efficient GPUs that utilize less power than GPUs having additional hardware shader units. Accordingly in some examples the techniques may be deployed in power limited devices such as mobile devices laptop computers and any other type of device that does not have a constant dedicated supply of power.

It should be understood that computing device may include additional modules or units not shown in for purposes of clarity. For example computing device may include a transceiver module for transmitting and receiving data and may include circuitry to allow wireless or wired communication between computing device and another device or a network. Computing device may also include a speaker and a microphone neither of which are shown in to effectuate telephonic communications in examples where computing device is a mobile wireless telephone or a speaker where computing device is a media player. In some instances user interface unit and display unit may be external to computing device in examples where computing device is a desktop computer or other device that is equipped to interface with an external user interface or display.

Graphics processing pipeline generally includes programmable stages e.g. illustrated with rounded corners and fixed function stages e.g. illustrated with squared corners . For example graphics rendering operations associated with certain stages of graphics rendering pipeline are generally performed by a programmable shader processor such as one of shading units while other graphics rendering operations associated with other stages of graphics rendering pipeline are generally preformed by non programmable fixed function hardware units associated with GPU . Graphics rendering stages performed by shading units may generally be referred to as programmable stages while stages performed by fixed function units may generally be referred to as fixed function stages.

Input assembler stage is shown in the example of as a fixed function stage and is generally responsible for supplying graphics data triangles lines and points to graphics processing pipeline . For example input assembler stage may collect vertex data for high order surfaces primitives and the like and output vertex data and attributes to vertex shader stage . Accordingly input assembler stage may read vertices from an off chip memory such as storage unit using fixed function operations. Input assembler stage may then create pipeline work items from these vertices while also generating vertex identifiers VertexIDs instance identifiers InstanceIDs which are made available to the vertex shader and primitive identifiers PrimativeIDs which are available to the geometry shader and pixel shader . Input assembler stage may automatically generate VertexIDs InstanceIDs and PrimitiveIDs upon reading the vertices.

Vertex shader stage may process the received vertex data and attributes. For example vertex shader stage may perform per vertex processing such as transformations skinning vertex displacement and calculating per vertex material attributes. In some examples vertex shader stage may generate texture coordinates vertex color vertex lighting fog factors and the like. Vertex shader stage generally takes a single input vertex and outputs a single processed output vertex.

Geometry shader stage may receive a primitive defined by the vertex data e.g. three vertices for a triangle two vertices for a line or a single vertex for a point and further process the primitive. For example geometry shader stage may perform per primitive processing such as silhouette edge detection and shadow volume extrusion among other possible processing operations. Accordingly geometry shader stage may receive one primitive as an input which may include one or more vertices and outputs zero one or multiple primitives which again may include one or more vertices . The output primitive may contain more data than may be possible without geometry shader stage . The total amount of output data may be equal to the vertex size multiplied by the vertex count and may be limited per invocation. The stream output from geometry shader stage may allow primitives reaching this stage to be stored to the off chip memory such as memory unit . The stream output is typically tied to geometry shader stage and both may be programmed together e.g. using an API .

Rasterizer stage is typically a fixed function stage that is responsible for clipping primitives and preparing primitives for pixel shader stage . For example rasterizer stage may perform clipping including custom clip boundaries perspective divide viewport scissor selection and implementation render target selection and primitive setup. In this way rasterizer stage may generate a number of fragments for shading by pixel shader stage .

Pixel shader stage receives fragments from rasterizer stage and generates per pixel data such as color. Pixel shader stage may also perform per pixel processing such as texture blending and lighting model computation. Accordingly pixel shader stage may receive one pixel as an input and may output one pixel at the same relative position or a zero value for the pixel .

Output merger stage is generally responsible for combining various types of output data such as pixel shader values depth and stencil information to generate a final result. For example output merger stage may perform fixed function blend depth and or stencil operations for a render target pixel position . While described above in general terms with respect to vertex shader stage geometry shader stage and pixel shader stage each of the foregoing description may refer to on or more shading units such as shading units designated by a GPU to perform the respective shading operations.

Certain GPUs may be unable to support all of the shader stages shown in . For example some GPUs may be unable to designate shading units to perform more than two shading operations due to hardware and or software restrictions e.g. a limited number of shading units and associated components . In an example certain GPUs may not support operations associated with geometry shader stage . Rather the GPUs may only include support for designating shading units to perform vertex shader stage and pixel shader stage . Thus operations performed by shading units must adhere to the input output interface associated with vertex shader stage and pixel shader stage .

In addition in some examples introducing geometry shader stage to the pipeline may result in additional reads and writes to storage unit relative to a graphics processing pipeline that does not include geometry shader stage . For example as noted above vertex shader stage may write vertices out to off chip memory such as storage unit . Geometry shader stage may read these vertices the vertices output by vertex shader stage and write the new vertices which are then pixel shaded. These additional reads and writes to storage unit may consume memory bus bandwidth while also potentially increasing the amount of power consumed. In this sense implementing a graphics processing pipeline that includes each of the vertex shader stage geometry shader stage and pixel shader stage may result in less power efficient GPUs that may also be slower in terms of outputting rendered images due to delay in retrieving data from storage unit .

As noted above aspects of this disclosure generally relate to merging the function of one or more of shading units such that a shading unit designated for a particular shading operation may perform more than one shading operation. As described in greater detail below in some examples one shading unit may be designated for performing vertex shading operations associated with vertex shader stage . According to aspects of this disclosure the same shading unit may also be implemented to perform geometry shading operations associated with geometry shader stage . That is GPU may invoke the shading unit to perform vertex shading operations but may also implement the shading unit to perform geometry shading operations without re designating the shading unit to perform the geometry shading task.

For example vertex shader stage represents one or more units such as shading units that perform vertex shading operations. That is vertex shader stage may include components that are invoked by GPU to perform vertex shading operations. For example vertex shader stage may receive a vertex as an input and translate the input vertex from the three dimensional 3D model space to a two dimensional 2D coordinate in screen space. Vertex shader stage may then output the translated version of the vertex which may be referred to as the translated vertex . Vertex shader stage does not ordinarily create new vertices but operates on one vertex at a time. As a result vertex shader stage may be referred to as a one to one 1 1 stage that vertex shader stage receives a single input vertex and outputs a single output vertex.

Geometry shader stage represents one or more units such as shading units that perform geometry shading operations. That is geometry shader stage may include components that are invoked by GPU to perform geometry shading operations. For example geometry shader stage may be useful for performing a wide variety of operations such as single pass rendering to a cube map point sprite generation and the like. Typically geometry shader stage receives primitives composed of one or more translated vertices which have been vertex shaded by vertex shader stage . Geometry shader stage performs geometry shading operations to create new vertices that may form new primitives or possibly transform the input primitive to a new type of primitive having additional new vertices .

For example geometry shader stage typically receives a primitive defined by one or more translated vertices and generates one or more new vertices based on the received primitive. Geometry shader stage then outputs the new vertices which may form one or more new primitives . As a result geometry shader stage may be referred to as a one to many 1 N or even a many to many N N stage in that geometry shader stage receives one or more translated vertices and generates a number of new vertices.

While described as being one to many or even many to many geometry shader stage may also in some instances not output any new vertices or only output a single new vertex. In this respect the techniques should not be limited to only those geometry shaders that output many vertices in every instance but may be generally implemented with respect to any geometry shader stage that may output zero one or many new vertices as will be explained in more detail below.

The output of geometry shader stage may be stored for additional geometry shading e.g. during stream out . The output of geometry shader stage may also be output to a rasterizer that rasterizes the new vertices and the translated vertices to generate a raster image comprised of pixels.

The pixels from geometry shader stage may also be passed to pixel shader stage . Pixel shader stage which may also be referred to as a fragment shader may compute color and other attributes of each pixel performing a wide variety of operations to produce a shaded pixel. The shaded pixels may be merged with a depth map and other post shading operations may be performed to generate an output image for display via a display device such as computer monitor television or other types of display devices.

The shader stages shown in may support one or more graphics APIs. In an example for purposes of illustration vertex shader stage geometry shader stage and pixel shader stage may support the DirectX 10 API. That is code produced using the DirectX 10 API may be executed by vertex shader stage geometry shader stage and pixel shader stage to render graphics data. Geometry shader stage however may be not be included in all graphics rendering pipelines and may not be executable by all GPUs. For example while the DirectX 10 API includes support for geometry shader stage certain earlier revisions e.g. DirectX 9 do not include such support. Accordingly GPUs designed to execute code created with earlier revisions of the DirectX API or GPUs designed for other APIs may not be able to designate shading units to perform the geometry shader stage .

For example upon vertex shading operations being invoked by GPU VS GS stage may perform both vertex shading operations and geometry shading operations. That is merged VS GS stage may include the same set of shading units for performing the operations described above with respect to vertex shader stage and for performing the operations described above with respect to geometry shader stage .

However because GPU initially invokes each shading unit as a vertex shading unit components of GPU may be configured to receive data from the vertex shading unit in a particular format e.g. adhering to a 1 1 input output interface. For example GPU may allocate a single entry in a cache e.g. a vertex parameter cache as described in greater detail below to store the output from a shading unit for a shaded vertex. GPU may also perform some rasterization operations based on the manner in which the shading unit is invoked. As described in greater detail below aspects of this disclosure allow GPU to perform geometry shading operations with the same shading unit as the vertex shading operations while still adhering to the appropriate interface.

In some instances the geometry shader stage may primarily be used for low amplification of data e.g. point sprite generation . Such operations may require relatively low ALU usage per geometry shader invocation. Accordingly ALUs of shading units may not be fully utilized during geometry shader stage . According to aspects of this disclosure geometry shader stage may be appended to vertex shader stage to form merged VS GS stage which may be invoked as vertex shader stage in GPU architecture. Invoking the merged VS GS stage in the manner described above may increase ALU utilization by allowing both vertex shading and geometry shading operations to be performed by the same processing units.

To enable merged VS GS stage GPU may perform functions for transitioning between vertex shading operations a 1 1 stage and geometry shading operations a 1 N stage as described in greater detail with respect to the example shown in . In this way the techniques of this disclosure allow a GPU having limited resources e.g. which may prevent the GPU from designating shading units to perform more than two shading operations to emulate a GPU having additional resources.

In the example of GPU may designate a shading unit to perform vertex shading operations. Accordingly components of GPU may be configured to send data for a vertex to shading unit and receive data for a shaded vertex from shading unit e.g. a 1 1 interface . The shading unit may execute a vertex shader to perform vertex shading operations thereby generating a first set of primitives . In the example of the first set of primitives include a triangle with adjacency having four vertices denoted as points p p.

After executing the vertex shading operations GPU may store the shaded vertices to local memory resources. For example GPU may export the vertex shader output to a position cache e.g. of GPU memory along with cut information if any and a streamid. The vertex shading operations and geometry shading operations may be separated by a VS END instruction. Accordingly after executing the VS END instruction and completing the vertex shading operations one or more shading units designated to perform the vertex shading operations each begin performing geometry shading operations.

That is according to aspects of this disclosure the same shading unit designated to perform vertex shading operations also performs geometry shading operations. For example GPU may change state to geometry shader specific resources e.g. geometry shader constants texture offsets and the like by changing one or more resource pointers. GPU may perform this state change according to a mode draw mode assigned to the shading operations.

In some examples GPU may set a draw mode when executing a draw call. The draw mode may indicate which shading operations are associated with the draw call. In an example for purposes of illustration a draw mode of 0 may indicate that the draw call includes vertex shading operations only. A draw mode of 1 may indicate that the draw call includes both vertex shading operations and geometry shading operations. Other draw modes are also possible as described in greater detail below. Table 1 provides an example mode table having two modes 

In the example of Table 1 above flow indicates the flow of operations as executed by GPU associated with the respective modes. For example mode 0 includes vertex shading VS and pixel shading PS operations. Accordingly GPU may designate shading units to perform vertex shading operations and pixel shading operations upon executing a mode 0 draw call. Mode 1 of Table 1 includes vertex shading and pixel shading operations as well as geometry shading GS operations.

Accordingly GPU may designate shading units to perform vertex shading operations and pixel shading operations. However GPU may also append geometry shader instructions to vertex shader instructions so that geometry shader operations are executed by the same shading units responsible for executing the vertex shader operations. The misc bits are reserved for variables e.g. rel primID rel vertex GsInstance Gsoutvertex that are used to enable the same shading unit to execute multiple different shaders in succession.

In the example of the same shading unit also generates a second set of primitives which may be referred to as a triangle strip having vertices V V using the first set of primitives as an input. To generate vertices V V the shading unit designated for vertex shading executes multiple instances of a geometry shader operation e.g. denoted by their output identifiers outID and which may also be referred to as different instances of the same geometry shader program . Each instance of the geometry shader operation executes the same algorithm to perform the same geometry shading operation and generates respective instances of the one or more new vertices V V.

The eight columns of the table shown in correspond to eight separate instances of the geometry shader operation or program where each column from left to right may be identified by the geometry shader operation outID of 0 7. The number of merged VS GS outputs per input primitive may be equal to dcl maxoutputvertexcount GSInstancecount where each VS GS output is one vertex emitted from a geometry shader stage. In instances in which the number of geometry shader stage output vertices are less than dcl maxoutputvertexcount that output vertex can be conditionally discarded or omitted which may be referred to as being killed as described in greater detail below. Accordingly each fiber corresponds to one invocation of a vertex shader followed by one invocation a geometry shader per geometry shader output vertex specified by MaxVertexOutput.

In the example shown in each of the eight instances of the geometry shader operation is appended and executed often concurrently by the same shading unit designated for vertex shading operations to generate a separate instance of the one or more new vertices. Thus each of the instances of the geometry shader operations generates all six of the vertices V V but only outputs a corresponding one of the six new vertices. Each instance of the geometry shader operation only outputs a corresponding one of the six new vertices so as to adhere to the 1 1 interface associated with invoking shading unit to perform vertex shading operations.

As shown in the example of each of the geometry shader operations outputs the one of the six new vertices that matches its outID. Thus the first instance of the geometry shader operation having an outID 0 outputs the first one of the six new vertices V. The second instance of the geometry shader operation having an outID 1 outputs the second one of the six new vertices V. The third instance of the geometry shader operation having an outID 2 outputs the third one of the six new vertices V. The fourth instance of the geometry shader operation having an outID 3 outputs the fourth one of the six new vertices V. The fifth instance of the geometry shader operation having an outID 4 outputs the second one of the six new vertices V. The sixth instance of the geometry shader operation having an outID 5 outputs the sixth one of the six new vertices V.

The seventh and eighth instances of the geometry shader operation are killed or terminated because the geometry shader operation only generates six new vertices and the outIDs of the seventh and eighth instance of the geometry shader operation do not correspond to any of the six new vertices. Thus shading unit terminates execution of the seventh and eight instances of the geometry shader operation upon determining that there is no corresponding vertex associated with these instances of the geometry shader operation.

Table 2 shown below illustrates several parameters that may be maintained by GPU to perform vertex shading operations and geometry shading operations.

Certain parameters shown in Table 2 e.g. uv msb Rel patchid are not used for VS GS operations and are described in greater detail below. In the example of Table 2 index indicates the relative index of the vertices. PrimitiveID indicates the primitive ID used during the geometry shading operations to identify the primitive of the associate vertices and may be a system generated value e.g. generated by one or more hardware components of GPU . As noted above Misc indicates reserved cache values for performing the GS operations after the VS operations. For example table 3 shown below illustrates parameter values when performing the vertex shading and geometry shading operations described above with respect to .

While a number of fibers e.g. instructions are allocated for performing the vertex shading and geometry shading operations in some instances GPU may only execute a sub set of the fibers. For example GPU may determine whether instructions are valid valid as input shown in Table 3 above before executing the instructions with shading units . Because only three of the allocated fibers are used to generate shaded vertices GPU may not execute the remaining fibers fibers 3 7 in Table 3 above when performing vertex shading operations which may conserve power. As described in greater detail below GPU may determine which fibers to executed by based on a mask e.g. cov mask  in below .

Certain APIs e.g. the DirectX 10 API provide for a so called stream out from the geometry shader stage where the stream out refers to outputting the new vertices from the geometry shader to a memory such as storage unit so that these new vertices may be input back into the geometry shader.

The techniques may provide support for this stream out functionality by enabling the hardware unit to output the new vertices that result from performing the geometry shader operation to storage unit . The new vertices output via this stream out are specified in the expected geometry shader format rather than in the format expected by the rasterizer. The hardware unit may retrieve these new vertices and continue to implement an existing geometry shader operation or a new geometry shader operation with respect to these vertices which may be referred to as stream out vertices in this context. In this way the techniques may enable a GPU such as GPU having a relatively limited number of shading units to emulate a GPU having more shading units.

In the example shown in the merged VS GS hardware shading unit writes system values such as vertex attributes vertex id instance id primitive id misc to a series of registers R R and R . Typically system values may be stored to any otherwise unallocated memory of GPU. By storing the system generated values to a series of registers in a predetermined location GPU may access the system generated values for each of the VS and GS stages. Accordingly the GS stage does not need to be complied based on the VS stage in order to determine where system generated values have been stored. Rather GPU may access predetermined memory locations when performing each of the stages to access the required system generated values.

The merged VS GS hardware unit then performs vertex shading operations . Following the vertex shading operations the merged VS GS hardware shading unit may write the contents of general purpose registers GPRs e.g. primitive vertices from the vertex shading operations to local memory such as GPU memory . The merged VS GS hardware shading unit may then switch to GS texture and constant offsets and a GS program counter as described in greater detail below with respect to .

The merged VS GS hardware shading unit may read the contents of local memory such as the primitive vertices from the vertex shading operations and perform geometry shading operations . The merged VS GS hardware shading unit may output one vertex attribute to a vertex parameter cache VPC as well as an indication of the position of the geometry shaded vertices a stream id any cut indications and any interpreted values to a position cache.

In the example shown in the hardware shading unit may initially perform vertex shading operations VS contained in the first dashed box from top to bottom which may correspond to steps in the example of . According to aspects of this disclosure the hardware shading unit or another component of the GPU may then execute a so called patch code to initiate the switchover from the vertex shading operations to the geometry shading operations contained in the second dashed box from top to bottom which may correspond to steps in the example of . More specifically the commands CHMSK and CHSH may cause the hardware shading unit to switch operational modes in accordance with a mode of the draw call being executed as described above .

For example the hardware shading unit may write the vertex data from the vertex shading operations to local GPU memory so that the shaded vertices are available when performing geometry shading operations. The hardware shading unit or another component of the GPU then executes a change mask CHMSK instruction that switches the resources of the hardware shading unit for geometry shading operations. For example executing the CHMSK instruction may cause the hardware shading unit to determine which mode is currently being executed.

With respect to the Table 2 above executing CHMSK may also cause the hardware shading unit to determine which shader stages are valid e.g. vs valid gs valid and the like . As noted above GPU may allocate a number of fibers for performing the vertex shading and geometry shading operations. However upon executing CHMSK GPU may only execute a sub set of the fibers. For example GPU may determine whether instructions are valid before executing the instructions with shading units . GPU may not execute fibers that are not valid e.g. do not generate a shaded vertex which may conserve power.

The hardware shading unit also executes a change shader CHSH instruction to switch a program counter PC to the appropriate state offsets for performing geometry shading operations. As described in greater detail below this patch code contained in the second dashed box from top to bottom which may correspond to steps in the example of may be the same regardless of which shader stages are being merged.

After executing the patch code the hardware shader unit ceases vertex shading operations and performs geometry shading operations contained in the third dash box from top to bottom corresponding to step in the example of . Typically shaders code for performing shading operations executed by a hardware shading unit that performs multiple shading operations may require recompiling based shader dependencies. For example if primitiveID a system generated value is used by the GS stage the VS stage may be compiled e.g. by compiler to put a primitiveID value in a location from which the GS stage can pick up the value. Accordingly compilation of the VS stage may be dependent on the needs of the GS stage.

According to aspects of this disclosure each of the shaders may be independently compiled without respect to other shaders. For example the shaders may be independently compiled without knowledge when other shaders will be executed. After compilation GPU may patch together the shaders using the patch code shown in based on mode information associated with the draw call being executed at draw time. System generated values vertexID and instanceID may only used in the vertex shader and may be loaded at specified general purpose register slots GPRs as computed by compiling the VS stage. However the primitiveID and other merge shader related values from the primitive controller PC as shown for example in such as misc and rel patchid may be used by any of the shader stages.

The patch code described above may be added to compiled shaders by a driver for GPU such as GPU driver . For example GPU driver determines which shaders are required for each draw call. GPU driver may attach the patch code shown in to the appropriate shaders shaders being merged at a so called driver time or link time thereby linking compiled shaders so that the shaders are executed by the same hardware shading units. GPU driver does not need to recompile the entire shaders thereby conserving computational resources.

In this way GPU may patch shading operations together using a plurality of modes with each mode having a particular set of associated shading operations. Such techniques may enable GPU to perform additional shading operations e.g. geometry shading operations hull shading operations and or domain shading operations without reconfiguring shading units . That is the techniques may allow shading units to adhere to input output constraints of certain shader stages while performing other shading operations.

In the example of VS GS unit is implemented by a one or more shading units designated to perform vertex shading operations in the manner described above. VPC may implement the stream out functionality to store stream out data to the stream out buffer . PC may manage vertices that may need to be transformed. For example PC may assemble the vertices into triangle primitives. VFD may fetch vertex data based on vertex format state. GRAS may receive triangle vertices as an input and may output pixels that are within the triangle boundaries. A pre fetch parser PFP may pre decode a command stream and fetch data via pointers e.g. resource pointers so that this data is ready by the time the main CP engine may need this data.

In an example for purposes of illustration a DirectX 10 dispatch mechanism may be implemented using the graphics processing unit shown in . For example a DirectX draw call may be treated as single pass draw call with draw initiators having mode bits mode information indicating that VS operations and GS operations are merged e.g. performed by the same shading units. This mode enables a GSblock within PC to generate data for VFD with GS output vertexID and GS instanceID. The GSblock creates number of VS fibers for an input primitive based on declared maxoutputvertexcount and GSinstancecount. If the number of fibers in a wave e.g. an amount of work done by a shading unit such as 32 fibers are more than maxoutputvertexcount GSinstancecount then a wave may have multiple complete input GS primitives. Otherwise GS input primitive vertex indices may be repeated for next wave until maxoutputvertexcount GSinstancecount fibers are created. No vertex reuse is needed for the input primitive vertices.

At the output of VPC PC will generate primitive connectivity based on GS output primitive type. For example the first output vertex from a GS of VS GS may typically consist of cut bit in the position cache which may indicate completion of a primitive strip before this vertex. PC also sends this connectivity information for complete primitives to VPC along with streamid for VPC to stream out GS outputs to buffers tied with a given stream. If there is a partial primitive between full primitives in GS such a partial primitive is marked as PRIM AMP DEAD for GRAS to drop the primitive. PC also sends dead primitive types to VPC to de allocate a parameter cache for such a primitive.

Based on maxoutputvertexcount a GPU driver such as GPU driver shown in may compute how many input primitive vertices will be stored in local memory. This input primitive value may be computed as the variable GS LM SIZE according to the following equation 

Accordingly according to aspects of this disclosure the relationship between input and output is not 1 1 as would be typical for a shading unit designated to perform vertex shading operations for VS GS . Rather the GS may output one or more vertices from each input primitive. In addition the number of vertices that are output by GS is dynamic and may vary from one to an API imposed maximum GS output e.g. 1024 double words dwords which may be equivalent to an output maximum of 1024 vertices .

That is the GS may produce a minimum of one vertex and a maximum of 1024 vertices and the overall output from the GS may be 1024 dwords. The GS may declare at compile time a maximum number of output vertices from the GS using the variable dcl maxoutputvertexcount. However the actual number of output vertices may not be known at the time GPU executes the GS. Rather the declaration dcl maxoutputvertexcount may only be required as a parameter for the GS.

The GS may also declare the variable instancecount for the number of GS instances operations to be invoked per input primitive. This declaration may act as an outer loop for the GS invocation identifying the maximum number of geometry shader instances . The maximum instancecount may be set to 32 although other values may also be used. Accordingly the GS has access to a variable GSInstanceID in the geometry shader operations which indicates which instance a given GS is working on. Each of the GS instances can output up to 1024 dwords and each may have dcl maxoutputvertexcount as a number of maximum output vertices. In addition each GS instance may be independent of other GS instances.

The input primitive type which GPU may declare at the input of the GS may be a point a line a triangle a line with adjacency a triangle with adjacency and patch . A triangle with adjacency may be a new feature for certain APIs such as DirectX 10. In addition a patch may be a further enhancement for added for the DirectX 11 API. The output primitive type from the GS can be a point line strip or a triangle strip. The output of the GS may go to one of four streams that may be declared in the GS and the GS may declare how many streams are used. In general a stream refers to shaded data that is either stored e.g. to a memory buffer or sent to another unit of the GPU such as the rasterizer. Each vertex emit instruction may use an emit stream designation that may indicate to which stream the vertex is going.

The GS may use a cut stream instruction or an emitthencut stream instruction to complete a strip primitive type. In such examples a next vertex will start a new primitive for a given stream. In some examples a programmer may declare using an API at most one of the streams to be used as a rasterized stream when setting up streams. In addition four 1D buffers may be tied to one stream but the total number of buffers tied to all of the GS streams may not exceed four. Off chip buffers are not typically shared between streams.

When a vertex is emitted for a given stream the subsections of the vertex for each buffer tied to the stream are written to an off chip buffer such as storage unit as a complete primitive. That is partial primitives are generally not written to an off chip buffer. In some examples the data written to the off chip buffers may be expanded to include and indication of a primitive type and if more than one stream is enabled for a given GS an output primitive type for the GS may be point only.

The GS stage may receive a PrimitiveID parameter as an input because the PrimitiveID is a system generated value. The GS may also output a PrimitiveID parameter a ViewportIndex parameter and a RenderTargetArrayIndex parameter to one or more registers. An attribute interpolation mode for the GS inputs is typically declared to be constant. In some examples it is possible to declare the GS to be NULL but still enable output. In such examples only stream zero may be active. Therefore the VS output may be expanded to list a primitive type and may write values to buffers tied to stream zero. If the input primitive type is declared to be an adjacent primitive type the adjacent vertex information may be dropped. That is for example only internal vertices of an adjacent primitive e.g. even numbered vertex number may be processed to form a non adjacent primitive type.

In the case of a patch input primitive type with a NULL GS the patch is written out as a list of points to buffers tied to the stream. If the declared stream is also rasterized GPU may render the patch as a plurality of points as specified by patch control points. In addition when GS is NULL A viewportindex parameter and a rendertargetarrayindex parameter may be assumed to be zero.

Query counters may be implemented to determine how many VS or GS operations are being processed by GPU thereby allowing hardware components to track program execution. Query counters may start and stop counting based on a stat start event and a stat end event. The counters may be sampled using a stat sample event. The operational block that receives a stat start and or stop event will start or stop counting at various points where increment signals are sent receive such events.

When a driver of GPU needs to read such counters the driver may send a stat sample event through the command processor CP as shown and described with respect to . The CP may refrain from sending any additional draw calls to GPU until a register backbone management RBBM unit gets an acknowledgement or ack back from the operational blocks responsible for incrementing the counters. Once an ack is received the RMMB unit may read the counters and resume sending the next draw call s .

GPU may store a variety of data to local GPU memory . For example the following query counts may be maintained by the CP in hardware. In some examples the following query counts may be formed as 64 bit counters which may be incremented using 1 3 bit pulses from various operational blocks as indicated below 

In addition to the values described above there may be two stream out related query counts that are maintained per stream. These the stream out related values may include the following values 

Typically GPU may support stream out directly from the VPC. As noted above there may be up to four streams that are supported by a GS. Each of these streams may be bound by up to four buffers and the buffers are not typically sharable between different streams. The size of the output to each buffer may be up to 128 dwords which is the same as the maximum size of a vertex. However a stride may be up to 512 dwords. The output data from a stream may be stored to multiple buffers but the data generally may not be replicated between buffers. In an example for purposes of illustration if color.x is written to one of the buffers tied to a stream then this color.x may not be sent to another buffer tied to same stream.

Streaming out to the buffers may be performed as a complete primitive. That is for example if there is space in any buffer for a given stream for only two vertices and a primitive type is triangle e.g. having three vertices then the primitive vertices may not be written to any buffer tied with that stream.

If the GS is null and stream out is enabled the stream out may be identified as a default stream zero. When stream out is being performed the position information may be written into the VPC as well as into the PC which may consume an extra slot. In addition when binning is performed e.g. the process of assigning vertices to bins for tile based rendering stream out may be performed during the binning pass.

In some APIs such as DirectX 10 a DrawAuto function that may patch and render previously created streams may be specified that consumes stream out data. For example a GPU driver may send an event for a stream out flush for a given stream along with a memory address. The VPC upon receiving such an event may send an acknowledge ack bit to the RBBM. The RBBM upon receiving the ack bit writes the amount of buffer space available in a buffer buffered filled size to a driver specified memory or memory location.

In the mean time a pre fetch parser PFP which may be included within the command processor CP waits to send any draw call. Once the memory address is written the PFP may then send a next draw call. If the next draw call is an auto draw call the GPU driver may send a memory address containing buffer filled size as part of a packet that indicate draw calls and state changes e.g. a so called PM4 packet . The PFP reads the buffer filled size from that memory location and sends the draw call to the PC.

GPU may initially invoke vertex shading operations for example upon receiving vertex shader instructions . Invoking the vertex shading operations may cause GPU to designate one or more shading units for the vertex shading operations. In addition other components of GPU such as a vertex parameter cache rasterizer and the like may be configured to receive a single output per input from each of the designated shading units .

GPU may perform with a hardware shading units designated for vertex shading operations vertex shading operations to shade input vertices . That is the hardware shading unit may perform vertex shading operations to shade input vertices and output vertex shaded indices. The hardware shading unit may receive one vertex and output one shaded vertex e.g. a 1 1 relationship between input and output .

GPU may determine whether to perform geometry shading operations . GPU may make such a determination for example based on mode information. That is GPU may execute patch code to determine whether any valid geometry shader instructions are appended to the executed vertex shader instructions.

If GPU does not perform geometry shading operations the NO branch of step GPU the hardware shading unit may output one shaded vertex for each input vertex . If GPU does perform geometry shading operations the YES branch of step the hardware shading unit may perform multiple instances of geometry shading operations to generate one or more new vertices based on the received vertices . For example the hardware shading unit may perform a predetermined number of geometry shading instances with each instance being associated with an output identifier. The hardware shading unit may maintain an output count for each instance of the geometry shading operations. In addition an output identifier may be assigned to each output vertex.

Accordingly to determine when to output a geometry shaded vertex the hardware shading unit may determine when the output count matches an output identifier . For example if an output count for a geometry shading operation does not match the output identifier the NO branch of step the vertex associated with that geometry shading operation is discarded. If the output count for a geometry shading operation does match the output identifier the YES branch of step the hardware shading unit may output the vertex associated with the geometry shading operation. In this way the hardware shading unit designated for vertex shading outputs a single shaded vertex and discards any unused vertices for each instance of the geometry shading program thereby maintaining a 1 1 input to output ratio.

Certain stages shown in may be configured similarly to or the same as the stages shown and described with respect to e.g. assembler stage vertex shader stage geometry shader stage rasterizer stage pixel shader stage and output merger stage . In addition pipeline includes additional stages for hardware tessellation. For example graphics processing pipeline includes in addition to the stages described above with respect to hull shader stage tessellator stage and domain shader stage . That is hull shader stage tessellator stage and domain shader stage are included to accommodate tessellation by GPU rather than being performed by a software application being executed for example by CPU .

Hull shader stage receives primitives from vertex shader stage and is responsible for carrying out at least two actions. First hull shader stage is typically responsible for determining a set of tessellation factors. Hull shader stage may generate tessellation factors once per primitive. The tessellation factors may be used by tessellator stage to determine how finely to tessellate a given primative e.g. split the primitive into smaller parts . Hull shader stage is also responsible for generating control points that will later be used by domain shader stage . That is for example hull shader stage is responsible for generating control points that will be used by domain shader stage to create actual tessellated vertices which are eventually used in rendering.

When tessellator stage receives data from hull shader stage tessellator stage uses one of several algorithms to determine an appropriate sampling pattern for the current primitive type. For example in general tessellator stage converts a requested amount of tessellation as determined by hull shader stage into a group of coordinate points within a current domain. That is depending on the tessellation factors from hull shader stage as well as the particular configuration of the tessellator stage tessellator stage determines which points in a current primitive need to be sampled in order to tessellate the input primitive into smaller parts. The output of tessellator stage may be a set of domain points which may include barycentric coordinates.

Domain shader stage takes the domain points in addition to control points produced by hull shader stage and uses the domain points to create new vertices. Domain shader stage can use the complete list of control points generated for the current primitive textures procedural algorithms or anything else to convert the barycentric location for each tessellated point into the output geometry that is passed on to the next stage in the pipeline. As noted above certain GPUs may be unable to support all of the shader stages shown in . For example some GPUs may be unable to designate shading units to perform more than two shading operations due to hardware and or software restrictions e.g. a limited number of shading units and associated components . In an example certain GPUs may not support operations associated with geometry shader stage hull shader stage and domain shader stage . Rather the GPUs may only include support for designating shading units to perform vertex shader stage and pixel shader stage . Thus operations performed by shading units must adhere to the input output interface associated with vertex shader stage and pixel shader stage .

In addition supporting a relatively longer graphics processing pipeline may require a relatively more complex hardware configuration. For example control points domain points and tessellation factors from hull shader stage tessellator stage and domain shader stage may require reads and writes to off chip memory which may consume memory bus bandwidth and may increase the amount of power consumed. In this sense implementing a graphics pipeline with many stages using dedicated shading units for each shader stage may result in less power efficient GPUs. In addition such GPUs may also be slower in terms of outputting rendered images due to delay in retrieving data from off chip memory as a result of limited memory bus bandwidth.

According to aspects of this disclosure as described in greater detail below shading units designated by GPU to perform a particular shading operation may perform more than one operation. For example a shading unit designated to perform vertex shading VS operations may also perform hull shading operations associated with hull shader stage . In another example the same shading unit may also perform domain shading operations associated with domain shader stage followed by geometry shader operations associated with geometry shader stage .

As described in greater detail below GPU may perform the shading operations above by breaking a draw call into two sub draw calls e.g. pass I and pass II with each sub draw call having associated merged shader stages. That is GPU may invoke the shading unit to perform vertex shading operations but may also implement the shading unit to perform hull shading operations during a first pass. The GPU may then use the same shading unit designated to perform vertex shading operations to perform domain shading operations and geometry shading operations without ever re designating the shading unit to perform the hull shading domain shading or geometry shading tasks.

Hull shader stage also generates tessellation factors that may be used to control the amount of tessellation of a patch. For example hull shader stage may determine how much to tessellate based on a viewpoint and or view distance of the patch. If an object is relatively close to the viewer in a scene a relatively high amount of tessellation may be required to produce a generally smooth looking patch. If an object is relatively far away less tessellation may be required.

Tessellator stage receives tessellation factors and performs tessellation. For example tessellator stage operates on a given patch e.g. a Bezier patch having a uniform grade to generate a number of U V coordinates. The U V coordinates may provide texture for the patch. Accordingly domain shader stage may receive the control points having displacement information and the U V coordinates having texture information and output tessellated vertices. These tessellated vertices may then be geometry shaded as described above.

According to aspects of this disclosure and as described in greater detail below shading operations associated with hull shader stage and domain shader stage may be performed by the same shading units of a GPU such as shading units . That is for example one or more shading units may be designated to perform vertex shading operations. In addition to the vertex shading operations the GPU may append shader instructions associated with hull shader stage and domain shader stage such that the shaders are executed by the same shading units in sequence and without being reconfigured to perform the tessellation operations.

In the example shown in vertex shader stage may be invoked on so called patch control points or control points as described above with respect to . Points in a given patch may be visible to hull shader stage which uses the points to compute tessellation factors for the use by tessellation stage . Hull shader stage may also output patch control points and constant data for use by domain shader stage .

In some examples tessellator stage may include fixed function hardware units for performing tessellation. Tessellator stage may receive tessellation factors and control points from hull shader stage and output so called domain points e.g. U V points that specify where to tessellate. Domain shader stage uses these domain points to compute vertices using output patch data from hull shader stage . Possible output primitives from domain shader stage include for example a point a line or a triangle which may be sent for rasertization stream out or to geometry shader stage . If any of the tessellation factors are less than or equal to zero or not a number NaN the patch may be culled discarded without being computed further .

The shader stages shown in may support one or more graphics APIs. In an example for purposes of illustration vertex shader stage hull shader stage domain shader stage geometry shader stage and pixel shader stage may support the DirectX 11 API. That is code produced using the DirectX 11 API may be executed by vertex shader stage hull shader stage domain shader stage geometry shader stage and pixel shader stage to render graphics data. However certain stages such as hull shader stage domain shader stage and or geometry shader stage may be not be included in all graphics rendering pipelines and may not be executable by all GPUs. For example while the DirectX 11 API includes support for such stages earlier revisions e.g. DirectX 9 and 10 do not include such support. Accordingly GPUs designed to execute code created with earlier revisions of the DirectX API or GPUs designed for other APIs may not be able to designate shading units to perform operations associated with hull shader stage domain shader stage and or geometry shader stage .

According to aspects of this disclosure more than one of the shader stages in may be merged in that the shader stages are performed by a single hardware shading unit e.g. such as shading unit . For example according to aspects of this disclosure a GPU such as GPU may perform multiple passes when executing a draw call to perform the shader stages shown in as described below with respect to .

For example GPU may execute an input draw call that includes tessellation operations as described above with respect to . GPU may initially break the draw call into multiple sub draw calls with each sub draw call including both Pass I operations and Pass II operations. The manner in which GPU divides the draw call may depend at least partially on an amount of memory that is available e.g. on chip GPU memory L2 global memory GMEM or offchip memory . For example GPU may configure the sub draw calls so that GPU is able to store all of the data generated by the Pass I operations to local memory for use with Pass II operations. The division of the draw call may be done in the command processor CP under the control of CP code which may be based on the input draw call type.

In example for purposes of illustration assume a draw call includes 1000 associated patches for rendering. In addition assume that local memory has the capacity to store data associated with 100 patches. In this example GPU or a driver for GPU such as GPU driver may split the draw call into 10 sub draw calls. GPU then performs the Pass I operations and Pass II operations for each of the 10 sub draw calls in sequence.

With respect to Pass I operations upon vertex shading operations being invoked by GPU VS HS stage may perform both vertex shading operations and hull shading operations. That is merged VS HS stage may include a single set of one or more shading units and may perform the operations described above with respect to vertex shader stage and hull shader stage in sequence. As described in greater detail below aspects of this disclosure allow GPU to perform hull shading operations with the same shading unit as the vertex shading operations while still adhering to the appropriate interface. In some examples hull shader instructions may be appended to vertex shader instructions using a patch code thereby allowing the same shading unit to execute both sets of instructions.

GPU may then perform Pass II operations. For example tessellation stage may perform tessellation as described with respect to tessellation stage above. Merged DS GS stage may include the same set of one or more shading units as the merged VS HS stage described above. Merged DS GS stage may perform the domain shading and geometry shading operations described above with respect to domain shader stage and geometry shader stage in sequence. In some examples geometry shader instructions may be appended to domain shader instructions using a patch code thereby allowing the same shading unit to execute both sets of instructions. Moreover these domain shader instructions and geometry shader instruction may be appended to the hull shader instructions of Pass I so that the same shading unit may perform vertex shading hull shading domain shading and geometry shading without being re configured.

The Pass II geometry shading operations may include essentially the same geometry shading operations as those described above. However when beginning Pass II operations the GPR initialized input previously for the VS stage now for the DS stage may include u v patch id produced by tessellation stage rather than fetched data from the vertex fetch decoder VFD . The PC may also compute rel patch id for Pass II and may pass the patch ID information to the DS along with u v computed by tessellation stage . Tessellation stage may use tessellation factors to produce u v coordinates for tessellated vertices. The output of tessellation stage can be fed to merged DS GS stage to prepare tessellated for further amplification geometry shading or stream out . DS uses hull shader HS output control point data and HS patch constant data from the off chip scratch memory.

In some examples the two passes shown in may be performed consecutively but separated by a wait for idle between the two passes. For example the CP of the GPU may send a draw call for Pass I operations. Prior to commencing Pass II on the data the GPU may wait for control point values to be fully written to local memory. To ensure that the correct values are available in local memory the GPU may confirm that the components of the GPU are idle before beginning Pass II operations.

The command processor CP may then send a draw call for Pass II. In an example the ratio of the amount of latency to start a first useful vertex versus the amount of work done in Pass II may be approximately less than 2 . Accordingly in some examples there may be no overlap between Pass I and Pass II. In other examples as described below the GPU may include an overlap between Pass I and Pass II operations. That is the GPU may overlap the pixel shading operations of pixel shader stage of Pass II of a previous draw call with vertex shading operations of VS HS stage of the Pass I of a current draw call because pixel shader processing may take longer than vertex shader processing.

According to aspects of this disclosure a primitive controller PC may send PASS done event after the Pass I which may help the hardware unit to switch to Pass II. In an example in which there may be overlap between Pass I and Pass II the existence of Pass I operations and Pass II operations may be mutually exclusive at the shader processor executing the instructions. However the tessellation factors for Pass II may be fetched while Pass I is still executing.

As described below with respect to the PC may keep a counter per shaded patch to record how many Pass I waves are completed. These counters may indicate how many patches have completed processing for Pass I. As soon as all the counter values are greater than zero tessellation factors may be fetched for Pass II. Accordingly Pass II may start before Pass I is completed. However a draw call for Pass II may not start processing until all of the indices for the Pass I draw call are processed. In this way pipeline flushing transfer from local GPU memory to external memory between the passes may be avoided.

In the example of GPU may designate a shading unit to perform vertex shading operations which may also ultimately perform hull shading domain shading and geometry shading as described in greater detail below without being reconfigured to perform such shading operations. For example the shading unit may initially perform vertex shading operations to generate an input primitive a triangle strip having three vertices denoted as points p p.

After executing the vertex shading operations GPU may store the shaded vertices to local memory resources. For example GPU may export the vertex shader output to a position cache e.g. of GPU memory . The vertex shading operations and hull shading operations may be separated by a VS END instruction. Accordingly after executing the VS END instruction and completing the vertex shading operations one or more shading units designated to perform the vertex shading operations each begin performing hull shading operations.

The same shading unit may then perform hull shading operations to generate an output patch having control points V V. In this example the shading unit executes multiple instances of the hull shader operation which are denoted by their output identifiers Outvert in a similar manner to the geometry shader operations described above with respect to . Each instance of the hull shader operation performs the same algorithm to perform the same hull shading operation and generates respective instances of the one or more new control points V V.

That is the four columns of the table shown in correspond to four separate instances of the hull shader operation or program where each column from left to right may be identified by the hull shader operation Outvert of 0 3. Each of these four instances of the hull shader operation is executed often concurrently by the shading unit to generate a separate instance of the one or more new control points. Thus each of the instances of the hull shader operations generates all four of the control points V V but only outputs a corresponding one of the four new control points. Each instance of the hull shader operation only outputs a corresponding one of the four new control points so as to adhere to the 1 1 interface of the shading unit which was invoked for vertex shading operations.

In the example of each of the hull shader operations outputs the one of the four new control points that matches its Outvert. Thus the first instance of the hull shader operation having an Outvert 0 outputs the first one of the four new control points V. The second instance of the hull shader operation having an Outvert 1 outputs the second one of the four new control points V. The third instance of the hull shader operation having an Outvert 2 outputs the third one of the four new control points V. The fourth instance of the hull shader operation having an Outvert 3 outputs the fourth one of the four new control points V. After the hull shader values have been written to local memory domain shading operations and geometry shading operations may be performed during a second pass Pass II as described above.

According to aspects of this disclosure the same shading unit designated to perform vertex shading operations also performs the hull shading operations described above. Moreover the same shading unit may also perform domain shading and geometry shading operations during a second pass Pass II of the draw call. For example GPU may change state to shader specific resources e.g. hull domain and or geometry shader constants texture offsets and the like . GPU may perform this state change according to a mode draw mode assigned to the shading operations.

Table 4 shown below illustrates operational modes and parameters that may be maintained by GPU to perform vertex shading hull shading domain shading and geometry shading with the same shading unit .

In some instances as indicated in Table 4 above certain shading operations may not be performed for a particular draw call. For example a draw call may include vertex shading hull shading domain shading and pixel shading operations but may not include geometry shading operations as shown for Mode 3 . GPU may use mode information to determine which shading operations to perform when executing a draw call.

Table 5 shown below illustrates parameter values when performing Pass II operations without performing geometry shading operations.

Table 6 shown below illustrates parameter values when performing Pass II operations including performing geometry shading operations.

After completing the operations associated with the first pass Pass I as shown in GPU may wait for idle. GPU may then perform the second pass of the draw call Pass II to complete the draw call.

For example generally illustrates a flow of operations performed by a merged VS HS hardware shading unit when performing vertex shading operations and hull shading operations. The merged VS HS hardware shading unit in some examples may include a shading unit that is designated by GPU to perform vertex shading operations but that performs both vertex shading operations and hull shading operations in accordance with techniques of this disclosure. generally illustrates pseudo code corresponding to the flow of operations shown in which may be executed by the merged VS HS hardware shading unit.

As shown in the hardware shading unit may perform VS operations followed by HS operations. For example a GPU such as GPU may write system generated values including vertex attributes vertex id instance id primitive id and misc as described above to registers. As noted above by storing the system generated values to a series of registers in a predetermined location GPU may access the system generated values for each of the VS and HS stages. Accordingly the HS stage does not need to be complied based on the VS stage in order to determine where system generated values have been stored. Rather GPU may access predetermined memory locations when performing each of the stages to access the required system generated values.

The hardware shading unit may then perform vertex shading operations to generate one or more shaded vertices. The hardware shading unit may write the shaded verticies to local memory so that the shaded vertices are available for hull shading operations.

The GPU may then switch the memory offsets and program counter prior to performing the hull shading operations. The GPU may perform such tasks for example when executing the patch code described above. The hardware shading unit may then read the shaded vertices from local memory and perform hull shading operations to generate one or more control points and tessellation factors.

The control points and tessellation factors generated during the first pass may be stored for example to local GPU memory. In some examples the control points and tessellation factors may be stored in separate buffers within local GPU memory.

In some instances in the VS portion of the shading operations only valid VS fibers are executed as noted above with respect to . On encountering an SWITCH ACTIVE instruction the coverage mask bits are changed to be associated with the HS shader and only active HS fibers are executed. In this way the reserved registers may be used by both VS and HS and the VS and HS may be implemented by a single hardware shading unit without re designating the shading unit to perform HS operations.

For example generally illustrates a flow of operations performed by a merged DS GS hardware shading unit when performing domain shading operations and geometry shading operations. The merged DS GS hardware shading unit in some examples may include the same shading unit as described above with respect to and that is originally designated by GPU to perform vertex shading operations. generally illustrates pseudo code corresponding to the flow of operations shown in which may be executed by the merged DS GS hardware shading unit.

According to aspects of this disclosure the first pass described with respect to may be followed by a wait for idle. That is to prevent data from being read from local memory during the second pass before the data has been fully written to memory during the first pass the GPU may wait for one or more components of the GPU to register as being idle e.g. not computing or transferring data before initiating the second pass operations shown in .

In any case as shown in the hardware shading unit may perform Pass II operations including domain shading and geometry shading tessellation may also be performed by a fixed function tessellation unit . For example the GPU may write system generated values including U V coordinates primitive id and misc as described above to registers. As noted above by storing the system generated values to a series of registers in a predetermined location GPU may access the system generated values for each of the DS and GS stages. Accordingly the GS stage does not need to be complied based on the DS stage in order to determine where system generated values have been stored. Rather GPU may access predetermined memory locations when performing each of the stages to access the required system generated values.

The hardware shading unit may then perform domain shading operations to generate one or more tessellated vertices. The hardware shading unit may write the tessellated verticies to local memory so that the tessellated vertices are available for geometry shading operations.

The GPU may then switch the memory offsets and program counter prior to performing the geometry shading operations. The GPU may perform such tasks for example when executing the patch code described above. The hardware shading unit may then read the tessellated vertices from local memory and perform geometry shading operations to generate one or more geometry shaded vertices which may be stored to a vertex parameter cache.

In the example shown in the capital lettered words are state or constant registers. The italic word indicates shader input. Number of GPRs allocated for this shader is a maximum of gprs needed for vs gprs needed for gs . Accordingly GPRs used in DS operations are released and used for GS operations. Upon encountering an SWITCH ACTIVE instruction the coverage mask bits are changed to be associated with the GS operations and only active GS fibers are executed. Upon encountering an END 1st instruction the hardware shader unit may switch resource offsets for the Constant File and Texture Pointers e.g. a resource pointer to the GS programmed offsets and jump to the first instruction of the GS. In this way the reserved registers may be used by both DS and GS shader stages and the DS and GS shader stages may be executed by the same hardware shading unit that performed the Pass I operations.

As shown in the examples of a single hardware shading unit may perform the operations of four different shader stages. According to some examples the patch code for merging shader stages may be the same regardless of which shader stages are being merged. For example DS operations may be merged with GS operations using the same patch code shown in the second dashed box from the top of as that used for merging VS and HS operations shown in the second dashed box from the top of . The hardware shading unit may switch to the appropriate shading operations based on an operational mode as shown and described with respect to the tables above which may be determined by the GPU at draw time.

According to aspects of this disclosure each shader stage VS GS HS DS may be complied separately and without knowing how the stages will be linked during execution. Accordingly three GPRs may be reserved to store parameters such as primitveID rel patch ID and misc. The compiler may cause input attributes or internal variables to be stored in GPRs IDs beyond two for DX10 DX11 applications.

In the example of the VS GS unit is implemented by one or more shading units in the manner described above. VPC may implement the stream out functionality to store stream out data to memory . PC may manage vertices that may need to be transformed and assembles the vertices into triangle primitives. VFD may fetch vertex data based on vertex format state. GRAS may receive triangle vertices as an input and may output pixels that are within the triangle boundaries. A pre fetch parser PFP may pre decode a command stream and fetch data via pointers e.g. resource pointers so that this data is ready by the time the main CP engine needs this data.

With respect to a dispatch mechanism for DirectX 11 a draw call may be divided in two pass draw by CP . Based on available storage to store output of Pass I a draw call may be divided into multiple sub draw calls with each sub draw call having a Pass I and a Pass II. Each sub draw call may adhere to the ordering of passes such that Pass I is performed for a sub draw call followed by Pass II for the sub draw call.

Upon receiving a sub draw call with Pass I PC may fetch indices and process a patch primitive type using VS HS . VS HS creates

Based on HS FIBERS PER PATCH a GPU driver such as GPU driver shown in may compute how many input primitive vertices will be stored in local memory local to VS HS . This may be computed as 

System interpreted values SIV e.g. clip cull distances rendertarget viewport may also be provided to VPC for loading into PS . A shader stage e.g. VS or GS may conditionally output the values. Accordingly if PS needs the values PS may set such a condition as part of a state. If PS does not need the values and such a determination is done after compilation of the pixel shading operations the state of outputting these SIVs can be reset so that VS or GS will not write the values to VPC at draw time.

For null GS if no geometry shader stage is being executed the compiler may also create a template GS so that there is no separate path for null or non null GS. This template GS may copy VS or domain shader DS output to local memory and further copy from local memory to output to VPC . This may only be done for a case in which stream out is performed.

The process of binning and consuming a visibility streams may be different depending on which shaders are being implemented. For example certain GPUs may divide image data to be rendered into tiles or bins rendering each bin successively or sometimes concurrently or in parallel until the entire image is rendered. By dividing the image into bins the GPUs may reduce on chip memory requirements while also promoting less data retrieval from off chip memory considering that the on chip memory may be large enough to store sufficient image data to render the tile .

With respect to a visibility stream a Z buffer algorithm may be used to determine primitives that are occluded by other primitives and therefore do not need to be rendered . For example the GPU may draw each primitive working from the back most depth wise primitive to the front most again depth wise primitive. In this example some primitives may be rendered only to be drawn over by other primitives.

As a result of this so called overdraw GPUs may be adapted to perform early Z buffer algorithm testing which allows the GPUs to identify primitives that are entirely occluded or not within the eye view to be ignored or bypassed when the GPU performs rendering. In this respect GPUs may be adapted to determine what may be referred to as visibility information with respect to each primitive and or object.

With respect to DX10 during the binning pass PC sends end of primitive to GRAS at the end of all the output primitives from a GS. Therefore visibility information is recorded per input primitive. Stream out may be performed during the binning pass. CP can read all stream out buffer related information at the end of the binning pass. Geometry related query counters may be updated during the binning pass.

A visibility pass may read the visibility stream and advance the stream as visibility information per primitive is read. If no stream is rasterized then the visibility pass may be skipped. Otherwise PC checks for visibility input GS primitive and process to render without any streamouts.

With respect to DX11 during a binning pass PC sends end of primitive to GRAS at the end of all the output primitives from a GS in Pass II e.g. one bit per input patch . Stream out may be performed as described above. During a visibility pass a visibility stream is processed in Pass I along with patches only patches with visibility may be processed . Pass II only processes visible patches and fetches tessellation factors for visible patches only.

Table 7 shown below provides information regarding the binning pass and rendering pass for each of five different modes of operation. Each mode corresponds to certain operations being performed by a single hardware shading unit as described above.

In the example of GPU determines whether the draw call currently being executed to render graphics includes tessellation operations . Tessellation operations may include for example operations associated with a hull shader stage a tessellation stage and a domain shader stage as described above. If the draw call does not include tessellation operations GPU may perform rendering with a single pass . For example GPU may perform vertex shading geometry shading and pixel shading in the manner described above.

If the draw call does include tessellation operations GPU may determine the size of local GPU memory resources such as GPU memory . GPU may then split the draw call into a plurality of sub draw calls . In some examples each sub draw call may include the Pass I operations and Pass II operations described above. For example Pass I operations may include vertex shading operations and hull shading operations while Pass II operations may include domain shading operations and geometry shading operations.

The amount of data rendered by each sub draw call may be determined based on the size of GPU memory . For example GPU may configure the sub draw calls so that GPU is able to store all of the data generated by the Pass I operations to local memory for use with Pass II operations. In this way GPU may reduce the amount of data being transferred between local GPU memory and memory external to the GPU which may reduce latency associated with rendering as described above.

After determining the sub draw calls GPU may perform Pass I operations for the first sub draw call . As noted above Pass I operations may include performing vertex shading operations and hull shading operations using the same hardware shading unit e.g. each of one or more shading units . That is while GPU may designate a number of shading units to perform vertex shading each of the shading units may perform both vertex shading and hull shading operations.

GPU may also perform Pass II operations for the first sub draw call . As noted above Pass II operations may include performing domain shading operations and geometry shading operations using the same one or more shading units . Again while GPU may designate a number of shading units to perform vertex shading each of the shading units may perform Pass II operations such that each of shading units performs vertex shading operations hull shading operations domain shading operations and geometry shading operations.

GPU may also perform pixel shading operations for the sub draw call . GPU may perform pixel shading operations using one or more other shading units . In other examples GPU may perform pixel shading for an entire draw call after all of the sub draw calls are complete.

GPU may then determine whether the completed sub draw call is the final sub draw call of the draw call . If the sub draw call is the final sub draw call of a draw call GPU may output the rendered graphics data associated with the draw call. If the sub draw call is not the final sub draw call of the draw call GPU may return to step and perform Pass I operations for the next sub draw call.

It should be understood that the steps shown in are provided as merely one example. That is the steps shown in need not necessarily be performed in the order shown and fewer additional or alternative steps may be performed.

In the example of GPU may initially designate one or more shading units to perform vertex shading operations associated with a vertex shader stage of a graphics rendering pipeline as described above . After performing the vertex shading operations each of the designated shading units may store the shaded vertices to local memory for hull shading operations . GPU may also change a program counter for tracking hull shading operations as well as change one or more resource pointers to hull shader resources offset. For example the resource pointers may point to data locations allocated for hull shading operations.

In this sense each of the shading units change operational modes to perform hull shading operations. However the mode change does not include re designating the shading units to perform the hull shading operations. That is components of GPU may still be configured to send data to and receive data from in the 1 1 interface format of a shading unit designated for vertex shading operations.

GPU may then perform hull shading operations associated with a hull shader stage of a graphics rendering pipeline using the same shading units that performed the vertex shading operations as described above . For example each shading unit may operate on shaded vertices to generate one or more control points which may be used for tessellation.

It should be understood that the steps shown in are provided as merely one example. That is the steps shown in need not necessarily be performed in the order shown and fewer additional or alternative steps may be performed.

In the example of GPU may use the same shading units described above with respect to for performing the operations of . For example to perform Pass II operations the same shading units may first perform domain shading operations associated with a domain shader stage of the graphics rendering pipeline as described above . That is shading units may operate on control points from a hull shader stage to generate domain shaded vertices.

After performing the domain shading operations each of the designated shading units may store the domain shaded vertices to local memory for geometry shading operations . GPU may also change a program counter for tracking hull shading operations as well as change one or more resource pointers to a hull shader resources offset. In examples in which the operations of follow those described with respect to these functions e.g. storing values to local memory changing a program counter changing resource offsets may also be performed prior to step .

In this sense each of the shading units change operational modes to perform domain shading and geometry shading operations. However the mode change does not include re designating the shading units to perform the domain shading and geometry shading operations. That is components of GPU may still be configured to send data to and receive data from in the 1 1 interface format of a hardware shading unit designated for vertex shading operations.

GPU may then perform geometry shading operations associated with a geometry shader stage of a graphics rendering pipeline using the same shading units that performed the domain shading operations as described above . For example each shading unit may operate on domain shaded vertices to generate one or more geometry shaded vertices.

It should be understood that the steps shown in are provided as merely one example. That is the steps shown in need not necessarily be performed in the order shown and fewer additional or alternative steps may be performed.

In the example of GPU may designate one or more hardware shading units e.g. one or more shading units to perform shading operations associated with a first shader stage . In some examples the first shader stage may be a vertex shader stage for generating vertices such that GPU designates one or more shading units to perform vertex shading operations.

Upon completing the operations associated with the first shader stage GPU may switch operational modes allowing the same shading units to perform a variety of other shading operations . For example as described above GPU may change a program counter and one or more resource pointers for performing second shading operations.

In some examples GPU may switch the operational mode of the shading units based on mode information associated with the draw call being executed. For example a driver of GPU such as GPU driver may generate a mode number for a draw call that indicates which shader stages are to be executed in the draw call. GPU may use this mode number to change operational modes of the shading units upon executing a patch code as described above.

Table 8 shown below generally illustrates mode information including mode numbers for a variety of combinations of shader stages.

As shown in Table 8 each mode dictates which shader stages are performed by shading units. Accordingly GPU can string shader instructions together allowing the same shading units to perform multiple shading operations. That is GPU can patch together the appropriate shader instructions based on the mode number of the draw call being executed.

In this way GPU may then perform second shading operations with the same shading units designated to perform the first shading operations . For example GPU may perform a combination of vertex shading operations hull shading operations domain shading operations and geometry shading operations as shown in Table 8 above.

It should be understood that the steps shown in are provided as merely one example. That is the steps shown in need not necessarily be performed in the order shown and fewer additional or alternative steps may be performed.

While certain examples described above include initially designating hardware shading units to perform vertex shading operations and transitioning to performing other shading operations with the same hardware shading units it should be understood that the techniques of this disclosure are not limited in this way. For example a GPU may initially designate a set of hardware shading units to perform a variety of other shading operations. That is in a system that allows GPU to designate hardware shading units to perform three different shading operations GPU may designate hardware shading units to perform vertex shading operations hull shading operations and pixel shading operations. In this example GPU may initially designate one more hardware shading units to perform hull shading operations but may also perform domain shading operations and geometry shading operations with the same hardware shading units as described above. A variety of other operational combinations are also possible.

In one or more examples the functions described may be implemented in hardware software firmware or any combination thereof. If implemented in software the functions may be stored as one or more instructions or code on an article of manufacture comprising a non transitory computer readable medium. Computer readable media may include computer data storage media. Data storage media may be any available media that can be accessed by one or more computers or one or more processors to retrieve instructions code and or data structures for implementation of the techniques described in this disclosure. By way of example and not limitation such computer readable media can comprise RAM ROM EEPROM CD ROM or other optical disk storage magnetic disk storage or other magnetic storage devices flash memory or any other medium that can be used to carry or store desired program code in the form of instructions or data structures and that can be accessed by a computer. Disk and disc as used herein includes compact disc CD laser disc optical disc digital versatile disc DVD floppy disk and blu ray disc where disks usually reproduce data magnetically while discs reproduce data optically with lasers. Combinations of the above should also be included within the scope of computer readable media.

The code may be executed by one or more processors such as one or more DSPs general purpose microprocessors ASICs FPGAs or other equivalent integrated or discrete logic circuitry. In addition in some aspects the functionality described herein may be provided within dedicated hardware and or software modules. Also the techniques could be fully implemented in one or more circuits or logic elements.

The techniques of this disclosure may be implemented in a wide variety of devices or apparatuses including a wireless handset an integrated circuit IC or a set of ICs e.g. a chip set . Various components modules or units are described in this disclosure to emphasize functional aspects of devices configured to perform the disclosed techniques but do not necessarily require realization by different hardware units. Rather as described above various units may be combined in a codec hardware unit or provided by a collection of interoperative hardware units including one or more processors as described above in conjunction with suitable software and or firmware.

Various examples have been described. These and other examples are within the scope of the following claims.

