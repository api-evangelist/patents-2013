---

title: System, method, and computer program product for scheduling tasks associated with continuation thread blocks
abstract: A system, method, and computer program product for scheduling tasks associated with continuation thread blocks. The method includes the steps of generating a first task metadata data structure in a memory, generating a second task metadata data structure in the memory, executing a first task corresponding to the first task metadata data structure in a processor, generating state information representing a continuation task related to the first task and storing the state information in the second task metadata data structure, executing the continuation task in the processor after the one or more child tasks have finished execution, and indicating that the first task has logically finished execution once the continuation task has finished execution. The second task metadata data structure is related to the first task metadata data structure, and at least one instruction in the first task causes one or more child tasks to be executed by the processor.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09256623&OS=09256623&RS=09256623
owner: NVIDIA Corporation
number: 09256623
owner_city: Santa Clara
owner_country: US
publication_date: 20130508
---
This invention was made with Government support under LLNS subcontract B599861 awarded by DOE. The Government has certain rights in this invention.

The present invention relates to task management and more particularly to hardware and software scheduling mechanisms for tasks associated with continuation thread blocks.

Programming tasks are typically implemented by generating a data structure in a memory that includes information associated with instructions and data to be processed by those instructions. Some tasks may be configured to launch child tasks that complete auxiliary work related to the task. The task may be stalled while the child work is completed. The task saves the state related to the task which may be restored at some point in the future once the child task has completed the auxiliary work.

However conventional mechanisms associated with related tasks are not efficient at avoiding deadlock conditions. Sometimes too many child threads may be launched such that resources are starved that don t allow child tasks to finish executing. Too many thread blocks may be active and resident in the processor causing the active tasks to stall on completion of the child tasks which in turn cannot be executed because the active tasks have locked all available resources. Thus there is a need for addressing this issue and or other issues associated with the prior art.

A system method and computer program product for scheduling tasks associated with continuation thread blocks is described. The method includes the steps of generating a first task metadata data structure in a memory generating a second task metadata data structure in the memory executing a first task corresponding to the first task metadata data structure in a processor generating state information representing a continuation task related to the first task and storing the state information in the second task metadata data structure executing the continuation task in the processor after the one or more child tasks have finished execution and indicating that the first task has logically finished execution once the continuation task has finished execution. The second task metadata data structure is related to the first task metadata data structure and at least one instruction in the first task causes one or more child tasks to be executed by the processor.

A hardware scheduling mechanism for a multi threaded processor is described below. The hardware scheduling mechanism provides a means to implement task scheduling including out of order execution of tasks prioritization of tasks and pre emption of tasks. A task is associated with a task metadata data structure that encapsulates the task state necessary for configuring a processing unit to complete some subset of work i.e. a program kernel configured to process data . In one embodiment a central processing unit CPU is coupled to a parallel processing unit PPU and the PPU is configured to execute one or more tasks. The tasks are written to a memory accessible by the PPU by either a device driver executing on the CPU or predecessor tasks executed on the PPU. In order to launch a task on the PPU a method call is sent to the PPU that points to a task metadata data structure in the memory. The PPU then loads the task state defined by the task metadata data structure from the memory and launches the task on a processing unit of the PPU.

At step state information representing a continuation task is generated in the memory and stored in the second task metadata data structure. At step the continuation task is executed by the processor after the one or more child tasks have finished execution. At step once the continuation task has finished executing state information in the first task metadata data structure is modified to indicate that the first task has logically finished execution.

More illustrative information will now be set forth regarding various optional architectures and features with which the foregoing framework may or may not be implemented per the desires of the user. It should be strongly noted that the following information is set forth for illustrative purposes and should not be construed as limiting in any manner. Any of the following features may be optionally incorporated with or without the exclusion of other features described.

In one embodiment the PPU includes an input output I O unit configured to transmit and receive communications i.e. commands data etc. from a central processing unit CPU not shown over the system bus . The I O unit may implement a Peripheral Component Interconnect Express PCIe interface for communications over a PCIe bus. In alternative embodiments the I O unit may implement other types of well known bus interfaces.

The PPU also includes a host interface unit that decodes the commands and transmits the commands to the task management unit or other units of the PPU e.g. memory interface as the commands may specify. The host interface unit is configured to route communications between and among the various logical units of the PPU .

In one embodiment a program encoded as a command stream is written to a buffer by the CPU. The buffer is a region in memory e.g. memory or system memory that is accessible i.e. read write by both the CPU and the PPU . The CPU writes the command stream to the buffer and then transmits a pointer to the start of the command stream to the PPU . The host interface unit provides the task management unit TMU with pointers to one or more streams. The TMU selects one or more streams and is configured to organize the selected streams as a pool of pending grids. The pool of pending grids may include new grids that have not yet been selected for execution and grids that have been partially executed and have been suspended.

A work distribution unit that is coupled between the TMU and the SMs manages a pool of active grids selecting and dispatching active grids for execution by the SMs . Pending grids are transferred to the active grid pool by the TMU when a pending grid is eligible to execute i.e. has no unresolved data dependencies. An active grid is transferred to the pending pool when execution of the active grid is blocked by a dependency. When execution of a grid is completed the grid is removed from the active grid pool by the work distribution unit . In addition to receiving grids from the host interface unit and the work distribution unit the TMU also receives grids that are dynamically generated by the SMs during execution of a grid. These dynamically generated grids join the other pending grids in the pending grid pool.

In one embodiment the CPU executes a driver kernel that implements an application programming interface API that enables one or more applications executing on the CPU to schedule operations for execution on the PPU . An application may include instructions i.e. API calls that cause the driver kernel to generate one or more grids for execution. In one embodiment the PPU implements a SIMD Single Instruction Multiple Data architecture where each thread block i.e. warp in a grid is concurrently executed on a different data set by different threads in the thread block. The driver kernel defines thread blocks that are comprised of k related threads such that threads in the same thread block may exchange data through shared memory. In one embodiment a thread block comprises 32 related threads and a grid is an array of one or more thread blocks that execute the same stream and the different thread blocks may exchange data through global memory. A thread block may also be referred to as a cooperative thread array CTA .

In one embodiment the PPU comprises X SMs X . For example the PPU may include 15 distinct SMs . Each SM is multi threaded and configured to execute a plurality of threads e.g. 32 threads from a particular thread block concurrently. Each of the SMs is connected to a level two L2 cache via a crossbar or other type of interconnect network . The L2 cache is connected to one or more memory interfaces . Memory interfaces implement 16 32 64 128 bit data buses or the like for high speed data transfer. In one embodiment the PPU comprises U memory interfaces U where each memory interface U is connected to a corresponding memory device U . For example PPU may be connected to up to 6 memory devices such as graphics double data rate version 5 synchronous dynamic random access memory GDDR5 SDRAM .

In one embodiment the PPU implements a multi level memory hierarchy. The memory is located off chip in SDRAM coupled to the PPU . Data from the memory may be fetched and stored in the L2 cache which is located on chip and is shared between the various SMs . In one embodiment each of the SMs also implements an L1 cache. The L1 cache is private memory that is dedicated to a particular SM . Each of the L1 caches is coupled to the shared L2 cache . Data from the L2 cache may be fetched and stored in each of the L1 caches for processing in the functional units of the SMs .

In one embodiment the PPU comprises a graphics processing unit GPU . The PPU is configured to receive commands that specify shader programs for processing graphics data. Graphics data may be defined as a set of primitives such as points lines triangles quads triangle strips and the like. Typically a primitive includes data that specifies a number of vertices for the primitive e.g. in a model space coordinate system as well as attributes associated with each vertex of the primitive. The PPU can be configured to process the graphics primitives to generate a frame buffer i.e. pixel data for each of the pixels of the display . The driver kernel implements a graphics processing pipeline such as the graphics processing pipeline defined by the OpenGL API.

An application writes model data for a scene i.e. a collection of vertices and attributes to memory. The model data defines each of the objects that may be visible on a display. The application then makes an API call to the driver kernel that requests the model data to be rendered and displayed. The driver kernel reads the model data and writes commands to the buffer to perform one or more operations to process the model data. The commands may encode different shader programs including one or more of a vertex shader hull shader geometry shader pixel shader etc. For example the TMU may configure one or more SMs to execute a vertex shader program that processes a number of vertices defined by the model data. In one embodiment the TMU may configure different SMs to execute different shader programs concurrently. For example a first subset of SMs may be configured to execute a vertex shader program while a second subset of SMs may be configured to execute a pixel shader program. The first subset of SMs processes vertex data to produce processed vertex data and writes the processed vertex data to the L2 cache and or the memory . After the processed vertex data is rasterized i.e. transformed from three dimensional data into two dimensional data in screen space to produce fragment data the second subset of SMs executes a pixel shader to produce processed fragment data which is then blended with other processed fragment data and written to the frame buffer in memory . The vertex shader program and pixel shader program may execute concurrently processing different data from the same scene in a pipelined fashion until all of the model data for the scene has been rendered to the frame buffer. Then the contents of the frame buffer are transmitted to a display controller for display on a display device.

The PPU may be included in a desktop computer a laptop computer a tablet computer a smart phone e.g. a wireless hand held device personal digital assistant PDA a digital camera a hand held electronic device and the like. In one embodiment the PPU is embodied on a single semiconductor substrate. In another embodiment the PPU is included in a system on a chip SoC along with one or more other logic units such as a reduced instruction set computer RISC CPU a memory management unit MMU a digital to analog converter DAC and the like.

In one embodiment the PPU may be included on a graphics card that includes one or more memory devices such as GDDR5 SDRAM. The graphics card may be configured to interface with a PCIe slot on a motherboard of a desktop computer that includes e.g. a northbridge chipset and a southbridge chipset. In yet another embodiment the PPU may be an integrated graphics processing unit iGPU included in the chipset i.e. Northbridge of the motherboard.

As described above the work distribution unit dispatches active grids for execution on one or more SMs of the PPU . The scheduler unit receives the grids from the work distribution unit and manages instruction scheduling for one or more thread blocks of each active grid. The scheduler unit schedules threads for execution in groups of parallel threads where each group is called a warp. In one embodiment each warp includes 32 threads. The scheduler unit may manage a plurality of different thread blocks allocating the thread blocks to warps for execution and then scheduling instructions from the plurality of different warps on the various functional units i.e. cores DPUs SFUs and LSUs during each clock cycle.

In one embodiment each scheduler unit includes one or more instruction dispatch units . Each dispatch unit is configured to transmit instructions to one or more of the functional units. In the embodiment shown in the scheduler unit includes two dispatch units that enable two different instructions from the same warp to be dispatched during each clock cycle. In alternative embodiments each scheduler unit may include a single dispatch unit or additional dispatch units .

Each SM includes a register file that provides a set of registers for the functional units of the SM . In one embodiment the register file is divided between each of the functional units such that each functional unit is allocated a dedicated portion of the register file . In another embodiment the register file is divided between the different warps being executed by the SM . The register file provides temporary storage for operands connected to the data paths of the functional units.

Each SM comprises L processing cores . In one embodiment the SM includes a large number e.g. 192 etc. of distinct processing cores . Each core is a fully pipelined single precision processing unit that includes a floating point arithmetic logic unit and an integer arithmetic logic unit. In one embodiment the floating point arithmetic logic units implement the IEEE 754 2008 standard for floating point arithmetic. Each SM also comprises M DPUs that implement double precision floating point arithmetic N SFUs that perform special functions e.g. copy rectangle pixel blending operations and the like and P LSUs that implement load and store operations between the shared memory L1 cache and the register file . In one embodiment the SM includes 64 DPUs 32 SFUs and 32 LSUs .

Each SM includes an interconnect network that connects each of the functional units to the register file and the shared memory L1 cache . In one embodiment the interconnect network is a crossbar that can be configured to connect any of the functional units to any of the registers in the register file or the memory locations in shared memory L1 cache .

In one embodiment the SM is implemented within a GPU. In such an embodiment the SM comprises J texture units . The texture units are configured to load texture maps i.e. a 2D array of texels from the memory and sample the texture maps to produce sampled texture values for use in shader programs. The texture units implement texture operations such as anti aliasing operations using mip maps i.e. texture maps of varying levels of detail . In one embodiment the SM includes 16 texture units .

The PPU described above may be configured to perform highly parallel computations much faster than conventional CPUs. Parallel computing has advantages in graphics processing data compression biometrics stream processing algorithms and the like.

In one embodiment the program offset field stores a memory offset for the start of program instructions for the task. The grid dimensions field includes grid dimensions for the grid. A grid is an array of thread blocks generated to implement the program specified by the program offset field on different sets of input data e.g. pixel data corresponding to each thread. The grid may be one dimensional two dimensional three dimensional or n dimensional. In one embodiment the grid dimensions field includes an x dimension a y dimension and a z dimension for the size of a three dimensional grid array. The block dimensions field stores the dimension for each of the thread blocks and is equal to the number of threads included in each thread block e.g. 32 . The resources field includes state information related to hardware resources allocated to the task. For example the resources field may include a location and size of a circular queue implemented in a memory that stores thread blocks to be added to the task. The cache control field includes data associated with configuring the cache. For example the cache control field may include data that specifies what portion of the L1 cache shared memory is configured as a cache and what portion is configured as a shared memory. The cache control field may also specify how much memory is allocated to each thread in a thread block. The memory barriers field may include counters that are configured to manage task dependency. Similarly the semaphores field may include pointers to semaphores that should be released when a task is completed.

The TMD defines in the memory the encapsulated state information necessary to execute a particular task on a processing unit of the PPU . In other words the TMD may be generated in the memory and the fields of the TMD may be filled by software either a device driver or application executing on the CPU or a different task executing on the PPU and then a pointer to the TMD is passed to the TMU in the PPU to indicate that the task is ready to be scheduled. In some system implementations the TMD for a task is written into a system memory i.e. a memory associated with the CPU and then copied to a video memory i.e. memory . One mechanism for copying the task to the video memory involves transmitting packets of data from the system memory to the PPU via the system bus . The PPU then uses various hardware engines to store the data in the video memory. Once the PPU is ready to schedule the task the TMD or at least portions of the TMD is read from the video memory into on chip memory structures accessible by the TMU and or the SMs .

In one embodiment the TMD includes a pending counter field . The pending counter field holds an integer value that indicates how many other pending actions must be completed before the task associated with the TMD is logically complete. In other words another related task may be executing that prevents the task associated with the TMD from finishing. When a TMD is initiated the pending counter field may be initially set to one 1 that indicates that the TMD will be logically complete when the grid of CTAs associated with the task corresponding to the TMD has finished executing. In modern parallel processing architectures tasks executing on the processor may be able to spawn one or more child tasks. For example instructions in a CTA referenced by the TMD may generate a new TMD corresponding to a child task in the memory . The child task may generate e.g. an intermediate value for use by one or more instructions in the CTA referenced by the TMD . For example the child task may sample an image to find an average value for the pixel colors in the image. The parent task may use this intermediate value for another calculation. The parent task may execute up to a point where the intermediate value is going to be calculated by a child task. The parent task then generates a TMD in memory corresponding to the child task and launches the child task. The parent task may then increment the pending counter field to indicate that the child task needs to finish as well as the parent task before the parent task is logically complete. The parent task may then be evicted from the processor until the child task has finished executing. Once the child task has finished executing the pending counter field of the TMD is decremented to indicate that the child task has finished and the parent task can then logically finish once any other instructions or child tasks have completed execution. A more detailed explanation of the use of the pending counter field in relation to generating new tasks is set forth below in conjunction with .

As shown in the TMD may also include an output dependence field . The output dependence field is a pointer to a TMD for a different task that is dependent on the completion of the task associated with the TMD for execution. In one embodiment the TMU is configured to decrement a reference counter field not explicitly shown in that indicates whether the task corresponding to the TMD is dependent on the completion of any predecessor tasks before the task may be executed. Once the reference counter field in the TMD is decremented to zero 0 then the task may be scheduled and launched by the TMU and the WDU respectively.

In one embodiment the parent task may initialize a continuation task that includes the work from the parent task that is executed after the child tasks have completed execution. As shown in the continuation task may be associated with a second TMD i.e. QUEUE TMD that is similar to the first TMD . However unlike the first TMD the second TMD corresponds to a special type of task which can receive additional CTAs for execution after the task has been launched. In other words the size or dimensions of the QUEUE TMD are not necessarily specified before the task is launched. The special type of task may be referred to herein as a queue task. In addition to the second TMD the queue task is also associated with a circular FIFO i.e. queue that is stored in memory . The queue holds a plurality of entries that include pointers to CTAs associated with the task. Unlike the first TMD that includes pointers to a grid of CTAs that are fully defined in the memory when the parent task is launched the second TMD includes a pointer to the queue that may or may not include pointers to one or more CTAs when the continuation task is launched.

In one embodiment when a logical task is generated by software the software generates both a grid TMD and a queue TMD in memory . The grid TMD may store the state associated with a defined grid of CTAs for the task. The queue TMD is generated to store continuation work that is to be completed after one or more child tasks have been launched and returned intermediate values to be processed by the parent task. The queue may also be generated in the memory which provides a place for the threads in the parent task to insert CTAs that represent the work that needs to be restored when the one or more child tasks have been completed. In another embodiment the grid TMD may be initialized and launched and the queue TMD is only initialized once the task corresponding to the grid TMD has reached an instruction to spawn a child task.

As the threads of a CTA in the parent task execute the threads may come to a set of instructions that are configured to generate one or more child tasks to perform some intermediate work. The threads generate the one or more child tasks by initializing additional TMDs not shown in in the memory . Then the threads in the CTA in the parent task may generate new CTAs to be added to the queue TMD . The threads may create a new CTA in memory and add a pointer to the new CTA to the queue . The new CTAs represent the work to be restored from the CTAs in the parent task once the child tasks have been executed. In other words the new CTAs include the instructions from the original CTAs that would be executed after the child tasks have been completed. The pointers are stored in the entries e.g. of the queue . Once the CTA in the parent task has completed these tasks the parent task may be evicted from the SM . It will be appreciated that multiple CTAs in the grid of the parent task may spawn different child tasks and may generate associated new CTAs that are added to the queue .

When each of the CTAs in the grid TMD have finished executing and have spawned the one or more child tasks the task associated with the grid TMD is complete and evicted from the SM . However the logical task i.e. the work encompassing the instructions to be executed after the child tasks have completed execution is not complete and therefore the semaphores i.e. the one or more semaphores referenced by the semaphores field in the grid TMD for the parent task should not be released. In order to prevent the TMU from releasing the semaphores the TMU is configured to clean up the task and release any semaphores only once the pending counter field for the grid TMD reaches zero. When the task associated with the grid TMD is evicted from the SM the TMU decrements the value in the pending counter field by one. However when a thread block associated with the parent task generates a continuation thread block that is added to the queue the pending counter field in the grid TMD is incremented by one. Therefore the value in the pending counter field in the grid TMD is incremented from one to two. Alternatively the thread block may generate a message that is passed to the TMU that causes the TMU to increment the pending counter field in the grid TMD by one. Therefore when the grid TMD is evicted from the SM the TMU will decrement the pending counter field to a value that is greater than zero as long as there is still pending work associated with the corresponding queue TMD waiting on results returned from the one or more child tasks. When the grid TMD is evicted from the SM the value in the pending counter field in the grid TMD is decremented from a value of two to one.

In one embodiment the CTAs associated with the parent task may generate instructions included in the continuation thread blocks that when executed by the SM cause the pending counter field of the grid TMD to be decremented by one. Thus when each continuation thread block is added to the queue the pending counter field of the grid TMD is incremented and when each continuation thread block has completed execution within the SM the pending counter field of the grid TMD is decremented. In another embodiment the pending counter field of the grid TMD is incremented only one time when one or more continuation thread blocks are added to the queue . The last CTA added to the queue includes instructions for decrementing the pending counter field of the grid TMD . Thus instead of incrementing the pending counter field for the grid TMD once per each continuation thread block and decrementing the pending counter field for the grid TMD when each continuation thread block has finished executing the pending counter field is only incremented and decremented one time when continuation work is added to the queue and when all continuation work has finished execution i.e. when the task associated with the queue TMD is finished executing .

As also shown in one or more of the child tasks may be implemented as part of a stream. A stream is a sequential ordering of dependent tasks. For example grid TMD corresponds to a first task in the stream and grid TMD corresponds to a second task in the stream. The second task is dependent on the first task. In other words the first task must finish executing before the second task can be launched. In one embodiment the TMU manages dependencies between tasks using streams. Each TMD may include an output dependence field that stores a pointer to a dependent task. Similar to the pending counter field which prevents a task from logical completion until the pending counter field reaches zero each TMD may also include an input dependence field not explicitly shown that includes a counter that must be zero before a task can be launched. For example when a task is created the input dependence field may be initialized to one to indicate that software is preventing the task from launch until software has finished initializing the state information in the TMD in memory . The input dependence field can also be incremented one time for each action that must be completed before the task may be launched. For example the second task in the stream i.e. the task corresponding to grid TMD may include an input dependence field initialized to two one for a software hold that prevents the task from being launched until software has completely filled out the grid TMD and one for a hardware hold that prevents the task from being launched until the first task in the stream i.e. the task corresponding to the grid TMD has completed execution. The output dependence field of the grid TMD corresponding to the first task in the stream includes a pointer to the grid TMD corresponding to the second task in the stream that causes the TMU to decrement the input dependence field of the grid TMD corresponding to the second task in the stream when the first task in the stream has completed execution. If no other tasks are dependent upon the completion of the execution of a task then the output dependence field in the TMD corresponding to the task may include a null pointer.

In one embodiment the task associated with the EOC TMD is launched on an SM and one or more instructions are executed related to finishing execution of all of the child tasks. For example the one or more instructions may perform some memory resource cleanup operations deallocating the memory used for the TMDs corresponding to the child tasks. In another embodiment the task associated with the EOC TMD may be completely executed by the TMU and the task is never launched on an SM .

As shown in when the task associated with the EOC TMD is finished executing the TMU decrements the input dependence field in the TMD pointed to by the pointer in the output dependence field of the EOC TMD . The output dependence field of the EOC TMD may point to the queue TMD that represents the continuation thread blocks generated by the thread blocks of the parent task. When the TMU decrements the input dependence field of the queue TMD the value of the input dependence field may go to zero thereby allowing the TMU to launch the CTAs in the queue on the SMs and completing the execution of the logical task that encompasses both the parent task and the continuation task.

At step an input dependence field in the third task metadata data structure is incremented for each child task in the one or more child tasks. At step an output dependence field in the task metadata data structures for each of the one or more child tasks is modified to include a pointer to the third task metadata data structure. At step a pointer to the second task metadata data structure e.g. queue TMD is stored in an output dependence field of the third task metadata data structure e.g. the EOC TMD . In addition an input dependence field in the second task metadata structure is incremented by one. At step an input dependence field in the second task metadata data structure e.g. the queue TMD is decremented after the one or more child tasks have finished execution. In other words when each of the child tasks has finished executing the task corresponding to the EOC TMD may be launched which causes the input dependence field of the queue TMD to be decremented. As the input dependence field of the queue TMD reaches zero the continuation task may be launched at step described above. The method then proceeds to step as set forth above in conjunction with .

It will be appreciated that the use of incremented and decremented are interchangeable in alternative embodiments. For example a specific value other than zero may be used to determine when tasks can be launched such as 1000. Then when child tasks are generated the value may be decremented e.g. from 999 to 998 . When child tasks complete execution the value may be incremented e.g. from 999 to 1000 . Thus incremented as used herein may mean adding one to a value or subtracting one from the value and decremented may mean the opposite of incremented i.e. subtracting one to a value or adding one to the value respectively .

The system also includes input devices a graphics processor and a display i.e. a conventional CRT cathode ray tube LCD liquid crystal display LED light emitting diode plasma display or the like. User input may be received from the input devices e.g. keyboard mouse touchpad microphone and the like. In one embodiment the graphics processor may include a plurality of shader modules a rasterization module etc. Each of the foregoing modules may even be situated on a single semiconductor platform to form a graphics processing unit GPU . Techniques for scheduling continuation thread blocks described above may be implemented on the graphics processor of .

In the present description a single semiconductor platform may refer to a sole unitary semiconductor based integrated circuit or chip. It should be noted that the term single semiconductor platform may also refer to multi chip modules with increased connectivity which simulate on chip operation and make substantial improvements over utilizing a conventional central processing unit CPU and bus implementation. Of course the various modules may also be situated separately or in various combinations of semiconductor platforms per the desires of the user.

The system may also include a secondary storage . The secondary storage includes for example a hard disk drive and or a removable storage drive representing a floppy disk drive a magnetic tape drive a compact disk drive digital versatile disk DVD drive recording device universal serial bus USB flash memory. The removable storage drive reads from and or writes to a removable storage unit in a well known manner.

Computer programs or computer control logic algorithms may be stored in the main memory and or the secondary storage . Such computer programs when executed enable the system to perform various functions. The memory the storage and or any other storage are possible examples of computer readable media.

In one embodiment the architecture and or functionality of the various previous figures may be implemented in the context of the central processor the graphics processor an integrated circuit not shown that is capable of at least a portion of the capabilities of both the central processor and the graphics processor a chipset i.e. a group of integrated circuits designed to work and sold as a unit for performing related functions etc. and or any other integrated circuit for that matter.

Still yet the architecture and or functionality of the various previous figures may be implemented in the context of a general computer system a circuit board system a game console system dedicated for entertainment purposes an application specific system and or any other desired system. For example the system may take the form of a desktop computer laptop computer server workstation game consoles embedded system and or any other type of logic. Still yet the system may take the form of various other devices including but not limited to a personal digital assistant PDA device a mobile phone device a television etc.

Further while not shown the system may be coupled to a network e.g. a telecommunications network local area network LAN wireless network wide area network WAN such as the Internet peer to peer network cable network or the like for communication purposes.

While various embodiments have been described above it should be understood that they have been presented by way of example only and not limitation. Thus the breadth and scope of a preferred embodiment should not be limited by any of the above described exemplary embodiments but should be defined only in accordance with the following claims and their equivalents.

