---

title: Code analysis for simulation efficiency improvement
abstract: A computer program product and computer system for analyzing code to improve efficiency of simulating a hardware system. A computer identifies one or more functions calling an application programming interface of a hardware simulator simulating the hardware system. In response to determining that left hand sides of respective one or more Boolean expressions are associated with the one or more functions calling the application programming interface and right hand sides are not associated with the one or more functions calling the application programming interface, the computer identifies the respective one or more Boolean expressions as one or more improvement points in source code for verifying a hardware model of the hardware system.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09069574&OS=09069574&RS=09069574
owner: International Business Machines Corporation
number: 09069574
owner_city: Armonk
owner_country: US
publication_date: 20131211
---
This application is a Continuation Application of pending U.S. patent application Ser. No. 13 782 119 filed on Mar. 1 2013.

The present invention relates generally to simulation of computer hardware systems and more particularly to code analysis for improving simulation efficiency.

Simulation of hardware models is a high performance application which has many long runs on a computer system or a computer cluster. Code execution time is critical to the high performance application. The simulation includes the time to simulate the hardware i.e. hardware execution and the time to drive and validate the hardware i.e. simulation environment execution . Simulation environments are usually written in programming languages e.g. C . In the computer languages known compiler optimization can be applied. Even though the simulation environments are optimized through the known compiler optimization the simulation of hardware models wastes a lot of time in the simulation environments.

Embodiments of the present invention provide a computer program product and computer system for analyzing code to improve efficiency of simulating a hardware system. A computer identifies one or more functions calling an application programming interface of a hardware simulator simulating the hardware system. The computer identifies respective one or more Boolean expressions as one or more improvement points in source code for verifying a hardware model of the hardware system in response to determining that left hand sides of the respective one or more Boolean expression are associated with the one or more functions calling the application programming interface and in response to determining that right hand sides of the respective one or more Boolean expressions are not associated with the one or more functions calling the application programming interface.

As will be appreciated by one skilled in the art aspects of the present invention may be embodied as a system method or computer program product. Accordingly aspects of the present invention may take the form of an entirely hardware embodiment an entirely software embodiment including firmware resident software micro code etc. or an embodiment combining software and hardware aspects that may all generally be referred to herein as a circuit module or system. Furthermore aspects of the present invention may take the form of a computer program product embodied in one or more computer readable medium s having computer readable program code embodied thereon.

Any combination of one or more computer readable medium s may be utilized. A computer readable storage medium may be for example but not limited to an electronic magnetic optical electromagnetic infrared or semiconductor system apparatus or device or any suitable combination of the foregoing. More specific examples a non exhaustive list of the computer readable storage medium would include the following an electrical connection having one or more wires a portable computer diskette a hard disk a random access memory RAM a read only memory ROM an erasable programmable read only memory EPROM or Flash memory an optical fiber a portable compact disc read only memory CD ROM an optical storage device a magnetic storage device or any suitable combination of the foregoing. In the context of this document a computer readable storage medium may be any tangible medium that can contain or store a program for use by or in connection with an instruction execution system apparatus or device. The term of computer readable storage medium or one or more computer readable tangible storage devices as used in this document is not to be construed as being transitory signals per se such as radio waves or other freely propagating electromagnetic waves electromagnetic waves propagating through a waveguide or other transmission media e.g. light pulses passing through a fiber optic cable or electrical signals transmitted through a wire.

Program code embodied on a computer readable medium may be transmitted using any appropriate medium including but not limited to wireless wireline optical fiber cable RF etc. or any suitable combination of the foregoing.

Computer program code for carrying out operations for aspects of the present invention may be written in any combination of one or more programming languages including an object oriented programming language such as Java Smalltalk C or the like and conventional procedural programming languages such as the C programming language or similar programming languages. The program code may execute entirely on the user s computer partly on the user s computer as a stand alone software package partly on the user s computer and partly on a remote computer or entirely on the remote computer or server. In the latter scenario the remote computer may be connected to the user s computer through any type of network including a local area network LAN or a wide area network WAN or the connection may be made to an external computer for example through the Internet using an Internet Service Provider .

Aspects of the present invention are described below with reference to flowchart illustrations and or block diagrams of methods apparatus systems and computer program products according to embodiments of the invention. It will be understood that each block of the flowchart illustrations and or block diagrams and combinations of blocks in the flowchart illustrations and or block diagrams can be implemented by computer program instructions. These computer program instructions may be provided to a processor of a general purpose computer special purpose computer or other programmable data processing apparatus to produce a machine such that the instructions which execute via the processor of the computer or other programmable data processing apparatus create means for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

These computer program instructions may also be stored in a computer readable medium that can direct a computer other programmable data processing apparatus or other devices to function in a particular manner such that the instructions stored in the computer readable medium produce an article of manufacture including instructions which implement the function act specified in the flowchart and or block diagram block or blocks.

The computer program instructions may also be loaded onto a computer other programmable data processing apparatus or other devices to cause a series of operational steps to be performed on the computer other programmable apparatus or other devices to produce a computer implemented process such that the instructions which execute on the computer or other programmable apparatus provide processes for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

Referring to verification code calls functions implemented within verification code . Verification code calls functions in simulation middle layer API . There are function calls from verification code through simulation middle layer API to all other layers namely simulator low level API hardware simulator and hardware model . The present invention is to identify improvement points in the source code of verification code so as to avoid unnecessary function calls from verification code through simulation middle layer API to the all other layers. Therefore the present invention provides a method computer program product and computer system for improving efficiency of simulating a hardware system.

At step code analysis program tags the functions calling the functions of simulator low level API . indicates that by highlighting with hatching the functions calling the functions of simulator low level API is tagged. In this example function get32 is tagged because it calls function is Shadowed function getShadowValue and function getHwValue of simulator low level API . At step code analysis program adds information about the functions calling the functions of simulator low level API to database .

At step code analysis program creates abstract syntax trees of source code of verification code . An abstract syntax tree is a tree representation of the abstract syntactic structure of source code written in a programming language. Each node of the abstract syntax tree denotes a construct occurring in the source code. For each function in verification code code analysis program creates an abstract syntax tree. Therefore a plurality of the abstract syntax trees is generated for verification code . A and A show exemplary segments of the abstract syntax trees. shows an assignment v get32 in the abstract syntax trees shows an expression if get32 c 1 . . . in the abstract syntax trees and shows an expression if v c 5 . . . in the abstract syntax trees.

At step code analysis program identifies in the abstract syntax trees symbols associated with the functions calling the functions of simulator low level API . Step is described in great detail in later paragraphs with reference to .

At step code analysis program by analyzing the abstract syntax trees identifies improvement points in the source code of verification code . Step is described in great detail in later paragraphs with reference to . At step code analysis program provides report of code locations of potentially inefficient code structure in verification code .

An abstract syntax tree has a plurality of nodes and each of the nodes has an attribute. In the exemplary embodiment for a node that is a symbol associated with simulation middle layer functions calling simulator low level API functions code analysis program sets the attribute to 1 for a node that is not a symbol associated with simulation middle layer functions calling simulator low level API functions code analysis program sets the attribute to 0. In analyzing the abstract syntax tree in the exemplary embodiment code analysis program sets initial attributes for the respective nodes to 0. In the exemplary embodiment analyzing the abstract syntax tree is started with a root node thereof.

Referring to at step a decision block code analysis program determines whether a root node in an abstract syntax tree a first abstract syntax tree has one or more child nodes. In response to determining that the root node of the abstract syntax tree has one or more child nodes YES branch of step at step a decision block code analysis program determines whether the root node is an assignment. In response to determining that the root node is not an assignment NO branch of step at step code analysis program determines whether the attribute of one of the one or more child nodes is equal to 1. At step code analysis program makes a recursive call to step for each of the one or more child nodes after setting the each of the one or more child nodes as the root node. In response to determining that the attribute of one of the one or more child nodes is equal to 1 YES branch of step at step code analysis program sets the attribute of the root node to 1.

Referring to in response to determining that the root node is an assignment YES branch of step at step a decision block code analysis program determines whether the attribute of a right hand side RHS node of the assignment is equal to 1. At step code analysis program makes a recursive call to step for each of one or more child nodes of the right hand side RHS node after setting the each of the one or more child nodes of the right hand side RHS node as the root node. In response to determining that the attribute of the right hand side RHS node of the assignment is equal to 1 YES branch of step at step code analysis program sets the attribute of the root node to 1. And next at step code analysis program sets the attribute of a left hand side LHS node of the assignment to 1.

Referring to in response to determining that the root node does not have the one or more child nodes NO branch of step at step a decision block code analysis program determines whether the root node is a call to a called function. In response to determining that the root node is a call to a called function YES branch of step at step a decision block code analysis program determines whether the root node is in database . In response to determining that the root node is in database YES branch of step code analysis program at step sets the attribute of the root node to 1. In response to determining that the root node is not in database NO branch of step at step a decision block code analysis program determines whether the attribute of a root node of an abstract syntax tree of the called function a second abstract syntax tree is equal to 1. At step code analysis program makes a recursive call to step for the abstract syntax tree of the called function. In response to determining that the attribute of the root node of the abstract syntax tree of the called function the root node of the second abstract syntax tree is equal to 1 YES branch of step at step code analysis program sets the attribute of the root node of the first abstract syntax tree to 1. At step code analysis program sets the attribute of a referenced variable in the first abstract syntax tree to the attribute of a referencing variable in the second abstract syntax tree. If the attribute of the referencing variable in the abstract syntax tree of the called function the second abstract syntax tree is equal to 1 then the attribute of the referenced variable corresponding to the referencing variable is set to 1.

To present examples of the operational steps shown in B and B show examples of identifying in the exemplary segments of abstract syntax trees shown in A and A the symbols associated with simulation middle layer functions calling simulator low level API functions in accordance with an exemplary embodiment of the present invention. In node get32 is a node without child nodes and it is a function in simulation middle layer API and calls simulator low level API . Code analysis program identifies node get32 to be one of the symbols according to steps and . In node func has a child node node get32 . Code analysis program identifies node func to be one of the symbols and sets its attribute to 1 according to steps and . In node is an assignment. Code analysis program identifies node to be one of the symbols and sets its attribute to 1 according to steps and then code analysis program identifies left hand side LHS node v to be one of the symbols and sets its attribute to 1 at step . All nodes identified to be the symbols attributes equal to 1 are highlighted by hatching in .

Code analysis program identifies nodes get32 and func in to be the symbols which are highlighted by hatching in . Code analysis program identifies node in A to be one of the symbols and sets the attribute to 1 according to steps and . In B node is highlighted by hatching. Code analysis program identifies node expr in A to be one of the symbols and sets the attribute to 1 according to steps and . In B node expr is highlighted by hatching.

In node v is a node without any child nodes. Code analysis program identifies node v in A to be one of the symbols and sets the attribute to 1 according to steps and . In analyzing node v code analysis program makes a recursive call with the abstract syntax tree of node v shown in . Code analysis program identifies respectively nodes and expr in A to be the symbols and sets their attributes to 1 according to steps and . Nodes v and expr attributes equal to 1 are highlighted by hatching in .

Referring to at step code analysis program finds a Boolean expression with a binary Boolean operator in abstract syntax trees. and A show examples of the Boolean expression with a binary Boolean operator. At step a decision block code analysis program determines whether a variable or a function on the left hand side LHS of the Boolean expression calls functions of simulator low level API through calling functions in simulation middle layer API .

In response to determining that the variable or the function on the left hand side LHS of the Boolean expression calls the functions of simulator low level API through calling functions in simulation middle layer API YES branch of step at step a decision block code analysis program determines whether a variable or a function on the right hand side RHS of the Boolean expression calls functions of simulator low level API through calling functions in simulation middle layer API .

In response to determining that the variable or the function on the left hand side LHS of the Boolean expression does not call functions of simulator low level API through calling functions in simulation middle layer API NO branch of step code analysis program moves to step which is discussed in a later paragraph. If the variable or the function on the left hand side LHS of the Boolean expression does not call functions of simulator low level API through calling functions in simulation middle layer API the Boolean expression is not an improvement point.

In response to determining that the variable or the function on the right hand side RHS of the Boolean expression does not call functions of simulator low level API through calling functions in simulation middle layer API NO branch of step at step code analysis program identifies the Boolean expression to be an improvement point.

In response to determining that the variable or the function on the right hand side RHS of the Boolean expression calls functions of simulator low level API through calling functions in simulation middle layer API YES branch of step code analysis program moves to step which is discussed in a later paragraph. If the variable or the function on the right hand side RHS of the Boolean expression calls simulator low level API through calling functions in simulation middle layer API the Boolean expression is not an improvement point.

After step or after determining that the variable or the function on the left hand side LHS of the Boolean expression does not call simulator low level API through calling functions in simulation middle layer API NO branch of step or after determining that the variable or the function on the right hand side RHS of the Boolean expression calls simulator low level API through calling functions in simulation middle layer API YES branch of step code analysis program at step a decision block determines whether all Boolean expressions in the abstract syntax trees are analyzed. In response to determining that the all Boolean expressions in the abstract syntax trees are analyzed YES branch of step code analysis program terminates its operation. In response to determining that not all Boolean expressions in the abstract syntax trees are analyzed NO branch of step code analysis program goes back to step .

For example the variable or the function on the left side hand LHS of the Boolean expression shown in or A calls the functions of simulator low level API through calling functions in simulation middle layer API as shown in or B the variable or the function on the right side hand RHS of the Boolean expression shown in or A does not call simulator low level API through calling functions in simulation middle layer API as shown in or B . Therefore code analysis program will identify that Boolean expressions shown in and A are improvement points in source code of verification code .

Referring to the computer device includes communications fabric which provides communications among processor s memory tangible storage device s network interface s and I O input output interface s . Memory includes ROM s Read Only Memory RAM s Random Access Memory and cache s .

One or more operating system s resides on one or more computer readable tangible storage device s . In the exemplary embodiment code analysis program database and report resides on one or more computer readable tangible storage device s of the computer device. In the exemplary embodiment verification code is loaded onto one or more computer readable tangible storage device s of the computer device.

The computer device further includes I O interface s . I O interface s allow for input and output of data with external device s that may be connected to the computer device. The computer device further includes network interface s for communications between the computer device and a computer network.

The flowchart and block diagrams in the Figures illustrate the architecture functionality and operation of possible implementations of systems methods and computer program products according to various embodiments of the present invention. In this regard each block in the flowchart or block diagrams may represent a module segment or portion of code which comprises one or more executable instructions for implementing the specified logical function s . It should also be noted that in some alternative implementations the functions noted in the block may occur out of the order noted in the figures. For example two blocks shown in succession may in fact be executed substantially concurrently or the blocks may sometimes be executed in the reverse order depending upon the functionality involved. It will also be noted that each block of the block diagrams and or flowchart illustration and combinations of blocks in the block diagrams and or flowchart illustration can be implemented by special purpose hardware based systems that perform the specified functions or acts or combinations of special purpose hardware and computer instructions.

