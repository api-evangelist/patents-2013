---

title: Primitive re-ordering between world-space and screen-space pipelines with buffer limited processing
abstract: One embodiment of the present invention includes approaches for processing graphics primitives associated with cache tiles when rendering an image. A set of graphics primitives associated with a first render target configuration is received from a first portion of a graphics processing pipeline, and the set of graphics primitives is stored in a memory. A condition is detected indicating that the set of graphics primitives is ready for processing, and a cache tile is selected that intersects at least one graphics primitive in the set of graphics primitives. At least one graphics primitive in the set of graphics primitives that intersects the cache tile is transmitted to a second portion of the graphics processing pipeline for processing. One advantage of the disclosed embodiments is that graphics primitives and associated data are more likely to remain stored on-chip during cache tile rendering, thereby reducing power consumption and improving rendering performance.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08704826&OS=08704826&RS=08704826
owner: Nvidia Corporation
number: 08704826
owner_city: Santa Clara
owner_country: US
publication_date: 20130910
---
This application claims benefit of U.S. provisional patent application Ser. No. 61 719 271 filed Oct. 26 2012 and titled An Approach for Tiled Caching. The subject matter of this related application is hereby incorporated herein by reference.

Embodiments of the present invention relate generally to graphics processing and more specifically to primitive re ordering between world space and screen space pipelines with buffer limited processing.

Some graphics subsystems for rendering graphics images implement a tiling architecture where one or more render targets such as a frame buffer are divided into screen space partitions referred to as tiles. In such a tiling architecture the graphics subsystem rearranges work such that the work associated with any particular tile remains in an on chip cache for a longer time than with an architecture that does not rearrange work in this manner. This rearrangement helps to improve memory bandwidth as compared with a non tiling architecture.

Typically the set of render targets changes over time as the rendering of the image progresses. For example a first pass could use a first configuration of render targets to partially render the image. A second pass could use a second configuration of render targets to further render image. A third pass could use a third set of render targets to complete the final rendering of the image. During the rendering process the computer graphics subsystem could use any number of different render target configurations to render the final image.

For each render target configuration graphics objects are first processed in a world space pipeline. The world space pipeline creates graphics primitives associated with the graphics objects. The graphics primitives are created and transmitted by the world space pipeline without regard to the position of the graphics primitives in the screen surface represented by the render targets. The graphics subsystem rearranges the graphics primitives into tile order where each tile represents a portion of the screen surface. The rearranged graphics primitives are then processed by the screen space pipeline while maintaining application programming interface API order.

Although memory allocated for storing tiles is generally designed to hold all the needed graphics primitives for a given render target configuration certain conditions may cause this tile memory to run out of space. For example a particular tile could include a large number of very small primitives such as when one or more graphics objects are finely tessellated. In such cases the tiling memory could fill with graphics primitives before the entire image is processed in the world space pipeline. In addition other data associated with the graphics primitives such as vertex attribute data may be stored in a general purpose cache. In certain cases the cache may fill with vertex attribute data or other data associated with the graphics primitives causing the graphics primitives to be evicted from the tiling memory and the vertex data or other data associated with the graphics primitives to be evicted from the cache. Such evicted data may be written to frame buffer memory and later retrieved.

One drawback to the above approach is that the frame buffer memory is generally off chip whereas the tiling memory and cache memory are generally on chip. Off chip memory accesses typically consume more power and take longer to complete. Such increased power consumption may result in shorter battery life particularly for graphics subsystems placed in mobile devices. In addition as off chip accesses to frame buffer memory increase rendering time increases resulting in lower graphics performance and reduced visual experience.

As the foregoing illustrates what is needed in the art is a technique for reducing off chip memory accessed in graphics subsystem that employs tiling architectures.

One embodiment of the present invention sets forth a method for processing graphics primitives associated with one or more cache tiles when rendering an image. The method includes receiving a set of graphics primitives associated with a first render target configuration from a first portion of a graphics processing pipeline and storing the set of graphics primitives in a first memory. The method further includes detecting a condition indicating that the set of graphics primitives is ready for processing and selecting a cache tile that intersects at least one graphics primitive in the set of graphics primitives. The method further includes transmitting at least one graphics primitive in the set of graphics primitives that intersects the cache tile to a second portion of the graphics processing pipeline for processing.

Other embodiments include without limitation a computer readable medium that includes instructions that enable a processing unit to implement one or more aspects of the disclosed methods. Other embodiments include without limitation a subsystem that includes a processing unit configured to implement one or more aspects of the disclosed methods as well as a computing device configured to implement one or more aspects of the disclosed methods.

One advantage of the disclosed approach is that graphics primitives and associated data are more likely to remain stored on chip during cache tile rendering thereby reducing power consumption and improving rendering performance.

In the following description numerous specific details are set forth to provide a more thorough understanding of the present invention. However it will be apparent to one of skill in the art that the present invention may be practiced without one or more of these specific details.

In operation I O bridge is configured to receive user input information from input devices such as a keyboard or a mouse and forward the input information to CPU for processing via communication path and memory bridge . Switch is configured to provide connections between I O bridge and other components of the computer system such as a network adapter and various add in cards and .

As also shown I O bridge is coupled to a system disk that may be configured to store content and applications and data for use by CPU and parallel processing subsystem . As a general matter system disk provides non volatile storage for applications and data and may include fixed or removable hard disk drives flash memory devices and CD ROM compact disc read only memory DVD ROM digital versatile disc ROM Blu ray HD DVD high definition DVD or other magnetic optical or solid state storage devices. Finally although not explicitly shown other components such as universal serial bus or other port connections compact disc drives digital versatile disc drives film recording devices and the like may be connected to I O bridge as well.

In various embodiments memory bridge may be a Northbridge chip and I O bridge may be a Southbridge chip. In addition communication paths and as well as other communication paths within computer system may be implemented using any technically suitable protocols including without limitation AGP Accelerated Graphics Port HyperTransport or any other bus or point to point communication protocol known in the art.

In some embodiments parallel processing subsystem comprises a graphics subsystem that delivers pixels to a display device that may be any conventional cathode ray tube liquid crystal display light emitting diode display or the like. In such embodiments the parallel processing subsystem incorporates circuitry optimized for graphics and video processing including for example video output circuitry. As described in greater detail below in such circuitry may be incorporated across one or more parallel processing units PPUs included within parallel processing subsystem . In other embodiments the parallel processing subsystem incorporates circuitry optimized for general purpose and or compute processing. Again such circuitry may be incorporated across one or more PPUs included within parallel processing subsystem that are configured to perform such general purpose and or compute operations. In yet other embodiments the one or more PPUs included within parallel processing subsystem may be configured to perform graphics processing general purpose processing and compute processing operations. System memory includes at least one device driver configured to manage the processing operations of the one or more PPUs within parallel processing subsystem .

In various embodiments parallel processing subsystem may be integrated with one or more other the other elements of to form a single system. For example parallel processing subsystem may be integrated with CPU and other connection circuitry on a single chip to form a system on chip SoC .

It will be appreciated that the system shown herein is illustrative and that variations and modifications are possible. The connection topology including the number and arrangement of bridges the number of CPUs and the number of parallel processing subsystems may be modified as desired. For example in some embodiments system memory could be connected to CPU directly rather than through memory bridge and other devices would communicate with system memory via memory bridge and CPU . In other alternative topologies parallel processing subsystem may be connected to I O bridge or directly to CPU rather than to memory bridge . In still other embodiments I O bridge and memory bridge may be integrated into a single chip instead of existing as one or more discrete devices. Lastly in certain embodiments one or more components shown in may not be present. For example switch could be eliminated and network adapter and add in cards would connect directly to I O bridge .

In some embodiments PPU comprises a graphics processing unit GPU that may be configured to implement a graphics rendering pipeline to perform various operations related to generating pixel data based on graphics data supplied by CPU and or system memory . When processing graphics data PP memory can be used as graphics memory that stores one or more conventional frame buffers and if needed one or more other render targets as well. Among other things PP memory may be used to store and update pixel data and deliver final pixel data or display frames to display device for display. In some embodiments PPU also may be configured for general purpose processing and compute operations.

In operation CPU is the master processor of computer system controlling and coordinating operations of other system components. In particular CPU issues commands that control the operation of PPU . In some embodiments CPU writes a stream of commands for PPU to a data structure not explicitly shown in either or that may be located in system memory PP memory or another storage location accessible to both CPU and PPU . A pointer to the data structure is written to a pushbuffer to initiate processing of the stream of commands in the data structure. The PPU reads command streams from the pushbuffer and then executes commands asynchronously relative to the operation of CPU . In embodiments where multiple pushbuffers are generated execution priorities may be specified for each pushbuffer by an application program via device driver to control scheduling of the different pushbuffers.

As also shown PPU includes an I O input output unit that communicates with the rest of computer system via the communication path and memory bridge . I O unit generates packets or other signals for transmission on communication path and also receives all incoming packets or other signals from communication path directing the incoming packets to appropriate components of PPU . For example commands related to processing tasks may be directed to a host interface while commands related to memory operations e.g. reading from or writing to PP memory may be directed to a crossbar unit . Host interface reads each pushbuffer and transmits the command stream stored in the pushbuffer to a front end .

As mentioned above in conjunction with the connection of PPU to the rest of computer system may be varied. In some embodiments parallel processing subsystem which includes at least one PPU is implemented as an add in card that can be inserted into an expansion slot of computer system . In other embodiments PPU can be integrated on a single chip with a bus bridge such as memory bridge or I O bridge . Again in still other embodiments some or all of the elements of PPU may be included along with CPU in a single integrated circuit or system of chip SoC .

In operation front end transmits processing tasks received from host interface to a work distribution unit not shown within task work unit . The work distribution unit receives pointers to processing tasks that are encoded as task metadata TMD and stored in memory. The pointers to TMDs are included in a command stream that is stored as a pushbuffer and received by the front end unit from the host interface . Processing tasks that may be encoded as TMDs include indices associated with the data to be processed as well as state parameters and commands that define how the data is to be processed. For example the state parameters and commands could define the program to be executed on the data. The task work unit receives tasks from the front end and ensures that GPCs are configured to a valid state before the processing task specified by each one of the TMDs is initiated. A priority may be specified for each TMD that is used to schedule the execution of the processing task. Processing tasks also may be received from the processing cluster array . Optionally the TMD may include a parameter that controls whether the TMD is added to the head or the tail of a list of processing tasks or to a list of pointers to the processing tasks thereby providing another level of control over execution priority.

PPU advantageously implements a highly parallel processing architecture based on a processing cluster array that includes a set of C general processing clusters GPCs where C 1. Each GPC is capable of executing a large number e.g. hundreds or thousands of threads concurrently where each thread is an instance of a program. In various applications different GPCs may be allocated for processing different types of programs or for performing different types of computations. The allocation of GPCs may vary depending on the workload arising for each type of program or computation.

Memory interface includes a set of D of partition units where D 1. Each partition unit is coupled to one or more dynamic random access memories DRAMs residing within PPM memory . In one embodiment the number of partition units equals the number of DRAMs and each partition unit is coupled to a different DRAM . In other embodiments the number of partition units may be different than the number of DRAMs . Persons of ordinary skill in the art will appreciate that a DRAM may be replaced with any other technically suitable storage device. In operation various render targets such as texture maps and frame buffers may be stored across DRAMs allowing partition units to write portions of each render target in parallel to efficiently use the available bandwidth of PP memory .

A given GPCs may process data to be written to any of the DRAMs within PP memory . Crossbar unit is configured to route the output of each GPC to the input of any partition unit or to any other GPC for further processing. GPCs communicate with memory interface via crossbar unit to read from or write to various DRAMs . In one embodiment crossbar unit has a connection to I O unit in addition to a connection to PP memory via memory interface thereby enabling the processing cores within the different GPCs to communicate with system memory or other memory not local to PPU . In the embodiment of crossbar unit is directly connected with I O unit . In various embodiments crossbar unit may use virtual channels to separate traffic streams between the GPCs and partition units .

Again GPCs can be programmed to execute processing tasks relating to a wide variety of applications including without limitation linear and nonlinear data transforms filtering of video and or audio data modeling operations e.g. applying laws of physics to determine position velocity and other attributes of objects image rendering operations e.g. tessellation shader vertex shader geometry shader and or pixel fragment shader programs general compute operations etc. In operation PPU is configured to transfer data from system memory and or PP memory to one or more on chip memory units process the data and write result data back to system memory and or PP memory . The result data may then be accessed by other system components including CPU another PPU within parallel processing subsystem or another parallel processing subsystem within computer system .

As noted above any number of PPUs may be included in a parallel processing subsystem . For example multiple PPUs may be provided on a single add in card or multiple add in cards may be connected to communication path or one or more of PPUs may be integrated into a bridge chip. PPUs in a multi PPU system may be identical to or different from one another. For example different PPUs might have different numbers of processing cores and or different amounts of PP memory . In implementations where multiple PPUs are present those PPUs may be operated in parallel to process data at a higher throughput than is possible with a single PPU . Systems incorporating one or more PPUs may be implemented in a variety of configurations and form factors including without limitation desktops laptops handheld personal computers or other handheld devices servers workstations game consoles embedded systems and the like.

Operation of GPC is controlled via a pipeline manager that distributes processing tasks received from a work distribution unit not shown within task work unit to one or more streaming multiprocessors SMs . Pipeline manager may also be configured to control a work distribution crossbar by specifying destinations for processed data output by SMs .

In one embodiment GPC includes a set of M of SMs where M 1. Also each SM includes a set of functional execution units not shown such as execution units and load store units. Processing operations specific to any of the functional execution units may be pipelined which enables a new instruction to be issued for execution before a previous instruction has completed execution. Any combination of functional execution units within a given SM may be provided. In various embodiments the functional execution units may be configured to support a variety of different operations including integer and floating point arithmetic e.g. addition and multiplication comparison operations Boolean operations AND OR XOR bit shifting and computation of various algebraic functions e.g. planar interpolation and trigonometric exponential and logarithmic functions etc. . Advantageously the same functional execution unit can be configured to perform different operations.

In operation each SM is configured to process one or more thread groups. As used herein a thread group or warp refers to a group of threads concurrently executing the same program on different input data with one thread of the group being assigned to a different execution unit within an SM . A thread group may include fewer threads than the number of execution units within the SM in which case some of the execution may be idle during cycles when that thread group is being processed. A thread group may also include more threads than the number of execution units within the SM in which case processing may occur over consecutive clock cycles. Since each SM can support up to G thread groups concurrently it follows that up to G M thread groups can be executing in GPC at any given time.

Additionally a plurality of related thread groups may be active in different phases of execution at the same time within an SM . This collection of thread groups is referred to herein as a cooperative thread array CTA or thread array. The size of a particular CTA is equal to m k where k is the number of concurrently executing threads in a thread group which is typically an integer multiple of the number of execution units within the SM and m is the number of thread groups simultaneously active within the SM .

Although not shown in each SM contains a level one L1 cache or uses space in a corresponding L1 cache outside of the SM to support among other things load and store operations performed by the execution units. Each SM also has access to level two L2 caches not shown that are shared among all GPCs in PPU . The L2 caches may be used to transfer data between threads. Finally SMs also have access to off chip global memory which may include PP memory and or system memory . It is to be understood that any memory external to PPU may be used as global memory. Additionally as shown in a level one point five L1.5 cache may be included within GPC and configured to receive and hold data requested from memory via memory interface by SM . Such data may include without limitation instructions uniform data and constant data. In embodiments having multiple SMs within GPC the SMs may beneficially share common instructions and data cached in L1.5 cache .

Each GPC may have an associated memory management unit MMU that is configured to map virtual addresses into physical addresses. In various embodiments MMU may reside either within GPC or within the memory interface . The MMU includes a set of page table entries PTEs used to map a virtual address to a physical address of a tile or memory page and optionally a cache line index. The MMU may include address translation lookaside buffers TLB or caches that may reside within SMs within one or more L1 caches or within GPC .

In graphics and compute applications GPC may be configured such that each SM is coupled to a texture unit for performing texture mapping operations such as determining texture sample positions reading texture data and filtering texture data.

In operation each SM transmits a processed task to work distribution crossbar in order to provide the processed task to another GPC for further processing or to store the processed task in an L2 cache not shown parallel processing memory or system memory via crossbar unit . In addition a pre raster operations preROP unit is configured to receive data from SM direct data to one or more raster operations ROP units within partition units perform optimizations for color blending organize pixel color data and perform address translations.

It will be appreciated that the core architecture described herein is illustrative and that variations and modifications are possible. Among other things any number of processing units such as SMs texture units or preROP units may be included within GPC . Further as described above in conjunction with PPU may include any number of GPCs that are configured to be functionally similar to one another so that execution behavior does not depend on which GPC receives a particular processing task. Further each GPC operates independently of the other GPCs in PPU to execute tasks for one or more application programs. In view of the foregoing persons of ordinary skill in the art will appreciate that the architecture described in in no way limits the scope of the present invention.

The PD collects vertex data associated with high order surfaces graphics primitives and the like from the front end and transmits the vertex data to the VAF .

The VAF retrieves vertex attributes associated with each of the incoming vertices from shared memory and stores the vertex data along with the associated vertex attributes into shared memory.

The VTG is a programmable execution unit that is configured to execute vertex shader programs tessellation programs and geometry programs. These programs process the vertex data and vertex attributes received from the VAF and produce graphics primitives as well as color values surface normal vectors and transparency values at each vertex for the graphics primitives for further processing within the graphics processing pipeline . Although not explicitly shown the VTG may include in some embodiments one or more of a vertex processing unit a tessellation initialization processing unit a task generation unit a task distributor a topology generation unit a tessellation processing unit and a geometry processing unit.

The vertex processing unit is a programmable execution unit that is configured to execute vertex shader programs lighting and transforming vertex data as specified by the vertex shader programs. For example the vertex processing unit may be programmed to transform the vertex data from an object based coordinate representation object space to an alternatively based coordinate system such as world space or normalized device coordinates NDC space. The vertex processing unit may read vertex data and vertex attributes that is stored in shared memory by the VAF and may process the vertex data and vertex attributes. The vertex processing unit stores processed vertices in shared memory.

The tessellation initialization processing unit is a programmable execution unit that is configured to execute tessellation initialization shader programs. The tessellation initialization processing unit processes vertices produced by the vertex processing unit and generates graphics primitives known as patches. The tessellation initialization processing unit also generates various patch attributes. The tessellation initialization processing unit then stores the patch data and patch attributes in shared memory. In some embodiments the tessellation initialization shader program may be called a hull shader or a tessellation control shader.

The task generation unit retrieves data and attributes for vertices and patches from shared memory. The task generation unit generates tasks for processing the vertices and patches for processing by later stages in the graphics processing pipeline .

The task distributor redistributes the tasks produced by the task generation unit. The tasks produced by the various instances of the vertex shader program and the tessellation initialization program may vary significantly between one graphics processing pipeline and another. The task distributor redistributes these tasks such that each graphics processing pipeline has approximately the same workload during later pipeline stages.

The topology generation unit retrieves tasks distributed by the task distributor. The topology generation unit indexes the vertices including vertices associated with patches and computes U V coordinates for tessellation vertices and the indices that connect the tessellated vertices to form graphics primitives. The topology generation unit then stores the indexed vertices in shared memory.

The tessellation processing unit is a programmable execution unit that is configured to execute tessellation shader programs. The tessellation processing unit reads input data from and writes output data to shared memory. This output data in shared memory is passed to the next shader stage the geometry processing unit as input data. In some embodiments the tessellation shader program may be called a domain shader or a tessellation evaluation shader.

The geometry processing unit is a programmable execution unit that is configured to execute geometry shader programs thereby transforming graphics primitives. Vertices are grouped to construct graphics primitives for processing where graphics primitives include triangles line segments points and the like. For example the geometry processing unit may be programmed to subdivide the graphics primitives into one or more new graphics primitives and calculate parameters such as plane equation coefficients that are used to rasterize the new graphics primitives.

The geometry processing unit transmits the parameters and vertices specifying new graphics primitives to the VPC . The geometry processing unit may read data that is stored in shared memory for use in processing the geometry data. The VPC performs clipping culling perspective correction and viewport transform to determine which graphics primitives are potentially viewable in the final rendered image and which graphics primitives are not potentially viewable. The VPC then transmits processed graphics primitives to the tiling unit .

The tiling unit is a graphics primitive sorting engine that resides between a world space pipeline and a screen space pipeline as further described herein. Graphics primitives are processed in the world space pipeline and then transmitted to the tiling unit . The screen space is divided into cache tiles where each cache tile is associated with a portion of the screen space. For each graphics primitive the tiling unit identifies the set of cache tiles that intersect with the graphics primitive a process referred to herein as tiling. After tiling a certain number of graphics primitives the tiling unit processes the graphics primitives on a cache tile basis where graphics primitives associated with a particular cache tile are transmitted to the setup unit . The tiling unit transmits graphics primitives to the setup unit one cache tile at a time. Graphics primitives that intersect with multiple cache tiles are typically processed once in the world space pipeline but are then transmitted multiple times to the screen space pipeline .

Such a technique improves cache memory locality during processing in the screen space pipeline where multiple memory operations associated with a first cache tile access a region of the L2 caches or any other technically feasible cache memory that may stay resident during screen space processing of the first cache tile. Once the graphics primitives associated with the first cache tile are processed by the screen space pipeline the portion of the L2 caches associated with the first cache tile may be flushed and the tiling unit may transmit graphics primitives associated with a second cache tile. Multiple memory operations associated with a second cache tile may then access the region of the L2 caches that may stay resident during screen space processing of the second cache tile. Accordingly the overall memory traffic to the L2 caches and to the render targets may be reduced. In some embodiments the world space computation is performed once for a given graphics primitive irrespective of the number of cache tiles in screen space that intersects with the graphics primitive.

The setup unit receives vertex data from the VPC via the tiling unit and calculates parameters associated with the graphics primitives including without limitation edge equations partial plane equations and depth plane equations. The setup unit then transmits processed graphics primitives to rasterizer .

The rasterizer scan converts the new graphics primitives and transmits fragments and coverage data to the pixel shading unit . Additionally the rasterizer may be configured to perform z culling and other z based optimizations.

The pixel shading unit is a programmable execution unit that is configured to execute fragment shader programs transforming fragments received from the rasterizer as specified by the fragment shader programs. Fragment shader programs may shade fragments at pixel level granularity where such shader programs may be called pixel shader programs. Alternatively fragment shader programs may shade fragments at sample level granularity where each pixel includes multiple samples and each sample represents a portion of a pixel. Alternatively fragment shader programs may shade fragments at any other technically feasible granularity depending on the programmed sampling rate.

In various embodiments the fragment processing unit may be programmed to perform operations such as perspective correction texture mapping shading blending and the like to produce shaded fragments that are transmitted to the ROP . The pixel shading unit may read data that is stored in shared memory.

The ROP is a processing unit that performs raster operations such as stencil z test blending and the like and transmits pixel data as processed graphics data for storage in graphics memory via the memory interface where graphics memory is typically structured as one or more render targets. The processed graphics data may be stored in graphics memory parallel processing memory or system memory for display on display device or for further processing by CPU or parallel processing subsystem . In some embodiments the ROP is configured to compress z or color data that is written to memory and decompress z or color data that is read from memory. In various embodiments the ROP may be located in the memory interface in the GPCs in the processing cluster array outside of the GPCs or in a separate unit not shown within the PPUs .

The graphics processing pipeline may be implemented by any one or more processing elements within PPU . For example one of the SMs of could be configured to perform the functions of one or more of the VTG and the pixel shading unit . The functions of the PD the VAF the VPC the tiling unit the setup unit the rasterizer and the ROP may also be performed by processing elements within a particular GPC in conjunction with a corresponding partition unit . Alternatively graphics processing pipeline may be implemented using dedicated fixed function processing elements for one or more of the functions listed above. In various embodiments PPU may be configured to implement one or more graphics processing pipelines .

In some embodiments the graphics processing pipeline may be divided into a world space pipeline and a screen space pipeline . The world space pipeline processes graphics objects in 3D space where the position of each graphics object is known relative to other graphics objects and relative to a 3D coordinate system. The screen space pipeline processes graphics objects that have been projected from the 3D coordinate system onto a 2D planar surface representing the surface of the display device . For example the world space pipeline could include pipeline stages in the graphics processing pipeline from the PD through the VPC . The screen space pipeline could include pipeline stages in the graphics processing pipeline from the setup unit through the ROP . The tiling unit would follow the last stage of the world space pipeline namely the VPC . The tiling unit would precede the first stage of the screen space pipeline namely the setup unit .

In some embodiments the world space pipeline may be further divided into an alpha phase pipeline and a beta phase pipeline. For example the alpha phase pipeline could include pipeline stages in the graphics processing pipeline from the PD through the task generation unit. The beta phase pipeline could include pipeline stages in the graphics processing pipeline from the topology generation unit through the VPC . The graphics processing pipeline performs a first set of operations during processing in the alpha phase pipeline and a second set of operations during processing in the beta phase pipeline. As used herein a set of operations is defined as one or more instructions executed by a single thread by a thread group or by multiple thread groups acting in unison.

In a system with multiple graphics processing pipeline the vertex data and vertex attributes associated with a set of graphics objects may be divided so that each graphics processing pipeline has approximately the same amount of workload through the alpha phase. Alpha phase processing may significantly expand the amount of vertex data and vertex attributes such that the amount of vertex data and vertex attributes produced by the task generation unit is significantly larger than the amount of vertex data and vertex attributes processed by the PD and VAF . Further the task generation unit associated with one graphics processing pipeline may produce a significantly greater quantity of vertex data and vertex attributes than the task generation unit associated with another graphics processing pipeline even in cases where the two graphics processing pipelines process the same quantity of attributes at the beginning of the alpha phase pipeline. In such cases the task distributor redistributes the attributes produced by the alpha phase pipeline such that each graphics processing pipeline has approximately the same workload at the beginning of the beta phase pipeline.

Please note as used herein references to shared memory may include any one or more technically feasible memories including without limitation a local memory shared by one or more SMs or a memory accessible via the memory interface such as a cache memory parallel processing memory or system memory . Please also note as used herein references to cache memory may include any one or more technically feasible memories including without limitation an L1 cache an L1.5 cache and the L2 caches.

The screen space represents one or more memory buffers configured to store rendered image data and other data transmitted by functional units within the graphics processing pipeline . In some embodiments the one or more memory buffers may be configured as one or more render targets. The screen space represents a memory buffer configured to store the image rendered by the graphics processing pipeline. The screen space may be associated with any number of render targets where each render target may be configured independently of other render targets to include any number of fields. Each field within a render target may be configured independently of other fields to include any number of bits. Each render target may include multiple picture elements pixels and each pixel may in turn include multiple samples. In some embodiments the size of each cache tile may be based on the size and configuration of the render targets associated with the screen space. In operation once rendering completes the pixels in the one or more render targets may be transmitted to a display device in order to display the rendered image.

By way of example a set of render targets for the screen space could include eight render targets. The first render target could include four fields representing color including red green and blue component colors and transparency information associated with a corresponding fragment. The second render target could include two fields representing depth and stencil information associated with the corresponding fragment. The third render target could include three fields representing surface normal vector information including an x axis normal vector a y axis normal vector and a z axis normal vector associated with the corresponding fragment. The remaining five render targets could be configured to store additional information associated with the corresponding fragment. Such configurations could include storage for various information including without limitation 3D positional data diffuse lighting information and specular lighting information.

Each cache tile represents a portion of the screen space . For clarity only five cache tiles 0 4 are shown in . In some embodiments cache tiles may have an arbitrary size in X and Y screen space. For example if a cache tile were to reside in a cache memory that also is used to store other data then the cache tile could be sized to consume only a specific portion of the cache memory. The size of a cache tile may be based on a number of factors including the quantity and configuration of the render targets associated with the screen space the quantity of samples per pixel and whether the data stored in the cache tile is compressed. As a general matter a cache tile is sized to increase the likelihood that the cache tile data remains resident in the cache memory until all graphics primitives associated with the cache tile are fully processed.

The raster tiles represent a portion of the cache tile 0 . As shown the cache tile 0 includes sixteen raster tiles 0 15 arranged in an array that is four raster tiles wide and four raster tiles high. In systems that include multiple GPCs processing associated with a given cache tile 0 may be divided among the available GPCs . In the example shown if the sixteen raster tiles of cache tile 0 were processed by four different GPCs then each GPC could be assigned to process four of the sixteen raster tiles in the cache tile 0 . Specifically the first GPC could be assigned to process raster tiles 0 7 10 and 13 . The second GPC could be assigned to process raster tiles 1 4 11 and 14 . The third GPC could be assigned to process raster tiles 2 5 8 and 15 . The fourth GPC would then be assigned to process raster tiles 3 6 9 and 12 . In other embodiments the processing of the different raster tiles within a given cache tile may be distributed among GPCs or any other processing entities included within computer system in any technically feasible manner.

During image rendering graphics objects are processed once through the world space pipeline producing one or more graphics primitives associated with each graphics object. A bounding box is computed for each graphics primitive or group of graphics primitives. Although described as a bounding box any technically feasible bounding primitive may by computed including without limitation a square a rectangle an irregular octagon or any other regular or irregular bounding shape. Each graphics primitive is then tiled that is the graphics primitive is associated with one or more screen space tiles and the graphics primitive data is stored in the tiling unit . Each graphics primitive is then processed one or more times by the screen space pipeline based on the number of tiles intersected by the graphics primitive. Accordingly world space computation is performed once for each graphics object regardless of how many screen cache tiles that the graphics intersects. Because world space computation is performed once the device driver may access the graphics processing pipeline as a single pass pipeline. As such the device driver does not need to loop over the graphics objects and associated vertex attributes and other state attributes more than once even though the graphics objects may be processed multiple times by the screen space pipeline . The tiling memory in the tiling unit is sized to store the graphics primitive data produced by the world space pipeline . For some images however more data is produced by the world space pipeline than can be stored in the tiling memory and associated cache memories. In such cases the tiling unit employs buffer limited processing. Buffer limited processing is further described below.

The world space pipeline processes graphics objects associated with an image being rendered in the graphics processing pipeline and creates graphics primitives associated with the graphics objects. The world space pipeline then transmits the graphics primitives to the crossbar .

The crossbar receives graphics primitives from the world space pipeline and transmits the graphics primitives to the tiling infrastructure . In GPCs that include multiple graphics processing pipelines the GPCs may have multiple world space pipelines tiling infrastructures and screen space pipelines . In such cases the crossbar transmits graphics primitives received from one of the world space pipelines to one several or all of the tiling infrastructures as appropriate.

The tiling infrastructure receives graphics primitives from the crossbar and tiles the graphics primitives into screen space tiles. As shown the tiling infrastructure includes a tiling unit and an L2 cache . Except as further described below the tiling unit and the L2 cache function substantially the same as described in conjunction with .

The tiling unit receives graphics primitives from the crossbar and tiles the data for screen space processing. As shown the tiling unit includes a tiling engine and a tiling memory .

The tiling engine is a processing unit that processes graphics primitives received from the crossbar and stores the processed data in the tiling memory . In particular the tiling engine stores graphics primitive data for each graphics primitive where the graphics primitive data includes without limitation primitive descriptors identifying the type of graphics primitive such as point line segment or triangle and a pointer to each vertex of the graphics primitive. Graphics primitives are received from the crossbar in the order that the graphics primitives are processed by the world space pipeline . The data associated with the graphics primitives are stored in the received order without regard to screen space positions of the graphics primitives.

The pointer to each vertex of a graphics primitive may be specified in any technically feasible manner including without limitation a direct memory address an offset address from a particular base address or a numeric index. In one embodiment each vertex pointer consumes four bytes of memory in the tiling memory . Each pointer to a graphics primitive vertex points to a location in the L2 cache that specifies the vertex attribute data associated with the vertex. The tiling engine also stores bounding box data where each entry in the bounding box data defines the position and size in screen space of a rectangular bounding box that circumscribes one or more associated graphics primitives. From the bounding box data the tiling engine may determine the set of screen tiles that intersect each graphics primitive.

The tiling memory is a dedicated on chip memory that stores data for the tiling engine including without limitation graphics primitive data and bounding box data . The tiling memory operates as a cache memory where data that does not fit in the tiling memory may be written to and read from an off chip memory such as a higher level cache or frame buffer memory. As shown the tiling memory includes graphics primitive data and bounding box data .

As described in conjunction with the L2 cache is a unified level 2 cache. As shown the L2 cache includes vertex attribute data state information data one or more cache tiles and constant data .

The vertex attribute data is a circular buffer in the L2 cache that includes various attributes associated with the vertices of the graphics primitives processed by the world space pipeline . The vertex attribute data is stored with an EVICT LAST eviction policy in order to increase the likelihood that the vertex attribute data stays resident in the L2 cache for an extended period. In one embodiment each entry in the vertex attribute data consumes sixty four bytes of memory in the L2 cache . The vertex pointers stored in the graphics primitive data of the tiling memory point to the entries in the vertex attribute data .

The state information data includes additional state information as needed by the screen space pipeline . In some embodiments the state information data may include data that is correlated to one or more vertices as stored in the vertex attribute data . In some embodiments the state information data may include data that is not correlated to any vertices stored in the vertex attribute data .

The cache tile portion of the L2 cache stores one or more cache tiles as described in conjunction with . As the screen space pipeline processes graphics primitives received from the tiling infrastructure the screen space pipeline accesses associated data in the cache tile portion of the L2 cache .

The constant data portion of the L2 cache stores data constants not stored in registers or other memory.

The L2 cache also stores various data not shown associated with the parallel processing subsystem . The L2 cache operates as a cache memory where data that does not fit in the L2 cache may be written to and read from an off chip memory such as the frame buffer memory.

In GPCs that include multiple graphics processing pipelines each GPC may have a screen space pipeline corresponding to each tiling infrastructure . In such cases each tiling infrastructure transmits tiled graphics primitives to a corresponding screen space pipeline .

The screen space pipeline receives tiled graphics primitives from the corresponding tiling infrastructure for screen space processing. Specifically the setup unit in the screen space pipeline receives graphics primitive data and bounding box data from the tiling unit and vertex attribute data state information data and cache tiles from the L2 cache . The screen space pipeline then processes the received data in tile order as received from the tiling infrastructure .

It will be appreciated that the system shown herein is illustrative and that variations and modifications are possible. In one example the tiling infrastructure is describes as having a tiling memory and an L2 cache that each include various sections. However the various sections of the tiling memory and the L2 cache could be stored in any technically feasible memory on chip or off chip whether or not such a memory is a cache memory. In another example portions of the tiling memory and the L2 cache could store other data not shown as needed by various processing elements including without limitation the tiling unit the GPCs and the CPU . In yet another example the vertex attribute data is described as being stored with an EVICT LAST eviction policy. However the vertex attribute data could be subject to any technically feasible cache eviction policy. Alternatively the vertex attribute data could be subject to no cache policy at all such as when the vertex attribute data is stored in memory that is not a cache memory.

Each of the graphics primitive data bounding box data vertex attribute data and other data may be individually selected for various buffering levels including without limitation single buffering double buffering triple buffering and quad buffering. For example graphics primitive data and bounding box data could be double buffered while vertex attribute data could be triple buffered and constant data could be single buffered. Buffering levels may be chosen based on any suitable criteria including without limitation the size of the stored data the criticality of the data and the duration that the data is expected to remain resident in on chip memory. Such an approach may increase the likelihood that data related to the processed graphics primitives to stay on chip for longer periods. In addition this approach may reduce additional memory traffic that would otherwise be incurred for writing and then reading back vertex attribute data generated by the world space pipeline from frame buffer memory.

As the tiling unit re orders graphics primitives on a tile by tile basis the tiling unit monitors threshold levels for various data sections associated with tiling including without limitation the graphics primitive data bounding box data the vertex attribute data and constant data . Thresholds are individually set for each of these data sections to indicate when the data currently in the tiling memory should be processed prior to overfilling one of the on chip memories such as the tiling memory and the L2 cache . When a threshold is reached in one or more data sections the tiling unit initiates a flush operation where the graphics primitives stored in the tiling memory are processed and sent to the screen space pipeline on a tile by tile basis. The corresponding entries in the tiling memory are then emptied freeing the associated tiling memory for receiving additional graphics primitives.

The memory bandwidth for processed geometry may be substantial particularly in the presence of geometry expansion such as during tessellation and geometry shading. Moreover significant quantities of graphics primitive data and vertex attribute data are generated when rendering images that include many small graphics primitives. The approaches described herein may advantageously reduce memory bandwidth during tiled rendering.

In some embodiments the memory dedicated to storing vertex attribute data in the L2 cache may be programmable via a software application. As such the vertex attribute data may be sized to allow spill into frame buffer memory. Such an approach may be advantageous where the performance penalty of writing to and reading from frame buffer memory is less than the penalty associated with flushing the tiling memory .

As shown a method begins at step where the tiling unit receives a new cache tile size corresponding to a new render target configuration. At step the tiling unit determines whether a flush condition is detected. A flush condition occurs for a variety of reasons including without limitation one or more buffers has reached a fill threshold a flush command is received from an application program or a new render target configuration is detected. If a flush condition is not detected then the method proceeds to step where the tiling unit determines whether a new graphics primitive has been received from the world space pipeline . If a new graphics primitive has been received from the world space pipeline then the method proceeds to step where the tiling unit stores the received graphics primitive in the tiling memory . The method then returns to step described above. If at step however a new graphics primitive has not been received from the world space pipeline then the method proceeds to step described above.

Returning to step if a flush condition is detected then the method proceeds to step where the tiling unit determines whether the tiling memory includes non empty tiles for processing. If the tiling memory includes non empty tiles for processing then the method proceeds to step where the tiling unit selects a tile for processing. At step the tiling unit parses the graphics primitive data in the tiling memory to find the graphics primitives that intersect the selected tile. At step the tiling unit transmits scissor data associated with the position and size of the selected tile to the screen space pipeline where the scissor data defines the portion of the intersecting graphics primitives that lie within the selected tile. At step the tiling unit transmits graphics primitive data associated with the intersecting graphics primitives to the screen space pipeline . The tiling unit may also transmit bounding box data such as the position and size for a bounding box associated with one or more of the transmitted graphics primitives. The method then returns to step described above.

Returning to step if the tiling memory does not include non empty tiles for processing then the method proceeds to step where the tiling unit determines whether the flush condition of step was due to a new render target configuration. If the flush condition was not due to a new render target configuration then the method returns to step described above. If at step however the flush condition was due to a new render target configuration then the method returns to step described above.

In this manner the tiling unit continuously receives graphics primitives from the world space pipeline and transmits tiled graphics primitives to the screen space pipeline . If the tiling memory is double buffered then the tiling unit stores the graphics primitives received from the world space pipeline into one buffer and transmits tiled graphics primitives to the screen space pipeline from the other buffer. If the tiling memory is triple buffered then the tiling unit stores the graphics primitives received from the world space pipeline into two buffers and transmits tiled graphics primitives to the screen space pipeline from the third buffer. Alternatively the tiling unit stores the graphics primitives received from the world space pipeline into one buffer and transmits tiled graphics primitives to the screen space pipeline from the other two buffers.

In sum graphics objects are processed once through the world space pipeline and are stored in a tiling memory between the end of the world space pipeline and the beginning of the screen space pipeline. Geometry primitive data is stored in an on chip tiling memory while associated data such as vertex attribute data is stored in an on chip cache memory. Various threshold levels limit the fill level for the tiling memory cache memory and other associated on chip storage areas. If an on chip memory fills to a corresponding threshold level then the tiling memory is flushed whereby tiling is halted and the graphics primitives in the tiling memory are processed. Tiling then resumes with respect to the unprocessed graphics primitives. Another feature is that the vertex attribute data in the cache memory are stored with an EVICT LAST policy increasing the likelihood that the vertex attribute data stays resident as tiling resumes and additional graphics primitives are processed. In some embodiments the graphics primitives in tiling memory or vertex attribute data in cache memory may be allowed to spill over into frame buffer memory in cases where the penalty for writing and reading frame buffer memory is determined to be less than the penalty for flushing the graphics primitives in the tiling memory.

One advantage of the disclosed approach is that graphics primitives and associated data are more likely to remain stored on chip during cache tile rendering thereby reducing power consumption and improving rendering performance. Another advantage of the disclosed approach is that world space processing is performed once regardless of how many cache tiles on the screen that the geometry falls into. Consequently the application program and device driver do not need to perform multiple processing passes over the graphics objects and associated state. As a result application programs and device driver may have a more simplified structure leading to fewer programming errors and further performance improvement.

One embodiment of the invention may be implemented as a program product for use with a computer system. The program s of the program product define functions of the embodiments including the methods described herein and can be contained on a variety of computer readable storage media. Illustrative computer readable storage media include but are not limited to i non writable storage media e.g. read only memory devices within a computer such as compact disc read only memory CD ROM disks readable by a CD ROM drive flash memory read only memory ROM chips or any type of solid state non volatile semiconductor memory on which information is permanently stored and ii writable storage media e.g. floppy disks within a diskette drive or hard disk drive or any type of solid state random access semiconductor memory on which alterable information is stored.

The invention has been described above with reference to specific embodiments. Persons of ordinary skill in the art however will understand that various modifications and changes may be made thereto without departing from the broader spirit and scope of the invention as set forth in the appended claims. The foregoing description and drawings are accordingly to be regarded in an illustrative rather than a restrictive sense.

