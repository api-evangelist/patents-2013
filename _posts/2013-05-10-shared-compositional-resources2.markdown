---

title: Shared compositional resources
abstract: Shared compositional resources are described. In one or more implementations, a global composition system may be configured to perform rendering for a plurality of processes, e.g., applications. For example, the global composition system may be configured to expose one or more application programming interfaces (APIs) that are accessible to the processes. The APIs may then be used to cause a single composition engine to perform the rendering for the plurality of applications. Thus, the single composition engine may be leveraged to support a variety of functionality, such as to manage sharing of compositional resources by a plurality of processes. This sharing may be performed in a variety of ways, which may include use of a writer/reader paradigm.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09542906&OS=09542906&RS=09542906
owner: Microsoft Technology Licensing, LLC
number: 09542906
owner_city: Redmond
owner_country: US
publication_date: 20130510
---
A wide variety of elements may be rendered on a computing device such as icons windows animations and so on. Further the numbers of applications typically executed on the computing device continues to increase as well as the number of elements each of the applications typically provides such as to provide additional functionality and a richer user experience.

However this increase in elements may consume a significant amount of resources of the computing device such as processor memory graphics hardware and other resources. Accordingly this consumption may also have an effect on execution of the applications themselves responsiveness of the computing device to a user and so on.

Shared compositional resources are described. In one or more implementations a global composition system may be configured to perform rendering for a plurality of processes e.g. applications. For example the global composition system may be configured to expose one or more application programming interfaces APIs that are accessible to the processes. The APIs may then be used to cause a single composition engine to perform the rendering for the plurality of applications. Thus the single composition engine may be leveraged to support a variety of functionality such as to manage sharing of compositional resources by a plurality of processes. This sharing may be performed in a variety of ways which may include use of a writer reader paradigm.

This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used as an aid in determining the scope of the claimed subject matter.

Conventional techniques used to render elements by a computing device employed a distributed system in which each process was assigned a corresponding composition engine. Because of this the different composition engines were unaware of what was being performed by other composition engines. This could lead to redundancies unnecessary rending of elements and so on that could hinder the efficiency of a computing device that implemented the conventional techniques and thus could make these conventional techniques ill suited for use by thin computing devices.

Global composition techniques and shared compositional resources are described herein. These techniques include use of a single composition engine that is accessible by a plurality of different processes via one or more APIs. Thus the composition engine may be made aware of what is being contributed by the various processes and how those elements relate. This knowledge may then be leveraged to improve efficiency in the rendering of elements of the applications. In one or more implementations the composition engine runs asynchronous from threads belonging to those applications which allows applications to cause content to be animated within their windows and use disparate rendering technologies to rasterize such content. Additionally composition data from each process in the system may be managed in a single graph e.g. a global composition tree which allows the composition engine to perform global optimizations such as occlusion detection as well as to mix and match content from multiple process in an efficient and secure fashion.

This may also be leveraged to share compositional resources between processes. For example a first process may create a compositional resource that may be shared with a second process such as a float color animation trigger transform visual or other visual property. In this way different processes may share compositional resources. For example a writer reader paradigm may then implemented by the composition engine in which a writer process has permission to modify properties of the shared compositional resources whereas a reader process has permission to specify an element to be rendered. In this way the reader process may specify what element is to be rendered and the writer process may specify how the element is to be rendered without either of the processes being aware of what was specified by the other process. In this way execution of each process may be abstracted from the execution of the other processes yet permit sharing of compositional resources. Further discussion of these and other techniques may be found in relation to the following figures.

In the following discussion an Example Composition Environment is first described that may employ the techniques described herein. A Shared Compositional Resource section follows that describe sharing of compositional resources between processes which may be implemented in the Example Composition System as well as other systems. Example procedures are then described which may be performed in the example environment as well as other environments. Consequently performance of the example procedures sharing of compositional resources and the example environment are not to be limited to each of the other described implementation those implementation being examples of a plurality of different implementations that may leverage the techniques described herein.

For example a computing device may be configured as a computer that is capable of communicating over the network such as a desktop computer a mobile station an entertainment appliance a set top box communicatively coupled to a display device a wireless phone a game console and so forth. Thus the computing device may range from full resource devices with substantial memory and processor resources e.g. personal computers game consoles to a low resource device with limited memory and or processing resources e.g. traditional set top boxes hand held game consoles . Additionally although a single computing device is shown the computing device may be representative of a plurality of different devices such as multiple servers utilized by a business to perform operations such as by the web service a remote control and set top box combination an image capture device and a game console configured to capture gestures and so on.

Although the network is illustrated as the Internet the network may assume a wide variety of configurations. For example the network may include a wide area network WAN a local area network LAN a wireless network a public telephone network an intranet and so on. Further although a single network is shown the network may be configured to include multiple networks.

The computing device is further illustrated as including an operating system . The operating system is configured to abstract underlying functionality of the computing device to applications that are executable on the computing device . For example the operating system may abstract processing memory network and or display functionality of the computing device such that the applications which may include single or multiple processes may be written without knowing how this underlying functionality is implemented. The application for instance may provide data to the operating system to be rendered and displayed by the display device without understanding how this rendering will be performed.

The operating system may also represent a variety of other functionality such as to manage a file system and user interface that is navigable by a user of the computing device . An example of this is illustrated as a desktop that is displayed on the display device of the computing device .

The operating system is also illustrated as including a global composition system . The global composition system may represent a system that includes a direct composition component that is configured to allow applications to use a single composition engine hereinafter also referred to as a global composition engine to draw items on the display device . Although illustrated as part of an operating system the global composition system may be implemented in a variety of other ways such as part of a browser as a stand alone module and so forth. Further the global composition system may be distributed across the network an example of which is illustrated as inclusion of a global composition system on the web service .

User experiences e.g. user interfaces generated for applications may include a signification number of elements that may interact with each other such as windows animations e.g. text scrolling and so on. For example a first window may correspond to an email application and a second window may correspond to a browser as illustrated on the display device . Thus a multitude of different rendering components may be involved at any one particular point in time. Additionally these different elements may have different refresh rates such as an animation of a ticker display along with video and static text.

The global composition system may be utilized to abstract this functionality such that different applications may offload this rendering and thus be unaware of how the rendering is performed. For example applications which are examples of processes in this discussion may provide data that describe elements to be rendered placement of the elements and how the elements interrelate with each other.

Additionally the global composition system may support independent animation. An application for instance may communicate a declaration description of an animation that describes how an animation is to be rendered. For example the description may describe what is being animated a rate at which redraws are to occur a location at which the animation is to begin a curve over which the animation is to move an ending location of the animation an amount of time the animation is to be rendered and so forth.

This rendering may then be performed by the global composition system and continue without further instruction. In this way the rendering of the animation is independent of the caller e.g. the application such that loss of communication with the application inconsistent processing of the application and so on does not have an effect on the rendering of the animation. Thereby this may be used to improve smoothness and fluidity of the animation as well as resources of the computing device and even network are further described below by cutting down on the number of communications by the application to render the animation.

Conventionally each of the applications that were executed by a computing device interacted with a corresponding composition engine to perform the processing and rendering of a display for the respective application. Therefore conventional composition engines were often implemented per process. Accordingly conventional techniques may involve execution of a plurality of different composition engines at any one time. Additionally conventional composition engines were typically not aware of the rendering performed by other composition engines. This could result in inefficient use of resources of the computing device such as to draw a window even though it may be occluded by another window which could result in unnecessary use of processor graphical processor memory and other resources of the computing device .

In one or more implementations the global composition system follows a global architecture such that a plurality of applications may access the composition engine e.g. via an application programming interface. For example a single composition engine may be responsible for an entire desktop and elements from applications that are currently being executed. Thus the single composition engine may be aware of the different elements that are to be rendered for the plurality of applications and react accordingly as well as manage interaction of the processes with each other such as to support shared compositional resources as further described below in a corresponding section.

Continuing with the previous example the composition engine may be aware that an element of an application e.g. a window is to be occluded by an element to be rendered for another application e.g. another window. As shown in for instance the application may have a window that is to be displayed behind the window that corresponds to the email application. Previously even though the corresponding window of the application was not viewable to a user of the computing device the window was still rendered. However the composition engine may use the present techniques to skip the rendering of the occluded window thereby conserving resources of the computing device and thus supporting use on thin computing devices.

The global composition system may be used to provide a wide variety of functionality. As previously described the global composition system may perform global analysis of what is to be rendered by the plurality of applications and efficiently determine which of the elements are to be drawn such as in the case of occlusion in which rendering of elements may be skipped as previously described. Additionally resources may be pooled by the global composition system such as to share intermediate memory by a plurality of applications instead of fragmented memory as could be consumed by conventional composition engines both by the engines themselves as well as what is being drawn by the engines.

The global composition system may also support security techniques. For example the global composition system may be employed to draw protected video such as encrypted movies and corresponding licensing. For conventional composition engines the application composes the content and then transfers the content to a corresponding composition engine. This may result in the content being transferred in the clear e.g. transfer of uncompressed video frames without the protections and thus the content could be exposed to malicious parties.

However in one or more implementations described herein the content may be provided to the global composition system and may execute within a protected area that is not touchable directly by the applications . Thus trust of the composition engine to not further communicate the content may be used to protect that content. For instance the composition engine may be relied upon to generate pixels for rendering without exposing those pixels to applications that are executed by the computing device . Thus this one way flow may help ensure that the wrong application e.g. from a malicious entity does not receive the unprotected content.

Further conventional composition engines and corresponding applications owned a particular portion of a screen of a display device . Therefore some display techniques were difficult to support using these conventional techniques. One such technique was transparency for multiple applications because the area of the display device could be owned by one or the other conventional composition engines but not both. For instance a particular area of the display device may involve windows from at least two different applications and their corresponding conventional composition engines. Conventionally to support techniques such as transparency each instance of the windows was drawn to memory and then effects were applied to the combination which was resource intensive.

However because the global composition system may be aware of the different windows and react accordingly the desired result may be achieved without drawing the windows separately to memory beforehand and then applying the visual effects to the windows. For example the global composition system may utilize a single hierarchical tree that describes elements to be rendered and thus know how the elements relate. Therefore the global composition system may draw directly to memory of the computing device without the intermediate steps that were performed using conventional techniques. Thus these techniques may be employed by thin computing devices that could not employ conventional composition engines due to memory and or processing limitations.

Additionally conventional composition engines were generally executed asynchronously to support different rendering rates by different applications. Although this did support functionality such that rendering specified an application associated with one composition did not affect the rendering specified by another application this could result in an inefficient use of computing device resources.

Further priorities assigned to the different conventional composition engines may cause errors both to the conventional composition engine as well as associated application. For instance conventional composition engines may be given a relatively high priority for execution by a processor of the computing device . However instances may occur in which the composition engines consume a signification amount of the resources such as to support multiple animations. Because of this the composition engines as well as the applications themselves may not have sufficient resources available to execute as intended when confronted with such resource intensive tasks.

In one or more implementations the composition engine may be assigned a high priority e.g. a high thread priority may be assigned to the composition engine relative to priorities assigned to other threads executed by the computing device . The global composition engine may then mange priority of how elements from the different sources are rendered by the composition engine which is given a high priority to ensure that the rendering occurs. For example the global composition system may manage which elements are updated a frequency at which this update occurs e.g. to switch from 60 Hz to 30 Hz and so on. Thus the global composition system may help promote availability of resources of the computing device for other uses such as the applications that provide the elements for rendering.

Conventional use of a plurality of distributed composition engines protected execution of the engines as well as applications of a computing device from each other. For example if a first application fails a first conventional composition engine coupled to the first application may also fail. However a second composition engine that was coupled to a different conventional composition engine was protected by the failure due to the lack of knowledge that the conventional composition engines had of each other.

In one or more implementations the global composition system may employ techniques to protect against corruption of state of the composition engine by applications that provide elements for rendering. One such technique is to employ the composition engine within a kernel of the operating system . Thus the composition engine may trust other components that are also executed in the kernel .

In this way the global composition system may employ a trust boundary between a user mode and a kernel mode such that checks are performed by the kernel. In one or more implementations applications may be relied upon to determine correctness provided by the applications such as parameter checking to improve efficiency of processing done by the global composition system .

Another such technique involves tracking such that the global composition system knows which data e.g. elements for rendering belongs to which application. Therefore a failure of one application e.g. a crash does not affect the elements of another application. Further the global composition system may clean up the elements in case of such failure such as to remove the elements from being rendered after a predetermined amount of time. In this way the global composition system may allow an application to fail gracefully and not affect other applications and corresponding elements to be rendered.

As illustrated the composition engine is executed on a dedicated system process which is different than processes used to execute other code such as other application processes of the computing device . Additionally this process may be assigned high levels of trust and priority. This process for instance may be trusted from a point of viewing of getting composition data and thus may be used for protected data such as protected video data email protected with rights management and so on.

As illustrated in the global composition system may be implemented using three parts. A first part is illustrated as the composition engine which is representative of functionality to perform the rendering i.e. do the drawing to the display device . A second part is illustrated as a user mode library which is representative of an entity that is called by the applications by exposing application programming interfaces API . For example the user mode library may act as a mail slot to receive composition data from the applications such as through use of a dynamic linked library DLL .

A third part is illustrated as an object database module that is illustrated as residing in the kernel . The object database module is representative of functionality that is responsible for moving data between the user mode library and the composition engine .

The object database module may also perform validation. For example an application may call the user mode library to create an element such as a bitmap. If the requested element does not meet criteria that are enforced by the object database module e.g. less than N number of pixels the object database module may return a failure message to the application that called the user mode library . Thus the object database module may operate within the kernel to control what is provided to the composition engine . A variety of other policies may be enforced by the object database module .

Therefore the composition engine may rely on data that is provided by the object database module as complying with policies implemented by the object database module . In other words the composition engine may assume that the data is valid and correct and thus suitable for rendering. Consequently the validation may be performed a single time by the object database module and then utilized by the composition engine to perform the rendering without further validation.

The object database module may also be representative of functionality to inform the composition engine of when data to be rendered has changed. For example an API implemented via the user mode library may be configured to consume a graph that describes what is to be rendered an example of which is shown in . The graph may include a list of elements to be rendered as well as a description of where to render the elements on the display device which may include how the elements are to move in an instance of an animation.

Additionally the elements to be rendered may be formed using sub elements and thus the graph may assume a hierarchical structure. Further the graph may describe how the elements are to be rendered e.g. draw text once render an animation at 60 Hz and so forth. Thus the graph may describe the elements and how the elements relate to each other.

The graph represents two sets of objects that may be used by the composition engine to render a scene bitmaps that are composed together and visuals that define the spatial relationships according to which those bitmaps are composed. In this model the bitmaps are the what and the visuals are the how of the composition engine . Those objects are arranged in a tree structure and bound to a top level or child window for composition.

Returning again to once received by the composition engine the application does not need to further call the composition engine to keep rendering the elements. Thus the composition engine may conserve resources as compared to conventional techniques that could involve an application making sixty calls per second to render an animation at a refresh rate of the display device . Thus the application may call an API of the user mode library to construct a structure and an API to construct elements to be rendered by the composition engine.

In order to make a change to the content that is rendered by the composition engine the application may call another application programming interface of the user mode library to update the structure and or elements. For example the application may provide data via an update API to provide information to be used for a stock ticker animation.

In one or more implementations batching techniques may also be leveraged to define which elements are to be rendered using frames. As previously described the global composition system may receive a variety of different elements for rendering at a variety of different rates. Accordingly the global composition system may support a structure in which a list of elements to be rendered together is formed. Thus the global composition system may implement a definition of begin and end for the elements in which the elements received in between are not rendered until the end is received. Thus the frame may support an all or nothing approach to the rendering of elements for particular frames and ensure that the elements are rendered together for display when desired.

For example the object database module may track two different states for an application. The first state may reference elements that are for current display. The second state may reference elements that are to be displayed subsequent to the first state and that are changed. Thus the second state may be used to build a list of elements for rendering by the composition engine once the list is completed e.g. once an indication is received from the application that the list is complete.

Once complete the changes may be sent to the composition engine . Further the timing of the receipt of the indication from the application that the list is complete may be used to determine when those changes are displayed e.g. which frame. Thus the composition engine may receive a batch of changes described in one or more lists that are completed but lists that have not been indicated as complete are not communicated. This batching may thus define frames that are rendered by the composition engine . Further this may help limit display of erroneous visual artifacts as could occur using conventional techniques that did not support such a definition. As should be readily apparent an amount of time that corresponds to the frames may be set for a variety of different amounts as desired.

Thus the object database module may remember what was previously rendered by the composition engine e.g. elements and properties of those elements as well as know what is going to be rendered. Therefore the object database module may determine which elements are changed by comparing this information. Accordingly the object database module may communicate information which describes this change without communicating information that is not changed to the composition engine .

Additionally the use of frames may further improve efficiency. For example an application may communicate data that describes that an object is to be moved a certain distance and return back to an original position. The object database module may determine that this movement is to occur within a time period of a single frame. Accordingly the object database module may refrain from communicating this data to the composition engine and rather have the object remain at its previous state. For instance this movement may occur within a time period used to refresh a display device and thus would not be viewable by a user regardless.

In this way the object database module may discard intermediate states in the construction of the list that is to be provided to the composition engine for rendering. This list may then be communicated in a variety of ways such as an array of commands to be performed by the composition engine to implement the changes. Further this technique may also be used to address instances of unbounded data sent by application because a single instance is reported to the composition engine.

The object database module and the composition engine may also employ acknowledgement techniques that describe that a change was implemented. For example the composition engine may receive a communication from the object database module that describes a change to be made. While the change is being made the object database module may wait to send additional changes until an acknowledgement has been received that the previous change was made. Once the acknowledgment is received by the object database module the additional changes may then be communicated to the composition engine.

Further this technique may be used to provide throttling and thus further conserve resources of the computing device . For example an application may make a number of requests that exceed the rate at which a display device is refreshed. By using the frames and batching the changes the amount of resources that would otherwise be consumed is reduced.

Applications that make changes to what is displayed by calling the API of the user mode library may be multithreaded. Accordingly in one or more implementations the object database module may employ techniques such that multiple calls from the multiple threads of a single application do not corrupt the state. This may be performed by the application locking its threads together itself e.g. one thread may be blocked while another thread of the application completes a task.

The changes from the multiple threads may then be stored in a queue which may be managed by the operating system such as through interlocked access that may be employed for variables such that different threads may make complete changes before passing control to another thread. This may support the frame techniques described above to arrive at atomic units of work that are to be processed by the composition engine. Additionally for frames in which updates are not received execution of the composition engine may be paused until the next frame thereby further conserving resources of the computing device .

The kernel may also add a variety of functionality in conjunction with the global composition system . For example when an application fails e.g. crashes the kernel may inform the composition engine of this occurrence. The composition engine may then perform techniques that are to similar to those that would be used if the application ceased execution naturally through a normal exit procedure. In this way the composition engine may clean up state such that the elements that correspond to the application are removed from display on the display device of the computing device . Thus this promotes robustness in the execution of the composition engine .

The execution of the composition engine may also be secured by implementing a write only API for the user mode library . In this way the composition engine may generate the pixels but not expose those pixels back to the applications thereby protecting the images from malicious parties.

As previously described implementation of these techniques may also involve devices outside of the computing device which may be distributed across one or more entities such as the web service . For example these techniques may be employed to support terminal services a remote desktop environment and so on through communication of the batch of elements and properties e.g. a composition tree such as a graph of via the network . Thus the graph may be generated elsewhere e.g. through implementation of the user mode library and or the object database module on the web service and transfer the composition tree for rendering by the composition engine through execution of the computing device . In this way the animations may be smoothly displayed even in instances in which the network is unreliable. Further discussion of these and other techniques may be found in relation to the following section regarding shared compositional resources.

The composition engine is this example is configured to support the ability to share the compositional resource by the application processes . The compositional resources may take a variety of forms such as a float color animation trigger transform visual usage pattern or other visual property. This may be utilized to support a variety of different techniques involved in the rendering of elements for display on a display device such as to support component hosting sharing of visual resources to host one framework within another as shown in and so on. This sharing may be implemented in a variety of ways an example of which is described as follows and shown in a corresponding figure.

Thus the writer process may apply each of the same properties to this hosted framework as it would to any visual in its tree such as transforms opacity and so on. This also makes it possible for the framework to be positioned via composition properties e.g. shared transforms rather than operating system commands. Further the composition engine may be configured such that a process is limited to access of elements e.g. nodes in the figure that correspond to that process. For example the reader process may be prevented from walking the writer visual tree in the illustration and vice versa. In one or more implementations a process that creates a shared compositional component has full rights to the component for modification purposes whereas a reader process sets a visual to be modified. Thus a creator of the shared compositional resource is configured as the writer i.e. the hosting process and a process that is given access to the created process is configured as the reader although other examples are also contemplated.

The use of the shared compositional resource may also support use of the separate frameworks represented by the reader and writer visual trees to be included in separate processes. For example in conventional techniques the hosted process was conventionally forced to execute in the same process as its host. With the ability to have multiple processes in a hosting scenario the host hosted processes are able to create an additional security boundary for the hosted content.

Using the shared compositional resource to tie the two trees together also enables elements of the reader visual tree to be implemented in the correct drawing order along with the rest of the elements in the writer visual tree . This means that the hosted framework of the reader visual tree will no longer suffer from airspace issues as its content is no longer contained in a separate top level window. Airspace involves the inability for two components to be composed together such that any given pixel on a display device is defined by the content of a single one of the components.

As shown in the shared compositional resource is illustrated as split between the reader and writer visual trees to indicate access to different functionality of the shared compositional resource by the respective processes. For example the composition engine may be configured to support a writer reader paradigm to enforce a security model for access to the shared compositional resource . A reader process for instance may be configured to specify what element is displayed as part of the shared compositional resource . The writer process on the other hand is configured to specify how the specified element of the shared compositional resource is displayed.

In another example as illustrated the shared compositional resource is included in a graph e.g. a compositional tree. The graph is configured to follow a reader writer paradigm managed by the composition engine for access by the plurality of processes such that a reader process is configured to associate one or more child nodes that specify content to the shared compositional resource in the graph . The writer process is configured to modify one or more visual properties of the content but is not configured to add child nodes i.e. elements to the shared compositional resource . In the illustrated instance the reader visual tree of a reader process includes child nodes of the shared compositional resource whereas the writer process is not configured to add child nodes. This security model may be used to support a variety of different functionality for a variety of different shared composition resources.

As previously described the shared visual component may be configured in a variety of ways one example of which is a float. A writer process for instance may set and or update a float value via an interface that is configured to set a shared float value as a static animation parameter which may be used to drive dependent animations. A reader process on the other hand is not permitted to change the float value and may not even be aware of the value that is set by the writer process. A dependent animation is an animation that is defined by periodic calls from an application to one or more system APIs on a regular cadence with a variable value. Therefore a dependent animation is maintained using constant involvement of the calling code as opposed to those animations that are defined by one single call that describes the value of the animation over time into the future which can be executed by the operating system without further involvement by the application.

The shared composition resource for example may be configured as a float that is configured to specify opacity of a visual e.g. to set opacity to the specified float value. The writer process may create the shared compositional resource i.e. the float which is to be used to specify an amount of opacity. Therefore opacity of an element of the shared resource and child nodes are controlled by a writer process whereas content of the shared resource and child nodes are specified by the reader process through interaction with the composition engine .

Further the composition engine may be configured to manage interaction with the shared compositional resource such that the writer process is not aware of the element being rendered nor is the writer process permitted to specify the element. On the contrary the composition engine may be configured to manage interaction such that the reader process is not aware of how the element is rendered e.g. the opacity applied to content of the element nor is the reader process permitted to specify how the element is rendered in this example. Thus as illustrated the reader writer paradigm may be used to support access to different functionality associated with the shared compositional resource to different processes.

In another example the shared compositional resource may be configured as an animation trigger. Animation triggers may be used to trigger multiple animations from different frameworks at the same time. This may include an animation of a software keyboard with a user interface of a browser. Previously applications were not able to notify a separate running application as to when an animation is to begin. With shared triggers however both the browser and soft keyboard may share the same animation trigger and activate both corresponding animations at the same time.

In a further example the shared compositional resource may be configured as a transform which may be used to modify a visual e.g. in two dimensional or three dimensional space. For instance a system may be configured to support responsive touch inputs. Accordingly touch inputs may be delegated to a dedicated process that is different than a process used to specify the content that is to be affected by the touch inputs.

A writer thread for instance may create a shared compositional resource as a transform that is to be used to move content responsive to a touch input. A reader thread e.g. an application may specify the visual that is to be a subject of the movement e.g. a cursor gaming element and so on. Thus the application does not change the transform but rather specifies the visual that is to be modified by the transform. Further how the visual is modified may be hidden by the writer process from the reader process. In this way the writer process may be changed e.g. to operate differently without affecting the reader process.

Thus either of the reader or writer processes may be changed in the above example without affecting execution of the other process. This abstraction may also be used to support a variety of other functionality such as to support execution of the processes independently use of different priorities security levels and so on. In this way the processes may collaborate through use of the shared resource without be bound to each other through indirect communication via the composition engine .

Although floats animation triggers and transforms were described above the shared compositional resource may be configured in a variety of other ways without departing from the spirit and scope thereof. The shared compositional resource for instance may be configured as a color in which an interface is exposed that accepts color values while another interface accepts a color element. Thus the writer process may specify modifications to the color and the reader process may specify a visual to be modified. Other visuals are also contemplated in which a reader process is permitted to set a visual and the writer process is configured to modify one or more visual properties of the visual. In another instance the shared compositional resource is configured as a usage pattern in which a creator of the shared compositional resource gets a handle to a corresponding object that is duplicated for cross process scenarios. A variety of other examples are also contemplated as further described in relation to the following procedures.

The following discussion describes shared compositional resource techniques that may be implemented utilizing the previously described systems and devices. Aspects of each of the procedures may be implemented in hardware firmware or software or a combination thereof. The procedures are shown as a set of blocks that specify operations performed by one or more devices and are not necessarily limited to the orders shown for performing the operations by the respective blocks. In portions of the following discussion reference will be made to .

Access of a writer process is managed by the composition engine to the shared compositional resource such that the writer process is configured to specify one or more modifications to properties of the shared compositional resource but is not configured to specify the element to be rendered by the composition engine block . Thus in this example the writer process is configured to modify an element but not specify the element to be modified. The reader process is configured to specify the element to be modified but not how the modification is to be performed. In this way a security boundary may be maintained between the processes without either process having full access to the shared compositional resource . A variety of other examples are also contemplated.

In the example system multiple devices are interconnected through a central computing device. The central computing device may be local to the multiple devices or may be located remotely from the multiple devices. In one embodiment the central computing device may be a cloud of one or more server computers that are connected to the multiple devices through a network the Internet or other data communication link. In one embodiment this interconnection architecture enables functionality to be delivered across multiple devices to provide a common and seamless experience to a user of the multiple devices. Each of the multiple devices may have different physical requirements and capabilities and the central computing device uses a platform to enable the delivery of an experience to the device that is both tailored to the device and yet common to all devices. In one embodiment a class of target devices is created and experiences are tailored to the generic class of devices. A class of devices may be defined by physical features types of usage or other common characteristics of the devices.

In various implementations the computing device may assume a variety of different configurations such as for computer mobile and television uses. Each of these configurations includes devices that may have generally different constructs and capabilities and thus the computing device may be configured according to one or more of the different device classes. For instance the computing device may be implemented as the computer class of a device that includes a personal computer desktop computer a multi screen computer laptop computer netbook and so on.

The computing device may also be implemented as the mobile class of device that includes mobile devices such as a mobile phone portable music player portable gaming device a tablet computer a multi screen computer and so on. The computing device may also be implemented as the television class of device that includes devices having or connected to generally larger screens in casual viewing environments. These devices include televisions set top boxes gaming consoles and so on. The techniques described herein may be supported by these various configurations of the computing device and are not limited to the specific examples the techniques described herein.

The cloud includes and or is representative of a platform for content services . The platform abstracts underlying functionality of hardware e.g. servers and software resources of the cloud . The content services may include applications and or data that can be utilized while computer processing is executed on servers that are remote from the computing device . Content services can be provided as a service over the Internet and or through a subscriber network such as a cellular or Wi Fi network.

The platform may abstract resources and functions to connect the computing device with other computing devices. The platform may also serve to abstract scaling of resources to provide a corresponding level of scale to encountered demand for the content services that are implemented via the platform . Accordingly in an interconnected device embodiment implementation of functionality of the functionality described herein may be distributed throughout the system . For example the functionality may be implemented in part on the computing device as well as via the platform that abstracts the functionality of the cloud .

Device also includes communication interfaces that can be implemented as any one or more of a serial and or parallel interface a wireless interface any type of network interface a modem and as any other type of communication interface. The communication interfaces provide a connection and or communication links between device and a communication network by which other electronic computing and communication devices communicate data with device .

Device includes one or more processors e.g. any of microprocessors controllers and the like which process various computer executable instructions to control the operation of device and to implement embodiments of the techniques described herein. Alternatively or in addition device can be implemented with any one or combination of hardware firmware or fixed logic circuitry that is implemented in connection with processing and control circuits which are generally identified at . Although not shown device can include a system bus or data transfer system that couples the various components within the device. A system bus can include any one or combination of different bus structures such as a memory bus or memory controller a peripheral bus a universal serial bus and or a processor or local bus that utilizes any of a variety of bus architectures.

Device also includes computer readable media such as one or more memory components examples of which include random access memory RAM non volatile memory e.g. any one or more of a read only memory ROM flash memory EPROM EEPROM etc. and a disk storage device. A disk storage device may be implemented as any type of magnetic or optical storage device such as a hard disk drive a recordable and or rewriteable compact disc CD any type of a digital versatile disc DVD and the like. Device can also include a mass storage media device .

Computer readable media provides data storage mechanisms to store the device data as well as various device applications and any other types of information and or data related to operational aspects of device . For example an operating system can be maintained as a computer application with the computer readable media and executed on processors . The device applications can include a device manager e.g. a control application software application signal processing and control module code that is native to a particular device a hardware abstraction layer for a particular device etc. . The device applications also include any system components or modules to implement embodiments of the techniques described herein. In this example the device applications include an interface application and an input output module that are shown as software modules and or computer applications. The input output module is representative of software that is used to provide an interface with a device configured to capture inputs such as a touchscreen track pad camera microphone and so on. Alternatively or in addition the interface application and the input output module can be implemented as hardware software firmware or any combination thereof. Additionally the input output module may be configured to support multiple input devices such as separate devices to capture visual and audio inputs respectively.

Device also includes an audio and or video input output system that provides audio data to an audio system and or provides video data to a display system . The audio system and or the display system can include any devices that process display and or otherwise render audio video and image data. Video signals and audio signals can be communicated from device to an audio device and or to a display device via an RF radio frequency link S video link composite video link component video link DVI digital video interface analog audio connection or other similar communication link. In an embodiment the audio system and or the display system are implemented as external components to device . Alternatively the audio system and or the display system are implemented as integrated components of example device .

Although the invention has been described in language specific to structural features and or methodological acts it is to be understood that the invention defined in the appended claims is not necessarily limited to the specific features or acts described. Rather the specific features and acts are disclosed as example forms of implementing the claimed invention.

