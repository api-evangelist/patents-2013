---

title: Methods and apparatuses for shared state information among concurrently running processes or threads
abstract: In a system where data is shared by a first module writing the information to memory, and a second module then reading the information from the memory, asynchronous and/or unpredictable operation of the two modules may lead to instances of blocking and/or instances of the second module reading invalid data from the memory. Aspects of the present disclosure manage reads and writes to memory such that blocking by either the first module and/or the second module, and/or reads of invalid data by the second module, may be prevented if so desired.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09141310&OS=09141310&RS=09141310
owner: Google Inc.
number: 09141310
owner_city: Mountain View
owner_country: US
publication_date: 20130625
---
This application claims the benefit of U.S. Provisional Application No. 61 665 283 filed Jun. 27 2012.

Conventional methods and systems for sharing state information can be inefficient in terms of resource usage or in predictability of performance. Further limitations and disadvantages of conventional and traditional approaches will become apparent to one of skill in the art through comparison of such approaches with some aspects of the present method and apparatus set forth in the remainder of this disclosure with reference to the figures.

In one embodiment the present disclosure provides a system including a mutator an observer an N element memory array a first pointer used by the mutator for writing to the N element memory array a second pointer used by the first observer for reading from the N element memory array and a third pointer. In response to a first function being called by the mutator the system may be configured to provide the first pointer to the mutator. In response to a second function being called by the mutator the system may be configured to set the third pointer equal to the first pointer and then circularly advances the first pointer. In response to a third function being called by the mutator the system may be configured to set the second pointer equal to the third pointer and then provides the second pointer to the observer.

In another embodiment the present disclosure provides a method performed by a system. The system may include a mutator an observer an N element memory array a first pointer used by the mutator for writing to the N element memory array a second pointer used by the observer reading the N element memory array and a third pointer. The method may include providing the first pointer to the mutator in response to a first function being called by the mutator. The method may also include setting the third pointer equal to the first pointer and then circularly advancing the first pointer in response to a second function being called by the mutator. The method may also include setting the second pointer equal to the third pointer and then providing the second pointer to the observer in response to a third function being called by the observer.

In yet another embodiment the present disclosure provides a computer readable storage device encoded with a computer program the program comprising instructions that if executed by one or more computers cause the one or more computers to perform operations. The operations may include providing a first pointer to a mutator in response to a first function being called by the mutator. The operations may also include setting a third pointer equal to the first pointer and then circularly advancing the first pointer in response to a second function being called by the mutator. The operations may also include setting a second pointer equal to the third pointer and then providing the second pointer to the observer in response to a third function being called by the observer.

These as well as other aspects advantages and alternatives will become apparent to those of ordinary skill in the art by reading the following detailed description with reference where appropriate to the accompanying drawings.

In the following detailed description reference is made to the accompanying figures which form a part hereof. In the figures similar symbols typically identify similar components unless context dictates otherwise. The illustrative embodiments described in the detailed description figures and claims are not meant to be limiting. Other embodiments may be utilized and other changes may be made without departing from the scope of the subject matter presented herein. It will be readily understood that the aspects of the present disclosure as generally described herein and illustrated in the figures can be arranged substituted combined separated and designed in a wide variety of different configurations all of which are explicitly contemplated herein.

The processing module may be operable to execute lines of code e.g. code corresponding to an operating system and or one or more applications programs to effect operation of the electronic device . The processing module may be operable to run multiple modules concurrently. The processing module may be operable to manage accesses to memory such that memory usage is kept low i.e. copying of state information is avoided when possible and concurrently running modules can share information with one another via the memory without blocking each other i.e. without one preventing the other from accessing needed information in the memory for an unpredictable and or intolerable amount of time.

In an example implementation the processing module comprises one or more processing cores . In such an implementation a first of a pair of concurrently running modules e.g. threads or processes may run on a first processing core and a second of the pair of concurrently running modules may run on a second processing core . In another example implementation the processing module may be for example a VHDL entity compiled synthesized and programmed into an FPGA or ASIC along with a pair of concurrently running modules each of which may also be for example a VHDL entity compiled synthesized and programmed into the FPGA or ASIC.

The memory module may comprise volatile and or non volatile memory. The memory module may comprise cache memory main memory and or configuration registers. The memory module may store for example general data configuration parameters program code and or run time data generated by the processing module while executing program code. The memory module may be distributed among various components of the device .

The input output I O module may enable a user to interact with the electronic device . In this regard the I O module may support various types of inputs and or outputs including video audio and or text. I O devices and or components external or internal may be utilized for inputting and or outputting data during operations of the I O module . The I O module may comprise for example control s a microphone and speaker s .

The controls may comprise for example a touchscreen and or one or more hard buttons that enable a user to interact with the device . The microphone may be operable to convert acoustic waves into digital electronic signals which may then be stored and or processed as one or more audio tracks. The speaker s may be operable to convert electronic signals representing one or more audio tracks to corresponding acoustic waves.

In operation a first module observer may need data from a second module mutator that runs concurrently with the first module. A mutator when invoked is a function that changes the value of an attribute of a structured type. Mutator functions are invoked for each attribute of the instance to assign values to each attribute. There are two parameters to any mutator function. The first parameter is implicit and is the instance of the type. The second parameter is explicit and is the value assigned to the attribute. The value returned by a mutator function is a new instance of the type with the modified attribute value. An observer is the opposite of a mutator its job is to retrieve the value of an attribute of a structured type.

Data may be provided from the mutator to the observer by the mutator writing the information to the memory and the observer then reading the information from the memory . During operation however the mutator and observer may each cycle between an idle state and an active state and do so with different periods e.g. the mutator may cycle with an average period T and the observer may cycle with an average period of T . Moreover the periods may be variable and may be asynchronous with respect to each other such that the observer may be unable to predict when the mutator will be writing to memory and the mutator may be unable to predict when the observer will be reading from memory. Moreover even if one could predict when the other would be accessing memory waiting for such access could lead to error or undesirable effects. Consequently absent aspects of this disclosure instances of blocking and or instances of the observer reading invalid data from the memory would likely occur. Aspects of this disclosure however manage reads and writes to memory such that blocking by either the observer and or the mutator and or reads of invalid data by the observer may be prevented if so desired.

The memory array may comprise N an integer number elements corresponding to N locations in memory . Each element of the array may be operable to store one or more bits of data. In an example implementation the observer and mutator are mixers and data stored in the memory array comprises information about audio tracks being processed by the device in which the system resides e.g. device and or about a configuration of one or more modules e.g. the I O module that process audio.

The observer may be operable to maintain a previous pointer and a current pointer . The mutator may be operable to maintain a write pointer . The memory manager may be operable to maintain pointers mExpecting mCurrent mAck Next mNext and mMutating . Each of the pointers may point to elements of the memory array and may be operable to store a memory address. The memory manager may be operable to maintain variables mInitialized mIsDirty and mInMutation . Each of the variables may correspond to locations in memory and be operable to store Boolean values.

In operation the observer may need state information from the mutator . This state information may be provided from the mutator to the observer by the mutator writing the information to the memory array and the observer subsequently reading the information from the memory array . These reads and writes may be managed by the memory manager . More specifically the mutator and the observer may each interact with the memory manager via a respective application programming interface API in order to obtain pointers to be utilized for reading from and writing to the memory array . Use of the API may enable the observer to directly use state information in the memory array without having to make a copy of the state information. The API via which the mutator interfaces with the memory manager may comprise a Begin function an End function and a Push function. The API via which the observer interfaces with the memory manager may comprise a Poll function. Example steps of these functions are described below with reference to . An example sequence of function calls is described below with respect to .

In function it is determined whether variable mIsDirty is asserted. In other words it is determined whether state information in the memory array has been modified since the last successful Push . If yes then the functions proceed to function .

In function it is determined whether a Push acknowledgement is expected. If not then the functions proceed to function .

In function the pointer mNext is set equal to the pointer mMutating i.e. mNext is set to point to the same memory location as mMutating . In an example implementation this may be achieved through a linearizable releasing store of mNext such that it appears to the mutator and the observer as if it occurred instantaneously. In this manner the observer may be prevented from reading an invalid value of mMutating while mMutating is in the process of changing from one value to another.

In function the pointer mExpecting is set equal to the pointer mMutating . After function the functions proceed to function .

In function the pointer mMutating is circularly advanced i.e. modified to point to the next element of the memory array and wrapped around to point to the first element of memory array if it was pointing to last element of memory array . For example the memory array may have four elements and the element pointed to by mMutating before and after the circular advancement may be as shown in table 1 below.

In function the memory manager copies state information from the element of memory array pointed to by mMutating before mMutating was circularly advanced to the mutator . The memory manager then copies state information from the element of memory array pointed to by mMutating after mMutating was circularly advanced to the mutator and the memory manager merges the previous copied state information with the current copied state information. As a result the mutator only needs to write changed state information to the memory array and does not have to rewrite unchanged state information.

In function the memory manager de asserts the variable mIsDirty . After function the functions proceed to function .

In function it is determined whether a Push acknowledgement is expected. If not then the functions proceed to function and the Push has successfully completed.

Returning to function if a Push acknowledgment is expected then in function it is determined whether the push has been acknowledged yet. In an example implementation this may involve a linearizable acquiring load of mAck and then a comparison of mAck and mExpecting . If the Push has been acknowledged then the steps proceed to step and the Push has successfully completed.

Returning to function if the expected Push acknowledgement has not yet been received then in function it is determined whether blocking is allowed. If no blocking is allowed then the functions proceed to function and the Push exits without successful completion. Consequently the current state pointed to by mMutating remains dirty mIsDirty remains asserted and the Push may be attempted again later as needed.

Returning to function if blocking is allowed then the functions proceed to function . In function advancement of the functions pauses for determined amount of time i.e. a busy wait operation is performed and then the functions return to previously described step .

Returning to function if a Push acknowledgment is expected then the functions proceed to function . In function it is determined whether the expected Push acknowledgement has been received yet. If so then the functions proceed to the previously described function .

Returning to function if the expected Push acknowledgement has not yet been received then in function it is determined whether blocking is allowed. If no blocking is allowed then the functions proceed to function and the Push exits without successful completion.

Returning to function if blocking is allowed then the functions proceed to function . In function advancement of the functions pauses for a determined amount of time i.e. a busy wait operation is performed and then the functions return to previously described function .

Returning to function if mIsDirty is not asserted then the functions proceed to previously described function .

In the implementation described in the system is prevented from performing a Push when a previous Push has not yet been acknowledged. In other implementations a Push may be performed without waiting for a previous Push to be acknowledged. In such an implementation the number of consecutive Push calls without an acknowledgement may be limited for example by the number of consecutive changes to the state information that the observer can miss without introducing unacceptable errors.

In function the pointer Next is set equal to the pointer mNext . In an example implementation this may be achieved through a linearizable acquiring load of mNext such that it appears to the mutator and the observer as if it occurred instantaneously. In this manner the observer may be prevented from reading an invalid value of mNext while mNext is in the process of changing from one value to another. After function the steps proceed to function . In function it is determined whether the pointer Next is different i.e. points to a different memory location than the pointer mCurrent . If not then in function it is determined that there has been no change in state such that the observer can continue to use the current state.

Returning to function if the pointer Next is different i.e. points to a different memory location than the pointer mCurrent then a Push has not been acknowledged. Accordingly in function the Push may be acknowledged by setting the pointer mAck equal to the pointer Next . In an example implementation this may be achieved through a linearizable releasing store of mAck such that it appears to the mutator and the observer as if it occurred instantaneously. After function the steps proceed to function .

In function the pointer mCurrent may be set equal to the pointer Next . In functions and Next may be used rather than mNext because mNext may change value between function and and or between functions and . After function the functions proceed to function .

Referring to from time T to time T the system may startup and mMutating may be initialized. The state of the system at time T is shown in . Question marks indicate unknown contents that have not yet been initialized.

Referring back to between time T and time T the Begin function is executed and the mutator stores state information to the element pointed to by mMutating just prior to time T. The state of system at time T is shown in . The arrow indicates that the pointer mMutating has been provided by memory manager to mutator . Memory manager links the write pointer with pointer mMutating .

Referring back to between time T and time T the End didModify True function is executed. The state of system at time T is shown in .

Referring back to between time T and time T the Push function is executed. The state of the system at time T is shown in . The arrow indicates that pointer mNext has been set equal to pointer mMutating . As shown in mMutating is incremented to a next value at address F. The arrow indicates that pointer mExpecting has been set equal to mMutating value at address F mExpecting is different than mAck indicating that an acknowledgment is expected .

Referring back to between time T and T the Begin function is executed and the mutator stores state information to the element pointed to by mMutating just prior to time T. The state of system at time T is shown in . The arrow indicates that the pointer mMutating has been provided by memory manager to mutator . Memory manager links the write pointer with pointer mMutating .

Referring back to between time T and time T the End function is executed. The state of system at time T is shown in .

Referring back to between time T and time T the mutator calls Push BLOCK NEVER but the function returns false because the previous push performed between time T and T has not yet been acknowledged. Subsequently the Poll function is executed. The state of the system at time T is shown in . The arrow indicates that pointer Next has been set equal to pointer mNext . The arrow indicates that the pointer mCurrent has been set equal to pointer Next . The arrow indicates that the pointer mAck has been set equal to pointer Next which is equal to mCurrent thus acknowledging the Push performed between time T and T . The arrow indicates that the pointer Next has been provided to the observer which has set current pointer equal to pointer Next . The arrow indicates that the previous pointer has been set equal to current pointer .

Referring back to between time T and T the Push function is executed. The state of the system at time T is shown in . The arrow indicates that pointer mNext has been set equal to pointer mMutating . As shown in mMutating is incremented to a next value at address F. The arrow indicates that pointer mExpecting has been set equal to mMutating value at address F mExpecting is different than mack indicating that an acknowledgment is expected .

Referring back to between time T and time T the observer and mutator continue to interact with the memory manager via the respective APIs such that the state of the system continues to be modified. The details of these interactions are omitted for brevity and the resumes at arbitrarily selected time T.

Between time T and T a begin operation is executed. The state of system at time T is shown in . The arrow indicates that the pointer mMutating has been provided to the mutator where write pointer has been set equal to mMutating .

Referring back to between time T and T the mutator begins modifying the element pointed to by mMutating but the observer calls the Poll function before the modification of the state information is completed. Thus at the time instant that Next is set equal to mNext the contents pointed to by mMutating are invalid. The observer however is unaffected by this invalid data because it uses the element of memory array pointed to by mNext . In this instance the element of memory array pointed to by mNext is the same as the element pointed to by mCurrent and thus the observer continues to use the element of memory array at address F.

Referring back to between time T and T the state modification begun prior to time T completes and the End function is executed. The state of system at time T is shown in .

Referring back to between Time T and T the Push function and Poll function are called and execute concurrently. This results in a race condition. The state of system at time T depends on which function wins the race.

Next the mutator pushes new state information C to the system. Initially the pointer Previous points to the previous state information A and the pointer mCurrent points to the state information B . The pointers mNext and mExpecting point to the state information C . The pointer mAck does not point to any elements at this time.

Next at step the observer acknowledges the addition of state information C to the system. The observer may acknowledge the addition of state information C by observing the pointer mCurrent. The memory manager may set the pointer Next equal to the pointer mCurrent and the pointer Next equal to the pointer mAck. The pointer Previous points to the state information B while the pointers mCurrent mNext mExpecting and mAck point to the state information C . Finally at step the memory manager recognizes the acknowledgement since the memory manager causes mExpecting to point to no elements. As such the memory manager can re use slot A . At this stage the pointer Previous points to state information B while the pointers mCurrent mNext and mAck point to the state information C . The pointer mExpecting does not point to any elements at this time since the memory manager already recognizes the acknowledgement.

Other implementations may provide a computer readable medium and or storage medium and or a machine readable medium and or storage medium having stored thereon a machine code and or a computer program having at least one code section executable by a machine and or a computer thereby causing the machine and or computer to perform the steps as described herein for shared state information among concurrently running processes or threads.

Accordingly the present method and or apparatus may be realized in hardware software or a combination of hardware and software. The present method and or apparatus may be realized in a centralized fashion in at least one computing system or in a distributed fashion where different elements are spread across several interconnected computing systems. Any kind of computing system or other apparatus adapted for carrying out the methods described herein is suited. A typical combination of hardware and software may be a general purpose computing system with a program or other code that when being loaded and executed controls the computing system such that it carries out the methods described herein. Another typical implementation may comprise an application specific integrated circuit or chip.

The present method and or apparatus may also be embedded in a computer program product which comprises all the features enabling the implementation of the methods described herein and which when loaded in a computer system is able to carry out these methods. Computer program in the present context means any expression in any language code or notation of a set of instructions intended to cause a system having an information processing capability to perform a particular function either directly or after either or both of the following a conversion to another language code or notation b reproduction in a different material form.

While the present method and or apparatus has been described with reference to certain implementations it will be understood by those skilled in the art that various changes may be made and equivalents may be substituted without departing from the scope of the present method and or apparatus. In addition many modifications may be made to adapt a particular situation or material to the teachings of the present disclosure without departing from its scope. Therefore it is intended that the present method and or apparatus not be limited to the particular implementations disclosed but that the present method and or apparatus will include all implementations falling within the scope of the appended claims.

