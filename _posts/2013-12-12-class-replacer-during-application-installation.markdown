---

title: Class replacer during application installation
abstract: This disclosure describes systems, methods, and computer-readable media related to online advertisement campaign recommendations. An archive file may be received from a server. The archive file may include one or more compiled code files and a manifest file. The archive file may be unpackaged. The one or more compiled code files may be optimized based at least in part on the manifest file. The optimizing the one or more compiled code files may include identifying a first sequence of bytes and a second sequence of bytes from one or more sources; formatting the second sequence of bytes based at least in part on one or more rules; searching the one or more compiled code files to identify one or more sequence of bytes matching the first sequence of bytes; and replacing the identified one or more sequence of bytes with the formatted second sequence of bytes. The optimized compiled code files may be stored.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09280339&OS=09280339&RS=09280339
owner: Amazon Technologies, Inc.
number: 09280339
owner_city: Reno
owner_country: US
publication_date: 20131212
---
Applications and software packages may be developed for different types of devices such as cell phones tablets laptops and the like. Software developers may create the applications and software packages using specific libraries and application programming interfaces APIs . The applications and software packages may need to be updated in order to work properly on specific user devices. However updating specific lines of code in the application and software packages to replace class or package names may be a tedious and inaccurate especially as the different class or package names may involve drastically different naming conventions and files paths.

The process for updating software packages or applications for specific user devices may be cumbersome or imprecise thus resulting in inefficient and failed installation of the software packages or applications on user devices. A class replacer may enable software packages or applications to be updated efficiently and accurately for different user devices. Specific class names or package names may be identified in one or more sources to be replaced by a different sequence of bytes. Each user device may update the software packages or applications during installation without the need to have different software packages or applications developed for each specific user device.

This disclosure relates to among other things systems methods computer readable media techniques and methodologies for a class replacer during application installation. An application developer may develop an application or software package for distribution to user devices. The class replacer may enable a framework to change linkage of the application or software package at install time from what the application or software package was compiled against prior to distribution. For instance the application developer may have developed the application or software package using a particular library. However in order for the application or software package to work properly on a specific tablet device the application or software package may need to utilize a different library. The class replacer enables the framework to efficiently and accurately update the linkage of the application or software package to the new library without having to individually update each compiled code file associated with the software package or application.

In some embodiments the software package or application may be distributed as an archive file such as a Java Archive JAR or Dalvik Executable DEX file. The archive file may include one or more compiled code files. In some embodiments the archive file may also include resources such as videos images sounds or the like and metadata. The archive file may include instructions or indications of replacement sequence of bytes pairs to update the compiled code files for a particular user device. The user device may receive the archive file and unpackage the archive file. The user device may identify the replacement sequence of bytes pairs that include at least a first sequence of bytes that is to be replaced by a second sequence of bytes. The second sequence of bytes may be formatted based at least in part on one or more rules. In some embodiments one or more rules may be applied to the first and second sequence of bytes to simulate output of a compiler. The compiled code files may be systematically searched to identify all sequence of bytes matching the first sequence of bytes. All identified sequence of bytes matching the first sequence of bytes may be replaced by the second sequence of bytes. The updated compiled code files may then be stored by the user device.

Various illustrative embodiments have been discussed above. These and other example embodiments of the disclosure will be described in more detail hereinafter through reference to the accompanying drawings. The drawings and the corresponding description are provided merely for illustration and are not intended to limit the disclosure in any way. It should be appreciated that numerous other embodiments variations and so forth are within the scope of this disclosure.

In various example embodiments a user application e.g. a browser application executing on a developer workstation may communicate with an app store sever . The user may be a developer who developed an application and is transmitting or uploading the files associated with the application to the app store server for distribution to different user device s . In some embodiments the user may sign into a web interface for the app store using the developer workstation . The user may upload or otherwise make available the application developed by the user to the app store server . In some embodiments the user may upload or make available an archive file. The archive file may include one or more compiled code files such as a Java class file and a manifest file.

The app store server may receive the application from the user . The app store server may determine one or more class or package names need to be modified or updated. In some embodiments the app store server may transmit a request to the user to update or modify the files associated with the application. Responsive to receiving approval from the user the app store server may unpackage the archive file and modify the manifest file to include instructions to replace specified sequence of bytes in the compiled code files during installation on the user device . The app store server may repackage the archive file with the modified manifest file. The app store server may transmit the updated archive file to one or more user devices .

One or more illustrative user device s operable by one or more users are illustratively depicted in The user device s may include any suitable device capable of developing applications and receiving and transmitting data with other computing devices. The user device s may include any suitable processor driven computing device including but not limited to a laptop computing device a tablet device a desktop computing device smartphone or other cellular device a gaming console a multimedia content streaming device a set top box and so forth. For ease of explanation the user device s may be described herein in the singular however it should be appreciated that multiple user device s may be provided. The user device s may transmit a request to the app store server to download an application. Responsive to the request the app store server may transmit the archive file to the requesting user device . The user device may receive the archive file unpackage the archive file and optimize the compiled code files based at least in part on the instructions in the manifest file. During the optimization a module of the user device may parse the manifest file to identify a pair of replacement sequence of bytes to replace in the compiled code files. In some embodiments the replacement sequence of bytes pair may be separated by a colon. Additional replacement sequence of bytes pairs may be supplied and separated by commas. Sequence of bytes may be replaced in order where the first match wins.

Any of the developer workstation s app store server s and or user device s may be configured to communicate with each other and any other component of the system architecture via one or more network s . The network s may include but are not limited to any one or a combination of different types of suitable communications networks such as for example cable networks public networks e.g. the Internet private networks wireless networks cellular networks or any other suitable private and or public networks. Further the network s may have any suitable communication range associated therewith and may include for example global networks e.g. the Internet metropolitan area networks MANs wide area networks WANs local area networks LANs or personal area networks PANs . In addition the network s may include any type of medium over which network traffic may be carried including but not limited to coaxial cable twisted pair wire optical fiber a hybrid fiber coaxial HFC medium microwave terrestrial transceivers radio frequency communication mediums satellite communication mediums or any combination thereof.

The developer workstation s may include one or more processor s that may include any suitable processing unit capable of accepting digital data as input processing the input data based on stored computer executable instructions and generating output data. The computer executable instructions may be stored for example in the data storage and may include among other things operating system software and application software. The computer executable instructions may be retrieved from the data storage and loaded into the memory as needed for execution. The processor s may be configured to execute the computer executable instructions to cause various operations to be performed. The processor s may include any type of processing unit including but not limited to a central processing unit a microprocessor a microcontroller a Reduced Instruction Set Computer RISC microprocessor a Complex Instruction Set Computer CISC microprocessor an Application Specific Integrated Circuit ASIC a System on a Chip SoC a field programmable gate array FPGA and so forth.

The data storage may store program instructions that are loadable and executable by the processor s as well as data manipulated and generated by the processor s during execution of the program instructions. The program instructions may be loaded into the memory as needed for execution. Depending on the configuration and implementation of the developer workstation s the memory may be volatile memory memory that is not configured to retain stored information when not supplied with power such as random access memory RAM and or non volatile memory memory that is configured to retain stored information even when not supplied with power such as read only memory ROM flash memory and so forth. In various implementations the memory may include multiple different types of memory such as various forms of static random access memory SRAM various forms of dynamic random access memory DRAM unalterable ROM and or writeable variants of ROM such as electrically erasable programmable read only memory EEPROM flash memory and so forth.

Various program modules applications or the like may be stored in data storage that may comprise computer executable instructions that when executed by the processor s cause various operations to be performed. The memory may have loaded from the data storage one or more operating systems O S that may provide an interface between other application software e.g. dedicated applications a browser application a web based application a distributed client server application etc. executing on the developer workstations and the hardware resources of the developer workstations . More specifically the O S may include a set of computer executable instructions for managing the hardware resources of the developer workstations and for providing common services to other application programs e.g. managing memory allocation among various application programs . The O S may include any operating system now known or which may be developed in the future including but not limited to any mobile operating system desktop or laptop operating system mainframe operating system or any other proprietary or open source operating system.

The data storage may additionally include various other program modules that may include computer executable instructions for supporting a variety of associated functionality. For example the data storage may include one or more application s and or one or more web browser s . In some embodiments one or more application s may be used to develop an application or software package by the user generate an archive file based at least in part on developed application or software package and transmit the generated archive file to an app store server . In some embodiments a user may launch a web browser to communicate and or exchange information with one or more app store server s .

The app store server s may include one or more processors processor s and one or more memories referred to herein generically as memory . The processor s may include any suitable processing unit capable of accepting digital data as input processing the input data based on stored computer executable instructions and generating output data. The computer executable instructions may be stored for example in the data storage and may include among other things operating system software and application software. The computer executable instructions may be retrieved from the data storage and loaded into the memory as needed for execution. The processor s may be configured to execute the computer executable instructions to cause various operations to be performed. The processor s may include any type of processing unit including but not limited to a central processing unit a microprocessor a microcontroller a Reduced Instruction Set Computer RISC microprocessor a Complex Instruction Set Computer CISC microprocessor an Application Specific Integrated Circuit ASIC a System on a Chip SoC a field programmable gate array FPGA and so forth.

The data storage may store program instructions that are loadable and executable by the processor s as well as data manipulated and generated by the processor s during execution of the program instructions. The program instructions may be loaded into the memory as needed for execution. Depending on the configuration and implementation of the app store server s the memory may be volatile memory memory that is not configured to retain stored information when not supplied with power such as random access memory RAM and or non volatile memory memory that is configured to retain stored information even when not supplied with power such as read only memory ROM flash memory and so forth. In various implementations the memory may include multiple different types of memory such as various forms of static random access memory SRAM various forms of dynamic random access memory DRAM unalterable ROM and or writeable variants of ROM such as electrically erasable programmable read only memory EEPROM flash memory and so forth.

The app store server s may further include additional data storage such as removable storage and or non removable storage including but not limited to magnetic storage optical disk storage and or tape storage. Data storage may provide non volatile storage of computer executable instructions and other data. The memory and or the data storage removable and or non removable are examples of computer readable storage media CRSM .

The app store server s may further include network interface s that facilitate communication between the app store server s and other devices of the illustrative system architecture e.g. developer workstation s user device s etc. or application software via the network s . The app store server s may additionally include one or more input output I O interfaces and optionally associated software components such as device drivers that may support interaction between a user and a variety of I O devices such as a keyboard a mouse a pen a pointing device a voice input device a touch input device a display speakers a camera a microphone a printer and so forth.

Referring again to the data storage various program modules applications or the like may be stored therein that may comprise computer executable instructions that when executed by the processor s cause various operations to be performed. The memory may have loaded from the data storage one or more operating systems O S that may provide an interface between other application software e.g. dedicated applications a browser application a web based application a distributed client server application etc. executing on the app store server s and the hardware resources of the app store server s . More specifically the O S may include a set of computer executable instructions for managing the hardware resources of the app store server s and for providing common services to other application programs e.g. managing memory allocation among various application programs . The O S may include any operating system now known or which may be developed in the future including but not limited to any mobile operating system desktop or laptop operating system mainframe operating system or any other proprietary or open source operating system.

The data storage may further include one or more database management systems DBMS for accessing retrieving storing and or manipulating data stored in one or more datastores. The DBMS may use any of a variety of database models e.g. relational model object model etc. and may support any of a variety of query languages.

The data storage may additionally include various other program modules that may include computer executable instructions for supporting a variety of associated functionality. For example the data storage may include one or more archive file review module s . The archive file review module s may include computer executable instructions that in response to execution by the processor s cause operations to be performed including determining that the compiled code files may need to be updated generating a request to the user that developed or generated the archive file to request permission or approval to update the compiled code files modifying the manifest file based at least in part on the permission or approval from the user and then preparing and transmitting the archive file to one or more requesting user devices for installation.

Within the data storage one or more modules may be stored. As used herein the term module may refer to a functional collection of instructions that may be executed by the one or more processor s . For ease of description and not by way of limitation separate modules are described. However it is understood that in some implementations the various functions provided by the modules may be merged separated and so forth. Furthermore the modules may intercommunicate or otherwise interact with one another such that the conditions of one affect the operation of another.

The user device s may include one or more processors processor s and one or more memories referred to herein generically as memory . The processor s may include any suitable processing unit capable of accepting digital data as input processing the input data based on stored computer executable instructions and generating output data. The computer executable instructions may be stored for example in the data storage and may include among other things operating system software and application software. The computer executable instructions may be retrieved from the data storage and loaded into the memory as needed for execution. The processor s may be configured to execute the computer executable instructions to cause various operations to be performed. The processor s may include any type of processing unit including but not limited to a central processing unit a microprocessor a microcontroller a Reduced Instruction Set Computer RISC microprocessor a Complex Instruction Set Computer CISC microprocessor an Application Specific Integrated Circuit ASIC a System on a Chip SoC a field programmable gate array FPGA and so forth.

The data storage may store program instructions that are loadable and executable by the processor s as well as data manipulated and generated by the processor s during execution of the program instructions. The program instructions may be loaded into the memory as needed for execution. Depending on the configuration and implementation of the user device s the memory may be volatile memory memory that is not configured to retain stored information when not supplied with power such as random access memory RAM and or non volatile memory memory that is configured to retain stored information even when not supplied with power such as read only memory ROM flash memory and so forth. In various implementations the memory may include multiple different types of memory such as various forms of static random access memory SRAM various forms of dynamic random access memory DRAM unalterable ROM and or writeable variants of ROM such as electrically erasable programmable read only memory EEPROM flash memory and so forth.

The user device s may further include additional data storage such as removable storage and or non removable storage including but not limited to magnetic storage optical disk storage and or tape storage. Data storage may provide non volatile storage of computer executable instructions and other data. The memory and or the data storage removable and or non removable are examples of computer readable storage media CRSM .

The user device s may further include network interface s that facilitate communication between the user device s and other devices of the illustrative system architecture e.g. developer workstation s app store server s etc. or application software via the network s . The user device s may additionally include one or more input output I O interfaces and optionally associated software components such as device drivers that may support interaction between a user and a variety of I O devices such as a keyboard a mouse a pen a pointing device a voice input device a touch input device a display speakers a camera a microphone a printer and so forth.

Referring again to the data storage various program modules applications or the like may be stored therein that may comprise computer executable instructions that when executed by the processor s cause various operations to be performed. The memory may have loaded from the data storage one or more operating systems O S that may provide an interface between other application software e.g. dedicated applications a browser application a web based application a distributed client server application etc. executing on the user device s and the hardware resources of the user device s . More specifically the O S may include a set of computer executable instructions for managing the hardware resources of the user device s and for providing common services to other application programs e.g. managing memory allocation among various application programs . The O S may include any operating system now known or which may be developed in the future including but not limited to any mobile operating system desktop or laptop operating system mainframe operating system or any other proprietary or open source operating system.

The data storage may further include one or more database management systems DBMS for accessing retrieving storing and or manipulating data stored in one or more datastores. The DBMS may use any of a variety of database models e.g. relational model object model etc. and may support any of a variety of query languages.

The data storage may additionally include various other program modules that may include computer executable instructions for supporting a variety of associated functionality. For example the data storage may include one or more archive file optimization module s . The archive file optimization module may include one or more class replacer s .

The archive file optimization module s may include computer executable instructions that in response to execution by the processor s cause operations to be performed including receiving an archive file unpackaging the archive file and or optimizing the archive file based at least in part on information obtained from the manifest file. In some embodiments the archive file optimization module s may parse the manifest file to identify replacement sequence of bytes pairs. The archive file optimization module s may include a class replacer . The class replacer may include computer executable instructions that in response to execution by the processor s cause operations to be performed including identifying a first sequence of bytes and a second sequence of bytes in the replacement sequence of bytes pair where the first sequence of bytes is to be replaced by the second sequence of bytes. The class replacer may retrieve one or more rules and format the second sequence of bytes based at least in part on the one or more rules. The class replacer may then search the one or more compiled code files to find any sequence of bytes that match the first sequence of bytes and replace the first sequence of bytes with the formatted second sequence of bytes.

Within the data storage one or more modules may be stored. As used herein the term module may refer to a functional collection of instructions that may be executed by the one or more processor s . For ease of description and not by way of limitation separate modules are described. However it is understood that in some implementations the various functions provided by the modules may be merged separated and so forth. Furthermore the modules may intercommunicate or otherwise interact with one another such that the conditions of one affect the operation of another.

Those of ordinary skill in the art will appreciate that any of the components of the system architecture may include alternate and or additional hardware software or firmware components beyond those described or depicted without departing from the scope of the disclosure. More particularly it should be appreciated that hardware software or firmware components depicted or described as forming part of any of the illustrative components of the system architecture and the associated functionality that such components support are merely illustrative and that some components may not be present or additional components may be provided in various embodiments. While various program modules have been depicted and described with respect to various illustrative components of the system architecture it should be appreciated that the functionality described as being supported by the program modules may be enabled by any combination of hardware software and or firmware. It should further be appreciated that each of the above mentioned modules may in various embodiments represent a logical partitioning of supported functionality. This logical partitioning is depicted for ease of explanation of the functionality and may not be representative of the structure of hardware software and or firmware for implementing the functionality. Accordingly it should be appreciated that the functionality described as being provided by a particular module may in various embodiments be provided at least in part by one or more other modules. Further one or more depicted modules may not be present in certain embodiments while in other embodiments additional modules not depicted may be present and may support at least a portion of the described functionality and or additional functionality. Further while certain modules may be depicted and described as sub modules of another module in certain embodiments such modules may be provided as independent modules.

Those of ordinary skill in the art will appreciate that the illustrative system architecture is provided by way of example only. Numerous other operating environments system architectures and device configurations are within the scope of this disclosure. Other embodiments of the disclosure may include fewer or greater numbers of components and or devices and may incorporate some or all of the functionality described with respect to the illustrative system architecture or additional functionality.

At block an archive file review module of the app store server may determine that the one or more compiled code files need to have one or more sequence of bytes replaced. The archive file review module may unpackage the received archive file and analyze the compiled code files. In some embodiments the archive file review module may determine if the compiled code files need to be updated by replacing one or more sequence of bytes based at least in part on one or more rules or policies. For example the rules or policies may indicate that the linkage of the application needs to be changed from the linkage that the application was compiled against. The rules and policies may indicate that in order to work properly on a particular user device the linkage must be changed at install time of the application.

At block the archive file review module may transmit a request to the user e.g. developer for permission or approval to update the compiled code files during installation of the application on the user device. In some embodiments the request may be a notification by text email in application message webpage message or the like. The user may respond indicating their approval to update the compiled code files. If the user responds indicating that they do not approve updating the compiled code files then the archive file may be transmitted to a requesting user device without any modifications. In some embodiments block may be optional.

At block the archive file review module may optionally modify the manifest file associated with the compiled code files. In some embodiments the archive file review module may modify a manifest file associated with the compiled code files in response to receiving approval or permission from the user . In some embodiments the archive file review module may modify a manifest file associated with the compiled code files to add replacement sequence of bytes pairs where the replacement sequence of bytes pair indicates that a first sequence of bytes may be replaced by a second sequence of bytes. In some embodiments the user may have provided the replacement sequence of bytes pairs. In some embodiments the manifest file may be modified based at least in part on rules or policies.

At block the archive file review module may update the archive file. In some embodiments the archive file may be updated based at least in part on the compiled code files and or the modified manifest file. In some embodiments the archive file review module may zip or otherwise aggregate the compiled code files the modified manifest file and any other data such as the manifest file metadata or resources into an updated archive file. At block the archive file review module may transmit the updated archive file to one or more user device s . In some embodiments the archive review module may transmit the updated archive file to one or more user device s in response to receiving a request from the one or more user device s to download the archive file.

At block an archive file optimization module may unpackage the archive file. In some embodiments the archive file may be unzipped and stored in a temporary location. At block the archive file optimization module may identify to identify a first and a second sequence of bytes. In some embodiments the first sequence of bytes may be the sequence of bytes to search for in the compiled code files from the archive file. The second sequence of bytes may be the sequence of bytes that should replace any found instances of the first sequence of bytes in the compiled code files. In some embodiments the first and second sequence of bytes may be identified from one or more sources. For example the first and second sequence of bytes may be identified by parsing a manifest file packaged with the archive file from tags created by the developer and included with the archive file from a configuration file from a command line command from a library from a file or the like.

At block the archive file optimization module may format the second sequence of bytes based at least in part on one or more rules and or policies. In some embodiments the archive file optimization module may retrieve the rules and or policies from a database may receive the rules and or policies from the app store server may retrieve the rules and or policies from a library identified by the manifest file and or may otherwise obtain the rules and or policies from other sources. In some embodiments formatting may include applying one or more rules to the first and or second sequence of bytes to simulate output of a compiler.

At block the class replacer may search the compiled code files to identify one or more sequence of bytes matching the first sequence of bytes. In some embodiments the compiled code files may be an array of strings. The class replacer may loop or otherwise systematically analyze each sequence of bytes in each of the compiled code files to identify one or more sequence of bytes matching the first sequence of bytes. In some embodiments the class replacer may also loop through or search other data in the archive file such as the resources and or metadata to identify one or more sequence of bytes matching the first sequence of bytes. If there are multiple replacement sequence of bytes pairs the class replacer may analyze the compiled code files to identify all sequence of bytes identified by the manifest file to be replaced.

At block the class replacer may replace the one or more identified sequence of bytes matching the first sequence of bytes with the second sequence of bytes. The class replacer may update all instances of the identified sequence of bytes matching the first sequence of bytes by replacing the identified sequence of bytes with the second sequence of bytes. At block the archive file optimization module may store the updated compiled code files and additional data if any on the user device .

The operations and processes described and shown above may be carried out or performed in any suitable order as desired in various implementations. Additionally in certain implementations at least a portion of the operations may be carried out in parallel. Furthermore in certain implementations less than or more than the operations described may be performed.

Certain aspects of the disclosure are described above with reference to block and flow diagrams of systems methods apparatuses and or computer program products according to various implementations. It will be understood that one or more blocks of the block diagrams and flow diagrams and combinations of blocks in the block diagrams and the flow diagrams respectively can be implemented by computer executable program instructions. Likewise some blocks of the block diagrams and flow diagrams may not necessarily need to be performed in the order presented or may not necessarily need to be performed at all according to some implementations.

These computer executable program instructions may be loaded onto a special purpose computer or other particular machine a processor or other programmable data processing apparatus to produce a particular machine such that the instructions that execute on the computer processor or other programmable data processing apparatus create means for implementing one or more functions specified in the flow diagram block or blocks. These computer program instructions may also be stored in a computer readable storage media or memory that can direct a computer or other programmable data processing apparatus to function in a particular manner such that the instructions stored in the computer readable storage media produce an article of manufacture including instruction means that implement one or more functions specified in the flow diagram block or blocks. As an example certain implementations may provide for a computer program product comprising a computer readable storage medium having a computer readable program code or program instructions implemented therein said computer readable program code adapted to be executed to implement one or more functions specified in the flow diagram block or blocks. The computer program instructions may also be loaded onto a computer or other programmable data processing apparatus to cause a series of operational elements or steps to be performed on the computer or other programmable apparatus to produce a computer implemented process such that the instructions that execute on the computer or other programmable apparatus provide elements or steps for implementing the functions specified in the flow diagram block or blocks.

Accordingly blocks of the block diagrams and flow diagrams support combinations of means for performing the specified functions combinations of elements or steps for performing the specified functions and program instruction means for performing the specified functions. It will also be understood that each block of the block diagrams and flow diagrams and combinations of blocks in the block diagrams and flow diagrams can be implemented by special purpose hardware based computer systems that perform the specified functions elements or steps or combinations of special purpose hardware and computer instructions.

Conditional language such as among others can could might or may unless specifically stated otherwise or otherwise understood within the context as used is generally intended to convey that certain implementations could include while other implementations do not include certain features elements and or operations. Thus such conditional language is not generally intended to imply that features elements and or operations are in any way required for one or more implementations or that one or more implementations necessarily include logic for deciding with or without user input or prompting whether these features elements and or operations are included or are to be performed in any particular implementation.

Many modifications and other implementations of the disclosure set forth herein will be apparent having the benefit of the teachings presented in the foregoing descriptions and the associated drawings. Therefore it is to be understood that the disclosure is not to be limited to the specific implementations disclosed and that modifications and other implementations are intended to be included within the scope of the appended claims. Although specific terms are employed herein they are used in a generic and descriptive sense only and not for purposes of limitation.

