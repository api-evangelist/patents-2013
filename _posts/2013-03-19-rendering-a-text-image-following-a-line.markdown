---

title: Rendering a text image following a line
abstract: A graphics or image rendering system, such as a map image rendering system, receives image data from an image database in the form of vector data that defines various image objects, such as roads, geographical boundaries, etc., and textures defining text strings to be displayed on the image to provide, for example, labels for the image objects. The imaging rendering system renders the images such that the individual characters of the text strings are placed on the image following a multi-segmented or curved line. This rendering system enables text strings to be placed on a map image so that the text follows the center line of a curved or angled road or other image feature without knowing the specifics of the curvature of the line along which the text will be placed when creating the texture that stores the text string information. This feature provides enhanced visual properties within a map image as it allows, for example, road names to be placed anywhere inside a road following the curvature of the road, thus providing a pleasing visual effect within the map image.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08917276&OS=08917276&RS=08917276
owner: Google Inc.
number: 08917276
owner_city: Mountain View
owner_country: US
publication_date: 20130319
---
This application is a divisional of and claims priority to U.S. patent application Ser. No. 13 244 771 entitled Rendering a Text Image Following a Line filed on Sep. 26 2011 which is a continuation of and claims priority to U.S. patent application Ser. No. 13 174 283 entitled Rendering a Text Image Following a Line filed on Jun. 30 2011 the entire disclosures of which are hereby expressly incorporated by reference herein.

The present disclosure relates to image rendering systems such as electronic map display systems and more specifically to an image rendering engine that renders a text image following a line such as multi segmented line.

Digital maps are found in and may be displayed by a wide variety of devices including mobile phones car navigation systems hand held GPS units computers and many websites. Although digital maps are easy to view and to use from an end user s perspective creating a digital map is a difficult task and can be a time consuming process. In particular every digital map begins with storing in a map database a set of raw data corresponding to millions of streets and intersections and other features to be displayed as part of a map. The raw map data that is stored in the map database and that is used to generate digital map images is derived from a variety of sources with each source typically providing different amounts and types of information. This map data must therefore be compiled and stored in the map database before being accessed by map display or map rendering applications and hardware.

There are of course different manners of digitally rendering map images referred to as digital map images based on map data stored in a map database. One method of rendering a map image is to store map images within the map database as sets of raster or pixelated images made up of numerous pixel data points with each pixel data point including properties defining how a particular pixel in an image is to be displayed on an electronic display device. While this type of map data is relatively easy to create and store the map rendering technique using this data typically requires a large amount of storage space for comprehensive digital map images and it is difficult to manipulate the digital map images as displayed on a display device in very many useful manners.

Another more flexible methodology of rendering images uses what is traditionally called vector image data. Vector image data is typically used in high resolution and fast moving imaging systems such as those associated with gaming systems and in particular three dimensional gaming systems. Generally speaking vector image data or vector data includes data that defines specific image objects or elements also referred to as primitives to be displayed as part of an image via an image display device. In the context of a map image such image elements or primitives may be for example individual roads or road segments text labels areas text boxes buildings points of interest markers terrain features bike paths map or street labels etc. Each image element is generally made up or drawn as a set of one or more triangles of different sizes shapes colors fill patterns etc. with each triangle including three vertices interconnected by lines. Thus for any particular image element the image database stores a set of vertex data points with each vertex data point defining a particular vertex of one of the triangles making up the image element. Generally speaking each vertex data point includes data pertaining to a two dimensional or a three dimensional position of the vertex in an X Y or an X Y Z coordinate system for example and various vertex attributes defining properties of the vertex such as color properties fill properties line width properties for lines emanating from the vertex etc.

During the image rendering process the vertices defined for various image elements of an image to be rendered are provided to and are processed in one or more image shaders which operate in conjunction with a graphics processing unit GPU such as a graphics card or a rasterizer to produce a two dimensional image on a display screen. Generally speaking an image shader is a set of software instructions used primarily to calculate rendering effects on graphics hardware with a high degree of flexibility. Image shaders are well known in the art and various types of image shaders are available in various application programming interfaces APIs provided by for example OpenGL and Direct3D to define special shading functions. Basically image shaders are simple programs in a high level programming language that describe or determine the traits of either a vertex or a pixel. Vertex shaders for example define the traits e.g. position texture coordinates colors etc. of a vertex while pixel or fragment shaders define the traits color z depth and alpha value of a pixel. A vertex shader is called for each vertex in an image element or primitive so that for each vertex input into the vertex shader the vertex shader produces one updated vertex output. Each vertex output by the vertex shader is then rendered as a series of pixels onto a block of memory that will eventually be sent to a display screen. As another example fragment shaders use the vertices output by the vertex shaders to pixelate the image i.e. to determine pixel color values of the image being created. Fragment shaders may fill in or render pixels based on the vertex attribute values of the vertices produced by the vertex shaders by interpolating between the vertex attribute values of different vertices of an image object. In other cases fragments shaders may use predefined textures in the form of pixel color maps to fill in or to pixelate particular areas defined by the vertices of the image object. In this case the textures define pixel values for various images to be rendered and are generally used to render text or an image on a screen.

As a more particular example of image shader technology Direct3D and OpenGL graphic libraries use three basic types of shaders including vertex shaders geometry shaders and pixel or fragment shaders. Vertex shaders are run once for each vertex given to the graphics processor. As noted above the purpose of a vertex shader is to transform a position of a vertex in a virtual space to the two dimensional coordinate at which it appears on the display screen as well as a depth value for the z buffer of the graphics processor . Vertex shaders can manipulate properties such as position color and texture coordinates by setting vertex attributes of the vertices but cannot create new vertices. The output of the vertex shader is provided to the next stage in the processing pipeline which is either a geometry shader if present or the rasterizer. Geometry shaders can add and remove vertices from a mesh of vertices and can be used to generate image geometry procedurally or to add volumetric detail to existing images that would be too costly to process on a central processing unit CPU . If geometry shaders are being used the output is then sent to the rasterizer. Pixel shaders which are also known as fragment shaders calculate the color and light properties of individual pixels in an image. The input to this stage comes from the rasterizer and the fragment shaders operate to fill in the pixel values of the polygons being sent through the graphics pipeline and may use textures to define the pixel values within a particular image object. Fragment shaders are typically used for scene lighting and related effects such as color toning. There is not a one to one relationship between calls to the fragment shader and pixels on the screen as fragment shaders are often called many times per pixel because they are called for every image element or object that is in the corresponding space even if that image object is occluded. However if the occluding object is drawn first the occluded pixels of other objects will generally not be processed in the fragment shader.

The use of vector graphics can be particularly advantageous in a mobile map system in which image data is sent from a centralized map database via a communications network such as the Internet a wireless communications network etc. to one or more mobile or remote devices for display. In particular vector data once sent to the receiving device may be more easily scaled and manipulated e.g. rotated etc. than pixelated raster image data. However the processing of vector data is typically much more time consuming and processor intensive on the image rendering system that receives the data. Moreover using vector image data that provides a higher level of detail or information to be displayed in a map leads to a higher amount of vector data or vertices that need to be sent to the map rendering system from the map database that stores this information which can result in higher bandwidth requirements or downloading time in some cases.

Moreover in the case of both rasterized map images and vector data generated images text such as that used to label streets roads and other features of a map is generally stored as a predetermined image. Such images are hard to manipulate so as to vary the placement of the text. In a pixelated map image for example the text is located in a fixed position with respect to other map features and it is thus difficult if not impossible to change the orientation or placement of the text with respect to other image objects. When using vector data text is typically stored as a fixed image or string that is not tied to other map features and thus can be placed at different locations within a map. However it is still difficult to manipulate the text image to vary placement of the individual characters within the text with respect to one another so as to make the characters of the text image to follow a line such as a multi segmented line i.e. a line having multiple line segments that extend at angles from one another or a line that is curved.

A computer implemented method for rendering an image on a display device includes using a computer device to determine a line within the image along which to render a text string which may be stored as a set of pixelated text characters within an image lookup table to determine a plurality of line segments associated with the line and a range associated with each line segment and to form a text box for each of the plurality of line segments each of the text boxes being oriented to draw text in an upright position along an associated line segment. The method selects one of the text boxes in which to render a text character of the text string selects one of the text characters from the text string and determines if a center of the one of the text characters when rendered in the one of the text boxes on the image will be within the range of the line segment associated with the one of the text boxes. The method thereafter renders the one of the text characters on the display device using the one of the text boxes if the center of the one of the text characters when rendered in the one of the text boxes will be within the range of the line segment associated with the one of the text boxes. Otherwise the method selects a different one of the plurality of text boxes as the one of the text boxes for use in rendering the one of the text characters on the display device e.g. if the center of the one of the text characters when rendered in the one of the text boxes will not be within the range of the line segment associated with the one of the text boxes.

In one embodiment the method further includes selecting each one of the text characters from the text string stored within the image lookup table in turn and for each selected one of the text characters performs the steps of determining if the center of the selected one of the text characters when rendered in the one of the text boxes will be within the range of the line segment associated with the one of the text boxes rendering the selected one of the text characters on the display device using the one of the text boxes if the center of the selected one of the text characters when rendered in the one of the text boxes will be within the range of the line segment associated with the one of the text boxes and otherwise selecting a different one of the plurality of text boxes as the one of the text boxes for use in rendering the selected one of the text characters on the display device. Moreover when determining if the center of the one of the text characters when rendered in the one of the text boxes will be within the range of the line segment associated with the one of the text boxes the method may read a set of encoding data for the one of the text characters the encoding data specifying the center of the one of the text characters in at least one direction and or specifying the width of the one of the text characters.

When forming the text boxes the method may form each of the text boxes oriented along a length of an associated one of the line segments and such that the text boxes have a length in the direction of the length of the associated line segment larger than the range of the associated line segment. In one case the method may form each of the text boxes so that the start of each text box extends a predetermined distance in the direction of the length of the associated line segment before the start of the line segment and so that the end of the text box extends the predetermined distance in the direction of the line segment past the end of the line segment. The predetermined distance may be for example half the width of one of the text characters of the text string stored in the image lookup table when formed in the text box. The method may also form a text box for each of the plurality of line segments so that the height of the text box extends a predetermined distance orthogonally to the direction of an associated line segment. In this case the height of the text box may be the height of one of the text characters of the text string stored in the image lookup table when formed in the text box.

If desired the method may use a fragment shader to determine if the center of the one of the text characters when rendered in the one of the text boxes will be within the range of the line segment associated with the one of the text boxes and to render the one of the text characters on the display device using the one of the text boxes if the one of the text characters when rendered in the one of the text boxes will be within the range of the line segment associated with the one of the text boxes. Moreover the method may use a vertex shader to form the text boxes for the plurality of line segments.

According to another embodiment an image rendering engine includes a communications network interface a processor a memory coupled to the processor a display device coupled to the processor and a number of routines stored in the memory that execute on the processor. A first routine receives via the communications network interface a set of vector data comprising data defining one or more image objects and one or more text string lookup tables wherein one of the text string lookup tables stores text characters of at least one text string as a set of pixelated text characters and stores encoding data defining the center position of each of a plurality of text characters associated with the text string. A second routine determines a plurality of line segments associated with a line along which the text string is to be rendered and a range associated with each line segment. A third routine determines a text box for each of the plurality of line segments each of the text boxes being oriented to draw text in an upright position along an associated line segment. A fourth routine selects one of the text boxes in which to render a text character of the text string selects a next one of the text characters of the text string determines if a center of the selected one of the text characters when rendered in the selected one of the text boxes on the image will be within the range of the line segment associated with the selected one of the text boxes and renders the one of the text characters on the display device using the one of the text boxes if a center of the selected one of the text characters when rendered in the selected one of the text boxes will be within the range of the line segment associated with the selected one of the text boxes. Otherwise the fourth routine selects a different one of the plurality of text boxes as the selected one of the text boxes for use in rendering the selected one of the text characters on the display device.

According to another embodiment a method of rendering text along a line within an image being rendered on a display device includes storing a text string lookup table in a computer memory the text string lookup table including a multiplicity of text characters associated with a text string and encoding data defining a center position of each of the multiplicity of text characters associated with the text string. The method also determines a plurality of line segments associated with a line in the image along which the text string is to be rendered and a range associated with each line segment. The method then forms a text box for each of the plurality of line segments each of the text boxes being oriented to draw text in an upright position along an associated line segment in the image. For each text character in the text string the method selects one of the text boxes in which to render the text character of the text string reads the encoding data from the text string lookup table and determines if the center position of the text character when rendered in the selected one of the text boxes will be within the range of the line segment associated with the selected one of the text boxes. The method then renders the text character in the image on the display device using the selected one of the text boxes if the center position of the text character when rendered in the selected one of the text boxes will be within the range of the line segment associated with the selected one of the text boxes. Otherwise the method selects a different one of the plurality of text boxes as the selected one of the text boxes i.e. if the center position of the text character when rendered in the selected one of the text boxes will not be within the range of the line segment associated with the selected one of the text boxes.

In a still further embodiment a map image rendering system includes a map database and a map image rendering system. The map database stores map related vector image data the vector image data comprising data defining one or more image objects and one or more text string lookup tables wherein one of the text string lookup tables stores text characters associated with at least one text string to be rendered as a set of pixelated text characters and stores encoding data defining the center position of each of a plurality of text characters associated with the text string. The map image rendering device is communicatively coupled to the map database to receive the map related vector image data and renders a map image using the map related vector image data. The map image rendering device includes a communications network interface a processor a memory coupled to the processor a display device coupled to the processor and a number of routines that are stored on the memory and that execute on the processor. In particular a communications routine receives via the communications network interface the vector image data for an image to be rendered on the display device. Additionally one or more image shader routines determine a plurality of line segments associated with a line along which a text string is to be rendered and a range associated with each line segment and form a text box for each of the plurality of line segments each of the text boxes being oriented to draw text in an upright position along an associated line segment in the image and each text box having a set of range values defined by the range of the associated line segment. For each text character in the text string the one or more image shader routines read the encoding data from the text string lookup table determine the text box having a range value in which the center position of the text character will fall when the text character is rendered on the image and render the text character as part of the image on the display device using the determined one of the text boxes.

A graphics or image rendering system such as a map image rendering system receives image data from an image database or from an application generating the image data in the form of vector data that defines various image objects such as roads boundaries etc. and textures defining text strings to be displayed on the image to provide for example labels for the image objects. The imaging rendering system renders the images such that the individual characters of the text strings are placed on the image following a multi segmented line e.g. a curved line. This rendering system enables for example text strings to be placed on a map image so that the text follows the center line of a curved or angled road or other image feature. This rendering technique provides great flexibility in rendering text within an image because this technique allows text to be rendered so as to follow a line without knowing the specifics of the curvature of the line along which the text will be placed when creating the texture that stores the text string information. This feature provides enhanced visual properties within a map image as it allows for example road names to be placed anywhere inside a road following the curvature of the road thus providing a pleasing visual effect within the map image being rendered.

Referring now to a map related imaging system includes a map database stored in a server or in multiple servers located at for example a central site or at various different spaced apart sites and also includes multiple map client devices and each of which stores and implements a map rendering device or a map rendering engine. The map client devices may be connected to the server via any hardwired or wireless communication network including for example a hardwired or wireless LAN MAN or WAN the Internet or any combination thereof. The map client devices may be for example mobile phone devices computers such a laptop desktop or other types of computers or components of other imaging systems such as components of automobile navigation systems etc. Moreover the client devices may be communicatively connected to the server via any suitable communication system such as any publicly available or privately owned communication network including those that use hardwired based communication structure such as telephone and cable hardware and or wireless communication structure such as wireless communication networks including for example wireless LANs and WANs satellite and cellular phone communications systems etc.

The map database may store any desired types or kinds of map data including raster image map data and vector image map data. However the image rendering systems described herein are best suited for use with vector image data which defines or includes a series of vertices or vertex data points for each of numerous sets of image objects elements or primitives within an image to be displayed and which uses textures to define text strings to be displayed on a map. Generally speaking each of the image objects defined by the vector data will have a plurality of vertices associated therewith and these vertices will be used to display a map related image object to a user via one or more of the client devices . Moreover various texture maps defining for example text images or text characters may be stored in the map database for use in rendering labels or other images on the map or these texture maps may be generated from text characters in one or more applications within the client devices .

As will also be understood each of the client devices includes an image rendering engine having one or more processors one or more memories a display device and in many cases a rasterizer or graphics card which are generally programmed and interconnected in known manners to implement or to render graphics images on the associated display device . The display device for any particular client device may be any type of electronic display device such as a liquid crystal display LCD a light emitting diode LED display a plasma display a cathode ray tube CRT display or any other type of known or suitable electronic display.

Generally speaking the map related imaging system of operates such that a user at one of the client devices opens or executes a map application not shown in that operates to communicate with and to obtain map information or map related data from the map database via the server and that then displays or renders a map image based on the received map data. The map application may allow the user to view different geographical portions of the map data stored in the map database to zoom in or zoom out on a particular geographical location to rotate spin or change the two dimensional or three dimensional viewing angle of the map being displayed etc. More particularly when rendering a map image on a display device or a display screen using the system described below each of the client devices downloads map data in the form of vector data from the map database and processes that vector data using one or more image shaders to render an image on the associated display device .

Referring now to an image generation or image rendering device associated with or implemented by one of the client devices is illustrated in more detail. The image rendering system of includes two processors and two memories and a user interface and a rasterizer . In this case the processor the memory and the rasterizer are disposed on a separate graphics card denoted below the horizontal line although this need not be the case in all embodiments. For example in other embodiments a single processor may be used instead. In addition the image rendering system includes a network interface a communications and storage routine and one or more map applications having map display logic therein stored on the memory which may be executed on the processor . Likewise one or more image shaders in the form of for example vertex shaders and fragment shaders are stored on the memory and are executed on the processor . The memories and may include either or both volatile and non volatile memory and the routines and shaders are executed on the processors and to provide the functionality described below. The network interface includes any well known software and or hardware components that operate to communicate with for example the server of via a hardwired or wireless communications network to obtain image data in the form of vector data for use in creating an image display on the user interface or display device . The image rendering device also includes a data memory which may be a buffer or volatile memory portion of the memory for example that stores vector data received from the map database the vector data including any number of vertex data points and one or more image textures as will be described in more detail.

During operation the map logic of the map application executes on the processor to determine the particular image data needed for display to a user via the display device using for example user input GPS signals prestored logic or programming etc. The display or map logic of the application interacts with the map database using the communications routine by communicating with the server through the network interface to obtain map data preferably in the form of vector data or compressed vector data from the map database . This vector data is returned via the network interface and may be decompressed and stored in the data memory by the routine . In particular the data downloaded from the map database may be a compact structured or otherwise optimized version of the ultimate vector data to be used and the map application may operate to transform the downloaded vector data into specific vertex data points using the processor . In one embodiment the image data sent from the server includes vector data generally including or defining data for each of a set of vertices associated with a number of different image elements or image objects to be displayed on the screen and possibly one or more image textures that define or contain text strings or other labels to be displayed on the image with respect to the image objects. More particularly the vector data for each image element or image object may include multiple vertices associated with one or more triangles making up the particular element or object of an image. Each such triangle includes three vertices defined by vertex data points and each vertex data point has vertex data associated therewith. In one embodiment each vertex data point includes vertex location data defining a two dimensional or a three dimensional position or location of the vertex in a reference or virtual space as well as one or more vertex attribute values and or an attribute reference pointing to or defining a set of vertex attribute values. Each vertex data point may additionally include other information such as an object type identifier that identifies the type of image object with which the vertex data point is associated. Likewise the image textures which are essentially text image or pixel lookup tables define text characters text strings or labels to be rendered on the image. While such image textures may be downloaded to the client devices these image textures may also be generated at the client devices use text character strings provided to or used at the client device .

Generally speaking the imaging system for rendering text along a line within a map image described herein includes or involves three parts. First text to be rendered in an image is placed into an image texture without a path or particular orientation associated therewith and is encoded with encoding data that defines certain characteristics of each text character within the text string. This step may be performed by a map application within a client device and if so the text string encoded texture is stored in a memory of the client device. If this encoding is performed at the server this texture also called an image or text string lookup table may be stored in the map database and may be sent to a client device for storage and use in the client device. Second a set of line segments for which the text to be rendered is to follow on an image are drawn or established preferably as triangles with appropriate vertex attributes. Third one or more shaders compute where to draw the text or the characters of the text strings stored in the texture so as to correctly follow the line segments with individual character rotation being performed so that each of the text characters of the text string is rendered with an orientation that follows or is rotated correctly with respect to the line formed by the line segments.

As noted above the rendering technique renders unrotated text into a texture or pixel map. Of course this process can be performed using any desired text rendering library that renders text into an image texture or other type of lookup table. If more than one text string is to be placed into a texture the location of each text string is recorded and is stored or provided as part of the texture. Moreover the height of the text within each text string may be recorded and encoded into the texture or may be provided as attribute data for the texture.

In addition to rendering the unrotated text of the text strings within the texture encoding data such as a coded pixel stripe is provided within the texture for each text string to define along the X direction of the texture the relative position of each pixel column of a text character with respect to the center of that text character. The encoding data may also define breaks or transitions between text characters within a text string. While the encoding data may be provided with the texture in any desired manner the encoding data may be placed within the texture within a row of pixels immediately or closely above the top of the pixel locations of the text string being encoded.

A portion of one of the encoding stripes is illustrated in in more detail. In particular illustrates a portion of the encoding stripe disposed above the text characters F r e e of the Freemont Ave text string of . While the text characters F r e and e are shown in block relief over various pixel value locations in FIG. As this is performed merely to illustrate the pixel rows and columns of the texture associated with these text characters. It will be understood that the pixel values stored at these pixel locations will define the specific image features of these specific text characters. The encoding stripe of is located within the texture directly above the text string with which the encoding stripe is associated e.g. in a row of pixels directly above the top row of pixels of the associated text string. In this case the values of each of the pixels in the encoding stripe reflect or specify the position along the X direction or the width of the texture of that column of pixels as measured with respect to the center of the particular text character located within the column of pixels directly below the encoding stripe . In one example the pixel value at the center column of a text character may be set to be a value of 128 while the value of the pixels offset from the center pixel may be incremented to the left for example or decremented to the right for example by one for each pixel column away from the center pixel column of the text character. For example the pixel range above the F text character in the Freemont Ave text string includes 12 pixels with the center pixel having a value of 128 the five pixels to the right of the center pixel having values of 127 126 125 124 and 123 respectively and the four pixels to the left of the center pixel having values of 129 130 131 and 132 respectively. The encoding stripe may use the values of the red color of each pixel to perform this encoding but could instead or in addition use other color values of the pixels for encoding text character centers and widths. In the example in which red pixel color values are encoded in the row of pixels within the texture defining the encoding stripe each pixel in the encoding stripe has a red color value that on a scale from 0 to 255 is 128 more than the pixel distance to the center of the text character currently below the pixel or within the same pixel column. One extra pixel can be included to the left and right of the pixels within the encoding stripe for each text character with the extra pixel on the left having a red value of for example 255 and the pixel on the right having a red value of for example 0 to indicate the ends of the current text character. Of course the encoding stripe may be used to similarly encode each text character in the text string immediately below the encoding stripe . Still further while the encoding stripe is illustrated as being located above the associated text string the encoding stripe could alternatively be located below the text string within the same texture or could be provided in other manners such as in an additional or separate texture have a location that minors or that is correlated to the text string to which it is associated. In any event the column position of the encoding stripe is correlated in position to the pixel columns of the associated text character. However the center position and width of each text character in a text string may be encoded or provided in any other desirable or useful manner.

As a result of storing and using the encoding data that may be provided in the form of the encoding stripe for each text string in the texture the image rendering system described herein is able to render the text characters in these text strings such that individual characters are drawn correctly oriented along a multi segmented line. In particular using the encoding data the image rendering system is able to determine the relative distance to the center of an associated text character along the X coordinate of the texture at any particular location i.e. pixel column of each text character. Using this information an image shader such as one of the fragment shaders may operate to correctly draw rotated text i.e. text along a curved line with no breaks in the middle of characters as will be described below.

The second general step of the text rendering process described herein determines the line segments of the line that the text string within the encoded texture is to follow. This step may occur as the map image is being rendered and of course the manner in which the text string ultimately is rendered will be dependent on the specific line that the text to be rendered is to follow. Of course the line to be followed may be any desired type of line such as one that traverses down the center of a road created using vector based image objects a line that follows a boundary etc. Such lines may generally be determined and used to render text to label a road or other image feature. Of course the line to be followed may be any other type of line such as a line following an outline of an image feature or any other desired line. The line to be used may be determined from other image features such as the vertices of image objects may be pre stored in and provided from the map database may be specified by a user or may be determined in any other desired manner.

Upon identifying the line along which to render text the line is broken into straight but connected line segments wherein each line segment is generally at an angle to the immediately adjacent line segment s . An example of a multi segmented line is illustrated in dotted relief in as a line traversing down the center of a multi sectional road . The segmented line includes interconnected line segments A B C and D. Of course the line and or its associated line segments may be determined in any desired manner such as based on data provided in the vertices defining the segments of the road .

Once each of the line segments e.g. A and B of the line is identified and the length thereof is determined each line segment may then represented as a pair of triangles forming a rectangle which will be referred to herein as a text box. Such a rectangle or text box A is illustrated in for the line segment A. Generally speaking the rectangle A will be used to define a set of vertices for a text box that is used by a fragment shader to render text along the line segment A. In particular the vertices of the rectangle A are selected to span from a position in the image that starts a predefined or specific distance such as half the width of the widest character of the text string to be rendered along the line before the start of the line segment A as measured in the direction along the length of the line segment A to the predefined or specific distance e.g. half the width of the widest character within the text string after the end of the line segment A. In the example of the predetermined distance is illustrated as being 5 in the relative space of the image and thus the rectangle A extends from 5 to 40 along the scale marker . In the direction orthogonal to the line segment A the rectangle A spans another distance such as half the height of the tallest text character to be rendered in a direction orthogonal to the line segment A to the another distance e.g. half the height of the tallest text character to be rendered in the other direction orthogonal to the line segment A. Thus as illustrated by the scale of the rectangle A spans from 5 to 5 assuming that the height of the text string to be rendered along the line is 10 in the relative image space .

Now the length of the entire line segment A from the start point to the end point which will be referred to herein as the range of the line segment A is computed or is determined and this range is set as two components of a vertex attribute for each of the vertices of the text box A with the values of these vertex attributes being the same for each of the vertices of the triangles forming the text box A . The range of a line segment will thereby be used as or will be referred to as a range of the text box A in which the line segment is disposed. Thus the range of the rectangle A will be the range of the line segment A along which text is to be rendered. This range will be used in a fragment shader to interpolate to compute length values for the vertices of the rectangle A such that linearly interpolating the length from one end of the rectangle A to the other end results in the correct length at the start of the line segment A at the end of the line segment A and at all points in between. Of course this interpolation can be performed by subtracting half of the width of the widest character i.e. the predetermined distance from the length of the line segment A up to the start of the line segment A and using that for the rectangle vertices before the line segment A and adding half of the width of the widest character e.g. the predetermined distance to the length of the end of the line segment A and using that for the rectangle vertices after the line segment A. In addition the vertices of a text box above a line segment may be assigned a vertex attribute specifying a Y texture value of 0 and the vertices of the text box below the line segment may be assigned a vertex attribute specifying a Y texture value that is equal to the height of the text as rendered within the image. The X Y coordinates of the outer vertices of the rectangle A of are thus illustrated as being 5 0 40 0 5 10 and 40 10 in an image space that is centered on the start point of the line segment A and extends parallel in the X direction and orthogonal to in the Y direction the line segment A. The use of this coordinate space is provided for ease of illustration only and might not be the actual coordinate space used in the image itself or in the shaders performing interpolation and image rendering. However conversion to a consistent image space may be accomplished by a coordinate rotation and translation to match the X Y coordinate space of the image.

If multiple text strings are provided in the same texture that is being used to specify the text string to render in a text box such as the text box A it may also be necessary to send the Y offset the text string in question as stored within the texture i.e. the Y offset of the text string to be rendered in the text box as a vertex attribute so as to be able to render the correct text image within the text box. It may also be necessary for a shader that is to render the text string stored within a texture along a particular line segment such as the line segment A to know the size e.g. height of the text string within the texture to properly compute texture coordinates so as to be able to locate the text character to be rendered at any particular time and to perform proper interpolation when rendering the text string on the image. However the sizes e.g. heights of characters or text strings in the texture may be uniform and this value can then be set as a uniform variable rather than as a vertex attribute of a text box.

As will be understood a rectangle or a text box can be formed for each of the other line segments B C D of the line to be followed. As an example a text box B is illustrated in for the line segment B. The text box B has vertices at 30 0 110 0 30 10 and 110 10 in the relative image space now defined by the scales and . Moreover the range of this text box will be 35 to 105 as this is the range of the line segment B from its start point to its end point measured from the start of the line .

After the vertices for the two triangles for each of the rectangles or text boxes are defined for each of the line segments of the line along which the text to be rendered is to follow these vertices and their associated attributes e.g. two dimensional locations and ranges and text string coordinates may be sent to one of the vertex shaders to render the text boxes for each of the line segments of the line to be followed. These text boxes once defined by the vertex shader can then be used by a fragment shader to render text within these text boxes using one of the encoded text strings as stored in the texture of for example in a manner described below.

Generally speaking during operation the fragment shader determines which pixel from the text image to draw if any for each pixel in the text box defined for each of the determined line segments. More particularly when rendering text along a multi segmented line the map application uses the fragment shader to place text from the text image in the various text boxes one text box at a time. In doing so the map application selects one of the line segments along which to begin rendering a particular text string and uses the text box created for that line segment. The first selected line segment or text box may be the line segment or text box having the range value of 0 therein. When operating using this text box the fragment shader may access the pixels of the first text character to be rendered from the appropriate texture and may look up or determine the relative distance to the center of that text character using the encoded stripe within the texture. This function can be performed by using the interpolated length value as the X coordinate into the texture divided by the width of the texture to get a texture coordinate for the position of the character being rendered as stored within the texture. The Y coordinate into the texture can be computed to be the first row of pixels in the texture or the first row after the texture offset if multiple strings are packed into the texture. Upon finding the current text character of the text string being rendered the fragment shader reads the appropriate color values from the encoding stripe of the text string and subtracts 128 to determine the distance to the center of the character. Adding the interpolated length gives the length up to the center of the character. If the center of the character as interpolated into the image space falls within the range of the text box then the fragment shader draws the pixel or pixels of the text image on the display within the text box. However if the computed center of the text character is not between the first and second limits of the range provided for the text box then the pixels of the current text character should be discarded and nothing is drawn. More particularly the fragment shader performs the determination of whether to place each pixel of a text character in the text box on a pixel by pixel basis and thus performs the determination of whether a pixel of a text image is associated with a text character having a center point that falls within the range of the text box currently being rendered for each individual pixel analyzed. Of course if desired the fragment shader could perform this analysis for each pixel column of the text image when trying to fill in the corresponding pixels of the text box and in this case will either draw the text image pixels of a column in the text box or not depending on whether the center of the character falls within range of the text box. In any event when any particular pixel or pixel column is not discarded the fragment shader can look up the colors for the text at that column of pixels using the same texture X coordinate as before and one or more than the interpolated Y texture coordinate passed in as a vertex attribute depending on the particular row of the column being rendered divided by the texture height. This should give the corresponding pixel from the rendered text correcting for the center encoding pixel above the text.

Of course if the pixels of a text character are not drawn in the text box because the center of the text character is outside of the range of the text box then the map application will use the fragment shader to draw that text character when processing or rendering the next or a subsequent text box associated with the next or a subsequent line segment along the line . The fragment shader repeats the process of determining if the pixels of a text character should be rendered in the currently selected text box or not until the shader fills in the text box i.e. reaches the end of the text box. Once the pixels of a text character are rendered within or using a particular text box the fragment shader tries to render the pixels of the next text character within the same text box and repeats this process until it reaches the end of the text box. As will be understood the size of the text boxes formed for line segments may be small and in fact may be smaller than the size of a character because if a character is not rendered in one text box as its center point extends outside the range of the text box the character will be rendered in a subsequent text box i.e. the text box in which the center of the text character falls . During this process text boxes may be created in which no text characters are rendered.

The result of this process is that each of the text characters within the text image is rendered right side up i.e. upright in the orientation of a text box and following a line but where each text character is rotated in orientation along the line to correctly follow the multi segmented line. As a result the text strings can be pre computed in an unrotated manner and stored in a texture and can be used again and again for multiple lines with different curvatures.

Referring now to a process flow diagram or flow chart of a method routine or process that may used to render text along a line within an image using an encoded texture or text string lookup table such as that of is illustrated in more detail. As an example only the routine may be used in a map rendering engine such as that of to render text along or within the boundaries of a multi segmented road and more particularly along a line that follows the center of that road such that the text rendered is centered in the road spanning various segments of the road. Generally speaking the routine or process may be implemented as one or more software routines or applications including routines that are part of the map application and or routines defined by the vertex and fragment shaders and which are executed in the processors and . These routines may be implemented or written in any desired language such as Javascript C code etc. and may be executed on one or both of the processors and . Additionally these routines may use the rasterizer to render an image on the display device .

In any event a block of the routine may draw or form an image feature such as a multi sectional road along which text characters are to be applied. As part of or after this process is completed a block determines a multi segmented line that follows the image feature such as a multi sectional road along which the text string is to be rendered. In one example this multi segmented line may follow the centerline of the multi sectional road such as the line illustrated in . Next a block finds or locates the points along the multi segmented line at the intersection of each pair of adjacent sections of the multi segmented line. Thus the block finds the start and end point of each line segment of the line along which text is to be rendered and may assign a unique range to each segment of the multi segmented line. The assigned range should extend consecutively or seamlessly across the boundaries of the line segments. That is the range of the line may start at the beginning of one line segment and extend consecutively through that line segment and then through each of the following line segments so that no two line segments have the same range and only share common end points.

Next a block forms a text box for each line segment in the manner discussed above with respect to . The vertices of these text boxes may be defined or computed for example in a routine within the map application and may then be sent to one of the vertex shaders of to form text boxes in the image being rendered using the rasterizer . Of course the outlines of the text boxes will be transparent or have no color as the text boxes themselves will not be visual aspects of the image being rendered although they could be if so desired . The vertices for each text box will specify the location of the text box vertices within the image and will include as attributes the range of the line segment associated with the text box and if needed one or more references to the text string of the texture that is to be rendered in the text box. That is if desired the text box vertices may include as attributes pointers to the location within the texture at which the text string to be rendered along the line is located.

Next at a block the routine or process selects a first one of the text boxes along which to begin rendering the referenced text string. This text box will generally be the text box having the zero 0 range value as this range value indicates the starting position along which to begin rendering the text string stored within the texture. However this need not be the case and the text could be rendered along the line beginning at any desired location or position along the determined line. In any event a block locates the starting point in the current or selected text box at which text is to be rendered as the current location along the line. This starting point can be and generally will be except for the first text box at the beginning or front end of the text box. A block then obtains the pixel or set of pixels associated with a column of a text character within the text string as stored within the texture that correspond to the range value associated with the current location along the line.

A block then determines if the center of the text character with which those pixels are associated is in the range of the current text box when the text size is interpolated to be fit within the size specified as part of the current text box if the entire text character were to be placed or rendered in the current text box at the current location along the line. The block may perform this test by reading the encoding stripe of the texture immediately above the pixels of the text character being considered. That is the block may read the encoding stripe to determine the pixel location in the X direction of the texture within the encoding stripe for the current text character i.e. without traversing across a 0 or a 255 valued pixel location that has a red color value of 128 and then recognizing this position as the center along the X direction of the texture of the text character being considered. Alternatively or additionally the block may use the width encoding within the encoding stripe to determine the distance to the center of the current text character. If when interpolated properly to be placed within the current text box the center pixel location of the current text character is within the range of the current text box then a block renders all of pixels of the current column of the text character in the current text box at a properly interpolated size at the current location along the line. On the other hand if when interpolated properly to be placed within the current text box the center pixel location of the text character is not within the range of the current text box the block is skipped by block so that the current pixel or current column of pixels of the text character are not rendered in the text box. These procedures may be performed in a fragment shader if so desired. Of course when the fragment shader is rendering a text character within the text box the pixels of the text character will be rendered along the X and Y orientations of the text box so that the text character will be rendered in an upright position along the line as defined by the orientation of the text box. Moreover in operation the routine may perform the blocks and in succession on a pixel by pixel basis so that the fragment shader separately analyzes for each pixel in a particular pixel column of the texture whether the text character to which that pixel belongs has a center position falling within the range of the text box. For the sake of simplicity however the flow chart of does not indicate a pixel by pixel operation but instead indicates processing of text character pixels on a pixel column by pixel column basis.

In any event after all of the pixels of a particular pixel column of the texture have been analyzed a block increments the current location along the line to the next position and a block determines if the current location is beyond the back end of the current text box. If not control is returned to the block which obtains the next pixel or set of pixels in a pixel column of the texture and the steps of blocks are repeated for the next column of pixels in a text character to see if those pixels should be rendered within the current text box.

However at the block if the new location of the line is found to be outside of or beyond the end of the current text box then a block which may be run in the application drawing the text along the line determines if all text boxes for the line have been rendered. If not a block determines the next text box to render and provides the specifics of that text box to the fragment shader for rendering. Control is then provided to which determines the starting point of the text image associated with the new text box as that point corresponding to the location along the line defined by the start of the new text box and sets this point as the current location along the line. The fragment shader then operates to implement the blocks to for the next text box. When the block determines that the last text box has been rendered the process of rendering the text string along the line will be complete for one text string in the texture.

As will be understood the routine essentially operates to find the text box along the selected or determined line in which the center of each text character will fall and draws the entire text character in that text box. Because the range of the line is used to determine the position of the text characters with respect to one another and this range is consecutive and unbroken at intersections of adjacent text boxes the text characters will each be rendered in the correct direction upright with respect to the text box in which they are rendered. However because the ends of each text box are extended beyond the range of the text box the routine assures that an entire text character can and will be rendered in one and only one text box i.e. the text box having the range value in which the center of the text character falls. This system enables text boxes to be of very small sizes in which case a text character may not be rendered in each text box such as may be the case with a continuously curving line. Thus this technique enables text to be rendered correctly along any curved line.

It will of course be understood that the various actions specified by the different blocks of could be rearranged or reordered and performed in other manners or sequences. Moreover the determination or establishment of text boxes could be performed on the fly as each text box becomes needed when it is determined that text to be rendered falls outside of the current text box instead of the text boxes being pre established or predetermined before text rendering begins as described herein.

While the encoding stripe for a text string in a texture is described as being immediately or directly above an associated text string this encoding stripe could be provided in the texture below the text string or could even be provided in another texture or lookup table if so desired in a manner that is somehow correlated to or referenced the pixels of the associated text string. Moreover the position of the center of each text character in a text string could be encoded in other manners than that described herein including in manners which do not use an encoding stripe . Moreover in the cases in which an encoding stripe is used the encoding technique is not limited to for example using the specific pixel values described herein. Thus while the value of 128 is described herein as being used to indicate the center of a text character within the encoding stripe other values could be used instead. Likewise while the red color value of a pixel row is used for the encoding stripes described herein one or more other pixel color values could be used instead.

Moreover as noted above it is important that the fragment shader that is rendering the text string along a line be able to determine where the center of each text character is within a texture so that the fragment shader can determine whether the center of the text character falls within the range of a text box or outside of the range of the text box in which text characters are currently being rendered. One manner of determining the center of a character as noted above may be to encode the center of the characters in the texture or image lookup table itself such as that illustrated in in which a single encoding stripe is used for a single string or group of text characters.

Using other encoding techniques however it is possible to reduce the size of a texture or a text string lookup table by storing the different text characters to be rendered as parts of various different text strings or as parts of the same text string as a set of glyphs within a texture. In addition such further encoding techniques need to provide first encoding data for each text string that includes center and or width information for each text character of the text string and second encoding data pointing to a particular glyph that is to be used as a text character at each text character location of a text string. For example illustrates a texture that stores encoding information and for three different text strings wherein these text strings may define labels or names for different roads in for example a map tile. The example lines of text encoding information of may define the text strings Freemont Ave Aurora Ave and First St for example. Each of the text strings associated with the encoding information and may for example be provided to be rendered along different lines within a map image. In this case each of the sets of encoding information includes an encoding stripe A A A respectively which have pixel values denoting the center of each text character in the text string and or the distances from each particular pixel column to the center of an associated text character. The encoding stripes A A and A are similar or are identical to the encoding stripes of . Again for the sake of illustration only the center of each text character of a text string is indicated by a small vertical line in the encoding stripes. However instead of storing an actual set of pixel values defining text characters in the texture directly below each of the encoding stripes A A and A a second line of encoding is provided within each of the sets of text string encoding information and . These second lines of encoding illustrated in as encoding lines B B and B are essentially sets of pointers to positions within a field of glyphs stored within the texture . Each of the glyphs within the field of glyphs may be a single text character that is used in one or more of the text strings defined by the text string encoding information and . In this case one or more of the glyphs within the field of glyphs may be used more than once in the same or different text strings defined by the text string encoding information .

Thus in the encoding technique illustrated in each line or set of text string encoding information and includes a first set of encoding data formed as a set of pixel values A A and A that indicate the width spacing and center of each character or glyph within the associated text string as well as the relative spacing of different text characters or glyphs with respect to one another within the associated text string. Moreover each line or set of text string encoding information and includes a second line or set of pixels B B B that defines the position or location of the glyph as stored in the field of glyphs that defines the particular text character to use at that position within the associated text string.

The second or further encoding lines B B B may be stored as a separate line of pixels within the texture adjacent to such as below the first encoding lines A A A. In one embodiment the second lines of encoding data B BB B may include a separate set of glyph pointer values that start at for example the center of each text character as defined in the first line of encoding data A A A. As an example each set of glyph pointer values may include four encoded pixel values which together point to the location of a particular glyph in the field of glyphs . As an example only the X position of a referenced glyph as stored in the field of glyphs may be stored in the first set of two pixel values the first and second pixel values while the Y position of the referenced glyph as stored in the field of glyphs may be stored in the second set of two pixel values the third and fourth pixel values . As a more particular example the X coordinate may be stored in the first and second pixel values by storing the X value of the referenced glyph divided by 256 in the first pixel location and storing the remainder X modulo 256 in the second pixel location. In a similar manner the Y coordinate of the referenced glyph may be stored in the third and fourth pixel values by storing the Y value of the referenced glyph divided by 256 in the third pixel location and storing the remainder Y modulo 256 in the fourth pixel location. Of course any other manner of providing or encoding pixel values with location pointers to other positions within the texture or even to locations within different texture in which glyphs are stored may be used instead. Moreover the location to which the glyph pointers reference could be the center of an associated glyph a corner of the glyph location such as the upper left hand corner the lower right hand corner or any other predefined position of a glyph. While glyphs as stored in the texture may be of a predetermined or predefined size their size may vary as well. In this later case the encoding lines A A A may be used to define the width of the glyph to be recovered and the height of the glyph may be fixed. Alternatively the second encoding lines B B B of the text string information may also include a size of the glyph to be obtained. In another embodiment the glyphs themselves may have a set of pixel values defining their size and this set of pixel values may be recovered first to determine the exact pixel locations within the texture that are associated with any particular glyph.

Of course the use of two or more encoding stripes as illustrated in the example of actually allows each text character or glyph used somewhere in one or more of the text strings to be stored in the texture only once because this glyph can be referenced numerous times by the same or different text encoding stripes. This dual encoding technique saves or reduces the space or data needed for a texture when downloading and storing the textures used to perform rendering of text within multiple sets of text boxes or along multiple different lines or when sending these textures between the processors and within the device . Moreover while the second data encoding lines B B B are illustrated in as being disposed in a pixel row immediately or slightly below the associated first encoding data line A A respectively the second data encoding lines B B B could be stored in the texture at other locations such as above the first encoding data lines or even as a set of pixel values for a different color field of the first encoding data lines. For example if the first encoding data line is stored in a row of pixel locations using the red pixel values of that row of pixels the second encoding data line could be stored in the blue or the green pixel values of this same row of pixels.

In some cases as illustrated in it may be desirable to create or render a text string that has overlapping characters. In the example of the r and the A are overlapping because a portion of the A i.e. the left most column of pixel values is located on the same X coordinate as the right most column of the pixel values of the r . The encoding techniques illustrated and described with respect to A and are not capable of rendering such text using a single text encoding string because the positions of the text characters within the text string are all defined serially in a single line pixels requiring a distinct transition between the end of one text character and the beginning of an adjacent character.

To allow or enable the rendering of overlapping text characters or glyphs within a common text string the encoding techniques described with respect to A and may be modified to include multiple sets of lines of encoding for each text string. Such a technique is illustrated in the texture of . In this case a single text string is illustrated as including two different sets of lines of encoding and with each line of encoding including the two encoding stripes described with respect to . In this case a first character of the text string information which may define the text string Freemont Ave is located in the upper set of encoding lines and includes an encoding stripe A that defines the center of the text character in the X direction and the width or distance from the center of the first character and further includes a second line of encoding B that points to the location of the glyph within the field of glyphs to use for the first text character. Now however the second character of the text string information is located in the lower line and includes an encoding stripe A that defines the center of the second text character in the X direction and the width or distance from the center of the second character and includes a second line of encoding B that points to the location of the glyph within the field of glyphs to use for the second text character. As illustrated in because the encoding stripes A and A are on different rows of the texture they can have pixel locations or pixel columns that overlap when rendered on an image. Thus as illustrated in the right most pixel columns of the first character A overlap with the left most pixel columns of the second character A. The fragment shader that reads the sets of encoding stripes and merely needs to read both encoding lines to recognize the next character to render for the text string . The fragment shader may for example alternate between the set of encoding lines and looking for the next character may read both sets of encoding lines and and determine the next character based on the next detected center position regardless of which encoding line the next center position is found etc. Of course the two sets of encoding lines and can be used in cases in which the text characters do not overlap in which case either 1 one of the sets of encoding lines or will have no information and thus can be ignored or 2 encoding stripes for adjacent text characters of the two encoding lines and will not overlap one another. Again as illustrated in by the sets of encoded data and multiple sets of text string encoding data each having multiple sets of encoding data therein may be stored in the texture along with the field of glyphs .

Of course the text rendering and texture encoding techniques described herein may be altered or varied in any number of manners to provide an image rendering system such as a map rendering system with the ability to render individual text characters within a text string along a curved e.g. multi segmented line.

Throughout this specification plural instances may implement components operations or structures described as a single instance. Although individual operations of one or more methods are illustrated and described as separate operations one or more of the individual operations may be performed concurrently and nothing requires that the operations be performed in the order illustrated. Structures and functionality presented as separate components in example configurations may be implemented as a combined structure or component. Similarly structures and functionality presented as a single component may be implemented as separate components. These and other variations modifications additions and improvements fall within the scope of the subject matter herein.

For example the network may include but is not limited to any combination of a LAN a MAN a WAN a mobile a wired or wireless network a private network or a virtual private network. Moreover while only four client devices are illustrated in to simplify and clarify the description it is understood that any number of client computers or display devices are supported and can be in communication with the server .

Additionally certain embodiments are described herein as including logic or a number of components modules or mechanisms. Modules may constitute either software modules e.g. code embodied on a machine readable medium or in a transmission signal or hardware modules. A hardware module is tangible unit capable of performing certain operations and may be configured or arranged in a certain manner. In example embodiments one or more computer systems e.g. a standalone client or server computer system or one or more hardware modules of a computer system e.g. a processor or a group of processors may be configured by software e.g. an application or application portion as a hardware module that operates to perform certain operations as described herein.

In various embodiments a hardware module may be implemented mechanically or electronically. For example a hardware module may comprise dedicated circuitry or logic that is permanently configured e.g. as a special purpose processor such as a field programmable gate array FPGA or an application specific integrated circuit ASIC to perform certain operations. A hardware module may also comprise programmable logic or circuitry e.g. as encompassed within a general purpose processor or other programmable processor that is temporarily configured by software to perform certain operations. It will be appreciated that the decision to implement a hardware module mechanically in dedicated and permanently configured circuitry or in temporarily configured circuitry e.g. configured by software may be driven by cost and time considerations.

Accordingly the term hardware should be understood to encompass a tangible entity be that an entity that is physically constructed permanently configured e.g. hardwired or temporarily configured e.g. programmed to operate in a certain manner or to perform certain operations described herein. Considering embodiments in which hardware modules are temporarily configured e.g. programmed each of the hardware modules need not be configured or instantiated at any one instance in time. For example where the hardware modules comprise a general purpose processor configured using software the general purpose processor may be configured as respective different hardware modules at different times. Software may accordingly configure a processor for example to constitute a particular hardware module at one instance of time and to constitute a different hardware module at a different instance of time.

Hardware and software modules can provide information to and receive information from other hardware and or software modules. Accordingly the described hardware modules may be regarded as being communicatively coupled. Where multiple of such hardware or software modules exist contemporaneously communications may be achieved through signal transmission e.g. over appropriate circuits and buses that connect the hardware or software modules. In embodiments in which multiple hardware modules or software are configured or instantiated at different times communications between such hardware or software modules may be achieved for example through the storage and retrieval of information in memory structures to which the multiple hardware or software modules have access. For example one hardware or software module may perform an operation and store the output of that operation in a memory device to which it is communicatively coupled. A further hardware or software module may then at a later time access the memory device to retrieve and process the stored output. Hardware and software modules may also initiate communications with input or output devices and can operate on a resource e.g. a collection of information .

The various operations of example methods described herein may be performed at least partially by one or more processors that are temporarily configured e.g. by software or permanently configured to perform the relevant operations. Whether temporarily or permanently configured such processors may constitute processor implemented modules that operate to perform one or more operations or functions. The modules referred to herein may in some example embodiments comprise processor implemented modules.

Similarly the methods or routines described herein may be at least partially processor implemented. For example at least some of the operations of a method may be performed by one or processors or processor implemented hardware modules. The performance of certain of the operations may be distributed among the one or more processors not only residing within a single machine but deployed across a number of machines. In some example embodiments the processor or processors may be located in a single location e.g. within a home environment an office environment or as a server farm while in other embodiments the processors may be distributed across a number of locations.

The one or more processors may also operate to support performance of the relevant operations in a cloud computing environment or as a software as a service SaaS . For example at least some of the operations may be performed by a group of computers as examples of machines including processors these operations being accessible via a network e.g. the Internet and via one or more appropriate interfaces e.g. application program interfaces APIs . 

The performance of certain of the operations may be distributed among the one or more processors not only residing within a single machine but deployed across a number of machines. In some example embodiments the one or more processors or processor implemented modules may be located in a single geographic location e.g. within a home environment an office environment or a server farm . In other example embodiments the one or more processors or processor implemented modules may be distributed across a number of geographic locations.

Some portions of this specification are presented in terms of algorithms or symbolic representations of operations on data stored as bits or binary digital signals within a machine memory e.g. a computer memory . These algorithms or symbolic representations are examples of techniques used by those of ordinary skill in the data processing arts to convey the substance of their work to others skilled in the art. As used herein an algorithm or a routine is a self consistent sequence of operations or similar processing leading to a desired result. In this context algorithms routines and operations involve physical manipulation of physical quantities. Typically but not necessarily such quantities may take the form of electrical magnetic or optical signals capable of being stored accessed transferred combined compared or otherwise manipulated by a machine. It is convenient at times principally for reasons of common usage to refer to such signals using words such as data content bits values elements symbols characters terms numbers numerals or the like. These words however are merely convenient labels and are to be associated with appropriate physical quantities.

Unless specifically stated otherwise discussions herein using words such as processing computing calculating determining presenting displaying or the like may refer to actions or processes of a machine e.g. a computer that manipulates or transforms data represented as physical e.g. electronic magnetic or optical quantities within one or more memories e.g. volatile memory non volatile memory or a combination thereof registers or other machine components that receive store transmit or display information.

As used herein any reference to one embodiment or an embodiment means that a particular element feature structure or characteristic described in connection with the embodiment is included in at least one embodiment. The appearances of the phrase in one embodiment in various places in the specification are not necessarily all referring to the same embodiment.

Some embodiments may be described using the expression coupled and connected along with their derivatives. For example some embodiments may be described using the term coupled to indicate that two or more elements are in direct physical or electrical contact. The term coupled however may also mean that two or more elements are not in direct contact with each other but yet still cooperate or interact with each other. The embodiments are not limited in this context.

As used herein the terms comprises comprising includes including has having or any other variation thereof are intended to cover a non exclusive inclusion. For example a process method article or apparatus that comprises a list of elements is not necessarily limited to only those elements but may include other elements not expressly listed or inherent to such process method article or apparatus. Further unless expressly stated to the contrary or refers to an inclusive or and not to an exclusive or. For example a condition A or B is satisfied by any one of the following A is true or present and B is false or not present A is false or not present and B is true or present and both A and B are true or present .

In addition use of the a or an are employed to describe elements and components of the embodiments herein. This is done merely for convenience and to give a general sense of the description. This description should be read to include one or at least one and the singular also includes the plural unless it is obvious that it is meant otherwise.

Still further the figures depict preferred embodiments of a map rendering system for purposes of illustration only. One skilled in the art will readily recognize from the following discussion that alternative embodiments of the structures and methods illustrated herein may be employed without departing from the principles described herein

Upon reading this disclosure those of skill in the art will appreciate still additional alternative structural and functional designs for a system and a process for rendering map or other types of images using the principles disclosed herein. Thus while particular embodiments and applications have been illustrated and described it is to be understood that the disclosed embodiments are not limited to the precise construction and components disclosed herein. Various modifications changes and variations which will be apparent to those skilled in the art may be made in the arrangement operation and details of the method and apparatus disclosed herein without departing from the spirit and scope defined in the appended claims.

