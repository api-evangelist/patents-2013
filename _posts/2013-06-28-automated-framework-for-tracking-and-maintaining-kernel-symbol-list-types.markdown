---

title: Automated framework for tracking and maintaining kernel symbol list types
abstract: Systems and methods are provided for tracking and maintaining kernel symbol list types. An example system includes a request tracker that receives from a consumer an identifier of a first kernel and at least one of a first set of kernel symbols of a first list type and a second set of kernel symbols of a second list type, where each kernel symbol of the first list type is included in a kernel application binary interface of the associated kernels. The system further includes a comparison module that compares kernel symbols included in the first kernel to kernel symbols included in the second kernel. The system also includes a notification module that sends, based on the comparison, a notification to the consumer, where the notification indicates a change in a kernel symbol included in the first kernel or second kernel.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08914815&OS=08914815&RS=08914815
owner: Red Hat, Inc.
number: 08914815
owner_city: Raleigh
owner_country: US
publication_date: 20130628
---
In computing an operating system may provide an environment in which the user is able to run application software. The applications that users run rely on services provided by the operating system to perform tasks while they execute in many cases without the user or even the programmer giving much thought to them. For example for an application to read a file from disk the programmer may simply call a function that the operating system provides and the operating system may handle the specific steps required to perform that read accordingly. As such the application programmer is freed from having to worry about the differences between reading a file that resides on the computer s internal hard disk or a file on an external USB flash drive the operating system takes care of such matters.

An operating system may include a kernel that serves as a central component for facilitating communication between software applications and hardware devices e.g. central processing unit CPU memory and input output I O devices of a machine. For example a kernel may be responsible for facilitating operating system functions and various management tasks e.g. process management disk management and memory management .

This disclosure relates to kernels and kernel symbols. Methods systems and techniques for tracking and maintaining kernel symbol list types are provided.

According to an embodiment a system for tracking and maintaining kernel symbol list types includes a request tracker that receives from a consumer an identifier of a first kernel and at least one of a first set of kernel symbols of a first list type and a second set of kernel symbols of a second list type. The system also includes a database that stores one or more kernel symbols of the first list type and one or more kernel symbols of the second list type. Each kernel symbol of the first list type and of the second list type in the database are included in one or more kernels. Each kernel symbol of the first list type is included in a kernel ABI application binary interface of one or more of the associated kernels. The request tracker stores in the database at least one of the first set of kernel symbols of the first list type and the second set of kernel symbols of the second list type. The system further includes a comparison module that identifies a second kernel associated with a third set of kernel symbols of the first list type and a fourth set of kernel symbols of the second list type and compares one or more kernel symbols included in the first kernel to one or more kernel symbols included in the second kernel. The system also includes a notification module that sends based on the comparison a notification to the consumer. The notification indicates a change in one or more kernel symbols included in the first kernel or second kernel.

According to another embodiment a method of tracking and maintaining kernel symbol list types includes receiving by one or more processors from a consumer an identifier of a first kernel and at least one of a first set of kernel symbols of a first list type and a second set of kernel symbols of a second list type. The method also includes storing in a database the kernel identifier and at least one of the first set of kernel symbols of the first list type and the second set of kernel symbols of the second list type. Each kernel symbol of the first list type and of the second list type in the database are included in one or more kernels. Each kernel symbol of the first list type is included in a kernel ABI application binary interface of one or more of the associated kernels. The method further includes identifying a second kernel associated with a third set of kernel symbols of the first list type and a fourth set of kernel symbols of the second list type. The method also includes comparing one or more kernel symbols included in the first kernel to one or more kernel symbols included in the second kernel. The method further includes sending based on the comparison a notification to the consumer. The notification indicates a change in one or more kernel symbols included in the first kernel or second kernel.

According to another embodiment a non transitory machine readable medium includes a plurality of machine readable instructions that when executed by one or more processors are adapted to cause the one or more processors to perform a method including receiving by one or more processors from a consumer an identifier of a first kernel and at least one of a first set of kernel symbols of a first list type and a second set of kernel symbols of a second list type storing in a database the kernel identifier and at least one of the first set of kernel symbols of the first list type and the second set of kernel symbols of the second list type where each kernel symbol of the first list type and of the second list type in the database are included in one or more kernels and each kernel symbol of the first list type is included in a kernel ABI application binary interface of the one or more associated kernels identifying a second kernel associated with a third set of kernel symbols of the first list type and a fourth set of kernel symbols of the second list type comparing one or more kernel symbols included in the first kernel to one or more kernel symbols included in the second kernel and sending based on the comparison a notification to the consumer the notification indicating a change in one or more kernel symbols included in the first kernel or second kernel.

It is to be understood that the following disclosure provides many different embodiments or examples for implementing different features of the present disclosure. Some embodiments may be practiced without some or all of these specific details. Specific examples of components modules and arrangements are described below to simplify the present disclosure. These are of course merely examples and are not intended to be limiting.

In host machine may execute a program in user space and is coupled to hardware . Program may employ the services of an operating system . Operating system serves as an interface between any hardware or physical resources of host machine and a user e.g. software developer computer programmer and system administrator . Operating system includes a kernel ABI application binary interface kernel and device driver . Kernel ABI KABI is an interface between program and operating system . KABI also serves as an interface between kernel and other parts of operating system such as device driver .

Device driver abstracts out the details of hardware so that it is unnecessary for an application programmer to be concerned with the details of hardware . Device driver and kernel execute in kernel space. Device driver may invoke kernel symbols included in kernel . A kernel symbol may refer to a function name and parameters included in the kernel. In an example the kernel symbol may be a function name in the C programming language. Other programming languages may also be used.

An operating system provider or kernel provider may determine which kernel symbols to include in the kernel and the KABI. Stability of the KABI is a critical issue for many third party kernel software vendors and third party kernel hardware vendors that provide device drivers and peripheral devices. For example a device driver may be designed to work with a particular version of a kernel and certain standard functions and data structures within the kernel may be relied upon by external parties.

A third party vendor may refer to a device driver developer or anyone consuming kernel subsystem functions or subsystem APIs application programming interfaces . For example the third party vendor may be a cloud provider that consumes a networking stack and the networking subsystem e.g. Internet subsystem has different functions consumed by the cloud provider. Some of the code of the networking subsystem may be included in the kernel. In another example the device driver may invoke a kernel provided print function e.g. printk . If the kernel provider changes the interface between the device driver and the print function the device driver may need to be recompiled otherwise if the device driver attempts to invoke the original print function using the updated interface errors may result and host machine may freeze or crash. Thus it may be desirable to maintain and track changes to kernel symbols and provide the third party vendor with this data.

It may also be desirable to provide internal kernel consumers with this kernel symbol data. An internal kernel consumer may refer to a team within the kernel providing company. The internal kernel consumer may be tasked with the responsibility of maintaining and updating the kernel. As such the internal team may want a list of kernel symbols that the company has guaranteed will not change. This may help to ensure that these kernel symbols are included in the subsequent release of the kernel and do not change. Further the internal team may also want to know which kernel symbols are being used in which kernel versions and the popularity of a kernel symbol. As such the internal team may have an easier time with the kernel release process and maintaining the kernel. For example if the internal team is aware that a particular kernel symbol is very popular in a non white list the internal team may decide to include the popular kernel symbol to the KABI white list.

This disclosure provides categories of list types that add value to kernel symbols and also to internal and external kernel consumers. The categories may include for example white list kernel symbols and non white list kernel symbols.

Device driver includes white list kernel symbols and non white list kernel symbols . Kernel includes white list kernel symbols and non white list kernel symbols that may be invoked by for example device driver . Kernel symbols included in KABI may refer to a list of kernel symbols that are part of the white list of kernel . White list kernel symbols and are defined as being part of KABI and are guaranteed to not change in one or more subsequent release cycles or releases of the kernel to which they are associated. The kernel provider may determine which kernel symbols to include in the white list of the kernel.

Non white list kernel symbols and are not part of KABI and may change in one or more subsequent release cycles or releases of the kernel. The white list of kernel symbols may be mutually exclusive of the non white list of kernel symbols. A non white list kernel symbol may be for example a grey list kernel symbol or a black list kernel symbol. The grey list kernel symbol may refer to a kernel symbol that may be included in the kernel symbol white list in a subsequent release of the kernel. The black list kernel symbol may refer to a kernel symbol that the kernel provider will not support in the subsequent kernel release. Black list kernel symbols may include kernel symbols that are infrequently used or associated with a questionable source. The kernel provider determines which kernel symbols are included in the black list of the kernel. Although two kernel symbol categories are described it should be understood that categories including more than two kernel symbols are within the scope of this disclosure. For example the kernel symbol categories may include white list kernel symbols non white list kernel symbols and black list kernel symbols.

Providing the white list and non white list category may add value to kernel consumers because they may readily identify which kernel symbols e.g. white list kernel symbols are trustworthy symbols that may continue to be used in confidence. For example the third party vendor may develop a new version of its device driver and use the white list kernel symbols in the previous device driver version in the updated device driver with confidence. The third party vendor may be weary regarding the non white list kernel symbols and watch out for changes regarding these symbols because the kernel provider has not yet stated that these symbols will be supported in further releases of the kernel.

The kernel provider may also benefit from this kernel symbol categorization. For example the kernel provider is aware of which kernel symbols should not be changed by identifying the kernel symbols in the white list. As such the white list of kernel symbols may help in maintaining a stable kernel ABI across a particular kernel product release. Further the subsequent version of a kernel is guaranteed to retain a level of compatibility with other previous versions of the kernel.

The kernel provider determines whether to incorporate a kernel symbol into the white list. It may be desirable to reduce the quantity of kernel symbols incorporated in the white list to reduce the size of the kernel. Thus it may be advantageous to determine the popularity of kernel symbols amongst external consumers e.g. third party vendors and the consumer s input on particular kernel symbols. The internal team may then consider the popularity of a non white list kernel symbol associated with a kernel to determine whether to incorporate the kernel symbol in a next release of the kernel.

Accordingly it may be desirable to provide a framework to track internal kernel symbols consumer white list kernel symbols and kernel symbols that consumers request for inclusion into the white list.

Diagram includes a kernel consumer server and request tracker coupled to a network . Each of kernel consumer server and request tracker may communicate with each other via network .

Network may include various configurations and use various protocols including the Internet World Wide Web intranets virtual private networks wide area networks local networks private networks using communication protocols proprietary to one or more companies cellular and other wireless networks Internet relay chat channels IRC instant messaging simple mail transfer protocols SMTP Ethernet WiFi and HTTP and various combinations of the foregoing.

Consumer may send requests to and receive responses from server over network . Consumer may also send requests to and receive responses from request tracker over network . In an example consumer sends a request to server and or request tracker for information regarding one or more kernel symbols.

Server and request tracker provide a framework to track and maintain kernel symbol list types. Tracking and maintaining kernel symbol list types may be beneficial to manage kernel symbols within a kernel release process. Server is coupled to a database that stores one or more kernel symbols of a first list type and one or more kernel symbols of a second list type. In an example the first list type is a white list type and the second list type is the non white list type. Each kernel symbol of the white list type and of the non white list type in database may be included in one or more kernels and each kernel symbol of the white list type may be included in a kernel ABI application binary interface of the one or more associated kernels.

In an embodiment request tracker receives from consumer an identifier of a kernel and at least one of a first set of kernel symbols of a white list type and a second set of kernel symbols of a non white list type. Request tracker stores in database the received first set of kernel symbols of the white list type and or the second set of kernel symbols of the non white list type. Request tracker may send the kernel symbol data to server and server may store the data in database .

In another embodiment consumer sends the kernel symbol data e.g. identifier of a kernel and at least one of a first set of kernel symbols of a white list type and a second set of kernel symbols of a non white list type directly to server . Server may receive the kernel symbol data via the backend and store the data in database .

During a kernel build a file e.g. Module.symvers may be generated that contains all exported symbols from the kernel and compiled modules. For each kernel symbol the corresponding cyclic redundancy check CRC value may also be stored. An example syntax of the file is illustrated in the table below 

Further the kernel may be available for a wide range of possible systems. These may include many different architectures platforms and configuration of the kernel for such platforms. As such architectures such as i686 i686PAE i686xen ia64 ia64xen ppc64 ppc64dump s390x x8664 and x8664xen may support the kernel. In an example a file named module.whitelist.i686 is generated and lists the white list kernel symbols for the i686 architecture. An appropriate file may be generated and may list the white list kernel symbols for each applicable architecture. The generated files may be a plain text file XML file or other formatted file. The data from the files e.g. Module.symvers and module.whitelist.i686 may be imported into server .

Usage of kernel symbols in relation to architectures and kernel symbol list types may be tracked by request tracker . Request tracker may track a consumer s release of source products e.g. different drivers . For example each request tracker may identify the white list kernel symbols and non white list kernel symbols included in a first source product and identify the white list kernel symbols and non white list kernel symbols included in a second source product. This information may be sent to server .

Database may store white list kernel symbols and non white list kernel symbols from third party vendors as well as white list kernel symbols and non white list kernel symbols from an internal team. Data in database may be analyzed at a later point in time. For example kernel symbols included in a first kernel may be compared to kernel symbols included in a second kernel.

Consumer may be a third party vendor that uses kernel symbols. In an example the third party vendor provides device drivers that consume kernel symbols. In particular a device driver provided by the third party vendor may consume white list kernel symbols and non white list kernel symbols included in a particular kernel.

The third party vendor may use an extractor on the device driver to identify the white and non white kernel symbols in the device driver. Extractor may be provided by the kernel provider third party vendor or another third party. Extractor may perform a static analysis of the device driver source code or binary code. In particular the third party vendor may run extractor against the device driver source code or binary code to generate the white list kernel symbols and non white list kernel symbols that the device driver consumes for a particular kernel. The generated list of kernel symbols may be used by the third party vendor to have a better understanding of the kernel symbols included and not included in the KABI of the kernel. The third party vendor may send the generated list to server and or request tracker e.g. for storage in database .

Database may include a set of consumers and each consumer of the set of consumers may be associated with one or more kernels. Each kernel may include one or more kernel symbols of the white list type and one or more kernel symbols of the non white list type. Each kernel symbol of the non white list type may correspond to a request from the associated consumer to incorporate the respective kernel symbol of the non white list type into the kernel ABI of a kernel.

In an example the third party vendor sends to request tracker a request including a kernel identifier and a set of non white list kernel symbols that the third party vendor would like incorporated into the white list of the kernel identified by the kernel identifier. The third party vendor may also send in the request or in a separate request one or more reasons to incorporate the set of non white list kernel symbols into the white list of the kernel.

Request tracker may receive from consumer the request to include the set of non white list kernel symbols that consumer would like incorporated into the white list of the kernel. For one or more kernel symbols of the non white list type request tracker may track a quantity of requests for the particular kernel symbol. Accordingly the kernel provider may better determine which kernel symbols in the non white list of a kernel are popular and determine whether to include them in the white list in future releases of the kernel. Request tracker may also receive in the request one or more reasons specified by the third party vendor to convert the set of non white list kernel symbols into the white list of the kernel. Request tracker may store this information into database .

In an example the third party vendor stores data in database and or sends requests to server via a direct API to store kernel symbol data from the generated file. In another example the third party vendor stores data in database and or sends requests to server via an HTTP request over network .

Based on the information from third party vendors the kernel provider may have a better understanding of which kernel symbols are being consumed per kernel which kernel symbols are frequently being used which third party vendors are consuming which kernel symbols the value of a kernel symbol and how important a kernel symbol is to consumers. The kernel provider may analyze the kernel symbol data and generate statistics and reports based on the analysis.

In another example consumer is an internal kernel consumer that uses kernel symbols. The internal kernel consumer may provide maintenance on and development of the kernel and also determine whether to include a kernel symbol in the white list of a kernel.

When the internal kernel consumer updates the kernel e.g. releases a new version of the kernel or recompiles a kernel the list of kernel symbols included in the updated kernel is available. In an example when a kernel is updated kernel symbols from the kernel are extracted and placed in a file e.g. Module.symvers file . The file is generated and includes all of the kernel symbols in the kernel.

In an example the internal kernel consumer sends a request to server for the white list and or non white list kernel symbols included in a given kernel. The request may include a kernel identifier that identifies the given kernel. Server may receive the request search database for the white list and or non white list kernel information associated with the given kernel and return to the internal kernel consumer the white list and or non white list kernel symbols included in the given kernel. The response may provide the internal kernel consumer with a better understanding of which kernel symbols should be included in the next version of the kernel. In an example the internal kernel consumer stores data in database and or sends requests to server via a direct API to store kernel symbol data from the generated file. In another example the internal kernel consumer stores data in database and or sends requests to server via an HTTP request over network .

Database may store a first set of white list kernel symbols and a second set of non white list kernel symbols included in a first kernel and a third set of white list kernel symbols and a fourth set of non white list kernel symbols included in a second kernel. The second kernel may be different from the first kernel. The second kernel may be an updated version of the first kernel or the first kernel may be an updated version of the second kernel.

Server includes a comparison module and notification module . In an embodiment comparison module identifies the first and second kernels and compares one or more kernel symbols associated with the first kernel to one or more kernel symbols associated with the second kernel. The kernel symbols stored in database may be compared and analyzed to determine for example whether a kernel symbol has changed or whether a non white list symbol has been incorporated into the white list of a subsequent kernel release.

Notification module may send based on the comparison a notification indicating a change in one or more kernel symbols associated with the first or second kernels. In an example when a new kernel is built and imported into server comparison module performs one or more comparisons between a kernel symbol included in any two or more kernels.

1. Non White List Kernel Symbol of a First Kernel May be Incorporated into the White List of a Second Kernel

In keeping with the above example comparison module may compare the second set of non white list kernel symbols included in a first kernel to the third set of white list kernel symbols included in the second kernel and determine whether the third set of white list kernel symbols includes a subset of kernel symbols included in the second set of non white list kernel symbols. The second and third sets of kernel symbols are associated with consumer and the third set of kernel symbols is included in a kernel ABI of the second kernel.

If the third set of white list kernel symbols includes a subset of kernel symbols that are included in the second set of non white list kernel symbols this may be an indication that one or more of the consumer s non white list kernel symbols included in the first kernel has been included in the white list of the second kernel. As such notification module may send a notification to consumer indicating that one or more kernel symbols included in the first kernel and of the consumer s non white list type has been included in the white list of the second kernel. Based on the notification the third party vendor may have confidence in continuing to use the particular kernel symbol that has been incorporated into the KABI of the second kernel because the particular kernel symbol will not change in subsequent releases of the second kernel.

In an example all kernel symbols are present in Module.symvers file and a separate file module.whitelist.i686 for the i686 architecture lists the white list kernel symbols for a given kernel. Both of these files may be built as part of the kernel build process. The kernel symbols for a given kernel in the Module.symvers file may be compared to the kernel symbols in the module.whitelist.i686 file for the given kernel. The kernel symbols that are included in the Module.symvers file and not included in the module.whitelist.i686 file may be the kernel symbols in the non white list.

Comparison module may perform this comparison based on a variety of reasons. In an example consumer sends a request to server requesting that the comparison be performed. Consumer may be a third party vendor that provides a device driver having a release cycle. Identifying these kernel symbols may enable the third party vendor to compare different products and or different releases of the device driver. The third party vendor may send the request on a regular basis e.g. based on the release cycle of the third party vendor s product or quarterly .

In another example comparison module performs the comparison based on the kernel being updated. For instance the internal team may decide to incorporate one or more non white list kernel symbols of the first kernel into the white list of the second kernel. This incorporation may be due to requests that have been tracked by request tracker . Comparison module may include an internal compare mechanism. In an example for each consumer that consumes a given kernel comparison module compares the new kernel symbols to corresponding kernel symbols included in a previous version of the given kernel. Notification module may include an internal notification mechanism that notifies consumers that have requested the newly incorporated kernel symbols of such information.

In an example comparison module determines a list of consumers that have previously requested that one or more kernel symbols of the non white list be incorporated into the white list of a kernel. Notification module may send a notification to each consumer in the list of consumers where the notification indicates that one or more kernel symbols of the respective consumer s non white list has been included in the white list of a kernel.

In another example comparison module performs the comparison based on a consumer s manual input. In another example comparison module performs the comparison based on a scheduled comparison. Comparison module may perform the comparison based on other reasons.

The kernel provider may update a kernel symbol in the non white list e.g. via a REST API to server . In an example a kernel symbol included in a kernel may be updated and the updated kernel symbol may be included in a different kernel. According a kernel symbol of the non white list in the first kernel may have a corresponding kernel symbol of the non white list in the second kernel. In the example table above scsi remove host may be included in both the first kernel and the second kernel. The second kernel may be an updated version of the first kernel. If the kernel provider updates scsi remove host in a subsequent kernel release it may be beneficial to notify kernel consumers of the update. In particular it may be desirable for a consumer to be notified when a kernel symbol included in a first kernel has been changed and included in a second kernel. If the second kernel is an updated version of the first kernel the notification may include what changes have been made since the kernel symbol was included in the first kernel.

In an example the consumer is a third party vendor providing a device driver that consumes a given kernel symbol included in a first kernel and the kernel provider changes the given kernel symbol and includes the changed kernel symbol in the second kernel. Accordingly the device driver may be able to access the given kernel symbol in the first kernel but unable to access the corresponding kernel symbol in the second kernel because of the change. Identifying these kernel symbol changes may enable the third party vendor to determine when to compile the device driver for compatibility with a particular kernel. For example to enable the device driver to access the corresponding kernel symbol in the second kernel the third party vendor may recompile the device driver for compatibility with the second kernel. It may be desirable to send a notification to the consumer indicating that the given kernel symbol has changed. Based on the notification the third party vendor may decide to recompile the device driver to consume the corresponding kernel symbol in the second kernel.

In an example the consumer is an internal kernel consumer that receives updates regarding changes to non white list kernel symbols. This information may assist internal kernel consumers maintain and track changes to the kernel.

Each kernel symbol stored in database may be associated with a checksum. In an example a first checksum based on scsi remove host in the first kernel may be generated and a second checksum based on scsi remove host in the second kernel may be generated. If the first checksum matches the second checksum the scsi remove host kernel symbol in the first kernel and the scsi remove host kernel symbol in the second kernel are the same. In contrast if the first checksum does not match the second checksum the scsi remove host kernel symbol in the first kernel and the scsi remove host kernel symbol in the second kernel are different and the function has been changed.

In an embodiment comparison module compares a first checksum of a first kernel symbol of the non white list to a second checksum of a second kernel symbol of the non white list where the first kernel symbol is included in the first kernel and corresponds to the second kernel symbol that is included in the second kernel. For each checksum mismatch notification module may send a notification to the consumer indicating that the first kernel symbol has been changed in the second kernel. The notification may include the one or more differences between the first and second kernel symbol changes. It may be unnecessary to determine whether the kernel symbols have changed in a white list because these kernel symbols do not change.

Comparison module may perform this comparison based on a variety of reasons. In an example consumer sends a request to server requesting that the comparison be performed. The third party vendor may send the request on a regular basis e.g. based on the release cycle of the third party vendor s product or quarterly . In another example comparison module performs the comparison based on the kernel being updated. The kernel may be updated in an internal release or an external release. Notification module may notify a consumer e.g. one or more internal teams that the kernel has been updated.

In another example comparison module performs the comparison based on a consumer s manual input. In another example comparison module performs the comparison based on a scheduled comparison. Comparison module may perform the comparison based on other reasons.

As discussed above and further emphasized here is merely an example which should not unduly limit the scope of the claims. For example although system is described herein with reference to request tracker receiving the kernel symbol data server may receive the kernel symbol data.

Further it should be understood that one or more modules or components e.g. comparison module and notification module in may be combined with another module or component. In an example comparison module and notification module are combined into one module. It should also be understood that one or more modules in may be separated into more than one module. In an example comparison module is split into a first comparison module and a second comparison module not shown .

Additionally each of the modules or components in may reside in a machine different from that shown in . For example request tracker may reside in server or in a physical machine different from server .

Further when server receives kernel symbol data or a request for kernel symbol data the processing may be performed on a single server e.g. server or in parallel with different virtual machines. The analysis of the kernel symbol data may be performed on the virtual machines on the backend. In this way faster performance may be provided to consumers.

Diagram includes server that receives kernel symbol data. In an example kernel symbol data includes a kernel identifier white list kernel symbols included in the kernel identified by the kernel identifier and non white list kernel symbols included in the kernel identified by the kernel identifier. In an example consumer sends kernel symbol data to request tracker which then sends kernel symbol data to server . In another example consumer sends kernel symbol data to server .

Server may be referred to as a host machine that hosts a set of virtual machines. Server includes a hypervisor that creates virtual machines and . Virtual machine includes comparison module A and notification module A and is coupled to database . Similarly virtual machine includes comparison module B and notification module B and is coupled to database .

Server may store the kernel symbol data into a backend cloud having a separate input process that imports kernel symbol data in parallel. Implementing the input process in a backend application and periodically importing kernel symbol data may be fast and effective when server desires to receive quick kernel symbol updates and provide quick analysis e.g. responses and notifications of kernel symbol data for consumers.

In an example consumer may send a request for kernel symbol data that is processed by server using virtual machines and . When multiple kernels and or consumers are analyzed hypervisor may start multiple virtual machines to analyze the kernel symbol data for the different consumers. For example virtual machine may compare a kernel symbol between two kernels for a first consumer and virtual machine may compare a kernel symbol between two kernels for a second consumer. Each of the virtual machines may return the results to server and server may send the appropriate notifications to the consumers.

Method includes steps . In a step an identifier of a first kernel and at least one of a first set of kernel symbols of a first list type and a second set of kernel symbols of a second list type are received from a consumer by one or more processors. In an example request tracker receives by one or more processors from a consumer an identifier of a first kernel and at least one of a first set of kernel symbols of a first list type and a second set of kernel symbols of a second list type.

In a step the kernel identifier and at least one of the first set of kernel symbols of the first list type and the second set of kernel symbols of the second list type are stored in a database where each kernel symbol of the first list type and of the second list type in the database is included in one or more kernels and each kernel symbol of the first list type is included in a kernel ABI application binary interface of one or more of the associated kernels. In an example request tracker stores in a database the kernel identifier and at least one of the first set of kernel symbols of the first list type and the second set of kernel symbols of the second list type where each kernel symbol of the first list type and of the second list type in the database is included in one or more kernels and each kernel symbol of the first list type is included in a kernel ABI application binary interface of one or more of the associated kernels.

In a step a second kernel associated with a third set of kernel symbols of the first list type and a fourth set of kernel symbols of the second list type is identified. In an example comparison module identifies a second kernel associated with a third set of kernel symbols of the first list type and a fourth set of kernel symbols of the second list type.

In a step one or more kernel symbols included in the first kernel is compared to one or more kernel symbols included in the second kernel. In an example comparison module compares one or more kernel symbols included in the first kernel to one or more kernel symbols included in the second kernel.

In a step a notification to the consumer is sent based on the comparison the notification indicating a change in one or more kernel symbols included in the first kernel or second kernel. In an example notification module sends based on the comparison a notification to the consumer the notification indicating a change in one or more kernel symbols included in the first kernel or the second kernel.

It is also understood that additional method steps may be performed before during or after steps discussed above. It is also understood that one or more of the steps of method described herein may be omitted combined or performed in a different sequence as desired.

Computer system includes a bus or other communication mechanism for communicating information data signals and information between various components of computer system . Components include an input output I O component that processes a user action such as selecting keys from a keypad keyboard selecting one or more buttons or links etc. and sends a corresponding signal to bus . I O component may also include an output component such as a display and an input control such as a cursor control such as a keyboard keypad mouse etc. . An optional audio input output component may also be included to allow a user to use voice for inputting information by converting audio signals into information signals. Audio I O component may allow the user to hear audio. A transceiver or network interface transmits and receives signals between computer system and other devices via a communication link to a network. In an embodiment the transmission is wireless although other transmission mediums and methods may also be suitable. A processor which may be a micro controller digital signal processor DSP or other processing component processes these various signals such as for display on computer system or transmission to other devices via communication link . Processor may also control transmission of information such as cookies or IP addresses to other devices.

Components of computer system also include a system memory component e.g. RAM a static storage component e.g. ROM and or a disk drive . Computer system performs specific operations by processor and other components by executing one or more sequences of instructions contained in system memory component . Logic may be encoded in a computer readable medium which may refer to any medium that participates in providing instructions to processor for execution. Such a medium may take many forms including but not limited to non volatile media volatile media and transmission media. In various implementations non volatile media includes optical or magnetic disks or solid state drives volatile media includes dynamic memory such as system memory component and transmission media includes coaxial cables copper wire and fiber optics including wires that include bus . In an embodiment the logic is encoded in non transitory computer readable medium. In an example transmission media may take the form of acoustic or light waves such as those generated during radio wave optical and infrared data communications.

Some common forms of computer readable media include for example floppy disk flexible disk hard disk magnetic tape any other magnetic medium CD ROM any other optical medium punch cards paper tape any other physical medium with patterns of holes RAM PROM EEPROM FLASH EEPROM any other memory chip or cartridge or any other medium from which a computer is adapted to read.

In various embodiments of the present disclosure execution of instruction sequences to practice the present disclosure may be performed by computer system . In various other embodiments of the present disclosure a plurality of computer systems coupled by communication link to the network e.g. such as a LAN WLAN PTSN and or various other wired or wireless networks including telecommunications mobile and cellular phone networks may perform instruction sequences to practice the present disclosure in coordination with one another.

Where applicable various embodiments provided by the present disclosure may be implemented using hardware software or combinations of hardware and software. Also where applicable the various hardware components and or software components set forth herein may be combined into composite components including software hardware and or both without departing from the spirit of the present disclosure. Where applicable the various hardware components and or software components set forth herein may be separated into sub components including software hardware or both without departing from the spirit of the present disclosure. In addition where applicable it is contemplated that software components may be implemented as hardware components and vice versa.

Application software in accordance with the present disclosure may be stored on one or more computer readable mediums. It is also contemplated that the application software identified herein may be implemented using one or more general purpose or specific purpose computers and or computer systems networked and or otherwise. Where applicable the ordering of various steps described herein may be changed combined into composite steps and or separated into sub steps to provide features described herein.

The foregoing disclosure is not intended to limit the present disclosure to the precise forms or particular fields of use disclosed. As such it is contemplated that various alternate embodiments and or modifications to the present disclosure whether explicitly described or implied herein are possible in light of the disclosure. Changes may be made in form and detail without departing from the scope of the present disclosure. Thus the present disclosure is limited only by the claims.

