---

title: Runtime generation and injection of java annotations
abstract: An annotation generator utility is implemented. The annotation generator utility reads, from a properties file, configurations of a Java component. The annotation generator utility generates annotations corresponding to the configurations. The annotation generator utility injects the annotations into compiled source code of the Java component. In one aspect, the annotations are injected into compiled source code of the Java component at build time. In another aspect, the annotations are injected into compiled source code of the Java component at runtime.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09471345&OS=09471345&RS=09471345
owner: SAP SE
number: 09471345
owner_city: Walldorf
owner_country: DE
publication_date: 20130925
---
In Java a deployment descriptor is a configuration file for an artifact that is to be deployed for example to a container. The deployment descriptor may be an Extensible Markup Language XML document that describes the deployment settings of an application a module or a component. The deployment settings may be specific container options security settings configuration requirements etc. At runtime a Java server reads the deployment descriptor and acts upon the application module or component accordingly. Typically Java components are compiled and packaged into one or more units for deployment e.g. Java archive file JAR enterprise archive file EAR web archive file WAR etc. The package may include the compiled source code of the component and the deployment descriptor. Because deployment descriptor specifies metadata information as a file external to the respective compiled source code of the component it can be changed without the need to modify the source code of the component. Nevertheless to change the metadata information specified by the deployment descriptor the package containing the deployment descriptor and the component needs to be unpackaged and repackaged after the deployment descriptor is modified.

Deployment descriptors may generate boilerplate code that may be redundant. In an effort to minimize boilerplate code annotations are introduced in later versions of the Java Platform Enterprise Edition e.g. Java EE 5 . One advantage of annotations is that they reduce the amount of code a developer needs to write. Annotations provide a mechanism for associating Java classes interfaces fields methods etc. with metadata information. Annotations are considered among other things as an alternative to deployment descriptors required by earlier versions of Java EE or the Java Platform Standard Edition Java SE . As opposed to deployment descriptors annotations maintain the metadata information as part of the program itself e.g. as part of the source code of the component. For example annotations may be included into the source code of a Java class to specify configurations of the Java class required at run time. Annotations to be included into the deployment package are compiled as part of the source code of the respective component. To modify the compiled annotations a possession of the source code is required to change to source code itself. In case where a customer of a software provider would desire to customize configurations the consumer needs to either possess the source code which is rare or request the desired modification from the software provider. In any case to modify annotations the source code of the component needs to be modified then recompiled or rebuild repackaged and redeployed. Such approach might be cumbersome time consuming and less scalable. Furthermore because the aforementioned actions require a recompilation to modify the annotations the approach is not performed dynamically e.g. during runtime of the component.

Embodiments of techniques for runtime generation and injection of Java annotations are described herein. In the following description numerous specific details are set forth to provide a thorough understanding of the embodiments. One skilled in the relevant art will recognize however that the embodiments can be practiced without one or more of the specific details or with other methods components materials etc. In other instances well known structures materials or operations are not shown or described in detail.

Reference throughout this specification to one embodiment this embodiment and similar phrases means that a particular feature structure or characteristic described in connection with the embodiment is included in at least one of the one or more embodiments. Thus the appearances of these phrases in various places throughout this specification are not necessarily all referring to the same embodiment. Furthermore the particular features structures or characteristics may be combined in any suitable manner in one or more embodiments.

Nowadays in the Java computer programming model configurations are often implemented using annotations. Annotations are metadata that can be added to Java source code. Configurations of Java components applications or modules can be implemented via annotations. Examples of Java applications modules or components include but are not limited to servlets web applications web containers application clients or applets JavaServer Faces JavaServer Pages JSPs Enterprise JavaBeans EJBs such as message driven beans etc. Elements of Java components that may be annotated include but are not limited to Java classes methods interfaces variables constructors fields parameters packages etc. Examples of annotations include but are not limited to Java Specification Request 250 JSR 250 and JSR175. Java annotations can be reflective in that they can be embedded in class files generated by the compiler. Further annotations may be retained by the Java Virtual Machine VM to be made retrievable at runtime.

At annotations are generated based on the configurations. The generated annotations correspond to the configurations that are read. In one embodiment the configurations may be generated using instrumentation libraries or bytecode manipulation libraries such as Java Programming Assistant Javassist and Code Generation Library cglib . In one embodiment the properties file is read and for each key value pair corresponding annotation is generated.

At the annotations are automatically injected into compiled source code of the Java component. For example the annotations may be injected into bytecode of a class file representing the Java component. Annotations may also be injected into object code of a component. One advantage is that annotations may be added or modified without the possession of the original source code of the Java component. Thus the original source code is not needed to add or modify configurations of a component. Further the original source code itself is not modified. The source code of the Java component that may be in the process of operation remains unchanged. Another advantage is that annotations may be added or modified dynamically during runtime. Also annotations may be injected without the need of recompilation of the Java component. Thus configurations may be changed on the fly.

In one embodiment the Java component may be without annotations. In such case annotations are generated and added to the Java component. Alternatively the Java component may originally be annotated. In such case modified annotations may be generated the original annotations may be deleted and new modified annotations may be added or inserted.

Upon detecting class loading of the class file of the Java component at configurations of the Java component are read from a file. At upon reading the configurations annotations corresponding to the configurations are generated. At the annotations are injected into byte code of the class file of the Java component. The annotations are injected at runtime during class loading of the class file of the Java component. The annotations may be injected while the Java component is operating. At the class file with the injected annotations is loaded by a class loader e.g. the class file may be loaded by Java Classloader.

Table 1 below illustrates a sample code that reads configurations from a properties file generates annotations based on the configurations and injects the generated annotations into a class file of Java component.

In one embodiment a key MyAnnotation is specified in properties file . Annotation generator utility reads corresponding value of the key MyAnnotation from properties file and injects or adds the respective value as annotation to ccFile that represents a Java class file of the Java component as illustrated in Table 1 . Sample code illustrated in Table 1 may be executed by annotation generator utility .

Consumer can change and create configurations dynamically and automatically without the need to request desired changes from software provider . For example in case of a message driven bean where one component connects to a particular queue and provider consumer may desire to scale out and have components listening to different queues. Using annotation generator utility consumer may modify or create configurations unilaterally and automatically. For example a customer may customize one Java component to listen to different queues for different scenarios. The same Java component may be customized using an annotation generator utility by various customers as determined by their respective requirements. Alternatively the Java component may be customized using an annotation generator utility by software provider for various consumers or customers. Further consumer does not need to possess the source code of the Java component to change the configurations as the original source code remains unchanged while only the compiled source code is modified by the injected annotations.

Some embodiments may include the above described methods being written as one or more software components. These components and the functionality associated with each may be used by client server distributed or peer computer systems. These components may be written in a computer language corresponding to one or more programming languages such as functional declarative procedural object oriented lower level languages and the like. They may be linked to other components via various application programming interfaces and then compiled into one complete application for a server or a client. Alternatively the components maybe implemented in server and client applications. Further these components may be linked together via various distributed programming protocols. Some example embodiments may include remote procedure calls being used to implement one or more of these components across a distributed programming environment. For example a logic level may reside on a first computer system that is remotely located from a second computer system containing an interface level e.g. a graphical user interface . These first and second computer systems can be configured in a server client peer to peer or some other configuration. The clients can vary in complexity from mobile and handheld devices to thin clients and on to thick clients or even other servers.

The above illustrated software components are tangibly stored on a computer readable storage medium as instructions. The term computer readable storage medium should be taken to include a single medium or multiple media that stores one or more sets of instructions. The term computer readable storage medium should be taken to include any physical article that is capable of undergoing a set of physical changes to physically store encode or otherwise carry a set of instructions for execution by a computer system which causes the computer system to perform any of the methods or process steps described represented or illustrated herein. A computer readable storage medium may be a non transitory computer readable storage medium. Examples of a non transitory computer readable storage media include but are not limited to magnetic media such as hard disks floppy disks and magnetic tape optical media such as CD ROMs DVDs and holographic devices magneto optical media and hardware devices that are specially configured to store and execute such as application specific integrated circuits ASICs programmable logic devices PLDs and ROM and RAM devices. Examples of computer readable instructions include machine code such as produced by a compiler and files containing higher level code that are executed by a computer using an interpreter. For example an embodiment may be implemented using Java C or other object oriented programming language and development tools. Another embodiment may be implemented in hard wired circuitry in place of or in combination with machine readable software instructions.

A data source is an information resource. Data sources include sources of data that enable data storage and retrieval. Data sources may include databases such as relational transactional hierarchical multi dimensional e.g. OLAP object oriented databases and the like. Further data sources include tabular data e.g. spreadsheets delimited text files data tagged with a markup language e.g. XML data transactional data unstructured data e.g. text files screen scrapings hierarchical data e.g. data in a file system XML data files a plurality of reports and any other data source accessible through an established protocol such as Open DataBase Connectivity ODBC produced by an underlying software system e.g. ERP system and the like. Data sources may also include a data source where the data is not tangibly stored or otherwise ephemeral such as data streams broadcast data and the like. These data sources can include associated data foundations semantic layers management systems security systems and so on.

In the above description numerous specific details are set forth to provide a thorough understanding of embodiments. One skilled in the relevant art will recognize however that the embodiments can be practiced without one or more of the specific details or with other methods components techniques etc. In other instances well known operations or structures are not shown or described in details.

Although the processes illustrated and described herein include series of steps it will be appreciated that the different embodiments are not limited by the illustrated ordering of steps as some steps may occur in different orders some concurrently with other steps apart from that shown and described herein. In addition not all illustrated steps may be required to implement a methodology in accordance with the one or more embodiments. Moreover it will be appreciated that the processes may be implemented in association with the apparatus and systems illustrated and described herein as well as in association with other systems not illustrated.

The above descriptions and illustrations of embodiments including what is described in the Abstract is not intended to be exhaustive or to limit the one or more embodiments to the precise forms disclosed. While specific embodiments and examples are described herein for illustrative purposes various equivalent modifications are possible as those skilled in the relevant art will recognize. These modifications can be made in light of the above detailed description. Rather the scope is to be determined by the following claims which are to be interpreted in accordance with established doctrines of claim construction.

