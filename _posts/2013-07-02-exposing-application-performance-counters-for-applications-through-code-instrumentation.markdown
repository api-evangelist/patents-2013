---

title: Exposing application performance counters for applications through code instrumentation
abstract: Disclosed is a method for adding performance counters to an application after compilation of the application to Common Intermediate Language code without a requirement for code changes to the original application code or application recompilation from the development side. With regard to a further aspect of a particularly preferred embodiment, the invention may provide a method for adding the performance counters by declarative instrumentation of an application at runtime or compile time, without the need for an application developer to hardcode instrumentation logic into the application. An instrumentation configuration file provides declarative definition for performance counters that are to be added to a particular application, and particularly includes a complete list of performance counters that need to be added and settings for each performance counter.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08839041&OS=08839041&RS=08839041
owner: Microsoft Corporation
number: 08839041
owner_city: Redmond
owner_country: US
publication_date: 20130702
---
This application is a continuation of and claims benefit of co pending U.S. patent application Ser. No. 13 252 648 entitled Exposing Application Performance Counters For .NET Applications Through Code Instrumentation filed with the U.S. Patent and Trademark Office on Oct. 4 2011 and which is to issue as U.S. Pat. No. 8 479 052 on Jul. 2 2013 the specification of which is incorporated herein by reference. U.S. patent application Ser. No. 13 252 648 in turn is a continuation of and claims benefit of co pending U.S. patent application Ser. No. 12 503 313 entitled Exposing Application Performance Counters For .NET Applications Through Code Instrumentation filed with the U.S. Patent and Trademark Office on Jul. 15 2009 and which has now issued as U.S. Pat. No. 8 051 332 the specification of which is incorporated herein by reference. U.S. patent application Ser. No. 12 503 313 in turn is based upon and claims benefit of U.S. Provisional Patent Application Ser. No. 61 134 919 entitled Exposing Application Performance Counters For .NET Applications Through Code Instrumentation filed with the U.S. Patent and Trademark Office on Jul. 15 2008 by the inventors herein the specification of which is incorporated herein by reference.

This invention relates generally to application performance monitoring and more particularly to exposing application performance counters by instrumenting application code at compile time or runtime.

Performance counters provide statistical information about application behavior. The information exposed through performance counters may be used by operations useful for by way of non limiting example i debugging and troubleshooting performance and resource usage problems ii tuning application configuration to achieve optimum performance iii providing capacity management to properly scale applications according to business needs and iv providing application health monitoring and service level monitoring.

Performance counters are essential for detecting and troubleshooting application issues related to high application load. The typical problems that are addressed by performance counters are slow performance and high consumption of shared resources such as CPU network memory and file systems. In addition to those problems performance counters can be used for warning about high usage of internal application resources. For example for an application that uses an internal queue for storing requests the application may provide a performance counter that will show percent of queue used. When usage goes above a predefined threshold a warning to an administrator may be issued. Administrators may use performance counters to pinpoint a source of performance or resource usage problems. After resolution of a problem administrators use performance counters to verify the resolution and ensure that the application has a healthy behavior.

In addition to using performance counters to troubleshoot problems administrators can use performance counters in a proactive mode to analyze application runtime parameters and to fine tune the application configuration environment configuration and hardware to achieve optimal performance.

Still further performance counters may be used for capacity planning. To do a proper capacity planning administrators need to be able to map business requirements for application performance and scalability into infrastructure requirements for memory CPU power network and so on. Performance counters allow quantifying user load placed on an application and the corresponding load placed on infrastructure resources. Typically an application may need to provide a set of counters to measure the current load such as number of users number of transactions and so on. Performance counters for measuring load on resources are typically provided by an operating system or in case of non standard resources by vendor applications.

Application health and service level monitoring is yet another area that may rely on information provided by performance counters. While information warning and error events report about important occurrences inside a monitored application performance counters reflect the current state of an application in a quantifiable form. The first step for using performance counters for health monitoring is to define the normal behavior of an application and values for performance counters that correspond to the normal behavior. After that critical deviations from normal behavior need to be identified. Most monitoring tools allow generating warning or error messages when the value of a performance counter crosses a threshold. An example of that can be monitoring for the amount of available memory and generating a warning when the application reaches a low level memory condition.

While performance counters are critical for application manageability and supportability software development teams typically do not spend an appropriate amount of time on adding performance counters to their applications. Traditionally application manageability requirements are considered optional and are treated with lower priority compared to functional or performance requirements. As a result the majority of applications in production do not expose performance counters at all or expose an insufficient set of performance counters.

It would therefore be advantageous to provide a system and method by which performance counters could be added to an application after the application code has been authored and without requiring changes to the finalized development code thus adding an application management function to an application that would otherwise have none.

In accordance with one aspect of a particularly preferred embodiment performance counters may be added to an application after the fact without a requirement for code changes or application recompilation from the development side. With regard to a further aspect of a particularly preferred embodiment the invention may provide a method for adding the performance counters by declarative instrumentation of an application at runtime or compile time without the need for an application developer to hardcode instrumentation logic into the application. An instrumentation configuration file provides declarative definition for performance counters that are to be added to a particular application and particularly includes a complete list of performance counters that need to be added and settings for each performance counter.

The invention summarized above may be better understood by referring to the following description which should be read in conjunction with the accompanying drawings in which like reference numbers are used for like parts. This description of an embodiment set out below to enable one to practice an implementation of the invention is not intended to limit the preferred embodiment but to serve as a particular example thereof. Those skilled in the art should appreciate that they may readily use the conception and specific embodiments disclosed as a basis for modifying or designing other methods and systems for carrying out the same purposes of the present invention. Those skilled in the art should also realize that such equivalent assemblies do not depart from the spirit and scope of the invention in its broadest form.

Disclosed herein are methods by which performance counters may be added to an application such as a .NET application after the application has been fully coded and without requiring code changes or application recompilation from the development side. Such performance counters may be added to such an application by declarative instrumentation of the application at either runtime or compile time. As used herein an application is instrumented by inserting code that performs the necessary performance counter functions such as uniquely naming each performance counter instance for a particular application method extracting the necessary data from the method execution etc. with such code insertion being carried out at compile time or runtime of the application. This code insertion process if referred to as instrumenting as it provides instruments for inserting performance counters into an already compiled application and for collecting data necessary to provide an overall application management function.

As shown in prior to compilation of the CIL code into machine code the method according to one aspect of a particularly preferred embodiment of the invention allows performance counters to be added to application by instrumentation of CIL code . As will be explained in further detail below instrumentation of CIL code can be done either at compile time or at run time. An instrumentation module is configured to communicate with CIL code such that instrumentation module may instrument methods of application with performance counters that are appropriate for such method. As discussed in greater detail below the instrumentation code that the instrumentation module inserts into methods comprises declarative instrumentation code to retrieve the appropriate values from application method runtime parameters and class member variables to name the method specific performance counters to calculate performance counter filter rules and to set a value for the performance counter. The instrumentation code preferably comprises an instrumentation type definition that is generated by instrumentation module through consultation with an instrumentation configuration file which instrumentation configuration file as discussed in greater detail below provides declarative definition for the particular performance counters that need to be added to a given application such as application . More particularly instrumentation configuration file preferably contains a complete list of performance counters that need to be added to a given application along with the necessary settings for each such performance counter.

Performance counters in the Windows Operating System have the following characteristics counter class counter name counter instance name window counter type and counter value. Counter class counter name and counter instance name uniquely identify a counter within the operating system. Counter class describes the type of object to which a counter belongs counter name describes the value that a counter exposes and counter instance describes an instance of an object for which the value is exposed. For example one of the operating system standard counters is Processor Time for a process. For this counter counter class is process counter name is Processor Time and counter instance is a name of a process to which the counter belongs. Counter class and counter name are typically based on static information and need to be registered with the operating system during counter configuration. Counter instance name is typically created dynamically and may be based on runtime information. Counter value reflects a value for an object property described by the counter name. In our example the counter value is an amount of processor time for a specific process at a certain point in that time. An application that exposes a performance counter is responsible for setting the value for a performance counter. Windows counter type is a helper information that tells the operating system how to interpret the value of a performance counter.

An application may expose performance counters that allow the operating system to observe application behavior. For example we may have an order processing application ACME that processes orders for multiple companies. In our example we can assume that a logic for processing an order is implemented in a method call processOrder and that this method takes a name of a company for which an order is processed as a parameter with the name CompanyName and an amount for the order as a parameter with the name OrderAmount . The application may expose a performance counter that shows the number of large orders processed for each company where by way of non limiting example a large order is an order with an amount greater than 1 000. In this example the counter class can be the application name ACME counter name can be Large Order Count and counter instance can be the name of a company for which orders are processed. Counter value is the number of orders processed. In order to expose the counter value every time that the method processOrder is called the application needs to look up the appropriate counter instance based on the parameter companyName and after that if a criteria for a counter matches increment the counter value by one. In our case the criteria or filtering rule for the counter is based on an order amount being greater than 1000. Thus as depicted in this example the methods of the invention may be used to insert counters in an already compiled application to define rules for counter class counter name and counter instance name to associate counters with a specific method and to define filtering rules for a counter based on a method runtime context which includes method parameters member variables and static variables.

As shown more particularly in instrumentation configuration file includes an application method performance counter type association table and a performance counter type definition . Instrumentation module locates class names and application method names that need to be instrumented from association table and determines the associated type or types of performance counter that needs to be instrumented for that particular application method. Those of ordinary skill in the art will recognize that a single application method may be instrumented with multiple types of performance counters. For a given application method instrumentation module may use instrumentation configuration file to generate an instrumentation type definition that comprises an identification of what performance counters need to be exposed an identification of what conditions need to applied for method parameters class member variables and static classes and what should be used for a performance counter name and what should be used for the performance counter instance name. The instrumentation type definition thus defines the type of modification that is to be performed on the method body .

Performance counter type definition in turn provides a list of performance counter types and for each such performance counter type a rule set for defining performance counter class and name a rule set for defining performance counter instance name a rule set for filtering performance counters to a subset of method executions and a rule set for defining where in the CIL code the instrumentation code is to be inserted.

Available performance counter types are varied and may include by way of non limiting example performance counters for the total number of executions performance counters for the number of executions per second performance counters for the average execution time performance counters for the maximum execution time and such other performance counters as will be apparent to those of ordinary skill in the art and as may be called for by a particular application. As mentioned briefly above for each performance counter type performance counter type definition provides a rule set for defining performance counter class and name and a rule set for defining counter instance name. The instrumentation module uses regular expressions to describe such naming rules. It should be appreciated that while the invention uses regular expressions any other language for parsing and building values from string values may be used for defining naming rules. Naming rules for defining performance counter class and name are preferably based on at least a method name and static application properties. Naming rules define the names of static application properties that are used for constructing counter class and counter name what portions of values of those properties and what portion of the method name are used and in what order to combine them together to get the counter class and counter name. Naming rules for defining performance counter instance name are preferably based on at least a method name static application properties runtime application properties and may optionally also be based on values of method parameters member variables and static classes. Naming rules define the names of static application properties runtime application properties method parameters member variable and static variables that are used for constructing counter instance name what portions of values of those properties and what portion of the method name are used and in what order to combine them together to get the counter instance name. In the example above we demonstrated how an instance name can be based on a value of a method parameter. We based instance name for the counter Large Order Number on a value of the method parameter CompanyName .

Next as mentioned above rule set provides rules for filtering performance counters to a subset of method executions. Such filtering rules are preferably based on at least runtime application properties method parameters class member variables and member variables of static classes. Filtering rules define the names of static application properties runtime application properties method parameters member variable and static variables that are used for performance counter filtering and define filtering criteria for each used value. Filtering criteria for numeric values is defined using comparison operands filtering criteria for string values defined using regular expressions. It should be appreciated that while the invention uses regular expressions and comparison operands any other language for comparing string and numeric values may be used for filtering criteria rules. In the example above we demonstrated how a filtering rule can be based on a value of a method parameter. We based filtering rule for counter Large Order Number on a value of the method parameter orderAmount and set greater that 1000 as the filtering criteria.

Still further rule set provides placement rules defining where in the method body of the CIL code the instrumentation code should be inserted and particularly whether the instrumentation should be inserted at the beginning of a method the end of a method or at a specific location inside of a method body. The particular location or locations at which such code should be inserted is determined by the type of performance counter that is to be inserted. For instance count based performance counters require that the instrumentation code be inserted only at the beginning of a method. Duration based performance counters on the other hand require instrumentation insertion at the beginning of a method and at the end of a method. Instrumentation inserted at the beginning of a method reads a method start time stamp and stores it. Instrumentation inserted at the end of the method reads a method finish time stamp and calculates duration based on the difference between start and finish time stamps. Because a CIL method may have multiple exit points the instrumentation module preferably detects all exit points and instruments all of them appropriately in the case when instrumentation is required at the end of a method. Exit points are detected by CIL return instruction. Each exit point is instrumented with the end of the method instrumentation for taking a finish time stamp and calculating duration.

After the CIL code has been instrumented and the methods are executed as machine code the performance counters may generate the particular data start time stamps finish time stamps etc. and transfer that data to a performance manager for processing.

After the particular performance counter types that are to be instrumented are determined instrumentation module reads naming rules for defining counter class and counter name and retrieves the appropriate method name and static application properties as described above to define the counter class and counter name. At step the instrumentation module generates regular expressions describing such naming rules for addition to instrumentation code . Likewise at step the instrumentation module reads naming rules for the identified performance counter types to define the counter instance name and retrieves the appropriate list of method parameters class member variables and static classes member variables as described above to define the counter instance name. At step the instrumentation module generates naming rules describing such performance counter instance naming rules for addition to instrumentation code . Those naming rules are configured to retrieve the corresponding values from an application method runtime parameters and class member variables and to calculate the performance counter instance name.

At step instrumentation module reads filtering rules for the identified performance counter types to filter the counters to a subset of method executions and retrieves the appropriate list of method parameters class member variables and static classes member variables as described above that are used in those filtering rules. At step the instrumentation module generates regular expressions describing such filtering rules for addition to instrumentation code . Those filtering rules are configured to retrieve the corresponding values from application method runtime parameters and class member variables calculate filtering expressions and decide if those values match with the filtering rules.

At step instrumentation module reads placement rules for placement of the instrumentation code into the CIL method body and at step adds to instrumentation code appropriate instruction of where such instrumentation should be inserted.

Last at step the instrumentation module completes the generation of the instrumentation code section by generating and adding to instrumentation code analysis instructions to determine whether a particular instance name is already registered with the operating system. The analysis instructions are configured such that i if the instance name is not yet registered with the operating system a new instance is created and the performance counter value is incremented on the required value ii if the instance name is already registered with the operating system then the instrumented code simply increments the value of the counter and iii the instance based instrumentation logic executes only when the method runtime context which includes method parameters member variables and static variables matches the filtering rules.

Referring next to a schematic view of an exemplary method is shown that may be carried out by instrumentation module of to instrument CIL code with performance counters using instrumentation code . At step instrumentation module reads the instrumentation configuration file locates class names application method names that need to be instrumented and the required type of instrumentation as discussed in detail above with regard to to generate instrumentation code . Next at step instrumentation controller locates the CIL method body i.e. the code that is being modified to expose appropriate performance counters for an application method that is to be instrumented. In accordance with a particularly preferred embodiment of the invention step may be carried out either at compile time or at run time. The decision to perform the instrumentation at compile or runtime is based on the usage scenarios. Compile time instrumentation allows the instrumentation to be carried out only once during the compile time but after that instrumentation is fixed. Runtime instrumentation requires executing instrumentation during each application load. Runtime instrumentation is more flexible but requires access to the application runtime environment and creates extra overhead during loading of the application. If the instrumentation is to be carried out at compile time the instrumentation module reads metadata for the assembly file for the application. The metadata contains a list of classes and methods defined in the assembly combined with information about the method body location within the assembly. The instrumentation module looks up the method body address based on the method name from the list of methods in the assembly metadata and retrieves the method body. Likewise in the case of run time installation instrumentation module subscribes on the Just in Time JIT compilation callback of the .NET profiling API. The compilation callback has a function ID as callback parameters which function ID uniquely identifies an application method. Instrumentation module reads an application method body based on the function ID. Next at step instrumentation module initiates instrumentation of the method body to expose the appropriate performance counters. Instrumentation module defines the type of modification to be performed on the CIL method body by the type of instrumentation specified in the instrumentation configuration file and more particularly by the instrumentation type definition created for a given application method that is to be instrumented with performance counters. As explained above depending upon the particular performance counter being inserted the instrumentation code is inserted into the CIL method body at a location determined by the placement rules of performance counter type definition . Because a CIL method may have multiple exit points the instrumentation manager detects all exit points and instruments all of them appropriately in the case when instrumentation is required at the end of a method. At step based upon the filtering rules in performance counter type definition the instrumentation module inserts declarative instrumentation code into method body to a retrieve the corresponding values from application method runtime parameters and class member variables b calculate filtering expressions and c decide if a method runtime context which includes method parameters member variables and static variables matches with the filtering rules. Next at step based upon naming rules for defining counter instance name and naming rules for defining counter class and counter name the instrumentation module inserts declarative instrumentation code into method body to a retrieve the corresponding values from an application method runtime parameters and class member variables b calculate the performance counter instance name and c calculate the performance counter class and counter name. Next at step instrumentation module inserts analysis instructions formatted as declarative instrumentation code into method body to determine whether or not a performance counter instance name is already registered which analysis instructions are configured such that a if the instance name is not registered a new instance is created and the performance counter value is incremented on the required value b if the instance name is already registered the instrumented code just increments the value of the counter and c the instance based instrumentation logic executes only when the method context matches the filtering rules.

While the above steps are recited as following a particular sequence those of ordinary skill in the art will recognize that such steps need not be carried out in precisely the sequence recited and may be varied to fit a particular application without departing from the spirit and scope of the invention.

Instrumentation module and the methods depicted in may be implemented on a computer system an exemplary embodiment of which is shown in . A computing device may include at least one processor and system memory . System memory may be volatile such as RAM non volatile such as ROM flash memory etc. or some combination of the two. System memory may include an operating system one or more program modules and program data . Operating system may include a component based framework that supports components objects inheritance polymorphism and reflection and may provide an object oriented component based application programming interface API such as that of the .NET Framework manufactured by Microsoft Corporation Redmond Wash. Computing device may also include additional removable data storage devices and non removable data storage devices such as by way of non limiting example magnetic disks optical disks or tape. Such computer storage media may include volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Each of system memory removable storage and non removable storage may include RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be accessed by computing device . Computing device may also include one or more input devices such as a keyboard mouse pen voice input device touch input device etc. one or more output devices such as a display printer speakers etc. and such other devices as may be particularly suited to a specific application as will be evident to those of ordinary skill in the art. Moreover computing device may also include a communications manager allowing communication between computing device and other external computing devices such as over a computer network. Communications manager may be implemented through computer readable instructions data structures program modules or other data in a modulated data signal i.e. a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal such as a carrier wave or other transport mechanism and includes any information delivery media and may include wired media such as a wired network or direct wired connection and wireless media such as acoustic RF infrared and other wireless media.

Referring again to after method body has been instrumented with appropriate performance counters and the particular application method or methods have been executed data produced from the performance counters may be directed to a performance manager for analysis and application management as would typically be implemented for the reception analysis and use of performance counters in an application.

While instrumentation based performance counters can be used in a variety of usage scenarios it is important to note that the primary usage scenarios enabled by the method described herein may include exposing performance counters for business activities and external service providers.

In accordance with another aspect of a preferred embodiment of the invention the methods described herein may be used to define the boundary of business activity based on an application method boundary and application method context. The method name and method context are used for identifying business activity. For ASP.NET applications the notion of activity is based on an ASP.NET page request. The ASP.NET page request boundary is defined by the ProcessRequest method. The method described herein instruments the ProcessRequest method with counters for number of requests and average execution time defines counter instance naming rules based on application name and page name and filtering rules based on page name. Counter instance naming rules define the names of the counter instance as a concatenation of an application name string and a page name string. It should be appreciated that while the exemplary embodiment of the invention described above uses this naming approach for instance name other naming approaches may be used for the instance name without departing from the spirit and scope of the invention. Filtering rules use criteria based on page name to limit the performance counters to specific pages only.

For Web Service and WCF applications the same approach may be used. The method described herein instruments the ProcessRequest method with counters for number of requests and average execution time and defines counter instance naming rules based on an application name and the WSDL action from the method context and filtering rules based on the WSDL action from the method context. Counter instance naming rules define names of the counter instance as a concatenation of an application name string and the WSDL action from the method context string. Again it should be appreciated that while the exemplary embodiment of the invention described above uses this naming approach for instance name other naming approaches may be used for the instance name without departing from the spirit and scope of the invention. Filtering rules use criteria based on the WSDL action to limit the performance counters to the WSDL actions only.

The method according to another aspect of a particularly preferred embodiment of the invention exposes performance counters for external service providers by instrumenting the methods responsible for communication with a service provider. Those methods are typically provided in libraries that implement interface for communication with an external service provider. An exemplary system and method for instrumenting .NET libraries and particularly for instrumenting those libraries to discover application dependencies through instrumentation of such libraries is described in copending and co owned U.S. application Ser. No. 12 503 321 titled Automatic Incremental Application Dependency Discovery Through Code Instrumentation and filed on Jul. 15 2009 the specification of which is incorporated herein by reference in its entirety. Some examples of external service providers that may be supported by the method described herein are Microsoft SQL Server Oracle ODBC data source OLEDb data sources IBM DB2 Web Services and WCF services. The methods described herein instrument application methods that execute requests against those external service providers. Information about the name of the external service provider is available in the context of those methods. For a database service provider the service provider name is available as a part of the connection string. For Web Service and WCF service providers information about the service provider name is available as part of the URI. The methods according to one aspect of a particularly preferred embodiment of the invention use the service provider name for defining the counter instance name and filtering options for performance counters. Counter instance naming rules define names of the counter instance as the service provider name. Filtering rules use criteria based on the service provider name to limit the performance counters to specific service providers only.

Having now fully set forth the preferred embodiments and certain modifications of the concept underlying the present invention various other embodiments as well as certain variations and modifications of the embodiments herein shown and described will obviously occur to those skilled in the art upon becoming familiar with said underlying concept. It should be understood therefore that the invention may be practiced otherwise than as specifically set forth herein.

