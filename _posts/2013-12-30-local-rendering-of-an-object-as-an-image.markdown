---

title: Local rendering of an object as an image
abstract: Techniques for locally rendering an object as an image may be provided. For example, an application may be executed by a computing device to access and retrieve information from a network-based resource and may display the retrieved information to a user of the computing device. In response to identifying (e.g., by way of a user selection or an automated selection) of an object within the displayed information, the application may locally process the object to generate a graphics object. Further, the application may configure the graphics object to support image-rendering operations by, for example, importing properties from the object into the graphics object and storing the graphics object as binary data at a location in a local memory of the application. Subsequently, the application may use the binary data and the location in the local memory to render an image based on the graphics object.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09460062&OS=09460062&RS=09460062
owner: Adobe Systems Incorporated
number: 09460062
owner_city: San Jose
owner_country: US
publication_date: 20131230
---
This disclosure relates generally to computer implemented methods and systems for rendering objects such as markup language elements as images.

A web browser of a computing device typically renders a hypertext markup language HTML document such as a web page that includes an HTML object. In some situations the rendered HTML object can include text and image elements. After rendering the HTML document it may be desirable to further transform the rendered HTML object into an image so that filters effects or other manipulations can be applied within the rendered HTML document. For example a user of the computing device may desire to perform drag and drop a colored multiply or highlighting effect or other image rendering operations on the rendered HTML object. However there is typically no native functionality included in the web browser for allowing the image rendering operations to be performed directly on the rendered HTML object.

Instead prior solutions require the web browser or other application executed by the computing device to transmit the HTML object to a server over a network. In turn the server renders the HTML object as an image by using for example a headless browser and returns the image to the computing device. The web browser then renders the image within the HTML document to complete the image rendering operation. However this interaction between the computing device and the server may be costly in terms of computational time and may be prohibitive in certain circumstances. For example the user may perceive an unacceptable delay between the time an image rendering operation is initiated e.g. an HTML object is selected and the time the rendering operation completes e.g. the image is rendered and a highlighting is applied thereto . Similarly a connection over the network may not exist between the computing device and the server when the image rendering operation is initiated and thus the operation may not be performed.

In certain embodiments a web browser or other application executed by a computing device locally generates an image from an HTML object so that image rendering operations can be performed on the image. For instance the web browser may render an HTML document that contains HTML objects. An HTML object included within the HTML document may be identified in association with an image rendering operation. To locally support the image rendering operation the web browser may transform the HTML object into an image and may store the image in an address of a local memory of the computing device. Further the web browser may attach an image element to the HTML document at a location of the HTML object and may use the image element of the HTML document to render the image stored in the local memory. As such the web browser can locally render the image within the HTML document and can apply image rendering operation to the image without needing to communicate with a server or an external computing device over a network.

These illustrative features are mentioned not to limit or define the disclosure but to provide examples to aid understanding thereof. These and additional features may be implemented independently in various embodiments or may be combined in yet other embodiments further details of which can be seen with reference to the following description and illustrations. Advantages offered by one or more of the various embodiments may be further understood by examining the specification or by practicing one or more of the various embodiments.

Generally the embodiments described herein are directed to functionality for a web browser to perform image rendering operations on HTML renderings. More particularly the web browser may locally transform an HTML object into an image to support image rendering operation. For example the web browser may render an HTML document such as a web page that includes an HTML object that in turn contains text and image elements. A user may desire to perform an image rendering operation on the rendered HTML object. For example the user may desire to drag and drop the rendered HTML object from one location to another location within the rendered HTML document to highlight the rendered HTML object in the rendered HTML document or to save the rendered HTML object as an image by right clicking on the rendered HTML object and selecting a save operation. To support the image rendering operation the web browser may locally perform a number of steps. For example the web browser may transform the HTML object into a corresponding image and may store the image in a local memory. Further the web browser may attach an image element to the HTML document in a location of the HTML object and may reference the image as a source of the image element. In addition the web browser may use the image element of the HTML document at the location of the HTML object to render an image and may apply the image rendering operation on the rendered image. As such the web browser is capable of locally transforming an HTML object that contains for example text elements into an image to perform the image rendering operation. In other words the web browser need not connect to a server or external computing device to request and receive an image of the HTML object allowing the web browse to save computational time reduce bandwidth usage and overcome potential network connectivity limitations.

In an example embodiment to transform the HTML object into the image the web browser may initially generate an empty scalable vector graphics SVG object configured to include multiple elements. Further the web browser may modify the elements of the HTML object according to a SVG format and may copy the modified elements to the SVG object. The web browser may store the SVG object including the corresponding elements as the image in the local memory

As used herein a computing device refers to any type of computing device configured to communicate with another computing device over a network to access information including portable computing devices and conventional computing devices. A portable computing device may allow mobility to the user during at least operation and may include for example a mobile phone a smart phone a personal digital assistant PDA a phablet a tablet and other portable computing devices. In comparison a conventional computing device may be more stationary may include larger processing power and memory space than the ones of a portable computing device and may have an operating system that may be more sophisticated than the one of a portable computing device. A laptop a personal computer a desktop computer and a server are examples of conventional computing devices.

As used herein an application refers to a program configured to access and retrieve information hosted on a remote computing system e.g. an HTML document from a web site hosted on a server and to render the information at a user interface. Examples of such an application include a web browser a script or a plug in that runs within a web browser a program that is hosted in a web browser a program that is separate from but that interfaces with a web browser and other types of programs capable of using local memory and a rendering engine to access and render information.

As used herein a document refers to an electronic document that can be rendered by an application. The document may have a markup format such as HTML.

As used herein a markup language refers to a language for annotating a document to allow an application to render the document.

As used herein an image rendering operation refers to an operation that an application may execute on an image. Image drag and drop highlight and save operations are examples of an image rendering operation.

As used herein an object refers to a combination of elements. In some situations the object may have a complex structure that nests the elements where the elements may be of various types such as text elements image elements and other types of elements. Further the object may have a markup format such as HTML SVG and other formats.

As used herein an image element refers to an element that includes ore reference an image for the content of the element. For example an image element attached to an HTML document may include a reference to a source that stores a corresponding image or may include the image itself. A web browser that renders the HTML document may read the image element to render the image.

As used herein a direct object model DOM refers to a cross platform and language independent convention for representing and interacting with elements and objects that have different formats such as HTML extensible markup language XML and extensible hypertext markup language XHTML .

In the interest of clarity of explanation various example embodiments are described in the context of an HTML document HTML objects and SVG objects. Nevertheless the principles of the embodiments can be applied to other types of documents and objects including documents and objects that support other markup language formats. Specific details of various exemplary embodiments of the present invention are set forth in the following description and are illustrated in . The various embodiments described herein can be implemented in hardware software or a combination thereof. In the figures similar symbols may identify similar components unless context dictates otherwise. Certain well known technology details such as methods apparatuses or systems that would be known by one of ordinary skill are not set forth in the following description or in the figures to avoid unnecessarily obscuring the various examples. Those of ordinary skill in the relevant art will understand that they can practice other examples of the disclosed subject matter without departing from the scope and spirit of the present invention.

The server may be configured to host one or more network based resource e.g. websites . Information available at these resources e.g. web pages may be accessible to computing devices e.g. the computing device that connect to the server over one or more networks. The server may include a portable computing device a conventional computing device or a combination of the two. The server may also include a number of computing devices clustered as a computing system. A content data network a datacenter and a server farm are examples of such computing system. The network may be a communication network configured to connect the computing device and the server and may include for example any one or a combination of many different types of networks such as cable networks the Internet wireless networks cellular networks and other private and or public networks.

To facilitate the interaction with the user the computing device may be configured with a display screen for displaying a user interface. The computing device may also be configured with requisite hardware and or software for enabling touch screen and other input technologies for allowing the user to interact with information rendered on the display screen in the user interface. The user interface may include one or more windows that may display outputs of and may allow inputs to one or more application. A web browser is an example of such an application and may be configured to access and retrieve information hosted on the server e.g. a web page and to render the information in the user interface. Other programs may also or alternatively be implemented by a computing device to provide similar functions such as an application that may use local memory and may access a rendering engine and other components. These programs may include for example a script or a plug in that runs within a web browser a program that is hosted in a web browser a program that is separate from but that interfaces with a web browser and other types of programs. As used herein an application may refer to any of these and other types of programs and may comprise instructions that when executed by a processor cause a computing device to perform the functions and operations of the present invention as described herein.

As illustrated in the information retrieved from the server may be rendered as a document . The document may contain numerous elements that may be represented using various techniques such as by using markup language. An HTML document e.g. a web page is an example of the document . Elements can have different attributes and may nest additional elements. These elements may allow text image audio video animation multimedia and other types of presentations. Further any number of these elements can be combined into objects. In other words an object may have in some situations a complex structure that may include a large number of nested elements.

As shown in the figure the example document contains two elements and and an object . Element represents a title of the document and contains text that may have a certain font and style Baseball Hall of Fame with a large font as shown in . Similarly element represents a paragraph within a body of the document and contains text that may have a certain font and style This is the story of Joe Dane with a smaller font than element as shown in . The object includes a combination of elements including image and text elements e.g. elements representing an image and the name of the baseball player as further described in .

The application may include functionality for allowing the user to select any of the elements and or the objects once the document is presented at the user interface. Various selection techniques may be available depending on the capabilities of the application and the computing device . For example application may include functionality for allowing the user to select object by clicking swiping or performing a certain touch screen action or gesture in the vicinity of the displayed object . Additionally or alternatively the user may provide a voice command that application may translate into a selection of object . Although the disclosure describes techniques for selecting and processing an object such as object similar techniques may also be available to select and process any other element s object s or combination s of element s and or object s included in a document or any other content.

The user s selection of the object may indicate a desire to further process or manipulate the object . For example the user may desire to receive additional information about the content that the object may represent or may want to move the object from one location to another on the user interface. In some contexts these and other operations may require the object to be rendered as an image. For example at a minimum highlighting that the user has indeed selected the object may require the application to apply an effect e.g. a highlighting mask to an image of the object . In some cases such an effect cannot be applied if the object is merely displayed as an integrated portion of the rendered information e.g. an image cannot be separately generated and rendered directly from the object .

As such and in order to handle for example image rendering operations the application may generate a graphics object that contains the elements of the object and may format these elements according to a graphics format of the graphics object. The application may store the graphics object in local memory such that an image can be rendered therefrom and image rendering operations can be performed thereon. These and other aspects of the present invention are further described herein below.

Turning to that figure illustrates an output of processing the object by the application . More particularly the application may generate a graphic object corresponding to the object . Unlike the object the graphics object may be configured to support image rendering operations as part of the rendered document . In an example the application may configure the graphics object such that an a binary large object BLOB can be locally generated and stored from the graphics object . The application may use the BLOB to render an image at the computing device without connecting to the server and such that the image rendering operations can be locally applied to the generated image .

The application may start and complete a process for generating the graphics object and or the image based on one or more events. As illustrated in when a user selection of the object is received the application may initiate the process. The user selection is an example of such events. However other events may also or alternatively be used. For example when the document is first received at the computing device the application may automatically initiate the process for some or all of the objects in the document and may store the generated graphics objects and or images locally. This can be done before or after the document is rendered on the user interface. In another example the application may interface with a second application that is hosted on the computing device and that receives the document from the server . This second application may send the object to the application . In turn the application may initiate the process for generating the graphics object and or the image and may send the graphics object and or the image to the second application.

As illustrated in the object may contain a combination of elements among which may be elements and . The object and the elements may be represented in a structure such as the one of . In an example this structure may include an XML or an HTML tree structure. Although and the disclosure generally describe the object as having three elements such a simplified example is provided in the interest of clarity of explanation. The disclosure is not limited as such. Instead the scope of the disclosure also covers complex structures of object that may include a large number of elements and nesting of elements.

In the interest of clarity of explanation the object and the elements and are described in the context of a baseball card. Nevertheless the object and the elements and may not be limited as such and may include any other information and content. As illustrated the element is the background image of the card whereas the elements and describes the baseball player. For example the element may be an image of the player and the element may be text representing the player s name. Thus each of these elements and may have different content and or different attributes. In the context of an HTML document e.g. the document is an HTML document elements of the HTML document may include well known HTML elements that may have content such as text images scripts and other content and attributes such as cascading style sheets CSS style attributes.

There may be situations where image rendering operations may need to be applied to the object after the document is rendered on the user interface. These image rendering operations may include for example drag and drop applying a colored multiply effect or sending an image of the object from computing device to another computing device. However because the object may be structured in a way that does not allow such operations the object may not be usable for such operations. For example when the object is an HTML object and combines text and image elements it may be necessary to transform the HTML object into an image to apply filters or effects on the image.

Therefore the application may be configured to locally generate the graphics object from the object such that the graphics object may be usable to support the image rendering operations. These and other features of the application are further described in the next figures. As such the application need not rely on a resource external to the computing device . Instead the application may generate the graphics object in a format that may support the image rendering operations. Further the application may populate elements of the graphics object to correspond to elements of the object but formatted based on the format of the graphics object . In an example populating the elements of the graphics object may include generating nodes representing these elements to a tree structure of the graphics objects and attaching or appending the elements to the nodes.

For example and as illustrated in the graphics object may include elements and . The elements and may correspond to the elements and of the object respectively. More particularly the element may be a background image of the card the element may be an image of the player and the element may be text representing the player s name. Thus the graphics object may provide the same information as the object e.g. baseball card with a player image and name . However the format of this information e.g. of the elements and can allow the application to render an image e.g. the image from the graphics object . In other words although the object and the graphics object provide the same information the content and attributes of the respective elements may follow different formats. For example if the object is an HTML object the graphics object may be a SVG object that may present the same information in a different format. However unlike the HTML object the graphics object in an SVG format may allow image rendering operations.

Once the graphics object is generated the application may generate an image e.g. the image based on the graphics object . This image may be rendered in the document in lieu of or in addition to the object and may be used when image rendering operations need to be performed. These and other features of the application are further described in the next figures. As such whereas it may not be possible to locally apply an image rendering operation to the object as an integrated part of the rendered document such an operation may be applied locally to the image and displayed within or in conjunction with the rendered document .

As shown in the application may use the image when performing a colored multiply effect operation. For example in response to a user selection of the object and to highlight that the object was selected the application may render the image in lieu of the object and may use the rendered image to lay a highlighting mask e.g. a transparent blue color layer on the user interface.

As described herein above a document may include a number of elements. Similarly an object may include a combination of elements. Generally the elements of a document such as a webpage may be represented using a structure such as a tree structure of a markup document e.g. XML HTML XHTML or other structured documents . To generate a graphics object and a corresponding image the application may perform operations using the structure of the document or of the object . illustrates examples of this structure.

The structure of the example document may include a logical structure configured in a way that may allow an application not only to process the structure but also to render the document. For example the structure may declare a document type e.g. XML HTML XHTML or other structured documents to help the application define a rendering mode. Also the structure may present semantics such as headings paragraphs lists links quotes embedded scripts e.g. JavaScripts and other items for rendering content of the document. In markup documents such as XML HTML or XHTML documents the structure may include elements attributes of the elements content of the elements and other data.

Further the structure may be based on a document object model DOM that may define a tree structure for organizing the elements and objects of the document . The DOM may be configured to present and interact with objects and elements independently of the language that the objects are written in by defining the elements and objects the associated properties and the associated access method. The DOM may also use an application programming interface API to allow a tree structure of an object written in one markup language e.g. HTML to be used with another markup language e.g. XML .

To render the document the application may download the document to a local memory and may parse the DOM tree structure. As shown in a DOM tree structure of document may be used to render the document and may be updated to support rendering of an image in conjunction with the document . The DOM structure may include a number of nodes nested in a logical fashion that may define hierarchical relationships between the nodes. The terms parent child and sibling may be used to describe the relationships. Parent nodes may have children. Children on the same level may be called siblings. The structure shown in is illustrative and does not limit the disclosure. For example other structures nodes nesting of nodes may also be used. Further the computation time to generate the graphics object and or the image based on the object may depend on the structure. Generally this computation time may increase with an increase in complexity of the structure of the object .

As illustrated at a top hierarchy a root node may be a parent node that may have a number of children and that may identify a type of the document e.g. HTML when the document is an HTML document . A Head node and a body node may be two nodes that are children of the root node and may represent a head section and a body section of the document respectively. The head node may be a parent of a title node . The title node may be a child node that may represent the element of the document e.g. the title node may include the text and the associated attributes of the title . Similarly the body node may be a parent of two children nodes text and card . In other words the body node may nest two nodes the text node and the card node and may represent a main layout of the body section of the document . The nodes nested under the body node may further represent the elements within the body section.

The text node may represent the element of the document e.g. the text node may include the text and the associated attributes of the paragraph within the body of the document . The card node may represent the object of the document and as such may be a parent of three children background image player image and player name which collectively may define the baseball card represented in the object . The background image node may represent the element of the document e.g. the background image node may include the background image and the associated attributes of the baseball card represented by the object . Similarly the player image node may represent the element of the document e.g. the player image node may include the image and the associated attributes of the baseball player of the object . In addition the player name node may represent the element of document the e.g. the player name node may include the name in text format and the associated attributes of the baseball player of the object . As noted above in the interest of clarity of explanation the card node is described as having three children nodes. However the structure of card node may not be limited as such. Instead the card node node may have additional children nodes each of which may have a nested structure of children nodes such that the card node may have an overall complex structure.

In response to an event e.g. a user selection or another event that may identify the object as described herein above the application may generate a graphics object based on the object and may generate and render an image based on the graphics object . To render the image in the rendered document the DOM structure of the document may be updated. The application may execute a script e.g. a combination of JavaScripts to perform this update and to render the resulting image in the document . The script may be automatically executed in response to the event without an input command from a user and can dynamically update the document with the image . For example the script may render the elements corresponding to the modified nodes of the DOM structure e.g. the image without refreshing the entire document e.g. without refreshing the title and the paragraph of the document . In another example the script may refresh the entire document when the update to the DOM structure is complete. Alternatively the script may be executed based on an input command from the user.

As shown in a DOM structure illustrates an example update to the DOM structure . The DOM structure may include new nodes and or modify for instance certain nodes and or certain properties of some or all of the nodes of the original DOM structure . For example the DOM structure may include the root head title body and text nodes from the DOM structure . These nodes need not be modified because the event e.g. the user selection may indicate that only the object is to be processed. In comparison the application may perform various operations on the card node because the card node represents the object that needs to be processed. For example the application may replace the card node with an image node e.g. by using JavaScripts that remove the card node and create the image node . This may include creating an image element as further described below appending the image element to the image node and appending the image node to the body node . In another example the application may not replace the card node . Instead the application may leave or may hide e.g. by using JavaScripts that hide elements the card node while also appending the image node to the DOM structure .

The image node may be based on a graphics card node that represents the graphics object . The image node may represent an image element that corresponds to the graphics object . In an example the content of this image element may be an address to an image stored in local memory of the application . The application may generate this image from the graphics object .

In turn the graphics card node that represents the graphics object may be based on the card node that represents the object . The application may generate and set the graphics card node according to graphics requirements e.g. graphics card node may represent a SVG object in lieu of an HTML object and as such a namespace of the graphics card node may be set to XML instead of HTML .

The graphics card node may nest multiple nodes that may represent the elements of the graphics object . As illustrated card node may have three child nodes background image player image and player name . These nodes may represent the elements and of the graphics object respectively which in turn correspond to the elements and of the object respectively.

Further although not explicitly shown in graphics card node may have additional nodes. For example and is further described herein below when the graphics object is an SVG object a foreign object may be generated and attached to the graphics object and elements from the object may be used to populate the foreign object. As such the graphics card node may include a node corresponding to the foreign object. This node may be a child of the graphics card node and may be a parent of the background image node player image node and player name node .

As described above the application may use the DOM structure to generate the new DOM structure that can be used to render the image from the graphics object . describes operations that the application may locally perform to generate the graphics object accordingly. Similarly describes similar operations that the application may perform within the context of an HTML object. In both figures the graphics object and the object may have different formats e.g. the graphics object may be a SVG object whereas the object may be a HTML object .

To generate the graphics object based on the object application may take advantage of features commonly shared between the corresponding different formats such as common characteristics of the markup languages used to write the objects. For example with HTML and SVG the application may be configured to translate between the two markup languages such that HTML content and accompanying attributes e.g. CSS based attributes may be copied and modified as needed into content and attributes usable in SVG. In other words the SVG object may have content set to the HTML content of the HTML object and may have style attributes set to a computed style based on the CSS style of the HTML object.

In the illustrative operations each of the steps or functions may be embodied in and fully or partially automated by code modules executed by one or more processors of computing device of . The code modules may include for example the application . Also while the operations are illustrated in a particular order it should be understood that no particular order is necessary and that one or more operations may be omitted skipped and or reordered. Further in the interest of clarity of explanation the application is described as performing the illustrative operations. Nevertheless other or additional code modules of computing device may be configured to implement one or more of the operations and or one or more steps of the operations.

Turning to that figure illustrates an example flow for generating a graphics object to support image rendering operations. For example in response to an event e.g. a user selection of object application may execute flow to generate the graphics object locally based on the object in a format that supports image rendering operations.

The flow starts at operation where a first object having a first format is selected. In other words the application may receive or determine an event that may require the processing of the first object at this operation. The first object may include a number of nested elements each of which may have content and attributes. The content may include for example text images audio video multimedia animations scripts links and other types of content. Each attribute may include for example properties for displaying the elements such as styles or a reference to a style sheet. The first format may be based on for instance a markup language. An example of the first object may include the object of .

At operation the application may generate a second object where the second object may be initially empty and may have a second format. An empty object may be an object that may not have elements but that may be populated with elements and the corresponding content and attributes. The second object may be a graphics object such as an object that when populated with elements may support image rendering operations. While also based on a markup language the second format may be different from the first format such that if the first format does not support image rendering operations the second format may do so. An example of the second object when populated may include the graphics object of . At this operation the application may invoke a function that may generate a node that may represent the second object and that may have a namespace configured to support image rendering operations e.g. an XML namespace XMLNS that may support a SVG object .

At this operation the application may also compute a size e.g. width and height attributes of the second object based on a size of the first object. This may involve for example performing a query to determine the size of the first object.

At operation the application may populate the second object with content and attributes from the first object where the content and or attributes may be modified according to the second format. For example application may attach elements to the second object each of which may correspond to one or more elements of the first object. The content and attributes of the attached elements may be modified to meet the second format. Said differently the application may modify the content and or attributes of each attached element such that the content and or attributes are written according to the second format. For example whereas the content of the elements of the first object may be copied application may compute attributes of the attached elements based on the attributes of the corresponding elements of the first object. To do so for each attached element application may invoke a DOM API call to receive a computed style for the attached element from the style of the corresponding one or more elements of the first object and may insert the computed style in the attribute of the attached element.

Additionally the application may use a third object configured to use a second namespace e.g. an XHTML namespace that may allow application to draw graphical content within the second namespace. The elements may be attached to this third object instead of being directly attached to the second object and in turn the third object may be attached to the second object. This nesting may allow application to use different namespaces e.g. XML and XHTML such that the second object can support image rendering operations.

At operation the application may store the second object as binary data in a local memory of the application . In this operation the application may take advantage of the second format of the second object where the second format may allow the second object to be stored as binary data. For example the application may append a media type e.g. an image type to the second object may transform the appended information and the second object into a binary large object BLOB and may store the BLOB at a location in the local memory. Further the application may generate an address e.g. a universal record locator URL that may be local to the application that may identify the location. For example the application may execute a JavaScript to request the URL of the BLOB. The BLOB and the address may allow the application to perform image rendering operations based on the second object. For example the application may attach an image element e.g. an element that includes image as content to the document e.g. DOM structure may be modified such that DOM structure includes the image node where the image element is appended to the image node . The application may set a source of such image element or image object to the address of the BLOB.

At operation the application may render an image using the binary data and may perform one or more image rendering operations e.g. the application may render the image in the rendered document . For example by using the local in memory address of the BLOB the application may render an image that may display the content of the second object using the corresponding attributes. The one or more image rendering operations may include for example applying a colored multiply effect as shown in drag and drop sending the image to a remote computing device or any other image rendering operations. The rendered image may also be used with other operations. For example a right click and save operation may be performed to store the image in a memory space of computing device .

Turning to that figures illustrates an example flow for generating an object to support image rendering operations. More particularly the application may locally execute the flow to render an image out of an HTML object when it may be necessary to transform the HTML into an image as discussed herein above. For example the flow may be executed when the object and the graphics object are HTML and SVG objects respectively. Further the flow may include similar operations as those shown in the flow . In the interest of clarity of explanation such similarities may not be repeated here. In addition under the flow the application may be a browser of a computing device such as a portable computing device that has a local memory.

Generally the application may use an HTML object as an input to the flow and may generate an SVG object as an output of the flow . Content and attributes of the SVG object may be used to support image rendering operations. More specifically the flow may allow the application to import HTML content from the HTML object into the content of the SVG object. In addition the flow may allow application to compute styles based on the CSS styles of the HTML object and to insert the computed styles into the style attributes of the SVG object. This transformation between the HTML object and the SVG object may take advantage of the DOM tree structure and may also use a foreign object. The foreign object may allow the application to render the imported content as XHTML using at least in part the inserted computed styles.

The flow starts at operation where an HTML object is selected from a source document. In other words the application may receive or determine an event that may require the processing of the HTML object at this operation. The HTML object may have a certain size e.g. height and width attributes and may include a number of elements each of which may have content and attributes. For example when the object is an HTML object the size of the HTML object may correspond to the size of the baseball card shown in and the elements may correspond to the image background the player image and the name of the player. The content of each element may be an image or a text. The attributes of each of element may include for example an id attribute configured to provide a document wide unique identifier for the element a class attribute configured to classify the element a style attribute configured to assign presentational properties to the element and other attributes. In certain implementations the id class and or style attribute may select a style for an element from a style sheet such as from cascading style sheets CSS .

At operation the application may generate an empty SVG object in response to for example the event determined at operation . To do so the application may for example generate and store the empty SVG object as an object or a file in the local memory of the application and may execute a CreateElementNS method to define a namespace for an XML representation of the SVG object. The createElementNS method may create an object node within an XML namespace. The application may define the XML namespace to the SVG . specification.

At operation the application may set a size of the SVG object e.g. height and width attributes as a function of the size of the HTML object. For example the SVG object and the HTML object may have the same size as shown in . In another example the SVG object s size may be a percentage of the HTML object s size. For instance with a drag and drop operation the SVG object s size may be set to 60 any other percentage or any other available unit for declaring the HTML object s size. This may allow the SVG object to be rendered in a smaller size which may allow a user friendly implementation of drag and drop operations. To set the SVG s object size the application may retrieve the HTML object s size by reading a computed style of the HTML object with a JavaScript query.

At operation the application may append a foreign object to the SVG object. Generally SVG may allow inclusion of elements from a foreign namespace anywhere with SVG content and of attributes from the foreign namespace on any SVG element or SVG object. The foreign object may be referred to as a foreignObject and may allow inclusion of a foreign XML namespace which may have graphical content drawn by a SVG user agent. The included foreign graphical content may be subject to SVG transformations and compositing. The content of the foreignObject may be assumed to be from a different namespace. Any SVG elements within a foreignObject may be drawn in situations where a properly defined SVG subdocument with a proper XMLNS attribute specification is embedded recursively. An example of such situations includes an implementation where an SVG document fragment is embedded within another non SVG document fragment which in turn is embedded within an SVG document fragment e.g. an SVG document fragment contains an XHTML document fragment which in turn contains yet another SVG document fragment .

As such the application may use the XML namespace of the SVG object to set the foreign object namespace to the XHTML . specification which may allow the application to render content attached to the foreign object through a rendering engine. In other words by setting the SVG object s namespace to XML and the foreign object s namespace to XHTML the application may render the elements attached to the foreign object which in turn may be attached to the SVG object as a vector graphic.

At operation the application may iterate through the tree of the HTML object e.g. nodes through of for the object to append elements from the HTML object to the foreign object. For each element of the HTML object the application may generate a new element of the same type and may read the computed style of the original element. The new element may be formatted according to XHTML and may include content of the original element and attributes determined based on for example the computed style of the original element e.g. CSS style . As such the new element may include for example content and a style attribute. Content of the original element may be copied into the content of the new element. Similarly the CSS style of the original element may be computed and the computed style may be inserted in the style attribute of the new element.

The computed style may be received through a DOM API as a key value structure. The DOM API may allow the application to use JavaScripts to access nodes of the HTML object at a DOM structure e.g. the DOM structure for the object for computing the key value structure. This structure may include a number of key value pairs each of which may represent a styling attribute e.g. background color font color font size location within document and other attributes . The key value structure may be flattened by looping over the new elements and by adding for each new element a description of the corresponding computed style as an inline string into an attribute of the new element. Flattening a key value structure may include expressing the key value pairs within that structure as a string of pairs in the style attribute of the new element. As an example and for an element that has N key value pairs the corresponding string may expressed as style key1 value 1 key2 value 2 . . . keyN valueN . When the iteration is complete a tree of the foreign object may be identical to the tree of the HTML object but each node e.g. element within the tree of the foreign object may contain the whole styling of that node in the respective attribute.

At operation the application may store the SVG object including the appended foreign object and the appended elements as a BLOB having an SVG MIME type e.g. image svg xml in a local memory of the application . The BLOB may be stored at a location of the memory addressable using for example a URL. At this operation the application may also attach a new image element to the document with a source set to the URL of the BLOB. By setting the URL the application may start rendering an image including any HTML content into the local memory as an SVG. When the rendering is complete a load event may be fired on the image element or image object. A handler may listen to the load event and in response may draw the rendered SVG into a canvas e.g. an HTML5 canvas using for example a drawImage method and may release the memory space storing the BLOB. At this point a pixel value representation may be successfully generated allowing image rendering operations to be performed. For example image transformations on the canvas may be applied. In another example the canvas may be extracted into a raster image format through a toDataURL method to return a base64 encoded output.

To illustrate portions of the above the flow two examples of markup language code are provided herein below. In the first example the object is an HTML object and illustrates an input to the flow e.g. at the operation . In the second example the graphics object is a SVG object that uses XML namespacing and computed styling and illustrates an output of the flow e.g. at the operation based on the input of the first example. The two examples are provided for illustrative purposes and are not meant to limit the disclosure.

In the second example the object graphics may represent a transformation of the object such that the HTML may be rendered in a SVG.

To implement the various functionalities of computing device some or all elements of the device may be implemented using the computing architecture of . More particularly illustrates an example computing architecture for implementing the techniques in accordance with the present disclosure. As used herein the term circuitry includes hardware components e.g. microprocessors application specific integrated circuits processors etc. configured using firmware and software that implement the techniques described herein. For example a processor can be configured by instructions loaded from memory e.g. random access memory RAM read only memory ROM firmware and or mass storage embodying logic operable to configure the processor to perform the functionalities disclosed herein.

Further the memory may comprise an operating system programs and applications. The processor may be configured to execute the stored instructions and can comprise for example a logical processing unit a microprocessor a digital signal processor and other processors. The input and output peripherals may include user interfaces such as a keyboard screen microphone speaker other input output devices and computing components such as graphical processing units serial ports parallel ports universal serial bus and other input output peripherals. The input output peripherals may be connected to the processor through any of the ports coupled to the interface bus . The communication peripherals may be configured to facilitate communication between the computing architecture and other computing devices over a communications network and may include for example a network interface controller modem wireless and wired interface cards antenna and other communication peripherals.

While the present subject matter has been described in detail with respect to specific embodiments thereof it will be appreciated that those skilled in the art upon attaining an understanding of the foregoing may readily produce alterations to variations of and equivalents to such embodiments. Accordingly it should be understood that the present disclosure has been presented for purposes of example rather than limitation and does not preclude inclusion of such modifications variations and or additions to the present subject matter as would be readily apparent to one of ordinary skill in the art. Indeed the methods and systems described herein may be embodied in a variety of other forms furthermore various omissions substitutions and changes in the form of the methods and systems described herein may be made without departing from the spirit of the present disclosure. The accompanying claims and their equivalents are intended to cover such forms or modifications as would fall within the scope and spirit of the present disclosure.

Unless specifically stated otherwise it is appreciated that throughout this specification discussions utilizing terms such as processing computing calculating determining and identifying or the like refer to actions or processes of a computing device such as one or more computers or a similar electronic computing device or devices that manipulate or transform data represented as physical electronic or magnetic quantities within memories registers or other information storage devices transmission devices or display devices of the computing platform.

The system or systems discussed herein are not limited to any particular hardware architecture or configuration. A computing device can include any suitable arrangement of components that provide a result conditioned on one or more inputs. Suitable computing devices include multipurpose microprocessor based computer systems accessing stored software that programs or configures the computing system from a general purpose computing apparatus to a specialized computing apparatus implementing one or more embodiments of the present subject matter. Any suitable programming scripting or other type of language or combinations of languages may be used to implement the teachings contained herein in software to be used in programming or configuring a computing device.

Embodiments of the methods disclosed herein may be performed in the operation of such computing devices. The order of the blocks presented in the examples above can be varied for example blocks can be re ordered combined and or broken into sub blocks. Certain blocks or processes can be performed in parallel.

Conditional language used herein such as among others can could might may e.g. and the like unless specifically stated otherwise or otherwise understood within the context as used is generally intended to convey that certain examples include while other examples do not include certain features elements and or steps. Thus such conditional language is not generally intended to imply that features elements and or steps are in any way required for one or more examples or that one or more examples necessarily include logic for deciding with or without author input or prompting whether these features elements and or steps are included or are to be performed in any particular example.

The terms comprising including having and the like are synonymous and are used inclusively in an open ended fashion and do not exclude additional elements features acts operations and so forth. Also the term or is used in its inclusive sense and not in its exclusive sense so that when used for example to connect a list of elements the term or means one some or all of the elements in the list. The use of adapted to or configured to herein is meant as open and inclusive language that does not foreclose devices adapted to or configured to perform additional tasks or steps. Additionally the use of based on is meant to be open and inclusive in that a process step calculation or other action based on one or more recited conditions or values may in practice be based on additional conditions or values beyond those recited. Similarly the use of based at least in part on is meant to be open and inclusive in that a process step calculation or other action based at least in part on one or more recited conditions or values may in practice be based on additional conditions or values beyond those recited. Headings lists and numbering included herein are for ease of explanation only and are not meant to be limiting.

The various features and processes described above may be used independently of one another or may be combined in various ways. All possible combinations and sub combinations are intended to fall within the scope of the present disclosure. In addition certain method or process blocks may be omitted in some implementations. The methods and processes described herein are also not limited to any particular sequence and the blocks or states relating thereto can be performed in other sequences that are appropriate. For example described blocks or states may be performed in an order other than that specifically disclosed or multiple blocks or states may be combined in a single block or state. The example blocks or states may be performed in serial in parallel or in some other manner. Blocks or states may be added to or removed from the disclosed examples. Similarly the example systems and components described herein may be configured differently than described. For example elements may be added to removed from or rearranged compared to the disclosed examples.

