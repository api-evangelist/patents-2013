---

title: Measuring transaction performance across application asynchronous flows
abstract: A mechanism modifies a deployment descriptor of each application component including at least one producer application component or consumer application component, by adding, for each producer application component or consumer application component, an application component identifier, a producer or consumer type, and a recipient identifier of a recipient the application component uses. Responsive to determining a match exists and the given application component is of producer type, the application server virtual machine logs an identifier of a recipient containing a message sent by the given application component, a correlation identifier of the given application component, and an execution start time. Responsive to determining a match exists and the given application component is of consumer type, the application server virtual machine logs an identifier of the recipient resource containing a message processed by the given application component, a correlation identifier of the given application component, and an execution end time.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08924973&OS=08924973&RS=08924973
owner: International Business Machines Corporation
number: 08924973
owner_city: Armonk
owner_country: US
publication_date: 20130214
---
This invention generally relates to transaction performance monitoring more particularly the invention aims at measuring response time of transactions tracked across asynchronous flows in a Java Java and all Java based trademarks and logos are trademarks or registered trademarks of Oracle and or its affiliates 2 Enterprise Edition J2EE application server.

In a production environment it is difficult to monitor J2EE application servers because of the debugging constraint problems. In this case it is not possible to use debugging and profiling tools and the most common technique to perform a deeper problem determination apart from browsing log and trace files is to record processing time in each of the components of the application server during a request to that application.

Currently available tools can collect transaction processing time and store in log or trace files for later retrieval and analysis or can send it to protocol agents such as an Application Response Measurement ARM ARM is a trademark of ARM Ltd. agent which is developed using an application programming interface API allowing to track resource consumption by a transaction when several elements in a network are contributing towards the completion of the transaction.

As a transaction flows through the system these tools include additional information so that the log records from each component can be correlated building up a complete picture of that transaction. The result provides processing time in each component as in the following example in which processing time is provided for each software component participating in the completion of one transaction 

The problem with such a solution is that it works only when the transaction within the application is a synchronous flow of calls among any number of components and or applications such as database servers resource connectors etc.

There is thus a need to collect processing time for a transaction when the application calls are made across asynchronous components. There is need for correlating the information collected when the application calls are made across asynchronous components like Java Message Service JMS resources for sending or receiving messages or when different applications perform independent read write operations to from an external data source or when there is the need to propagate a correlation information among different application components.

Known solutions to solve such kind of problems do not completely solve them and or require to manually hard code into the application the code that takes care of managing such correlation information. For example in case of asynchronous transactions based on JMS queues a typical way to solve this problem is to directly insert into the JMS message an additional parameter containing a correlator token. Such intrusive solution requires to write some custom code to be added to the applications that have to share the correlation information which is not possible when debugging applications operating in production mode and which cannot be modified.

Other solutions are based on on the fly instrumenting the application when it is being loaded into the runtime environment and intercepting specific method invocations corresponding to the start completion of a transaction. But also such solution does not automatically take case of propagating a correlation information among different processes both synchronous and asynchronous.

The US patent application published under the number US 2005 0039171 under the title USING INTERCEPTORS AND OUT OF BAND DATA TO MONITOR THE PERFORMANCE OF JAVA 2 ENTERPRISE EDITION J2EE APPLICATIONS discloses a runtime bytecode instrumentation of the application classes to locate static code points always derived by a top level servlet invocation where a transaction may occur. This prior art solution avoids modifying code source of applications running on a JVM application server but it only supports transaction based on a pre defined parent child hierarchy which is static meaning that the transaction flow is synchronous.

There is thus a need for a method to allow tracking of processing time of a transaction based on execution of a synchronous or asynchronous process flow.

In one illustrative embodiment method is provided for identifying processing time of asynchronous transactions in applications running on an application server virtual machine. The asynchronous transactions involve execution in one application component of a producer application component sending a message into a recipient and execution in a consumer application component. The method comprises modifying a deployment descriptor of each application component of an application including at least one producer application component or consumer application component by adding for each producer application component or consumer application component an application component identifier a producer or consumer type and a recipient identifier of a recipient the application component uses. The method further comprises the application server virtual machine when executing a transaction using a given application component determining whether the given application component matches an application component identifier in the deployment descriptor of the given application. The method further comprises responsive to determining a match exists and the given application component is of producer type the application server virtual machine logging an identifier of a recipient containing a message sent by the given application component a correlation identifier of the given application component and an execution start time. The method further comprises responsive to determining a match exists and the given application component is of consumer type the application server virtual machine logging an identifier of the recipient resource containing a message processed by the given application component a correlation identifier of the given application component and an execution end time.

In other illustrative embodiments a computer program product comprising a computer storage medium having a computer readable program is provided. The computer readable program when executed on a computing device causes the computing device to perform various ones of and combinations of the operations outlined above with regard to the method illustrative embodiment.

In yet another illustrative embodiment computing device is provided. The computing device may comprise one or more processors and a memory coupled to the one or more processors. The memory may comprise instructions which when executed by the one or more processors cause the one or more processors to perform various ones of and combinations of the operations outlined above with regard to the method illustrative embodiment.

These and other features and advantages of the present invention will be described in or will become apparent to those of ordinary skill in the art in view of the following detailed description of the example embodiments of the present invention.

The proposed solution provides a way to correlate components involved in the execution of a transaction by modifying the deployment descriptor of applications running on the application server JVM. The solution is implemented in the application server JVM runtime and optionally in the assembler and uses existing log filing to collect processing times. This automatic process is transparent for the Java application developer who can write the code of applications running in the application server JVM without worrying about transaction recording and correlation.

The main advantage of the solution is that it is general and may correlate any type of components involved in execution of one J2EE compliant application server transaction. These components may be different components of a same application they may also correspond to components of different applications running on the same J2EE compliant application server or to a remote Web server depending on the same application server. These components can also be application processes running on a different J2EE compliant application server implementing the present method of the invention.

As the solution is based on the use of the deployment descriptor attached to each application component running on a J2EE specification for developing application servers it may be considered by the J2EE developers as an extension of the current implementations they develop. The deployment descriptor being an XML file it is a flexible solution. The descriptor can be updated by the developer the administrator or automatically by the application assembler.

A second advantage of the use of a J2EE deployment descriptor is that the numerous existing tools facilitating development of J2EE compliant application servers can be extended for including correlation of components involved in execution of a transaction. There are currently a number of tools that can be used to develop and assemble a J2EE application. The proposed solution enhances these tools to allow the application assembler to define an asynchronous transaction.

The architecture comprises a Client application accessed through the browser of a user computer sending a request to a Web server handled by the J2EE application server and starting a transaction for which the total processing time needs to be collected. The application server JVM will introduce a correlation id which will identify each component involved in the execution of a transaction and will log processing time for each running component in a log file included in the JVM and not represented in . As the correlation IDs will be stored in the Log file it will be possible for a log analyzer tool to read the Log file to allow computation of the total processing time of one transaction.

In the illustrative embodiment it will be a responsibility of the application assembler to define the proper correlation scope optional transaction boundary and transaction type so that this information is written into the application deployment descriptors. The assembler can modify the information written or left by the developer and the administrator can modify the information written or left by the assembler. In a different embodiment the new information will be directly entered by the developer or the administrator in the deployment descriptor at any time even after compilation.

It will be the Application server runtime responsibility to retrieve this DD information create a new correlation ID and propagate it when managing the transaction within the transaction scope. The component execution information will comprise according to the illustrative embodiment the correlation ID as an additional information going along with the component processing time in the Log files of the application server.

The correlation ID is then used according to the transaction type by the Application Server runtime to track correlation records into the configured log files or send them for further processing to collector agents such as ARM agents IBM Tivoli Composite Application Manager agents etc. IBM and Tivoli are trademarks of IBM Corporation in certain countries . The administrator can see the logs from the application server console and process them with a log analyzer tool.

According to the illustrative embodiment a new component of the JVM application server will perform computing of the correlation ID and tagging of the transaction related logged data tagging of the logged data. This component the Asynchronous Correlation feature may be activated by the administrator from the application server console. From the application server console which can be remote the administrator will also activate the Log files post processing program for collecting the real transaction processing time which will help for instance for problem determination.

According to the illustrative embodiment in the a first block the application assembler defines for each component of the Java application running in the JVM application server some correlation information comprising at least the transaction boundary and the transaction type. The transaction boundary is the initial component method of a servlet etc. which will be involved in the flow started with the execution of the transaction. As discussed before the execution of application component Java class methods can be asynchronous. This is a well known point by the application assembler who is supposed to know the application and its flow.

Then the assembler which is in charge of creating the deployment descriptors includes in the deployment descriptors of the application components the correlation information which has been defined and which comprises the transaction boundary and the transaction type besides asynchronous correlation name and other optional parameters like correlation scope description and so on. All these parameters will be described in more detail in reference to .

The System Administrator enables an Asynchronous Correlation feature from the Application Server console which also allows mapping for instance through a GUI the deployment descriptors fields to the referenced database instance that is part of the correlation scope to the actually used database or defines the whole correlation scope depending on what is left undefined by the application assembler .

As the Asynchronous Correlation feature is activated when the asynchronous transaction takes place the Application Server runtime leveraging the deployment descriptors is able to write correlation logs containing matching a correlation ID corresponding to said transaction and transaction start and end time of the executing application component Java class methods participating in the same transaction.

After the transaction completes the Administrator imports the Application Server log files into a log analyzer tool that picks up the matching correlation IDs and transaction times and displays the aggregated transaction . Details of possible correlation ID is better described later on in the document in reference to .

The standard J2EE deployment descriptor XML files of the components and not deployment descriptor of the entire application as described in are modified according to the preferred embodiment. A new correlation settings section is added. As stated before the assembler adds in the standard deployment descriptor of the application components a correlation information which is then updated by the administrator after assembly phase or after installation phase.

The example of is a deployment descriptor of a web module having as name appearing on the server console MyWebModule . This is a J2EE standard deployment descriptor of an application component modified according to the illustrative embodiment. Any other components such as an EJB module or a client application can have a similar deployment descriptor modified according to the illustrative embodiment. The standard deployment descriptor contains executable module information to allow the application server to retrieve the Java classes to be executed for the web module. A security role section is also part of the J2EE standard deployment descriptor. The security role section allows the JVM to filter capability of the web module to Role 1 after this generic name is mapped to a real user group name by the administrator or any other people having permissions to perform such operation .

A correlation settings section containing the correlation information is added according to the illustrative embodiment. In this example and it is not mandatory it is included before the security role section.

The correlation settings section comprises the transaction boundary name which is the name of the piece of code in the component a Java class method which is involved in an asynchronous transaction. The MyServlet.writeObject is the writeObject method of MyServlet Java class of MyWebModule component. This method is of type write transaction type field this means this method has a producer part in the asynchronous transaction scheme as described later on in the document in reference to description of . This method writes in a database table which is the MyDB.MyTable database table correlation scope field . As explained in in the flow of asynchronous transactions the producer writes a message in a recipient which can be a database table or a message queue depending on the application. The correlation scope represents the recipient that works as source or destination of the messages exchanged among the different actors in an asynchronous transaction. In the example of it is a database table but could be a queue based messaging system such as JMS in memory queues etc. As a matter of fact in one asynchronous transaction at least one other method which can be from the same application component or from one other component of the same application or one component of a different application acts as a consumer and reads later on the message from the same recipient location. This is why more than one correlation settings section such as the one described in can be added in a same component deployment descriptor.

The assembler which adds the new information in the component deployment descriptors can enter a generic name which is overridden by the administrator directly from the console by mapping the real database table name known in the system. Sharing between assembler part and administrator or any authorized person is optional in the scope of the illustrative embodiment.

As illustrated in JMS is a messaging standard which allows application components based on the Java 2 Platform Enterprise Edition J2EE to create send receive and read messages. At least two main actors contribute to a global transaction with asynchronous flow a producer that creates a message and one or more consumers that later on receives the message and start processing it participating in an asynchronous transaction. The JMS message queue is a staging area in which messages are queued each message will be processed once independently of the order they have been received.

A similar schema exists for all asynchronous transactions under Java applications running on an application server JVM. An asynchronous transaction comprises transaction boundaries which correspond to execution of a application component Java class method which may act as a producer and writing a message in a recipient which is here a JMS queue but which could be a location in a database table. The asynchronous transaction also comprises one other transaction boundary which corresponds to execution of an application component Java class method which acts as a consumer. Later on it reads and processes the message which has been written in a location of the recipient. The dependent transactions or the different operations of an asynchronous transaction may be either of Write or Read type depending on whether they are producer or consumer.

Hereunder is described how the correlation settings section read from the deployment descriptor of are used for evaluating processing time of an asynchronous transaction. Assuming that Application A contains a servlet S in which method M performs an insert in table T of database instance D the application assembler will open the Asynchronous Correlation feature of its assembly tool select A.S.M method M in servlet S of application A as transaction boundary W that is write as transaction type and D.T database table as correlation scope.

Now assuming an Application B contains the EJB E in which method M performs a read from the same table and uses the record that Application A previously queued to perform its task the application assembler will select B.E.M as transaction boundary R read as transaction type and the same D.T database table as correlation scope.

These settings are saved in both web.xml and ejb jar.xml deployment descriptors one for the servlet web module the other one for the EJB module to be later retrieved by the Application server runtime.

Even if the correlation scope can be set up at assembly time it is possible that the database configuration that the application leverages is not known at assembly time. For this reason it is more convenient to set up the correlation scope at deployment time or after installation has been performed. The administrator responsible of the deployment of the application in the production environment maps the referenced database instance onto the actually used instance. This is a common practice when dealing with J2EE resources and adds an additional level of flexibility to the solution.

When the Application Server manages the transaction for Application A transaction management is performed by each J2EE Application Server it creates a correlation ID for each write operation performed by the method M of the servlet S. The correlation ID will be composed by two parts the first part is the identifier of the written record which is for example D.T.ind where ind is the index that uniquely identifies a record in the table D.T. the second part is the identifier of the caller which is A.S.M. So the complete correlation ID will be D.T.ind A.S.M .

When a situation like this happens the Application Server runtime if the Asynchronous Correlation feature is enabled writes into the log files a record containing the correlation ID and the transaction start time.

In a similar way when the Application Server manages the transaction for Application B that reads the record D.T.ind it matches the EJB deployment descriptor and creates a second correlation ID that in this case will be D.T.ind B.E.M . Then the Application Server runtime will log the correlation ID and the transaction end time.

It is noted that in case of transaction type R read the Application Server will log the transaction end time while in case of W write the transaction start time thus providing a correct measure of the transaction lifetime across asynchronous communication.

After the transaction is terminated and the System Administrator wants to correlate the events related to the transaction asynchronous flow that involved components of application A and B he simply has to import log files and analyze them with the currently available log analyzer tools.

Properly filtering the logs to select the same correlation ID and optionally enhancing the tool to perform automatic correlation and time aggregation the Administrator will reach the results that cannot be achieved with the currently available tools. The two log records containing the same common part of the two correlation IDs which is D.T.ind the total transaction processing time being end time of the read operation minus start time of the write operation. In this step is used the same root D.T.ind to link the main and dependent transactions the second part of the correlation ID D.T.ind B.E.M determining which component B.E.M took part in the transaction. In fact the definition of the transaction elements in the descriptors just states that a transaction may occur but only the actual log files can confirm that the transaction really pass for that component. Assuming is defined a transaction producer and 5 consumers in 5 different components only 3 consumer components could be actually involved according to the logged information. This implies that these components from the second part of the correlation ID are written in the log files.

In the embodiments described above we referred to a queue represented by a database table. The idea presented here is actually generic and may be applied to any queue based messaging system such as JMS in memory queues etc. The only difference is just in the way the system has to intercept the creation of the message by the boundary transaction and the reading of the messages by the dependent transaction s which are the different operations executed during an asynchronous transaction.

The illustrative embodiments described above may take the form of a computer program comprising instructions for carrying out the functions of the illustrative embodiments. The computer program is executed on a computing device. As known in the art a typical computing device comprises at least one processor a memory coupled to the processor for storing the instructions of the computer program and a computer storage medium for storing the instructions of the computer program in persistent storage such that when the computer program is executed by the processor the computer program causes the processor to perform the functions of the illustrative embodiments.

