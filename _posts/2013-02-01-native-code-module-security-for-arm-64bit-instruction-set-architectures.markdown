---

title: Native code module security for arm 64-bit instruction set architectures
abstract: Methods, systems, and apparatuses, including computer programs, for safely executing a native code module for an ARM 64-bit instruction set. The native code module contains native code that is executed within a secure runtime environment that isolates the native code module from sensitive data and resources on the computing system. The native code module is validated by a validator prior to execution within the secure runtime environment to ensure that the native code module complies with a set of security constraints.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08935781&OS=08935781&RS=08935781
owner: Google Inc.
number: 08935781
owner_city: Mountain View
owner_country: US
publication_date: 20130201
---
The present embodiments relate to techniques for safely executing native code modules. More specifically the present embodiments relate to methods and systems for safely executing native code modules within ARM 64 bit instruction set architectures. ARM is a registered trademark of ARM Limited of Cambridge England. 

Easy access to computers and plentiful network bandwidth have facilitated sharing of information and applications. For instance a user of a computing device e.g. a personal computer a mobile phone or a personal digital assistant may easily install and execute an application downloaded from a web site or received from a friend as an email attachment. Similarly a user of shared cloud computers may upload and run an application that is unknown to the operator of the cloud. This entails risk to the operator and if the application has access to resources shared with other users to the other users. Installing and executing such applications on a given computing device typically involves a level of trust that is granted on an all or nothing basis by the operating system of the computing device. Furthermore bugs in the operating system may inadvertently allow applications to access resources As a result some applications e.g. native applications may have full access to the operating system and or resources of the computing device while other applications e.g. web applications may have little to no direct access to the operating system and or resources of the computing device.

Such coarse application of trust may negatively impact the execution of all applications on the computing device. For example native applications may produce unwanted side effects by modifying files on the computing device and or engaging in computation or communication outside of the tasks or features requested by the user. On the other hand web applications may execute one to two orders of magnitude slower than native applications and may provide limited functionality to the user.

This specification describes methods systems and apparatuses including computer programs for safely executing a native code module for an ARM 64 bit instruction set. The native code module contains native code. The system executes the native code within a secure runtime environment that isolates the native code module from sensitive data and resources on the computing system. The native code module is additionally validated by a validator prior to execution within the secure runtime environment to ensure that the native code module complies with a set of security constraints.

In general one innovative aspect of the subject matter described in this specification can be embodied in methods that include the actions of receiving a native code module for an ARM 64 bit instruction set wherein the instruction set has several types of store instructions wherein one or more of the types of store instructions are forbidden instructions and wherein the native code has one or more store instructions loading the native code module into a secure runtime environment wherein an address space of the secure runtime environment is divided into multiple regions and wherein one of the regions is a write area validating the native code module verifying that no reachable store instruction in the native code module is a forbidden instruction verifying that for each reachable store instruction in the native code module that uses a 64 bit base register the 64 bit base register used by the instruction is masked by one or more diffuser instructions defining a first write area buffer zone above and adjacent to the write area defining a second write area buffer zone below and adjacent to the write area determining that a first reachable store instruction in the native code module has an extended register offset wherein a destination address of the first reachable store instruction is determined as a sum of an address contained in a first base register and a scaled 32 bit offset value contained in a first 64 bit offset register and determining that each write area buffer zone is at least 16 gigabytes in size. Other embodiments of this aspect include corresponding computer systems apparatus and computer programs recorded on one or more computer storage devices each configured to perform the actions of the methods. For a system of one or more computers to be configured to perform particular operations or actions means that the system has installed on it software firmware hardware or a combination of them that in operation cause the system to perform the operations or actions. For one or more computer programs to be configured to perform particular operations or actions means that the one or more programs include instructions that when executed by data processing apparatus cause the apparatus to perform the actions.

The foregoing and other embodiments can each optionally include one or more of the following features alone or in combination. The native code module includes one or more branch instructions. One of the regions is a code area. The code area is partitioned into equally sized code bundles. Validating the native code module includes verifying that for each indirect branch instruction having a respective destination address pointing into the code area the respective destination address of the branch instruction is a start of one of the code bundles. Validating the native code module includes verifying that for each direct branch instruction having a respective destination address pointing into the code area executing the branch instruction does not allow an unsafe instruction to be executed without its corresponding diffuser instruction or instructions being executed. Validating the native code module includes verifying that for each reachable store instruction in the native code module that uses a 64 bit base register the one or more diffuser instructions occur before the store instruction in the same code bundle as the store instruction. Validating the native code module includes verifying that no instruction that could modify the base register of the store instruction occurs after any of the one or more diffuser instructions and before the store instruction. The one or more diffuser instructions include at least a first instruction that clears one or more most significant bits of the base register of the store instruction such that a destination address of the store instruction must lie within the write area or one of the write area buffer zones. The methods include the action of verifying that each memory page of the write area buffer zones is marked as non writable or is unmapped.

In general another innovative aspect of the subject matter described in this specification can be embodied in methods that include the actions of receiving a native code module for an ARM 64 bit instruction set wherein the instruction set has several types of load instructions wherein one or more of the types of load instructions are forbidden instructions and wherein the native code has one or more load instructions loading the native code module into a secure runtime environment wherein an address space of the secure runtime environment is divided into multiple regions and wherein one of the regions is a read area validating the native code module verifying that no reachable load instruction in the native code module is a forbidden instruction verifying that for each reachable load instruction in the native code module that uses a 64 bit base register the 64 bit base register used by the instruction is masked by one or more diffuser instructions defining a first read area buffer zone above and adjacent to the read area defining a second read area buffer zone below and adjacent to the read area determining that a first reachable load instruction in the native code module has an extended register offset wherein a source address of the first reachable load instruction is determined as a sum of an address contained in a first base register and a scaled 32 bit offset value contained in a first 64 bit offset register and determining that each read area buffer zone is at least 16 gigabytes in size. Other embodiments of this aspect include corresponding computer systems apparatus and computer programs recorded on one or more computer storage devices each configured to perform the actions of the methods.

The foregoing and other embodiments can each optionally include one or more of the following features alone or in combination. The native code module includes one or more branch instructions. One of the regions is a code area. The code area is partitioned into equally sized code bundles. Validating the native code module includes verifying that for each indirect branch instruction having a respective destination address pointing into the code area the respective destination address of the branch instruction is a start of one of the code bundles. Validating the native code module includes verifying that for each direct branch instruction having a respective destination address pointing into the code area the respective destination address of the branch instruction does not jump to a location between an unsafe instruction and its associated one or more diffuser instructions. Validating the native code module includes verifying that for each reachable load instruction in the native code module that uses a 64 bit base register the one or more diffuser instructions occur before the store instruction in the same code bundle as the load instruction. Validating the native code module includes verifying that no instruction that could modify the base register of the load instruction occurs after any of the one or more diffuser instructions and before the load instruction. The one or more diffuser instructions include at least a first instruction that clears one or more most significant bits of the base register of the load instruction such that a source address of the load instruction must lie within the read area or one of the read area buffer zones. The methods include the action of verifying that each memory page of the read area buffer zones is marked as non readable or is unmapped.

In general another innovative aspect of the subject matter described in this specification can be embodied in methods that include the actions of receiving a native code module for an ARM 64 bit instruction set wherein the instruction set comprises one or more types of forbidden instructions loading the native code module into a secure runtime environment wherein an address space of the secure runtime environment is divided into at least a code area and a non overlapping trusted area validating the native code module verifying that the code area includes no forbidden instructions and verifying that instructions can be executed only from the code area or the trusted area. Other embodiments of this aspect include corresponding computer systems apparatus and computer programs recorded on one or more computer storage devices each configured to perform the actions of the methods.

The foregoing and other embodiments can each optionally include one or more of the following features alone or in combination. Verifying that instructions can be executed only from the code area or the trusted area includes verifying that all of the address space other than the code area and the trusted area is marked as non executable or is unmapped. Verifying that instructions can be executed only from the code area or the trusted area includes verifying that branch instructions can only branch to the code area or the trusted area. Verifying that instructions can be executed only from the code area or the trusted area includes partitioning the code area into equally sized code bundles wherein each code bundle has a start address. Verifying that instructions can be executed only from the code area or the trusted area includes verifying that branch instructions that branch into the code area must branch to the start address of one of the equally sized code bundles. Verifying that instructions can be executed only from the code area or the trusted area includes verifying that each branch instruction that branches into the trusted area must branch to a respective safe entry point.

In general another innovative aspect of the subject matter described in this specification can be embodied in methods that include the actions of receiving a native code module for an ARM 64 bit instruction set wherein the native code module has one or more indirect branch instructions each indirect branch instruction having a respective destination address contained in a respective 64 bit destination register loading the native code module into a secure runtime environment wherein an address space of the secure runtime environment is divided into multiple regions and wherein one of the regions is a code area partitioning the code area into equally sized code bundles each code bundle having a respective start address wherein each start address is a multiple of a predetermined power of two validating the native code module and verifying that for each indirect branch instruction in the native code module one or more corresponding diffuser instructions exist wherein the combined effect of the one or more diffuser instructions is to clear one or more of the most significant bits of the destination register such that the destination address must lie within the code area and to clear one or more least significant bits of the destination register such that the destination address must be a multiple of the predetermined power of two. Other embodiments of this aspect include corresponding computer systems apparatus and computer programs recorded on one or more computer storage devices each configured to perform the actions of the methods.

The foregoing and other embodiments can each optionally include one or more of the following features alone or in combination. Validating the native code module includes for each indirect branch instruction in the native code module verifying that the one or more corresponding diffuser instructions occur before and in the same bundle as the indirect branch instruction. Validating the native code module includes for each indirect branch instruction in the native code module verifying that no instruction that could modify the destination register occurs between the one or more corresponding diffuser instructions and the indirect branch instruction. The one or more corresponding diffuser instructions include a first diffuser instruction that clears one or more most significant bits of the destination register such that the destination address must lie within the code area and a second diffuser instruction that clears one or more least significant bits of the destination register such that the destination address must be a multiple of the predetermined power of two. Alternatively the one or more corresponding diffuser instructions are a single diffuser instruction that clears one or more most significant bits of the destination register such that the destination address must lie within the code area and that clears one or more least significant bits of the destination register such that the destination address must be a multiple of the predetermined power of two.

Particular embodiments of the subject matter described in this specification can be implemented so as to realize one or more of the following advantages. Embodiments may provide per thread protection with low performance overhead during execution of native code modules for ARM 64 bit instruction sets while maintaining platform independence and portability across different web browsers and operating systems. Embodiments may provide per thread protection that constrains threads used to execute untrusted code in the native code module while allowing trusted code used to validate and execute the native code module to execute without constraints. Embodiments may permit a wider variety of store and load instructions in the native code module by requiring large write area buffer zones and read area buffer zones. Embodiments may simplify verification by enforcing that the code and the data in the native code module are in separate areas. Furthermore embodiments may improve performance by minimizing overhead associated with masking store and load instructions.

Finally the direct execution of the native code module on ARM 64 bit hardware may allow the native code module to execute on a variety of ARM 64 bit processors and operating systems without modification.

The following description is presented to enable any person skilled in the art to make and use the embodiments and is provided in the context of a particular application and its requirements. Various modifications to the disclosed embodiments will be readily apparent to those skilled in the art and the general principles defined herein may be applied to other embodiments and applications without departing from the spirit and scope of the present embodiments.

This specification describes methods and systems for maintaining security for the native code module within an ARM 64 bit instruction set architecture ISA e.g. the architectures referred to as ARMv8 that include the A64 instruction set. To maintain security the validator and the secure runtime environment maintain control flow integrity and constrain store and load instructions in the native code module. Consequently this specification describes methods and systems that provide per thread protection with low performance overhead during execution of native code modules while maintaining platform independence and portability across different web browsers and operating systems.

Computing system is an electronic device that provides one or more services or functions to a user. For example computing system may operate as a mobile phone personal computer PC global positioning system GPS receiver portable media player personal digital assistant PDA and or graphing calculator. In addition computing system may include an operating system not shown that coordinates the use of hardware and software resources on computing system as well as one or more applications e.g. web browser or web application that perform specialized tasks for the user. For example computing system may include applications such as an email client address book document editor web browser and or media player. To perform tasks for the user applications may obtain the use of hardware resources e.g. ARM 64 bit processor memory I O components network interface card graphics processing unit GPU and so on on computing system from the operating system as well as interact with the user through a hardware and or software framework provided by the operating system as described below.

In some cases computing system includes functionality to obtain and or execute applications using a network connection. In particular computing system may obtain web application from one or more servers e.g. server 1 or server x using a network connection with the server s and load web application in web browser . For example web application may be downloaded from an application server over the Internet by web browser .

Once loaded web application may provide features and user interactivity comparable to that of native applications on computing system . For example web application may function as an email client document editor media player computer aided design CAD system and or computer game. Web application may also include dynamic user interface elements such as menus buttons windows sub windows icons animations and or other graphical objects that emulate analogous user interface elements in native applications. In other words web application may correspond to a Rich Internet Application RIA .

Furthermore web application may execute on computing system regardless of the operating system drivers or hardware associated with computing system . Though platform independent applications such as web application may be more portable and secure than native applications such cross platform applications may lack certain performance capabilities of native applications.

More specifically non native applications such as web application may be written using scripting languages that are interpreted rather than compiled such as JavaScript JavaScript is a registered trademark of Sun Microsystems Inc. . The interpreted nature of web application and or other non native applications may result in significantly slower execution times for the non native applications than those of compiled native applications. Non native applications may also be unable to utilize low level libraries and or application programming interfaces API that are available for use by native applications. Consequently non native applications may provide limited functionality in certain tasks.

To enable native performance for web applications computing system may obtain and execute a native code module within plugin . Like web application native code module may be obtained from one or more servers e.g. server 1 or server x by web browser . For example web application may provide a hyperlink to native code module on the Internet. Web browser may then download native code module from the Uniform Resource Locator URL specified in the hyperlink. Alternatively native code module may be specified by the user or by an external source such as another web application and or a native application. Furthermore native code module may be obtained from local storage e.g. a browser cache on computing system instead of from a server.

More specifically native code module is a software module containing native code that runs directly on the ARM 64 bit processor . As a result native code module may be used to perform tasks that require substantial access to CPU resources on computing system . For example native code module may be used by web application to provide computationally intensive features associated with physics simulation signal processing audio codecs video codecs artificial intelligence modeling flexible high throughput cryptography and or multimedia editing and analysis.

Plugin includes a variety of mechanisms to ensure the safe execution of native code module . In particular native code module is validated by a validator provided by plugin prior to execution. Native code module validation is described in U.S. patent application Ser. No. 12 117 634 filed 8 May 2008 which is incorporated herein by reference.

Before native code module is validated native code module is loaded into a secure runtime environment provided by plugin . Optionally some or all of the validation may be performed before native code module is loaded into secure runtime environment . Native code execution in a secure runtime environment is described in U.S. patent application Ser. No. 12 117 650 filed 8 May 2008 which is incorporated herein by reference. Secure runtime environment may also be provided by a web browser extension to web browser or secure runtime environment may be built into web browser .

Furthermore because native code module may include binary code that runs directly on hardware native code module may be platform independent with respect to the operating system web browser and or other software components on computing system . As described in the above referenced applications plugin and or native code module may also include mechanisms for executing on a variety of instruction set architectures including the use of fat binaries and binary translators.

In some cases the system of includes functionality to safely execute native code module within an ARM 64 bit ISA. In other words plugin and web browser may correspond to software modules that execute directly on ARM 64 bit processor using the ARM 64 bit ISA. Moreover native code module may correspond to a set of ARM 64 bit instructions and data that is loaded into the address space of ARM processor and used to facilitate the execution of web application .

Native code module is loaded into memory of computing system for inspection by validator . Once loaded into memory page table protection provided by the operating system of computing system may prevent native code module from being modified. As discussed below with respect to page table protection may additionally restrict instruction execution in native code module to a code area in the address space memory stores to the write area in the address space and memory loads to a read area in the address space.

Validator performs static binary analysis on native code module to ensure that native code module conforms to a set of security constraints. If native code module does not conform to the security constraints validator may discard native code module prior to loading native code module into secure runtime environment .

During analysis of native code module validator ensures that native code module is statically linked at a start address within the code area by providing a zero based address range for native code module . Validator then sequentially disassembles and or decodes all executable instructions within native code module that would fall within a defined code area of an address space of secure runtime environment . The analysis verifies that the regions specified by the native code module are compatible with the predefined address space organization described below with reference to and that unused parts of the address space are unmapped. During disassembly validator may verify that native code module does not contain any restricted instructions such as instructions that directly invoke the operating system hardware performance instructions and or complex addressing modes or any constructions with irregular control flow e.g. direct branches that bypass diffuser instructions while leading to the execution of corresponding unsafe instructions. As discussed below validator may also verify that instructions can be executed only from code area or trusted area . Optionally the code area can include a secondary trusted area. The secondary trusted area can be used to include the only instructions that are permitted to jump from the code area to the trusted code and the validator may verify that this condition is satisfied. Alternatively a secondary trust area can be mapped into an otherwise unmapped area and the instructions jumping to the trusted code can be placed there by the validator or the secure runtime environment .

Once native code module is validated native code module is executed in secure runtime environment . As described in the above referenced applications secure runtime environment may load and launch native code module from memory provide an execution environment that includes communications threads memory management and debugging support for native code module moderate access to system resources according to an access policy for native code module and or support the isolated execution of multiple native code modules on computing system . Consequently secure runtime environment may provide additional mechanisms for ensuring the secure execution of native code module on computing system . In particular secure runtime environment may restrict access from native code module to registers memory and or other resources associated with the ARM 64 bit ISA.

As discussed in the above referenced applications validator enforces security for native code module by verifying that diffuser instructions are present to mask certain instructions within native code module . Diffuser instructions are instructions that are combined in a verifiable way with unsafe instructions i.e. instructions that have the potential to violate security constraints depending on the state of registers or memory at the time the instructions are executed e.g. branching to an arbitrary location or reading or writing to or from an arbitrary memory location. The required diffuser instruction or instruction sequence depends on the type of the unsafe instruction. In some cases the diffuser instruction or instructions precede the unsafe instruction in other cases the diffuser instruction or instructions succeeds the unsafe instruction. The validator ensures that whenever an unsafe instruction is executed the corresponding diffuser instruction or instructions have been or will be executed as the case may be. Furthermore the validator ensures that all diffuser instructions and the associated unsafe instruction are executed sequentially or at least with no intervening instructions that might compromise the effect of the diffuser instructions or no intervening instructions at all. Execution of diffuser instructions and their associated unsafe instructions within ARM 64 bit ISAs is discussed in further detail below with reference to .

Code area is a region of the address space of secure runtime environment . For example as illustrated in code area can be the first 4 gigabytes of memory. Code area is one of many regions into which the address space of secure runtime environment is divided.

Code area is partitioned into equally sized non overlapping and adjacent code bundles . shows an example code bundle. Each code bundle has a start address in bytes that is a multiple of a predetermined power of two e.g. or . To allow simple diffuser instructions to be used code area ends at an address that is a one less than a power of two. Note that if the native code module does not use all of the code area the secure runtime environment can leave the unused portion unmapped.

Validator verifies that each indirect branch instruction of native code module is masked by one or more appropriate diffuser instructions. shows an example indirect branch instruction masked by two diffuser instructions and where xzr is a reference to a 64 bit zero register r5 is the 64 bit destination register of indirect branch instruction and x5 is a reference to the 64 bit value of r5. The first diffuser instruction clears one or more most significant bits of a destination register of indirect branch instruction such that a destination address of indirect branch instruction must lie within code area . For example if code area is the first 4 Gbytes of memory then diffuser instruction would then clear the 32 most significant bits of the destination register r5 of indirect branch instruction . The second diffuser instruction clears one or more least significant bits of the destination register r5 of indirect branch instruction such that the destination address must be the start of one of the code bundles . The second diffuser does so by ensuring that the destination address must be a multiple of the same predetermined power of two as referenced by code bundles above. For example if the start addresses of code bundles are multiples of 16 bytes diffuser instruction would clear the 4 least significant bits of the destination register r5 of indirect branch instruction . The A64 instruction set provides an AND instruction for certain 64 bit immediate values including all values necessary for clearing arbitrary numbers of the bits at the top and bottom simultaneously. Thus this instruction can be used as a single diffuser instruction for all scenarios described in this specification.

In some cases diffuser instruction clears one or more most significant bits of the destination register r5 of indirect branch instruction such that the destination address of indirect branch instruction must lie within the code area. For example if code area were the first 2 Gbytes of memory then diffuser instruction would clear the 33 most significant bits. Consequently the destination addresses of indirect branch instructions in native code module would never lie outside code area .

Validator verifies that diffuser instruction and diffuser instruction occur before and in the same code bundle as indirect branch instruction . Validator also verifies that no other instruction that could modify the destination register r5 occurs between either of the two diffuser instructions and and the indirect branch instruction . For example validator allows intervening instruction to be a nop instruction or an instruction that modifies an unrelated register r1 as shown in . However validator does not allow intervening instruction to be an instruction that modifies the destination register r5.

Validator also enforces that the entire code area is checked for forbidden instructions and that instructions can be executed only from code area and trusted area . Specifically the ARM 64 bit instruction set can have some instructions that are forbidden e.g. msr instructions. Every 4 byte block in code area is interpreted as an instruction and validated such that no 4 byte block in code area is a forbidden instruction.

In some scenarios validator enforces that instructions can be executed only from code area or trusted area by ensuring that all the address space of secure runtime environment other than code area and trusted area is marked as non executable or is unmapped.

In some scenarios validator enforces that instructions can be executed only from code area or trusted area by verifying that branch instructions in native code module can only branch to code area or trusted area . For example validator verifies that all indirect branch instructions in native code module are masked such that their destination addresses must lie within the code area by clearing one or more most significant bits from the destination register. Validator also verifies that all direct branch instructions are pointing to either code area or trusted area . Consequently validator can further enforce that all branches to trusted area are direct branches.

In some scenarios validator further restricts branches into code area and trusted area . In particular code area is partitioned into multiple equally sized code bundles. Validator verifies that all indirect branches into code area will have a destination address at the start of one of the code bundles. In some implementations validator allows direct branches to a location within a code bundle if the location is not between an unsafe instruction and its associated one or more diffuser instructions. Furthermore safe entry points into trusted area may be defined. The safe entry points may be specified in a configuration file or other form of data provided to validator . For example secure runtime environment may publish safe entry points into trusted area for use by validator . Safe entry points are addresses through which native code module is permitted to interact with computing system e.g. to access I O components network interface cards GPUs and so on. Validator verifies that direct branches into trusted area will be to one of the safe entry points.

Validator and secure runtime environment additionally constrain store instructions in native code module . Validator and secure runtime environment may also constrain load instructions in native code module . Validator verifies that one or more diffuser instructions exist for each load or store instruction in native code module and verify that the load or store instructions use specific addressing modes. Validator also enforces the use of unmapped pages or page protection to bound a valid memory region and call stack of native code module . Constraining store instructions is discussed in further detail below with respect to .

Described most generally the multiple regions include a writable region which is not necessarily zero based and a bigger readable region which is zero based that the base registers are restricted to and buffer zones around the readable region which make it feasible to permit addressing modes that may compute an effective address by adding a shifted 32 bit value to a base value. In each case the region is nominally zero based in the sense that the diffuser instructions do not prevent i stores to access the entire range from zero to the top of the write area ii loads to access the entire range from zero to the top of the read area iii indirect branches to branch to bundles from zero to the top of the code area. However page memory protection established by the operating system on behalf of the validator does impose additional restrictions e.g. effectively carving out the code area from the write area because self modifying code cannot be permitted. In the example division of the address space described below the writable region corresponds to write area the readable region corresponds to read area and the buffer zones correspond to unmapped pages .

In some cases code area begins at address 0 and extends to an address that is one less than a power of two. Alternatively code area may begin at a different address other than 0 zero and may not extend to an address that is a power of two. If a code area begins above zero the pages below the code area would be marked non executable because the diffuser instruction would not prevent branches to the low addresses. For example code region can be the first 3 Gbytes of the address space. Write area begins where code area ends and extends to an address that is one less than a higher power of two e.g. between 3 Gbytes and 8 Gbytes of the address space. Alternatively write area may begin at a different address other than the end of code area and may not extend to an address that is one less than a power of two. Read area begins at address 0 zero and extends to an address that is one less than a power of two e.g. the first 8 Gbytes of the address space. Alternatively read area may begin at a different address other than 0 zero and may not extend to an address that is one less than a power of two. Finally trusted area spans some other region of the address space e.g. between 100 Gbytes and 120 Gbytes of the address space. Code area may contain only code while write area and read area may contain a call stack and data . Unmapped pages and may bound trusted code and data used to facilitate the execution of the native code module such as code and data for a validator e.g. validator of secure runtime environment e.g. secure runtime environment of and or trusted services associated with the native code module.

Write area buffer zones span regions of the address space on both sides of write area of size 16 Gbytes each. For example as illustrated in if write area were the region of the address space between 3 Gbytes and 8 Gbytes one of the write area buffer zones would span the region of the address space between 8 Gbytes and 24 Gbytes on one side and another write area buffer zone would wrap around to the upper end of the address space spanning the region between 0 and 3 Gbytes and between 13 Gbytes from the end of the address space until the end of the address space.

Similarly if the address space includes a read area read area buffer zones would span regions of the address space on both sides of read area of size 16 Gbytes each. For example if read area is the first 8 Gbytes of memory then read area buffer zones would be between 8 Gbytes and 24 Gbytes and between 16 Gbytes from the end of the address space until the end of the address space.

As described in the above referenced applications trampoline instructions may be used by the native code module to access resources and or services associated with trusted region . However validator and or secure runtime environment may prevent the native code module from inappropriately accessing trusted region and or other portions of the address space.

Secure runtime environment includes page table protection. Page table protection may be provided by the ARM 64 bit processor and or an operating system associated with the address space and may restrict the native code module s access to various parts of the address space. First page table protection may restrict access to code area write area and read area . As described above code area may begin at address 0. Moreover after the native code module is loaded into code area page table protection may prevent code area from subsequent modification.

In some scenarios page table protection may also be used to prevent the native code module from executing portions of the address space outside of code area . For example the use of execute never or XN bits in ARM 64 bit page table entries may prevent the native code module from executing pages in write area . Bits in page table entries may also be set to restrict portions of the address space to non writable access and or read write access by the native code module. For example the memory pages of write area buffer zones can be set to non writable or they can be unmapped. For example string constants associated with the native code module may be stored in a non writable section of read area that is enforced using page table protection. Memory that is not intended to be read e.g. read area buffer zone can be unmapped or marked as non readable. As discussed below page table protection associated with unmapped pages and may effectively constrain the native code module s memory references and stack pointer updates to code area write area and or read area while minimizing performance overhead.

In some implementations the stack point is allowed to be anywhere in the write area which has the read area buffer zone which has already been described. For load and store instructions with the stack pointer the validator limits the instruction modes to ones using a register or a register plus a scaled offset.

In some implementations validator enforces storage of valid data addresses e.g. within data region in stack pointer e.g. the sp register used to reference call stack . Stack pointer may be initialized with an address within call stack . To constrain stack pointer within call stack the validator may ensure that call stack is bound with unmapped pages and enable store instructions that increment or decrement stack pointer without masking mask direct updates to stack pointer to keep a value of stack pointer within call stack follow instructions that change stack pointer with diffuser instructions so that stack pointer is within call stack the next time stack pointer is used or any combination of these techniques.

More specifically having unmapped pages and may permit the use of stack relative store instructions without masking if the immediate offset plus the largest store is smaller than a size of one or more of the unmapped pages e.g. 4 Kbytes which may be pages of a buffer zone. Immediate offsets are 12 bit numbers may be left shifted by up to 12 bits and may be scaled by increments of 4 bytes. As a result store instructions e.g. stp and ldp instructions that increment or decrement stack pointer may be executed without masking Because such instructions make relatively small adjustments to stack pointer the adjustments either keep stack pointer within call stack or cause segmentation violations if stack pointer exceeds the bounds of call stack and references an instruction in an unmapped page or . The secure runtime environment may then respond to the segmentation violations by terminating the execution of the native code module and or triggering traps that handle the segmentation violations.

In addition direct updates to stack pointer may be made using the add sub and or mov instructions using immediate offsets while instructions such as ldr and ldp may be disallowed in direct updates to stack pointer . Alternatively load instructions that load a value into the stack pointer may be allowed by the validator like move instructions if followed by an appropriate diffuser instruction or instructions and instructions that update the stack pointer as a side effect of using a pre or post update addressing mode with the stack pointer may be allowed without any diffuser instructions. Direct updates with offsets larger than the size of unmapped pages and may be followed immediately by a masking instruction that keeps stack pointer within call stack and or unmapped pages and . For example a code bundle that contains a direct update to stack pointer may include the following 

To constrain non stack relative store instructions that use a 64 bit register validator allows addressing modes that calculate store addresses by combining a valid 64 bit base register with an immediate offset or with a scaled extended 32 bit register offset while disabling addressing modes that calculate store addresses by adding two 64 bit registers together. In particular if validator detects that at least one store instruction contains an extended register offset it enforces that write area buffer zones must each be at least 16 Gbytes in size. Optionally this address mode can be prohibited in which case the buffer zones can be smaller. These immediate offsets may thus cause displacements of at most 64 Mbytes. Store instructions with extended register offsets use a 32 bit value contained in a 64 bit offset register as an offset value. These offset values can be scaled by 4 bytes wherein the offset value is the 32 bit value multiplied by 4 bytes. These scaled extended 32 bit register offsets may cause displacements of at most 16 Gbytes. Consequently immediate offsets and scaled extended register offsets of register values within the address range of write area remain either within write area or generate memory references into write area buffer zones that can cause segmentation violations.

Furthermore validator verifies that non stack relative store instructions are masked to ensure that register values used in the non stack relative store instructions fall within write area or one of the write area buffer zones . For example a code bundle that contains a non stack relative store instruction may include the following instructions 

Those skilled in the art will also appreciate that the same mechanisms described above may be used to constrain load instructions in the native code module. In particular page table protection unmapped pages and restrictions on modifications to stack pointer and or masking base registers may also be used to constrain load addresses to read area or read area buffer zones . For example load addresses may be computed by combining a valid base register with an immediate offset and or by masking values in the base register. As a result the validator and secure runtime environment may also include functionality to constrain some or all load instructions in the native code module. Alternatively the validator and secure runtime environment can constrain none of the load instructions in the native code module allowing the native code module to read from any portion of the address space.

Validator also verifies that each memory page of write area buffer zones is marked as non writable or is unmapped. Consequently store instructions that attempt to address write area buffer zones will cause segmentation violations.

If validator is constraining load instructions validator will also verify that each memory page of read area buffer zones is unmapped or marked as non readable. Consequently load instructions that attempt to address read area buffer zones will cause segmentation violations.

Furthermore the validator and secure runtime environment may constrain any combination of non stack relative loads non stack relative stores stack relative loads and stack relative stores. Such selective constraining of loads and or stores may be based on security and or performance considerations associated with executing the native code module. For example stack pointer may be restricted to code area and write area e.g. the lower 8 Gbytes of the address space instead of to call stack to reduce the amount of masking used in stack relative loads and or stores.

First the native code module for an ARM 64 bit instruction set is received operation . The native code module may be received from one or more servers and or compiled from source code and or translated from some form of intermediate code into native code. In addition the native code module may be used to facilitate the execution of a web application such as a JavaScript application. For example the native code module may be used to perform computationally intensive operations for the web application.

Next the native code module is loaded into a secure runtime environment for an ARM 64 bit ISA operation . In particular the native code module may be loaded into a valid memory region e.g. code area write area and read area of in the 64 bit address space of the ARM 64 bit ISA. As part of the loading unused parts of the address space are unmapped if necessary and the buffer zones are established. The loaded native code module is then validated operation prior to executing the native code module. During validation the native code module may be inspected for conformity to a set of security constraints. In particular the native code module may be inspected to detect defects that do not conform to the security constraints operation . Specifically the native code module is validated as described above. If the native code module does not conform to the security constraints e.g. if the validator detects defects in the native code the native code module is discarded without having been executed.

If the validator does not detect defects in the native code module the native code module is executed in the secure runtime environment operation . The secure runtime environment may be provided by a plugin associated with the web browser a browser extension to the web browser and or a component within the web browser.

Consequently the validation of the native code module may enable secure execution of the native code module on ARM 64 bit hardware with low performance overhead while maintaining portability and platform independence across different web browsers and operating systems. In particular the validation may provide per thread protection that constrains threads used to execute untrusted code in the native code module while allowing trusted code used to validate and execute the native code module to execute without constraints. Furthermore the validation may improve performance by minimizing overhead associated with masking store and load instructions. Finally the direct execution of the native code module on ARM 64 bit hardware may allow the native code module to execute on a variety of ARM 64 bit processors and operating systems without modification.

The foregoing descriptions of embodiments have been presented only for purposes of illustration and description. They are not intended to be exhaustive or to limit the embodiments to the forms disclosed. Accordingly many modifications and variations will be apparent to practitioners skilled in the art. Additionally the above disclosure is not intended to limit the present embodiments. The scope of the embodiments is defined by the appended claims. What is claimed is 

