---

title: Systems and methods for parsing user-generated content to prevent attacks
abstract: The present invention relates to systems and methods for parsing of a token stream for user generated content in order to prevent attacks on the user generated content. The systems and methods include a database which stores one or more whitelists, and a parser. The parser removes tokens from the token stream by comparing the tokens against the whitelist. Next, the parser validates CSS property values, encodes data within attribute values and text nodes, reconciles closing HTML tags, and coerces media tags into safe variants. The tokens removed may be any of HTML tags, HTML attributes, HTML protocols, CSS selectors and CSS properties.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09098722&OS=09098722&RS=09098722
owner: Prevoty, Inc.
number: 09098722
owner_city: Los Angeles
owner_country: US
publication_date: 20130315
---
This application is related to co pending and concurrently filed application U.S. Ser. No. 13 839 622 filed Mar. 15 2013 entitled Systems and Methods for Tokenizing User Generated Content to Enable the Prevention of Attacks by Kunal Anand which is incorporated by reference herein for all purposes.

The present invention relates to systems and methods for preventing malicious attacks contained within user generated content in an online computing setting. Traditionally sophisticated third parties like publishers produced content for users via the Internet. Increasingly however users are interested in more interactive experiences. These users don t merely want to consume content they wish for more immersive participatory experiences. Today users are significant creators of user generated content.

As such user generated content has become a rapidly expanding field. Users typically create content through interacting with web applications from desktop web browsers mobile web browsers third party client widgets third party client libraries and application programming interfaces APIs . These are the most popular mechanisms of contributing user generated content over Hypertext Transfer Protocol HTTP . Often user generated content may contain text plain or localized in an international language hypertext markup language HTML cascading style sheet CSS information and JavaScript JS among other known script variants. User generated content is delivered as strings and or sequences of bytes to web applications via a communications network such as HTTP or read from data persistence stores such as databases caches or queues.

With the proliferation of user content there has been an equally robust increase in the number of attacks embedded in user generated content. These attacks enable malicious parties to gain personal and potentially sensitive information on users redirect users to malicious websites track user browsing behavior and otherwise take advantage of users often without them being aware of the attack.

User generated content can contain two significant attack variants cross site scripting XSS or structured query language SQL injection. An XSS attack exploits security vulnerabilities found in web applications. XSS enables an attacker to inject a client side script into web pages viewed by other users allowing said attacker to bypass access controls. XSS is possible through malicious JS tags attributes protocols CSS properties and rich media tags. XSS attacks accounted for roughly 84 of all security vulnerabilities documented by a major security firm in 2007. XSS attacks have the ability to read and write web browser cookies containing private user data create web application requests on behalf of a user without acknowledgement redirect users to malicious websites as well as other behaviors that take advantage of a user s trust.

In contrast SQL injection is designed to attack data driven applications. This is accomplished by providing fragments of a SQL query into an input variable supplied by a web application user. When the input is evaluated by the application the tainted SQL query is executed allowing attackers to CRUD create read update delete information potentially sensitive from a database.

Currently a number of techniques exist to reduce the danger of user generated content attacks. The most commonly employed techniques utilize filters that attempt to prevent XSS and SQL injection attacks by using a blacklist to remove content. As used herein the term blacklist means a source of information that enumerates a list of pre defined attacks to be removed. The process of using the blacklist to perform transformations employs a strategy of applying heuristics via string and regex regular expression replacements. At runtime this flow typically looks like 

After the blacklist has been loaded it can be used to remove malicious content and potential content attacks. The blacklist process is comprised of the following steps 

Unfortunately current methods utilizing blacklists for the filtering of content attacks in user generated content is insufficient to prevent many of said attacks from being successful or otherwise obstruct the content. This is because blacklist based security filtering suffers from three major drawbacks. The first drawback is that these filters are employed in an iterative model way to remove first level attacks and completely miss nested attacks. One example is a concatenation based attack that comes together post blacklist filtering.

Secondly these existing blacklist based filters run the risk of removing fragments of content that may resemble HTML CSS and SQL injection but are not. The intent and fidelity of the source content therefore has the potential of being ruined.

Lastly and possibly most importantly these filters are immediately outdated as new attack variants are discovered. The entire system is built on top of existing attack definitions and is unreactive to new attacks. Consequently a system like this has virtually no defense against undefined and newly discovered attacks such as zero day exploits.

It is therefore apparent that an urgent need exists for improved systems and methods for preventing attacks against user generated content. Such systems and methods enable attack prevention that are not reactive to the introduction of new attacks and may prove to be more accurately able to prevent attacks than current systems.

To achieve the foregoing and in accordance with the present invention systems and methods for parsing of user generated content in order to prevent attacks is provided. The parsing filters out all attacks including XSS and SQL injections.

In some embodiments the security system capable of parsing user generated content receives a token stream that was generated from the user content. By being tokenized prior to parsing the content may be more efficiently filtered. The system includes a database which stores one or more whitelists and a parser. The parser removes tokens from the token stream by comparing the tokens against the whitelist. Next the parser validates CSS property values encodes data within attribute values and text nodes reconciles closing HTML tags and coerces media tags into safe variants.

The tokens removed may be any of HTML tags HTML attributes HTML protocols CSS selectors and CSS properties. Removal includes iterating over the token stream while filtering for nodes that are HTML tags and cross referencing the tag against the whitelist if the tag is in the whitelist then iterating through the attributes of the tag and cross referencing the attributes against the whitelist. Next the system iterates through protocol based HTML attributes to identify a valid URL and cross references the valid URL with the whitelist. It also iterates through the CSS selectors within and tags and cross references the CSS selector with the whitelist if the CSS selector is in the whitelist then the system iterates through properties for the CSS selector in tags or as style attributes on a specific HTML tag and cross references the properties against the whitelist. Any token which is not found in the whitelist when cross referenced is removed. The system may also remove matching opening closing nodes to the removed token.

When the system validates the CSS property value it iterates through each property value combination and verifies that the CSS property value meets the requirements set forth in CSS specification. Any CSS property value which does not meet requirements set forth in CSS specification is removed.

An encoder may be run for text within attribute values and text nodes. Further closing HTML tags that have missing opening tags may be removed and matching closing HTML tags for opening tags that are not closed may be inserted. The system updates opening closing positions throughout the entire token stream when new matching nodes are added.

Lastly the system coerces media tags into safe variants by iterating through rich media tags and coercing the rich media tags based on type class identifier and URL endpoints for the destination file.

Note that the various features of the present invention described above may be practiced alone or in combination. These and other features of the present invention will be described in more detail below in the detailed description of the invention and in conjunction with the following figures.

The present invention will now be described in detail with reference to several embodiments thereof as illustrated in the accompanying drawings. In the following description numerous specific details are set forth in order to provide a thorough understanding of embodiments of the present invention. It will be apparent however to one skilled in the art that embodiments may be practiced without some or all of these specific details. In other instances well known process steps and or structures have not been described in detail in order to not unnecessarily obscure the present invention. The features and advantages of embodiments may be better understood with reference to the drawings and discussions that follow.

As previously noted user generated content has become far more prevenient in recent years. As a direct correlation corresponding attacks embedded in such content have likewise increased. Turning to Users typically create content through interacting with web applications from desktop web browsers mobile web browsers third party client widgets third party client libraries and application programming interfaces APIs . These are the most popular mechanisms of contributing user generated content over Hypertext Transfer Protocol HTTP . Often user generated content may contain text plain or localized in an international language hypertext markup language HTML cascading style sheet CSS information and JavaScript JS among other known script variants. User generated content is delivered as strings and or sequences of bytes to web applications via a communications network such as HTTP or read from data persistence stores such as databases caches or queues.

The present invention relates to novel systems and methods for preventing attacks on user generated content. Unlike previous systems that utilize blacklists as previously discussed the present system utilizes a tokenization process followed by a parsing process which compares user generated content nodes to whitelists of allowable data. By screening for allowable data as opposed to scripts that are attacks such a system and methods becomes proactive rather than reactive against security threats. This enables a higher degree of protection for users.

Note that while much of the discussion contained herein relates to user generated content in the context of Internet social media sites and the like such systems and methods are valuable wherever HTTP content is open to attack via XSS or SQL injection.

The following description of some embodiments will be provided in relation to numerous subsections. The use of subsections with headings is intended to provide greater clarity and structure to the present invention. In no way are the subsections intended to limit or constrain the disclosure contained therein. Thus disclosures in any one section are intended to apply to all other sections as is applicable.

To facilitate the discussion illustrates a system to protect user generated content from malicious attacks in accordance with some embodiments. In this example system the users to are seen interacting with interfaces to . The interfaces may include any of those illustrated in including web applications from desktop web browsers mobile web browsers third party client widgets third party client libraries and application programming interfaces APIs . Via the interface the user may generate content that is supplied via the computer network to the web application . The computer network may be the Internet internal corporate network or any other wide area network.

A security system may interact with the user content prior to access by the web application or as part of the web application s security features. The security system is illustrated in greater detail in . Here it can be seen that the security system includes a front end server including a computer processor which handles the interaction between the computer application and computer network. The server is capable of receiving the user generated content and provides it to a pre processor that utilizes a secondary input of the target s language to ensure that tokenization described in greater detail below is capable of iterating over bytes correctly. The target language is simply an identifier that represents the character set of the input. Several examples of this include ASCII Latin 1 UTF 8 and UTF 16.

The security system also includes a tokenizer that is capable of extracting meaningful tokens from the content for further analysis. This tokenized stream that is generated by the tokenizer may be processed by a parser which compares the nodes within the token stream to a whitelist in order to prevent the execution of content attacks. Whitelists are configurations of approved data that if properly matched allow for the pass through within the stream. Data not matching the whitelist is presumed to not belong and thus is discarded by the security system.

In comparison to using a blacklist the implementation of a whitelist is a far superior approach for sanitizing content. As more attacks are discovered the blacklist will linearly grow. With a whitelist implementation more attack preventions may not require additional configuration. Whitelists may be stored within the security system in a database cache or memory for ready retrieval.

The usage of a whitelist requires that the content be chunked into a token stream comprised of recognizable token stream nodes for future parsing. This process may be referred to as tokenizing or lexical analysis in the context of this application. In order to describe the process of tokenization with more clarity attention is directed to where a high level flow chart is provided for the process of tokenization.

In this example process flow user content is input to the tokenizer as a string or a sequence of bytes. The result is a token stream of token nodes with support for further operations the addition removal of HTML tags HTML attributes CSS selectors CSS properties and HTML tag balancing. These operations can only be performed after a valid token stream is yielded from the tokenization process.

The tokenizer can be implemented in a development testing and production environment to accept content through communication protocols including standard input STDIN transmission control protocol TCP requests HTTP requests and through a remote procedure call RPC protocol. Of course it is considered within the scope of this disclosure that any communication protocol that supports the ability to send strings and or bytes can interact with this processor.

For the tokenization process initially the content string is pre processed at . A secondary input of the target s language is provided at this step to ensure that the tokenization phase is able to correctly iterate over bytes while providing first class support for internationalized characters. Pre processing is described in greater detail in reference to . The pre processing step also includes the initialization of finite state machine FSM variables at tokenizer markers unsigned integers at and string buffers at . FSM variables are used by the programmed FSM to signal states for appending parsed text into buffers as well as constructing appending token stream nodes into the token stream. The FSM variables are symbolic identifiers that guide the flow of tokenization. Various actions can happen when specific FSM states are activated. One example is at the start of an HTML tag to convert existing text buffers into a token stream text node and subsequently insert it into the token stream.

Returning to the next step is tokenization at of the pre processed user generated content. Tokenization is the process of extracting meaningful tokens from content to be further analyzed by a parser or subsequent phases of lexical analysis. A token represents a string of characters categorized according to the rules as a symbol e.g. IDENTIFIER NUMBER COMMA . Extraction of symbolic data from strings requires scanning input by individual runes. Through activating individual finite state machine states each rune is pushed into a specific buffer text HTML tag name HTML attribute name HTML attribute value CSS selector CSS property name CSS property value .

Details of tokenization are provided in . Buffers allow text at HTML tag names attributes at and CSS selectors properties at to accumulate of which the final accumulation representing the intent of user generated content. HTML tokenization precedes CSS tokenization as the latter is nested within the former. At the end of each state particular buffers are used to construct specific token stream nodes to be inserted into the token stream and subsequently cleared to handle future finite state machine states.

In the case of adding HTML tag nodes to the token stream tokenization markers are established on matching opening closing tag nodes to support future tag balancing. This is accomplished by iterating through the token stream in reverse searching for the complementary tag node. In the case of an opening tag a complementary tag node is defined as a closing tag with the same tag name. In the case of a closing tag a complementary tag node is defined as an opening tag with the same tag name. Unlike parsing a well formed Extensible Markup Language XML document user generated HTML may not be properly formatted. The tokenizer is constructed to handle malformed HTML and CSS while adhering to World Wide Web Consortium W3C specifications.

Returning to the third final phase of tokenization is termination of the process at by inserting the remaining buffers that did not activate finite state machine states into the token stream. Turning to these buffers are converted to strings that are HTML encoded and appended to the token stream as text nodes at . Finite state machine variables token markers and string buffers are all cleared at the end of this process at . At the end of this process a token stream full of token stream nodes is yielded to the caller.

Below is provided a table illustrating significant finite state machine states that are utilized within the disclosed tokenization process 

Now an example of tokenization will be provided to assist in clarification of the process. Note however that this example is but one possible way of tokenizing and is not intended to limit the overall scope of this disclosure.

The above example is a simple visualization of the nodes that comprise a reference token stream. From the token stream it s evident that HTML tags have opening closing values which allows for future tag balancing and other manipulation. Text nodes are distinguished from tag nodes in that text nodes only contain a single value of the text content.

Once the token stream has been constructed in the manner disclosed above the system may check if each node is whitelisted. illustrates the parsing process in flowchart form at in accordance with some embodiments. The parsing process includes the removal of HTML tags that are not in the whitelist at . This involves iterating over the token stream while filtering for nodes that are HTML tags. For each tag the system checks whether or not it belongs in the whitelist. If the tag belongs the process proceeds to HTML attribute whitelist checking. If the tag does not belong then it is removed as well as any potentially corresponding opening closing tag nodes.

Next HTML attributes that are not in the whitelist are removed at . This involves iterating through the attributes for each tag. For each attribute the system checks whether or not it belongs in the whitelist for each tag. If the attribute belongs the process proceeds to protocol checking assuming that the attribute is a recognized protocol based attribute. If the attribute does not belong then the attribute key and value are removed.

The process then removes HTML protocols that are not in the whitelist at . This involves iterating through protocol based HTML attributes for each tag. For each attribute value the process parses the protocol as a URL. If the URL is valid and the schema matches the whitelisted definition then the sanitized version is accepted. If it is invalid then the entire attribute including the value is removed.

Subsequently CSS selectors that are not in the whitelist are removed at . This involves iterating through the selectors within and tags sources of CSS definitions that are involved with rendering an HTML document. If the selector has been whitelisted then the process proceeds to property value examination. If it is invalid then the selector as well as all of the nested key values is removed.

Then CSS properties that are not in the whitelist are removed at . This involves iterating through the properties for a defined selector in and tags or as style attributes on a specific HTML tag. If a property has been whitelisted the system checks the value. If it is invalid then the CSS property including the name and value is removed.

Next the process validates CSS property values protocols to conform to the CSS specification at . This involves iterating through each property value combination and verifying that the CSS property value meets the requirements set forth in the CSS specification. If it does not then the property including the name and value is removed.

Next the data within attribute values is encoded at . This involves running an encoder for text within attribute values. This is done to escape potential HTML fragments such as the characters. Likewise data within text nodes is also encoded at . This involves running an encoder for text nodes. This is done to prevent the creation of errant HTML constructs.

Subsequently the closing HTML tags that have missing opening tags are removed at . This involves iterating through the HTML tag nodes. If the tag has been closed but does not match an opening tag then it is removed. Matching closing HTML tags for opening tags that are not closed are then inserted at . This involves correctly inserting HTML tag nodes for nodes that have been opened but remain unclosed. When new matching nodes are added the opening closing positions are updated throughout the entire token stream.

Lastly media tags embeds objects are coerced into safe variants at . This involves iterating through the rich media tags embeds objects and coercing them based on type class identifier and URL endpoints for the destination file. This completes the parsing process. Parsing in this manner ensures that XSS and SQL injection attacks are filtered effectively.

Now an example of parsing tokenized user generated content will be provided to assist in clarification of the process. Note however that this example is but one possible way of parsing and is not intended to limit the overall scope of this disclosure.

In this example an XSS attack that automatically redirects users to a malicious site http badsite.com in JavaScript in the inner text of an HTML script tag is provided which does not require a user action other than loading the page 

Once this token stream goes through the parser step 1 will remove the first and third elements which is the tag. The tag is the simplest way of embedding JavaScript onto a page. This tag would never be in the whitelist and therefore always eliminated during the parsing phase. The final piece of content is simply window.location http badsite.com this is safe text content that does not create future exploits.

In this case any HTML attribute that begins with on is an attribute that enables JavaScript execution. This attribute would be absent from the blacklist and therefore removed from the tag.

In this case any HTML attribute that begins with on is an attribute that enables JavaScript execution. This attribute would be absent from the blacklist and therefore removed from the tag.

Likewise here is provided a XSS attack similar to the one above but now as an HTML attribute protocol in this case the user has to explicitly click on the link 

Like the above attempts this XSS attack in this case is disguised within a protocol based attributed. This would be removed as JavaScript protocols would never be in the whitelist.

In sum the present invention provides systems and methods for tokenizing and parsing user generated content in order to prevent content attacks like XSS or SQL injection. Such systems and methods utilize whitelists rather than traditional blacklist filters thereby eliminating the reactive nature of attack prevention common to all current systems. Likewise whitelist filtering does not increase in configuration size as additional attacks are discovered thereby ensuring consistent and efficient filtering even over time.

While this invention has been described in terms of several embodiments there are alterations modifications permutations and substitute equivalents which fall within the scope of this invention. It should also be noted that there are many alternative ways of implementing the methods and apparatuses of the present invention. It is therefore intended that the following appended claims be interpreted as including all such alterations modifications permutations and substitute equivalents as fall within the true spirit and scope of the present invention.

