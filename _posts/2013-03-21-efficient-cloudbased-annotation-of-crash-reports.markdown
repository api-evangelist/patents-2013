---

title: Efficient cloud-based annotation of crash reports
abstract: One embodiment of the present invention relates to a system for efficiently annotating numerous crash reports originating from multiple instances of an application. Prior to deploying a version of the application, a service receives a file that stores debugging information associated with the version. Next, the service parses the debugging information from the file. The service then converts the debugging information into an object representation in memory and stores the object representation in a database. Next, in response to an instance of the version crashing on a client device, the service receives a crash report from the client device. Then, for each item in the crash report, the service determines whether that item needs to be annotated and, if so, annotates the item.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09104797&OS=09104797&RS=09104797
owner: INTUIT INC.
number: 09104797
owner_city: Mountain View
owner_country: US
publication_date: 20130321
---
Despite a software developer company s best efforts a software application may contain bugs even after the company releases the application into the market. These bugs may cause a user to experience an application crash on her client device. The fact that the application crashes on a client device outside of the company s development environment introduces obstacles to finding and fixing the underlying bug.

First crash reports commonly lack information. Generally the only evidence of an application crash is a crash report. While some crash reports may help pinpoint the bug s location in the application s source code by providing line numbers in the original source code and method names others only display the absolute address of the instruction that caused the crash. Without more clues developers may spend more time and effort chasing down the bug than they otherwise need to.

Second the crash occurred outside the company s development environment. Hence the developers may not have a way of conveniently accessing crash reports generated on a user s client device.

Finally a popular application may generate a high volume of crash reports. If a popular application possesses a bug that causes the application to crash this crash may repeat on numerous client devices generating a torrent of crash reports. This torrent may overwhelm any process for handling crash reports.

One embodiment of the present invention relates to a system for efficiently annotating numerous crash reports originating from multiple instances of an application. Prior to deploying a version of the application a service receives a file that stores debugging information associated with the version. Next the service parses the debugging information from the file. The service then converts the debugging information into an object representation in memory and stores the object representation in a database. Next in response to an instance of the version crashing on a client device the service receives a crash report from the client device. Then for each item in the crash report the service determines whether that item needs to be annotated and if so annotates the item.

In some embodiments of the present invention the debugging information is organized in Debugging with Attributed Record Formats DWARF format.

In some embodiments of the present invention the service does the following when receiving the file that stores the version s debugging information. First the service provides a directory for uploading files that store debugging information associated with a version of the application. Next the service detects when the file is uploaded to that directory.

In some embodiments of the present invention the debugging information may comprise a universally unique identifier UUID associated with the version relative addresses of method invocations within the application and symbols associated with each relative address. Additionally the symbols may comprise a line number a class name and a method name.

In some embodiments of the present invention the service does the following when converting the debugging information into an object representation. The service enters into a first map a key value pair wherein the key is the relative address and the value is the line number that is associated with the relative address. The service also enters into a second map a key value pair wherein the key is also the relative address and the value comprises the class and method names associated with a method invocation located at the relative address.

In some embodiments of the present invention the service does the following when storing the object representation in a database. The service saves each key value pair in the first map into an entry in a first database table. Here each entry is uniquely identified by a combination of the UUID and the relative address. The service then saves each key value pair in the second map into an entry in a second database table. Here each entry is also uniquely identified by a combination of the UUID and the relative address. Finally the service converts the object representation into an Extensible Markup Language XML representation and saves the XML representation into a third database table.

In some embodiments of the present invention the service does the following when receiving a crash report. First the service receives an annotation request from the client device wherein the annotation request is both in XML format and asynchronously received as a Representational State Transfer REST request. Additionally the annotation request encapsulates the crash report within a character data CDATA section.

In some embodiments of the present invention after receiving the crash report from the client device the service also obtains a start address from the crash report.

In some embodiments of the present invention the service determines whether the item needs to be annotated by determining whether the item contains a match to a regular expression.

In some embodiments of the present invention the service does the following when annotating the item. First the service obtains an absolute address from the item. Next the service calculates a relative address from the start address and the absolute address. The service then retrieves the symbols associated with the relative address. Finally the service replaces the item s absolute address with the symbols.

In some embodiments of the present invention the service does the following when retrieving the symbols associated with the relative address. First if a first sorted list is not in the cache the service populates the first sorted list with entries from the database. The service then performs a binary search on the first sorted list to find a line number associated with a method invocation located at the relative address. Next if a second sorted list is not in the cache the service populates the second sorted list with entries from the database. Finally the service performs a binary search on the second sorted list to find a class name and a method name associated with the method invocation.

The following description is presented to enable any person skilled in the art to make and use the invention and is provided in the context of a particular application and its requirements. Various modifications to the disclosed embodiments will be readily apparent to those skilled in the art and the general principles defined herein may be applied to other embodiments and applications without departing from the spirit and scope of the present invention. Thus the present invention is not limited to the embodiments shown but is to be accorded the widest scope consistent with the principles and features disclosed herein.

The data structures and code described in this detailed description are typically stored on a computer readable storage medium which may be any device or medium that can store code and or data for use by a system. The computer readable storage medium includes but is not limited to volatile memory non volatile memory magnetic and optical storage devices such as disk drives magnetic tape CDs compact discs DVDs digital versatile discs or digital video discs or other media capable of storing code and or data now known or later developed.

The methods and processes described in the detailed description section can be embodied as code and or data which can be stored on a non transitory computer readable storage medium as described above. When a system reads and executes the code and or data stored on the non transitory computer readable storage medium the system performs the methods and processes embodied as data structures and code and stored within the non transitory computer readable storage medium.

Furthermore the methods and processes described below can be included in hardware modules. For example the hardware modules can include but are not limited to application specific integrated circuit ASIC chips field programmable gate arrays FPGAs and other programmable logic devices now known or later developed. When the hardware modules are activated the hardware modules perform the methods and processes included within the hardware modules.

Some embodiments of the present invention use data structures search algorithms and the REST paradigm to provide a cloud based service for annotating numerous crash reports sent from application instances running on client devices. Annotated crash reports contain more information about the crash enabling developers of the application to fix the application s bugs more quickly.

In some cases embodiments of the present invention offer various advantages. Where a user of a client device installs an application onto the client device an application crash leaves only a crash report behind to document the causes of the crash. By having developers support a cloud based service that accepts crash reports embodiments of the present invention enable the client device to submit the crash report to the developers automatically. After the crash report is annotated developers may use the annotated crash report to quickly diagnose and fix the crash s underlying cause. Thus embodiments of the present invention promote a faster turnaround time for fixing application bugs by providing an automatic process for handling crash reports with little developer oversight. Furthermore embodiments of the present invention save developers the trouble of having to manually annotate the crash report themselves via a command item executable by automatically annotating crash reports.

In some cases embodiments of the present invention may also shorten the time needed to annotate a single crash report. Embodiments of the present invention achieve reduced annotation times by extracting organizing storing and caching debugging information needed to annotate crash reports prior to receiving the crash reports themselves. Thus even where the volume of incoming crash reports is high embodiments of the present invention can annotate and respond to all crash reports in near real time. By providing a quick response to crashes developers may garner good will from users of the application.

In cases where the application is compiled using Apple s Xcode integrated development environment IDE the OS X tools used to annotate the application run on the Mac OS platform. Because embodiments of the present invention may be written in Java embodiments of the present invention may provide the advantage of being platform agnostic. The ability to run the service on a variety of hardware systems may save developers 1 money otherwise spent on Mac OS hardware and 2 time otherwise spent on retraining system administrators to use the Mac OS platform.

One embodiment of the present invention relates to a system for efficiently annotating numerous crash reports originating from multiple instances of an application. Prior to deploying a version of the application a service receives a file that stores debugging information associated with the version. Note that by selecting certain options in a compiler the developer may instruct the compiler to generate the file when the compiler compiles the version of the application from source. For example when an application developer develops an iPhone application on Xcode the developer may instruct Xcode to produce a dSYM file during compilation by selecting the DWARF with dSYM File setting in the build options. The resulting dSYM file has a .dSYM extension in its name and possesses debugging information associated with the application s executable in DWARF format. The service then converts the debugging information into an object representation in memory and stores the object representation in a database. Next in response to an instance of the version crashing on a client device the service receives a crash report from the client device. Then for each item in the crash report the service determines whether that item needs to be annotated and if so annotates the item.

In some embodiments of the present invention the debugging information is organized in DWARF format. For example a dSYM file that is associated with the application contains debugging information about the application s executable in DWARF format.

In some embodiments of the present invention the service does the following when receiving the file that stores the version s debugging information. First the service provides a directory for uploading files that store debugging information associated with a version of the application. Note that the service may only expose the directory to the internal network of the company that developed the application. Also note that the ways in which the service may expose the directory include but are not limited to Hypertext Transfer Protocol HTTP and File Transfer Protocol FTP . Next the service detects when the file is uploaded to that directory. Note that the ways in which the service may detect a new file include but are not limited to a polling cron job that periodically checks the directory for new files and a script that triggers on filesystem event.

In some embodiments of the present invention the debugging information may comprise a universally unique identifier UUID associated with the version relative addresses of method invocations within the application and symbols associated with each relative address. Note that each version of the application is identified by a UUID. Also note that it is important to understand the relationship between the crash report and method invocations made in the application. The bulk of the information provided by a crash report comprises the stack trace. A stack trace provides a list of stack frames that were active at the time of the crash wherein each item of the stack trace represents a stack frame. Note that the forms a stack trace item may adopt include but are not limited to a line in the stack trace and a paragraph in the stack trace. Additionally because each stack frame is associated with a method invocation each item in the stack trace is associated with a method invocation. Furthermore each item in the stack trace is associated with a relative address wherein a relative address represents the offset between the memory location of the beginning of the application s executable and the memory location of the method invocation. Additionally the symbols may comprise a method name a class name and a line number wherein 1 the method name is the invoked method s name 2 the class name is the name of the class the invoked method is a member of and 3 the line number denotes the line in the original source code where the thread of execution invoked a second method within the invoked method.

In some embodiments of the present invention the service does the following when converting the debugging information into an object representation. The service enters into a first map a key value pair wherein the key is the relative address and the value is the line number that is associated with the relative address. The service also enters into a second map a key value pair wherein the key is also the relative address and the value comprises the class and method names associated with a method invocation located at the relative address. Note that if the service is written in Java the type of both maps may be any Java class that implements the java.util.Map interface. Also note that the object representation may exist in memory. Finally note that the object representation may comprise a family of Java classes designed to encapsulate the debugging information. For example the object representation may be an instance of a Java class named DWARFObject. Here the DWARFObject instance may contain both maps as member fields.

In some embodiments of the present invention the service does the following when storing the object representation in a database. The service saves each key value pair in the first map into an entry in a first database table. For example the columns of the first database table may comprise a column that stores relative addresses a column that stores UUIDs and a column that stores line numbers. Here each entry is uniquely identified by a combination of the UUID and the relative address. This is because while multiple versions of the same application may exist the service saves debugging information from all versions to the same table. Without the UUID debugging information from one version may override debugging information from another version. The service then saves each key value pair in the second map into an entry in a second database table. For example the columns of the second database table may comprise a column that stores relative addresses a column that stores UUIDs a column that stores method names and a column that stores class names. Here each entry is also uniquely identified by a combination of the UUID and the relative address. Alternatively the service may save the key value pairs in both the first and second maps to a single database table. Finally the service converts the object representation into an Extensible Markup Language XML representation and saves the XML representation into a third database table. Finally the service may move the file to a directory reserved for successfully processed files. The service may then generate an XML formatted success message and send the message via Java Message Service JMS to the service logs or some other intended recipient. If some error prevented the service from processing the file the service may move the file to a directory reserved for unsuccessfully processed files. The service may then generate an XML formatted error message and send the message via JMS to the service logs or some other intended recipient.

In some embodiments of the present invention the service does the following when receiving a crash report. First the service receives an annotation request from the client device wherein the annotation request is both in XML format and asynchronously received as a REST request. Note that the service may utilize an Apache HTTP web server or a Tomcat servlet among other solutions to implement the REST API. Additionally the annotation request encapsulates the crash report within a character data CDATA section. Note that in addition to the original crash report the annotation request may contain other information relevant to the crash such as the client device s CPU type.

In some embodiments of the present invention after receiving the crash report from the client device the service also obtains a start address from the crash report. Note that the start address represents the memory location of the application s executable in the client device s memory.

In some embodiments of the present invention the service determines whether the item needs to be annotated by determining whether the item contains a match to a regular expression. Note that because many of the items in the stack trace may already display symbols some items do not require annotation and the service may stream these items to an output buffer without further modification. For example the service may apply the regular expression 

against each item in a stack trace to determine whether the item needs to be annotated. In this example the following item 

does not produce a match for the regular expression. Thus the service may send this item to an output buffer without further processing. On the other hand because the item 

does produce a match the service may retain the item for annotation. Here 0x000078d0 is the absolute address that needs to be replaced with symbols.

In some embodiments of the present invention the service does the following when annotating the item. First the service obtains an absolute address from the item. Next the service calculates a relative address from the start address and the absolute address. Note that the service may calculate the relative address by subtracting the start address from the absolute address. The service then retrieves the symbols associated with the relative address. Finally the service replaces the item s absolute address with the symbols. For example the service may annotate the original item 

In this example the method name is testFunction2 the class name is MyCustomClass and the line number is 540.

In some embodiments of the present invention the service does the following when retrieving the symbols associated with the relative address. First if a first sorted list is not in the cache the service populates the first sorted list with entries from the database. Note that the cache may exist in local system memory. Recall that the first map represents relationships between line numbers and relative addresses. Also recall that the service stored the first map in the first database table. Now to minimize database transactions the service loads these relationships from the first database table into the first sorted list wherein the first sorted list is sorted by relative address. The service then performs a binary search on the first sorted list to find a line number associated with a method invocation located at the relative address. Next if a second sorted list is not in the cache the service populates the second sorted list with entries from the database. Recall that the second map represents relationships between class names method names and relative addresses. Also recall that the service stored the second map in the second database table. Now to minimize database transactions the service loads these relationships from the second database table into the second sorted list wherein the second sorted list is sorted by relative address. Finally the service performs a binary search on the second sorted list to find a class name and a method name associated with the method invocation.

User may include individuals groups of individuals organizations groups of organizations computing systems groups of computing systems or other entities that can interact with computing environment .

Client device may include any device that includes computational capability such as PDAs tablet computers laptops desktops smartphones and cell phones.

Development environment may include any device that supports an IDE such as Xcode or a suite of applications that allows a software programmer to develop software.

Both parsing module server and annotation module server may coexist on a single physical server or an advanced computing cluster or exist on separate physical servers or advanced computing clusters.

Symbol cache may include any type of system for caching data in volatile memory and may physically reside within annotation module server or exist as a separate physical system.

Database may include any type of system for storing data in non volatile storage. This includes but is not limited to relational database management systems text files XML files and spreadsheets. This also includes but is not limited to systems based upon magnetic optical or magneto optical storage devices as well as storage devices based on flash memory and or battery backed up memory.

Note that different embodiments of the present invention may use different system configurations and are not limited to the system configuration illustrated in computing environment .

The next three figures explain how the combination of a parsing module server and an annotation module server allows a software development company to annotate a high volume of crash reports originating from instances of an application executing on client devices. The flow chart found in provides a chronological illustration of this process. focuses on how the parsing module server uses dSYM files provided by a development environment to prepare the environment for annotating crash reports. focuses on how the annotation module server annotates incoming crash reports.

Note that when an application crashes on a client device a crash reporter service that runs on the device s operating system creates and sends a crash report to the developer s annotation module servers. The information included in a crash report includes a stack trace of the application at the time of the crash. Here each item in the stack trace represents a method the application had already invoked when the crash occurred. Some of these items do not provide the name of the invoked method. Rather these items may only display an absolute address which is the memory location of the method invocation in the client device. Embodiments of the present invention can replace absolute addresses with the associated method name the name of the class the method belongs to and the method invocation s line number in the source code file. Note however that the dSYM file maps method names class names and line numbers to relative addresses not absolute addresses. Embodiments of the present invention may calculate the relative address of an item from the item s absolute address and the application s start address which are both provided by the crash report.

As shown in embodiments of the present invention operate in two main phases. The first stage occurs when the application is close to release. In the process of developing an application in Xcode Xcode s compiler may generate a dSYM file as the compiler compiles the application. The dSYM file contains debugging information that when included in a crash report may help developers debug the application. Initially developers of the application may upload the dSYM file to a directory of a parsing module server operation . When the parsing module server detects the upload the parsing module server first parses debugging information from the file operation . As the parsing module server parses debugging information from the dSYM file the parsing module server sorts relative addresses and associated symbols from the debugging information into maps operation . Finally the parsing module server persists the Java objects into database tables operation .

The second stage ensues when a running instance of the application crashes on a client device. At this point the software development company has released the application into the market. Numerous client devices may be executing an instance of the application. Thus if one of these instances crashes due to an application bug many other instances may crash around the same time since all instances have the same bug producing a large number of crash reports crash repots in a short period of time.

Embodiments of the present invention provide an annotation module server that receives crash reports over the Internet operation . First the annotation module server extracts a start address from the crash report operation . Note that a start address is the starting memory location of the application in the client device. Next the annotation module server iterates over each item in the crash report s stack trace. By determining whether the item matches a regular expression the annotation module server decides whether the item requires annotation operation . If a match is found the annotation module server extracts the item s absolute address from the crash report. Then the annotation module server calculates the relative address from the absolute address and the start address operation . After making sure that the debugging information is loaded from the database into lists in the cache the annotation module server searches the lists for debugging information associated with the relative address operation . Finally the annotation module server annotates the item with the method name the class name and the line number operation .

In the beginning terminator the parsing module server periodically checks a local folder for recently uploaded dSYM files decision . For example suppose a software development firm that develops applications for the iPhone is about to release a new version of a popular third party application for the iPhone. In the days before the release an Xcode compiler which runs on development environment compiles the new version of the application. During compilation the Xcode also produces a dSYM file that is associated with the application. Meanwhile parsing module server which hosts parsing module mechanism exposes a directory within the company network for receiving dSYM files. A polling process on the server which is started via a scheduler constantly checks the pending directory for recently uploaded dSYM files. As soon as developer uploads the dSYM file into the directory parsing module server will detect the dSYM file.

Next the parsing module server extracts debugging information from the dSYM file. The debugging information includes header information such as a UUID that uniquely identifies the version and symbols associated with relative addresses wherein each symbol is associated with a line number a method name and a class name operation . Returning to the above example because the dSYM file is a binary file parsing module server parses out debugging information with byte level precision. Any errors in calculating offsets will cause parsing module server to extract the debugging information incorrectly rendering the debugging information corrupted and unusable. Suppose that parsing module mechanism makes use of the Java Platform. Additionally Apple s Mach O file format reference reveals how debugging information is stored with the dSYM file. Using both the reference and the Java Platform parsing module server instantiates an object of the type java.io.RandomAccessFile and uses the object to read sections of data from the dSYM file. Focusing on the symbol table and the debug item section of the dSYM file parsing module server uses the file pointer to 1 find locations of relative addresses of interest in the dSYM file 2 extract the relative addresses from the dSYM file and 3 extract line numbers method names and class names associated with each relative address from the dSYM file.

If an errors occurs while parsing module server parses the dSYM file decision parsing module server records this error and moves the dSYM file into a failure directory operation . Returning to the above example suppose that the dSYM file uploaded by developer is corrupted due to an incomplete upload. After parsing module server s attempt to parse the dSYM file fails parsing module server records this error in database and moves the dSYM file to the failure directory for future diagnosis.

On the other hand if the parsing succeeds decision the parsing module server converts the extracted debugging information into an object representation operation . Returning to the above example parsing module server creates an instance of the MachObject class which is a Java class to encapsulate the debugging information. All instances of the MachObject class possess child objects including those to hold header information such as the UUID. The child objects also include a line number map which is a Java object that implements the Map interface and which maps relative addresses to associated line numbers. The child objects also include a method name map which is a Java object that implements the java.util.Map interface and which maps relative addresses to associated class and method names. Note that in both maps the relative address acts as the key in the key value pair.

Next the parsing module server converts the object representation into an XML representation operation . Returning to the above example parsing module server uses Java Architecture for XML Binding JAXB to serialize the MachObject into an XML document.

Next the parsing module server stores both the object representation and the XML representation in a database operation . Returning to the above example parsing module server persists all entries from the method name map into a first database table and persists all entries of the line number map into a second database table. Note that the entries in both the first database table and the second database table are uniquely identified by the combination of the UUID and the relative address of the corresponding map entry. This way if multiple versions of the same application have their debugging information extracted and persisted to the same database table entries specific to a newer version of the application will not overwrite entries specific to an older version. Parsing module server also stores the XML representation into a third database table.

If storing the debugging information in a database results in an error decision the error is recorded and the dSYM file is moved to the failed directory operation . On the other hand if storing the debugging information in the database is successful the parsing module server moves the dSYM file to the processed directory operation .

First an annotation module server receives a crash report from a client device where an application instance has crashed operation . Returning to the previous example in assume that the software development company releases a version of the iPhone application to the market. Subsequently many consumers download and install the new version of the iPhone application on their iPhones. One of these consumers user installs the application on client . Meanwhile annotation module server uses a Tomcat servlet to provide a REST based service that accepts crash reports from remote client devices. When the application crashes on client client generates a crash report. Client then builds an XML document called a symbolication request and inserts the crash report into a CDATA element of the symbolication request. Next client sends the symbolication request across network to annotation module server . Finally annotation module server extracts the crash report from the symbolication request.

Next the annotation module server processes each item of the crash report s stack trace operation . Returning to the above example annotation module server uses an object of the type java.io.BufferedReader to read the crash report s stack trace.

Next the annotation module server uses regular expressions to determine whether an item needs to be annotated operation . If an item contains a match to a regular expression decision the annotation module server retains the item for annotation. Otherwise the annotation module server streams the item to an output buffer untouched operation . Returning to the above example annotation module server uses classes in the java.util.regex Java package to apply the regular expression 0 9 . 0x 0 9A F 1 8. 0x 0 9A F 1 8. 0 9 to each item in the stack trace. If there is no match annotation module server streams the item to an output buffer before proceeding to the next item in the stack trace. If there is a match annotation module server retains the item for annotation.

Next the annotation module server calculates the item s relative address using the item s absolute address and the application s start address operation . Returning to the above example annotation module server already knows the application s start address from the crash report. Next annotation module server extracts the item s absolute address from the item itself. Annotation module server then subtracts the start address from the absolute address to calculate the item s relative address.

Next the annotation module server determines whether a cache is populated with relative addresses and associated symbols specific to the application s version decision . If not the annotation module server loads the relative addresses and symbols from the database operation . Returning to the above example rather than obtaining debugging information from database every time an item is annotated annotation module server obtains debugging information from cache . If the cache is empty annotation module server loads all relative addresses and line numbers specific to the application s version from database into cache s line number list which is an object that implements the java.util.list interface. Additionally annotation module server loads all relative addresses method names and class names specific to the application s version from database into cache s method name list which is also an object that implements the java.util.list interface. Note that both the line number list and the method name list are sorted by relative address.

Next the annotation module server performs a binary search on both lists to find the line number the method name and the class name that are associated with the relative address operation . Returning to the above example because both lists are sorted by relative address annotation module server can use a binary search algorithm to find the entry that matches the item s relative address in either list. Once annotation module server locates the matching entry in both lists annotation module server retrieves the line number from the entry obtained from the line number list and retrieves the method name and the class name from the entry obtained from the method name list.

Finally the annotation module server annotates the item with the symbols obtained from the lists in the cache operation . If that item was the last item in the stack trace decision annotation module server finishes annotating the crash report and proceeds to process the next crash report terminator . Otherwise annotation module server continues to the next item in the crash report operation . Returning to the above example annotation module server annotates the item with the line number the method name and the class name. Then annotation module server sends the item to the output buffer Annotation module server then moves on to the next item in the stack trace. After annotation module server annotates the final item in the stack trace annotation module server builds an XML document called a symbolication response. Next annotation module server writes the annotated crash report which is stored in the output buffer into a character data node in the symbolication response. Finally annotation module server sends the symbolication response back to client over network .

The foregoing descriptions of embodiments of the present invention have been presented only for purposes of illustration and description. They are not intended to be exhaustive or to limit the present invention to the forms disclosed. Accordingly many modifications and variations will be apparent to practitioners skilled in the art. Additionally the above disclosure is not intended to limit the present invention. The scope of the present invention is defined by the appended claims.

