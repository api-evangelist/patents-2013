---

title: Systems and methods for deploying a spotted virtual server in a cluster system
abstract: The present invention is directed towards systems and methods deploying a virtual server on a subset of devices in a cluster of devices. A first device of a cluster of devices intermediary between at least one client and at least one server, may identify a first virtual server to establish on one or more devices of the cluster. The first device may associate, to the identified virtual server, a group comprising a subset of devices in the cluster of devices. The cluster may establish the first virtual server on each device in the group responsive to associating the group to the first virtual server. Each virtual server on each device of the group may be assigned a same internet protocol address.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09519518&OS=09519518&RS=09519518
owner: CITRIX SYSTEMS, INC.
number: 09519518
owner_city: Fort Lauderdale
owner_country: US
publication_date: 20130515
---
The present application generally relates to the management of virtual servers. In particular the present application relates to systems and methods for deploying a spotted virtual server in a cluster system.

Remote computing and centralized management of computing environments have converged to provide remote access to resources such as data and application resources but also to incorporate management aspects including multi level security e.g. authentication and firewall policies support for a variety of access points and client environments and uniform presentation of resources. Systems such as network appliances that help to provision applications and or data to remote users may deliver computing and or application services in a variety of ways. For example dedicated servers may provide access to particular software applications by delivering application components to a remote client for execution. Network appliances may provide proxy functions and applications such as secured session establishment load balancing and content switching. As application and computing needs evolve such systems may have to provide a higher level of service in both delivery and performance. Accordingly some of these systems may provide increased levels of parallel processing or multi tasking by incorporating multiple hardware and software engines to process packets and to support various applications.

The present disclosure is directed towards methods and systems for deploying a spotted virtual server in a cluster system. A device or appliance intermediary between one or more client and servers may include a cluster system that comprises a group of nodes. Each of these nodes may comprise a multi core system and may host one or more processing engines for handling packets. The present disclosure provides methods and systems for deploying a spotted virtual server vserver in a cluster system. The cluster system may include a cluster of nodes or devices. The cluster system may provide specific application services such as content switching load balancing and SSL VPN session establishment and or management. These services may be provided via a virtual server or a group of related virtual servers deployed within the cluster system. The clustered configuration of devices may often be symmetrical or homogeneous and any or most of the nodes may be configured to provide or support such application services sometimes in place of another node. Therefore a vserver may be placed hosted established or striped across the nodes of a cluster system. However in certain scenarios it may be desirable that a vserver be spotted on a subset of the nodes in the cluster. For example specific applications such as SSL VPN establishment and management and global server load balancing GSLB may be preferred as a spotted solution on a cluster. The present methods and systems allows for deployment of a virtual server on a subset of the devices instead of being striped across all nodes of a cluster.

In one aspect the present invention is related to a method for deploying a virtual server in a subset of devices of a cluster of devices. A first device of a cluster of devices intermediary between at least one client and at least one server may identify a first virtual server to establish on one or more devices of the cluster. The first device may associate to the identified virtual server a group comprising a subset of devices in the cluster of devices. The cluster may establish the first virtual server on each device in the group responsive to associating the group to the first virtual server. Each virtual server on each device of the group may be assigned a same internet protocol address.

In some embodiments the cluster may establish a second virtual server within the identified group. The second virtual server may include a virtual server dependent on the first virtual server. The first device may identify the group comprising the subset of devices in the cluster of devices. Each of the devices in the cluster may include a plurality of processing cores. The cluster may migrate the first virtual server to a second group comprising a second subset of devices in the cluster of devices and may migrate virtual servers dependent on the first virtual server to the second group. The cluster may receive a request to establish the first virtual server. The request may include a key. The cluster may determine based on the key a first core of an owner device in the group for establishing the first virtual server.

In certain embodiments the first device may request the first core to create an entry for a session of the first virtual server in a hash table. The first core may include in the entry an identification of the subset of the devices in the group. The cluster may replicate a hash table entry for the session at each remaining device of the group if the group comprises more than one device. The cluster may migrate each virtual server dependent on the first virtual server to a back up device of the owner device if the owner device leaves the cluster. The cluster may provide responsive to a second request from a client to access the session via the hash table based on the key included in the second request information about the session.

In another aspect the present invention is related to a system for deploying a virtual server in a subset of devices of a cluster of devices. The system may include a cluster of devices intermediary between at least one client and at least one server. A first virtual server may be established on one or more devices of the cluster. A first device of the cluster may identify the first virtual server to establish on the one or more devices of the cluster and may associating to the identified virtual server a group comprising a subset of devices in the cluster of devices. The first virtual server may be established on each device in the group responsive to associating the group to the first virtual server each virtual server on each device of the group assigned a same internet protocol address.

In certain embodiments the cluster establishes a second virtual server within the identified group the second virtual server comprising a virtual server dependent on the first virtual server. The first device may identify the group comprising the subset of devices in the cluster of devices each of the devices in the cluster comprising a plurality of processing cores. The cluster may migrate virtual servers dependent on the first virtual server to a second group comprising a second subset of devices in the cluster of devices responsive to migrating the first virtual server to the second group. The first device may receive a request to establish the first virtual server. The request may include a key. The first device may determine based on the key a first core of an owner device in the group for establishing the first virtual server. The first device may request the first core to create an entry for a session of the first virtual server in a hash table.

In some embodiments the first core includes in the entry an identification of the subset of the devices in the group. The cluster may replicate a hash table entry for the session at each remaining device of the group if the group comprises more than one device. The cluster may migrate each virtual server dependent on the first virtual server to a back up device of the owner device if the owner device leaves the cluster. The first core may provide responsive to a second request from a client to access the session via the hash table based on the key included in the second request information about the session.

The details of various embodiments of the invention are set forth in the accompanying drawings and the description below.

The features and advantages of the present invention will become more apparent from the detailed description set forth below when taken in conjunction with the drawings in which like reference characters identify corresponding elements throughout. In the drawings like reference numbers generally indicate identical functionally similar and or structurally similar elements.

For purposes of reading the description of the various embodiments below the following descriptions of the sections of the specification and their respective contents may be helpful 

Prior to discussing the specifics of embodiments of the systems and methods of an appliance and or client it may be helpful to discuss the network and computing environments in which such embodiments may be deployed. Referring now to an embodiment of a network environment is depicted. In brief overview the network environment comprises one or more clients also generally referred to as local machine s or client s in communication with one or more servers also generally referred to as server s or remote machine s via one or more networks generally referred to as network . In some embodiments a client communicates with a server via an appliance .

Although shows a network and a network between the clients and the servers the clients and the servers may be on the same network . The networks and can be the same type of network or different types of networks. The network and or the network can be a local area network LAN such as a company Intranet a metropolitan area network MAN or a wide area network WAN such as the Internet or the World Wide Web. In one embodiment network may be a private network and network may be a public network. In some embodiments network may be a private network and network a public network. In another embodiment networks and may both be private networks. In some embodiments clients may be located at a branch office of a corporate enterprise communicating via a WAN connection over the network to the servers located at a corporate data center.

The network and or be any type and or form of network and may include any of the following a point to point network a broadcast network a wide area network a local area network a telecommunications network a data communication network a computer network an ATM Asynchronous Transfer Mode network a SONET Synchronous Optical Network network a SDH Synchronous Digital Hierarchy network a wireless network and a wireline network. In some embodiments the network may comprise a wireless link such as an infrared channel or satellite band. The topology of the network and or may be a bus star or ring network topology. The network and or and network topology may be of any such network or network topology as known to those ordinarily skilled in the art capable of supporting the operations described herein.

As shown in the appliance which also may be referred to as an interface unit or gateway is shown between the networks and . In some embodiments the appliance may be located on network . For example a branch office of a corporate enterprise may deploy an appliance at the branch office. In other embodiments the appliance may be located on network . For example an appliance may be located at a corporate data center. In yet another embodiment a plurality of appliances may be deployed on network . In some embodiments a plurality of appliances may be deployed on network . In one embodiment a first appliance communicates with a second appliance . In other embodiments the appliance could be a part of any client or server on the same or different network as the client . One or more appliances may be located at any point in the network or network communications path between a client and a server .

In some embodiments the appliance comprises any of the network devices manufactured by Citrix Systems Inc. of Ft. Lauderdale Fla. referred to as Citrix NetScaler devices. In other embodiments the appliance includes any of the product embodiments referred to as WebAccelerator and BigIP manufactured by F5 Networks Inc. of Seattle Wash. In another embodiment the appliance includes any of the DX acceleration device platforms and or the SSL VPN series of devices such as SA 700 SA 2000 SA 4000 and SA 6000 devices manufactured by Juniper Networks Inc. of Sunnyvale Calif. In yet another embodiment the appliance includes any application acceleration and or security related appliances and or software manufactured by Cisco Systems Inc. of San Jose Calif. such as the Cisco ACE Application Control Engine Module service software and network modules and Cisco AVS Series Application Velocity System.

In one embodiment the system may include multiple logically grouped servers . In these embodiments the logical group of servers may be referred to as a server farm . In some of these embodiments the serves may be geographically dispersed. In some cases a farm may be administered as a single entity. In other embodiments the server farm comprises a plurality of server farms . In one embodiment the server farm executes one or more applications on behalf of one or more clients .

The servers within each farm can be heterogeneous. One or more of the servers can operate according to one type of operating system platform e.g. WINDOWS NT manufactured by Microsoft Corp. of Redmond Wash. while one or more of the other servers can operate on according to another type of operating system platform e.g. Unix or Linux . The servers of each farm do not need to be physically proximate to another server in the same farm . Thus the group of servers logically grouped as a farm may be interconnected using a wide area network WAN connection or medium area network MAN connection. For example a farm may include servers physically located in different continents or different regions of a continent country state city campus or room. Data transmission speeds between servers in the farm can be increased if the servers are connected using a local area network LAN connection or some form of direct connection.

Servers may be referred to as a file server application server web server proxy server or gateway server. In some embodiments a server may have the capacity to function as either an application server or as a master application server. In one embodiment a server may include an Active Directory. The clients may also be referred to as client nodes or endpoints. In some embodiments a client has the capacity to function as both a client node seeking access to applications on a server and as an application server providing access to hosted applications for other clients 

In some embodiments a client communicates with a server . In one embodiment the client communicates directly with one of the servers in a farm . In another embodiment the client executes a program neighborhood application to communicate with a server in a farm . In still another embodiment the server provides the functionality of a master node. In some embodiments the client communicates with the server in the farm through a network . Over the network the client can for example request execution of various applications hosted by the servers in the farm and receive output of the results of the application execution for display. In some embodiments only the master node provides the functionality for identifying and providing address information associated with a server hosting a requested application.

In one embodiment the server provides functionality of a web server. In another embodiment the server receives requests from the client forwards the requests to a second server and responds to the request by the client with a response to the request from the server . In still another embodiment the server acquires an enumeration of applications available to the client and address information associated with a server hosting an application identified by the enumeration of applications. In yet another embodiment the server presents the response to the request to the client using a web interface. In one embodiment the client communicates directly with the server to access the identified application. In another embodiment the client receives application output data such as display data generated by an execution of the identified application on the server .

Referring now to an embodiment of a network environment deploying multiple appliances is depicted. A first appliance may be deployed on a first network and a second appliance on a second network . For example a corporate enterprise may deploy a first appliance at a branch office and a second appliance at a data center. In another embodiment the first appliance and second appliance are deployed on the same network or network . For example a first appliance may be deployed for a first server farm and a second appliance may be deployed for a second server farm . In another example a first appliance may be deployed at a first branch office while the second appliance is deployed at a second branch office . In some embodiments the first appliance and second appliance work in cooperation or in conjunction with each other to accelerate network traffic or the delivery of application and data between a client and a server

Referring now to another embodiment of a network environment deploying the appliance with one or more other types of appliances such as between one or more WAN optimization appliance is depicted. For example a first WAN optimization appliance is shown between networks and and a second WAN optimization appliance may be deployed between the appliance and one or more servers . By way of example a corporate enterprise may deploy a first WAN optimization appliance at a branch office and a second WAN optimization appliance at a data center. In some embodiments the appliance may be located on network . In other embodiments the appliance may be located on network . In some embodiments the appliance may be located on network or network . In one embodiment the appliance and are on the same network. In another embodiment the appliance and are on different networks. In another example a first WAN optimization appliance may be deployed for a first server farm and a second WAN optimization appliance for a second server farm .

In one embodiment the appliance is a device for accelerating optimizing or otherwise improving the performance operation or quality of service of any type and form of network traffic such as traffic to and or from a WAN connection. In some embodiments the appliance is a performance enhancing proxy. In other embodiments the appliance is any type and form of WAN optimization or acceleration device sometimes also referred to as a WAN optimization controller. In one embodiment the appliance is any of the product embodiments referred to as WANScaler manufactured by Citrix Systems Inc. of Ft. Lauderdale Fla. In other embodiments the appliance includes any of the product embodiments referred to as BIG IP link controller and WANjet manufactured by F5 Networks Inc. of Seattle Wash. In another embodiment the appliance includes any of the WX and WXC WAN acceleration device platforms manufactured by Juniper Networks Inc. of Sunnyvale Calif. In some embodiments the appliance includes any of the steelhead line of WAN optimization appliances manufactured by Riverbed Technology of San Francisco Calif.

In other embodiments the appliance includes any of the WAN related devices manufactured by Expand Networks Inc. of Roseland N.J. In one embodiment the appliance includes any of the WAN related appliances manufactured by Packeteer Inc. of Cupertino Calif. such as the PacketShaper iShared and SkyX product embodiments provided by Packeteer. In yet another embodiment the appliance includes any WAN related appliances and or software manufactured by Cisco Systems Inc. of San Jose Calif. such as the Cisco Wide Area Network Application Services software and network modules and Wide Area Network engine appliances.

In one embodiment the appliance provides application and data acceleration services for branch office or remote offices. In one embodiment the appliance includes optimization of Wide Area File Services WAFS . In another embodiment the appliance accelerates the delivery of files such as via the Common Internet File System CIFS protocol. In other embodiments the appliance provides caching in memory and or storage to accelerate delivery of applications and data. In one embodiment the appliance provides compression of network traffic at any level of the network stack or at any protocol or network layer. In another embodiment the appliance provides transport layer protocol optimizations flow control performance enhancements or modifications and or management to accelerate delivery of applications and data over a WAN connection. For example in one embodiment the appliance provides Transport Control Protocol TCP optimizations. In other embodiments the appliance provides optimizations flow control performance enhancements or modifications and or management for any session or application layer protocol.

In another embodiment the appliance encoded any type and form of data or information into custom or standard TCP and or IP header fields or option fields of network packet to announce presence functionality or capability to another appliance . In another embodiment an appliance may communicate with another appliance using data encoded in both TCP and or IP header fields or options. For example the appliance may use TCP option s or IP header fields or options to communicate one or more parameters to be used by the appliances in performing functionality such as WAN acceleration or for working in conjunction with each other.

In some embodiments the appliance preserves any of the information encoded in TCP and or IP header and or option fields communicated between appliances and . For example the appliance may terminate a transport layer connection traversing the appliance such as a transport layer connection from between a client and a server traversing appliances and . In one embodiment the appliance identifies and preserves any encoded information in a transport layer packet transmitted by a first appliance via a first transport layer connection and communicates a transport layer packet with the encoded information to a second appliance via a second transport layer connection.

Referring now to a network environment for delivering and or operating a computing environment on a client is depicted. In some embodiments a server includes an application delivery system for delivering a computing environment or an application and or data file to one or more clients . In brief overview a client is in communication with a server via network and appliance . For example the client may reside in a remote office of a company e.g. a branch office and the server may reside at a corporate data center. The client comprises a client agent and a computing environment . The computing environment may execute or operate an application that accesses processes or uses a data file. The computing environment application and or data file may be delivered via the appliance and or the server .

In some embodiments the appliance accelerates delivery of a computing environment or any portion thereof to a client . In one embodiment the appliance accelerates the delivery of the computing environment by the application delivery system . For example the embodiments described herein may be used to accelerate delivery of a streaming application and data file processable by the application from a central corporate data center to a remote user location such as a branch office of the company. In another embodiment the appliance accelerates transport layer traffic between a client and a server . The appliance may provide acceleration techniques for accelerating any transport layer payload from a server to a client such as 1 transport layer connection pooling 2 transport layer connection multiplexing 3 transport control protocol buffering 4 compression and 5 caching. In some embodiments the appliance provides load balancing of servers in responding to requests from clients . In other embodiments the appliance acts as a proxy or access server to provide access to the one or more servers . In another embodiment the appliance provides a secure virtual private network connection from a first network of the client to the second network of the server such as an SSL VPN connection. It yet other embodiments the appliance provides application firewall security control and management of the connection and communications between a client and a server .

In some embodiments the application delivery management system provides application delivery techniques to deliver a computing environment to a desktop of a user remote or otherwise based on a plurality of execution methods and based on any authentication and authorization policies applied via a policy engine . With these techniques a remote user may obtain a computing environment and access to server stored applications and data files from any network connected device . In one embodiment the application delivery system may reside or execute on a server . In another embodiment the application delivery system may reside or execute on a plurality of servers . In some embodiments the application delivery system may execute in a server farm . In one embodiment the server executing the application delivery system may also store or provide the application and data file. In another embodiment a first set of one or more servers may execute the application delivery system and a different server may store or provide the application and data file. In some embodiments each of the application delivery system the application and data file may reside or be located on different servers. In yet another embodiment any portion of the application delivery system may reside execute or be stored on or distributed to the appliance or a plurality of appliances.

The client may include a computing environment for executing an application that uses or processes a data file. The client via networks and appliance may request an application and data file from the server . In one embodiment the appliance may forward a request from the client to the server . For example the client may not have the application and data file stored or accessible locally. In response to the request the application delivery system and or server may deliver the application and data file to the client . For example in one embodiment the server may transmit the application as an application stream to operate in computing environment on client .

In some embodiments the application delivery system comprises any portion of the Citrix Access Suite by Citrix Systems Inc. such as the MetaFrame or Citrix Presentation Server and or any of the Microsoft Windows Terminal Services manufactured by the Microsoft Corporation. In one embodiment the application delivery system may deliver one or more applications to clients or users via a remote display protocol or otherwise via remote based or server based computing. In another embodiment the application delivery system may deliver one or more applications to clients or users via steaming of the application.

In one embodiment the application delivery system includes a policy engine for controlling and managing the access to selection of application execution methods and the delivery of applications. In some embodiments the policy engine determines the one or more applications a user or client may access. In another embodiment the policy engine determines how the application should be delivered to the user or client e.g. the method of execution. In some embodiments the application delivery system provides a plurality of delivery techniques from which to select a method of application execution such as a server based computing streaming or delivering the application locally to the client for local execution.

In one embodiment a client requests execution of an application program and the application delivery system comprising a server selects a method of executing the application program. In some embodiments the server receives credentials from the client . In another embodiment the server receives a request for an enumeration of available applications from the client . In one embodiment in response to the request or receipt of credentials the application delivery system enumerates a plurality of application programs available to the client . The application delivery system receives a request to execute an enumerated application. The application delivery system selects one of a predetermined number of methods for executing the enumerated application for example responsive to a policy of a policy engine. The application delivery system may select a method of execution of the application enabling the client to receive application output data generated by execution of the application program on a server . The application delivery system may select a method of execution of the application enabling the local machine to execute the application program locally after retrieving a plurality of application files comprising the application. In yet another embodiment the application delivery system may select a method of execution of the application to stream the application via the network to the client .

A client may execute operate or otherwise provide an application which can be any type and or form of software program or executable instructions such as any type and or form of web browser web based client client server application a thin client computing client an ActiveX control or a Java applet or any other type and or form of executable instructions capable of executing on client . In some embodiments the application may be a server based or a remote based application executed on behalf of the client on a server . In one embodiments the server may display output to the client using any thin client or remote display protocol such as the Independent Computing Architecture ICA protocol manufactured by Citrix Systems Inc. of Ft. Lauderdale Fla. or the Remote Desktop Protocol RDP manufactured by the Microsoft Corporation of Redmond Wash. The application can use any type of protocol and it can be for example an HTTP client an FTP client an Oscar client or a Telnet client. In other embodiments the application comprises any type of software related to VoIP communications such as a soft IP telephone. In further embodiments the application comprises any application related to real time data communications such as applications for streaming video and or audio.

In some embodiments the server or a server farm may be running one or more applications such as an application providing a thin client computing or remote display presentation application. In one embodiment the server or server farm executes as an application any portion of the Citrix Access Suite by Citrix Systems Inc. such as the MetaFrame or Citrix Presentation Server and or any of the Microsoft Windows Terminal Services manufactured by the Microsoft Corporation. In one embodiment the application is an ICA client developed by Citrix Systems Inc. of Fort Lauderdale Fla. In other embodiments the application includes a Remote Desktop RDP client developed by Microsoft Corporation of Redmond Wash. Also the server may run an application which for example may be an application server providing email services such as Microsoft Exchange manufactured by the Microsoft Corporation of Redmond Wash. a web or Internet server or a desktop sharing server or a collaboration server. In some embodiments any of the applications may comprise any type of hosted service or products such as GoToMeeting provided by Citrix Online Division Inc. of Santa Barbara Calif. WebEx provided by WebEx Inc. of Santa Clara Calif. or Microsoft Office Live Meeting provided by Microsoft Corporation of Redmond Wash.

Still referring to an embodiment of the network environment may include a monitoring server A. The monitoring server A may include any type and form performance monitoring service . The performance monitoring service may include monitoring measurement and or management software and or hardware including data collection aggregation analysis management and reporting. In one embodiment the performance monitoring service includes one or more monitoring agents . The monitoring agent includes any software hardware or combination thereof for performing monitoring measurement and data collection activities on a device such as a client server or an appliance . In some embodiments the monitoring agent includes any type and form of script such as Visual Basic script or Javascript. In one embodiment the monitoring agent executes transparently to any application and or user of the device. In some embodiments the monitoring agent is installed and operated unobtrusively to the application or client. In yet another embodiment the monitoring agent is installed and operated without any instrumentation for the application or device.

In some embodiments the monitoring agent monitors measures and collects data on a predetermined frequency. In other embodiments the monitoring agent monitors measures and collects data based upon detection of any type and form of event. For example the monitoring agent may collect data upon detection of a request for a web page or receipt of an HTTP response. In another example the monitoring agent may collect data upon detection of any user input events such as a mouse click. The monitoring agent may report or provide any monitored measured or collected data to the monitoring service . In one embodiment the monitoring agent transmits information to the monitoring service according to a schedule or a predetermined frequency. In another embodiment the monitoring agent transmits information to the monitoring service upon detection of an event.

In some embodiments the monitoring service and or monitoring agent performs monitoring and performance measurement of any network resource or network infrastructure element such as a client server server farm appliance appliance or network connection. In one embodiment the monitoring service and or monitoring agent performs monitoring and performance measurement of any transport layer connection such as a TCP or UDP connection. In another embodiment the monitoring service and or monitoring agent monitors and measures network latency. In yet one embodiment the monitoring service and or monitoring agent monitors and measures bandwidth utilization.

In other embodiments the monitoring service and or monitoring agent monitors and measures end user response times. In some embodiments the monitoring service performs monitoring and performance measurement of an application. In another embodiment the monitoring service and or monitoring agent performs monitoring and performance measurement of any session or connection to the application. In one embodiment the monitoring service and or monitoring agent monitors and measures performance of a browser. In another embodiment the monitoring service and or monitoring agent monitors and measures performance of HTTP based transactions. In some embodiments the monitoring service and or monitoring agent monitors and measures performance of a Voice over IP VoIP application or session. In other embodiments the monitoring service and or monitoring agent monitors and measures performance of a remote display protocol application such as an ICA client or RDP client. In yet another embodiment the monitoring service and or monitoring agent monitors and measures performance of any type and form of streaming media. In still a further embodiment the monitoring service and or monitoring agent monitors and measures performance of a hosted application or a Software As A Service SaaS delivery model.

In some embodiments the monitoring service and or monitoring agent performs monitoring and performance measurement of one or more transactions requests or responses related to application. In other embodiments the monitoring service and or monitoring agent monitors and measures any portion of an application layer stack such as any .NET or J2EE calls. In one embodiment the monitoring service and or monitoring agent monitors and measures database or SQL transactions. In yet another embodiment the monitoring service and or monitoring agent monitors and measures any method function or application programming interface API call.

In one embodiment the monitoring service and or monitoring agent performs monitoring and performance measurement of a delivery of application and or data from a server to a client via one or more appliances such as appliance and or appliance . In some embodiments the monitoring service and or monitoring agent monitors and measures performance of delivery of a virtualized application. In other embodiments the monitoring service and or monitoring agent monitors and measures performance of delivery of a streaming application. In another embodiment the monitoring service and or monitoring agent monitors and measures performance of delivery of a desktop application to a client and or the execution of the desktop application on the client. In another embodiment the monitoring service and or monitoring agent monitors and measures performance of a client server application.

In one embodiment the monitoring service and or monitoring agent is designed and constructed to provide application performance management for the application delivery system . For example the monitoring service and or monitoring agent may monitor measure and manage the performance of the delivery of applications via the Citrix Presentation Server. In this example the monitoring service and or monitoring agent monitors individual ICA sessions. The monitoring service and or monitoring agent may measure the total and per session system resource usage as well as application and networking performance. The monitoring service and or monitoring agent may identify the active servers for a given user and or user session. In some embodiments the monitoring service and or monitoring agent monitors back end connections between the application delivery system and an application and or database server. The monitoring service and or monitoring agent may measure network latency delay and volume per user session or ICA session.

In some embodiments the monitoring service and or monitoring agent measures and monitors memory usage for the application delivery system such as total memory usage per user session and or per process. In other embodiments the monitoring service and or monitoring agent measures and monitors CPU usage the application delivery system such as total CPU usage per user session and or per process. In another embodiments the monitoring service and or monitoring agent measures and monitors the time to log in to an application a server or the application delivery system such as Citrix Presentation Server. In one embodiment the monitoring service and or monitoring agent measures and monitors the duration a user is logged into an application a server or the application delivery system . In some embodiments the monitoring service and or monitoring agent measures and monitors active and inactive session counts for an application server or application delivery system session. In yet another embodiment the monitoring service and or monitoring agent measures and monitors user session latency.

In yet further embodiments the monitoring service and or monitoring agent measures and monitors measures and monitors any type and form of server metrics. In one embodiment the monitoring service and or monitoring agent measures and monitors metrics related to system memory CPU usage and disk storage. In another embodiment the monitoring service and or monitoring agent measures and monitors metrics related to page faults such as page faults per second. In other embodiments the monitoring service and or monitoring agent measures and monitors round trip time metrics. In yet another embodiment the monitoring service and or monitoring agent measures and monitors metrics related to application crashes errors and or hangs.

In some embodiments the monitoring service and monitoring agent includes any of the product embodiments referred to as EdgeSight manufactured by Citrix Systems Inc. of Ft. Lauderdale Fla. In another embodiment the performance monitoring service and or monitoring agent includes any portion of the product embodiments referred to as the TrueView product suite manufactured by the Symphoniq Corporation of Palo Alto Calif.

In one embodiment the performance monitoring service and or monitoring agent includes any portion of the product embodiments referred to as the TeaLeaf CX product suite manufactured by the TeaLeaf Technology Inc. of San Francisco Calif. In other embodiments the performance monitoring service and or monitoring agent includes any portion of the business service management products such as the BMC Performance Manager and Patrol products manufactured by BMC Software Inc. of Houston Tex.

The client server and appliance may be deployed as and or executed on any type and form of computing device such as a computer network device or appliance capable of communicating on any type and form of network and performing the operations described herein. depict block diagrams of a computing device useful for practicing an embodiment of the client server or appliance . As shown in each computing device includes a central processing unit and a main memory unit . As shown in a computing device may include a visual display device a keyboard and or a pointing device such as a mouse. Each computing device may also include additional optional elements such as one or more input output devices generally referred to using reference numeral and a cache memory in communication with the central processing unit .

The central processing unit is any logic circuitry that responds to and processes instructions fetched from the main memory unit . In many embodiments the central processing unit is provided by a microprocessor unit such as those manufactured by Intel Corporation of Mountain View Calif. those manufactured by Motorola Corporation of Schaumburg Ill. those manufactured by Transmeta Corporation of Santa Clara Calif. the RS 6000 processor those manufactured by International Business Machines of White Plains N.Y. or those manufactured by Advanced Micro Devices of Sunnyvale Calif. The computing device may be based on any of these processors or any other processor capable of operating as described herein.

Main memory unit may be one or more memory chips capable of storing data and allowing any storage location to be directly accessed by the microprocessor such as Static random access memory SRAM Burst SRAM or SynchBurst SRAM BSRAM Dynamic random access memory DRAM Fast Page Mode DRAM FPM DRAM Enhanced DRAM EDRAM Extended Data Output RAM EDO RAM Extended Data Output DRAM EDO DRAM Burst Extended Data Output DRAM BEDO DRAM Enhanced DRAM EDRAM synchronous DRAM SDRAM JEDEC SRAM PC100 SDRAM Double Data Rate SDRAM DDR SDRAM Enhanced SDRAM ESDRAM SyncLink DRAM SLDRAM Direct Rambus DRAM DRDRAM or Ferroelectric RAM FRAM . The main memory may be based on any of the above described memory chips or any other available memory chips capable of operating as described herein. In the embodiment shown in the processor communicates with main memory via a system bus described in more detail below . depicts an embodiment of a computing device in which the processor communicates directly with main memory via a memory port . For example in the main memory may be DRDRAM.

The computing device may support any suitable installation device such as a floppy disk drive for receiving floppy disks such as 3.5 inch 5.25 inch disks or ZIP disks a CD ROM drive a CD R RW drive a DVD ROM drive tape drives of various formats USB device hard drive or any other device suitable for installing software and programs such as any client agent or portion thereof. The computing device may further comprise a storage device such as one or more hard disk drives or redundant arrays of independent disks for storing an operating system and other related software and for storing application software programs such as any program related to the client agent . Optionally any of the installation devices could also be used as the storage device . Additionally the operating system and the software can be run from a bootable medium for example a bootable CD such as KNOPPIX a bootable CD for GNU Linux that is available as a GNU Linux distribution from knoppix.net.

Furthermore the computing device may include a network interface to interface to a Local Area Network LAN Wide Area Network WAN or the Internet through a variety of connections including but not limited to standard telephone lines LAN or WAN links e.g. 802.11 T1 T3 56 kb X.25 broadband connections e.g. ISDN Frame Relay ATM wireless connections or some combination of any or all of the above. The network interface may comprise a built in network adapter network interface card PCMCIA network card card bus network adapter wireless network adapter USB network adapter modem or any other device suitable for interfacing the computing device to any type of network capable of communication and performing the operations described herein.

A wide variety of I O devices may be present in the computing device . Input devices include keyboards mice trackpads trackballs microphones and drawing tablets. Output devices include video displays speakers inkjet printers laser printers and dye sublimation printers. The I O devices may be controlled by an I O controller as shown in . The I O controller may control one or more I O devices such as a keyboard and a pointing device e.g. a mouse or optical pen. Furthermore an I O device may also provide storage and or an installation medium for the computing device . In still other embodiments the computing device may provide USB connections to receive handheld USB storage devices such as the USB Flash Drive line of devices manufactured by Twintech Industry Inc. of Los Alamitos Calif.

In some embodiments the computing device may comprise or be connected to multiple display devices which each may be of the same or different type and or form. As such any of the I O devices and or the I O controller may comprise any type and or form of suitable hardware software or combination of hardware and software to support enable or provide for the connection and use of multiple display devices by the computing device . For example the computing device may include any type and or form of video adapter video card driver and or library to interface communicate connect or otherwise use the display devices . In one embodiment a video adapter may comprise multiple connectors to interface to multiple display devices . In other embodiments the computing device may include multiple video adapters with each video adapter connected to one or more of the display devices . In some embodiments any portion of the operating system of the computing device may be configured for using multiple displays . In other embodiments one or more of the display devices may be provided by one or more other computing devices such as computing devices and connected to the computing device for example via a network. These embodiments may include any type of software designed and constructed to use another computer s display device as a second display device for the computing device . One ordinarily skilled in the art will recognize and appreciate the various ways and embodiments that a computing device may be configured to have multiple display devices 

In further embodiments an I O device may be a bridge between the system bus and an external communication bus such as a USB bus an Apple Desktop Bus an RS 232 serial connection a SCSI bus a FireWire bus a FireWire 800 bus an Ethernet bus an AppleTalk bus a Gigabit Ethernet bus an Asynchronous Transfer Mode bus a HIPPI bus a Super HIPPI bus a SerialPlus bus a SCl LAMP bus a FibreChannel bus or a Serial Attached small computer system interface bus.

A computing device of the sort depicted in typically operate under the control of operating systems which control scheduling of tasks and access to system resources. The computing device can be running any operating system such as any of the versions of the Microsoft Windows operating systems the different releases of the Unix and Linux operating systems any version of the Mac OS for Macintosh computers any embedded operating system any real time operating system any open source operating system any proprietary operating system any operating systems for mobile computing devices or any other operating system capable of running on the computing device and performing the operations described herein. Typical operating systems include WINDOWS 3.x WINDOWS 95 WINDOWS 98 WINDOWS 2000 WINDOWS NT 3.51 WINDOWS NT 4.0 WINDOWS CE and WINDOWS XP all of which are manufactured by Microsoft Corporation of Redmond Wash. MacOS manufactured by Apple Computer of Cupertino Calif. OS 2 manufactured by International Business Machines of Armonk N.Y. and Linux a freely available operating system distributed by Caldera Corp. of Salt Lake City Utah or any type and or form of a Unix operating system among others.

In other embodiments the computing device may have different processors operating systems and input devices consistent with the device. For example in one embodiment the computer is a Treo 180 270 1060 600 or 650 smart phone manufactured by Palm Inc. In this embodiment the Treo smart phone is operated under the control of the PalmOS operating system and includes a stylus input device as well as a five way navigator device. Moreover the computing device can be any workstation desktop computer laptop or notebook computer server handheld computer mobile telephone any other computer or other form of computing or telecommunications device that is capable of communication and that has sufficient processor power and memory capacity to perform the operations described herein.

As shown in the computing device may comprise multiple processors and may provide functionality for simultaneous execution of instructions or for simultaneous execution of one instruction on more than one piece of data. In some embodiments the computing device may comprise a parallel processor with one or more cores. In one of these embodiments the computing device is a shared memory parallel device with multiple processors and or multiple processor cores accessing all available memory as a single global address space. In another of these embodiments the computing device is a distributed memory parallel device with multiple processors each accessing local memory only. In still another of these embodiments the computing device has both some memory which is shared and some memory which can only be accessed by particular processors or subsets of processors. In still even another of these embodiments the computing device such as a multi core microprocessor combines two or more independent processors into a single package often a single integrated circuit IC . In yet another of these embodiments the computing device includes a chip having a CELL BROADBAND ENGINE architecture and including a Power processor element and a plurality of synergistic processing elements the Power processor element and the plurality of synergistic processing elements linked together by an internal high speed bus which may be referred to as an element interconnect bus.

In some embodiments the processors provide functionality for execution of a single instruction simultaneously on multiple pieces of data SIMD . In other embodiments the processors provide functionality for execution of multiple instructions simultaneously on multiple pieces of data MIMD . In still other embodiments the processor may use any combination of SIMD and MIMD cores in a single device.

In some embodiments the computing device may comprise a graphics processing unit. In one of these embodiments depicted in the computing device includes at least one central processing unit and at least one graphics processing unit. In another of these embodiments the computing device includes at least one parallel processing unit and at least one graphics processing unit. In still another of these embodiments the computing device includes a plurality of processing units of any type one of the plurality of processing units comprising a graphics processing unit.

In some embodiments a first computing device executes an application on behalf of a user of a client computing device . In other embodiments a computing device executes a virtual machine which provides an execution session within which applications execute on behalf of a user or a client computing devices . In one of these embodiments the execution session is a hosted desktop session. In another of these embodiments the computing device executes a terminal services session. The terminal services session may provide a hosted desktop environment. In still another of these embodiments the execution session provides access to a computing environment which may comprise one or more of an application a plurality of applications a desktop application and a desktop session in which one or more applications may execute.

Hardware layer provides the hardware elements upon which programs and services within kernel space and user space are executed. Hardware layer also provides the structures and elements which allow programs and services within kernel space and user space to communicate data both internally and externally with respect to appliance . As shown in the hardware layer includes a processing unit for executing software programs and services a memory for storing software and data network ports for transmitting and receiving data over a network and an encryption processor for performing functions related to Secure Sockets Layer processing of data transmitted and received over the network. In some embodiments the central processing unit may perform the functions of the encryption processor in a single processor. Additionally the hardware layer may comprise multiple processors for each of the processing unit and the encryption processor . The processor may include any of the processors described above in connection with . For example in one embodiment the appliance comprises a first processor and a second processor . In other embodiments the processor or comprises a multi core processor.

Although the hardware layer of appliance is generally illustrated with an encryption processor processor may be a processor for performing functions related to any encryption protocol such as the Secure Socket Layer SSL or Transport Layer Security TLS protocol. In some embodiments the processor may be a general purpose processor GPP and in further embodiments may have executable instructions for performing processing of any security related protocol.

Although the hardware layer of appliance is illustrated with certain elements in the hardware portions or components of appliance may comprise any type and form of elements hardware or software of a computing device such as the computing device illustrated and discussed herein in conjunction with . In some embodiments the appliance may comprise a server gateway router switch bridge or other type of computing or network device and have any hardware and or software elements associated therewith.

The operating system of appliance allocates manages or otherwise segregates the available system memory into kernel space and user space . In example software architecture the operating system may be any type and or form of Unix operating system although the invention is not so limited. As such the appliance can be running any operating system such as any of the versions of the Microsoft Windows operating systems the different releases of the Unix and Linux operating systems any version of the Mac OS for Macintosh computers any embedded operating system any network operating system any real time operating system any open source operating system any proprietary operating system any operating systems for mobile computing devices or network devices or any other operating system capable of running on the appliance and performing the operations described herein.

The kernel space is reserved for running the kernel including any device drivers kernel extensions or other kernel related software. As known to those skilled in the art the kernel is the core of the operating system and provides access control and management of resources and hardware related elements of the application . In accordance with an embodiment of the appliance the kernel space also includes a number of network services or processes working in conjunction with a cache manager sometimes also referred to as the integrated cache the benefits of which are described in detail further herein. Additionally the embodiment of the kernel will depend on the embodiment of the operating system installed configured or otherwise used by the device .

In one embodiment the device comprises one network stack such as a TCP IP based stack for communicating with the client and or the server . In one embodiment the network stack is used to communicate with a first network such as network and a second network . In some embodiments the device terminates a first transport layer connection such as a TCP connection of a client and establishes a second transport layer connection to a server for use by the client e.g. the second transport layer connection is terminated at the appliance and the server . The first and second transport layer connections may be established via a single network stack . In other embodiments the device may comprise multiple network stacks for example and and the first transport layer connection may be established or terminated at one network stack and the second transport layer connection on the second network stack . For example one network stack may be for receiving and transmitting network packet on a first network and another network stack for receiving and transmitting network packets on a second network. In one embodiment the network stack comprises a buffer for queuing one or more network packets for transmission by the appliance .

As shown in the kernel space includes the cache manager a high speed layer 2 7 integrated packet engine an encryption engine a policy engine and multi protocol compression logic . Running these components or processes and in kernel space or kernel mode instead of the user space improves the performance of each of these components alone and in combination. Kernel operation means that these components or processes and run in the core address space of the operating system of the device . For example running the encryption engine in kernel mode improves encryption performance by moving encryption and decryption operations to the kernel thereby reducing the number of transitions between the memory space or a kernel thread in kernel mode and the memory space or a thread in user mode. For example data obtained in kernel mode may not need to be passed or copied to a process or thread running in user mode such as from a kernel level data structure to a user level data structure. In another aspect the number of context switches between kernel mode and user mode are also reduced. Additionally synchronization of and communications between any of the components or processes and can be performed more efficiently in the kernel space .

In some embodiments any portion of the components and may run or operate in the kernel space while other portions of these components and may run or operate in user space . In one embodiment the appliance uses a kernel level data structure providing access to any portion of one or more network packets for example a network packet comprising a request from a client or a response from a server . In some embodiments the kernel level data structure may be obtained by the packet engine via a transport layer driver interface or filter to the network stack . The kernel level data structure may comprise any interface and or data accessible via the kernel space related to the network stack network traffic or packets received or transmitted by the network stack . In other embodiments the kernel level data structure may be used by any of the components or processes and to perform the desired operation of the component or process. In one embodiment a component and is running in kernel mode when using the kernel level data structure while in another embodiment the component and is running in user mode when using the kernel level data structure. In some embodiments the kernel level data structure may be copied or passed to a second kernel level data structure or any desired user level data structure.

The cache manager may comprise software hardware or any combination of software and hardware to provide cache access control and management of any type and form of content such as objects or dynamically generated objects served by the originating servers . The data objects or content processed and stored by the cache manager may comprise data in any format such as a markup language or communicated via any protocol. In some embodiments the cache manager duplicates original data stored elsewhere or data previously computed generated or transmitted in which the original data may need longer access time to fetch compute or otherwise obtain relative to reading a cache memory element. Once the data is stored in the cache memory element future use can be made by accessing the cached copy rather than refetching or recomputing the original data thereby reducing the access time. In some embodiments the cache memory element may comprise a data object in memory of device . In other embodiments the cache memory element may comprise memory having a faster access time than memory . In another embodiment the cache memory element may comprise any type and form of storage element of the device such as a portion of a hard disk. In some embodiments the processing unit may provide cache memory for use by the cache manager . In yet further embodiments the cache manager may use any portion and combination of memory storage or the processing unit for caching data objects and other content.

Furthermore the cache manager includes any logic functions rules or operations to perform any embodiments of the techniques of the appliance described herein. For example the cache manager includes logic or functionality to invalidate objects based on the expiration of an invalidation time period or upon receipt of an invalidation command from a client or server . In some embodiments the cache manager may operate as a program service process or task executing in the kernel space and in other embodiments in the user space . In one embodiment a first portion of the cache manager executes in the user space while a second portion executes in the kernel space . In some embodiments the cache manager can comprise any type of general purpose processor GPP or any other type of integrated circuit such as a Field Programmable Gate Array FPGA Programmable Logic Device PLD or Application Specific Integrated Circuit ASIC .

The policy engine may include for example an intelligent statistical engine or other programmable application s . In one embodiment the policy engine provides a configuration mechanism to allow a user to identify specify define or configure a caching policy. Policy engine in some embodiments also has access to memory to support data structures such as lookup tables or hash tables to enable user selected caching policy decisions. In other embodiments the policy engine may comprise any logic rules functions or operations to determine and provide access control and management of objects data or content being cached by the appliance in addition to access control and management of security network traffic network access compression or any other function or operation performed by the appliance . Further examples of specific caching policies are further described herein.

The encryption engine comprises any logic business rules functions or operations for handling the processing of any security related protocol such as SSL or TLS or any function related thereto. For example the encryption engine encrypts and decrypts network packets or any portion thereof communicated via the appliance . The encryption engine may also setup or establish SSL or TLS connections on behalf of the client server or appliance . As such the encryption engine provides offloading and acceleration of SSL processing. In one embodiment the encryption engine uses a tunneling protocol to provide a virtual private network between a client and a server . In some embodiments the encryption engine is in communication with the Encryption processor . In other embodiments the encryption engine comprises executable instructions running on the Encryption processor .

The multi protocol compression engine comprises any logic business rules function or operations for compressing one or more protocols of a network packet such as any of the protocols used by the network stack of the device . In one embodiment multi protocol compression engine compresses bi directionally between clients and servers any TCP IP based protocol including Messaging Application Programming Interface MAPI email File Transfer Protocol FTP HyperText Transfer Protocol HTTP Common Internet File System CIFS protocol file transfer Independent Computing Architecture ICA protocol Remote Desktop Protocol RDP Wireless Application Protocol WAP Mobile IP protocol and Voice Over IP VoIP protocol. In other embodiments multi protocol compression engine provides compression of Hypertext Markup Language HTML based protocols and in some embodiments provides compression of any markup languages such as the Extensible Markup Language XML . In one embodiment the multi protocol compression engine provides compression of any high performance protocol such as any protocol designed for appliance to appliance communications. In another embodiment the multi protocol compression engine compresses any payload of or any communication using a modified transport control protocol such as Transaction TCP T TCP TCP with selection acknowledgements TCP SACK TCP with large windows TCP LW a congestion prediction protocol such as the TCP Vegas protocol and a TCP spoofing protocol.

As such the multi protocol compression engine accelerates performance for users accessing applications via desktop clients e.g. Microsoft Outlook and non Web thin clients such as any client launched by popular enterprise applications like Oracle SAP and Siebel and even mobile clients such as the Pocket PC. In some embodiments the multi protocol compression engine by executing in the kernel mode and integrating with packet processing engine accessing the network stack is able to compress any of the protocols carried by the TCP IP protocol such as any application layer protocol.

High speed layer 2 7 integrated packet engine also generally referred to as a packet processing engine or packet engine is responsible for managing the kernel level processing of packets received and transmitted by appliance via network ports . The high speed layer 2 7 integrated packet engine may comprise a buffer for queuing one or more network packets during processing such as for receipt of a network packet or transmission of a network packet. Additionally the high speed layer 2 7 integrated packet engine is in communication with one or more network stacks to send and receive network packets via network ports . The high speed layer 2 7 integrated packet engine works in conjunction with encryption engine cache manager policy engine and multi protocol compression logic . In particular encryption engine is configured to perform SSL processing of packets policy engine is configured to perform functions related to traffic management such as request level content switching and request level cache redirection and multi protocol compression logic is configured to perform functions related to compression and decompression of data.

The high speed layer 2 7 integrated packet engine includes a packet processing timer . In one embodiment the packet processing timer provides one or more time intervals to trigger the processing of incoming i.e. received or outgoing i.e. transmitted network packets. In some embodiments the high speed layer 2 7 integrated packet engine processes network packets responsive to the timer . The packet processing timer provides any type and form of signal to the packet engine to notify trigger or communicate a time related event interval or occurrence. In many embodiments the packet processing timer operates in the order of milliseconds such as for example 100 ms 50 ms or 25 ms. For example in some embodiments the packet processing timer provides time intervals or otherwise causes a network packet to be processed by the high speed layer 2 7 integrated packet engine at a 10 ms time interval while in other embodiments at a 5 ms time interval and still yet in further embodiments as short as a 3 2 or 1 ms time interval. The high speed layer 2 7 integrated packet engine may be interfaced integrated or in communication with the encryption engine cache manager policy engine and multi protocol compression engine during operation. As such any of the logic functions or operations of the encryption engine cache manager policy engine and multi protocol compression logic may be performed responsive to the packet processing timer and or the packet engine . Therefore any of the logic functions or operations of the encryption engine cache manager policy engine and multi protocol compression logic may be performed at the granularity of time intervals provided via the packet processing timer for example at a time interval of less than or equal to 10 ms. For example in one embodiment the cache manager may perform invalidation of any cached objects responsive to the high speed layer 2 7 integrated packet engine and or the packet processing timer . In another embodiment the expiry or invalidation time of a cached object can be set to the same order of granularity as the time interval of the packet processing timer such as at every 10 ms.

In contrast to kernel space user space is the memory area or portion of the operating system used by user mode applications or programs otherwise running in user mode. A user mode application may not access kernel space directly and uses service calls in order to access kernel services. As shown in user space of appliance includes a graphical user interface GUI a command line interface CLI shell services health monitoring program and daemon services . GUI and CLI provide a means by which a system administrator or other user can interact with and control the operation of appliance such as via the operating system of the appliance . The GUI or CLI can comprise code running in user space or kernel space . The GUI may be any type and form of graphical user interface and may be presented via text graphical or otherwise by any type of program or application such as a browser. The CLI may be any type and form of command line or text based interface such as a command line provided by the operating system. For example the CLI may comprise a shell which is a tool to enable users to interact with the operating system. In some embodiments the CLI may be provided via a bash csh tcsh or ksh type shell. The shell services comprises the programs services tasks processes or executable instructions to support interaction with the appliance or operating system by a user via the GUI and or CLI .

Health monitoring program is used to monitor check report and ensure that network systems are functioning properly and that users are receiving requested content over a network. Health monitoring program comprises one or more programs services tasks processes or executable instructions to provide logic rules functions or operations for monitoring any activity of the appliance . In some embodiments the health monitoring program intercepts and inspects any network traffic passed via the appliance . In other embodiments the health monitoring program interfaces by any suitable means and or mechanisms with one or more of the following the encryption engine cache manager policy engine multi protocol compression logic packet engine daemon services and shell services . As such the health monitoring program may call any application programming interface API to determine a state status or health of any portion of the appliance . For example the health monitoring program may ping or send a status inquiry on a periodic basis to check if a program process service or task is active and currently running. In another example the health monitoring program may check any status error or history logs provided by any program process service or task to determine any condition status or error with any portion of the appliance .

Daemon services are programs that run continuously or in the background and handle periodic service requests received by appliance . In some embodiments a daemon service may forward the requests to other programs or processes such as another daemon service as appropriate. As known to those skilled in the art a daemon service may run unattended to perform continuous or periodic system wide functions such as network control or to perform any desired task. In some embodiments one or more daemon services run in the user space while in other embodiments one or more daemon services run in the kernel space.

Referring now to another embodiment of the appliance is depicted. In brief overview the appliance provides one or more of the following services functionality or operations SSL VPN connectivity switching load balancing Domain Name Service resolution acceleration and an application firewall for communications between one or more clients and one or more servers . Each of the servers may provide one or more network related services referred to as services . For example a server may provide an http service . The appliance comprises one or more virtual servers or virtual internet protocol servers referred to as a vServer VIP server or just VIP also referred herein as vServer . The vServer receives intercepts or otherwise processes communications between a client and a server in accordance with the configuration and operations of the appliance .

The vServer may comprise software hardware or any combination of software and hardware. The vServer may comprise any type and form of program service task process or executable instructions operating in user mode kernel mode or any combination thereof in the appliance . The vServer includes any logic functions rules or operations to perform any embodiments of the techniques described herein such as SSL VPN switching load balancing Domain Name Service resolution acceleration and an application firewall . In some embodiments the vServer establishes a connection to a service of a server . The service may comprise any program application process task or set of executable instructions capable of connecting to and communicating to the appliance client or vServer . For example the service may comprise a web server http server ftp email or database server. In some embodiments the service is a daemon process or network driver for listening receiving and or sending communications for an application such as email database or an enterprise application. In some embodiments the service may communicate on a specific IP address or IP address and port.

In some embodiments the vServer applies one or more policies of the policy engine to network communications between the client and server . In one embodiment the policies are associated with a vServer . In another embodiment the policies are based on a user or a group of users. In yet another embodiment a policy is global and applies to one or more vServers and any user or group of users communicating via the appliance . In some embodiments the policies of the policy engine have conditions upon which the policy is applied based on any content of the communication such as internet protocol address port protocol type header or fields in a packet or the context of the communication such as user group of the user vServer transport layer connection and or identification or attributes of the client or server .

In other embodiments the appliance communicates or interfaces with the policy engine to determine authentication and or authorization of a remote user or a remote client to access the computing environment application and or data file from a server . In another embodiment the appliance communicates or interfaces with the policy engine to determine authentication and or authorization of a remote user or a remote client to have the application delivery system deliver one or more of the computing environment application and or data file. In yet another embodiment the appliance establishes a VPN or SSL VPN connection based on the policy engine s authentication and or authorization of a remote user or a remote client In one embodiment the appliance controls the flow of network traffic and communication sessions based on policies of the policy engine . For example the appliance may control the access to a computing environment application or data file based on the policy engine .

In some embodiments the vServer establishes a transport layer connection such as a TCP or UDP connection with a client via the client agent . In one embodiment the vServer listens for and receives communications from the client . In other embodiments the vServer establishes a transport layer connection such as a TCP or UDP connection with a client server . In one embodiment the vServer establishes the transport layer connection to an internet protocol address and port of a server running on the server . In another embodiment the vServer associates a first transport layer connection to a client with a second transport layer connection to the server . In some embodiments a vServer establishes a pool of transport layer connections to a server and multiplexes client requests via the pooled transport layer connections.

In some embodiments the appliance provides a SSL VPN connection between a client and a server . For example a client on a first network requests to establish a connection to a server on a second network . In some embodiments the second network is not routable from the first network . In other embodiments the client is on a public network and the server is on a private network such as a corporate network. In one embodiment the client agent intercepts communications of the client on the first network encrypts the communications and transmits the communications via a first transport layer connection to the appliance . The appliance associates the first transport layer connection on the first network to a second transport layer connection to the server on the second network . The appliance receives the intercepted communication from the client agent decrypts the communications and transmits the communication to the server on the second network via the second transport layer connection. The second transport layer connection may be a pooled transport layer connection. As such the appliance provides an end to end secure transport layer connection for the client between the two networks .

In one embodiment the appliance hosts an intranet internet protocol or IntranetIP address of the client on the virtual private network . The client has a local network identifier such as an internet protocol IP address and or host name on the first network . When connected to the second network via the appliance the appliance establishes assigns or otherwise provides an IntranetIP address which is a network identifier such as IP address and or host name for the client on the second network . The appliance listens for and receives on the second or private network for any communications directed towards the client using the client s established IntranetIP . In one embodiment the appliance acts as or on behalf of the client on the second private network . For example in another embodiment a vServer listens for and responds to communications to the IntranetIP of the client . In some embodiments if a computing device on the second network transmits a request the appliance processes the request as if it were the client . For example the appliance may respond to a ping to the client s IntranetIP . In another example the appliance may establish a connection such as a TCP or UDP connection with computing device on the second network requesting a connection with the client s IntranetIP .

In some embodiments the appliance provides one or more of the following acceleration techniques to communications between the client and server 1 compression 2 decompression 3 Transmission Control Protocol pooling 4 Transmission Control Protocol multiplexing 5 Transmission Control Protocol buffering and 6 caching. In one embodiment the appliance relieves servers of much of the processing load caused by repeatedly opening and closing transport layers connections to clients by opening one or more transport layer connections with each server and maintaining these connections to allow repeated data accesses by clients via the Internet. This technique is referred to herein as connection pooling .

In some embodiments in order to seamlessly splice communications from a client to a server via a pooled transport layer connection the appliance translates or multiplexes communications by modifying sequence number and acknowledgment numbers at the transport layer protocol level. This is referred to as connection multiplexing . In some embodiments no application layer protocol interaction may be required. For example in the case of an in bound packet that is a packet received from a client the source network address of the packet is changed to that of an output port of appliance and the destination network address is changed to that of the intended server. In the case of an outbound packet that is one received from a server the source network address is changed from that of the server to that of an output port of appliance and the destination address is changed from that of appliance to that of the requesting client . The sequence numbers and acknowledgment numbers of the packet are also translated to sequence numbers and acknowledgement numbers expected by the client on the appliance s transport layer connection to the client . In some embodiments the packet checksum of the transport layer protocol is recalculated to account for these translations.

In another embodiment the appliance provides switching or load balancing functionality for communications between the client and server . In some embodiments the appliance distributes traffic and directs client requests to a server based on layer 4 or application layer request data. In one embodiment although the network layer or layer 2 of the network packet identifies a destination server the appliance determines the server to distribute the network packet by application information and data carried as payload of the transport layer packet. In one embodiment the health monitoring programs of the appliance monitor the health of servers to determine the server for which to distribute a client s request. In some embodiments if the appliance detects a server is not available or has a load over a predetermined threshold the appliance can direct or distribute client requests to another server .

In some embodiments the appliance acts as a Domain Name Service DNS resolver or otherwise provides resolution of a DNS request from clients . In some embodiments the appliance intercepts a DNS request transmitted by the client . In one embodiment the appliance responds to a client s DNS request with an IP address of or hosted by the appliance . In this embodiment the client transmits network communication for the domain name to the appliance . In another embodiment the appliance responds to a client s DNS request with an IP address of or hosted by a second appliance . In some embodiments the appliance responds to a client s DNS request with an IP address of a server determined by the appliance .

In yet another embodiment the appliance provides application firewall functionality for communications between the client and server . In one embodiment the policy engine provides rules for detecting and blocking illegitimate requests. In some embodiments the application firewall protects against denial of service DoS attacks. In other embodiments the appliance inspects the content of intercepted requests to identify and block application based attacks. In some embodiments the rules policy engine comprises one or more application firewall or security control policies for providing protections against various classes and types of web or Internet based vulnerabilities such as one or more of the following 1 buffer overflow 2 CGI BIN parameter manipulation 3 form hidden field manipulation 4 forceful browsing 5 cookie or session poisoning 6 broken access control list ACLs or weak passwords 7 cross site scripting XSS 8 command injection 9 SQL injection 10 error triggering sensitive information leak 11 insecure use of cryptography 12 server misconfiguration 13 back doors and debug options 14 website defacement 15 platform or operating systems vulnerabilities and 16 zero day exploits. In an embodiment the application firewall provides HTML form field protection in the form of inspecting or analyzing the network communication for one or more of the following 1 some required fields are returned 2 no added field allowed 3 read only and hidden field enforcement 4 drop down list and radio button field conformance and 5 form field max length enforcement. In some embodiments the application firewall ensures cookies are not modified. In other embodiments the application firewall protects against forceful browsing by enforcing legal URLs.

In still yet other embodiments the application firewall protects any confidential information contained in the network communication. The application firewall may inspect or analyze any network communication in accordance with the rules or polices of the engine to identify any confidential information in any field of the network packet. In some embodiments the application firewall identifies in the network communication one or more occurrences of a credit card number password social security number name patient code contact information and age. The encoded portion of the network communication may comprise these occurrences or the confidential information. Based on these occurrences in one embodiment the application firewall may take a policy action on the network communication such as prevent transmission of the network communication. In another embodiment the application firewall may rewrite remove or otherwise mask such identified occurrence or confidential information.

Still referring to the appliance may include a performance monitoring agent as discussed above in conjunction with . In one embodiment the appliance receives the monitoring agent from the monitoring service or monitoring server as depicted in . In some embodiments the appliance stores the monitoring agent in storage such as disk for delivery to any client or server in communication with the appliance . For example in one embodiment the appliance transmits the monitoring agent to a client upon receiving a request to establish a transport layer connection. In other embodiments the appliance transmits the monitoring agent upon establishing the transport layer connection with the client . In another embodiment the appliance transmits the monitoring agent to the client upon intercepting or detecting a request for a web page. In yet another embodiment the appliance transmits the monitoring agent to a client or a server in response to a request from the monitoring server . In one embodiment the appliance transmits the monitoring agent to a second appliance or appliance .

In other embodiments the appliance executes the monitoring agent . In one embodiment the monitoring agent measures and monitors the performance of any application program process service task or thread executing on the appliance . For example the monitoring agent may monitor and measure performance and operation of vServers A N. In another embodiment the monitoring agent measures and monitors the performance of any transport layer connections of the appliance . In some embodiments the monitoring agent measures and monitors the performance of any user sessions traversing the appliance . In one embodiment the monitoring agent measures and monitors the performance of any virtual private network connections and or sessions traversing the appliance such as an SSL VPN session. In still further embodiments the monitoring agent measures and monitors the memory CPU and disk usage and performance of the appliance . In yet another embodiment the monitoring agent measures and monitors the performance of any acceleration technique performed by the appliance such as SSL offloading connection pooling and multiplexing caching and compression. In some embodiments the monitoring agent measures and monitors the performance of any load balancing and or content switching performed by the appliance . In other embodiments the monitoring agent measures and monitors the performance of application firewall protection and processing performed by the appliance .

Referring now to an embodiment of the client agent is depicted. The client includes a client agent for establishing and exchanging communications with the appliance and or server via a network . In brief overview the client operates on computing device having an operating system with a kernel mode and a user mode and a network stack with one or more layers . The client may have installed and or execute one or more applications. In some embodiments one or more applications may communicate via the network stack to a network . One of the applications such as a web browser may also include a first program . For example the first program may be used in some embodiments to install and or execute the client agent or any portion thereof. The client agent includes an interception mechanism or interceptor for intercepting network communications from the network stack from the one or more applications.

The network stack of the client may comprise any type and form of software or hardware or any combinations thereof for providing connectivity to and communications with a network. In one embodiment the network stack comprises a software implementation for a network protocol suite. The network stack may comprise one or more network layers such as any networks layers of the Open Systems Interconnection OSI communications model as those skilled in the art recognize and appreciate. As such the network stack may comprise any type and form of protocols for any of the following layers of the OSI model 1 physical link layer 2 data link layer 3 network layer 4 transport layer 5 session layer 6 presentation layer and 7 application layer. In one embodiment the network stack may comprise a transport control protocol TCP over the network layer protocol of the internet protocol IP generally referred to as TCP IP. In some embodiments the TCP IP protocol may be carried over the Ethernet protocol which may comprise any of the family of IEEE wide area network WAN or local area network LAN protocols such as those protocols covered by the IEEE 802.3. In some embodiments the network stack comprises any type and form of a wireless protocol such as IEEE 802.11 and or mobile internet protocol.

In view of a TCP IP based network any TCP IP based protocol may be used including Messaging Application Programming Interface MAPI email File Transfer Protocol FTP HyperText Transfer Protocol HTTP Common Internet File System CIFS protocol file transfer Independent Computing Architecture ICA protocol Remote Desktop Protocol RDP Wireless Application Protocol WAP Mobile IP protocol and Voice Over IP VoIP protocol. In another embodiment the network stack comprises any type and form of transport control protocol such as a modified transport control protocol for example a Transaction TCP T TCP TCP with selection acknowledgements TCP SACK TCP with large windows TCP LW a congestion prediction protocol such as the TCP Vegas protocol and a TCP spoofing protocol. In other embodiments any type and form of user datagram protocol UDP such as UDP over IP may be used by the network stack such as for voice communications or real time data communications.

Furthermore the network stack may include one or more network drivers supporting the one or more layers such as a TCP driver or a network layer driver. The network drivers may be included as part of the operating system of the computing device or as part of any network interface cards or other network access components of the computing device . In some embodiments any of the network drivers of the network stack may be customized modified or adapted to provide a custom or modified portion of the network stack in support of any of the techniques described herein. In other embodiments the acceleration program is designed and constructed to operate with or work in conjunction with the network stack installed or otherwise provided by the operating system of the client .

The network stack comprises any type and form of interfaces for receiving obtaining providing or otherwise accessing any information and data related to network communications of the client . In one embodiment an interface to the network stack comprises an application programming interface API . The interface may also comprise any function call hooking or filtering mechanism event or call back mechanism or any type of interfacing technique. The network stack via the interface may receive or provide any type and form of data structure such as an object related to functionality or operation of the network stack . For example the data structure may comprise information and data related to a network packet or one or more network packets. In some embodiments the data structure comprises a portion of the network packet processed at a protocol layer of the network stack such as a network packet of the transport layer. In some embodiments the data structure comprises a kernel level data structure while in other embodiments the data structure comprises a user mode data structure. A kernel level data structure may comprise a data structure obtained or related to a portion of the network stack operating in kernel mode or a network driver or other software running in kernel mode or any data structure obtained or received by a service process task thread or other executable instructions running or operating in kernel mode of the operating system.

Additionally some portions of the network stack may execute or operate in kernel mode for example the data link or network layer while other portions execute or operate in user mode such as an application layer of the network stack . For example a first portion of the network stack may provide user mode access to the network stack to an application while a second portion of the network stack provides access to a network. In some embodiments a first portion of the network stack may comprise one or more upper layers of the network stack such as any of layers 5 7. In other embodiments a second portion of the network stack comprises one or more lower layers such as any of layers 1 4. Each of the first portion and second portion of the network stack may comprise any portion of the network stack at any one or more network layers in user mode kernel mode or combinations thereof or at any portion of a network layer or interface point to a network layer or any portion of or interface point to the user mode and kernel mode .

The interceptor may comprise software hardware or any combination of software and hardware. In one embodiment the interceptor intercept a network communication at any point in the network stack and redirects or transmits the network communication to a destination desired managed or controlled by the interceptor or client agent . For example the interceptor may intercept a network communication of a network stack of a first network and transmit the network communication to the appliance for transmission on a second network . In some embodiments the interceptor comprises any type interceptor comprises a driver such as a network driver constructed and designed to interface and work with the network stack . In some embodiments the client agent and or interceptor operates at one or more layers of the network stack such as at the transport layer. In one embodiment the interceptor comprises a filter driver hooking mechanism or any form and type of suitable network driver interface that interfaces to the transport layer of the network stack such as via the transport driver interface TDI . In some embodiments the interceptor interfaces to a first protocol layer such as the transport layer and another protocol layer such as any layer above the transport protocol layer for example an application protocol layer. In one embodiment the interceptor may comprise a driver complying with the Network Driver Interface Specification NDIS or a NDIS driver. In another embodiment the interceptor may comprise a mini filter or a mini port driver. In one embodiment the interceptor or portion thereof operates in kernel mode . In another embodiment the interceptor or portion thereof operates in user mode . In some embodiments a portion of the interceptor operates in kernel mode while another portion of the interceptor operates in user mode . In other embodiments the client agent operates in user mode but interfaces via the interceptor to a kernel mode driver process service task or portion of the operating system such as to obtain a kernel level data structure . In further embodiments the interceptor is a user mode application or program such as application.

In one embodiment the interceptor intercepts any transport layer connection requests. In these embodiments the interceptor execute transport layer application programming interface API calls to set the destination information such as destination IP address and or port to a desired location for the location. In this manner the interceptor intercepts and redirects the transport layer connection to a IP address and port controlled or managed by the interceptor or client agent . In one embodiment the interceptor sets the destination information for the connection to a local IP address and port of the client on which the client agent is listening. For example the client agent may comprise a proxy service listening on a local IP address and port for redirected transport layer communications. In some embodiments the client agent then communicates the redirected transport layer communication to the appliance .

In some embodiments the interceptor intercepts a Domain Name Service DNS request. In one embodiment the client agent and or interceptor resolves the DNS request. In another embodiment the interceptor transmits the intercepted DNS request to the appliance for DNS resolution. In one embodiment the appliance resolves the DNS request and communicates the DNS response to the client agent . In some embodiments the appliance resolves the DNS request via another appliance or a DNS server . In yet another embodiment the client agent may comprise two agents and .

In one embodiment a first agent may comprise an interceptor operating at the network layer of the network stack . In some embodiments the first agent intercepts network layer requests such as Internet Control Message Protocol ICMP requests e.g. ping and traceroute . In other embodiments the second agent may operate at the transport layer and intercept transport layer communications. In some embodiments the first agent intercepts communications at one layer of the network stack and interfaces with or communicates the intercepted communication to the second agent .

The client agent and or interceptor may operate at or interface with a protocol layer in a manner transparent to any other protocol layer of the network stack . For example in one embodiment the interceptor operates or interfaces with the transport layer of the network stack transparently to any protocol layer below the transport layer such as the network layer and any protocol layer above the transport layer such as the session presentation or application layer protocols. This allows the other protocol layers of the network stack to operate as desired and without modification for using the interceptor . As such the client agent and or interceptor can interface with the transport layer to secure optimize accelerate route or load balance any communications provided via any protocol carried by the transport layer such as any application layer protocol over TCP IP.

Furthermore the client agent and or interceptor may operate at or interface with the network stack in a manner transparent to any application a user of the client and any other computing device such as a server in communications with the client . The client agent and or interceptor may be installed and or executed on the client in a manner without modification of an application. In some embodiments the user of the client or a computing device in communications with the client are not aware of the existence execution or operation of the client agent and or interceptor . As such in some embodiments the client agent and or interceptor is installed executed and or operated transparently to an application user of the client another computing device such as a server or any of the protocol layers above and or below the protocol layer interfaced to by the interceptor .

The client agent includes an acceleration program a streaming client a collection agent and or monitoring agent . In one embodiment the client agent comprises an Independent Computing Architecture ICA client or any portion thereof developed by Citrix Systems Inc. of Fort Lauderdale Fla. and is also referred to as an ICA client. In some embodiments the client comprises an application streaming client for streaming an application from a server to a client . In some embodiments the client agent comprises an acceleration program for accelerating communications between client and server . In another embodiment the client agent includes a collection agent for performing end point detection scanning and collecting end point information for the appliance and or server .

In some embodiments the acceleration program comprises a client side acceleration program for performing one or more acceleration techniques to accelerate enhance or otherwise improve a client s communications with and or access to a server such as accessing an application provided by a server . The logic functions and or operations of the executable instructions of the acceleration program may perform one or more of the following acceleration techniques 1 multi protocol compression 2 transport control protocol pooling 3 transport control protocol multiplexing 4 transport control protocol buffering and 5 caching via a cache manager. Additionally the acceleration program may perform encryption and or decryption of any communications received and or transmitted by the client . In some embodiments the acceleration program performs one or more of the acceleration techniques in an integrated manner or fashion. Additionally the acceleration program can perform compression on any of the protocols or multiple protocols carried as a payload of a network packet of the transport layer protocol. The streaming client comprises an application program process service task or executable instructions for receiving and executing a streamed application from a server . A server may stream one or more application data files to the streaming client for playing executing or otherwise causing to be executed the application on the client . In some embodiments the server transmits a set of compressed or packaged application data files to the streaming client . In some embodiments the plurality of application files are compressed and stored on a file server within an archive file such as a CAB ZIP SIT TAR JAR or other archive. In one embodiment the server decompresses unpackages or unarchives the application files and transmits the files to the client . In another embodiment the client decompresses unpackages or unarchives the application files. The streaming client dynamically installs the application or portion thereof and executes the application. In one embodiment the streaming client may be an executable program. In some embodiments the streaming client may be able to launch another executable program.

The collection agent comprises an application program process service task or executable instructions for identifying obtaining and or collecting information about the client . In some embodiments the appliance transmits the collection agent to the client or client agent . The collection agent may be configured according to one or more policies of the policy engine of the appliance. In other embodiments the collection agent transmits collected information on the client to the appliance . In one embodiment the policy engine of the appliance uses the collected information to determine and provide access authentication and authorization control of the client s connection to a network .

In one embodiment the collection agent comprises an end point detection and scanning mechanism which identifies and determines one or more attributes or characteristics of the client. For example the collection agent may identify and determine any one or more of the following client side attributes 1 the operating system an or a version of an operating system 2 a service pack of the operating system 3 a running service 4 a running process and 5 a file. The collection agent may also identify and determine the presence or versions of any one or more of the following on the client 1 antivirus software 2 personal firewall software 3 anti spam software and 4 internet security software. The policy engine may have one or more policies based on any one or more of the attributes or characteristics of the client or client side attributes.

In some embodiments the client agent includes a monitoring agent as discussed in conjunction with . The monitoring agent may be any type and form of script such as Visual Basic or Java script. In one embodiment the monitoring agent monitors and measures performance of any portion of the client agent . For example in some embodiments the monitoring agent monitors and measures performance of the acceleration program . In another embodiment the monitoring agent monitors and measures performance of the streaming client . In other embodiments the monitoring agent monitors and measures performance of the collection agent . In still another embodiment the monitoring agent monitors and measures performance of the interceptor . In some embodiments the monitoring agent monitors and measures any resource of the client such as memory CPU and disk.

The monitoring agent may monitor and measure performance of any application of the client. In one embodiment the monitoring agent monitors and measures performance of a browser on the client . In some embodiments the monitoring agent monitors and measures performance of any application delivered via the client agent . In other embodiments the monitoring agent measures and monitors end user response times for an application such as web based or HTTP response times. The monitoring agent may monitor and measure performance of an ICA or RDP client. In another embodiment the monitoring agent measures and monitors metrics for a user session or application session. In some embodiments monitoring agent measures and monitors an ICA or RDP session. In one embodiment the monitoring agent measures and monitors the performance of the appliance in accelerating delivery of an application and or data to the client .

In some embodiments and still referring to a first program may be used to install and or execute the client agent or portion thereof such as the interceptor automatically silently transparently or otherwise. In one embodiment the first program comprises a plugin component such an ActiveX control or Java control or script that is loaded into and executed by an application. For example the first program comprises an ActiveX control loaded and run by a web browser application such as in the memory space or context of the application. In another embodiment the first program comprises a set of executable instructions loaded into and run by the application such as a browser. In one embodiment the first program comprises a designed and constructed program to install the client agent .

In some embodiments the first program obtains downloads or receives the client agent via the network from another computing device. In another embodiment the first program is an installer program or a plug and play manager for installing programs such as network drivers on the operating system of the client .

Referring now to a block diagram depicts one embodiment of a virtualization environment . In brief overview a computing device includes a hypervisor layer a virtualization layer and a hardware layer. The hypervisor layer includes a hypervisor also referred to as a virtualization manager that allocates and manages access to a number of physical resources in the hardware layer e.g. the processor s and disk s by at least one virtual machine executing in the virtualization layer. The virtualization layer includes at least one operating system and a plurality of virtual resources allocated to the at least one operating system . Virtual resources may include without limitation a plurality of virtual processors generally and virtual disks generally as well as virtual resources such as virtual memory and virtual network interfaces. The plurality of virtual resources and the operating system may be referred to as a virtual machine . A virtual machine may include a control operating system in communication with the hypervisor and used to execute applications for managing and configuring other virtual machines on the computing device .

In greater detail a hypervisor may provide virtual resources to an operating system in any manner which simulates the operating system having access to a physical device. A hypervisor may provide virtual resources to any number of guest operating systems generally . In some embodiments a computing device executes one or more types of hypervisors. In these embodiments hypervisors may be used to emulate virtual hardware partition physical hardware virtualize physical hardware and execute virtual machines that provide access to computing environments. Hypervisors may include those manufactured by VMWare Inc. of Palo Alto Calif. the XEN hypervisor an open source product whose development is overseen by the open source Xen.org community HyperV VirtualServer or virtual PC hypervisors provided by Microsoft or others. In some embodiments a computing device executing a hypervisor that creates a virtual machine platform on which guest operating systems may execute is referred to as a host server. In one of these embodiments for example the computing device is a XEN SERVER provided by Citrix Systems Inc. of Fort Lauderdale Fla.

In some embodiments a hypervisor executes within an operating system executing on a computing device. In one of these embodiments a computing device executing an operating system and a hypervisor may be said to have a host operating system the operating system executing on the computing device and a guest operating system an operating system executing within a computing resource partition provided by the hypervisor . In other embodiments a hypervisor interacts directly with hardware on a computing device instead of executing on a host operating system. In one of these embodiments the hypervisor may be said to be executing on bare metal referring to the hardware comprising the computing device.

In some embodiments a hypervisor may create a virtual machine generally in which an operating system executes. In one of these embodiments for example the hypervisor loads a virtual machine image to create a virtual machine . In another of these embodiments the hypervisor executes an operating system within the virtual machine . In still another of these embodiments the virtual machine executes an operating system .

In some embodiments the hypervisor controls processor scheduling and memory partitioning for a virtual machine executing on the computing device . In one of these embodiments the hypervisor controls the execution of at least one virtual machine . In another of these embodiments the hypervisor presents at least one virtual machine with an abstraction of at least one hardware resource provided by the computing device . In other embodiments the hypervisor controls whether and how physical processor capabilities are presented to the virtual machine .

A control operating system may execute at least one application for managing and configuring the guest operating systems. In one embodiment the control operating system may execute an administrative application such as an application including a user interface providing administrators with access to functionality for managing the execution of a virtual machine including functionality for executing a virtual machine terminating an execution of a virtual machine or identifying a type of physical resource for allocation to the virtual machine. In another embodiment the hypervisor executes the control operating system within a virtual machine created by the hypervisor . In still another embodiment the control operating system executes in a virtual machine that is authorized to directly access physical resources on the computing device . In some embodiments a control operating system on a computing device may exchange data with a control operating system on a computing device via communications between a hypervisor and a hypervisor . In this way one or more computing devices may exchange data with one or more of the other computing devices regarding processors and other physical resources available in a pool of resources. In one of these embodiments this functionality allows a hypervisor to manage a pool of resources distributed across a plurality of physical computing devices. In another of these embodiments multiple hypervisors manage one or more of the guest operating systems executed on one of the computing devices .

In one embodiment the control operating system executes in a virtual machine that is authorized to interact with at least one guest operating system . In another embodiment a guest operating system communicates with the control operating system via the hypervisor in order to request access to a disk or a network. In still another embodiment the guest operating system and the control operating system may communicate via a communication channel established by the hypervisor such as for example via a plurality of shared memory pages made available by the hypervisor .

In some embodiments the control operating system includes a network back end driver for communicating directly with networking hardware provided by the computing device . In one of these embodiments the network back end driver processes at least one virtual machine request from at least one guest operating system . In other embodiments the control operating system includes a block back end driver for communicating with a storage element on the computing device . In one of these embodiments the block back end driver reads and writes data from the storage element based upon at least one request received from a guest operating system .

In one embodiment the control operating system includes a tools stack . In another embodiment a tools stack provides functionality for interacting with the hypervisor communicating with other control operating systems for example on a second computing device or managing virtual machines on the computing device . In another embodiment the tools stack includes customized applications for providing improved management functionality to an administrator of a virtual machine farm. In some embodiments at least one of the tools stack and the control operating system include a management API that provides an interface for remotely configuring and controlling virtual machines running on a computing device . In other embodiments the control operating system communicates with the hypervisor through the tools stack .

In one embodiment the hypervisor executes a guest operating system within a virtual machine created by the hypervisor . In another embodiment the guest operating system provides a user of the computing device with access to resources within a computing environment. In still another embodiment a resource includes a program an application a document a file a plurality of applications a plurality of files an executable program file a desktop environment a computing environment or other resource made available to a user of the computing device . In yet another embodiment the resource may be delivered to the computing device via a plurality of access methods including but not limited to conventional installation directly on the computing device delivery to the computing device via a method for application streaming delivery to the computing device of output data generated by an execution of the resource on a second computing device and communicated to the computing device via a presentation layer protocol delivery to the computing device of output data generated by an execution of the resource via a virtual machine executing on a second computing device or execution from a removable storage device connected to the computing device such as a USB device or via a virtual machine executing on the computing device and generating output data. In some embodiments the computing device transmits output data generated by the execution of the resource to another computing device .

In one embodiment the guest operating system in conjunction with the virtual machine on which it executes forms a fully virtualized virtual machine which is not aware that it is a virtual machine such a machine may be referred to as a Domain U HVM Hardware Virtual Machine virtual machine . In another embodiment a fully virtualized machine includes software emulating a Basic Input Output System BIOS in order to execute an operating system within the fully virtualized machine. In still another embodiment a fully virtualized machine may include a driver that provides functionality by communicating with the hypervisor . In such an embodiment the driver may be aware that it executes within a virtualized environment. In another embodiment the guest operating system in conjunction with the virtual machine on which it executes forms a paravirtualized virtual machine which is aware that it is a virtual machine such a machine may be referred to as a Domain U PV virtual machine . In another embodiment a paravirtualized machine includes additional drivers that a fully virtualized machine does not include. In still another embodiment the paravirtualized machine includes the network back end driver and the block back end driver included in a control operating system as described above.

Referring now to a block diagram depicts one embodiment of a plurality of networked computing devices in a system in which at least one physical host executes a virtual machine. In brief overview the system includes a management component and a hypervisor . The system includes a plurality of computing devices a plurality of virtual machines a plurality of hypervisors a plurality of management components referred to variously as tools stacks or management components and a physical resource . The plurality of physical machines may each be provided as computing devices described above in connection with .

In greater detail a physical disk is provided by a computing device and stores at least a portion of a virtual disk . In some embodiments a virtual disk is associated with a plurality of physical disks . In one of these embodiments one or more computing devices may exchange data with one or more of the other computing devices regarding processors and other physical resources available in a pool of resources allowing a hypervisor to manage a pool of resources distributed across a plurality of physical computing devices. In some embodiments a computing device on which a virtual machine executes is referred to as a physical host or as a host machine .

The hypervisor executes on a processor on the computing device . The hypervisor allocates to a virtual disk an amount of access to the physical disk. In one embodiment the hypervisor allocates an amount of space on the physical disk. In another embodiment the hypervisor allocates a plurality of pages on the physical disk. In some embodiments the hypervisor provisions the virtual disk as part of a process of initializing and executing a virtual machine .

In one embodiment the management component is referred to as a pool management component . In another embodiment a management operating system which may be referred to as a control operating system includes the management component. In some embodiments the management component is referred to as a tools stack. In one of these embodiments the management component is the tools stack described above in connection with . In other embodiments the management component provides a user interface for receiving from a user such as an administrator an identification of a virtual machine to provision and or execute. In still other embodiments the management component provides a user interface for receiving from a user such as an administrator the request for migration of a virtual machine from one physical machine to another. In further embodiments the management component identifies a computing device on which to execute a requested virtual machine and instructs the hypervisor on the identified computing device to execute the identified virtual machine such a management component may be referred to as a pool management component.

Referring now to embodiments of a virtual application delivery controller or virtual appliance are depicted. In brief overview any of the functionality and or embodiments of the appliance e.g. an application delivery controller described above in connection with may be deployed in any embodiment of the virtualized environment described above in connection with . Instead of the functionality of the application delivery controller being deployed in the form of an appliance such functionality may be deployed in a virtualized environment on any computing device such as a client server or appliance .

Referring now to a diagram of an embodiment of a virtual appliance operating on a hypervisor of a server is depicted. As with the appliance of the virtual appliance may provide functionality for availability performance offload and security. For availability the virtual appliance may perform load balancing between layers 4 and 7 of the network and may also perform intelligent service health monitoring. For performance increases via network traffic acceleration the virtual appliance may perform caching and compression. To offload processing of any servers the virtual appliance may perform connection multiplexing and pooling and or SSL processing. For security the virtual appliance may perform any of the application firewall functionality and SSL VPN function of appliance .

Any of the modules of the appliance as described in connection with may be packaged combined designed or constructed in a form of the virtualized appliance delivery controller deployable as one or more software modules or components executable in a virtualized environment or non virtualized environment on any server such as an off the shelf server. For example the virtual appliance may be provided in the form of an installation package to install on a computing device. With reference to any of the cache manager policy engine compression encryption engine packet engine GUI CLI shell services and health monitoring programs may be designed and constructed as a software component or module to run on any operating system of a computing device and or of a virtualized environment . Instead of using the encryption processor processor memory and network stack of the appliance the virtualized appliance may use any of these resources as provided by the virtualized environment or as otherwise available on the server .

Still referring to and in brief overview any one or more vServers A N may be in operation or executed in a virtualized environment of any type of computing device such as any server . Any of the modules or functionality of the appliance described in connection with may be designed and constructed to operate in either a virtualized or non virtualized environment of a server. Any of the vServer SSL VPN Intranet UP Switching DNS acceleration App FW and monitoring agent may be packaged combined designed or constructed in a form of application delivery controller deployable as one or more software modules or components executable on a device and or virtualized environment .

In some embodiments a server may execute multiple virtual machines in the virtualization environment with each virtual machine running the same or different embodiments of the virtual application delivery controller . In some embodiments the server may execute one or more virtual appliances on one or more virtual machines on a core of a multi core processing system. In some embodiments the server may execute one or more virtual appliances on one or more virtual machines on each processor of a multiple processor device.

In accordance with Moore s Law the number of transistors that may be placed on an integrated circuit may double approximately every two years. However CPU speed increases may reach plateaus for example CPU speed has been around 3.5 4 GHz range since 2005. In some cases CPU manufacturers may not rely on CPU speed increases to gain additional performance. Some CPU manufacturers may add additional cores to their processors to provide additional performance. Products such as those of software and networking vendors that rely on CPUs for performance gains may improve their performance by leveraging these multi core CPUs. The software designed and constructed for a single CPU may be redesigned and or rewritten to take advantage of a multi threaded parallel architecture or otherwise a multi core architecture.

A multi core architecture of the appliance referred to as nCore or multi core technology allows the appliance in some embodiments to break the single core performance barrier and to leverage the power of multi core CPUs. In the previous architecture described in connection with a single network or packet engine is run. The multiple cores of the nCore technology and architecture allow multiple packet engines to run concurrently and or in parallel. With a packet engine running on each core the appliance architecture leverages the processing capacity of additional cores. In some embodiments this provides up to a 7 increase in performance and scalability.

Illustrated in are some embodiments of work task load or network traffic distribution across one or more processor cores according to a type of parallelism or parallel computing scheme such as functional parallelism data parallelism or flow based data parallelism. In brief overview illustrates embodiments of a multi core system such as an appliance with n cores a total of cores numbers 1 through N. In one embodiment work load or network traffic can be distributed among a first core A a second core B a third core C a fourth core D a fifth core E a sixth core F a seventh core G and so on such that distribution is across all or two or more of the n cores N hereinafter referred to collectively as cores . There may be multiple VIPs each running on a respective core of the plurality of cores. There may be multiple packet engines each running on a respective core of the plurality of cores. Any of the approaches used may lead to different varying or similar work load or performance level across any of the cores. For a functional parallelism approach each core may run a different function of the functionalities provided by the packet engine a VIP or appliance . In a data parallelism approach data may be paralleled or distributed across the cores based on the Network Interface Card NIC or VIP receiving the data. In another data parallelism approach processing may be distributed across the cores by distributing data flows to each core.

In further detail to in some embodiments load work or network traffic can be distributed among cores according to functional parallelism . Functional parallelism may be based on each core performing one or more respective functions. In some embodiments a first core may perform a first function while a second core performs a second function. In functional parallelism approach the functions to be performed by the multi core system are divided and distributed to each core according to functionality. In some embodiments functional parallelism may be referred to as task parallelism and may be achieved when each processor or core executes a different process or function on the same or different data. The core or processor may execute the same or different code. In some cases different execution threads or code may communicate with one another as they work. Communication may take place to pass data from one thread to the next as part of a workflow.

In some embodiments distributing work across the cores according to functional parallelism can comprise distributing network traffic according to a particular function such as network input output management NW I O A secure sockets layer SSL encryption and decryption B and transmission control protocol TCP functions C. This may lead to a work performance or computing load based on a volume or level of functionality being used. In some embodiments distributing work across the cores according to data parallelism can comprise distributing an amount of work based on distributing data associated with a particular hardware or software component. In some embodiments distributing work across the cores according to flow based data parallelism can comprise distributing data based on a context or flow such that the amount of work A N on each core may be similar substantially equal or relatively evenly distributed.

In the case of the functional parallelism approach each core may be configured to run one or more functionalities of the plurality of functionalities provided by the packet engine or VIP of the appliance. For example core 1 may perform network I O processing for the appliance while core 2 performs TCP connection management for the appliance. Likewise core 3 may perform SSL offloading while core 4 may perform layer 7 or application layer processing and traffic management. Each of the cores may perform the same function or different functions. Each of the cores may perform more than one function. Any of the cores may run any of the functionality or portions thereof identified and or described in conjunction with . In this the approach the work across the cores may be divided by function in either a coarse grained or fine grained manner. In some cases as illustrated in division by function may lead to different cores running at different levels of performance or load .

In the case of the functional parallelism approach each core may be configured to run one or more functionalities of the plurality of functionalities provided by the packet engine of the appliance. For example core 1 may perform network I O processing for the appliance while core 2 performs TCP connection management for the appliance. Likewise core 3 may perform SSL offloading while core 4 may perform layer 7 or application layer processing and traffic management. Each of the cores may perform the same function or different functions. Each of the cores may perform more than one function. Any of the cores may run any of the functionality or portions thereof identified and or described in conjunction with . In this the approach the work across the cores may be divided by function in either a coarse grained or fine grained manner. In some cases as illustrated in division by function may lead to different cores running at different levels of load or performance.

The functionality or tasks may be distributed in any arrangement and scheme. For example illustrates a first core Core 1 A processing applications and processes associated with network I O functionality A. Network traffic associated with network I O in some embodiments can be associated with a particular port number. Thus outgoing and incoming packets having a port destination associated with NW I O A will be directed towards Core 1 A which is dedicated to handling all network traffic associated with the NW I O port. Similarly Core 2 B is dedicated to handling functionality associated with SSL processing and Core 4 D may be dedicated handling all TCP level processing and functionality.

While illustrates functions such as network I O SSL and TCP other functions can be assigned to cores. These other functions can include any one or more of the functions or operations described herein. For example any of the functions described in conjunction with may be distributed across the cores on a functionality basis. In some cases a first VIP A may run on a first core while a second VIP B with a different configuration may run on a second core. In some embodiments each core can handle a particular functionality such that each core can handle the processing associated with that particular function. For example Core 2 B may handle SSL offloading while Core 4 D may handle application layer processing and traffic management.

In other embodiments work load or network traffic may be distributed among cores according to any type and form of data parallelism . In some embodiments data parallelism may be achieved in a multi core system by each core performing the same task or functionally on different pieces of distributed data. In some embodiments a single execution thread or code controls operations on all pieces of data. In other embodiments different threads or instructions control the operation but may execute the same code. In some embodiments data parallelism is achieved from the perspective of a packet engine vServers VIPs A C network interface cards NIC D E and or any other networking hardware or software included on or associated with an appliance . For example each core may run the same packet engine or VIP code or configuration but operate on different sets of distributed data. Each networking hardware or software construct can receive different varying or substantially the same amount of data and as a result may have varying different or relatively the same amount of load .

In the case of a data parallelism approach the work may be divided up and distributed based on VIPs NICs and or data flows of the VIPs or NICs. In one of these approaches the work of the multi core system may be divided or distributed among the VIPs by having each VIP work on a distributed set of data. For example each core may be configured to run one or more VIPs. Network traffic may be distributed to the core for each VIP handling that traffic. In another of these approaches the work of the appliance may be divided or distributed among the cores based on which NIC receives the network traffic. For example network traffic of a first NIC may be distributed to a first core while network traffic of a second NIC may be distributed to a second core. In some cases a core may process data from multiple NICs.

While illustrates a single vServer associated with a single core as is the case for VIP1 A VIP2 B and VIP3 C. In some embodiments a single vServer can be associated with one or more cores . In contrast one or more vServers can be associated with a single core . Associating a vServer with a core may include that core to process all functions associated with that particular vServer. In some embodiments each core executes a VIP having the same code and configuration. In other embodiments each core executes a VIP having the same code but different configuration. In some embodiments each core executes a VIP having different code and the same or different configuration.

Like vServers NICs can also be associated with particular cores . In many embodiments NICs can be connected to one or more cores such that when a NIC receives or transmits data packets a particular core handles the processing involved with receiving and transmitting the data packets. In one embodiment a single NIC can be associated with a single core as is the case with NIC1 D and NIC2 E. In other embodiments one or more NICs can be associated with a single core . In other embodiments a single NIC can be associated with one or more cores . In these embodiments load could be distributed amongst the one or more cores such that each core processes a substantially similar amount of load. A core associated with a NIC may process all functions and or data associated with that particular NIC.

While distributing work across cores based on data of VIPs or NICs may have a level of independency in some embodiments this may lead to unbalanced use of cores as illustrated by the varying loads of .

In some embodiments load work or network traffic can be distributed among cores based on any type and form of data flow. In another of these approaches the work may be divided or distributed among cores based on data flows. For example network traffic between a client and a server traversing the appliance may be distributed to and processed by one core of the plurality of cores. In some cases the core initially establishing the session or connection may be the core for which network traffic for that session or connection is distributed. In some embodiments the data flow is based on any unit or portion of network traffic such as a transaction a request response communication or traffic originating from an application on a client. In this manner and in some embodiments data flows between clients and servers traversing the appliance may be distributed in a more balanced manner than the other approaches.

In flow based data parallelism distribution of data is related to any type of flow of data such as request response pairings transactions sessions connections or application communications. For example network traffic between a client and a server traversing the appliance may be distributed to and processed by one core of the plurality of cores. In some cases the core initially establishing the session or connection may be the core for which network traffic for that session or connection is distributed. The distribution of data flow may be such that each core carries a substantially equal or relatively evenly distributed amount of load data or network traffic.

In some embodiments the data flow is based on any unit or portion of network traffic such as a transaction a request response communication or traffic originating from an application on a client. In this manner and in some embodiments data flows between clients and servers traversing the appliance may be distributed in a more balanced manner than the other approached. In one embodiment data flow can be distributed based on a transaction or a series of transactions. This transaction in some embodiments can be between a client and a server and can be characterized by an IP address or other packet identifier. For example Core 1 A can be dedicated to transactions between a particular client and a particular server therefore the load A on Core 1 A may be comprised of the network traffic associated with the transactions between the particular client and server. Allocating the network traffic to Core 1 A can be accomplished by routing all data packets originating from either the particular client or server to Core 1 A.

While work or load can be distributed to the cores based in part on transactions in other embodiments load or work can be allocated on a per packet basis. In these embodiments the appliance can intercept data packets and allocate them to a core having the least amount of load. For example the appliance could allocate a first incoming data packet to Core 1 A because the load A on Core 1 is less than the load B N on the rest of the cores B N. Once the first data packet is allocated to Core 1 A the amount of load A on Core 1 A is increased proportional to the amount of processing resources needed to process the first data packet. When the appliance intercepts a second data packet the appliance will allocate the load to Core 4 D because Core 4 D has the second least amount of load. Allocating data packets to the core with the least amount of load can in some embodiments ensure that the load A N distributed to each core remains substantially equal.

In other embodiments load can be allocated on a per unit basis where a section of network traffic is allocated to a particular core . The above mentioned example illustrates load balancing on a per packet basis. In other embodiments load can be allocated based on a number of packets such that every 10 100 or 1000 packets are allocated to the core having the least amount of load. The number of packets allocated to a core can be a number determined by an application user or administrator and can be any number greater than zero. In still other embodiments load can be allocated based on a time metric such that packets are distributed to a particular core for a predetermined amount of time. In these embodiments packets can be distributed to a particular core for five milliseconds or for any period of time determined by a user program system administrator or otherwise. After the predetermined time period elapses data packets are transmitted to a different core for the predetermined period of time.

Flow based data parallelism methods for distributing work load or network traffic among the one or more cores can comprise any combination of the above mentioned embodiments. These methods can be carried out by any part of the appliance by an application or set of executable instructions executing on one of the cores such as the packet engine or by any application program or agent executing on a computing device in communication with the appliance .

The functional and data parallelism computing schemes illustrated in can be combined in any manner to generate a hybrid parallelism or distributed processing scheme that encompasses function parallelism data parallelism flow based data parallelism or any portions thereof. In some cases the multi core system may use any type and form of load balancing schemes to distribute load among the one or more cores . The load balancing scheme may be used in any combination with any of the functional and data parallelism schemes or combinations thereof.

Illustrated in is an embodiment of a multi core system which may be any type and form of one or more systems appliances devices or components. This system in some embodiments can be included within an appliance having one or more processing cores A N. The system can further include one or more packet engines PE or packet processing engines PPE A N communicating with a memory bus . The memory bus may be used to communicate with the one or more processing cores A N. Also included within the system can be one or more network interface cards NIC and a flow distributor which can further communicate with the one or more processing cores A N. The flow distributor can comprise a Receive Side Scaler RSS or Receive Side Scaling RSS module .

Further referring to and in more detail in one embodiment the packet engine s A N can comprise any portion of the appliance described herein such as any portion of the appliance described in . The packet engine s A N can in some embodiments comprise any of the following elements the packet engine a network stack a cache manager a policy engine a compression engine an encryption engine a GUI a CLI shell services monitoring programs and any other software or hardware element able to receive data packets from one of either the memory bus or the one of more cores A N. In some embodiments the packet engine s A N can comprise one or more vServers A N or any portion thereof. In other embodiments the packet engine s A N can provide any combination of the following functionalities SSL VPN Intranet UP switching DNS packet acceleration App FW monitoring such as the monitoring provided by a monitoring agent functionalities associated with functioning as a TCP stack load balancing SSL offloading and processing content switching policy evaluation caching compression encoding decompression decoding application firewall functionalities XML processing and acceleration and SSL VPN connectivity.

The packet engine s A N can in some embodiments be associated with a particular server user client or network. When a packet engine becomes associated with a particular entity that packet engine can process data packets associated with that entity. For example should a packet engine be associated with a first user that packet engine will process and operate on packets generated by the first user or packets having a destination address associated with the first user. Similarly the packet engine may choose not to be associated with a particular entity such that the packet engine can process and otherwise operate on any data packets not generated by that entity or destined for that entity.

In some instances the packet engine s A N can be configured to carry out the any of the functional and or data parallelism schemes illustrated in . In these instances the packet engine s A N can distribute functions or data among the processing cores A N so that the distribution is according to the parallelism or distribution scheme. In some embodiments a single packet engine s A N carries out a load balancing scheme while in other embodiments one or more packet engine s A N carry out a load balancing scheme. Each core A N in one embodiment can be associated with a particular packet engine such that load balancing can be carried out by the packet engine. Load balancing may in this embodiment provide that each packet engine A N associated with a core communicate with the other packet engines associated with cores so that the packet engines A N can collectively determine where to distribute load. One embodiment of this process can include an arbiter that receives votes from each packet engine for load. The arbiter can distribute load to each packet engine A N based in part on the age of the engine s vote and in some cases a priority value associated with the current amount of load on an engine s associated core .

Any of the packet engines running on the cores may run in user mode kernel or any combination thereof. In some embodiments the packet engine operates as an application or program running is user or application space. In these embodiments the packet engine may use any type and form of interface to access any functionality provided by the kernel. In some embodiments the packet engine operates in kernel mode or as part of the kernel. In some embodiments a first portion of the packet engine operates in user mode while a second portion of the packet engine operates in kernel mode. In some embodiments a first packet engine on a first core executes in kernel mode while a second packet engine on a second core executes in user mode. In some embodiments the packet engine or any portions thereof operates on or in conjunction with the NIC or any drivers thereof.

In some embodiments the memory bus can be any type and form of memory or computer bus. While a single memory bus is depicted in the system can comprise any number of memory buses . In one embodiment each packet engine can be associated with one or more individual memory buses .

The NIC can in some embodiments be any of the network interface cards or mechanisms described herein. The NIC can have any number of ports. The NIC can be designed and constructed to connect to any type and form of network . While a single NIC is illustrated the system can comprise any number of NICs . In some embodiments each core A N can be associated with one or more single NICs . Thus each core can be associated with a single NIC dedicated to a particular core .

The cores A N can comprise any of the processors described herein. Further the cores A N can be configured according to any of the core configurations described herein. Still further the cores A N can have any of the core functionalities described herein. While illustrates seven cores A G any number of cores can be included within the system . In particular the system can comprise N cores where N is a whole number greater than zero.

A core may have or use memory that is allocated or assigned for use to that core. The memory may be considered private or local memory of that core and only accessible by that core. A core may have or use memory that is shared or assigned to multiple cores. The memory may be considered public or shared memory that is accessible by more than one core. A core may use any combination of private and public memory. With separate address spaces for each core some level of coordination is eliminated from the case of using the same address space. With a separate address space a core can perform work on information and data in the core s own address space without worrying about conflicts with other cores. Each packet engine may have a separate memory pool for TCP and or SSL connections.

Further referring to any of the functionality and or embodiments of the cores described above in connection with can be deployed in any embodiment of the virtualized environment described above in connection with . Instead of the functionality of the cores being deployed in the form of a physical processor such functionality may be deployed in a virtualized environment on any computing device such as a client server or appliance . In other embodiments instead of the functionality of the cores being deployed in the form of an appliance or a single device the functionality may be deployed across multiple devices in any arrangement. For example one device may comprise two or more cores and another device may comprise two or more cores. For example a multi core system may include a cluster of computing devices a server farm or network of computing devices. In some embodiments instead of the functionality of the cores being deployed in the form of cores the functionality may be deployed on a plurality of processors such as a plurality of single core processors.

In one embodiment the cores may be any type and form of processor. In some embodiments a core can function substantially similar to any processor or central processing unit described herein. In some embodiment the cores may comprise any portion of any processor described herein. While illustrates seven cores there can exist any N number of cores within an appliance where N is any whole number greater than one. In some embodiments the cores can be installed within a common appliance while in other embodiments the cores can be installed within one or more appliance s communicatively connected to one another. The cores can in some embodiments comprise graphics processing software while in other embodiments the cores provide general processing capabilities. The cores can be installed physically near each other and or can be communicatively connected to each other. The cores may be connected by any type and form of bus or subsystem physically and or communicatively coupled to the cores for transferring data between to from and or between the cores.

While each core can comprise software for communicating with other cores in some embodiments a core manager not shown can facilitate communication between each core . In some embodiments the kernel may provide core management. The cores may interface or communicate with each other using a variety of interface mechanisms. In some embodiments core to core messaging may be used to communicate between cores such as a first core sending a message or data to a second core via a bus or subsystem connecting the cores. In some embodiments cores may communicate via any type and form of shared memory interface. In one embodiment there may be one or more memory locations shared among all the cores. In some embodiments each core may have separate memory locations shared with each other core. For example a first core may have a first shared memory with a second core and a second share memory with a third core. In some embodiments cores may communicate via any type of programming or API such as function calls via the kernel. In some embodiments the operating system may recognize and support multiple core devices and provide interfaces and API for inter core communications.

The flow distributor can be any application program library script task service process or any type and form of executable instructions executing on any type and form of hardware. In some embodiments the flow distributor may any design and construction of circuitry to perform any of the operations and functions described herein. In some embodiments the flow distributor distribute forwards routes controls and or manage the distribution of data packets among the cores and or packet engine or VIPs running on the cores. The flow distributor in some embodiments can be referred to as an interface master. In one embodiment the flow distributor comprises a set of executable instructions executing on a core or processor of the appliance . In another embodiment the flow distributor comprises a set of executable instructions executing on a computing machine in communication with the appliance . In some embodiments the flow distributor comprises a set of executable instructions executing on a NIC such as firmware. In still other embodiments the flow distributor comprises any combination of software and hardware to distribute data packets among cores or processors. In one embodiment the flow distributor executes on at least one of the cores A N while in other embodiments a separate flow distributor assigned to each core A N executes on an associated core A N. The flow distributor may use any type and form of statistical or probabilistic algorithms or decision making to balance the flows across the cores. The hardware of the appliance such as a NIC or the kernel may be designed and constructed to support sequential operations across the NICs and or cores.

In embodiments where the system comprises one or more flow distributors each flow distributor can be associated with a processor or a packet engine . The flow distributors can comprise an interface mechanism that allows each flow distributor to communicate with the other flow distributors executing within the system . In one instance the one or more flow distributors can determine how to balance load by communicating with each other. This process can operate substantially similarly to the process described above for submitting votes to an arbiter which then determines which flow distributor should receive the load. In other embodiments a first flow distributor can identify the load on an associated core and determine whether to forward a first data packet to the associated core based on any of the following criteria the load on the associated core is above a predetermined threshold the load on the associated core is below a predetermined threshold the load on the associated core is less than the load on the other cores or any other metric that can be used to determine where to forward data packets based in part on the amount of load on a processor.

The flow distributor can distribute network traffic among the cores according to a distribution computing or load balancing scheme such as those described herein. In one embodiment the flow distributor can distribute network traffic according to any one of a functional parallelism distribution scheme a data parallelism load distribution scheme a flow based data parallelism distribution scheme or any combination of these distribution scheme or any load balancing scheme for distributing load among multiple processors. The flow distributor can therefore act as a load distributor by taking in data packets and distributing them across the processors according to an operative load balancing or distribution scheme. In one embodiment the flow distributor can comprise one or more operations functions or logic to determine how to distribute packers work or load accordingly. In still other embodiments the flow distributor can comprise one or more sub operations functions or logic that can identify a source address and a destination address associated with a data packet and distribute packets accordingly.

In some embodiments the flow distributor can comprise a receive side scaling RSS network driver module or any type and form of executable instructions which distribute data packets among the one or more cores . The RSS module can comprise any combination of hardware and software. In some embodiments the RSS module works in conjunction with the flow distributor to distribute data packets across the cores A N or among multiple processors in a multi processor network. The RSS module can execute within the NIC in some embodiments and in other embodiments can execute on any one of the cores .

In some embodiments the RSS module uses the MICROSOFT receive side scaling RSS scheme. In one embodiment RSS is a Microsoft Scalable Networking initiative technology that enables receive processing to be balanced across multiple processors in the system while maintaining in order delivery of the data. The RSS may use any type and form of hashing scheme to determine a core or processor for processing a network packet.

The RSS module can apply any type and form hash function such as the Toeplitz hash function. The hash function may be applied to the hash type or any the sequence of values. The hash function may be a secure hash of any security level or is otherwise cryptographically secure. The hash function may use a hash key. The size of the key is dependent upon the hash function. For the Toeplitz hash the size may be 40 bytes for IPv6 and 16 bytes for IPv4.

The hash function may be designed and constructed based on any one or more criteria or design goals. In some embodiments a hash function may be used that provides an even distribution of hash result for different hash inputs and different hash types including TCP IPv4 TCP IPv6 IPv4 and IPv6 headers. In some embodiments a hash function may be used that provides a hash result that is evenly distributed when a small number of buckets are present for example two or four . In some embodiments hash function may be used that provides a hash result that is randomly distributed when a large number of buckets were present for example 64 buckets . In some embodiments the hash function is determined based on a level of computational or resource usage. In some embodiments the hash function is determined based on ease or difficulty of implementing the hash in hardware. In some embodiments the hash function is determined based on the ease or difficulty of a malicious remote host to send packets that would all hash to the same bucket.

The RSS may generate hashes from any type and form of input such as a sequence of values. This sequence of values can include any portion of the network packet such as any header field or payload of network packet or portions thereof. In some embodiments the input to the hash may be referred to as a hash type and include any tuples of information associated with a network packet or data flow such as any of the following a four tuple comprising at least two IP addresses and two ports a four tuple comprising any four sets of values a six tuple a two tuple and or any other sequence of numbers or values. The following are example of hash types that may be used by RSS 

The hash result or any portion thereof may used to identify a core or entity such as a packet engine or VIP for distributing a network packet. In some embodiments one or more hash bits or mask are applied to the hash result. The hash bit or mask may be any number of bits or bytes. A NIC may support any number of bits such as seven bits. The network stack may set the actual number of bits to be used during initialization. The number will be between 1 and 7 inclusive.

The hash result may be used to identify the core or entity via any type and form of table such as a bucket table or indirection table. In some embodiments the number of hash result bits are used to index into the table. The range of the hash mask may effectively define the size of the indirection table. Any portion of the hash result or the hash result itself may be used to index the indirection table. The values in the table may identify any of the cores or processor such as by a core or processor identifier. In some embodiments all of the cores of the multi core system are identified in the table. In other embodiments a port of the cores of the multi core system are identified in the table. The indirection table may comprise any number of buckets for example 2 to 128 buckets that may be indexed by a hash mask. Each bucket may comprise a range of index values that identify a core or processor. In some embodiments the flow controller and or RSS module may rebalance the network rebalance the network load by changing the indirection table.

In some embodiments the multi core system does not include a RSS driver or RSS module . In some of these embodiments a software steering module not shown or a software embodiment of the RSS module within the system can operate in conjunction with or as part of the flow distributor to steer packets to cores within the multi core system .

The flow distributor in some embodiments executes within any module or program on the appliance on any one of the cores and on any one of the devices or components included within the multi core system . In some embodiments the flow distributor can execute on the first core A while in other embodiments the flow distributor can execute on the NIC . In still other embodiments an instance of the flow distributor can execute on each core included in the multi core system . In this embodiment each instance of the flow distributor can communicate with other instances of the flow distributor to forward packets back and forth across the cores . There exist situations where a response to a request packet may not be processed by the same core i.e. the first core processes the request while the second core processes the response. In these situations the instances of the flow distributor can intercept the packet and forward it to the desired or correct core i.e. a flow distributor instance can forward the response to the first core. Multiple instances of the flow distributor can execute on any number of cores and any combination of cores .

The flow distributor may operate responsive to any one or more rules or policies. The rules may identify a core or packet processing engine to receive a network packet data or data flow. The rules may identify any type and form of tuple information related to a network packet such as a 4 tuple of source and destination IP address and source and destination ports. Based on a received packet matching the tuple specified by the rule the flow distributor may forward the packet to a core or packet engine. In some embodiments the packet is forwarded to a core via shared memory and or core to core messaging.

Although illustrates the flow distributor as executing within the multi core system in some embodiments the flow distributor can execute on a computing device or appliance remotely located from the multi core system . In such an embodiment the flow distributor can communicate with the multi core system to take in data packets and distribute the packets across the one or more cores . The flow distributor can in one embodiment receive data packets destined for the appliance apply a distribution scheme to the received data packets and distribute the data packets to the one or more cores of the multi core system . In one embodiment the flow distributor can be included in a router or other appliance such that the router can target particular cores by altering meta data associated with each packet so that each packet is targeted towards a sub node of the multi core system . In such an embodiment CISCO s vn tag mechanism can be used to alter or tag each packet with the appropriate meta data.

Illustrated in is an embodiment of a multi core system comprising one or more processing cores A N. In brief overview one of the cores can be designated as a control core A and can be used as a control plane for the other cores . The other cores may be secondary cores which operate in a data plane while the control core provides the control plane. The cores A N may share a global cache . While the control core provides a control plane the other cores in the multi core system form or provide a data plane. These cores perform data processing functionality on network traffic while the control provides initialization configuration and control of the multi core system.

Further referring to and in more detail the cores A N as well as the control core A can be any processor described herein. Furthermore the cores A N and the control core A can be any processor able to function within the system described in . Still further the cores A N and the control core A can be any core or group of cores described herein. The control core may be a different type of core or processor than the other cores. In some embodiments the control may operate a different packet engine or have a packet engine configured differently than the packet engines of the other cores.

Any portion of the memory of each of the cores may be allocated to or used for a global cache that is shared by the cores. In brief overview a predetermined percentage or predetermined amount of each of the memory of each core may be used for the global cache. For example 50 of each memory of each code may be dedicated or allocated to the shared global cache. That is in the illustrated embodiment 2 GB of each core excluding the control plane core or core 1 may be used to form a 28 GB shared global cache. The configuration of the control plane such as via the configuration services may determine the amount of memory used for the shared global cache. In some embodiments each core may provide a different amount of memory for use by the global cache. In other embodiments any one core may not provide any memory or use the global cache. In some embodiments any of the cores may also have a local cache in memory not allocated to the global shared memory. Each of the cores may store any portion of network traffic to the global shared cache. Each of the cores may check the cache for any content to use in a request or response. Any of the cores may obtain content from the global shared cache to use in a data flow request or response.

The global cache can be any type and form of memory or storage element such as any memory or storage element described herein. In some embodiments the cores may have access to a predetermined amount of memory i.e. 32 GB or any other memory amount commensurate with the system . The global cache can be allocated from that predetermined amount of memory while the rest of the available memory can be allocated among the cores . In other embodiments each core can have a predetermined amount of memory. The global cache can comprise an amount of the memory allocated to each core . This memory amount can be measured in bytes or can be measured as a percentage of the memory allocated to each core . Thus the global cache can comprise 1 GB of memory from the memory associated with each core or can comprise 20 percent or one half of the memory associated with each core . In some embodiments only a portion of the cores provide memory to the global cache while in other embodiments the global cache can comprise memory not allocated to the cores .

Each core can use the global cache to store network traffic or cache data. In some embodiments the packet engines of the core use the global cache to cache and use data stored by the plurality of packet engines. For example the cache manager of and cache functionality of may use the global cache to share data for acceleration. For example each of the packet engines may store responses such as HTML data to the global cache. Any of the cache managers operating on a core may access the global cache to server caches responses to client requests.

In some embodiments the cores can use the global cache to store a port allocation table which can be used to determine data flow based in part on ports. In other embodiments the cores can use the global cache to store an address lookup table or any other table or list that can be used by the flow distributor to determine where to direct incoming and outgoing data packets. The cores can in some embodiments read from and write to cache while in other embodiments the cores can only read from or write to cache . The cores may use the global cache to perform core to core communications. The global cache may be sectioned into individual memory sections where each section can be dedicated to a particular core . In one embodiment the control core A can receive a greater amount of available cache while the other cores can receiving varying amounts or access to the global cache .

In some embodiments the system can comprise a control core A. While illustrates core 1 A as the control core the control core can be any core within the appliance or multi core system. Further while only a single control core is depicted the system can comprise one or more control cores each having a level of control over the system. In some embodiments one or more control cores can each control a particular aspect of the system . For example one core can control deciding which distribution scheme to use while another core can determine the size of the global cache .

The control plane of the multi core system may be the designation and configuration of a core as the dedicated management core or as a master core. This control plane core may provide control management and coordination of operation and functionality the plurality of cores in the multi core system. This control plane core may provide control management and coordination of allocation and use of memory of the system among the plurality of cores in the multi core system including initialization and configuration of the same. In some embodiments the control plane includes the flow distributor for controlling the assignment of data flows to cores and the distribution of network packets to cores based on data flows. In some embodiments the control plane core runs a packet engine and in other embodiments the control plane core is dedicated to management and control of the other cores of the system.

The control core A can exercise a level of control over the other cores such as determining how much memory should be allocated to each core or determining which core should be assigned to handle a particular function or hardware software entity. The control core A in some embodiments can exercise control over those cores within the control plan . Thus there can exist processors outside of the control plane which are not controlled by the control core A. Determining the boundaries of the control plane can include maintaining by the control core A or agent executing within the system a list of those cores controlled by the control core A. The control core A can control any of the following initialization of a core determining when a core is unavailable re distributing load to other cores when one core fails determining which distribution scheme to implement determining which core should receive network traffic determining how much cache should be allocated to each core determining whether to assign a particular function or element to a particular core determining whether to permit cores to communicate with one another determining the size of the global cache and any other determination of a function configuration or operation of the cores within the system .

A SSL session may be allocated private memory address space and associated with a SSL protocol stack that is independent from other SSL sessions. In a single core system such as a single core appliance maintaining a SSL session between a client and a server the SSL session may be resumed if the SSL session is temporarily disrupted and or inactive. For example a disruption may occur due to a mobile client disconnecting and reconnecting to a network or a server going offline due to inactivity or power loss. A client may send a request to resume the SSL session instead of establishing a new session. This may be more efficient in terms of the time and resources consumed in performing a full handshake process allocating memory starting a protocol stack and meeting authentication authorization requirements. Furthermore the disrupted SSL session may remain persistent although a connection may be lost. Resuming a SSL session may also maintain some level of continuity in client server communications.

In some embodiments a packet engine maintains a connection between a client and a core directing packets from the client to the core . The packet engine can maintain a TCP connection through a core for example by identifying the core based on information from received packets and or client . A flow distributor may direct traffic to a packet engine of a core by associating a connection based on information from received packets and or client . In one embodiment this information includes a TCP tuple or TCP quadruple. A TCP tuple may include information on a source IP address a source port number a destination IP address and a destination port number. The TCP tuple may be extracted from a packet. The TCP tuple may remain the same for a client connection and or session. In some embodiments a disruption to a connection of session may cause the TCP tuple to change. For example the source port number may change if the client attempts to reconnect to the intermediary .

The flow distributor may generate a hash index or other identifier based on a TCP tuple to associate the packet traffic with a core. In some embodiments when a TCP tuple changes a different hash index or identifier is generated and a second core is identified instead. Upon a disruption to a connection or session a client may attempt to resume transmission of packets. These packets may come from a different application instance of the client . These packets may provide a different source port information. Other components of the TCP tuple may also change. Based on a changed TCP tuple the flow distributor may generate a second hash index or identifier and direct packet traffic from the client to a second core corresponding to the second hash index or identifier.

In some embodiments use of a flow distributor and or packet engines in a multi core system can result in higher SSL transactions per second TPS and or bulk throughput numbers. Each core may have a virtual IP address VIP associated with the core that may or may not be established in relation to a SSL session . In some embodiments the flow distributor identifies each core via the VIP of the core.

Referring now to an embodiment of a system for managing SSL session persistence and reuse is depicted. In brief overview the system includes an intermediary between a client and a server . The intermediary comprises a multi core system a flow distributor and a storage or memory module . In some embodiments a SSL session may be established and maintained by one of a plurality of cores in a multi core system such as the first core . This core is sometimes referred to as the owner of the SSL session . Upon disruption of the SSL session a client may request resumption of the SSL session by sending a request to the multi core system. The flow distributor may direct the request to a second core that will determine if it owns the disrupted SSL session . The second core may identify the owner of the session and determine if the session can be resumed. The second core can communicate with the first core and receive information for cloning the disrupted SSL session for reuse by the second core . Upon completion of the cloning the connection between the client and the server is resumed based on the cloned session .

Each core of the multi core system can include a transceiver . The transceiver can receive packets or messages directed from the flow distributor . The transceiver can also communicate with other cores of the multi core system. In some embodiments inter core communication involves sending a core to core messaging CCM message from a first core to a second core . The transceiver may support packets and messages based on any type or form of communication protocols. The transceiver can also communicate with other components of the intermediary . For example a core can access data from memory using the transceiver as an interface. The transceiver can also transmit a packet or message to another machine such as server . The transceiver may direct outgoing packets or messages to a destination based on information from the associated TCP tuple.

Each core may include a decoder encoder pair hereinafter generally referred to as a cipher . A cipher may comprise hardware or any combination of software and hardware. The cipher may include an application program library script process task thread or any type and form of executable instructions. Although the cipher is illustrated as part of a certificate manager in some embodiments the cipher may be a separate component or module of the multi core system. In one embodiment the cipher may include a general purpose encoder decoder. In another embodiment the cipher is designed and constructed to encode encrypt or decode decrypt any type and form of information such as session identifiers and or core identifiers . In one embodiment the ciphers are block ciphers. Further the ciphers may include functionality from any embodiment of the encryption engine described in connection with . In some embodiments the system uses data encryption standard DES ciphers such as standard DES ciphers and 3DES ciphers.

The first core is assigned a core identifier . The core identifier may be any type or form of alphanumeric identifier or code string. In addition this core identifier may be unique among the plurality of cores of the multi core system. The core identifier may be a CPU number of the core or incorporate the CPU number of the core . A core identifier may be assigned sequentially to each core based on the CPU numbers of the cores. The core identifier can be of any size. In one embodiment the core identifier is one byte in size. In particular one byte can give 256 0 255 unique core identifiers.

The first core can establish a SSL session between the client and the server . The SSL session may be established in connection with the cipher and or functionality from any embodiment of the encryption engine described in connection with . The SSL session is assigned a session identifier which can be any type or form of alphanumeric identifier or code string. The first core the backend server or the client may issue the session identifier . The session identifier may uniquely identify the SSL session among a plurality of SSL sessions associated with the multi core system. A session identifier may be a random 16 or 32 byte value. In one embodiment the X OR of the byte 0 with byte 1 location of the session identifier results in a random value. By randomly selecting a one byte location in the session identifier for encoding the core identifier such as at system boot time additional security and randomness with respect to the session identifier may be incorporated. In one embodiment a SSLv2 session identifier has a size of 16 bytes and the last 4 bytes may contain a time stamp. In this embodiment the one byte location for the core identifier is preferably between byte 0 to byte 11. In another embodiment a session identifier is 32 bytes for SSLv3 and TLSv1. The lower 4 bytes may be taken up by the timestamp allowing 28 bytes for encoding a core identifier in SSLv3 TLSv1 protocol. Other than the byte locations reserved for timestamp purposes the byte location for encoding a core identifier may be selected by any means.

By way of illustration and not limiting in any way one embodiment of pseudo code for encoding a core identifier may be 

In some embodiments a valid session identifier is encoded with a core identifier. A valid session identifier is sometimes referred to as a validity identifier. A valid session identifier can be a string that identifies a valid session. As an example a cipher may use 8 bytes to encode the valid session identifier and the core identifier. The intermediary or the multi core system can determine whether a session is valid. In one embodiment use of a valid session identifier helps to filter away random or malicious requests to reuse a session. A valid session identifier may also identify active reused sessions.

In some other embodiments the core identifier is not encoded within a byte or a range of bits of a session identifier. Instead individual bits of a session identifier can be used to encode a core identifier . The core identifier can be encoded as a bit pattern in the session identifier . Other than the byte locations that are reserved for timestamp purposes the individual bit locations for encoding a core identifier may be selected by any means. When a session identifier is generated by the core owning the SSL session individual bits can be set to encode the core identifier . The number of bits that are set or unset may depend on the number of cores in the multi core system. This method may impose a relatively small footprint on session identifiers as the number of bits affected is limited to the number of cores in the multi core system

The first core or the packet engine of the first core may store the session identifier in a session cache of the first core . In one embodiment the session cache is persistent for the duration that the core is powered up and or the duration that a session is maintained. In another embodiment the session cache is persistent even when the core is powered down or when a session has ended. The session cache can be memory allocated to the first core and or the SSL session . The session cache may be accessed by one or more cores. In some embodiments the first core maintains and or updates the session cache . The memory module may include the session cache . The memory module may comprise one or more interconnected storage devices such as any embodiment of storage devices described above in connection with .

In some embodiments the session cache stores the session identifier of the SSL session established by the first core . The session cache may store a plurality of session identifiers such as session identifiers of sessions established by the first core . The first core may encode the core identifier in the session identifier to form a second session identifier . In some embodiments the cipher encodes the core identifier in the session identifier to form the second session identifier . In one embodiment the cipher encodes the core identifier in one byte of the session identifier . Encoder decoder routines of the cipher can securely encode the core identifier in the second session identifier and or decode the core identifier . Encoder decoder routines of the cipher can also securely encode decode a valid session identifier in association with the session identifier . In another embodiment the core identifier can be directly stored into bits of the second session identifier . The second session identifier can be stored in the session cache either with the session identifier or in replacement of the session identifier .

In some embodiments the second core is substantially similar or identical to the first core in terms of functionality capability and or associated elements. For example the second core includes a transceiver and a decoder and is associated with a session cache . The second core can be assigned a unique core identifier . The second may similarly establish a new SSL session. In addition the second core may reuse a SSL session of the first core .

The intermediary includes a set of policies . These policies may be any embodiments of the policies described in connection with . These policies may be applied to a request such as a request to resume a SSL session. The policies can also determine to which core the flow distributor directs an incoming message. In addition an associated policy engine may apply the policies for example to determine whether a session can be resumed or reused. In some embodiments the policies are stored in the memory module . For example the policies can be stored in a private partition of the memory module . Some of these policies may be grouped and associated with a client and or a server .

A core may resume a session that it has established. For example a core may resume a session that it has established by restarting part of the protocol stack of the session that was disrupted. A core may resume a session that was established by another core by creating a copy or clone of the session in the core. In some embodiments the latter case is referred to as a reuse of the session. In these embodiments resuming a session may have a broader scope than reusing a session. In other embodiments session resume or reuse can be used interchangeably. In still other embodiments reuse refers to the reuse of some elements of a session such as security parameters of the session.

Each SSL session may be associated with a resumable indicator . The resumable indicator may be predetermined or dynamically updated. An administrator the server or a core establishing a SSL session may determine and or set an associated resumable indicator . The resumable indicator may be determined and or set via analysis of session history and or statistics such as via any algorithm or process steps. In other embodiments a core reusing the SSL session may be able to update the resumable indicator of the SSL session . In some other embodiments a core reusing the SSL session may send information to the owner of the SSL session to update the resumable indicator of the SSL session .

The resumable indicator may indicate whether a request to resume a SSL session should be allowed. The resumable indicator may indicate whether a request to resume a SSL session is allowed subject to a reuse limit and or other factors. A resumable indicator may be set based on the state of the SSL session for example whether the session is active and or is being reused by one or more cores. In one embodiment the resumable indicator may be set as non resumable when the SSL session is still active. In another embodiment the resumable indicator may be set as resumable if an inactive SSL session has not expired and or is not corrupted. In one embodiment if a fatal alert is sent or received in a SSL session the corresponding resumable indicator is set as non resumable. In some embodiments if the resumable indicator is set as non resumable all further session resume requests may be rejected or discarded.

A second core processing a request to reuse and or resume a SSL session may access the resumable indicator to determine whether the SSL session is resumable. The resumable indicator may be stored at a shared location in memory accessible by a plurality of cores. The resumable indicator may also be stored at a location in memory accessible by each core of the multi core system. In some embodiments the resumable indicator of a SSL session established by a core can be stored in the session cache of that core and or that session. The resumable indicator may be stored in a location in shared memory. The resumable indicator may be one byte in size although other embodiments are supported. In some embodiments the stored value is a pointer to a larger memory location. In other embodiments a plurality of cores e.g. cores requesting reuse of the SSL session can each store a copy of the resumable indicator . In one of these embodiments the plurality of cores having a copy of the resumable indicator may check for updates to the resumable indicator or receive a notification of an update to the resumable indicator . An update or notification may be sent as a CCM message from the first core . An update or notification may be sent to cores identified to be reusing the SSL session .

In some embodiments the packet engine stores a reuse limit to a memory module . A reuse limit is sometimes referred to as a maximum reuse threshold. This reuse limit may indicate the number of times a session can be resumed or reused. This reuse limit may be predetermined or dynamically updated. The reuse limit may be determined and set by an administrator and or via analysis of session history and or statistics such as via any algorithm or process steps. The first core may specify a reuse limit directed to the first core to the multi core system or to the SSL session established by the first core . A second core reusing a SSL session owned by the first core may specify a reuse limit directed to the second core . The reuse limit of a session for a core can be stored in the session cache of that core and or that session. The reuse limit may also be stored in a shared location in memory accessible by a plurality of cores. The reuse limit of a core may also be stored in memory partitioned or allocated for a core.

In some embodiments a reuse limit may be set to limit the reuse of a session that may be inherently unstable or prone to disruption. In other embodiments a reuse limit may be set to limit cumulative and or parallel reuse of a SSL session by a plurality of cores.

In some embodiments if the resumable indicator for a session indicates that that the session is non resumable reuse of the session is not allowed. In one of these embodiments the reuse limit is removed. In another of these embodiments the reuse limit is set to zero. A core attempting to process a request to reuse and or resume a SSL session may access the reuse limit to determine whether the SSL session is reusable. If the resumable indicator for a session indicates that that the session is resumable and the reuse limit of a core and or session is not reached reuse of the session may be allowed. In some embodiments the reuse limit and the resumable indicator are determined and or set independently. In other embodiments the reuse limit and the resumable indicator are determined and or set in relation to each another. In some other embodiments the reuse limit and or the resumable indicator are determined in accordance with other factors such whether the session has expired and or is corrupted.

To resume a SSL session a client may send a request to the intermediary . The flow distributor of the intermediary can process the request and or forward the request to one of the plurality of cores. The request may include a session identifier of the SSL session identified to resume. The request may also include any information related to the session the client the server and the first core . If a second core receives the request the second core may send a message to the first core requesting for information about the SSL session . The second core can use this information about the SSL session to copy clone reconstruct duplicate mirror or otherwise create a SSL session substantially similar to the original SSL session . This process may be generally referred to as cloning a session. The SSL session is sometimes referred to as a copy of the original session or a clone of the original session .

The information about the SSL session may include one or more of protocol stack information TCP tuple information a master key a client certificate a name of a cipher a result of client authentication and an SSL version. Some or all of these information may be held in the SSL session data structure of the SSL session . The second core may access some or all of these information via the first core . Although information for generating an identical

SSL session may be available in the session data structure of the SSL session a complete copy of the session data structure may not be required to clone and resume the SSL session.

In some embodiments protocol stack information may be determined from the SSL version information. In other embodiments information on the state and or components of the protocol stack such as that of drivers and agents that may be dynamically installed and or configured can be used for cloning the SSL session . The first core may use at least some portions of TCP tuple information to clone the SSL session . The first core may also obtain TCP tuple information from the request .

A first core or a packet processor of the core can use a master key for the SSL session to manage security for example data encryption and decryption and securing transactions though authorization and authentication. The master key can be applied to SSL certificates. The master key can be 48 bits long although other embodiments are also supported. In some embodiments the master key can be a Federal Information Processing Standard FIPS key such as one generated by a FIPS card. The intermediary may include a FIPS card in communication with the first core . The master key can also be created by a certificate authority CA such as a local CA residing in the intermediary . In one embodiment the CA executes on the first core and generates certificates certificate revocation lists CRLs and certificate signing requests CSRs in addition to the keys. By way of illustration and not limiting in any way one embodiment of a set of typical commands for a CA is as follows 

create ssl cert The second core may request some or all of the generated information from the first core to clone the SSL session . In some embodiments the second core requests a minimum set of information to reuse the SSL session . The first core may send a minimal set of information to the second core to clone the SSL session . The first core may send one or more messages containing the set of information to clone the SSL session .

The first core can use information related to the client certificate for example to determine the certificate authority status issuer identifier of the certificate and whether the certificate is valid and or revoked. Client certificate information can facilitate authentication and or authorization management in the cloned session. In some embodiments a client certificate is used to support client authentication and or SSL data insertion. In different embodiments client certificate information can be of variable size.

The name or type of a cipher including any configuration of the cipher can allow the second core to decode encode decrypt encrypt data consistent with the SSL session . Cipher information can be sent in 32 bytes of information although other embodiments can be supported. In addition client authentication results can facilitate re authentication of the client and or allow bypass of some authentication steps. Client authentication results may also be used in policy based authentication of the client such as using one or more of the policies . Client authentication results can be sent in 4 bytes of information although other embodiments can be supported.

The second core may also request for the SSL version to clone a SSL network protocol stack and or session data structure. The SSL version may also facilitate cloning of connections within the SSL network protocol stack as well as connections between any layer of the protocol stack with the client server and any other network component. SSL version information can be sent in 4 bytes of information although other embodiments can be supported. In some embodiments additional information or arguments for using the master key and or other keys can be used to clone a SSL session. For example and in one embodiment SSLv2 protocol may use a 8 bit key argument.

The first core that owns the SSL session may store information about session reuse by other cores. This information can be maintained as a bit pattern such as a bit pattern representing the cores of the multi core system in the session cache or in memory . This information may also include a reference count of cloned sessions . This information can be used for ageing the cloned sessions for timeout. On timeout of a cloned session the non owner core for example the second core may send a message to the first core indicating that the cloned session has ended. In response to this message the first core may update the stored information e.g. a reference count of cloned sessions. In one embodiment the SSL session may not be terminated if cloned sessions are active. In some embodiments each core processes session ageing irrespective of whether the SSL session is a cloned or original session. Certain operations performed by a core described herein in various embodiments may be performed by a packet engine of the core.

Referring now to a flow diagram depicting an embodiment of steps of a method for maintaining session persistence and reuse in a multi core system is shown. In brief overview at step a first core of a multi core system in an intermediary receives a request from a client to establish a secure socket layer SSL session with a server the core assigned a first core identifier . At step the first core establishes a session identifier for the SSL session . At step the first core encodes the first core identifier in the session identifier to form a second session identifier . At step the first core establishes the SSL session with the client using the second session identifier . At step the first core stores the second session identifier in a session cache of the first core . At step the first core indicates whether the SSL session is resumable. At step the first core sets an indicator at a location in memory accessible by each core of the multi core system the indicator indicating whether the SSL session is resumable. At step a flow distributor of the multi core system forwards a second request from the client to a second core to reuse and resume the SSL session . At step the second core receives the second request from the client the request comprising the second session identifier . The second core is assigned a second core identifier . At step the second core determines that the second session identifier is not in a session cache of the second core .

At step the second core decodes a core identifier encoded in the second session identifier . At step the second core determines whether the indicator in the memory location indicates that the SSL session is resumable. At step the second core determines whether a reuse limit for the SSL session has been exceeded. At step the second core determines whether the core identifier corresponds to the second core identifier . At step the second core resumes client communications with the server in the SSL session . At step the second core forwards the request to the server . At step the second core transmits a message requesting information about the SSL session to the first core identified by the core identifier . At step the first core identifies the second core via a second core identifier included in the message received from the second core . At step the first core transmits a message to the second core . At step the first core transmits to the second core the message indicating that the SSL session is not reusable. At step the second core determines not to resume the SSL session based on at least one of the message from the first core the identification that the second core is not the establisher of the SSL session application of a policy the indicator and the reuse limit . At step the first core transmits to the second core at least one of a master key a client certificate a name of a cipher a result of client authentication and an SSL version in the message. At step the second core establishes a copy of the SSL session on the second core based on the information about the SSL session obtained from the first core . At step the second core resumes client communications with the server in the copy of the SSL session .

In further details of step a first core of a multi core system in an intermediary receives a request from a client to establish a SSL session with a server. In one embodiment a first core of multi core system deployed as an intermediary between the client and a server receives a request from a client to establish a SSL session with a server . In some embodiments the first core receives a client hello message from the client . The first core may receive a first request from the client via the flow distributor . The first core is assigned a first core identifier . The first core may be assigned a core identifier based on an identifier of a processing unit of the first core. In one embodiment the first core is assigned a one byte core identifier . The multi core system the flow distributor or other component of the intermediary may generate and assign the first core identifier to the first core . The first core identifier may be generated via application of at least one policy .

The flow distributor may identify the first core based on information e.g. TCP tuple included in the request . For example an in one embodiment the flow distributor calculates a hash value for the first request based on information e.g. TCP tuple included in the request . The flow distributor may identify the first core from the calculated hash value. The flow distributor may determine that the first core is active and or available to handle the request . The flow distributor may then forward the request to the first core . The first core can receive the request via a transceiver of the first core .

In further details of step the first core establishes a session identifier for the SSL session. Responsive to receiving the request the first core may parse extract or otherwise process information from the request . The first core may parse the request for a session identifier if available. In some embodiments an absence of a session identifier in the request indicates that the request is a request for establishing a new SSL session. The first core may perform authentication and or authorization in connection with request for example by applying at least one policy .

In some embodiments the server generates the session identifier for the SSL session . The first core may obtain the session identifier from the server . In other embodiments the first core may generate the session identifier for the SSL session . The session identifier may be generated via any program code formulas or algorithms. In one embodiment the server and or the first core may generate a 16 byte session identifier . In one embodiment the server and or the first core may generate a 32 byte session identifier . In some embodiments the server and or the first core may reserve 4 byte of the session identifier for timestamp information. The server and or the first core may generate a random session identifier . The server and or the first core may generate a session identifier using a cipher and or a random code generator. The server and or the first core may apply at least one policy in generating the session identifier . During generation of the session identifier The server and or the first core may determine that the session identifier is unique for the multi core system. In some embodiments the session identifier is generated after the SSL session is established. In other embodiments the session identifier is generated while the SSL session is established.

In some embodiments a SSL server or vserver generates the session identifier. In other embodiments the client generates the session identifier . In some other embodiments the session identifier may be generated by a cipher and or an encryption engine .

In further details of step the first core encodes the first core identifier in the session identifier to form a second session identifier . In some embodiments the first core uses an encoder decoder pair or a cipher to encode the first core identifier in the session identifier to form a second session identifier . The first core may encode a byte of the session identifier with the core identifier to form the second session identifier . The first core may encode the core identifier into a plurality of bits of the session identifier to form the second session identifier . The first core may determine at a predetermined frequency a predetermined set of one or more bytes of the session identifier to encode to form the second session identifier . The first core may determine a predetermined set of one or more bytes of the session identifier to encode to form the second session identifier . The first core may determine a predetermined set of one or more bits of the session identifier to encode to form the second session identifier . The first core may encode the core identifier as a bit pattern in the session identifier . The first core may set or unset a number of bits in the session identifier to encode the core identifier .

The first core may encode with a block cipher the core identifier and a validity identifier with the session identifier to form the second session identifier . The first core may encode the core identifier and or a validity identifier with the session identifier using a DES or 3DES cipher. The first core may use 7 bytes of the session identifier to encode the validity identifier. The first core may use 8 bytes of the session identifier to encode both the core identifier and the validity identifier. The multi core system intermediary a SSL server or a SSL vserver may generate the validity identifier.

In some embodiments the first core uses an encoder decoder pair or a cipher to encode the first core identifier and or a validity identifier in the session identifier to form a second session identifier . In some embodiments the first core executes program codes to encode the first core identifier and or a validity identifier in the session identifier to form a second session identifier . The first core may also perform mapping or apply hash functions on session identifier before or after encoding. The second session identifier may be a result of mapping hash functions and or encoding applied on the session identifier . The first core may randomly select a byte location in the session identifier to encode the core identifier. The first core may randomly select byte locations in the session identifier to encode the validity identifier.

In further details of step the first core establishes the SSL session with the client using the second session identifier . The first core may establish an SSL session with a client responsive to the request . The first core may establish an SSL session with a client responsive to successful authentication and or authorization. The first core may initiate handshaking operations with the client and or server to establish one or more connections between the client and the server . The first core may negotiate a SSL version with the client and or the server . Upon reaching agreement of a SSL version the first core may establish a session protocol stack for a SSL session . The first core may execute one or more drivers and or agents in the protocol stack in establishing the protocol stack. The first core may establish one or more connections between the client server and layers of the session protocol stack. In addition the first core may establish a session data structure for the SSL session .

The first core may perform any of the steps of establishing the SSL session via functionality provided by one or more of the cipher the encryption engine and or a SSL vserver executing on the first core or on the multi core system. In addition the SSL session may be generated based on application of at least one policy . The first core may allocate memory for establishing and or maintaining the SSL session . Further the first core may establish the session data structure for the SSL session . In some embodiment the backend server establishes the SSL session on behalf of the first core .

In further details of step the first core stores the second session identifier in a session cache of the first core . The first core may create or allocate memory for a session cache responsive to the request . The first core may create or allocate memory for a session cache responsive to successful authentication and or authorization. The first core may create a session cache for one or more SSL sessions associated with the first core . The first core may create a session cache in association with establishing a SSL session. In one embodiment the first core stores the second identifier at a location in memory . The first core may store the second identifier in a private memory space of the first core . In one embodiment the first core stores the second identifier at a location in shared memory accessible by a plurality of cores.

In further details of step the first core indicates whether the SSL session is resumable. In one embodiment the first core of a multi core system indicates that an SSL session established by the first core is resumable or non resumable. In another embodiment the first core of the multi core system deployed as an intermediary between the client and a server receives a notification that the SSL session is resumable or non resumable. The multi core system or the flow distributor may determine that the SSL session is resumable or non resumable. The SSL session may be resumable or non resumable based on a setting preference or configuration associated with the client the server and or the request . In still another embodiment the first core of the multi core system deployed as an intermediary between the client and a server determines that the SSL session is resumable or non resumable in accordance with a policy .

In some embodiments the first core identifies via core identifiers included in requests for session information for the SSL session one or more cores of the multi core system that sent the requests. The first core may receive these requests as CCM messages from other cores. The first core may receive these requests from other cores responsive to a session disruption. The first core may parse each request for a core identifier each core identifier identifying a core that sent the request. The first core can identify one or more cores based on a bit pattern of data stored on the first core . The first core can identify one or more cores based on a bit pattern of data stored in the memory . The first core can identify the one or more cores by comparing the core identifiers included in the requests with the bit pattern.

In some embodiments the first core transmits to each of the identified one or more cores of the multi core system a message indicating that the SSL session is resumable or non resumable. The first core may broadcast a message to each of the identified one or more cores indicating that the SSL session is resumable or non resumable. In some embodiments the first core sends a message to each of the identified one or more cores if a resumable indicator is not available and or not set.

In further details of step the first core sets an indicator at a location in memory accessible by each core of the multi core system. The indicator indicates whether the SSL session is resumable. In one embodiment responsive to the indication the first core sets an indicator at a location in memory accessible by each core of the multi core system. The indicator may indicate that the SSL session is resumable or non resumable. The indicator may be referred to as a resumable indicator . The first core may store to the location in the memory a value for a resumable field associated with the SSL session as the indicator.

In further details of step a flow distributor of the multi core system forwards a second request from the client to a second core to reuse and resume the SSL session . In some embodiments a flow distributor e.g. receive side scaler of the multi core system determines to forward the request to the second core based on a source port indicated by the request . The flow distributor may receive the second request from the client . The flow distributor may receive the second request after a disruption related to the SSL session . The flow distributor may determine to forward the request to the second core based a non availability of the first core . The flow distributor may determine to forward the request to the second core based on a TCP tuple indicated by the request . The flow distributor may determine to forward the request to the second core based on a hash index determined from a TCP tuple indicated by the request . The flow distributor may determine to forward the request to the second core by associating the hash index with the second core .

In further details of step the second core receives the second request from the client . The request comprises the second session identifier . In some embodiments the second core of the multi core system deployed as an intermediary between the client and a server receives the request from the client to resume the SSL session with the server. The second core is assigned a second core identifier . The multi core system may assign the second core identifier to the second core based on an identifier of a processing unit of the second core . The multi core system may assign the core a one byte core identifier . The multi core system may generate for the second core identifier a random and or unique core identifier in the multi core system.

The second core can receive via a transceiver of the second core the second request . The second core may receive the second request from the flow distributor . The second core may receive the second request as a client hello message. The second core may receive the request from a client via a SSL session. For example a connection between the client and the intermediary may be maintained but a connection between the intermediary and the server may be disrupted. The second core may receive the request to resume and or reuse the SSL session .

The second request may comprise a session identifier . The second core may parse extract and or decode a session identifier from the second request . The second core may parse extract and or decode this second session identifier from the second request responsive to receiving the second request . The second core may decode the second session identifier to extract a core identifier and or validity identifier from the session identifier . The second core may apply mapping and or hash functions on the session identifier before or after the decoding.

In some embodiments the decoding process includes applying mapping and or hash functions on the session identifier . Application of mapping and or hash functions may yield the original session identifier generated by the server for the SSL session . The second core may apply this original session identifier in communications with the server . The second core may use this original session identifier to identify the server and or SSL session . In some embodiments the second core may check the session cache against this original session identifier.

The second session identifier may identify the first core as an establisher or owner of the SSL session . The second core may establish that the validity identifier is valid by accessing related information from memory applying at least one policy and or communicating with at least one of the first core the flow distributor and some other component of the intermediary .

In further details of step and in one embodiment the second core determines that the second session identifier is not in a session cache of the second core . In another embodiment the second core determines that the second session identifier is in a session cache of the second core . Responsive to obtaining the second session identifier the second core may access at least one session cache of the second core . The second core may retrieve the at least one session cache from memory . The second core may retrieve information from the session cache such as a session identifier to compare against the second session identifier . Responsive to the comparison the second core can determine whether the second session identifier is in a session cache of the second core . In some embodiments if the second session identifier is in the session cache the corresponding session is already associated with the second core . Consequently the second core can resume the session and resume client communications with the server if other factors for resuming the session is met.

In further details of step the second core decodes a core identifier encoded in the second session identifier . The second core may decode a second core identifier from a byte of the second session identifier . The second core may decode a predetermined byte of the second session identifier to obtain the second core identifier . The second core may apply a decoder to decode the second core identifier to obtain the second session identifier . The second core may apply a cipher e.g. a block cipher to decode the second core identifier to obtain the second session identifier . In other embodiments the second core may use a DES or a 3DES cipher. The second core may decode the second core identifier from a predetermined number of bits in the second session identifier .

In further details of step the second core determines whether the indicator in the memory location indicates that the SSL session is resumable. The second core processing a request to reuse and or resume a SSL session may access the resumable indicator to determine whether the SSL session is resumable. The second core may access the resumable indicator from memory . The second core may access a copy of the resumable indicator for example from the private memory space of the second core . The second core may process the resumable indicator field or pointer destination to determine whether the SSL session is resumable. In one embodiment the second core may determine that a resumable indicator of the SSL session does not exist or is not set. In some embodiments the second core receives a notification or message from the first core or other component of the multi core system on whether the SSL session is resumable.

In one embodiment the resumable indicator and or notification indicates that the SSL session is non resumable. In this embodiment the second core may determine not to resume the SSL session. Further details are described in connection with step . In another embodiment the resumable indicator and or notification indicates that the SSL session is resumable. In this embodiment the second core can resume the session and resume client communications with the server if other requirements for resuming the session are met see step .

In further details of step the second core determines whether a reuse limit for the SSL session has been exceeded. The second core may access the memory e.g. shared memory space or private memory space for a reuse limit . The second core may set a reuse limit for the SSL session for example if a reuse limit does not already exist. The second core may compare the reuse limit against a reuse history counter or tracker. The second core may access the memory for the reuse history counter or tracker.

In one embodiment the second core determines that the reuse limit for the SSL session has been exceeded. In this embodiment the second core may determine not to resume the SSL session. Further details are described in connection with step . In another embodiment the second core determines that the reuse limit for the SSL session has not been exceeded. Consequently the second core can resume the session and resume client communications with the server if other requirements for resuming the session are met see step .

In further details of step the second core determines whether the core identifier corresponds to the second core identifier . In one embodiment the second core identifies from encoding of the second session identifier that the second core is not the establisher of the SSL session . For example the second core may determine that the core identifier does not corresponds to the second core identifier . In another embodiment the second core may identify from encoding of the second session identifier that the first core is the establisher of the SSL session . The second core may send a message to the first core to verify that the first core is the establisher of the SSL session .

In still another embodiment the second core identifies from encoding of the second session identifier that the second core is the establisher of the SSL session. For example the second core may determine that the core identifier in the received session identifier matches the second core identifier . In this embodiment the second core can resume the session and resume client communications with the server if other requirements for resuming the session are met see step .

In further details of step the second core resumes client communications with the server in the SSL session. If the core identifier of the second core corresponds to the second core identifier the second core may resume client communications with the server in the SSL session if other requirements for resuming the session is met. If the second core determines that the second core is the establisher of the SSL session the second core may resume client communications with the server in the SSL session if other requirements for resuming the session is met. In different embodiments some or all of the following requirements must be met before the second core can resume the SSL session 

In connection with resuming the session the second core may update one or more of the resumable indicator the reuse limit and the associated session cache. The second core may restart a portion of the session protocol stack and or restore a connection of the SSL session e.g. a disrupted connection between the server and the protocol stack . In addition the second core may send a message to the client . In some embodiments the second core may initiate handshaking with the client to resume the SSL session and may include authentication and or authorization process steps.

In further details of step the second core forwards the request to the server . The second core may resume communications with the server responsive to resumption of the SSL session . In one embodiment the second core resumes client communications with the server from the point of disruption of the SSL session . In some embodiments the resumption of client communications is transparent or substantially transparent to one or more of the user of the client the client and the server

In further details of step the second core transmits a message requesting information about the SSL session to the first core identified by the core identifier . The second core may transmit to the core identified by the core identifier a message requesting information about the established SSL session . In some embodiments the second core determines that the second core is not the establisher of the SSL session . Responsive to the determination the second core may transmit a request to the core that established the SSL session . The second core may transmit a request to verify that the first core is the establisher of the SSL session .

The second core may transmit a request for information to reuse and clone the SSL session . The second core may transmit a request for a minimum set of information to reuse and clone the SSL session on the second core . The second core may transmit a request for at least a partial copy of the session data structure of the SSL session . The second core may transmit a request for at least a master key a client certificate a name of a cipher a result of client authentication and an SSL version to reuse and clone the SSL session . The second core may transmit a request for a key processing argument a CRL and or TCP tuple information. The second core may transmit the request or message as a CCM message.

In further details of step the first core identifies the second core via a core identifier included in the message received from the second core . In some embodiments the first core receives the message or request from the second core . The first core may parse or extract a core identifier from the message or request to identify the second core . Based on the identification the first core may respond to the second core .

In further details of step the first core transmits a message to the second core . The first core may transmit a message to the second core responsive to the request or message from the second core . The first core may send a confirmation message to the second core that the first core is the establisher of the SSL session . Steps and describes other embodiments of the first core s responses.

In further details of step the first core transmits to the second core the message indicating that the SSL session is not reusable or resumable. In some embodiments this message is a CCM message. The first core may transmit the message indicating that the SSL session is non resumable based on the resumable indicator . The first core may transmit the message indicating that the SSL session is non resumable based on a notification that the first core have received. The first core may transmit the message indicating that the SSL session is not reusable based on a reuse limit of the SSL session . The first core may transmit the message indicating that the SSL session is not reusable or resumable based on an expiration of the SSL session . The first core may transmit the message indicating that the SSL session is not reusable or resumable based on a determination that the SSL session is corrupted. The first core may transmit the message indicating that the SSL session is not reusable or resumable based on detecting an error message in the SSL session .

In further details of step the second core determines not to resume the SSL session based on at least one of the message from the first core the identification that the second core is not the establisher of the SSL session application of a policy the indicator and the reuse limit. The second core may receive a message from the first core indicating that the SSL session is not reusable or resumable based on any of the reasons described in connection with step . The second core may determine not to resume the SSL session based on the message from the first core . The second core may determine not to resume the SSL session based on limited resources available on the second core .

The second core may determine not to resume the SSL session based on a determination that the second core did not establish the SSL session . The second core may determine whether a predetermined maximum reuse threshold e.g. reuse limit has been reached. The second core may determine not to resume the SSL session if the maximum reuse threshold is reached or exceeded. The second core may determine not to resume the SSL session in the absence of a reuse limit . The second core may determine not to resume the SSL session based on a determination that the SSL session is non resumable according to the resumable indicator .

In some embodiments the second core removes information about the SSL session from a session cache of the second core . The second core may remove a session cache of the second core . The second core may remove the information and or the session cache responsive to a determination not to resume or reuse the SSL session . In some embodiments the second core establishes a new SSL session responsive to the client request . The second core may negotiate with the client for a new SSL version and or send a new session identifier to the client . Embodiments of details for establishing a new SSL session is described above in connection step .

In further details of step the first core transmits to the second core at least one of a master key a client certificate a name of a cipher a result of client authentication and an SSL version in the message. In one embodiment the first core transmits to the second core a master key a client certificate a name of a cipher a result of client authentication and an SSL version. The first core may also transmit information associated with key processing arguments CRLs and TCP tuples. The first core may send the second core at least a portion of the session data structure of the SSL session .

The first core may send the second core any other information for resuming or reusing the SSL session . The first core may send the second core a minimum set of information for resuming or reusing the SSL session in the second core . The first core may send the second core information for cloning or creating a copy of the SSL session in the second core . The first core may send any of these information to the second core in one or more messages. The one or more messages may be sent via CCM. In some embodiments the first core may provide any of these information at a location in memory for the second core to access. The first core may also provide the second core a pointer or location to any of these information.

In further details of step the second core establishes a copy of the SSL session on the second core based on the information about the SSL session obtained from the first core. In some embodiment the second core establishes a clone or copy of the SSL session using one or more steps substantially similar to establishing a new SSL session. The second core may build a session data structure for the SSL session from a partial data structure of the original SSL session provided by the first core . The second core may initiate handshaking steps with the client and or server . The handshaking steps may include any extent and combination of authentication authorization certificate validation renewal and key validation renewal depending on the information provided by the first core .

The second core may generate a session identifier for the cloned SSL session . The second core may generate a session identifier that is the same as the session identifier for SSL session except for the encoded bits for the core identifier. The second core may encode the core identifier of the second core in the session identifier . A validity identifier for the SSL session may be issued and encoded in the session identifier . The second core may create a session cache in connection with establishing the cloned SSL session . The second core may update the session cache with the session identifier . The second core may create and or update the session cache according to embodiments of steps described above in connection with and steps and .

The second core may update the resumable indicator reuse limit and or reuse count. The second core may also send a message to the first core indicating that the cloned session is resumed. The first core may update a record for tracking session reuse of the SSL session amongst the plurality of cores. The first core may maintain the original SSL session if any corresponding cloned sessions are active.

In further details of step the second core resumes client communications with the server with the copy of the SSL session . The second core may resume client communications with the server with the cloned SSL session substantially similar to the steps described in connection with steps and . The second core may transmit a message to the client and or server including the new session identifier and core identifier . In one embodiment the second core resumes client communications with the server from the point of disruption of the original SSL session . In some embodiments the resumption of client communications is transparent or substantially transparent to one or more of the user of the client the client and the server .

Although generally discussed with respect to a first and a second core the techniques in this disclosure can apply to any cores of the multi core system. Various embodiments of the methods may include any combination of the steps described. The systems and methods disclosed can apply to homogeneous and heterogeneous system. Homogeneous systems includes but are not limited to i cores in a multi core system ii a plurality of multi core systems and iii servers in a server farm. Heterogeneous systems includes but are not limited to i general purpose CPUs and application specific cores ii a network of machines of various types iii multi core systems of different types and or number of cores and iv server farms comprising machines of different types and or number of machines.

In some embodiments the systems and methods disclosed can be applied to cluster deployment where session cloning is performed across homogenous or heterogeneous systems. In one embodiment a plurality of sessions in a first multi core system may be cloned in a second multi core system. In other embodiments session information and parameters may be reused across homogenous or heterogeneous systems. In some embodiments SSL security parameters may be transferred across homogenous or heterogeneous systems. Some or all of a set of SSL security parameters may be copied regenerated or otherwise reused in one or more cores or machines. Examples of SSL security parameters include identification of a secure port for SSL connection the level or strength of encryption the interval for session renegotiation enablement of host matching and location of private key. Furthermore reuse may include but are not limited to information and or parameters related to keys encryption certificates ciphers. authentication results and SSL version. Embodiments of these information and or parameters are described above in connection with .

The systems and methods disclosed can also be applied to state full SSL session failover in homogenous or heterogeneous systems. In some embodiments Active Standby deployment may be available where a SSL session established on an active node is cloned on a standby node. When failover happens the standby node can take over as the active node. The SSL clients may not need to re negotiate the SSL session as the new Active node already have the complete cloned session. The systems and methods disclosed can be further applied to external heterogeneous systems such as those with well defined authentication processes in place to identify the external device performing session cloning.

As discussed earlier to overcome limitations on transistor spacing and CPU speed increases many CPU manufacturers have incorporated multi core CPUs to improve performance beyond that capable of even a single higher speed CPU. Similar or further performance gains may be made by operating a plurality of appliances either single or multi core together as a distributed or clustered appliance. Individual computing devices or appliances may be referred to as nodes of the cluster. A centralized management system may perform load balancing distribution configuration or other tasks to allow the nodes to operate in conjunction as a single computing system. Externally or to other devices including servers and clients in many embodiments the cluster may be viewed as a single virtual appliance or computing device albeit one with performance exceeding that of a typical individual appliance.

Referring now to illustrated is an embodiment of a computing device cluster or appliance cluster . A plurality of appliances or other computing devices sometimes referred to as nodes such as desktop computers servers rackmount servers blade servers or any other type and form of computing device may be joined into a single appliance cluster . Although referred to as an appliance cluster in many embodiments the cluster may operate as an application server network storage server backup service or any other type of computing device without limitation. In many embodiments the appliance cluster may be used to perform many of the functions of appliances WAN optimization devices network acceleration devices or other devices discussed above.

In some embodiments the appliance cluster may comprise a homogenous set of computing devices such as identical appliances blade servers within one or more chassis desktop or rackmount computing devices or other devices. In other embodiments the appliance cluster may comprise a heterogeneous or mixed set of devices including different models of appliances mixed appliances and servers or any other set of computing devices. This may allow for an appliance cluster to be expanded or upgraded over time with new models or devices for example.

In some embodiments each computing device or appliance of an appliance cluster may comprise a multi core appliance as discussed above. In many such embodiments the core management and flow distribution methods discussed above may be utilized by each individual appliance in addition to the node management and distribution methods discussed herein. This may be thought of as a two tier distributed system with one appliance comprising and distributing data to multiple nodes and each node comprising and distributing data for processing to multiple cores. Accordingly in such embodiments the node distribution system need not manage flow distribution to individual cores as that may be taken care of by a master or control core as discussed above.

In many embodiments an appliance cluster may be physically grouped such as a plurality of blade servers in a chassis or plurality of rackmount devices in a single rack but in other embodiments the appliance cluster may be distributed in a plurality of chassis plurality of racks plurality of rooms in a data center plurality of data centers or any other physical arrangement. Accordingly the appliance cluster may be considered a virtual appliance grouped via common configuration management and purpose rather than a physical group.

In some embodiments an appliance cluster may be connected to one or more networks . For example referring briefly back to in some embodiments an appliance may be deployed between a network joined to one or more clients and a network joined to one or more servers . An appliance cluster may be similarly deployed to operate as a single appliance. In many embodiments this may not require any network topology changes external to appliance cluster allowing for ease of installation and scalability from a single appliance scenario. In other embodiments an appliance cluster may be similarly deployed as shown in or discussed above. In still other embodiments an appliance cluster may comprise a plurality of virtual machines or processes executed by one or more servers. For example in one such embodiment a server farm may execute a plurality of virtual machines each virtual machine configured as an appliance and a plurality of the virtual machines acting in concert as an appliance cluster . In yet still other embodiments an appliance cluster may comprise a mix of appliances or virtual machines configured as appliances . In some embodiments appliance cluster may be geographically distributed with the plurality of appliances not co located. For example referring back to in one such embodiment a first appliance may be located at a first site such as a data center and a second appliance may be located at a second site such as a central office or corporate headquarters. In a further embodiment such geographically remote appliances may be joined by a dedicated network such as a T1 or T3 point to point connection a VPN or any other type and form of network. Accordingly although there may be additional communications latency compared to co located appliances there may be advantages in reliability in case of site power failures or communications outages scalability or other benefits. In some embodiments latency issues may be reduced through geographic or network based distribution of data flows. For example although configured as an appliance cluster communications from clients and servers at the corporate headquarters may be directed to the appliance deployed at the site load balancing may be weighted by location or similar steps can be taken to mitigate any latency.

Still referring to an appliance cluster may be connected to a network via a client data plane . In some embodiments client data plane may comprise a communication network such as a network carrying data between clients and appliance cluster . In some embodiments client data plane may comprise a switch hub router or other network devices bridging an external network and the plurality of appliances of the appliance cluster . For example in one such embodiment a router may be connected to an external network and connected to a network interface of each appliance . In some embodiments this router or switch may be referred to as an interface manager and may further be configured to distribute traffic evenly across the nodes in the application cluster . Thus in many embodiments the interface master may comprise a flow distributor external to appliance cluster . In other embodiments the interface master may comprise one of appliances . For example a first appliance may serve as the interface master receiving incoming traffic for the appliance cluster and distributing the traffic across each of appliances . In some embodiments return traffic may similarly flow from each of appliances via the first appliance serving as the interface master. In other embodiments return traffic from each of appliances may be transmitted directly to a network or via an external router switch or other device. In some embodiments appliances of the appliance cluster not serving as an interface master may be referred to as interface slaves.

The interface master may perform load balancing or traffic flow distribution in any of a variety of ways. For example in some embodiments the interface master may comprise a router performing equal cost multi path ECMP routing with next hops configured with appliances or nodes of the cluster. The interface master may use an open shortest path first OSPF In some embodiments the interface master may use a stateless hash based mechanism for traffic distribution such as hashes based on IP address or other packet information tuples as discussed above. Hash keys and or salt may be selected for even distribution across the nodes. In other embodiments the interface master may perform flow distribution via link aggregation LAG protocols or any other type and form of flow distribution load balancing and routing.

In some embodiments the appliance cluster may be connected to a network via a server data plane . Similar to client data plane server data plane may comprise a communication network such as a network carrying data between servers and appliance cluster . In some embodiments server data plane may comprise a switch hub router or other network devices bridging an external network and the plurality of appliances of the appliance cluster . For example in one such embodiment a router may be connected to an external network and connected to a network interface of each appliance . In many embodiments each appliance may comprise multiple network interfaces with a first network interface connected to client data plane and a second network interface connected to server data plane . This may provide additional security and prevent direct interface of client and server networks by having appliance cluster server as an intermediary device. In other embodiments client data plane and server data plane may be merged or combined. For example appliance cluster may be deployed as a non intermediary node on a network with clients and servers . As discussed above in many embodiments an interface master may be deployed on the server data plane for routing and distributing communications from the servers and network to each appliance of the appliance cluster. In many embodiments an interface master for client data plane and an interface master for server data plane may be similarly configured performing ECMP or LAG protocols as discussed above.

In some embodiments each appliance in appliance cluster may be connected via an internal communication network or back plane . Back plane may comprise a communication network for inter node or inter appliance control and configuration messages and for inter node forwarding of traffic. For example in one embodiment in which a first appliance communicates with a client via network and a second appliance communicates with a server via network communications between the client and server may flow from client to first appliance from first appliance to second appliance via back plane and from second appliance to server and vice versa. In other embodiments back plane may carry configuration messages such as interface pause or reset commands policy updates such as filtering or compression policies status messages such as buffer status throughput or error messages or any other type and form of inter node communication. In some embodiments RSS keys or hash keys may be shared by all nodes in the cluster and may be communicated via back plane . For example a first node or master node may select an RSS key such as at startup or boot and may distribute this key for use by other nodes. In some embodiments back plane may comprise a network between network interfaces of each appliance and may comprise a router switch or other network device not illustrated . Thus in some embodiments and as discussed above a router for client data plane may be deployed between appliance cluster and network a router for server data plane may be deployed between appliance cluster and network and a router for back plane may be deployed as part of appliance cluster . Each router may connect to a different network interface of each appliance . In other embodiments one or more planes may be combined or a router or switch may be split into multiple LANs or VLANs to connect to different interfaces of appliances and serve multiple routing functions simultaneously to reduce complexity or eliminate extra devices from the system.

In some embodiments a control plane not illustrated may communicate configuration and control traffic from an administrator or user to the appliance cluster . In some embodiments the control plane may be a fourth physical network while in other embodiments the control plane may comprise a VPN tunnel or communication via one of planes . Thus the control plane may in some embodiments be considered a virtual communication plane. In other embodiments an administrator may provide configuration and control through a separate interface such as a serial communication interface such as RS 232 a USB communication interface or any other type and form of communication. In some embodiments an appliance may comprise an interface for administration such as a front panel with buttons and a display a web server for configuration via network or back plane or any other type and form of interface.

In some embodiments as discussed above appliance cluster may include internal flow distribution. For example this may be done to allow nodes to join leave transparently to external devices. To prevent an external flow distributor from needing to be repeatedly reconfigured on such changes a node or appliance may act as an interface master or distributor for steering network packets to the correct node within the cluster . For example in some embodiments when a node leaves the cluster such as on failure reset or similar cases an external ECMP router may identify the change in nodes and may rehash all flows to redistribute traffic. This may result in dropping and resetting all connections. The same drop and reset may occur when the node rejoins. In some embodiments for reliability two appliances or nodes within appliance cluster may receive communications from external routers via connection mirroring.

In many embodiments flow distribution among nodes of appliance cluster may use any of the methods discussed above for flow distribution among cores of an appliance. For example in one embodiment a master appliance master node or interface master may compute a RSS hash such as a Toeplitz hash on incoming traffic and consult a preference list or distribution table for the hash. In many embodiments the flow distributor may provide the hash to the recipient appliance when forwarding the traffic. This may eliminate the need for the node to recompute the hash for flow distribution to a core. In many such embodiments the RSS key used for calculating hashes for distribution among the appliances may comprise the same key as that used for calculating hashes for distribution among the cores which may be referred to as a global RSS key allowing for reuse of the calculated hash. In some embodiments the hash may be computed with input tuples of transport layer headers including port numbers internet layer headers including IP addresses or any other packet header information. In some embodiments packet body information may be utilized for the hash. For example in one embodiment in which traffic of one protocol is encapsulated within traffic of another protocol such as lossy UDP traffic encapsulated via a lossless TCP header the flow distributor may calculate the hash based on the headers of the encapsulated protocol e.g. UDP headers rather than the encapsulating protocol e.g. TCP headers . Similarly in some embodiments in which packets are encapsulated and encrypted or compressed the flow distributor may calculate the hash based on the headers of the payload packet after decryption or decompression. In still other embodiments nodes may have internal IP addresses such as for configuration or administration purposes. Traffic to these IP addresses need not be hashed and distributed but rather may be forwarded to the node owning the destination address. For example an appliance may have a web server or other server running for configuration or administration purposes at an IP address of 1.2.3.4 and in some embodiments may register this address with the flow distributor as it s internal IP address. In other embodiments the flow distributor may assign internal IP addresses to each node within the appliance cluster . Traffic arriving from external clients or servers such as a workstation used by an administrator directed to the internal IP address of the appliance 1.2.3.4 may be forwarded directly without requiring hashing.

In some aspects the present disclosure is directed towards methods and systems for SSL session management in a cluster system. A device or appliance intermediary between one or more client and servers may include a cluster system that comprises a group of nodes. Each of these nodes may comprise a multi core system and may host one or more processing engines PEs for handling packets. The present methods and systems can efficiently manage SSL sessions established across nodes and or cores including nodes having symmetric or asymmetric configuration. By interoperating between nodes within the cluster system the nodes can present a single node image to a user or device interfacing with the appliance. These methods and systems can use a distributed hash table DHT that may allow any core receiving a session resume reuse request to identify an owner code of the requested session. The distributed hash table can receive as input a key derived from a session identifier to output information about the owner core. Copies of the distributed hash table may be available to each core and or node and can be used to mark particular sessions that may be invalid or non resumable. Based on the has table the receiving core may request for session information related to the requested session. The receiving core may then establish a local cloned session of the requested session responsive to the session resume resuse request.

Referring now to one embodiment of a system for SSL session management in a cluster system is depicted. In brief summary the system includes an intermediary comprising a cluster system that facilitates and or processes communications between a client and a server over at least one communication session. The cluster may comprise any embodiment of features described above in connection with . Each node of the cluster may include a plurality of cores or packet processing engines PEs such as various embodiments of the cores or PEs described above in connection with sections B G. Each core may include a hash table which may comprise a copy or a portion of a distributed hash table DHT maintained within the cluster.

In some embodiments each node of the cluster may comprise one or more functionality of an appliance having multi core features such as embodiments of appliances described above in connection with at least . A pair of nodes may communicate or exchange messages between themselves using node to node N2N messages as discussed in section G. Each core or PE of a node may establish and or maintain a N2N channel or connection to each of the other nodes. The configuration of the nodes may not be symmetric. For example some nodes may comprise a larger number of cores and or have access to different resources or may comprise cores of different performance and or features than those of certain other nodes.

In some aspects SSL session management may require particular attention or handling in a cluster based system or architecture. A SSL session data structure can hold information that can be used to allow resumption or cloning of existing SSL sessions. A SSL session data structure can be built or replicated using certain session data that may be stored in a DHT. In some embodiments of the present systems SSL session resumption or reuse may be commonly used for example in applications involving secure communication. SSL session resumption or reuse may be used to reduce processing or communications load on a web server e.g. by avoiding or reducing full handshake processing.

In certain embodiments of a cluster system SSL sessions created or established on a particular core of a node may be private to or reserved for that core. Other cores of the same node as well as of different nodes may not be able to have direct access to session data and or session states of such an SSL session. Certain embodiments of the system may employ or be subject to processes or features that direct or distribute incoming packets or requests across nodes and or cores of the intermediary. By way of illustration and not intended to be limiting in any way the system may comprise RSS features e.g. as described above in connection with at least and or CITRIX data flow diagram DFD features. Such features may make it likely for or result in session resume reuse requests or connections going to a different core e.g. node core pair than the one owner core which established or allocated the session. For example RSS and or DFD may distribute packet or message load across nodes and or cores of the cluster system and may do so without regards to e.g. without the ability to determine the identity of the corresponding owner nodes and or cores.

In certain embodiments the intermediary provides a mechanism to identify the owner node core . A node core may receive a session resume reuse cloning request hereafter sometimes generally referred to as a request . Such a node core may hereafter sometimes generally be referred to as a receiving core . The request may include a session identifier for a requested session. The request may include a request to access a particular session e.g. established with a server or to be established with the server. The request may include a request to access features and or resources provided by or available through a session but may not necessarily comprise a request to access the requested session itself. The request may include a request to clone reuse and or resume a session e.g. resume a session that was established by another node and or core or to reuse a session established at the receiving core. The cloning and or resumption of a requested session on a non owner node and or core may involve having the cloned reused resumed session incorporating or making available certain features and or resources provided by or available through the requested session.

In some embodiments the request includes a Client Hello message or other handshaking message or packet. The request may include a message sent or conveyed from a client to the server and or intermediary. The request may include a message for accessing and or establishing a session or connection of any type or form e.g. a SSL session with the server and or intermediary. The request may include a session identifier which can include any type or form of information for identifying a session and or a type of session. The request may include a request for information that an owner node core may provide to an non owner node core e.g. to replicate a session structure consistent or compatible with a particular session or session identifier hereafter sometimes referred to as session ID .

By identifying the owner node core for a given session ID the cluster system can apply its N2N message passing mechanism to receive information enabling a receiving core to make or establish a copy or clone of the session. The receiving core may establish the copy or clone locally e.g. in or from the receiving core. The receiving core may establish the copy or clone in or from a cache of the requesting core.

The intermediary may include a hash table mechanism for identifying an owner of a session. The intermediary may in certain embodiments include a distributed hash table DHT . The intermediary may include a shared hash table e.g. in shared memory which may be shared or accessible by nodes and or cores. In some embodiments a DHT comprises a mechanism data structure infrastructure or system for storing and or retrieving data regarding sessions e.g. session identifier ownership information and session status such as validity resumability reusability . Each core of a node may have its own DHT table or a copy of the DHT. Each data item in a DHT may be indexed by an unique key. The unique key may be specified e.g. in form and or in value by an application which uses the DHT. For example in an SSL application a packet engine PE establishing or accessing a session may access or interface with a DHT using one or more predefined APIs which may be provided by the DHT.

In some embodiments a pair of is called a DHT entity. DHT entities may be stored in a DHT table. The data may include any information about a session such as owner core identification and or information for cloning a session. A DHT can identify determine or compute the identity of an owner of an entity or session based on the key. By having local or distributed copies of the DHT at each node core applications using DHT may not have to be aware of a location e.g. shared location for fetching and or storing the data that can be accessed. By way of example various operations can be made on a DHT including but not limited to the following embodiments 

In some embodiments a receiving core sometimes referred to as a requesting core can form or generate a key based at least in part on a session ID e.g. received from the client in the request . The receiving core can form or generate a key based at least in part on a unique identifier value of a vserver VIP or PE on which the receiving core received the request. For example the receiving core may apply a predefined transformation or encoding function scheme to any of the information to form a key.

In certain embodiments the data portion of a DHT entity may include one or more of e.g. at least the following information though not limited to these 

The following is a non limiting illustration of one embodiment of formats and or data structures for keys and data e.g. that can be used with DHT APIs for SSL 

In certain embodiments session creation or resumption reuse using a DHT within a cluster system may involve a number of steps that may be difference from that of a mere or typical multi core system. Some or all of the following steps may be described with respect to a front end side e.g. between a client and the intermediary . In general for example upon receiving a new SSL connection request e.g. native Client Hello or Client Hello with no session ID the cluster system may create and or assign a new session ID responsive to the request. The cluster system may e.g. call an operation dht put key data to install the requested session on the owner node core e.g. the core that was assigned or received the request for the new session.

On receiving a session resume reuse request e.g. a Client Hello with session ID the cluster system or receiving core may perform one or more of the following. If the requested session is present or identified on a local cache of the receiving core the receiving core may proceed to reuse the session. The receiving core may increment the reuse count e.g. to indicate the reuse resumption of the session. If the requested session is not present or identified on a local cache of the receiving core the cluster system or receiving core may e.g. call an operation dht get KEY to determine if the requested session is present or available on the owner node core .

If the requested session is present or available on the owner node core e.g. if the dht get response is positive it may mean that the owner node core still maintains the session and the owner may provide e.g. in the response session information for performing a resumption of the session on the current node core . If the requested session is not present or available on the owner node core e.g. if the dht get response is negative the session may have expired on the owner node core . In this case the current or receiving core can issue a new session ID may establish a session corresponding to the session ID and may add the session ID to the core s own cache. The receiving core may e.g. invoke an operation dht put KEY DATA to install the session on the owner node core .

Each session structure may be associated with a DHT entry in a DHT. If a session is to be freed or to expire the cluster system or owner core may e.g. use the DHT API to delete the DHT entry which may be updated to copies of the DHT at each node core . In some embodiments an owner session is a session which is installed by DHT using a dht put operation. Other sessions may be referred to as cached sessions or cloned sessions. As discussed above the core that establishes or installs a session e.g. calls the dht put operation may not be the owner of the session. Ownership of a session may be determined by a DHT based on the particular key e.g. formed by a receiving core .

In some embodiments cached sessions are created or established in response to an action of an non owner receiving core e.g. via the dht get key operation . A cached session may send heart beat signals or any other type of indication to the corresponding owner session or owner node core . This may ensure that the owner session is not deleted when it has cloned references sessions at other nodes or cores. Thus at any time for a given owner session there may exist multiple cached sessions.

In some embodiments on the backend side e.g. between the intermediary and the server the intermediary e.g. a Netscalar node may be the SSL client. A SSL web server or the server may issue a session ID. Each core e.g. of the cluster system may open a session to the backend server. There may be no requirement for session cloning. Each core may try to reuse the session to a backend server e.g. for a predetermined limit such as a maximum of 100 times or instances .

In session resume a cluster system may clone a SSL session across cores. On receiving a session reuse resume request on a receiving core the core may check for the session in the receiving core s local cache. If the session exists on the same core the session may be reused. If not the session may be cloned e.g. copied from the owner node core to the receiving or current node core . As discussed DHT may be used to facilitate or perform the cloning e.g. by invoking the dht get key operation. Cloning may not mean that an entire SSL session data structure has to be copied. The cluster system may need to copy only required or minimal information from the session data structure to honor the session resumption. For example the owner node core may perform a DHT lookup using the key as formed and received from the requesting core. The owner core may generate and send a response comprising data e.g. minimal data to recreate a requested session structure or features. In some embodiments session cloning may fail if the requested session does not exist e.g. has expired on the owner node core .

In certain embodiments each core may perform e.g. its own session ageing which may be irrespective of whether the corresponding session is local or copied from an owner core. The cluster system or owner core may invoke a session free function when references e.g. all SPCB references to the session have ceased or become zero. When a session free function is called a call may be made to an operation e.g. to a DHT API dht entry delete operation to check whether a DHT pointer associated with the session structure can be deleted. In one illustrative nonlimiting embodiment this operation may perform the following checks check whether the session is an owner session and the corresponding DHT entry has aged out or not. If not the operation may return a failure to the session free function. If the session is not an owner session the corresponding DHT entry can be deleted automatically and the operation may return a success to the session free function. If all cached sessions are deleted or freed the corresponding owner session may not receive any heart beat signals and the owner session may be deleted for example in a next function call to session free . An owner session may be deleted only after all the cached sessions are deleted.

In some cases e.g. in some front end cases the cluster system may determine that a session in not resumable. For example if any fatal alert is sent or received in connection with a SSL session the session may be marked e.g. by the owner core or the cluster system in the DHT as not resumable. All further SSL session resume requests corresponding to that session may be discarded or rejected. It may be helpful to recognize that in a single core system there is one copy of a session s session entry. Thus as soon as the session is marked not resumable the information is available for all subsequent session resume requests e.g. session not resumable 1. In a cluster system on the other hand a session entry is owned by one core owner core . Other node core s may have copies or access to the entry e.g. depending on which core received the session resume request. If the session is to be marked as not resumable in a core owner or non owner the information should be updated such that it is accessible to each core having a reference e.g. copy to the session. In some embodiments the cluster system uses a DHT API to perform the update.

The cluster system may includes a DHT API or operation sometimes referred to as dht update. When a session has a status change e.g. is marked not resumable on a core the core can send an dht update key oldvalue newvalue operation to the owner node core . The owner node core can send a broadcast message to nodes and or cores e.g. to all cores or to cores having a reference or cached session to update the oldvalue e.g. valid or resumable to newvalue e.g. not resumable expired or invalid . If for any reason the dht update operation s message cannot be conveyed across the cluster system can queue the corresponding session in a list and may retry or re invoke the same operation until the operation succeeds.

In some embodiments and in the case of backend SSL sessions for example each core may open a SSL session to the backend server. Since sessions may not be shared between the cores each core can maintain its session status e.g. not resumable for incoming requests. For example each core can mark its own local session as not resumable. Because the sessions are not shared across cores each core can maintain its own count of a maximum reuse limit of the session.

The cluster system may support re handshake operations. In some embodiments and in the front end for example a re handshale e.g. a SSL Re handshake may operate similarly on a core that owns a session as on a core having a reference copy. During re handshake a new session may be created on the core on which re handshake is taking place. The old session can still exists as the old session is not marked not resumable or invalid or expired .

The cluster system may support SSL data insertion. SSL data insertion involving client certificates may require a client certificate to be copied e.g. from the DHT or from the owner core to a core which has reference copy of the session. When session cloning is complete a client s certificate may be copied in addition to session data structure contents. Other pointers holding the Intermediate CA certificate chain sent by the client may not be copied in some embodiments. In some cases such pointers may not be valid on the core which does not own the session.

Referring now to one embodiment of a method for SSL session management in a cluster system is depicted. The method may include receiving by a first core of a first node a session reuse request e.g. Client Hello with session ID for a first session the request comprising a session identifier . The first core may determine that the first session is not identified in a cache of the first core . The first core may identify via a hash table an owner core of the first session using a key the key determined based on the session identifier . The first core or the cluster system may request for session data of the first session the session data for creating a second session cloned from the first session . If the response does not include the session data the first core may establish a new session responsive to the session reuse request . If the response includes the session data the first core may establish the second session cloned from the first session .

Referring to and in further details a core of a node e.g. a receiving core may receive a session reuse resume clone request e.g. Client Hello with session ID for a e.g. first session. The receiving core e.g. a first node core of a cluster system in an intermediary between at least client and at least one server may receive the request e.g. as discussed above in connection with . The receiving core may receive a request for reusing resuming cloning a SSL session e.g. between the client and the intermediary which may be referred to as a front end side session. The receiving core may receive the request comprising one or more packets which may be directed to or assigned to the receiving core by the intermediary the cluster system a node of the receiving core or a flow distributor mechanism or feature associated with the intermediary e.g. RSS and or DFD .

The receiving core may receive the request as part of a handshaking process e.g. a SSL handshaking process. The receiving core may receive the request the request comprising a client hello message. If the client hello message does not include a session identifier the receiving core may create or assign a new session identifier and may establish a session local to the receiving core s cache responsive to the request. In some embodiments the receiving core may receive the request the request comprising a session identifier or session ID. The session identifier may be used to identify the requested session.

Referring to and in further details the receiving or first core may determine that the e.g. first session is not identified in a cache of the receiving core. The receiving core may determine if the session is identified in a local cache of the receiving core. The receiving core may determine this based on the session identifier of the session for example. The receiving core may determine if any sessions are associated with the receiving core or its cache. The receiving core may compare or match the session identifier with those of sessions associated with the receiving core or its cache. The receiving core may determine that the session is not identified in a cache of the receiving core based on an absence of any sessions associated with the receiving core or its cache. The receiving core may determine that the session is not identified in a cache of the receiving core based on a comparison of the session identifier with those of sessions associated with the receiving core or its cache.

In some cases the receiving core may determine that the session is identified in a cache of the receiving core. The receiving core may determine that it is the owner code of the requested session. The receiving core may proceed to reuse the session e.g. if the session is valid reusable and or unexpired. If the session is invalid not reusable or expired the receiving core may re establish the session e.g. based on session data recovered from or stored for the session. If the session is invalid not reusable or expired the receiving core may establish a session e.g. a new session responsive to the request.

Referring to and in further details the receiving or first core may identify via a hash table an owner core of the first session using a key. The key may be determined based on the session identifier. If the receiving core determines that the session is not identified in a cache of the receiving core the receiving core may access a hash table for example a DHT as described above in connection with . The receiving core may access a hash table via an API which may include or support one or more functions or operations e.g. dht get as discussed above in connection with . The receiving core may compute calculate determine form or otherwise generate a key based on data comprising at least one or more of the session identifier and a unique identifier of an entity from at which the request is received e.g. a VIP PE node . The receiving core may form the key by applying a predefined function or transformation on the data.

The receiving core may use the key to index into the hash table which may be a copy or a portion e.g. a local copy of a distributed hash table of the cluster system. For example the receiving core may use the API to invoke an operation e.g. dht get operation to access the hash table. The hash table may output or provide an identification of the owner core based on the key. The receiving core may use the key to index into or otherwise access the hash table to determine if the session is valid resumable and or available at the owner core.

Referring to and in further details the receiving first core or the cluster system may request a response e.g. from the owner core or from the hash table for session data of the e.g. first session. The session data may be for creating a second session cloned from the session. In some embodiments the receiving core may request the response via the API e.g. as part of the dht get operation or step. Responsive to the operation e.g. using the key to index into or otherwise access the hash table the hash table or the owner core may return or provide a set of data. The set of data may include session data or data associated with the requested session. The session data may be used by the receiving core to establish a second session e.g. by cloning or making a copy of the requested session.

Referring to and in further details if the response does not include the session data the receiving core may establish a new session responsive to the session reuse resume request. In some cases the hash table may include a status of the requested session or information indicating that the session is invalid expired or not resumable. In such a situation the hash table may not respond or may not respond with the session data. The hash table may provide a response indicating that the requested session is invalid expired or not resumable.

If the requested session is expired the receiving core may attempt to establish or resume the session responsive to the session resume reuse request. The receiving core may create or assign a new session identifier and may establish or resume the session corresponding to the new session identifier responsive to the session resume reuse request. The receiving core may update the hash table with the new session identifier. The receiving core may install or initiate installation of the session at the owner core e.g. as determined via the hash table. The receiving core may update the hash table via the hash table API e.g. using a dht put operation discussed above in connection with .

If the requested session is invalid or not resumable the receiving core may establish a new session responsive to the session reuse resume request. The receiving core may create or assign a new session identifier and may establish a new session corresponding to the new session identifier responsive to the session reuse resume request. The receiving core may add the new session to the receiving core s cache. The receiving core may update the hash table with the new session. The receiving core may install the new session and or update the hash table via the hash table API e.g. using the dht put operation.

Referring to and in further details if the response includes the session data the receiving first core may establish a e.g. second session cloned from the first session. The hash table may provide data comprising the session data responsive to indexing using the key. The hash table may provide data comprising the session data responsive to a determination that the requested session is valid unexpired and available at the owner core. The hash table may provide a minimal set of data for cloning the session at the receiving core. The receiving core may clone or make a copy of the requested session based on the session data. The receiving core may establish a session data structure consistent with the requested session using the session data. The receiving core may establish the cloned session e.g. cached session in or from a local cache of the receiving core. The receiving core or cached session may provide heart beat signals to the owner core or owner session to indicate that the cached session has not aged out expired or been deleted.

In some aspects the present disclosure is directed towards methods and systems for deploying a spotted virtual server vserver in a cluster system. The cluster system may include a cluster of nodes or devices as described above in connection with . Each of these devices or nodes hereafter sometimes referred to interchangeably as devices or nodes may comprise a multi core system and may host one or more processing engines PEs for handling packets. The cluster system may provide specific application services such as content switching load balancing and SSL VPN session establishment and or management. These services may be provided via a virtual server or a group of related virtual servers deployed within the cluster system. The clustered configuration of devices may often be symmetrical or homogeneous and any or most of the nodes may be configured to provide or support such application services sometimes in place of another node. Therefore a vserver may be hosted established or striped across the nodes of a cluster system. The present methods and systems allows for deployment of a virtual server on a subset of the devices instead of being striped across all nodes of a cluster.

In a cluster a vserver may be typically striped across all the nodes in the cluster. However in certain scenarios it may be desirable that a vserver be spotted on a subset of the nodes in the cluster. For example specific applications such as SSL VPN establishment and management and global server load balancing GSLB may be deployed as a spotted solution on a cluster. One aspect of a spotted vserver is the placement of the vserver. Placement may identify a list of nodes or devices where the spotted vserver resides and or executes. Placement may identify a list of nodes or devices where the spotted vserver is hosted deployed and or replicated. Placement may identify a list of nodes or devices included in a virtualization of resources to execute or provide the vserver. In some embodiments each of the devices identified by the placement may execute the vserver a portion of the vserver or a copy of the vserver. Placement of the vserver may include automatic placement and manual placement. In automatic placement each spotted vserver may be placed automatically by a configuration coordinator or cluster configuration owner CCO . The CCO may reside and or execute on one or more devices of the cluster.

Referring to one embodiment of a system for deploying a spotted vserver in a cluster system is depicted. In brief overview the system includes a cluster or devices or nodes and one or more vservers. One of the vservers may be placed on a subset of devices within the cluster e.g. spotted vserver A. In this example a node group comprising Node 1 and Node 2 may be defined for the spotted vserver. An owner core may be identified for establishing a session of the vserver and for creating an entry in a DHT corresponding to the session. The entry may also include information about the node group.

In some embodiments IP addresses such as vserver IP addresses VIPs may be defined on a cluster. Such IP addresses may be defined to be available on all the nodes of the cluster e.g. striped addresses or only on a single or specific nodes e.g. spotted addresses . Traffic distribution in a cluster may depend on the type of IP addresses. For example traffic may be directed to a specific spotted IP address or to any node according to a striped IP address. A striped IP address may be active on all the nodes of the cluster. IP addresses configured on the cluster without specifying an owner node may be active on all the cluster nodes. A spotted IP address may be active on and owned exclusively by one node or a subset of nodes. An IP address may be assigned to a spotted vserver and may be referred to as a spotted VIP. The spotted VIP may be assigned to each of the nodes in the identified node group within which the vserver A is placed.

In manual placement a user such as an operator or administrator of the cluster system or appliance may specify or provide the placement for each spotted vserver. The user may specify or identify the placement or configuration of one or more spotted vservers via any type or form of interface such as a command line interface CLI or a graphical user interface GUI . By way of illustration one embodiment of commands instructions or configuration for adding binding updating and or deleting spotted vservers and their placement are as follows 

Configuration of a spotted vserver may includes a number of steps one embodiment of which includes the following 1 add a striped vserver 2 create a node group 3 bind nodes to the node group and 4 bind the vserver to the node group. A first step may create a striped vserver. A second step may add a named entity for a group of nodes. This step may take an optional parameter strict option. strict option can ensure that vservers bound to this node group can stay on the nodes included in the node group. A third step may bind a group of nodes which can be added one at a time or provided as a list to the node group. Step 4 may convert a striped vserver into a spotted vserver by binding the vserver to the node group. The latter step may take an optional parameter force option. force option can ensure that the vserver is bound to the node group and may ensure that all dependent vservers are migrated to this node group. In certain embodiments a configuration may be rejected e.g. by the cluster if both the strict and force options are applied. In certain embodiments a configuration may be rejected if there are any dependent vservers and if the strict option is applied but not the force option.

By way of illustration one embodiment of commands instructions to configure a spotted load balancing LB vserver vi that is placed at nodes 1 2 and 3 is as follows 

by way of illustration one embodiment of commands instructions to configure a spotted content switching CS vserver cs1 and spotted LB vservers v2 and v3 bound to cs1 with cs1 v2 and v3 placed at nodes 1 3 and 5 is as follows 

by way of illustration one embodiment of an approach to configure a migration of all vservers bound to a same or given node group may include updating the nodes in that node group. Suppose there is a CS vserver configured as shown in the preceding example. To remove node 3 from the node group and to add nodes 2 4 and 7 to the group one embodiment of commands instructions is as follows 

By way of illustration a user may try to configure a backup vserver is as follows. Suppose there is an LB vserver v4 bound to node group v4 group that has nodes 2 4 and 6. And suppose there is another LB vserver v5 bound to node group v5 group that has nodes 1 3 and 6. A user may attempt to configure v5 as a backup vserver of v4 using the following command set lb vserver v4 backupVserver v5. In some embodiments this command or configuration may be rejected e.g. because v4 and v5 are placed on different nodes.

By way of illustration of the Force option suppose a CS vserver is configured as discussed in the spotted vserver example A. The following commands configuration may be rejected because v3 has dependent vservers 

This command may first unbind v3 v2 and cs1 from node group cs1 group and may bind these vservers to the node group new group. The force option may ensure that v3 v2 and cs1 are configurationally moved to the new node group.

In some embodiments a node may be added or removed e.g. from a cluster or a cluster configuration . If such a node e.g. to be added is bound to a node group the cluster or CCO may check if the node is present in the cluster configuration. If the node is present in the cluster configuration the cluster or CCO may allow the configuration. Otherwise the cluster or CCO may reject the configuration.

When a node N is removed from the cluster configuration e.g. using rm cluster node N applied on CCO or rm cluster instance applied on N the cluster or CCO may check if N is part of a node group that has vserver bindings. If N is part of a node group that has vserver bindings then the cluster or CCO may reject the command. If N is part of a node group that does not have any vserver bindings the cluster or CCO may allow the command. And the cluster or CCO can remove N from the node group. If N is not part of any node group the cluster or CCO may allow the command.

In certain embodiments a plurality of vservers may be associated and some of the vservers may be dependent on a specific vserver. A vserver may be related to or associated with other vserver s either directly or indirectly. In a spotted deployment the cluster or CCO may require all related vservers to be placed in the same node group. This requirement may be to ensure that any statistics that is dependent on the related vservers are present locally and do not require any aggregation or a query to the CCO. When a vserver is bound to an association of multiple vservers the cluster or CCO may check if the node groups of the vserver and the association are same. If the node groups match the association the cluster or CCO may accept the configuration. Otherwise. the cluster or CCO may reject the configuration. An example of successful configuration of an association is illustrated in the spotted vserver example A.

If one vserver in an association is migrated with force option as illustrated in an earlier example all vservers bound to that association may move to the new node group. If any vserver is migrated with force option the cluster or CCO may migrate all vservers that are related either directly e.g. as part of a CS vserver or a group vserver or indirectly e.g. an association of a backup vserver and its members policy bindings etc. to the new node group. Towards this end the cluster or CCO may leverage on or use reference counts and or a dependency graph. The reference counts may determine the number of direct dependents of a vserver. The dependency graph may identify or map the relationships between vservers.

The cluster or CCO may maintain or incorporate a reference count RC in the vserver structure. When a vserver V is added there may be no dependents or relationships. Therefore RC of V 0. When V is bound to an association e.g. a CS or group vserver the cluster or CCO may update the reference counts of V and the association. Suppose V is bound to a CS vserver X the cluster or CCO may increment the reference counts of V and X by 1.

When a vserver VB is assigned as a backup vserver for V the cluster or CCO may increment the reference counts of V and VB by 1. If there is a policy expression that includes vservers V1 V2 . . . Vi then the reference counts of each vserver in this expression may be incremented by 1.

In some embodiments a dependency graph or table hereafter sometimes illustratively referred to as a table may provide a representation of vserver relationships in a database. The cluster or CCO may maintain a table for vserver relationships. The table may include a row for each vserver. Each vserver entry may includes a list that may hold unique identifiers of vservers related to it. By way of illustration the cluster or CCO may build or map vserver relationships as follows. When a vserver u is added the vserver may have no dependents. As a result the dependent list of u may be empty. If u is bound to an association e.g. to a CS vserver X the cluster or CCO may update the dependent list of u and X. The cluster or CCO may add X to the dependent list of u and vice versa. If a vserver Ub is assigned to u as a backup the cluster or CCO may add u to a dependent list of Ub and vice versa. If there is a policy expression that includes vservers U1 U2 . . . Ui then the dependent list of each vserver in this expression may includes all the other vservers.

By way of illustration and referring to the example embodiment of vserver relationships in there may be two CS vservers X and Y. LB vservers a b and c may be bound to X. LB vservers c d and e may be bound to Y. Y may be assigned as a backup vserver for X. Vserver a may be backed up by vserver f. Vserver f may be backed by vserver g and g may be backed by vserver e. The reference counts for each vserver are illustratively shown in . depicts one embodiment of a representation of a dependency graph corresponding to

In certain embodiments or scenarios a node may leave or join a cluster. Consider the following configuration for illustration and discussion 

In some embodiments or scenarios migration of spotted vservers may occur. A first type of migration may occur when nodes in a node group are updated. In this scenario nodes in a node group are updated e.g. by a user . As a result all vservers bound to the corresponding node group may migrate to the new set of nodes. An example of this scenario is discussed above in example B.

In a second case migration may occur if a different node group is bound to a spotted vserver. In this scenario. A user may bind a new or different node group to a spotted vserver e.g. already bound to another node group . Consider the following configuration 

If we execute the following command to move v1 to node group ng2 which has nodes 2 4 and 5 bind nodegroup ng2 lbvserver v1 this command may be rejected since LB vserver v1 is already bound to node group ng1. To move v1 to node group ng2 the cluster may unbind v1 from node group ng1 e.g. effectively making v1 striped and then bind v1 to the new node group ng2 

The above commands first unbinds v1 from node group ng1 and then binds v1 to node group ng2. However if a reference count of v1 is non zero i.e. RC 0 then the unbind command may be rejected. As a result v1 may remain in node group ng1 as there are related vservers of v1 that are bound to ng1.

Instead of specifying an unbind command followed by a bind command an alternative is to use the following command e.g. to simplify the command line for migration of spotted vservers bind nodegroup ng2 lbvserver v1 force . This command may e.g. internally remove the v1 binding with node group ng1 and then may bind v1 with node group ng2.

If RC 0 then the following approach may be used to migrate v1 and all its dependents to the node group ng2. Referring again to the embodiment of the vserver dependency graph shown in and the representation shown in assume initially that all vservers are bound to node group ng1. Node group ng1 may be configure or defined as follows.

Towards this end the cluster or CCO may perform a depth first search DFS on the dependency graph and migrate all dependent vservers to node group ng2. The process may start with vserver b. The cluster or CCO may move b to the new node group. Then the cluster or CCO may pick the first child in the dependency list of b. In this example the cluster or CCO may pick vserver X. the cluster or CCO may move X to the new node group and subsequently pick the first child of X which is a. If the cluster or CCO picks a node that is already moved the cluster or CCO may proceeds to the next child. If all vservers in the dependency list of a vserver is moved to the new node group the cluster or CCO may backtrack to the parent of that vserver. Continuing in this fashion the cluster or CCO may move all dependent vservers to the new node group. One illustrative embodiment of the pseudo code for depth first search based migration of dependent vservers is as follows 

Based on the complexity of the above approach users or operators may identify the list of dependent vservers and bound them to the same node group. This node group may not be used for other vservers. If the user or operator desires to migrate the vservers to a new set of nodes all the user or operator needs to do is to update the node group. An example is as discussed above in Example B.

If a user executes the following command bind nodegroup ng2 lbvserver b force all vservers X a and b may move to new node group ng2. Only nodes in node group ng1 may be strictly bound to the group and not the vservers. Accordingly the above command s may be accepted.

The spotted depth of a vserver v bound to a node group with D nodes is D. Vservers may be classified into the following classes i D 1 where v is active on only one node and ii D 1 where v is active on more than 1 node.

In some embodiments D 1 may be referred to as an Active Backup Configuration. This is a special case where the vserver is active on only one node. In order to protect the vserver from nodes leaving the cluster the cluster or CCO may provision a PRL backup node Npr1. If the dependency list of the vserver is empty one may use an unique identifier of the vserver to determine Npr1. If the dependency list is not empty one may use an unique identifier of the node group to determine Npr1. Npr1 is a special node in the case of spotted depth 1. Npr1 may not take traffic as long as the configured primary node e.g. the node included in the node group is active. All sessions e.g. DHT entries may be replicated to Npr1. When the primary node goes out of the cluster Npr1 may receive traffic for this vserver. When Npr1 is handling traffic there is no backup. When the primary node joins rejoins the cluster the primary node can take the responsibility of handling traffic again. If a node group is configured with strict option the cluster or CCO may not pick a PRL backup for any vservers bound to that node group. If a vserver v is bound to a strict node group with 1 node there is no PRL backup provisioned for v. As a result when the primary node goes out of the cluster the state of v may be marked as down .

In some embodiments D 1 may be referred to as an Active Active Configuration. If a vserver is bound to a node group that includes more than 1 node all the nodes in the node group may take traffic. In other words all nodes in the node group may actively participate in handling traffic for the vservers bound to that node group. Additionally the sessions e.g. DHT entries may be replicated or backed up among these nodes. If any node in the node group exits the cluster a backup may be chosen to substitute the missing node.

If a node group is configured with strict option the cluster or CCO may not pick a PRL backup for any vservers bound to that node group. As long as there is one active node in the node group the vservers bound to that node group may continue to handle traffic. The state of those vservers may remain up .

The cluster CCO may additionally place v1 at nodes 1 and 4. As a result v1 may become active on nodes 1 3 and 4. All three nodes may handle traffic for v1 and backup sessions e.g. DHT entries among themselves.

In some embodiments a transition may occur from D 1 to D 1. When nodes are removed from a node group such that the number of nodes becomes 1. The number of nodes cannot be zero as long as there are vservers bound to it. The vservers bound to the node group can have a spotted depth of 1. In other words the vservers transition from an active active configuration to an active backup configuration. As a result the cluster CCO may pick a PRL backup node Npr1 for the vservers e.g. if the node group is not strict . Npr1 may not handle traffic as long as the primary node is active.

In some embodiments a transition may occur from strict binding to not strict binding or vice versa . Consider the following configuration in which node group n1 is added with strict option and nodes 3 4 and 5 are bound to the group 

In some embodiments a transition may occur from a striped vserver to a spotted vserver and vice versa . By the nature of configuration when a vserver is added it may be striped by default. The vserver becomes spotted when it is bound to a node group. We may apply the approach discussed earlier to make all dependent vservers spotted. Consider a striped LB vserver v with RC O. To make v and all its dependent vservers spotted on node group ng1 we may use the following command bind nodegroup ng1 lbvserver v force. On the other hand when a vserver is unbound from a node group it may become striped. We may transition all dependent vservers to striped. Consider a spotted LB vserver v with RC 0 on node group ng1. To make v and all its dependent vservers striped we may use the following command unbind nodegroup ng1 lbvserver v force.

In some embodiments a cluster may support spotted services as distinguished from spotted vservers. The configuration of a spotted service may incorporate features similar to that of a spotted vserver. For example we may define a node group which is a named entity for a list of nodes. Then a user may bind a service to a node group to make the service spotted. When a spotted service is bound to a vserver the vserver may be made spotted to the node group of the service. If a spotted service e.g. on node group ng1 is bound to a spotted vserver e.g. on node group ng2 the dependencies should be handled properly. A spotted vserver may be dependent on other vservers. Additionally a spotted vserver may be dependent on other spotted services e.g. bound the same node group ng2 . As a result binding a service may require migration of vservers and or services if any and where possible .

In certain embodiments when a spotted vserver is created or added the vserver IP address VIP and or port may be registered with a distributed flow distributor DFD . A DFD may be a module or service that controls how traffic flow can happen in the cluster. This may be achieved using an API e.g. a ReqisterService ps API that takes as parameters processing set and replica set . In the case of D 1 processing set may identify the node bound to the node group. If the node group is not strict then the replica set may identify the PRL backup node. When the primary node e.g. the node bound to the node group is active DFD may steer the packet to that node. When the primary node is down DFD may steer the traffic to the node in the replica set.

In the case of D 1 processing set may identify nodes bound to the node group. If a node N goes out of the cluster then we may pick a node e.g. using PRL to replace N. The processing set may be updated to include the replacement node. When N re joins the cluster processing set may be updated again. The replacement node may be removed and N may be added back. However if the node group is strict we do not pick any replacement nodes using PRL. The processing set can be the same as the nodes in the node group.

In case of a striped vserver an RegisterService API can be invoked to register the VIP and or port with DFD. DFD may steer traffic for this VIP and or port using PRL.

In certain embodiments when a node group is updated or modified all vservers bound to that node group may re register with DFD to update the processing set and replica set . When a new node group is bounded to a spotted vserver re registration with DFD may take place to update the processing set and replica set . When a vserver is unbound from a node group the vserver may becomes striped. A RegisterService API may be called to register the VIP and or port with DFD. DFD may then steer traffic for this VIP port using PRL. In certain embodiments when a vserver is deleted the VIP and or port is un registered from DFD.

In a cluster system supporting spotted vservers the corresponding DHTs are configured to be spotted aware. In a spotted deployment DHT operations on a DHT entry created for a spotted vserver may be limited to the nodes in the node group of the corresponding vserver. For example. when a session is created for a spotted vserver a DHT entry may also be created. This DHT entry may be replicated at one of the nodes bound to the node group of that vserver.

In some embodiments the cluster system may include a node mask for PRL. Under a DHT system operations may be based on the PRL. Generating a PRL may include computing a permutation of the nodes based on a hash of a key provided by the application SSL VPN LB or CS . The PRL generation may takes a bitmask of nodes to use to compute the permutation. The following are illustrative embodiments of bitmasks that may be used for various deployments i Striped the node bitmask may identify the current OVS clGetCurrOvs ii Spotted D 1 the node bitmask may identify the node bound to the node group of the vserver for which the session and the DHT entry is created it may also include the PRL backup node if the node group is not strict iii Spotted D 1 the node bitmask may identify the nodes bound to the node group of the vserver for which the session and the DHT entry is created.

To support spotted vservers DHT entries APIs and functionality may be extended to incorporate more features or data. The DHT entry may include additional fields e.g. entityID and spotted mask. The first field entityID may identify the global unique identifier. In case of LB this identifier may identify the global unique identifier of the vserver for which the session and the DHT entry is created. The field spotted mask may identify the nodes bound to the node group of the vserver. For D 1 a field real owner may be included in the entry to identify the owner node of the spotted entity. Regardless of whether the owner node is active or down real owner reflects the node bound to the node group of the vserver. For a striped scenario PRL may identify the owner nodes and the replicas. In some embodiments real owner and spotted mask may be set to 1 for an entry corresponding to a striped entity.

The cluster system may support DHT APIs that are spotted aware e.g. dht get or create and dht put . These APIs may take the following parameters i a spotted flag and ii a spotted mask. In a striped scenario spotted mask may be configured as 1. The spotted flag may be used only for the D 1 scenario. It may indicate whether the entry is created on the owner node e.g. NS DHT SPOTTEO OWNER or the backup node e.g. NS DIIT SPOTTED BACKUP as identified by the node bound to the node group of the vserver. If the spotted flag indicates that the entry is being created at the owner node the DHT may set the real owner to the local node. If the flag indicates that the entry is being created at the backup node the mask provided by the application may identify the configured owner of the corresponding spotted entity. In such case DHT may set the real owner from the mask and the spotted mask to indicate the bitmask of the local node e.g. denoting the configured backup of the spotted entity . The DHT may send a request to the owner core of the owner node corresponding to the key to create an entry for it.

Once an entry is created the owner core at the owner node may try to replicate the entry to its replica nodes. Regardless of the deployment scenario e.g. spotted or striped PRL may identify the replica nodes. However as discussed earlier the node mask for PRL may differ. In a striped scenario the node mask may include the current OVS of the cluster e.g. via clGetCurrOvs . On the other hand in a spotted scenario the node mask is obtained as clGetCurrOvs spotted mask e.g. the current active nodes from the node group and any substitute nodes . In a spotted scenario the process may include a determination of replication can be performed or not. Cases in which replication of an entry may be disallowed may include i D 1 the number of active nodes in the node group of the vserver is 1 and the node group is strict ii D 1 the node group is strict iii D 1 the entity is created at the backup node as DFD steered traffic to the backup node . In these cases the DHT may not attempt to replicate the entry. For all other cases The DHT may replicate the entry.

In some embodiments DHT hunting may be performed. A node bound to the node group of the vserver may re join the OVS of the cluster. If a DHT create request lands on this node the DHT may hunt to find an existing entry at other active nodes bound to the node group. If the DHT does not find the entity in the cluster the DHT may make a new decision and return it to the requestor. Otherwise the DHT may return the restored entry to the requestor. In the case of D 1 if the create request lands on the PRL backup node of the spotted vserver e.g. the configured node in the node group is down and the owner core does not have a corresponding entry in its local cache then the entry may not exist anywhere else in the cluster. As a result the DHT may not hunt for the entry. Rather the DHT may make a new decision and returns the entry to the requestor.

In some embodiments a spotted mask may be updated. When the node group of spotted vserver is updated or the vserver is bound a new node group the corresponding DHT entries may be updated. This may be done in order to keep the spotted mask of the DHT entries in sync with the configuration. Consider the following configuration 

As a result the nodes in node group n1 may be 0 1 3 and 4. The spotted mask of DHT entries for v1 may now be 0x18 00011011 . On the other hand if we bind a new node group n2 the spotted mask of DHT entries may change. For example consider the following configuration 

To update the spotted mask a background task may be used. When node group of a vserver is updated e.g. the list of nodes is changed in the node group or the vserver is bound to new node group the application may call a DHT callback to update the spotted mask of the vserver. The DHT may update each entry via the DHT background task with the new spotted mask. Towards this end we may proceed according to the following options 

Option 1 DHT may maintain a small hash table that maps the vservers to the new spotted masks for vservers that are not updated completely in DHT. The DHT may maintain a mapping from global unique entityID to spotted mask for pending updates. The background task may walk the node ordered list of DHT entries and may check if the entityID matches with any of the IDs in the pending entity update table. If there is a match the DHT may check if the spotted mask needs to be updated.

Option 2 The background task may traverse or walk the node ordered list of DHT entries and may call an API to retrieve the spotted mask for the corresponding entityID. The DHT may check if the spotted mask needs to be updated. If the spotted mask needs to be updated we may proceeds as follows 

 i For an owned entry the spotted mask may be updated. If this node is not an owner node anymore then the entry is moved to a cached bucket of the new owner node. Eventually the entry may time out and may be purged from the table. If the local node core is the owner node core for that entry then the replica node may be checked if it changes. If the replica changes a replica request may be sent to the new replica.

 ii For a replica entry the spotted mask may be updated. If this node is no longer in the spotted mask the entry may be moved to the cached bucket of the owner node of the entry. If the local node core is the replica node owner core for that entry this node is checked if it is still a replica. If the local node is still the replica then nothing has to be done. Otherwise the entry may be moved to the cached bucket of the owner node. Eventually this entry may time out and may be purged from the table.

 iii For a cached entry the spotted mask may be updated. Eventually the entry may be purged from the table.

In some embodiments a node group may be configured under strict binding or as a strict node group. If a vserver is bound to a strict node group the vserver may stay remain in the active nodes of the node group. If one or more nodes in the node group exit from the OVS the vserver may reside only on the remaining active nodes. There may be no backup for the missing exited nodes.

In certain embodiments the cluster system supports spotted vservers of depth larger or equal to 1 up to the number of nodes in the cluster. For D 1 active backup configuration the vserver is active on only node. However. if the node group is not strict the system may provision a backup node. This backup node may be determined using a PRL based on an unique identifier of the node group. The backup node may not take traffic if the primary node e.g. the node bound to the node group is active. The backup node may act as a replica node for DHT to replicate any entries created for this vserver. When the primary node exits the cluster the backup node can assume responsibility for traffic in place of the primary node.

For D 1 active active configuration the vserver may be present on more than one node. All active nodes bound to the node group of the vserver can receive traffic. The replica node for DHT entries may be selected among the active nodes. In case of dynamism or node changes if the node group is not strict a replacement node may be chosen for each missing exited node in the node group as a substitute. If the configured nodes e.g. exited nodes re join the cluster the vserver may be removed from the replacement substitute nodes and placed at the active e.g. rejoined nodes bound to the node group.

In certain embodiments and as discussed earlier migration of spotted vservers may occur. A vserver v may be bound to a node group ng1 with nodes N1 N2 . . . ND. To migrate v to new set of nodes n1 n2 . . . nD the node group may be updated with the new set of nodes for example as discussed above in connection with Example B. The system may reject binding a spotted vserver to new node group. The system may reject binding a vserver with reference count RC 0 to a node group. In other words if the vserver has any dependencies or relationships the system may reject binding of that vserver to a node group. To establish relationships between vservers the system may make all vservers in a dependency graph spotted and then build the relationships.

In some embodiments to make a spotted vserver striped the system may reject an unbinding of the vserver from the node group if the reference count is not 0. To perform unbinding from a node group the system may remove all relationships from a dependency graph of the vserver make the vservers striped e.g. unbind the vservers from the node group and then build the relationships again.

In certain embodiments migration of dependent vservers may occur. When a spotted vserver is bound to a new node group the system may migrate that vserver and all its dependents e.g. from the corresponding dependency graph to the new node group. The system may remove restrictions imposed for building associations and moving from spotted to striped deployment and vice versa . In some embodiments the system and method provide automatic placement of spotted vservers provided spotted depth.

Referring now to one embodiment of a method for deploying a virtual server on a subset of devices in a cluster of devices is depicted. The method may include a first device of a cluster of devices intermediary between at least one client and at least one server identifying a first virtual server to establish on one or more devices of the cluster . The first device may associate to the identified virtual server a group comprising a subset of devices in the cluster of devices . The cluster may establish the first virtual server on each device in the group responsive to associating the group to the first virtual server . Each virtual server on each device of the group may be assigned a same internet protocol address.

Referring to and in further details a device e.g. a first device of a cluster of devices intermediary between at least one client and at least one server identifying a vserver e.g. a first virtual server to establish on one or more devices of the cluster. The cluster of devices may reside in an appliance gateway or other device in a network intermediary between at least one client and at least one server. An administrator or a configuration of the cluster may identify the device to facilitate or manage establishment of a virtual server in the cluster. For example the administrator or configuration may identify and or establish a configuration coordinator or a cluster configuration owner CCO on the device. The CCO may identify the virtual server to establish for example upon start up of the host appliance or the cluster of devices. In some embodiments the e.g. first device is selected by default or randomly from the cluster of devices to identify the vserver. The device may identify the virtual server to establish based on a configuration or a configuration update and or based on application of one or more policies e.g. responsive to receiving an external request . The device may identify the virtual server to establish based on a request for a specific service or application e.g. load balancing content switching or SSL VPN .

The e.g. first device or CCO may identify the virtual server to establish as a striped virtual server or a spotted virtual server. The device or CCO may identify the virtual server based on a request or configuration for one or more related services or applications for example content switching with distributed load balancing. In the latter example the device or CCO may identify the virtual server as a content switching virtual server which may be related to one or more dependent vservers e.g. load balancing vservers .

The e.g. first device or CCO may determine whether to establish the vserver as a striped vserver or a spotted vserver. The device or CCO may determine whether to establish a striped vserver or a spotted vserver based on the corresponding service or application e.g. SSL VPN or GSLB . The device or CCO may determine whether to establish a striped vserver or a spotted vserver based on one or more of the structure or architecture of the cluster e.g. heterogeneous or homogenous devices nodes the level of parallelism and or throughput required in providing a corresponding service application the configuration of active inactive nodes in the cluster present projected availability of nodes in the cluster and user specified instructions or configuration e.g. to dedicate or allocate specific nodes to a corresponding service application . In some embodiments the identified first vserver is striped by default and the first device may determined whether to configure the first vserver as a spotted vserver.

Referring to and in further details the e.g. first device may associate to the identified virtual server a group comprising a subset of devices in the cluster of devices. The group may comprise one or more of the devices in the cluster of devices. The device may determine placement of the vserver within the cluster of devices. The device may determine the nodes devices within the cluster of devices on which the vserver is to reside or be active. The device may identify the group comprising the subset of devices in the cluster of devices each of the devices in the cluster comprising a plurality of processing cores. The device may select or identify the subset of devices based on directives or a configuration e.g. provided by a user . The subset of devices may be identified for example based on one or more of the structure or architecture of the cluster e.g. heterogeneous or homogenous devices nodes the level of parallelism and or throughput required in providing a corresponding service application the configuration of active inactive nodes in the cluster and present projected availability of nodes in the cluster.

The device may bind the vserver to this group or subset of devices. In some embodiments the device may bind or associate to the identified virtual server a group comprising a single device e.g. for a node group depth of 1. The device may bind or associate to the identified virtual server a group comprising multiple devices up to a node group depth of Nc where Nc is the number of devices in the cluster. The e.g. first device may bind or associate to the identified virtual server a group comprising all devices in the cluster the identified virtual server thereby comprising a striped vserver. The device or cluster may assign or identify an IP address to the vserver which may be referred to as a spotted VIP. The device or cluster may assign or allocate the spotted VIP to each device node in the identified node group within which the vserver A is placed.

In some embodiments the cluster or the device e.g. first device may receive a request to establish the first virtual server. The request may include a key e.g. provided by the corresponding application . The device may determine an owner device for the vserver. The first device may determine based on the key a first core of an owner device in the group for establishing the virtual server. The cluster or the first device may request or instruct the first core to create an entry for a session of the virtual server in a hash table e.g. DHT . The first core may create a DHT entry incorporating one or more features of DHT entries described above in connection with at least . The owner core may include in the entry information about the node group e.g. an identification of the subset of the devices in the group. In some embodiments the entry may include a listing of the nodes devices or a reference or identifier of the node group.

Referring to and in further details the cluster may establish or configure the virtual server on each device in the group responsive to associating the node group to the virtual server. The cluster may deploy host place replicate or execute the virtual server on each device in the node group. The cluster may place or execute the virtual server across all devices in the node group. Each of the in the node group may execute the vserver a portion of the vserver or a copy of the vserver. Each virtual server on each device of the group may be assigned a same internet protocol address e.g. spotted VIP . Each device of the group may share the same VIP of the vserver. Communications directed to the vserver may be received at one or more devices of the node group based on the shared VIP.

The cluster may allow each device of the group to receive traffic if the group comprises more than one device. The cluster may configure the vserver to be active across all devices of the group. The cluster may replicate a session of the vserver at each device of the group if the group comprises more than one device and may allow each device of the group to receive traffic corresponding to the session. For example the cluster or CCO may request or instruct one or more cores in each node group member to perform one or more of request session information from the owner core establish a copy of the session e.g. based on the session information receive a packet associated with the session and process the packet. The cluster may replicate a hash table entry for the session at each remaining device of the group if the group comprises more than one device. For example the cluster or CCO may request or instruct one or more cores in each node group member to update a local cache or DHT with an entry for the session.

In some embodiments a device of the node group may receive a request from a client e.g. to access the session. The request may include the key discussed earlier. The device may provide responsive to the request information about the session via the hash table based on the key included in the request. The device may use the key to hash into the DHT to retrieve the session information for example as discussed above in connection with .

In certain embodiments the CCO or cluster may establish another vserver e.g. a second virtual server within the identified group the second virtual server comprising a virtual server dependent on the first virtual server. For example the second vserver may comprise a LB vserver dependent on or related to the first vserver which comprises a CS vserver. The CCO or cluster may establish a plurality of vservers related to the first vserver within the identified node group to which the first vserver is bound.

In certain embodiments the CCO or cluster may identify a back up device for the e.g. first device if the group comprises only one device. The back up device may be identified from the cluster of devices e.g. based on a PRL as discussed earlier . In some embodiments CCO or cluster may identify the back up device based on an identifier of the first virtual server. The CCO or cluster may identify the back up device and replicate the session on the back up device. The back up device may be prevented from receiving traffic if the first device is active. In some embodiments a node group may be configured under strict binding or as a strict node group. If a vserver is bound to a strict node group the vserver may stay remain in the active nodes of the node group. If one or more nodes in the node group exit from the OVS the vserver may reside only on the remaining active nodes. There may be no backup for the missing exited nodes.

In certain embodiments the cluster may migrate the virtual server to a second group comprising a second subset of devices in the cluster of devices e.g. based on a user directive or configuration update. The cluster or CCO may migrate other virtual servers dependent on virtual server to the second group. The cluster or CCO may migrate other virtual servers dependent on virtual server to the devices nodes to which the virtual server is bound. When a spotted vserver is bound to a new node group the system may migrate that vserver and all its dependents e.g. from the corresponding dependency graph to the new node group. In some embodiments the cluster or CCO may migrate each virtual server dependent on the first virtual server to a back up device of the owner first device if the owner first device leaves the cluster.

It should be understood that the systems described above may provide multiple ones of any or each of those components and these components may be provided on either a standalone machine or in some embodiments on multiple machines in a distributed system. In addition the systems and methods described above may be provided as one or more computer readable programs or executable instructions embodied on or in one or more articles of manufacture. The article of manufacture may be a floppy disk a hard disk a CD ROM a flash memory card a PROM a RAM a ROM or a magnetic tape. In general the computer readable programs may be implemented in any programming language such as LISP PERL C C C PROLOG or in any byte code language such as JAVA. The software programs or executable instructions may be stored on or in one or more articles of manufacture as object code.

While the invention has been particularly shown and described with reference to specific embodiments it should be understood by those skilled in the art that various changes in form and detail may be made therein without departing from the spirit and scope of the invention as disclosed herein.

