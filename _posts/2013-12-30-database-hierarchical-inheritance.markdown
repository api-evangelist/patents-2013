---

title: Database hierarchical inheritance
abstract: A database system comprising a plurality of access keys stored in a first data memory device sector, each access key associated with a node value stored in a second data memory device sector. An access key processor configured to receive an input value and return the associated node value for the input value if the input value matches an access key stored in the first data memory device sector. The access key processor is configured to generate a revised input value if the input value does not match an access key stored in the first data memory device; a default node value stored in the second data memory device sector and associated with a portion of the input value, wherein the access key processor is configured to return the default node value as part of the revised input value.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09418240&OS=09418240&RS=09418240
owner: CONEXANT SYSTEMS, INC.
number: 09418240
owner_city: Irvine
owner_country: US
publication_date: 20131230
---
The present application is a divisional application of U.S. patent application Ser. No. 13 149 725 filed May 31 2011 now U.S. Pat. No. 8 620 868 which is hereby incorporated by reference for all purposes. This application is also related to the following commonly owned and co pending applications U.S. patent application Ser. No. 13 149 713 filed May 31 2011 entitled Regular Expression Selection for Configurable Application Data Steering U.S. patent application Ser. No. 13 149 747 filed May 31 2011 entitled Persistent Data Storage and U.S. patent application Ser. No. 13 149 735 filed May 31 2011 entitled Asynchronous Process Notification. 

The application relates generally to multi component systems and more specifically to a multi component process notification system that uses a database for communication activities where the database uses hierarchical inheritance.

An unsolved problem in a multi component system is the dissemination of data that defines changes to system component states settings or configurations to other interrelated systems components. In a modularized system consisting of independently developed components it is not feasible for each system that changes information to know the systems that must react to the change. It is also not efficient for each system to frequently check to see if a change has occurred.

A further problem relates to determining the value that a named data item should assume if there is not an explicit definition of that data item. In many systems this is determined by the system component that uses the data by a method such as by assuming default values or by searching for an appropriate definitions in a related data store. In some other systems accessing such an unspecified data item is an error. Either of these processes have numerous associated drawbacks.

Within the system which embodies the configuration data base taught herein it is important that each system component need only be aware of the parameters that system component controls. For instance a user interface which controls the process of copying an image from a scanning device to a printing device should not be concerned about aspects of the printing system not being altered by the copy function. Also the user interface code should not be concerned about the particular hierarchy of parameters settings and parameter overrides implemented in the particular system.

The method of arriving at the value of parameters in this description embodies a unique method of directed hierarchical inheritance.

Other systems methods features and advantages of the present disclosure will be or become apparent to one with skill in the art upon examination of the following drawings and detailed description. It is intended that all such additional systems methods features and advantages be included within this description be within the scope of the present disclosure and be protected by the accompanying claims.

A detailed description of embodiments of the present disclosure is presented below. While the disclosure will be described in connection with these drawings there is no intent to limit it to the embodiment or embodiments disclosed herein. On the contrary the intent is to cover all alternatives modifications and equivalents included within the spirit and scope of the disclosure.

As used herein and by way of example and not by limitation hardware can include a combination of discrete components an integrated circuit an application specific integrated circuit a field programmable gate array a general purpose processing or server platform or other suitable hardware. As used herein and by way of example and not by limitation software can include one or more objects agents threads lines of code subroutines separate software applications one or more lines of code or other suitable software structures operating in one or more software applications or on one or more processors or other suitable software structures. In one exemplary embodiment software can include one or more lines of code or other suitable software structures operating in a general purpose software application such as an operating system and one or more lines of code or other suitable software structures operating in a specific purpose software application.

System includes system manager . System manager manages the resources of system such as port handlers applications peripheral application programming interface API A through N peripheral A through N and configuration database . The control of resources is managed by the components that need the resources. For example user interface system manager and applications do not need to know the address of memory buffers or other resources that are needed by a peripheral A through N such as a scanner or a printer. By distributing control system manager can be used for other purposes such as to determine whether an application can be started. For example user interface does not need to determine if the printer is currently printing. This architecture eliminates the possibility for system error to be caused such as from race conditions between an application and a user requesting functions from user interface .

System further includes peripheral API A through N which can be a common API for applications that are accessed by system manager . In one exemplary embodiment user interface can communicate parameters to applications through configuration database instead of the peripheral API A through N for applications . In this manner the only data that system manager needs to launch an application is the entry point.

Applications register with system manager by providing a name as a string and data that defines how to pass control to each application. For example this data can include an entry point address a command line that is used to launch the application or other suitable data. In this manner system manager does not need to be pre loaded with data that defines applications that are built into a product that uses system . System manager can manipulate applications but does not maintain data that identifies which applications exist.

When user interface or any other suitable system needs to invoke an application a request is transmitted to system manager which can start an application by name by matching against the members of a class or in other suitable manners. To match against a class the requesting system transmits a string to system manager such as the first bytes from a file to be processed and a class name. System manager matches the string against the regular expressions registered with each application looking for a match. If a match is found the application name is used as if the name had been provided to system manager as the application name.

Application launcher can be provided for use with a user interface function and other parts of system that need to start an application or monitor the status of an application. Such user interface functions can also allow the status of the application to be determined. For example a gross status indicator can be used to provide information about the current execution state of the application such as whether execution is pending has been started has started and failed has completed or other suitable state information. Communication of the status between the user interface or other system and the application is accomplished using configuration database .

Applications can be launched into a suitable execution slot by immediately being launched through a start API by being launched later after a user defined delay through a delay API such as to launch applications at a scheduled time or in other suitable manners. In one exemplary embodiment system manager can create an activity node and return a node reference through an activity parameter. A persistent node can also be used to store application launch information so that a loss of power before the application is launched does not prevent the application from starting.

Application registration registers applications with configuration database and other suitable systems. In one exemplary embodiment an application can be named using a hierarchical naming scheme such as an XML based scheme so as to allow the application name to also be a node identifier in configuration database . An application can also be registered as a member of a class.

Configuration database interface provides an application programming interface or other suitable interface to configuration database . In one exemplary embodiment configuration database can be used by system manager and other systems to communicate status information or other suitable information for applications or other components of system . System manager thus interfaces with configuration database through configuration database interface to start or terminate applications to facilitate communications between applications or components or for other suitable purposes.

Initialization performs initialization operations for system manager and configuration database such as to initialize a number of processor slots to allocate memory and to perform other suitable operations. In one exemplary embodiment an estimated size is obtained to determine an amount of memory to be reserved for the database storage such as by using an average number of size times a number of database entries or in other suitable manners. Initialization can populate configuration database with initial contents such as by using a bulk population procedure. Bulk population of the database can be done 1 using an XML stream that adheres to the hierarchical naming schema 2 by pointing to an object that contains such an XML stream 3 from streams that follow the proprietary format in which persistent objects are stored or in other suitable manners. A complementary function can be used to convert a database context into a bulk structure. In another exemplary embodiment API calls can be used to set the initial contents of nodes associated with the keys of configuration database .

Application cancellation performs cancellation processing for an application that has been scheduled an application that is in operation or other suitable activities. Typically a cancellation routine is required to cancel an application or activity. An activity can be cancelled where the application itself will not be cancelled such as a print job for a printer. Two APIs can be provided to assist with canceling such activities. The first API can be a helper function that provides a list of activities that can be canceled such as with an option to retrieve only the activity of the highest hierarchy if the intention is to cancel the application. The second API can be used to trigger a cancellation of an activity. For example if an activity has not started such as a delayed start application then the node can be deleted and a callback can be made to let the associated client know that the application was cancelled and never started. For an application that has never started the cleanup function can still be called at the end of the cancellation procedure.

Application cancellation can provide the callback indirectly where a piece of code that requires confirmation of a completed cancel is registered for a notification function through configuration database for the node. The reapplication cancellation can also be provided through a configuration database node or in other suitable manners such as for debugging or other suitable purposes. The calling thread information and current time can also be recorded before submitting the activity to application cancellation for canceling the activity. The activity is deemed canceled when the activity sets its completion status in configuration database . Application cancellation can then delete the activity from an activities tree.

In operation system provides system manager functionality that is used to manage operations of the components of system in accordance with the present disclosure. System uses configuration database to communication between components of system .

Access keys are used to access data stored in configuration database . An access key can be named using a hierarchical naming schema such as an XML compliant naming schema. In one exemplary embodiment an XML based naming schema might result in an access key having a value of A B C D where a text string is associated with each of the variables A through D.

Nodes refer to the data strings stored within configuration database . A node can be characterized as a key value that contains sub keys and the terms node key sub node and sub key can refer to the same data structure but connote different relative meanings. For example a key is used to locate a node and the node associated with the key will typically include additional data beyond that data that defines the key. Likewise a node may have associated sub nodes where the key that is used to locate a node can also be used to locate the associated sub nodes. Data can be stored in a node in a suitable predetermined data format. A node can also have associated sub nodes such as default nodes persistent nodes and notify nodes or other suitable sub nodes.

Default nodes are used to provide data for a node that is automatically constructed. In one exemplary embodiment a node can be automatically constructed in configuration database in order to allow systems and components of system to communicate with each other. In this exemplary embodiment a default node can be created as a sub node for a related class such as a print sub node for data that defines a print job. The new print sub node can contain all of the data required for the print job to be processed and can be created as a print node sub node where the default node settings notification node settings and persistent node settings are used to coordinate processing of the print job as further described herein.

A default node value can be stored in configuration database and associated with a node. Access key processor can return the default node value as part of a revised input value. For example access key processor can be configured to return part of the input value as part of the revised input access key where a hierarchical naming schema such as an XML compliant naming schema or other suitable schema are used. In this exemplary embodiment an XML based naming schema might result in an input of A B C D to access key processor and a default node value may exist for A B C A B or A. The default node value can be used to provide the root for a new input key such as X Y Z where the entire new input key would be X Y Z D. A default node value can be generated if an associated node value is not stored in the configuration database for an associated key value.

A node can have a default sub node that is used to handle a request for information which is presented by submitting a key value for a node when there is no associated information stored at the node for that key value. The default sub node can contain a name of another node that can be searched to satisfy the request. Rather than giving each key a default value an hierarchal system of inheritance can be provided that determines defaults. For example if a node value for key is not found in the database a SOUGHT NAME variable can be set to be the final name in the key. In this example if the key is A B C D NumCopies then SOUGHT NAME would be set to NumCopies . A SEEKING NODE variable can be set to be the key with the final slash and name removed. Using the above example in the above case SEEKING NODE would be A B C D. If a default value for SEEKING NODE exists a new key is constructed based on the value. In the above example if the value of A B C D DEFAULT is X Y Z then the new search is set to be to be X Y Z Numcopies and the search is repeated using the new key. If the SEEKING NODE is equal to the root value such as then the search has failed. If no value for the default in the SEEKING NODE exists the final name is moved from the end of SEEKING NODE to SOUGHT KEY. For example SOUGHT NAME becomes D NumCopies and SEEKING NODE becomes A B C and the search is repeated again.

Persistent nodes are nodes containing data that is stored in a persistent electronic memory such as NVRAM. Persistent node data can be stored using string keys and simple values in a tagged self describing data structure unlike the anonymous untagged i.e. not self describing structures stored in NVRAM with a standard NVRAM API. Storing data in a string based self describing structure is less storage efficient than pure binary encoding but one benefit of string based storage is that when different versions of firmware that utilizes the data are stored to a flash memory device the database remains intact and usable. In an untagged data structure the data would be preserved but if the binary layout of the data changed it would be unusable to new firmware. For such new firmware any stored values would automatically revert to factory default settings. By using a tagged data structure any new values will assume the factory default values but any pre existing values will be preserved.

To associate a portion of the database with a record in NVRAM or other suitable nonvolatile memory the value of a persistent node identifier is set to equal the name of the NVRAM object and a persistent key is associated with the node. All nodes or sub nodes under the node can also be serialized into the object and nodes at various sections of a database tree can be assigned to the same NVRAM object.

In one exemplary embodiment persistent nodes can be used to prevent interruption of scheduled tasks if a loss of power occurs. In this example if a print job has been created and stored to a print node the print job can inherit a default persistent node setting such that the print job node data is backed up in persistent data memory systems and is only deleted from persistent data memory systems when the print job completes. In this manner the print job data can be restored if a loss of power occurs before the print job completes.

Notify nodes are utilized by the configuration database to transmit change data to any component that needs to know when a change occurs to a node. In one exemplary embodiment a notify node or tag such as a data field contained within a node can be attached or associated with the selected node. The node associated with the notify tag can contain notification data such as a single value can be a node that contains sub nodes or can be other suitable data structures. In this exemplary embodiment pairs of addresses and parameters can be associated with or stored in the notify node. When the notify node is triggered each of the functions identified by the address can be called with the given parameter and a reason for why the function is called such as when the node has changed when the node has been deleted or when a new sub node has been added .

In another exemplary embodiment a user interface system can be used to monitor processes such as print jobs. In this exemplary embodiment control of the print jobs can be coordinated between user interface which receives user entered control data system manager which launches the printer application in response to the user entered control data the peripheral A through N that is associated with the printer and other components of system each of which communicate through configuration database by accessing data stored in nodes of configuration database . The print job data can be stored to a new node that is a sub node of a print node where the print node includes an associated notify node that notifies the associated printer that a print job is available and needs to be retrieved for processing. The new node can be created using data stored in one or more default nodes associated with the print node or sub nodes such as sub nodes for specific printers or types of print data . As the print job is processed status updates can be transmitted from the printer back to configuration database such as printing offline or finished and a notify node associated with the printer status node can transmit the status data to user interface . In this manner all communication can be handled through configuration database without the need for a communications infrastructure.

Access key processor can receive an input value such as an input key and return the associated node value for the input value if the input value matches an access key. In general the access key will be stored in a first memory device sector and the associated node data will be stored in a second memory device sector but the keys and nodes can also or alternatively be stored in separate memory devices. If the input value does not match an access key stored in the first memory device sector then access key processor generates a revised input value containing a default node value if one exists. In one exemplary embodiment access key processor can modify the input key to search for a default node value such as by using a root portion of the input key to search for an associated default node value or default search key and returns a search failed indication if no default node value is stored in the second data memory device sector and associated with the portion of the input value.

Update processor can process notification field data if data associated with a notify node is modified. In one exemplary embodiment update processor can retrieve a function stored in a sub field of the notification field and can execute the function such as to transmit other sub fields contained within the notification field data to an address stored in a sub field of the notification field. As previously discussed the address can be associated with a component of system such as user interface one of peripherals A through N or other suitable components.

Code development system allows a user to associate default nodes persistent nodes notify nodes or other suitable nodes with nodes or components that are stored in configuration database while creating applications for use with system . In one exemplary embodiment a user can identify data as being required for a default node such as to accommodate and configure new peripherals identify data as being required to be stored as persistent data such as user preference settings for peripherals and identify a component or system that should be notified if a node is changed deleted or if sub nodes are added such as for a status indicator on a user interface. Other suitable applications can also or alternatively be created using code development system and code development system provides the functionality for creating applications or other software code that utilizes the data functions and structures disclosed herein.

Persistent data memory systems are one or more non volatile data memory devices that are used to store configuration data such as user preferences. Persistent data memory systems can be updated in conjunction with persistent nodes or in other suitable manners.

Locking system locks nodes and sub nodes based on data received from systems and components that access the nodes to control simultaneous access. The operation to lock a node returns a key which may be referred to as an access code or visa that must be presented with subsequent requests to access in order to unlock the node. In one exemplary embodiment when a lock is accessed by a function four parameters can be passed the context the name the visa and the wait behavior. Likewise other suitable parameters can be used to access a locked node.

In one exemplary embodiment a lock operation performed on a node can be used to implement a direct lock and any sub nodes that inherit the locked state can be used to implement an inherited lock. In this exemplary embodiment a node with a direct lock may not be locked again whereas a sub node with an inherited lock can be locked if the visa is presented. If the visa is correct a new visa can be returned where the new visa can be used to access the sub node and its contents. In this exemplary embodiment the visa corresponding to the inherited lock can be deactivated such that it no longer gives access to the sub node or its contents. When a node is locked all reads writes and locks are prohibited unless the proper visa is passed with the call. Notification and persistent data processing can also be deactivated for a locked node. When a node is unlocked and is not a sub node of any locked node any pending notifications and persistent data processing can be performed.

In operation system facilitates communication between components and systems of system through configuration database . Through the use of default nodes persistent nodes and notify nodes these components and systems can communication with each other and process data such as data for a multi function peripheral or other suitable data.

Algorithm begins at where a key is received. The key can be received as encoded data from system manager or other suitable systems and can have a predetermined data format that is defined by a number of fields and data type such as alphanumeric . The key can be named using a hierarchical naming convention such as an XML naming convention or in other suitable manners. For example the key can be named A B C D where A D can be any suitable text string. The algorithm then proceeds to .

At it is determined whether the key matches a key value in the configuration database. The match can be determined using a suitable matching or look up algorithm such as an algorithm that searches through an ordered list or other suitable algorithms. If a match is found the algorithm proceeds to and the value corresponding to the key is retrieved from the database such as by copying a data field stored in the database that is associated with the key. Otherwise the algorithm proceeds to where a name is set. In one exemplary embodiment the name can be set by using the least significant text string of the hierarchical key name such as the text string associated with D in the example above or in other suitable manners. The algorithm then proceeds to where the node is set. In one exemplary embodiment the node can be the remainder of the key name other than the least significant text string such as A B C in the example above. The algorithm then proceeds to .

At it is determined whether a default name value exists for the node assigned in . If it is determined at that a default name has been found the algorithm proceeds to where a new key is constructed using the default name and the name set at . For example if the default name value is X Y Z then the new key would be X Y Z D. The algorithm then returns to .

If it is determined at that no default name value exists the algorithm proceeds to where it is determined whether the key is at a root. For example using the naming convention discussed above if the remaining key is D then the key is at a root i.e. and no additional searching can be performed. The algorithm proceeds to where a search failed indicator is generated. Otherwise the algorithm proceeds to where the name is set. Using the above example the new name setting when the search for A B C D has not resulted in an associated node or a default for A B C the new name would be C D for the second default node search. The algorithm then proceeds to where the node is set such as to A B for the example described above. The algorithm then returns to where a search for a default node for the new node value is performed.

In operation algorithm allows a default node value structure to be used in a configuration database that allows default values for nodes to be assigned to identify information for an unidentified node. Algorithm seeks for the default value that is closest to the new node value by checking each node in a hierarchical naming scheme for a default node value starting with the node closest to the new node in the naming scheme and ending with the root node after which a search failed indicator is returned.

Algorithm begins at where a node identifier is received. In one exemplary embodiment the node identifier can be received when the node is created using a software development kit as part of an application that uses a configuration database to store data associated with the node or in other suitable manners. The algorithm then proceeds to .

At a storage identifier is defined such as by using the software development kit to identify a persistent data memory device such as a nonvolatile data memory device a magnetic drive an optical data storage device or other suitable persistent data memory devices. The algorithm then proceeds to .

At a tag is attached to a node that associates the data stored at the node with a storage identifier. In one exemplary embodiment the tag can be attached to the node when an application is being created or modified by a programmer such as when the programmer indicates that data should be stored in a persistent data storage device. The algorithm then proceeds to .

At the node data is stored in the associated persistent data memory device. In one exemplary embodiment the node data can be stored when it is created for each node the node data can be stored after programming for a module or application has been completed or other suitable processes can be used. The algorithm then proceeds to .

At it is determined whether more nodes are to be generated or processed. If it is determined that more nodes are to be generated or processed such as when an application is being developed or compiled the algorithm returns to . Otherwise the algorithm proceeds to .

At a database is initialized. In one exemplary embodiment the initialization can be performed for a configuration database when a multi function peripheral is powered on or in other suitable manners. The algorithm then proceeds to .

At persistent node data for the nodes of the database is recovered. In one exemplary embodiment the nodes of the database with associated tags can be identified and the data stored in persistent memory devices can be retrieved and used to populate the database. The algorithm then proceeds to .

At it is determined whether a node has been updated. In one exemplary embodiment a node can be used to store user settings for devices such as printers fax machines or other suitable peripherals. When a user changes a setting the setting data can be stored at a node in a configuration database. If a node has not been updated the algorithm returns and waits for a node to be updated. Otherwise the algorithm proceeds to .

At the node is checked to see if it is locked. If the node is locked the algorithm proceeds to . If the node is not locked the algorithm proceeds to .

At the updated node data is stored in the persistent data memory device. In one exemplary embodiment the persistent data memory device can be identified using the tag data and the updated node data can be stored in the associated persistent data memory device using a suitable data storage process. The algorithm then returns to .

At the information to update the associated persistent data memory device is queued for later processing by an unlock algorithm.

In operation algorithm allows data that should be maintained in a persistent data memory device to be easily identified updated and recovered. Algorithm can be used by programmers during the application coding process to create a structure within the application code for providing for persistent storage of selected data that is determined by the developer to be suitable for persistent storage such as user setting selections for peripheral devices.

Algorithm begins at where a related node for an application is identified. In one exemplary embodiment the node can be identified using a function for retrieving or setting a key value such as a key value get function or a key value set function. In this exemplary embodiment a set function which implies nodes that do not exist can cause those nodes to be created. If a type of the key does not result in a match when a get function that uses the key as an argument is called the function can return an error whereas if the type of a key does not match when a set function is called the type can be changed.

A set function call can create a key in the context if it does not already exist and a get function call can return a value from a default setting if a default setting exists. A set function call does not change the default. In addition after a set function call any node having an associated persistent tag is updated in the persistent data memory if it is not locked. If the node is locked the update can be delayed until all locks are removed from the node.

After a get or set function call notification processing can be performed by looking in the node that contains the changed key for a notify tag. If a notify tag is present and the node does not have a lock a configuration database system manager can call each of the entries in the notify tag and search for each of the containing contexts. If a context is present and the node is has a lock the notification can be delayed until all locks are removed from the node such as where bottom up processing is necessary so that a subscription to a lower level node does not interrupt subscriptions to a higher level node.

For a notification get or set function an address of the function to be called for notification can be provided as well as a value for the first argument to be passed to the notification function. Additional data such as a reason parameter can be provided that identify a reason that a notifier was called such as an object add an object delete an object change other suitable reasons or a combination of suitable reasons. Restrictions can also be imposed on the notification function such as to prevent a configuration database application programming interface from being called from the notification callbacks. The algorithm then proceeds to .

At a notification tag is attached to the node. As discussed above the notification tag can include an address of a function to be called a value for a first argument or other suitable data. The algorithm then proceeds to .

At it is determined whether any additional nodes are to be processed. If no additional nodes are to be processed the algorithm proceeds to otherwise the algorithm returns to .

At a system state is monitored such as by a system manager of a configuration database or other suitable systems. The algorithm then proceeds to where it is determined whether a node has been updated such as if an object has been added changed deleted or if other suitable node updates have occurred. If no update has occurred system state monitoring continues. Otherwise the algorithm proceeds to .

At notification data associated with a node is obtained as discussed above. The algorithm then proceeds to .

At it is determined if the node is locked. If the node is not locked the algorithm proceeds to where the associated function is called as described above. If the node is locked the algorithm proceeds to .

At the notification function is called with the notification function argument and the reason for the notification. The algorithm then proceeds to to wait for the next change.

At the notification function the notification function argument and the reason for the notification are queued for subsequent processing by an unlock algorithm. The algorithm proceeds to to continue monitoring for changes to the node or nodes.

In operation algorithm allows a component to be notified when a change occurs to a related node. Algorithm only provides notification when a change occurs and does not require the component to periodically issue a query to determine whether a change has occurred. In addition algorithm avoids other problems that can exist with disseminating information about changes to system state settings or configuration to other affected systems.

Algorithm begins at where a node to be access has been identified. A current visa is determined by examining the node to see if it has a direct lock and associated visa. If it determined that a direct lock and visa exists that visa is used to match for the following steps. If no direct lock and visa exists for the node then each containing node is examined until a top level of the structure is reached or an inherited lock and visa is found. If it determined that an inherited lock and visa exists that visa is used to match for the following steps. The algorithm continues with .

At if a direct or inherited lock and associated visa were not found the algorithm continues to and the access is permitted. If any lock was found the algorithm continues to .

At the visa found in is compared with the visa supplied. If the visa matches the algorithm proceeds to and the access is permitted. If the visa does not match the algorithm continues at .

At the time remaining to wait is examined. If there is no remaining time to wait the algorithm continues to and access is denied. If there is time remaining the algorithm continues at .

At the algorithm waits until either the specified time has elapsed or a change has been made to the locks which could result in access being allowed. When such a change has occurred or when the time period has elapsed the algorithm continues at .

At if the wait was for a specific period the time spent in step is subtracted from the remaining period. The algorithm continues to to attempt again to match the supplied visa with the node to be accessed.

Algorithm begins at in which a visa of any containing node is determined. The algorithm continues with .

At if a visa was found the node is not unlocked as it is indirectly locked by a node which contains it. The algorithm continues with .

At the queue of persistent storage updates from algorithm is examined for entries which apply to this node or any sub nodes.

At the queued persistent storage updates are performed to the associated memory system and the updates are removed from the queue. In one exemplary embodiment information may have been updated many times while the node was locked and the associated memory system can be updated once with the most recent value stored in the node or sub node. Other suitable update procedures can also or alternatively be used.

At the queue of pending change notifications is examined for entries which apply to this node or any sub nodes.

At the queued pending change notifications are performed by calling the notification functions with their argument and the reason for change. In one exemplary embodiment where multiple changes have occurred while the node or sub node was locked each function can be called once for each argument regardless of how many changes were queued where the reason for change argument can the union of the one or more change notification reasons. Other suitable function call processes can also or alternatively be used.

It should be emphasized that the above described embodiments are merely examples of possible implementations. Suitable variations and modifications can be made to the above described embodiments without departing from the principles of the present disclosure. All such modifications and variations are intended to be included herein within the scope of this disclosure and protected by the following claims.

