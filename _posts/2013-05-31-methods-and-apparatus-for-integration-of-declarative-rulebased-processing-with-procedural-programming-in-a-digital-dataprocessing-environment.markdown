---

title: Methods and apparatus for integration of declarative rule-based processing with procedural programming in a digital data-processing environment
abstract: The present invention provides methods and systems for integrating a procedural computational model with a declarative computational model. For example, in one aspect, the present invention provides a method for integrating a plurality of procedural instructions in a procedural computational system with a plurality of declarative rules in a declarative computational system. In such a method, for each of the procedural instructions operating on one or more variables, a hash table indexed by variable names is utilized to determine whether any of these variables participate in at least one of the declarative rules. Upon execution of a procedural instruction that changes a variable participating in a declarative rule, other variables associated with the rule are updated so as to maintain a relationship imposed by the rule among the variables. The updating of the other variables is performed prior to execution of other procedural instructions.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08959480&OS=08959480&RS=08959480
owner: Pegasystems Inc.
number: 08959480
owner_city: Cambridge
owner_country: US
publication_date: 20130531
---
This application is a continuation of U.S. patent application Ser. No. 12 649 095 filed Dec. 29 2009 entitled METHODS AND APPARATUS FOR INTEGRATION OF DECLARATIVE RULE BASED PROCESSING WITH PROCEDURAL PROGRAMMING IN A DIGITAL DATA PROCESSING ENVIRONMENT which is a continuation of U.S. patent application Ser. No. 10 854 017 filed on May 26 2004 entitled METHODS AND APPARATUS FOR INTEGRATION OF DECLARATIVE RULE BASED PROCESSING WITH PROCEDURAL PROGRAMMING IN A DIGITAL DATA PROCESSING ENVIRONMENT the teachings of which are incorporated herein by reference.

The invention pertains generally to digital data processing and more particularly to methods and apparatus for implementation of declarative rule based systems and their integration into mainstream computing environments. The invention has application by way of non limiting example in the design and implementation of workflow applications. Such systems typically have object oriented architectures and the invention takes advantage of aspects of such architectures but it is not limited to these.

The vast majority of data processing systems use a procedural based programming paradigm. This is exemplified by programming languages like C or Java where execution is controlled by procedures consisting of sequences of statements assignments loops if etc. . The programmer of such a system is responsible for specifying in great detail what this sequence is and making sure that it is correct. The sequential nature of such systems and the resulting exponentially large number of execution paths that a system of even moderate size can take is the fundamental basis for their complexity. It is also the source of most of the very large number of bugs that typically plague such systems.

Declarative rule based programming is a fundamentally different programming paradigm. It is characterized by the lack of any sequential statements and any notion of state of which the programmer has to be aware. Instead processing is specified in the form of logical rules where each rule relates one or more output variables to a set of input variables. Such rules can be chained together so that the output of one rule becomes an input to other rules.

An important characteristic of such a system is that the rules always hold. In other words the values of the variables are always such that they are consistent with the rules. For example if a rule states a relation between variables like z x y then the values of x y and z are constrained to be such that this relation is never violated. This implies that changes to input variables x or y in this example must be propagated instantly so that the corresponding output variables are updated according to the relation. For example if x 1 y 2 and z 3 and then x is changed to 2 then z must be updated to 4. In this case instantly means that the update happens before any user or any processing element outside the declarative programming system notices an inconsistency.

The primary advantage of a declarative rule based system is that it allows the programmer to focus on the required behavior of the application by specifying declaring invariant logical and arithmetic relations between variables. The complexity related to sequencing and state is hidden from the programmer.

In many applications declarative rules can be used for solving significant portions of a problem. However they are usually not appropriate for every aspect of a typical workflow problem. Some things a sequence of steps to be executed for a work item for example are best expressed procedurally.

In view of the foregoing an object of this invention is to provide improved methods and apparatus for digital data processing and more particularly for integrating declarative and procedural programming systems.

Another object of the invention is to provide such integrated computational systems that are relevant to a wide variety of applications including for example modeling and processing workflows.

A related object of the invention is to provide methods and apparatus for improved integration of declarative and procedural programming systems that are suited for integration with systems having object oriented data architectures.

A further object is to provide such methods and apparatus as can be implemented in a variety of programming languages and or on a variety of platforms.

The foregoing are among the objects attained by the invention which provides in one aspect methods for entering maintaining and executing declarative rules that allow the programmer to express invariant relations as defined above. The methods further include facilities for entering maintaining and executing procedural statements that allow the programmer to specify sequential activity as defined above. The methods further provide for integration of the declarative and procedural systems such that changes resulting from procedural actions are immediately propagated within the declarative system so that for all practical purposes the data is always consistent with the invariant relations specified by the declarative rules.

In one aspect the invention provides a method for integrating a plurality of procedural instructions in a procedural computational system with a plurality of declarative rules in a declarative computational system. In such a method for each of the procedural instructions operating on one or more variables a hash table indexed by variable names is utilized to determine whether any of these variables participate in at least one of the declarative rules. Upon execution of a procedural instruction that changes a variable participating in a declarative rule other variables associated with the rule are updated so as to maintain a relationship imposed by the rule among the variables. The updating of the other variables is performed prior to execution of other procedural instructions.

In a related aspect in a method as described above for each of the updated values changes associated with the updated variable are propagated to other rules if any in which the updated variable participates. The propagation of the change can be accomplished by modifying values of variables other than the updated variable so as to maintain relationships defined by these other rules.

A related aspect of the invention provides methods for efficiently propagating the effects of the changes according to relevant declarative rules so that the data is once again consistent with the invariant relations. This propagation is done in a manner such that neither the procedural system nor the user is able to detect the temporary inconsistency.

A further aspect of the invention provides methods for distinguishing variables involved in declarative processing variables that are mentioned in declarative rules from ones that are not and for efficiently associating variables involved in declarative processing with the rules in which they are mentioned. This helps minimize the overhead in the procedural system associated with detection and propagation and thus maximizes efficiency. It also ensures that variables not involved in declarative processing impose no penalty on execution performance of the procedural system. For such variables execution of the procedural system is no less efficient than it would be for a purely procedural system one with no declarative rule capability . The overall effect of these methods is that propagation is limited to computation necessary to repair any rule violations.

Other aspects of the invention facilitate use of object oriented data architectures in the declarative and procedural programming systems. These aspects include methods for efficiently assigning values to variables that are embedded within represent attributes of objects and for matching such variables which may be embedded many levels deep within a sub object hierarchy with relevant rules. These aspects also include methods that allow declarative rules to refer to objects in sophisticated ways and that propagate effects of changes between objects.

In a related aspect the invention provides a method of integrating a procedural computational system which supports object oriented representation of data in a plurality of objects with a declarative computational system which provides rules for defining relationships among the objects. One step of such a method determines for each object whether that object participates in any of the declarative rules. Upon execution of a procedural instruction operating on an object that participates in at least one declarative rule to modify data associated with the object the data modification is propagated to other data in that object and or to data associated with other objects so as to render data values associated with the declarative rule consistent with the rule definition.

In yet another aspect the invention provides a method of integrating a procedural computational system which supports execution of a plurality of procedural instructions operating on one or more variables with a declarative computational system which provides a plurality of rules for defining relationships among these variables. The method calls for compiling each procedural instruction corresponding to assignment of a value to a variable participating in a declarative rule so as to effect upon assignment of a value to the variable at runtime updating of other variables associated with the declarative rule so as to maintain consistency of a relationship imposed by the rule among the variables.

In other aspects the invention provides an integrated procedural and declarative computational system that includes a procedural module for executing procedural instructions operating on one or more variables and a declarative module that is coupled to the procedural module so as to operate on these variables so as to maintain a set of relationships among the variables defined by one or more declarative rules. The system further includes a tracking module that is in communication with the procedural and declarative modules. Upon execution of each of the procedural instructions the change tracking module detects changes if any in one or more variables participating in at least one of the declarative rules and reports the change to the declarative module. In response the declarative module updates values of other variables participating in the declarative rule so as to maintain a relationship defined by the rule.

Hence an integrated computational system of the invention allows both declarative and procedural programming styles in a single system. The declarative system can operate in a background mode to ensure that the rules are always true without the need for a workflow architect to insert explicit update requests in the procedural code. Such a capability provides a programmer with unprecedented flexibility in utilizing these two different programming tools without having to be concerned about the details of their integration.

These and other aspects of the invention are evident in the drawings and in the description that follows.

Illustrated processing center represents a service provider or other entity that utilizes work item routing. Non limiting examples include retailers mail order houses professional service providers counseling centers and help bureaus and so forth. While work item typically refers to tasks processed by the resources or to which resources may be allocated as used herein the term refers to tasks products customer or other things for processing by the resources or to which resources may be allocated.

With continued reference to the illustrated work items comprise customer requests that require routing or assignment to employee agents of the processing center . More generally the illustrated agents represent any resource to which the work items may be allocated. This can include human resources business resources environmental resources energy resources consumable resources or otherwise. The illustrated work items here customer requests are processed in the manner described in the aforementioned incorporated by reference application. Thus for example requests or other work items received by the processing center are subject to intake processing e.g. by intake processing personnel and then are passed to digital data processor A for routing to the agents or other resources .

The declarative rule system also reads and writes variable values but the execution is more specialized. Declarative rules are compiled by a rule compiler into a dependency network and execution code for each rule as described in more detail below. The dependency network is an efficient representation of the rules which is suitable for interpretation by a rule interpreter . The rule interpreter can utilize the dependency network to determine the correct sequence in which the declarative rules need to be executed. It also uses the dependency network to determine the subset of rules that need to be executed when there is a change typically a very small subset of all the rules needs to be executed in response to a change . It may also use the dependency network to determine additional objects that may have to be loaded into virtual memory from persistent storage.

A change tracking system detects a change of a variable value caused by execution of an assignment statement in the procedural system. Before the next statement is executed the change tracking system notifies the declarative rule system of the change. An inference engine determines a sub network within the dependency network that is associated with the change. The inference engine uses this sub network to determine the rules that need to be executed in response to the change and the correct sorting of these rules. It then executes these rules thus removing any inconsistency in the data resulting from the change made by the procedural system. The procedural system then executes its next statement.

Operation of the various components shown in is now explained in more detail. In particular the procedural and declarative programming systems are described in detail along with the change tracking system. Additionally the widely used object oriented data representation is discussed. For each of these components definitions of important terms are given together with explanatory diagrams and examples. The definitions are primarily for the purpose of describing the invention and are not intended to be limiting of the scope of the invention. In most cases the definitions correspond to industry standard terminology. However some of the definitions are specific to this invention and are made primarily for convenience of describing the invention.

For the most part the definitions introduced in this section are based on standards and conventions used in most popular procedural programming languages C for example . Structured data types arrays structures objects etc. are not covered in this section as they are not central to this discussion. Object representations are covered separately in a subsequent section.

EXAMPLE 1 below shows an exemplary listing of a typical procedural program which illustrates many important features of procedural programming systems. In this example the function compute order takes parameters for product quantity store location monthly payment and number of payments. It computes a price before tax based on product and quantity. It then calls compute order tax to compute a tax based on the state in which the store where the purchase is made is located. Compute order then adds this tax to compute total price. Finally it iterates over number of payments to compute the remaining balance after this number of payments using a fixed monthly interest rate of 0.5 . This remaining balance is returned. Note that prices are in cents so integer variables can be used to represent prices.

This simple program illustrates many of the key features of procedural programming systems including variables and constants with different data types price before tax and principal for example operators expressions and assignment statements price before tax product price quantity for example control flow statements the if statements and for iteration and the use of functions compute order calls the function compute order tax . These terms are now defined more formally.

A data type specifies the format and memory allocation requirements for a datum. It also constrains the operations that can be performed using that datum. Basic data types include boolean character string integer and float.

A constant is an unchanging datum. For example 5 is an integer constant a is a character constant and 3.7 is a float constant.

A variable is a datum of a particular type that may change. The datum is referenced by a variable name. Variables can be any one of the basic data types.

Operators produce values based on a set of arguments. Operators can be categorized according to the types of their arguments and the types of the values they return. For example arithmetic operators such as and take arithmetic arguments integer or float and return an arithmetic result. Relational operators like 

Examples 5 arithmetic expression and logical expression 5 relational expression product price quantity arithmetic expression Statement 

A statement is the most basic building block for procedural processing. There are different kinds of statements. One of the most basic is the assignment statement which sets the value of a variable to the result of an expression.

Note that the procedural programming system does no processing between statements. That is variables can be changed or accessed only within statements. Suppose that the procedural system executes an assignment statement that sets a variable in such a way that one of the declarative rules is no longer consistent. If the declarative system performs necessary update computations immediately after this statement and before the next procedural statement is executed then the system is consistent once again. In other words the consistency of the declarative rules is restored before the procedural system has any chance to notice any inconsistency. Thus if declarative processing is performed between procedural statements it is possible to give the illusion to the procedural system that declarative rules are always true.

A number of different kinds of statements are useful for controlling flow of processing in a procedural language. These statements when combined with appropriate state variables counters for example update these state variables and guide processing based on these state variables.

Functions provide a mechanism for re using code allowing a useful fragment of code to be invoked from many places in a program. A function has a name a set of parameters and a body that consists of a set of statements that do computation based on the parameters. The function is called using the function name along with a set of values for the parameters.

By way of example conventional work flow systems can be viewed as specialized procedural systems in which performance of a step in work flow processing corresponds to execution of a procedural statement.

This invention can be used for programming systems that do not use object representations that use unstructured variables only . However the vast majority of practical implementations use some form of structured data and it is for such systems that the invention provides the most benefit.

Note that for the most part the definitions that follow are based on standards and conventions used in most popular object oriented programming languages like Java or C . Note also that these definitions do not imply any particular implementation. They merely specify requirements for the implementation and thus impose some constraints. However there is still significant implementation flexibility and some implementations may be more efficient than others.

A class is a type specification for a structured data collection called an object. The type specification is represented as a set of elements. A class has a unique name that distinguishes it from other classes and objects.

An element has a name as well as information associated with that name. There are two types of elements data elements and methods. A data element also known as a property contains a data type specification and a data value. For elements that are part of a class specification this value is the default value the initial value for the element when an object of the class is instantiated . A method element contains a reference to a function as well as type specification information for the parameters of the function and the values returned by the function.

An object is a structured data collection containing a set of elements and some other information. An object is created or instantiated according to a specification from a particular class. A possible implementation of such an instantiation would be to simply copy the elements of the class to the object. An object maintains a reference to its associated class. An object is also given a unique name. That is its name is different from that of any other object regardless of class. An object is given the name when it is instantiated. An object may also be deleted at which time its resources memory used and unique id are recycled to pools from which they may be re used.

A property data element of an object may itself be an object. An object contained in a property of another object is called a sub object of the containing object. A property of an object may also contain a set of sub objects.

A property of an object may contain a reference to another related object. This is distinct from the notion of a sub object in that the property contains a reference to the related object rather than the complete information for the object as is the case with a sub object. For example suppose an object A1 contains a sub object B1 and a reference to a related object C1. The related object C1 can exist independently of A1 but B1 cannot. Thus if A1 is deleted B1 will be also deleted because its memory is allocated as part of A1. However C1 will not be deleted.

A class may define its own elements. A class may also optionally have a superior class from which it inherits elements. Thus when an object of the class is instantiated it will have elements defined by its associated class as well as elements inherited from the class superior class if such a superior class exists. If an element defined for a class has the same name as an element inherited by the class the element defined for the class is used and the inherited element is ignored.

An object can be created instantiated using a global create method that takes as parameters the class and the name for the object. Optionally data element name value pairs can be included as parameters to this method for the purpose of initializing the named data elements to the values as long as these values are consistent with the class specified data types for the data elements. Also optionally constructor methods that take zero or more arguments can be specified at the class level. The constructor methods are invoked after memory for the object is allocated and its data elements are initialized to their default values.

An object can be deleted using a global delete method that takes as parameter the name of the object. When an object is deleted its resources allocated memory and unique id are recycled to pools from which they may be re used. It is the responsibility of the developer to delete any outstanding references to this object from other objects for example .

In a typical object oriented system object instances exist in the virtual memory space of the computer s operating system. Objects in virtual memory can easily be accessed and modified by application algorithms declarative or procedural . The virtual memory representation is used for all computations both declarative and procedural that modify data elements of objects. Virtual memory is however volatile. For example when the computer s operating system shuts down virtual memory is reset and any objects in it are lost. To prevent this objects must be made persistent. That is the transient objects residing in virtual memory must be saved to persistent memory. This is typically achieved using a database and a suitable API that supports load and save operations on objects.

A load operation can load an object into virtual memory from a database. The load operation takes the object s name as a parameter and uses the name to find the object in the database. The object s name must be unique within the database. After the object is loaded into virtual memory it is identified within virtual memory by this same name. A save operation saves the object from virtual memory to a database to persistent storage . The save operation also takes the object s name as a parameter and uses this to locate the object in virtual memory and to associate the object with this name in the database.

In typical procedural programs object loads and saves are performed explicitly as part of the program. Thus the programmer is responsible for loading any objects needed in a computation before the computation is performed and for saving the objects that have changed after the computation has been performed.

The same approach is used for declarative processing systems when it is known that all computations will be restricted to a single particular object. Consider for example the following declarative rule see also related property designation examples in EXAMPLE 5 Order.TotalCost Sum Order.OrderItems .Cost 

This rule can be applied to any object of class Order it could be applied to the object Order 1 in EXAMPLE 5 for example . The object to which the rule is applied is called the context object. The rule computes the TotalCost property of the Order context object by summing the costs of individual order items. If the OrderItems property contains a set of sub objects then all computations performed by this rule are restricted to the context object. If all rules in a dependency network have the same context object all computations in the declarative system defined by the dependency network are restricted to that context object. This important special case is referred to here as the single object context case. The case where computation is not restricted in this way is referred to here as the multiple object context case. In the previous exemplary rule if the OrderItems property contains a set of related objects rather than a set of sub objects then computation is not restricted to a single context object. In other words computation is performed using multiple related objects.

For the single object context case load and save of the object can be accomplished by using a procedural program that wraps the declarative processing with appropriate loads and saves of the object. In a typical scenario the procedural program loads the object and then performs some computations on the object. These computations may result in changes to the object requiring declarative processing to propagate the changes. After the declarative processing is completed procedural processing resumes and ultimately saves the object.

The multiple object context case is more complicated. Although procedural processing may begin with one object the declarative processing if it uses rules that span related objects will require other objects to be loaded from the database. In the previous exemplary rule if the OrderItems property contains a set of related objects rather than a set of sub objects the rule spans multiple objects. Execution of the rule requires a multiple object context.

Suppose that the rule system begins with the goal of computing the TotalCost property of Order 1 and would like to use the above exemplary rule. Suppose that Order 1 is loaded into virtual memory but that the related objects in the OrderItems property are not. The rule system must then first load these related objects before executing the rule.

Alternatively suppose that the procedural system has just changed the Cost property of an OrderItem object let us call this OrderItem 1 and that the declarative rule system is invoked to propagate changes according to rules. The rule system first needs to check whether the above exemplary rule even applies. This is because the OrderItem object that was changed may not fit the pattern required by the rule. The rule states that the OrderItem object in question must be a member of the set of related objects in the OrderItems property of an Order object. If this is not the case then the rule should not be used. For example if OrderItem 1 is a free standing object i.e. an object not related in any way to any other object the rule does not apply.

The manner in which the rule pattern is checked can depend on the details of the object relation structure. To check if OrderItem 1 is referred to in the OrderItems property a relation that is the inverse of OrderItems is used. For example the OrderItem class can be given an additional property called ParentOrder. OrderItem instances that are referred to in the OrderItems property of an Order would have a reference to that Order in their ParentOrder property. OrderItem instances that are not referred to in this way would have a null reference in their ParentOrder property. With this property the rule system can easily check whether OrderItem 1 fits the pattern required by the rule.

If OrderItem 1 does fit the pattern the rule system uses the ParentOrder property to reference the corresponding Order and load it into virtual memory if necessary. It then uses the OrderItems property of the order to load all the other OrderItem instances needed. When this is done the complete multiple object context is available and the rule can be executed.

It is difficult for the programmer of the procedural or declarative system to determine explicitly for all possible situations all objects that may have to be loaded in this way from the database. Therefore it is preferable to determine this automatically. This can be accomplished by the rule compiler which parses context information from rules and generates code that loads required missing objects for any situation that may be encountered. This will be discussed in more detail in the subsequent section on declarative rules.

The illustrated system can utilize the following approaches for persistent object storage 1 converting the objects into normalized tabular form and storing them in a relational database and 2 converting them into an XML Extensible Markup Language format and storing them in an XML document. These two approaches can also be combined XML formatted data can be stored in relational database tables. Databases designed specifically for storing objects are also commercially available but these do not typically enjoy the immense popularity of relational databases and XML partly due to their complexity. The most typical representation of objects in a relational database is as normalized tables. In this representation each object class has its own table within the relational database. Each row of such a table corresponds to an object instance. The first column of such a table is typically the object name. Subsequent columns correspond to scalar properties of the object. Properties containing sets of sub objects or references to related objects are not represented in the table at all Instead the tables corresponding to the sub object or related object class have columns for parent object. Thus the information about the object sub object relation is stored with the sub object not the parent. EXAMPLE 6 below shows the exemplary object configuration from EXAMPLE 5 represented in this normalized form.

Retrieving all the information for a particular object requires the equivalent of a database join operation. This can be accomplished by using an SQL query that specifies tables to be included. For example to retrieve all Order Item instances for an Order the query must specify that Order Item.ParentOrder Order.Name. A database join can combine information from different tables into one new table. For purposes of loading an object from the database into virtual memory the actual join creation of the new table is unnecessary. Typically the information from the various tables found by the query is used to directly create the object in virtual memory.

Table structure in a relational database can be defined by employing schemas which are analogous to object class definitions.

Conversion to XML is relatively straightforward because XML is designed for storing persistent objects. EXAMPLE 7 shows the exemplary object configuration from EXAMPLE 5 represented in XML form. Note that with the XML representation sub object information is stored within the parent object so there is no need to perform a join.

The structure of XML documents can be defined using a Document Type Definition which is analogous to an object class definition. XSL Extensible Style Language patterns can be used to query XML structured data. This is useful for loading into virtual memory particular objects that meet certain criteria.

Standards for declarative systems are not as well developed as they are for procedural systems. Therefore the definitions introduced in this section are not necessarily based on any industry standards. The definitions are introduced primarily to help explain the invention and not to track evolving standards.

A declarative programming system typically includes a set of declarative rules a set of associated variables and a rule interpreter that computes values for the variables based on the rules see .

A declarative rule states a relation between a set of variables that is always true. Although a declarative rule can have the same format as an assignment statement its behavior is very different. Whereas an assignment statement makes the assignment as a procedural step at one point in time a declarative rule ensures that the relationship is always true. There is no notion of processing or state it is timeless . It specifies an invariant relation.

A declarative rule may have many forms. Often declarative rules are expressed as a formula or equation as in 105 or Declarative rules are also often expressed as if then relations as in

Note that besides the expression based rules shown in the above examples declarative relations can also be expressed by using tables or even procedures. If the computation is performed by a procedure it must ensure that the output is always deterministic based on the input variables. Thus the procedure must base its computations solely on the input parameters and is not allowed to access any external variables that may introduce state and non deterministic behavior.

Note also that object representations can be accommodated by such rules as in loan.payment loan.principal loan.interest airplane.weight airplane.empty weight sum airplane.passangers.weight Rule Compiler 

A rule compiler such as the rule compiler shown in parses rules according to a grammar such as the one shown in EXAMPLE 15 below. The parsing may be accomplished by any standard parser an ATN parser for example.

The compiler generates code that performs the computation of the rule. This can include context generation code as well as rule body execution code. Context generation code checks whether the object to which the rule is being applied fits the pattern of objects required by the rule as specified in the rule s context specification . Context generation code also loads any missing required objects from persistent storage. For example consider the second exemplary rule shown in EXAMPLE 15. Suppose that the Quantity property of an instance of class OrderItem changes. The rule may or may not be applicable. The context generation code begins with the focus object in this case the instance of OrderItem and checks if the ConfiguredProduct property of this object refers to an instance of class ConfiguredProduct. If it does not then the match fails and the rule cannot be executed. Otherwise the rule can be executed but the ConfiguredProduct instance must be loaded from persistent storage if it is not already resident in memory. Now suppose that the Cost property of an instance of class ConfiguredProduct changes. Again the rule may or may not be applicable. The focus object is not the instance of ConfiguredProduct. The context generation code begins with this focus object and checks if its ParentOrderItem property inverse of ConfiguredProduct property refers to an instance of class OrderItem. If so the rule may be executed. Again it may be necessary for the context generation code to load the OrderItem instance from persistent storage.

The rule compiler generates context generation code based on the context specification in the rule see EXAMPLE 15 . The generated code covers all possible focus object situations that may arise. In the second exemplary rule in EXAMPLE 15 the focus object may be an instance of ConfiguredProduct or an instance of OrderItem. In the former case the corresponding instance of OrderItem must be loaded to complete the context. In the latter case the corresponding instance of ConfiguredProduct must be loaded to complete the context. If the context cannot be completed the pattern match fails and the rule cannot be executed.

The rule compiler also generates rule body execution code code corresponding to the rule body . This code assumes all context objects have been loaded and it performs the actual computation of the rule computing a new value for a property of one of the context objects based on properties in all the context objects.

The code generated by the rule compiler may be in Java C or any other language suitable for processing by the rule interpreter see below . The rule compiler also generates a dependency network which is a graph that represents in an efficient form the dependencies between variables and rules. The dependency network can be used to determine input and output variables of rules and rules that compute and use variables. The rule interpreter can utilize this information to determine a subset of rules that need to be executed when a variable changes and to determine the correct execution sequence for the rules. An exemplary dependency network is shown in .

A rule interpreter such as the rule interpreter shown in can represent an algorithm that reads the rules in a declarative programming system and uses them to compute values for the variables mentioned in the rules. Such algorithms can include for example inference engines equation solvers and a large variety of optimizers. A rule interpreter performs computations that ensure that declarative rules are always true. Thus if a variable is assigned a new value by a procedural statement for example that new value might cause a violation of a declarative rule. The rule interpreter is run by passing it the set of variables that have changed. The rule interpreter employs the declarative rules to propagate the effects of those changes. It performs this processing until all declarative rules are consistent once again.

EXAMPLE 8 below shows a simple exemplary declarative rule set for computing a monthly payment. Rule 1 computes price before tax based on product price and quantity. Rule 2 computes price based on price before tax and tax rate. Rule 3 computes monthly payment based on price and number of payments. The rules in this example all have an important common characteristic they all express a mapping from a set of input variables to a single output variable. They are a special case of declarative rule that is defined here as a simple formula .

A simple formulat is a type of declarative rule that expresses a mapping from a set of input variables to one output variable. The output variable cannot be a member of the set of input variables.

Rule systems consisting only of simple formulas are important because they can be used for a wide range of applications and because rule interpreters can take advantage of their special characteristics in order to simplify and speed up variable value computation. A declarative programming system consisting only of simple formulas is defined in the following way.

EXAMPLE 8 below illustrates a simple formula declarative system. Note that the outputs of some rules can serve as inputs to others. This leads to the notion of a dependency network a graph that represents the dependency between variables and rules. depicts the dependency network for the exemplary rule set of EXAMPLE 8. The input variables for this dependency network are product price quantity tax rate and number of payments. The output variable is monthly payment. The arrows indicate input output directionality of the rules.

The rules and variables in the network shown in form a directed acyclic graph DAG . In a DAG the arcs are all directed and there are no loops. The dependency network for a simple formula declarative system is always a DAG. This has important implications for the rule interpreter. In particular elements of a DAG can always be sorted into a linear list so that order dependencies expressed in the DAG are preserved. This sort operation is an important part of what the rule interpreter must do. When an input variable changes the rule interpreter must determine which rules typically a subset of all the rules in the dependency network must be executed and what their execution sequence should be. Once this is done the actual execution of the rules is straightforward. For example if product price changes all 3 rules need to be executed in the following sequence Rule1 Rule2 Rule3 . If only tax rate changes then the execution list is Rule2 Rule3 . If only number of payments changes then the execution list is Rule3 .

The rule interpreter can generate the execution list by using the recursive algorithm shown in EXAMPLE 9 below. With appropriate node pointer implementation the algorithm is fast. Such pointers allow for the insertion operation in insert current list to be performed in a single step. The flag which indicates that a node is in the execution list allows for a fast check rather than searching through the list . Thus the algorithm can be implemented so that its performance is of order N where N is the number of nodes in the DAG. The speed is therefore roughly linearly proportional to the number of nodes in the DAG. Note that with this algorithm variable nodes as well as rule nodes are inserted into the execution list but they can easily be pruned or skipped.

For any change in a variable in the dependency network this algorithm searches forward in the DAG and extracts the relevant sub network corresponding to rules that must be executed. EXAMPLE 10 below shows the call sequence and the execution list at each step in the algorithm for a change to the variable tax rate in the exemplary DAG of .

The algorithm described above can be applied repeatedly when more than one variable is changed to compute an execution list that takes all changes into account. For example if both variables A and B in change the algorithm can be called once for the change in variable A and then again for the change in variable B. The second call will add appropriately to the execution list. In this case nothing has to be added all rules are already being executed . Generally however there will be additions.

This approach allows the rule interpreter to generate an execution list and then possibly defer the actual rule execution which is typically far more computationally intensive than generation of the execution list until a later time. This can be advantageous for the following reasons. In certain applications values of variables affected by the changed variable may not immediately be needed the values may not have to be accessed by other code in the application for some time after the change . In some cases they may never be needed or they may not be needed for a long time. In such situations it is often better to defer rule execution until the time when a variable is actually needed. This allows utilizing algorithms that tailor the rule execution to limit it to only those variables that are needed. Also this deferral allows changes to accumulate which can save rule executions. In the dependency network of each of the changes to variables A and B requires execution of every rule in the network. Thus waiting for both to change instead of executing after each individual change cuts the number of rule executions in half. Of course it is not always possible to defer execution because deferring execution leaves the system in an inconsistent state where some rules may be violated. In the previous example if the effects of the change to variable A are needed immediately after the change and before the change to variable B then rule execution must happen after the change to variable A.

Although deferral of rule execution may be possible deferral of update of the execution list is not. In the previous example if variable A is changed it is important to note immediately the variables affected by the change even if rule execution is deferred. The presence of the variables in the execution list at the end of EXAMPLE 11 indicates that they all need to be recomputed in response to the change to variable A.

Propagation for simple formula declarative systems is relatively simple and efficient. Unfortunately simple formula declarative systems are not adequate for all applications. For such applications some of the restrictions on simple formula declarative systems have to be lifted. This results in a more complicated system with more complex rule interpretation. One such type of system is the Multiple source Directional Declarative System described below.

EXAMPLE 12 below shows an exemplary set of rules and shows an associated dependency network for a multiple source directional declarative system. The example is a diagnostic system which is a common application for multiple source directional declarative system. The rules are all if then rules that operate on boolean variables. This is a typical form for this type of application but more general rule forms and variable types are possible as well.

The fact that zero one or possibly more than one rule may produce a value for a variable drastically complicates matters for the rule interpreter.

The fact that rules may fail to produce a value for a variable means that all variables regardless of type must include a representation of the value unknown in their domains. Thus for example boolean variables can have values true or false or they may have the value unknown. Similarly integer variables can have an integer value or the value unknown. This complicates variable value computation. The simple sort and execute algorithm used for simple formula declarative systems is not adequate here. To see why this is so consider EXAMPLE 12. Suppose that initially light on is false light switch on is true and switch wire loose is false so Rule 1 is used to conclude that light switch broken is true. Now suppose that the variable light on changes to true. The sort algorithm for simple formula declarative systems would put Rule 1 on the execution list. However execution of Rule 1 has no effect. Because light on is now true the antecedent of Rule 1 fails and no conclusion is made. The value of light switch broken is unchanged it is still true. This is incorrect. Its value should be unknown.

For this type of system the correct approach is to first retract values of variables that are affected by a change and to set their values to unknown. After that the value of each such variable is recomputed by searching backwards in the dependency network to find all rules that are involved with computing a value for that variable. An exemplary algorithm for performing this task is summarized in EXAMPLE 13. Note that this algorithm uses a combination of forward and backward search of the dependency network. It performs a forward search similar to that used for simple formula declarative systems to identify variables that are affected by a particular variable change. For each such affected variable it performs a backward search to find rules involved with computing its value.

In EXAMPLE 12 See also when light on becomes true as discussed above the algorithm of EXAMPLE 13 first retracts the value of light switch broken and sets it to unknown. It then puts Rule 1 and Rule 2 on the execution list since both of these can compute values for light switch broken. It then executes these rules. In the scenario described above neither rule succeeds and the value of light switch broken remains unknown.

The fact that rules may produce more than one value for a variable also creates complications. If the rules all produce the same value for the variable then everything is consistent and there is no problem. However if they produce different values then there is an inconsistency sometimes also called an infeasibility . Suppose Rule 1 in EXAMPLE 12 were modified as follows 

Now suppose that light on is true light switch on is true and switch wire loose is also true. Rule 1 will compute false for light switch broken and Rule 2 will compute true. There is an inconsistency which typically means there is a bug either in the rule set or in the inputs. In this case it would make sense to inspect the switch wire closely to see if it is really loose.

The rule interpreter deals with inconsistencies of this sort by warning the user and providing information about the rules and input variables that cause the conflict. The user then has the option of changing the variables or rules until the conflict disappears.

Another complication with multiple source directional declarative systems is that logical loops can occur in the dependency network. This does not necessarily indicate a bug in the rule set. In fact such loops are sometimes perfectly reasonable and useful. Consider the exemplary rule set shown in EXAMPLE 14 and . This rule set is perfectly logical and reasonable. However the resulting dependency network is not a DAG. Hence it will cause problems for the algorithm given in EXAMPLE 13.

The problem is resolved by converting the dependency network to a DAG by utilizing for example the notion of a well founded support. A variable cannot be a well founded support for itself but it can be a well founded support for another variable. Thus in EXAMPLE 14 light switch on and light on are well founded supports for light switch broken. The algorithm that converts the dependency network of EXAMPLE 14 into a DAG searches backward from each variable finding its well founded supports. The search stops when there are no input rules for a variable or when a loop is detected when a variable already in the search path is encountered again . This results in the DAG dependency network shown in . This simply represents the fact that in this example two of the three variables must be input to the system so that the third can be computed. Note that the output of Rule2 cannot be chained to be used as an input to Rule 1.

Simple formula and multiple source directional declarative systems cover a wide range of applications. However there is an important class of applications that can be addressed only by lifting the directionality restriction on the multiple source directional declarative system. Such a system is called a constrained system.

A constrained system is a type of declarative programming system having the following characteristics 

Each of the equations can be considered a rule. For this sort of system the rule interpreter is an equation solving algorithm LU decomposition for example . If there are more variables than equations and a cost function is provided a linear programming algorithm can be used as the rule interpreter.

Systems of propositional logic clauses can be considered constrained systems. For example the propositional sentence consists of a set of clauses in conjunctive normal form that constrain the values of the boolean variables. The clauses can be thought of as rules and the rule interpreter is a propositional satisfaction algorithm like WALKSAT or DPLL. Such algorithms compute a set of values for the variables such that all the clauses are satisfied.

Constrained systems are not limited to numeric or boolean variables. Variables that have enumerated set types a discrete set of possible values are useful in an important class of applications. The domains of such variables can be constrained by rules. For example in a map coloring problem the variables represent the colors of countries on a map and the rules state that no two adjacent countries can have the same color. Constraint propagation algorithms of various types are used as the rule interpreters here.

Change tracking is a facility that automatically and efficiently detects when there are variable changes due to procedural assignment statements that may cause a declarative rule violation. Change tracking collects such variables and can be used to automatically invoke the rule interpreter between procedural statements in order to ensure that the declarative rules always appear consistent to the procedural system.

A change tracking system such as the change tracking system shown in above can be based on a number of fast predicates that indicate whether and how a variable participates in declarative processing. These predicates can utilize hash tables generated by the rule compiler part of the declarative processing system . The rule compiler generates the hash tables by first generating a dependency network based on the declarative rules. The dependency network indicates input and output variables of rules. The dependency network concisely indicates variables that participate in declarative processing. The rule compiler utilizes these variables to generate the hash tables. The rule compilation process will be explained in more detail in a subsequent section.

The hash tables contain information about variables that are mentioned in rules and how those variables are embedded within objects. The change tracking predicates use this information to determine whether a variable that has just been changed by a procedural assignment statement corresponds to a variable designation mentioned in a declarative rule.

EXAMPLE 2 shows predicates that can be used by the change tracking system. These predicates refer to the dependency network because the dependency network indicates whether and how variables participate in declarative processing. An exemplary dependency network is shown in . This dependency network corresponds to an order processing example problem that has object structure shown in EXAMPLE 5 and rules shown in EXAMPLE 17 this example will be discussed in more detail in a subsequent section . EXAMPLE 16 provides a table in which variables shown in are designated by property and class of object that contains the property. EXAMPLE 3 shows hash tables that support these predicates of filled in with values from the order computation example.

The change tracking system utilizes the predicate VariableDesignationInDependencyNetwork to ensure that the variable is actually in the dependency network and to determine its location in the dependency network. However it may first try some of the other predicates in order to quickly rule out variables that do not match. The reason is that the other predicates are typically faster because their supporting hash tables are smaller. For example change tracking may try the ContainingClasslnDependencyNetwork predicate first passing it the containing class for the changed variable. If this predicate returns false there is no need to try the computationally more expensive predicate VariableDesignationInDependencyNetwork.

These predicates may be used in two ways. They may be used at run time as part of execution of an assignment statement. For example the execution mechanism for an assignment statement calls the change tracking system if the variable value has changed. The change tracking system checks the predicates and if they return true invokes the declarative rule system.

Alternatively the compilation mechanism for the procedural system may check these predicates at compile time in order to emit appropriate code depending on the result. If the variable does not participate in declarative processing a simple version of the assignment statement is generated namely one that sets the variable and does nothing more. If on the other hand the variable does participate in declarative processing a more complex version is generated namely one that sets the variable checks if its value has changed and if so notifies the declarative rule system to propagate the change.

Note that any such compilation is invalidated if there are any changes to the rules which result in the predicate giving a different answer regarding the participation of a variable in declarative processing.

The following example involving an order processing problem illustrates an exemplary operation of the system in detail.

Consider the class definitions and instances for an order processing problem shown in EXAMPLE 5. Suppose that the declarative rules that refer to these classes are the ones shown in EXAMPLE 17. The dependency network generated by the rule compiler for this set of rules and class definitions is shown in .

Suppose that the variable Order 1.HandlingCost is changed by an assignment statement in the Procedural System. The Change Tracking System finds the class associated with this variable Order and invokes the first level predicate to see if this class is involved in declarative processing. Since it is the second level predicate is invoked with the full variable designation Order.HandlingCost . This predicate also returns a positive result. Therefore the Change Tracking System notifies the Declarative Rule System of the change to this variable.

The Declarative Rule System locates the variable designation in the dependency network and extracts a sub network consisting only of Rule1 and related variables. This is the only rule that needs to be executed to make the data consistent. The rule is executed using Order 1 to generate context and the variable Order 1.TotalCost is updated to be consistent with the new value of Order 1.HandlingCost.

Suppose instead that the variable changed by an assignment statement is OrderItem 1.Quantity. Now the sub network extracted consists of Rule2 as well as Rule1. Rule2 is executed first with OrderItem 1 establishing context followed by execution of Rule1 with Order 1 establishing context.

Suppose instead that the changed variable is Component 1.Price. Now the sub network is the entire dependency network and the rules are executed in the following sequence Rule4 Rule3 Rule2 Rule1 with Embed FC Component 1 establishing context for Rule4.

Table below shows variables shown in designated by property and class of object that contains the property see also EXAMPLE 4 . Full variable designation information is shown in the following table.

Those having ordinary skill in the art will appreciate that various changes can be made to the above embodiments without departing from the scope of the invention.

