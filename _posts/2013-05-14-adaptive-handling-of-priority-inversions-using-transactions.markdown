---

title: Adaptive handling of priority inversions using transactions
abstract: An operating system of a data processing system receives a request from a first process to acquire an exclusive lock for accessing a resource of the data processing system. A second priority of a second process is increased to reduce total execution time. The second process is currently in possession of the exclusive lock for performing a transactional operation with the resource. The second priority was lower than a first priority of the first process. The operating system notifies the second process to indicate that another process is waiting for the exclusive lock to allow the second process to complete or roll back the transactional operation and to release the exclusive lock thereafter.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09400677&OS=09400677&RS=09400677
owner: Apple Inc.
number: 09400677
owner_city: Cupertino
owner_country: US
publication_date: 20130514
---
This application claims the benefit of U.S. Provisional Patent Application No. 61 748 341 filed Jan. 2 2013 which is incorporated by reference herein in its entirety.

Embodiments of the present invention relate generally to data processing systems. More particularly embodiments of the invention relate to resource management of a data processing system.

In a typical data processing system multiple processes or threads may be executed simultaneously and these processes may compete for exclusive access of a particular resource such as a file or database. A single thread possesses a particular lock for exclusive access of a particular resource at a time. Different threads may vie for ownership of the lock. These threads may have different priorities assigned to them by the system. Typically threads servicing immediate user instigated actions have higher priorities than long running background tasks. After a thread has won ownership of the lock and begun executing within the critical session it typically cannot have its ownership preempted. Even if such a thread is the highest priority thread at the time it acquired the lock an even higher priority thread may come later and become blocked. As a result the higher priority thread has to wait for the lower priority thread to finish its current transactional operations and release the lock. This sort of priority inversion can result in reduced overall user responsiveness and or performance.

Various embodiments and aspects of the invention will be described with reference to details discussed below and the accompanying drawings will illustrate the various embodiments. The following description and drawings are illustrative of the invention and are not to be construed as limiting the invention. Numerous specific details are described to provide a thorough understanding of various embodiments of the present invention. However in certain instances well known or conventional details are not described in order to provide a concise discussion of embodiments of the present inventions.

Reference in the specification to one embodiment or an embodiment means that a particular feature structure or characteristic described in conjunction with the embodiment can be included in at least one embodiment of the invention. The appearances of the phrase in one embodiment in various places in the specification do not necessarily all refer to the same embodiment.

According to some embodiments a system is designed to improve handling of priority inversions around critical resources by terminating the lower priority ownership of the lock for accessing the resource and utilizing a recovery mechanism. In one embodiment the priority of a lower priority process which is in possession of ownership of the lock is boosted to at least match the priority of a higher priority process which is waiting for the lock for accessing the resource. The increased priority is to reduce the total lock hold time of the lower priority process by enabling the lower priority process to finish its current transactional operation e.g. critical section quicker but otherwise release the lock to the higher priority process in the normal fashion after the full completion of its current transactional operation.

For critical sections paired with a natural recovery mechanism such as database transactions or software transaction memory it is possible to go further and preempt the current execution of the critical section such that the higher priority process or thread may assume ownership of the lock even sooner. According to one embodiment the system e.g. a kernel of an operating system receives a request from a first process e.g. a higher priority thread to acquire a lock for accessing a resource where the lock is currently owned by a second process e.g. a lower priority thread that is currently performing a transactional operation on the resource. In response to the request the system increases a second priority of the second process to at least match a first priority of the first process. In addition the system notifies the second process indicating that there is another process waiting for the lock such that the second process can either complete the transaction with the increased priority or roll back the transaction and thereafter release the lock sooner.

According to another embodiment in response to the request received from the first process the system invokes the input output IO subsystem to reject any further access to the resource from the second process by returning a predetermined error. Such an error message may cause the second process to abort further access to the resource such as rolling back the current transaction and to release the lock thereafter. According to a further embodiment instead of waiting for the second process to roll back and to release the lock the system may immediately revoke or terminate the ownership of the lock from the second process and perform the rollback operation on behalf of the second process. Thereafter the lock is allocated or assigned to the first process without having to wait for the second process.

Kernel further includes a resource manager and a priority manager . Resource manager is responsible to keep track resource usage by processes . Resource manager is responsible for allocating or deallocating memory or other hardware resources e.g. processor or processor core resources for processes . Priority manager is responsible for assigning and modifying priorities for processes . Resource manager can then manage resource usages of processes based on their respective priorities. Typically a process with a higher priority can obtain resources quicker than a process with a lower priority. By increasing a priority of a process priority manager increases that particular process s chances to successfully compete against other processes for acquiring resources. Similarly a lower priority lowers the chances of the corresponding process against other processes for acquiring resources.

In this example it is assumed process has a higher priority than process . It is also assumed that process acquires a lock for exclusive access of resource and subsequently process requests an exclusive access to the same resource . In one embodiment the priority of process which is in possession of ownership of the lock is boosted by priority manager to at least match the priority of process which is waiting for the clock for accessing resource . The increased priority is to reduce the blockage of process which allows process to finish the current transactional operation e.g. critical section quicker but otherwise release the lock to process in the normal fashion after the full completion of the current transactional operation.

For critical sections paired with a natural recovery mechanism such as database transactions or software transaction memory it is possible to go further and preempt the current execution of the critical section such that process may assume ownership of the lock even sooner. According to one embodiment kernel receives a request from process e.g. a higher priority thread to acquire a lock for accessing resource where the lock is currently owned by process e.g. a lower priority thread that is currently performing a transactional operation on resource . In response to the request the system increases a second priority of process to at least match a first priority of process . In addition the system notifies process indicating that there is another process such as process waiting for the lock such that process can either complete the transaction with the increased priority or roll back the transaction and thereafter release the lock sooner. In this embodiment the system communicating with process via notification is referred to as operating in a cooperative mode.

According to another embodiment in response to the request received from process the system invokes the input output IO subsystem e.g. resource service component to reject any further access to the resource from process by returning a predetermined error. Such an error message may cause process to abort further access to resource such as rolling back the current transaction and to release the lock thereafter. In this embodiment the system is referred to as operating in a partially cooperative mode. According to a further embodiment instead of waiting for process to roll back and to release the lock the system may immediately revoke or terminate the ownership of the lock from process and perform the rollback operation on behalf of process . Thereafter the lock is allocated or assigned to process without having to wait for process . In this embodiment the system is referred to as operating in a non cooperative mode.

In the cooperative mode according to one embodiment after the system typically the kernel mediating the locks determines a higher priority thread is waiting for the lock it may send a message to the lower priority process currently owning the lock. The lower priority process may asynchronously handle the message to instruct itself to cease further work on the resource e.g. critical section and release the lock as soon as possible. In one embodiment this communication may be done by setting a flag that code within the critical section would periodically check. Upon determination that a higher priority thread is waiting the code operating within the critical section of the lower priority thread may cease its work and execute the recovery mechanism such as rolling back the database transaction or alternatively the lower priority thread may finish the transaction as soon as possible if it is deemed to be reasonable.

In one embodiment after rolling back the lower priority owner releases the lock. It would then attempt to re acquire the lock. At this point the system mediating the lock would have the opportunity to prioritize the new lock owner. The previous owner would wait until it was the highest priority thread still contending for ownership. Once it has re acquired the lock it would replay the operation it had aborted e.g. replay the rolled back database transaction . In this model owners who allow themselves to be pre empted need to maintain enough state before the critical section starts such that they can replay their attempted operations within the critical section multiple times. An example of this would be a system which maintains in memory the data it wishes to update in its next database transaction. After the transaction is rolled back it can simply try a new transaction again from the same in memory state.

In the partially cooperative mode according to one embodiment the system typically the kernel mediating the locks may cause the lock owner to jump to a cancellation point sooner by causing routines related to the critical section s operation to return errors immediately. For example in the case of a database holding a write lock the kernel could cause file IO routines associated with the file descriptor for the lock owner s process to return a specific error code forcing an immediate rollback. By refusing to allow any additional IO against that file descriptor the lock owner would have no choice but to jump to a cancellation point as soon as possible. In order to allow the recovery mechanism to proceed with a rollback the lock owner would send a message to the kernel acknowledging the error condition and its arrival at a cancellation point. At that time the kernel could then allow further IO against the file descriptor so that the database rollback can proceed.

According to one embodiment when the system operates in a non cooperative mode the system mediating the locks typically the kernel additionally implements the recovery mechanism itself. That is instead of waiting for the lock owner to provide the recovery the lock owner is pre empted and the kernel implements the actual rollback. In the lock owner s process all routines or potentially just writes related to that critical section file descriptor fail due to rejection by the system until the lock owner successfully re acquires the lock and re enters the critical section. Additionally these variations may supplement their approach with a maximum time out. If an owning process fails to yield the lock within that time window it can be terminated thereby establishing an upper bound on any failures due to lack of cooperation.

In one embodiment the focus is on file locks for database transactions between database connections typically within different processes. However embodiments of the invention can also be applicable to other types of critical sections within one or more processes provided a recovery mechanism exists for the critical section s operations such as software transaction memory.

Referring to in one embodiment system includes processor and peripheral interface also referred to herein as a chipset to couple various components to processor including memory and devices via a bus or an interconnect. Processor may represent a single processor or multiple processors with a single processor core or multiple processor cores included therein. Processor may represent one or more general purpose processors such as a microprocessor a central processing unit CPU or the like. More particularly processor may be a complex instruction set computing CISC microprocessor reduced instruction set computing RISC microprocessor very long instruction word VLIW microprocessor or processor implementing other instruction sets or processors implementing a combination of instruction sets. Processor may also be one or more special purpose processors such as an application specific integrated circuit ASIC a field programmable gate array FPGA a digital signal processor DSP a network processor a graphics processor a network processor a communications processor a cryptographic processor a co processor an embedded processor or any other type of logic capable of processing instructions. Processor is configured to execute instructions for performing the operations and steps discussed herein.

Peripheral interface may include memory control hub MCH and input output control hub ICH . Peripheral interface may include a memory controller not shown that communicates with a memory . Peripheral interface may also include a graphics interface that communicates with graphics subsystem which may include a display controller and or a display device. Peripheral interface may communicate with graphics device via an accelerated graphics port AGP a peripheral component interconnect PCI express bus or other types of interconnects.

An MCH is sometimes referred to as a Northbridge and an ICH is sometimes referred to as a Southbridge. As used herein the terms MCH ICH Northbridge and Southbridge are intended to be interpreted broadly to cover various chips who functions include passing interrupt signals toward a processor. In some embodiments the MCH may be integrated with processor . In such a configuration peripheral interface operates as an interface chip performing some functions of the MCH and ICH. Furthermore a graphics accelerator may be integrated within the MCH or processor .

Memory may include one or more volatile storage or memory devices such as random access memory RAM dynamic RAM DRAM synchronous DRAM SDRAM static RAM SRAM or other types of storage devices. Memory may store information including sequences of instructions that are executed by processor or any other device. For example executable code and or data of a variety of operating systems device drivers firmware e.g. input output basic system or BIOS and or applications can be loaded in memory and executed by processor . An operating system can be any kind of operating systems such as for example Windows operating system from Microsoft Mac OS iOS from Apple Android from Google Linux Unix or other real time or embedded operating systems such as VxWorks.

Peripheral interface may provide an interface to IO devices such as devices including wireless transceiver s input device s audio IO device s and other IO devices . Wireless transceiver may be a WiFi transceiver an infrared transceiver a Bluetooth transceiver a WiMax transceiver a wireless cellular telephony transceiver a satellite transceiver e.g. a global positioning system GPS transceiver or a combination thereof. Input device s may include a mouse a touch pad a touch sensitive screen which may be integrated with display device a pointer device such as a stylus and or a keyboard e.g. physical keyboard or a virtual keyboard displayed as part of a touch sensitive screen . For example input device may include a touch screen controller coupled to a touch screen. The touch screen and touch screen controller can for example detect contact and movement or break thereof using any of a plurality of touch sensitivity technologies including but not limited to capacitive resistive infrared and surface acoustic wave technologies as well as other proximity sensor arrays or other elements for determining one or more points of contact with the touch screen.

Audio IO may include a speaker and or a microphone to facilitate voice enabled functions such as voice recognition voice replication digital recording and or telephony functions. Other optional devices may include a storage device e.g. a hard drive a flash memory device universal serial bus USB port s parallel port s serial port s a printer a network interface a bus bridge e.g. a PCI PCI bridge sensor s e.g. a motion sensor a light sensor a proximity sensor etc. or a combination thereof. Optional devices may further include an imaging processing subsystem e.g. a camera which may include an optical sensor such as a charged coupled device CCD or a complementary metal oxide semiconductor CMOS optical sensor utilized to facilitate camera functions such as recording photographs and video clips.

Note that while illustrates various components of a data processing system it is not intended to represent any particular architecture or manner of interconnecting the components as such details are not germane to embodiments of the present invention. It will also be appreciated that network computers handheld computers mobile phones and other data processing systems which have fewer components or perhaps more components may also be used with embodiments of the invention.

Some portions of the preceding detailed descriptions have been presented in terms of algorithms and symbolic representations of operations on data bits within a computer memory. These algorithmic descriptions and representations are the ways used by those skilled in the data processing arts to most effectively convey the substance of their work to others skilled in the art. An algorithm is here and generally conceived to be a self consistent sequence of operations leading to a desired result. The operations are those requiring physical manipulations of physical quantities.

It should be borne in mind however that all of these and similar terms are to be associated with the appropriate physical quantities and are merely convenient labels applied to these quantities. Unless specifically stated otherwise as apparent from the above discussion it is appreciated that throughout the description discussions utilizing terms such as those set forth in the claims below refer to the action and processes of a computer system or similar electronic computing device that manipulates and transforms data represented as physical electronic quantities within the computer system s registers and memories into other data similarly represented as physical quantities within the computer system memories or registers or other such information storage transmission or display devices.

The techniques shown in the figures can be implemented using code and data stored and executed on one or more electronic devices. Such electronic devices store and communicate internally and or with other electronic devices over a network code and data using computer readable media such as non transitory computer readable storage media e.g. magnetic disks optical disks random access memory read only memory flash memory devices phase change memory and transitory computer readable transmission media e.g. electrical optical acoustical or other form of propagated signals such as carrier waves infrared signals digital signals .

The processes or methods depicted in the preceding figures may be performed by processing logic that comprises hardware e.g. circuitry dedicated logic etc. firmware software e.g. embodied on a non transitory computer readable medium or a combination of both. Although the processes or methods are described above in terms of some sequential operations it should be appreciated that some of the operations described may be performed in a different order. Moreover some operations may be performed in parallel rather than sequentially.

In the foregoing specification embodiments of the invention have been described with reference to specific exemplary embodiments thereof. It will be evident that various modifications may be made thereto without departing from the broader spirit and scope of the invention as set forth in the following claims. The specification and drawings are accordingly to be regarded in an illustrative sense rather than a restrictive sense.

