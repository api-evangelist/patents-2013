---

title: Universe migration from one database to another
abstract: A semantic layer (universe), which is created on a source database (DB), is migrated to a target DB. The migration includes pre-migration steps, actual migration and post-migration steps. The pre-migration steps prepare the target DB for the actual migration by configuring the target DB and determining the differences between the source DB and the target DB. During the actual migration, data, tables and views are migrated to the target DB conforming to the target database structure, functions and configuration. A new universe is created on the target database and all consumers of the source universe such as created reports are changed to refer to the new universe.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09176997&OS=09176997&RS=09176997
owner: SAP SE
number: 09176997
owner_city: Walldorf
owner_country: DE
publication_date: 20130628
---
Customers use databases from external providers to store data. There are many reasons to move from one database DB to another DB better performance change in data received from external providers corporate policy to move to a new DB etc.

Customers need to make a lot of changes to make an application compatible with a new DB. They have to migrate all their Business Objects content namely universes reports and other dependent components. It is a huge task to make all of these compatible with a new DB. A lot of time is expected to be needed for creating and tuning Universes.

Potential problems with a new DB may be that each DB has its own way of supporting Structured Query Language SQL tables and views are case sensitive a qualifier added to identify the table and view varies in each DB DB specific parameters need to be re mapped to a new DB etc. Another problem may be if not all tables are present in a DB. Some objects in a universe may have reference in queries and may not be part of the schema.

Embodiments of techniques for universe migration from a source database DB to a target DB are described herein. In the following description numerous specific details are set forth to provide a thorough understanding of the embodiments. One skilled in the relevant art will recognize however that the embodiments can be practiced without one or more of the specific details or with other methods components materials etc. In other instances well known structures materials or operations are not shown or described in detail.

Reference throughout this specification to one embodiment this embodiment and similar phrases means that a particular feature structure or characteristic described in connection with the embodiment is included in at least one of the one or more embodiments. Thus the appearances of these phrases in various places throughout this specification are not necessarily all referring to the same embodiment. Furthermore the particular features structures or characteristics may be combined in any suitable manner in one or more embodiments.

There are many Business Intelligence BI products that provide insight into customer data. There are also many report based solutions that allow customers to analyze and create ad hoc reporting on the data. Universe is a semantic layer that hides database details and gives business perspective. It allows end users easy way to understand customer data. It hides all the database internals and also it contains various parameters that would help users to tune queries and improve the performance. represents a semantic layer universe and its connections to a database and reporting servers . Customers create universes on a database in a generic way that can cater the needs of hundreds of reports. Many reporting solutions use universes as input for creating ad hoc report for analysis. Universe designers spend a lot of time in designing universes as being input for ad hoc reporting and analysis. A universe contains components that can be divided in to two categories visual components and data foundation. Visual components are used for reporting and are also called objects. They are dimensions details measures and filters. The end users choose combination of objects to create reports. Data foundation includes database schema and various parameters. A database schema is a graphical representation of DB structures. The database schema contains physical tables views and virtual tables based on for example Structure Query Language SQL queries that provide a result . The database schema also contains relations between the tables primary key foreign key etc. and joins left outer left inner right outer right inner . The joins link tables so that correct data is returned for queries. All the information is used to generate queries during the report creation. The various parameters are used for report creation customization and performance tuning.

At block configuration data is loaded by flapping DB functions front the source DB to the target DB. The mapping is performed using the source connection and the target connection. DB functions may be used in SQL queries part of the universe objects. When these objects are used in reports the SQL queries will be generated based on objects syntax. DB functions may vary from one database to another. Configuration data provides mapping of DB functions from a source DB to a target DB.

At block the source universe is examined. In one embodiment examining the source universe includes the steps as described further in connection to .

At block a script is generated to create corresponding tables in the target DB that are unavailable in the target DB compared to the source DB. A list of tables not present in the target DB is created after the source universe examination and comparison to the target DB.

At block the integrity of all tables in the target DB is checked. These tables include available tables in the target DB and tables created at block . The integrity means the data contained is accurate and reliable.

At block a new data foundation is created in the target DB. In one embodiment creating the new data foundation includes the steps as described further in connection to .

At block reports created on the source universe are determined and the reports are adapted to point to the new universe. In one embodiment determining the reports includes determining of consumers of the source universe preparing a list of reports created on the source universe and changing references of the reports created on the source universe to point to the new universe.

Further at block joins and contexts are determined for the list of used tables in the source DB. Context is a set of joins in a universe which provides a valid join path between tables for generating queries. First a list of joins is prepared type syntax etc. and then for each context the used joins.

At block a list of objects is determined. In one embodiment determining the list of objects includes identifying used DB functions. In one embodiment the list of objects includes dimensions details measures and filters.

At block security applied on the source universe is determined. The security may be applied on tables and objects. In one embodiment determining the security applied on the source universe includes examining security rules and determining queries containing DB functions.

At block alias tables and derived tables are added to the target DB from the list of used tables in the source DB based on dependency logic. For a derived table the source table functions have to be replaced with matched functions according to step in . A new query is then used to create the derived table in the target DB.

A script generator engine is operable to generate a script to create one or more corresponding tables in the target DB wherein the created one or more corresponding tables are from a list of used tables in the source DB unavailable in the target DB .

A migration engine performs the migration from the source universe to the new universe. The migration engine is operable to examine the source universe. In one embodiment the migration engine is also operable to determine the list of used tables in the source DB determine joins and contexts for the determined list of used tables determine a list of objects and determine security applied on the source universe . In one embodiment the of used tables includes tables views alias tables and derived tables. In one embodiment the migration engine is operable to identify used DB functions . In one embodiment the objects may be dimensions details measures and filters. In one embodiment the migration engine is operable to examine security rules and determine queries containing DB functions. The migration engine is also operable to check integrity of available and created tables in the target DB . The migration engine is further operable to persist the new universe and check the integrity of the new universe. In one embodiment the new universe is persisted in repository . The migration engine is also operable to determine reports created on the source universe and adapt the reports to point to the new universe in one embodiment the reports are accessed through a reporting server .

Some embodiments may include the above described methods being written as one or more software components. These components and the functionality associated with each may be used by client server distributed or peer computer systems. These components may be written in a computer language corresponding to one or more programming languages such as functional declarative procedural object oriented lower level languages and the like. They may be linked to other components via various application programming interfaces and then compiled into one complete application for a server or a client. Alternatively the components maybe implemented in server and client applications. Further these components may be linked together via various distributed programming protocols. Some example embodiments may include remote procedure calls being used to implement one or more of these components across a distributed programming environment. For example a logic level may reside on a first computer system that is located remotely from a second computer system containing an interface level e.g. a graphical user interface . These first and second computer systems can be configured in a server client peer to peer or some other configuration. The clients can vary in complexity from mobile and handheld devices to thin clients and on to thick clients or even other servers.

The above illustrated software components are tangibly stored on a computer readable storage medium as instructions. The term computer readable storage medium should be taken to include a single medium or multiple media that stores one or more sets of instructions. The term computer readable storage medium should be taken to include any physical article that is capable of undergoing a set of physical changes to physically store encode or otherwise catty a set of instructions for execution by a computer system which causes the computer system to perform any of the methods or process steps described represented or illustrated herein. A computer readable storage medium may be a non transitory computer readable storage medium. Examples of non transitory computer readable storage media include but are not limited to magnetic media such as hard disks floppy disks and magnetic tape optical media such as CD ROMs DVDs and holographic devices magneto optical media and hardware devices that are specially configured to store and execute such as application specific integrated circuits ASICs programmable logic devices PLDs and ROM and RAM devices. Examples of computer readable instructions include machine code such as produced by a compiler and files containing higher level code that are executed by a computer using an interpreter. For example an embodiment may be implemented using Java C or other object oriented programming language and development tools. Another embodiment may be implemented in hard wired circuitry in place of or in combination with machine readable software instructions.

A data source is an information resource. Data sources include sources of data that enable data storage and retrieval. Data sources may include databases such as relational transactional hierarchical multi dimensional e.g. OLAP object oriented databases and the like. Further data sources include tabular data e.g. spreadsheets delimited text files data tagged with a markup language e.g. XML data transactional data unstructured data e.g. text files screen scrapings hierarchical data e.g. data in a file system XML data files a plurality of reports and any other data source accessible through an established protocol such as Open DataBase Connectivity ODBC produced by an underlying software system e.g. ERP system and the like. Data sources may also include a data source where the data is not tangibly stored or otherwise ephemeral such as data streams broadcast data and the like. These data sources can include associated data foundations semantic layers management systems security systems and so on.

In the above description numerous specific details are set forth to provide a thorough understanding of embodiments. One skilled in the relevant art will recognize however that the embodiments can be practiced without one or more of the specific details or with other methods components techniques etc. In other instances well known operations or structures are not shown or described in details.

Although the processes illustrated and described herein include series of steps it will be appreciated that the different embodiments are not limited by the illustrated ordering of steps as some steps may occur in different orders some concurrently with other steps apart from that shown and described herein. In addition not all illustrated steps may be required to implement a methodology in accordance with the one or more embodiments. Moreover it will be appreciated that the processes may be implemented in association with the apparatus and systems illustrated and described herein as well as in association with other systems not illustrated.

The above descriptions and illustrations of embodiments including what is described in the Abstract is not intended to be exhaustive or to limit the one or more embodiments to the precise forms disclosed. While specific embodiments of and examples for the invention are described herein for illustrative purposes various equivalent modifications are possible within the scope of the invention as those skilled in the relevant art will recognize. These modifications can be made in light of the above detailed description. Rather the scope is to be determined by the following claims which are to be interpreted in accordance with established doctrines of claim construction.

