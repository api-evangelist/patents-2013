---

title: Test case pattern matching
abstract: Received source code is transformed according to a predefined rule set to create an encoded text string representation of each function of the received source code. Each encoded text string representation of each function of the received source code includes a text string that identifies each parameter type of the respective function of the received source code, and is compared in real time with encoded text string representations of stored source code fragments in a repository. Each stored source code fragment is transformed according to the same predefined rule set into the respective encoded text string representations that each include a text string that identifies each parameter type of a respective function of the respective stored source code fragment. An indication of each portion of the received source code determined to already exist as a stored source code fragment in the repository is outputted in response to the real-time comparison.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09389849&OS=09389849&RS=09389849
owner: GLOBALFOUNDRIES INC.
number: 09389849
owner_city: Grand Cayman
owner_country: KY
publication_date: 20131125
---
This application is a continuation of and claims priority to and claims the benefit of U.S. patent application Ser. No. 12 643 893 titled TEST CASE PATTERN MATCHING which was filed in the United States Patent and Trademark Office on Dec. 21 2009 and which is incorporated herein by reference in its entirety and this application also claims priority to and claims the benefit of European Patent Application Serial No. EP09151985.0 titled TEST CASE PATTERN MATCHING which was filed in the European Patent Office on Feb. 3 2009 and which is also incorporated herein by reference in its entirety. This application is also related to U.S. patent application Ser. No. 13 434 495 titled TEST CASE PATTERN MATCHING which was filed in the United States Patent and Trademark Office on Mar. 29 2012.

The present subject matter relates to a method of and system for providing feedback on source code being created. In one embodiment the invention may be used for real time test case pattern matching.

Software testing is an investigation carried out to provide information about the quality of the software product under test in relation to the environment in which it is intended to operate. This includes for example the execution of a program with the intent of finding errors. The primary purpose of such software testing is to discover failures so that the detected errors may be corrected. The scope of software testing often includes the execution of the code in various environments and under different conditions. In the current culture of software development a testing organization may be separate from the development team. Information derived from the software testing may be used to correct the original process by which the software is developed.

With the increasing time and resource pressures on test organizations it is vitally important that every new test case that is written is as effective as possible. Test effectiveness in this context means that a new test case would exercise the maximum amount of the system under test s SUT untested code with the minimum amount of overlap and duplication of existing test cases. The ideal situation in relation to testing using a test suite would be to have test cases that all exercise different areas of the software code. The main benefit being that there is no duplication of test code or effort. However there is an added benefit in that it becomes easier to isolate bugs.

In the case where each test is testing a different part of the code it is likely that one bug in the SUT may only cause one test case to fail. In reality the coverage provided by the tests tends to be creation tests that are overlapping in relation to the code that comprises the SUT. This results in large amounts of duplication and overlap and consequently large amounts of wasted effort. It also means that a single bug may be likely to cause the failure of multiple test cases thus making debugging more complex. The problem is that the test case programmer receives little help in determining the effectiveness of their test until it is too late to do anything about it.

The current solution to this problem is to use code coverage instrumentation for example tools such as EMMA emma.sourceforge.net during the test execution phase and then carry out a complex analysis of the output to determine which SUT code is covered by each test case. At this point overlaps and duplication may be identified so that a more modular test suite may be produced on the second pass. However the main drawback to this solution is that it is necessary to write all the test code set up the SUT instrument the SUT execute the test cases analyse the code coverage output and finally make the assessment on each test s effectiveness before the test programmer may take any action. This is a very time consuming and costly exercise to do properly. In addition the test code programmers are very reluctant to change what is probably already a valid test case just to remove the duplication. So valuable time and resources may be wasted.

According to a first aspect of the present invention there is provided a method of providing feedback on source code being created comprising receiving source code processing the received source code according to a predefined rule set to create a representation of the received source code accessing a source code repository comprising source code fragments each source code fragment in the repository processed according to the predefined rule set to create a representation of the respective source code fragments comparing the representation of the received source code to each representation of the source code fragments calculating a matching score for the representation of the received source code with respect to each representation of the source code fragments based upon an output of the comparison step and presenting an output derived from the calculated matching scores.

According to a second aspect of the present invention there is provided a system of providing feedback on source code being created comprising a display device a user interface arranged to receive source code and a processor programmed to process the received source code according to a predefined rule set to create a representation of the received source code access a source code repository comprising source code fragments each source code fragment in the repository processed according to the predefined rule set to create a representation of the respective source code fragments compare the representation of the received source code to each representation of the source code fragments calculate a matching score for the representation of the received source code with respect to each representation of the source code fragments based upon an output of the comparison step and present an output derived from the calculated matching scores via the display device.

According to a third aspect of the present invention there is provided a computer program product on a computer readable storage medium including computer readable program code for providing feedback on source code being created wherein the computer readable program code when executed on a computer causes the computer to receive source code process the received source code according to a predefined rule set to create a representation of the received source code access a source code repository comprising source code fragments each source code fragment in the repository processed according to the predefined rule set to create a representation of the respective source code fragments compare the representation of the received source code to each representation of the source code fragments calculate a matching score for the representation of the received source code with respect to each representation of the source code fragments based upon an output of the comparison step and present an output derived from the calculated matching scores.

Owing to the present subject matter a method is provided that is capable of letting the test programmer know in real time i.e. at the point that they are actually writing the code whether an area of code they are attempting to test has already been exercised. In addition to letting the programmer know about existing test cases the method may also identify areas of testing that may be rationalized or reused across a test suite to enhance maintainability. The method may recognize patterns in the test code and match them with existing patterns in the source code to highlight potential duplication. The assumption being that similar patterns of test code will drive similar code coverage patterns in the SUT. By moving the verification as early in the process as possible test organizations may realize large savings in time and resources by developing more effective test cases.

The method and system may be used to provide a user interface allowing code development with continuous reference to a code repository and visual feedback on the uniqueness of the code being written. This allows a developer to instantly have reference to potential areas of re use as well as a clear indication of when a test is treading new ground. So that code in an editor will have visual cues color may be used to identify code that exists in full or in part within existing files in the code repository. By showing common routines and providing links to other examples a developer may quickly have reference to code that is intended to be similar as well as quickly show that new code is indeed testing sequences that are not already covered by existing tests.

Furthermore the immediate feedback on where sequences of calls exist already in the code base may lead to identification of functions currently implemented in a single test case that may be generic helper functions since they are about to be needed by the new code . The editor may provide the ability to re factor a function from its point in the code repository to be added to a helper function that may then be called by the existing test and this new test. This step may require re factoring of the original test case and the function itself if the function was not originally written to be modular. However any variable references that relied on global scope may be fixed by making them function inputs.

The resulting interface may yield significant productivity gains allowing testers to stick to standard style where they expect code to be similar and quickly identify any existing similar test code. The method allows the minimizing of the time that is spent re writing code that already exists and maximizing confidence that new code is indeed testing new things within the SUT.

Advantageously the step of comparing the representation of the received source code to a representation of a source code fragment comprises comparing one or more lines of the representation of the received source code to one or more lines of the representation of the source code fragment. A line by line comparison may be used to compare the source code being entered to the source code stored in the repository. This provides a simple and efficient method of determining the extent of the similarity between the two components.

In one embodiment the step of calculating a matching score for the representation of the received source code with respect to a representation of a source code fragment comprises calculating a binary score indicating whether there is a match. The method may be used to identify only those components within the stored source code of the repository that are identical to the new source code being created.

In a further embodiment the step of calculating a matching score for the representation of the received source code with respect to a representation of a source code fragment comprises calculating a score based upon the number of matching lines between the representation of the received source code and the representation of the source code fragment. An improved feedback result may be achieved by deriving a matching score from the extent of the match between the new source code and the existing source code. This may be a percentage of lines that match between the two components or may be a number representing the number of patterns within the new source code that match with the existing source code. This may be used to provide an output to the user that may support a more intelligent review of those parts of the existing source code that are relevant to the new source code being created.

The step of presenting an output derived from the calculated matching scores comprises displaying a representation of the source code repository indicating the matching of the representation of the received source code with respect to the representations of the source code fragment the representation indicating the level of matching within portions of the source code repository. The user may be provided with a visualization of the stored source code that indicates where there is matching to the current source code being created and also the user may receive an indication of the extent of that matching. An alternative visual representation may be that the source code that the user is creating is highlighted in some way to indicate those portions that match existing source code. For example the user may enter ten lines of source code and those lines that are detected as existing already may be highlighted to the user.

A client device such as a standard desktop computer is shown in . The client device is connected to a remote server which functions as a source code repository . The client device comprises a processor a user interface and a display device . Further components of the client device are also present but not shown such as storage components and network connections and so on. The client device serves the function of allowing a software developer or software tester to create source code either for the purpose of adding to or amending the source code already present on the source code repository or for the purpose of creating one or more tests for use in a testing of source code on the source code repository . A computer readable medium is provided such as a CD ROM which stores a suitable software developer kit SDK for creating the source code when that SDK is run by the client device .

The solution to the problems such as those described above is a system in three principal parts. First there is provided a method and system for indexing the repository of source code based on a canonical form template to be appropriate to the language context of the source code . For example a typical language canonical form may ignore all comments within the source code and refer to all variables based on their type and constant value where applicable . The indexing may also provide a means of representing tests as sequences of function calls grouped in accordance with a template to represent calls which equate to product API test infrastructure calls base function library calls.

Each fragment of the original source code may be processed using the predefined rule set to produce a respective representation of the original fragment within the overall representation . The purpose of the conversion of the original source code is to remove and or change aspects of the source code that would make later searching difficult. For example comments inserted by developers have no programming purpose other than to inform later readers of the source code about the function of particular routines and may be removed in the translation from the original source code to the representation . Similarly certain types of routines and functions embodied by the fragments of the source code may be converted into a predefined format using a template specified in the rule set.

Second an editor or plug in for the SDK is provided which will dynamically hold a canonical representation of an active code fragment using the same rules as are currently active for the code repository . Additionally the editor may provide visual feedback colored to indicate duplicated code areas and uniqueness.

Finally a search engine is used which may form part of the SDK the plug in or may be a completely separate unit. The search engine takes in the canonical code fragments and separates them into API sequences to perform independent searches against the source code of the indexed code repository . Each sequence is searched as a multiple set. First a search for just the first line gives a hit count for its occurrences then a search for the first and second in a sequence gives a count for the occurrences of both lines in that order. The sequence is continued until there are 0 counts for the set in a row. This forms a break point and a new search is performed for only the last line and its count is also determined forming the start of potentially a new group of calls in a sequence. Once completed the search results yield scores for each sequence of calls in terms of the hit count on the existing code base. By separating the sequences as they apply to separate APIs it is possible to ignore irrelevant differences such as the order of unrelated calls. The values are fed to the editor visualization which is displayed on the external display which codes each entry in the code fragment with its own uniqueness and a second value for the group if any that it is within.

The next step is the step S of accessing the source code repository where each source code fragment in the repository has already been processed according to the same predefined rule set to create a representation of the respective source code fragments . At step S there is then carried out the step of comparing the representation of the received source code to each representation of the source code fragments . In one embodiment the step S comprises comparing one or more lines of the representation of the received source code to one or more lines of the representation of a source code fragment stored in the repository .

The next step S comprises calculating a matching score for the representation of the received source code with respect to each representation of the source code fragments based upon the output of the comparison step S. In one form the step of calculating a matching score comprises calculating a binary score 1 or 0 indicating whether there is a match or not. In another arrangement the step of calculating a matching score comprises calculating a score based upon the number of matching lines between the representation of the received source code and the representation of the source code fragment . In this latter case the match may be represented as a percentage for example giving a range of 0 no match at all to 100 the two representations being identical .

The final step in the method is step S which comprises presenting an output derived from the calculated matching scores. Preferably this step comprises displaying a representation of the source code repository indicating the matching of the representation of the received source code with respect to the representations of the source code fragment the representation indicating the level of matching within portions of the source code repository .

The matching process has identified two parts of the source code in the repository as matching the current source code entered by the user. The icons indicating the match may be color coded to represent the extent of the match if a percentage system is being used for example. Alternatively if a binary system of matching is being used then the parts of the source code that are identical to the entered source code may be indicated. It should be understood that the matching is between the representations of the two source codes i.e. after they have been processed with the rule set to convert them to the template form of the source code.

The user interface may provide various features that the user may access to improve the functionality of the matching and display process. For example the SDK may be arranged so that the user may switch between the binary and graded systems of matching and indeed set the level of the grading. For example if a percentage system is being used then the user may set a level such as 90 and only those portions of the source code that have a 90 or greater similarity with the source code being entered may be displayed to the user. The user may also drill down into the code as displayed in the window with a zoom like function. This may be used to find out more detail about the matching code indicated by the icons .

To aid understanding the following steps provide a practical example of how the method may be implemented for the specific piece of source code shown in . These steps are to be done in real time as the user is typing code into the editor.

Step A canonicalized version of the code is held internally in which all comments white space and formatting is removed. This enables code to be compared from people with different coding styles.

Step Encode function calls to differentiate overloaded parameters. A sample encoding mechanism to differentiate overloaded functions may be addItem String addItem String and addItem int addItem Int.

From the above code it is possible to get three unique patterns. As the number of lines increases so does the number of patterns at an exponential rate. A maximum depth value may be used to limit the number lines that are used to generated patterns in a section of code.

Step Compare generated patterns against stored patterns and flag existence switch on existing patterns. When code is integrated into a code repository its code patterns are generated and stored in a database such as DB2 for real time pattern matching. It is this database that the above patterns are compared against.

Below are some scenarios that show the effectiveness of pattern matching against test cases. It is assumed that Test1.java from Step has already been integrated into the code repository and therefore its patterns exist in the database.

Looking at the patterns it may be seen that they already exist. Therefore Test2b.java is giving no additional value on top of what is already present.

Scenario 2 Test2b.java contains same code as Test1.java but the other way around Test2b.java canonicalized encoded 

By switching the deleteItem String and addItem String calls around there has now been generated a new test case as shown in pattern 3.

By adding another function call changeItem String the coverage of the test has changed since there are four new patterns being tested. Therefore Test3.java provides considerable value on top of the tests already in the code repository.

Step Visually represent findings in real time. Even a simple count of existence flags gives a value of four. Having understood which code patterns are new and which ones already exist this data may be visually presented to the user. A simple mechanism for this would be to count the NEW flags for a block of code and show the value. In this case Test2a.java would have a value of 0 to signify it has little value. Test2b.java has a value of 1 and Test3.java has a value of 4 .

Other mechanisms may be to change the background color of the lines of code to signify their value. In this case blocks of code may be shown to have a background color or shading if they provide no additional value and potentially a different color or shading to show unique patterns. Additionally grades of color may be chosen to indicate larger stretches of repeated code such that the more lines in a row that are found elsewhere in the repository the darker the color. shows an alternative view of the visualisation of the matching process in which the display device shows the entered source code with existing code highlighted by shading. Warnings may be provided on the left hand side bar not shown providing access to quick help features to provide options such as importing existing functions or refactoring to new shared features. shows the prompt to import existing functions from the code repository to create a new test pattern and shows a tool used to detect an existing pattern and to prompt a user to generate a shared library. These example mechanisms may give the developer real time feedback at the point of writing code to steer them to writing the most effective code based on the existing information within the code repository.

The system described above also has the additional benefit of highlighting potential code re use. For example when new code is written where areas of it are shown to already exist in the code repository this highlights potential areas of code re use. This common pattern code may be put into a library function and called from the many areas where it is shown to exist.

As will be appreciated by one skilled in the art aspects of the present invention may be embodied as a system method or computer program product. Accordingly aspects of the present invention may take the form of an entirely hardware embodiment an entirely software embodiment including firmware resident software micro code etc. or an embodiment combining software and hardware aspects that may all generally be referred to herein as a circuit module or system. Furthermore aspects of the present invention may take the form of a computer program product embodied in one or more computer readable medium s having computer readable program code embodied thereon.

Any combination of one or more computer readable medium s may be utilized. The computer readable medium may be a computer readable signal medium or a computer readable storage medium. A computer readable storage medium may be for example but not limited to an electronic magnetic optical electromagnetic infrared or semiconductor system apparatus or device or any suitable combination of the foregoing. More specific examples a non exhaustive list of the computer readable storage medium would include the following an electrical connection having one or more wires a portable computer diskette a hard disk a random access memory RAM a read only memory ROM an erasable programmable read only memory EPROM or Flash memory a portable compact disc read only memory CD ROM an optical storage device a magnetic storage device or any suitable combination of the foregoing. In the context of this document a computer readable storage medium may be any tangible medium that can contain or store a program for use by or in connection with an instruction execution system apparatus or device.

A computer readable signal medium may include a propagated data signal with computer readable program code embodied therein for example in baseband or as part of a carrier wave. Such a propagated signal may take any of a variety of forms including but not limited to electro magnetic optical or any suitable combination thereof. A computer readable signal medium may be any computer readable medium that is not a computer readable storage medium and that can communicate propagate or transport a program for use by or in connection with an instruction execution system apparatus or device.

Program code embodied on a computer readable medium may be transmitted using any appropriate medium including but not limited to wireless wireline optical fiber cable RF etc. or any suitable combination of the foregoing.

Computer program code for carrying out operations for aspects of the present invention may be written in any combination of one or more programming languages including an object oriented programming language such as Java Smalltalk C or the like and conventional procedural programming languages such as the C programming language or similar programming languages. The program code may execute entirely on the user s computer partly on the user s computer as a stand alone software package partly on the user s computer and partly on a remote computer or entirely on the remote computer or server. In the latter scenario the remote computer may be connected to the user s computer through any type of network including a local area network LAN or a wide area network WAN or the connection may be made to an external computer for example through the Internet using an Internet Service Provider .

Aspects of the present invention are described below with reference to flowchart illustrations and or block diagrams of methods apparatus systems and computer program products according to embodiments of the invention. It will be understood that each block of the flowchart illustrations and or block diagrams and combinations of blocks in the flowchart illustrations and or block diagrams can be implemented by computer program instructions. These computer program instructions may be provided to a processor of a general purpose computer special purpose computer or other programmable data processing apparatus to produce a machine such that the instructions which execute via the processor of the computer or other programmable data processing apparatus create means for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

These computer program instructions may also be stored in a computer readable storage medium that can direct a computer or other programmable data processing apparatus to function in a particular manner such that the instructions stored in the computer readable storage medium produce an article of manufacture including instructions which implement the function act specified in the flowchart and or block diagram block or blocks.

The computer program instructions may also be loaded onto a computer other programmable data processing apparatus or other devices to cause a series of operational steps to be performed on the computer other programmable apparatus or other devices to produce a computer implemented process such that the instructions which execute on the computer or other programmable apparatus provide processes for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

The flowchart and block diagrams in the Figures illustrate the architecture functionality and operation of possible implementations of systems methods and computer program products according to various embodiments of the present invention. In this regard each block in the flowchart or block diagrams may represent a module segment or portion of code which comprises one or more executable instructions for implementing the specified logical function s . It should also be noted that in some alternative implementations the functions noted in the block may occur out of the order noted in the figures. For example two blocks shown in succession may in fact be executed substantially concurrently or the blocks may sometimes be executed in the reverse order depending upon the functionality involved. It will also be noted that each block of the block diagrams and or flowchart illustration and combinations of blocks in the block diagrams and or flowchart illustration can be implemented by special purpose hardware based systems that perform the specified functions or acts or combinations of special purpose hardware and computer instructions. A data processing system suitable for storing and or executing program code will include at least one processor coupled directly or indirectly to memory elements through a system bus. The memory elements can include local memory employed during actual execution of the program code bulk storage and cache memories which provide temporary storage of at least some program code in order to reduce the number of times code must be retrieved from bulk storage during execution.

Input output or I O devices including but not limited to keyboards displays pointing devices etc. can be coupled to the system either directly or through intervening I O controllers.

Network adapters may also be coupled to the system to enable the data processing system to become coupled to other data processing systems or remote printers or storage devices through intervening private or public networks. Modems cable modems and Ethernet cards are just a few of the currently available types of network adapters.

The terminology used herein is for the purpose of describing particular embodiments only and is not intended to be limiting of the invention. As used herein the singular forms a an and the are intended to include the plural forms as well unless the context clearly indicates otherwise. It will be further understood that the terms comprises and or comprising when used in this specification specify the presence of stated features integers steps operations elements and or components but do not preclude the presence or addition of one or more other features integers steps operations elements components and or groups thereof.

The corresponding structures materials acts and equivalents of all means or step plus function elements in the claims below are intended to include any structure material or act for performing the function in combination with other claimed elements as specifically claimed. The description of the present invention has been presented for purposes of illustration and description but is not intended to be exhaustive or limited to the invention in the form disclosed. Many modifications and variations will be apparent to those of ordinary skill in the art without departing from the scope and spirit of the invention. The embodiment was chosen and described in order to best explain the principles of the invention and the practical application and to enable others of ordinary skill in the art to understand the invention for various embodiments with various modifications as are suited to the particular use contemplated.

