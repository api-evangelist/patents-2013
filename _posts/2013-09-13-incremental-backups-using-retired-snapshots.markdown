---

title: Incremental backups using retired snapshots
abstract: Systems and methods for performing backups to a storage device are provided. For virtual disks of a virtual machine, snapshots are used to backup data periodically to a storage device. A disk virtualization layer “retires” data blocks associated with a snapshot, while retaining a list of block addresses, for comparison in future backup operations. The retired snapshot can be compared against future snapshots to generate incremental backups without occupying storage space with data blocks that have already been copied to another storage device.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09514002&OS=09514002&RS=09514002
owner: VMware, Inc.
number: 09514002
owner_city: Palo Alto
owner_country: US
publication_date: 20130913
---
This application is related to co pending U.S. patent application Ser. No. 14 026 789 filed on the same day as this application and also entitled Incremental Backups Using Retired Snapshots the entire contents of which are incorporated by reference herein.

Traditional backup software uses a driver that tracks changes made to a persistent storage device also called a hard disk herein. The changes are used to backup only the parts of the disk that have changed since the last backup. However such drivers require specialized code for each operating system. Also implementation of the drivers is complex to ensure that not a single change is missed this is particularly hard during a boot process.

Additionally present backup methods do not handle complex situations in an efficient manner. For example some existing backup routines use an archive bit where one bit is designated to a file and the bit is turned on when data in that file is changed. A backup just retrieves and replicates files that have the corresponding bit turned on. When the backup is completed all the archive bits are cleared. A drawback is that a break down would occur due to resetting of the bits when an additional backup application uses this interface. Even worse the problem would not be detected by the additional backup application. Also the archive bit corresponds to an entire file and thus if one part of a file is changed then all of it is backed up.

Other existing backup methods use redo logs. Once a redo log is created all changes to a disk are captured in the redo log. When a backup is to be performed data stored in the redo log is used for the backup. A new redo log is then created and the prior one is committed into the base disk. However this method is costly in terms of additional operations and additional disk space required particularly if there is more than one application performing a backup. This costly overhead stems for example from the fact that redo logs also preserve the prior state of the disk.

Using timestamps also requires relatively heavy storage and or processing. Also if the backup is taken from an alternate location such as a dedicated backup server issues could arise if the clocks between a virtual machine whose data is being backed up and a backup server are not tightly synchronized If the clock on the backup server is ahead of the clock in the virtual machine backups might be incomplete.

Another backup method uses checksums. While this method can deliver incremental image level backups its scalability is limited. For example every time a backup is performed the entire disk to be backed up has to be read by the backup application. Hence the load on the data source is not reduced compared to performing a full backup every time. Also reliable checksums e.g. cryptographic hashes can be computationally expensive to compute.

One or more embodiments of the present disclosure provide a method system and computer readable storage medium having executable instructions for generating incremental backups for a virtual disk. In one embodiment the method includes receiving a request to take a snapshot of a first virtual disk associated with a virtual machine. The first virtual disk may include a first plurality of data blocks and a first block allocation map having a first plurality of entries associated with the first plurality of data blocks. The method further includes generating a second virtual disk comprising a reference to the first virtual disk and a second block allocation map having a second plurality of entries corresponding to the first plurality of entries. The method includes storing a copy of the first plurality of data blocks in a second storage device and modifying an indication associated with the first virtual disk wherein the indication represents that the first virtual disk has been retired. The method further includes determining changes between the first virtual disk and the second virtual disk based on a comparison of the second block allocation map against the first block allocation map and generating a backup comprising the determined changes in the virtual disk.

One or more embodiments disclosed herein provide methods systems and computer programs for tracking changes of virtual devices and making incremental backups using the tracked changes. Further embodiments save storage space on the physical device underlying the virtual device by putting the set of tracked changes in a state i.e. retired where the changes are remembered without having to store the data underlying the changes. As such next time an incremental backup is performed the state of the disk at last backup is available however conventional known techniques require the old state to effectively keep around all the data that was on the previous backup just so that the state of the previous backup can be remembered.

As shown in host includes a disk interface depicted as a Host Bus Adapter HBA and a network interface depicted as a network interface card NIC which enable host to connect to storage system . As further shown in a hypervisor is installed on top of hardware platform and supports a virtual machine execution space within which multiple virtual machines VMs may be instantiated and executed. Each such virtual machine implements a virtual hardware platform that supports the installation of a guest operating system OS which is capable of executing one or more applications not shown . Examples of a guest OS include any of the well known commodity operating systems such as Microsoft Windows Linux and the like. In each instance guest OS includes a native file system layer for example either an NTFS or an ext3FS type file system layer. These file system layers interface with virtual hardware platforms to access from the perspective of guest operating systems a data storage HBA which in reality is virtual HBA implemented by virtual hardware platform that provides the appearance of disk storage support in reality virtual disks to enable execution of guest OS transparent to the virtualization of the system hardware. In certain embodiments virtual disks may appear to support from the perspective of guest OS the SCSI standard for connecting to the virtual machine or any other appropriate hardware connection interface standard known to those with ordinary skill in the art including IDE ATA and ATAPI.

Although from the perspective of guest operating systems file system calls initiated by such guest operating systems to implement file system related data transfer and control operations appear to be routed to virtual disks for final execution in reality such calls are processed and passed through virtual HBA to adjunct virtual machine monitor VMM layers that implement the virtual system support needed to coordinate operation with hypervisor . In particular a HBA emulator of each VMM functionally enables the data transfer and control operations to be correctly handled by hypervisor which ultimately passes such operations through its various layers to true hardware HBAs or NIC that connect to storage system . Assuming a SCSI supported virtual device implementation although those with ordinary skill in the art will recognize the option of using other hardware interface standards SCSI virtualization layer of hypervisor receives a data transfer and control operation in the form of SCSI commands for example intended for a SCSI compliant virtual disk from VMM layers and converts them into file system operations that are understood by virtual machine file system VMFS in order to access a file stored in one or more logical unit numbers LUNs in storage system under the management of VMFS that represents the SCSI compliant virtual disk. In one embodiment the file representing the virtual disk e.g. virtual disk conforms to the VMware Virtual Disk VMDK file format promulgated by VMware Inc. for virtual disks although it should be recognized that alternative virtual disk file formats may be used in other embodiments.

SCSI virtualization layer then issues these file system operations to VMFS . VMFS in general manages creation use and deletion of files e.g. such as .vmdk files representing virtual disks stored on LUNs exposed by storage system . VMFS converts the file system operations received from SCSI virtualization layer to volume e.g. LUN block operations and provides the volume block operations to logical volume manager . Logical volume manager LVM is typically implemented as an intermediate layer between the driver and file system layers and supports volume oriented virtualization and management of the LUNs accessible through HBAs and NIC . LVM issues raw SCSI operations to a data access layer based on the LUN block operations. Data access layer includes a device access layer which discovers storage system and applies command queuing and scheduling policies to the raw SCSI operations and a device driver which understands the input output interface of HBAs and NIC interfacing with storage array and sends the raw SCSI operations from the device access layer to HBAs or NIC to be forwarded to storage array .

It should be recognized that the various terms layers and categorizations used to describe the virtualization components in may be referred to differently without departing from their functionality or the spirit or scope of the invention. For example VMMs may be considered separate virtualization components between VMs and hypervisor which in such a conception may itself be considered a virtualization kernel component since there exists a separate VMM for each instantiated VM. Alternatively each VMM may be considered to be a component of its corresponding virtual machine since such VMM includes the hardware emulation components for the virtual machine. In such an alternative conception for example the conceptual layer described as virtual hardware platform may be merged with and into VMM such that virtual host bus adapter is removed from i.e. since its functionality is effectuated by a host bus adapter emulator within VMM .

According to one embodiment VMFS may include a virtual disk layer that provides applications with access to virtual disk storage. Virtual disk layer in response to requests from applications via an application programming interface API may create virtual machine disk files e.g. .vmdk files provide read and write access to a virtual disk and create snapshots of virtual disks. By exposing functionality of virtual disk storage virtual disk layer enables a wide variety of uses for example the creation of virtual machine disk files to store backup of physical images read access to virtual disks for off line centralized anti virus scanning of virtual machines write access to virtual disks for off line centralized patching of virtual machines read access to virtual disks for off line software package analysis of virtual machines. In one particular implementation virtual disk layer may be a pre packaged library or API having a plurality of functions and methods that may be invoked by applications and an example of which includes Virtual Disk Development Kit VDDK made available by VMware Inc. of Palo Alto Calif.

In one embodiment a backup agent is configured to backup data e.g. virtual disks of virtualized computing architecture to a backup storage system . As shown in backup agent may use virtual disk layer to access virtual disks and backup virtual disk data to backup storage system . Backup storage system may be similar to storage system and may any of suitable persistence storage system including disk arrays solid state drives and tape drives. While backup storage system is depicted as connected directly to host it should be recognized that intermediary communication agents and components may be arranged between host and backup system including a communications network and proxy backup agents. Further while backup agent is depicted as an application executing on host it should be recognized that backup agent may be executing in one of the VMs of host or in an external server communicatively connected to host .

Each virtual disk may behave as a block addressable device that retains content of blocks of data distinguished by a logical block address which abstracts the physical location of data in regions of the virtual disk. Virtual disk can be accessed by a VM for read and write operations using the logical block addresses. In one embodiment a virtual disk includes a data structure depicted in as a block allocation map which maps each logical block address to a corresponding physical address. During operation the logical block addresses specified by read and write operations are translated to corresponding physical block addresses using block allocation map .

According to one embodiment virtual disks may comprise independent allocation maps that reference a shared pool of data blocks as shown in greater detail in . According to another embodiment virtual disks may comprise allocation maps that reference each other and whose data blocks are independent described later.

Each entry of the block allocation map may have an address field for a physical block address PBA that specifies the storage region containing the corresponding data block . For example in one implementation each entry may contain a 64 bit physical block address specifying a guest physical location i.e. physical from the VM s perspective of data block . It should be recognized that the physical block addresses for data blocks may be non contiguous and distributed across the underlying storage device. In the example shown in LBA 0 points to the location for data block LBA 3 points to the location for data block LBA 4 data block .

In certain embodiments for space efficiency virtual disk may record and retain only those blocks which have been explicitly written i.e. allocated and returning all zeros for read operations on unwritten blocks i.e. unallocated blocks although other implementations of thin allocation may be used. To implement such functionality entries in block allocation map are marked as allocated or unallocated. In one embodiment an entry may be marked as allocated simply by storing a physical block address in field . An entry may be marked as unallocated by storing a special or reserved value in physical block address field for example a or NULL address shown in .

According to one embodiment block allocation map may be extended to include indications that a data block had been previously allocated and is now de allocated in contrast to a data block has never been allocated. In some embodiments an entry may be marked as previously allocated now de allocated by storing a special or reserved value different from the special value indicating a never allocated data block i.e. character . In the example shown in LBA 5 contains a special value represented by the character T indicating the corresponding data block had been trimmed.

In one embodiment each data block is associated with a reference count that indicates a number of entries of block allocation maps that reference the corresponding data block . It should be appreciated that data blocks of storage may be shared by multiple virtual disks and reference counts enable embodiments of the present disclosure to track related blocks across allocation maps as described in greater detail later.

While one particular embodiment of block allocation map is depicted in it should be recognized that other implementations of the data structure may be utilized and are within the scope of the present disclosure. For example rather than store special or reserved values within physical block address to indicate unallocated data blocks entries in block allocation map may have a separate dedicated field for indicating state of a data block i.e. allocated never allocated previously allocated . In another example while reference count is depicted as part of a data structure for a data block reference counts for data blocks may be maintained in a separate centralized data structure.

To read a logical block from a virtual disk having an independent block allocation map referencing shared data blocks virtual disk layer determines whether block allocation map has an allocated data block for the requested block. If so virtual disk layer returns that data block . Otherwise virtual disk layer returns a block of zeros.

To write a logical block to virtual disk virtual disk layer first receives a request to write data to a block having a given logical address. Virtual disk layer determines whether the block is unallocated based on block allocation map . If unallocated virtual disk layer allocates a new data block updates the corresponding entry in block allocation map with the physical block address of the new data block sets an associated reference count to 1 and writes the data. Otherwise if the logical block has an allocated data block already virtual disk layer determines whether the reference count associated with the existing data block is equal to 1. If so virtual disk layer overwrites data of the existing data block with the new data of the received write request. If the associated reference count is not equal to 1 i.e. other block allocation maps still refer to this data block virtual disk layer decrements the associated reference count of the existing data block allocates a new block updates the corresponding entry in block allocation map with the physical block address of the new data block sets the reference count to 1 and writes the data.

To delete a disk virtual disk layer is configured to for each block in an allocation map de allocate a data block if the associated reference count is equal to 1. In one implementation the associated reference count may be zeroed upon de allocation. In another implementation free data blocks are maintained in a central list or tree and reference counts associated with free blocks in the central list or tree are implicitly zero due to the blocks inclusion within the list of free blocks. After completion of this process virtual disk layer de allocates block allocation map and then deletes the disk.

According to one embodiment virtual disk layer is configured to generate a snapshot of one or more virtual disks that represents the state of a virtual machine at the time the snapshot was taken. In some embodiments snapshot may include files and memory state of a virtual machine s guest operating system and may include settings and configuration of a virtual machine and its virtual hardware . In some embodiments snapshot may be stored within storage device as a set of files for example in the same directory as other files that comprise a virtual machine .

In some embodiments virtual disk layer may quickly and efficiently make a snapshot of virtual disk by recording the logical block addresses of each block that has been written as of that moment in time. Virtual disk layer may be further configured to capture changes to virtual disk after that particular moment in time by making a snapshot at that moment then using copy on write COW techniques to record subsequently written blocks in the list of addresses e.g. block allocation map for snapshot and not the parent virtual disk or vice versa . In some embodiments virtual disk layer may be configured to quickly and efficiently compare a snapshot to a parent disk e.g. virtual disk to discover the list of addresses of changed data blocks . These features of snapshots and comparing snapshots are used for example to facilitate incremental backups which back up only those files and data that have changed since the last backup whether the last backup was a full backup or a previous incremental backup.

To create an incremental backup a backup agent e.g. backup agent periodically makes snapshots of the virtual disk compares the new snapshot to an earlier created snapshot and copies the changed data blocks to another storage device such as backup storage system . However using known techniques the incremental backup process must retain the latest snapshot until the time of a next backup to be a basis for comparison with the next backup. This retention may be considered wasteful since the incremental backup made a copy of exactly that retained data to backup storage system already.

Embodiments of the present disclosure provide a technique for retiring data blocks associated with a snapshot while retaining the list of block addresses for future compare operations. The described technique solves the problem of duplicate data retention discussed above by providing a snapshot that can be compared against another snapshot i.e. a future snapshot while not occupying storage space with data blocks that have already been copied to another storage device i.e. backup system .

At step virtual disk layer generates a snapshot of the target virtual disk. According to one embodiment virtual disk layer creates a second virtual disk having a block allocation map copied from the target virtual disk. Virtual disk layer steps through the copied block allocation map and for each allocated block increment the associated reference count to represent that the second virtual disk references the same data blocks.

In the example shown in virtual disk includes a block allocation map that references a plurality of shared data blocks which are similar to block allocation map and data blocks of . Block allocation map includes entries that map logical block addresses e.g. LBA 0 to LBA 4 to physical block addresses for data blocks . For simplicity of illustration entries of block allocation map are notated as A T or . In the A notation represents that the data block corresponding to the block allocation map entry is allocated i.e. entry contains a physical block address . The notation represents that the data block corresponding to the block allocation map has never been allocated i.e. entry contains the special value . The T notation represents that the data block corresponding to the block allocation map entry had been previously allocated and is now de allocated i.e. entry contains the special value . In logical blocks LBA 0 LBA 1 and LBA 3 have been written to and map to allocated data blocks and as such are depicted with A notations logical blocks LBA 2 and LBA 4 are unallocated and are therefore depicted with notations.

As shown in virtual disk layer generates a second virtual disk with a block allocation map which is a copy of block allocation map for virtual disk . Physical block addresses of block allocation map point to the same physical data blocks that are shared between the virtual disks. As shown reference counts associated with each of allocated data blocks are incremented e.g. from 1 to 2 . While depicts virtual disk as being left as the current disk and the second virtual disk being designated as the snapshot it should be recognized that in alternative embodiments virtual disk layer may associate the second virtual disk as current disk of VM in place of virtual disk and designate the target virtual disk as snapshot .

At step backup agent uses virtual disk layer to retrieve all data from the initial snapshot for a full backup. It should be appreciated that virtual disk layer handles the extraction of data from the virtual disks of a virtual machine. At step responsive to an access request for all data from the initial snapshot virtual disk layer queries the block allocation map of the initial snapshot and at step returns every data block that is marked as allocated. As described earlier virtual disk layer walks through the block allocation map and retrieves data blocks for any logical blocks marked as allocated within the block allocation map e.g. LBA 0 LBA 1 LBA 3 in and returns zeros for an unallocated blocks e.g. LBA 2 LBA 4 .

At step backup agent copies the returned data blocks to backup storage system thereby forming a full backup. As shown in backup storage device includes a copy of data blocks .

At step backup agent requests virtual disk layer to retire the initial snapshot. At step virtual disk layer generates a data structure herein referred to as a retired block allocation map for the initial now retired snapshot. Virtual disk layer may delete data blocks associated the snapshot as part of the retirement process. In some embodiments virtual disk layer uses a TRIM primitive to delete data blocks which causes corresponding entries in block allocation map for those deleted data blocks to be marked as unallocated specifically previously allocated now de allocated. Virtual disk layer may retain an internal copy of the retired block allocation map for later use for example in compare or delete operations.

According to one embodiment to retire a snapshot or virtual disk virtual disk layer steps through each entry in the block allocation map of the snapshot and for each block if the associated reference count is equal to 1 de allocates the data block and marks the block as trimmed within the block allocation map. In cases where a data block is shared among block allocation maps of virtual disks i.e. the associated reference count is greater than 1 virtual disk layer does not change the associated reference count and retains untrimmed shared blocks in the block allocation map of the snapshot so that untrimmed shared data blocks can be seen as unchanged in later compare operations described later. In some embodiments virtual disk layer may register retired disks with untrimmed blocks in a list and the retirement process described above e.g. in step may be performed periodically in the background on all retired disks on the list. In such an embodiment retiring a snapshot may have no immediate effect on a block allocation map other than marking the disk as retired or registering the retired disk to the list. Rather data blocks get trimmed as activity on the live disk e.g. virtual disk causes reference counts on referenced blocks to decrement to 1 according to the operations to write a logical block to virtual disk described above. Virtual disk layer retains responsibility for trimming retired snapshots for example by a background process that trigger scans of retired snapshots.

Retired snapshot having a retired block allocation map is depicted in greater detail in . As shown data blocks and have been trimmed from retired snapshot subsequent to being de allocated in first virtual disk in the case of block or being replaced with a copy on write block in the case of block as a copy of this data is retained at backup storage device . Retired block allocation map is similar to the original block allocation map except that some data blocks marked as allocated i.e. with entries of block allocation map having A are now marked as previously allocated now de allocated i.e. with T . It has been determined that by having separate states that distinguish between trimmed and unallocated data blocks retired snapshots may be used subsequently for comparison purposes.

Under conventional backup approaches an entire previous snapshot would be retained and used for comparison when the next incremental backup is taken. In another conventional technique this snapshot would be deleted after the backup is complete that is changes made after taking the snapshot are saved to the parent snapshot disk and a traditional backup agent retains a copy of the snapshot data for later comparison. In both cases storage space is wasted on retaining this past data. Accordingly embodiments of the present disclosure provide an improved technique for backing up data that reduces the amount of storage space needed to perform backups. The use of the retired snapshot saves storage space because the data blocks themselves no longer need to be retained by the backup agent or virtual disk. Further although some existing devices might have a trim facility conventional trim functionality does not distinguish unallocated blocks from trimmed blocks and therefore a snapshot trimmed on such a device would not be useful for comparison.

At some subsequent time i.e. t t backup agent may initiate a process for an incremental backup. In some embodiments backup agent may initiate the incremental backup process after a pre determined period of time or in some embodiments responsive to user input. It should be recognized that by the subsequent time i.e. t t read and write operations may have been performed on virtual disk during the operation of the virtual machine . As described above write operations on virtual disk may use copy on write COW techniques to record subsequently written blocks to new allocation blocks and update reference counts of the previously referenced data blocks. As such virtual disk is depicted in as having a modified block allocation map and one or more modified data blocks that reflect changes made to virtual disk .

Modified block allocation map shown in illustrates an exemplary range of scenarios for changed data blocks. In one scenario an allocated data block may be trimmed by guest operating system . This may occur when guest operating system deletes one or more files or other data and passes a TRIM command to inform an underlying storage device in fact virtual hardware which blocks of data are no longer considered in use and can be wiped internally. In the example shown the logical block LBA 0 was allocated in as depicted by the A notation and is de allocated in as depicted by the notation. Further data block has been discovered by the background retirement process described earlier and has been de allocated and the associated reference count has been set to zero.

In another scenario an allocated data block may be changed or written over for example when an application or guest operating system performs a write operation on existing logical blocks when saving a document. In the example shown the logical block LBA 1 is allocated to data block in and is modified at t tand allocated to a new data block as depicted in . Also depicted in is previous data block de allocated and the associated reference count set to zero having been discovered by the background retirement process described earlier. While not shown in it should be recognized that virtual disks may have one or more intermediary snapshots that continue to be reference data blocks shared with current virtual disks .

In yet another scenario an unallocated data block may be written to for example when an application or guest operating system performs a write operation on an unallocated logical block when creating a new file. In the example shown the logical block LBA 2 was unallocated in as depicted by the notation and at t tis allocated to data block as depicted in with a A notation.

Finally in some scenarios an allocated data block may remain unchanged as in the example of allocated logical block LBA 3 depicted in maintaining the A notation. Similarly an unallocated data block may remain unchanged i.e. unallocated as in the example of unallocated logical block LBA 4 depicted in maintaining the notation.

Referring back to to initiate an incremental backup process at step backup agent makes a new snapshot. Similar to the operation in step above at step virtual disk layer generates a new snapshot of the target virtual disk to be backed up. As shown in a new snapshot is created that includes a copy of the updated block allocation map as of time t tand is linked to virtual disk .

At step backup agent uses virtual disk layer to compare new snapshot and previous retired snapshot and retrieve data blocks that have changed between new snapshot and previous snapshot . In some embodiments backup agent may request virtual disk layer to retrieve data blocks and pass references or identifiers to particular retired snapshots to accomplish the desired comparison.

At step virtual disk layer compares retired block allocation map of previous retired snapshot to block allocation map of the new snapshot to determine which data blocks have changed between the two snapshots i.e. since the last full or incremental backup . Virtual disk layer can infer the changed data blocks using the retired snapshot according to logic listed below in Table 1.

According to one embodiment when the new snapshot and the previous snapshot both have allocated blocks for a corresponding entry in their block allocation maps the result may be determined based on a Write Block on Compare function as shown in Table 1 and is described as follows. If both allocation maps of the previous and new snapshot have the same block then the block is omitted from the result. However if the allocation maps of the previous and new snapshot have different data blocks which may be enforced by the copy on write behavior of the block allocation maps then the data block associated with the new snapshot is included in the result and written out. In one embodiment the result is an accumulated set of allocated data blocks.

In the example shown in virtual disk layer determines a de allocate operation for logical block LBA 0 i.e. dealloc LBA 0 because logical block LBA 0 in new snapshot has been de allocated and corresponding logical block LBA 0 in retired snapshot had been trimmed. Regarding logical block LBA 1 virtual disk layer determines contents of logical block LBA 1 from the new snapshot should be written i.e. write LBA 1 block to the incremental backup because logical block LBA 1 in new snapshot has been allocated and is different than the data block and the logical block LBA 1 in retired snapshot had been trimmed. Virtual disk layer determines contents of logical block LBA 2 from the new snapshot should be written i.e. write LBA 2 block to the incremental backup because the newer logical block LBA 2 has been allocated and changed i.e. A and the previous logical block LBA 2 from retired snapshot had not been unallocated i.e. . It should be recognized that even though contents of block allocation map abstractly depict A T and notation the above described write operations use physical block addresses found within entries of block allocation map of the new snapshot.

Virtual disk layer determines no changed data blocks for logical block LBA 3 i.e. no change because even though the newer logical data block LBA 3 in snapshot has been allocated the data block has not been changed i.e. A notation . Therefore since the corresponding entry in retired block allocation map contains the same physical block address i.e. same A value virtual disk layer can infer that a copy of the contents of logical block LBA 3 is already being retained in backup storage for example in full backup . Virtual disk layer further determines no changed data blocks for logical block LBA 4 i.e. no change because corresponding entries in the newer block allocation map and retired block allocation map both indicate an unallocated block i.e. .

At step virtual disk layer returns a copy of changed data blocks to backup agent which at step writes the data blocks to backup storage system as an incremental backup. In the example shown in backup agent writes the data blocks as an incremental backup linked to full backup which represents files and data which have changed since full backup has made.

After the backup is complete at step backup agent uses virtual disk layer to delete the retired snapshot and at step retires the new snapshot as depicted in by a cross out of retired snapshot .

Responsive to a request to delete the retired snapshot at step virtual disk layer for each block in allocation map de allocates any data blocks in allocation map of disk that are not shared by other allocation maps i.e. if the associated reference count is equal to 1 . After completion of this process virtual disk layer de allocates block allocation map and then deletes disk .

Responsive to a request to retire the new snapshot virtual disk layer performs a process similar to that described above in step of method . Virtual disk layer writes changes made after the snapshot back into the parent snapshot disk thereby changing the state of the virtual machine to the current state. Then at step virtual disk layer generates a new retired block allocation map for the new retired snapshot. Virtual disk layer deletes data blocks associated with new snapshot . In some embodiments virtual disk layer uses a TRIM primitive to delete data blocks which causes entries of block allocation map corresponding to the deleted data blocks to be marked as unallocated specifically previously allocated now de allocated. In some embodiments virtual disk layer registers new snapshot to a list for background processing of trimmed data blocks. As described earlier virtual disk layer may retain an internal copy of the retired block allocation map until a next incremental backup is made or return the retired block allocation map to backup agent . It should be recognized that operations from step to step may repeat for each incremental backup made for one or more virtual disks.

In one embodiment entries in block allocation map may be marked as allocated unallocated and previously allocated now de allocated similar to block allocation map . In one embodiment an entry may be marked as allocated simply by storing a physical block address in field which is depicted in with simply an A value to represent the block has been allocated and includes a physical block address for simplicity of illustration. An entry may be marked as unallocated by storing a special or reserved value in physical block address field for example a or NULL address . An entry may be marked to indicate that a data block had been previously allocated and is now de allocated in contrast to a data block has never been allocated by storing a special or reserved value represented by the character T i.e. for trimmed in .

Virtual disks may be associated with other virtual disks in a predecessor successor relationship. In one embodiment virtual disk includes a predecessor field which references another virtual disk associated with virtual disk . Predecessor field may have a null value for virtual disks that are a base or initial disk in a chain of virtual disks as shown in .

In one embodiment virtual disk may include a successors field a retired field and a deleted field . Successors field may be a count of disks of which virtual disk is a predecessor. Retired field may be a state variable e.g. bit flag that is configured to indicate whether virtual disk has been retired . Deleted field may be a state variable e.g. bit that is configured to indicate whether virtual disk has been deleted. In some embodiments retired field and deleted field may be initially cleared e.g. set to a zero or null value as depicted in . While one particular embodiment of virtual disk is depicted in it should be recognized that other implementations of described data structures may be utilized and are within the scope of the present disclosure. For example retired field and deleted fields may be combined and implemented as a single multi bit variable.

To create an incremental backup backup agent periodically creates a snapshot of virtual disk compares the new snapshot to an earlier created and retired snapshot and copies changed data blocks to another storage device such as backup storage system similar to methods described earlier. In one embodiment backup agent may make at least one full backup of a virtual disk selected as a subject for the backup procedure. Periodically or responsive to user input backup agent may use virtual disk layer e.g. via API call to make an initial snapshot of virtual disk that represents the state of virtual disk at the time the snapshot was taken i.e. at t t .

Backup agent may use virtual disk layer to read and retrieve all blocks from the initial snapshot i.e. virtual disk for a full backup. In one embodiment to read a block from a disk having a shared block allocation map referencing data blocks e.g. virtual disk virtual disk layer may determine whether block allocation map is allocated and references a data block . If so the contents of the data block are returned. Otherwise if that logical block is unallocated then the requested block is recursively fetched from a predecessor. If there is no predecessor then it may be inferred that the data block was never allocated and therefore the read request returns a block of zeros. If a trimmed block is encountered virtual disk layer may raise an internal error. It should be recognized that the read operation described herein may be used to create full backups incremental backups and perform routine read operations during runtime of a VM.

Backup agent copies the returned data blocks to backup storage system thereby forming a full backup not shown . Similar to method backup agent may request virtual disk layer to retire the initial snapshot i.e. virtual disk .

To retire a disk virtual disk layer sets retired field of a target virtual disk to indicate virtual disk has been retired. Virtual disk layer then selectively cleans up and trims data blocks of virtual disk based on whether virtual disk has successor virtual disks that might rely on data blocks referenced by block allocation map of virtual disk . In one embodiment responsive to determining virtual disk has no successors i.e. successors field is equal to zero virtual disk layer de allocates all allocated data blocks referenced by block allocation map marking the de allocated data block as trimmed. Responsive to determining virtual disk has a successor i.e. successors field is equal to 1 virtual disk layer selectively trims data blocks of virtual disk based on whether successive virtual disks have newer corresponding data blocks allocated or whether successive virtual disks continue to rely on underlying data blocks of virtual disk . In one embodiment for the chain of predecessors starting at the current disk e.g. virtual disk for each predecessor block that is allocated virtual disk layer de allocates and trims that retiree block. In virtual disk has no block allocated within block allocation map and as such no blocks are trimmed from retired virtual disk .

At some subsequent time i.e. t t backup agent may initiate a process for an incremental backup. It should be recognized that by the subsequent time t t2 read and write operations may have been performed on virtual disk during runtime of the VM e.g. VM . Read operations on a virtual disk having shared block allocation maps that reference each other proceed as described above. Write operations on virtual disks having shared block allocation maps is shown in greater detail in .

At step virtual disk layer determines whether the data block is currently unallocated. If so at step virtual disk layer allocates a new data block from the underlying storage device e.g. storage and at step writes the data to that new data block. Otherwise at step virtual disk layer overwrites data to the currently allocated data block.

For example as shown in responsive to a request to write in LBA 0 of virtual disk virtual disk layer allocates a new data block modifies block allocation map to reference new data block and writes data to block as depicted by the A notation within LBA0 of block allocation map . It should be recognized that this example illustrates writing a block when an existing data block is already allocated for a predecessor disk . In another example responsive to a request to write in a LBA2 virtual disk layer allocates a new data block write data to the new block and updates block allocation map . It should be recognized that this example illustrates writing to a block that has never been allocated in predecessor disks i.e. corresponding logical block LBA2 in predecessor disk has a special value or null character .

Referring back to virtual disk layer proceeds to selectively trim data blocks of predecessor disks that are no longer relied upon by successor disks. In one embodiment at step virtual disk layer determines whether the predecessor disk of the current disk is retired and the corresponding block of the predecessor disk is allocated. If so at step virtual disk layer de allocates the block referenced by the predecessor and at step marks the block as trimmed within in the allocation map of the predecessor disk. It should be recognized that de allocation of a data block may include invoking a TRIM operation of the block addressable device if the device supports such an operation. Otherwise if the correspond block of the predecessor disk is not allocated including not trimmed at step then virtual disk layer recursively checks the predecessor disk s predecessor.

In the example shown in when processing write operation to LBA0 virtual disk layer determines that predecessor disk of current disk is retired based on the value of retired field . Further virtual disk layer determines that the corresponding block LBA0 of block allocation map is allocated. As such virtual disk layer de allocates data block and marks the data block as trimmed within block allocation map .

In another example shown in when processing write operation on LBA2 virtual disk layer determines that predecessor disk of current disk is retired but the corresponding block LBA2 of block allocation map is not allocated. Virtual disk layer proceeds to recursively check the predecessor disk of predecessor disk . However since predecessor field has a null value i.e. virtual disk is an initial or base disk virtual disk layer takes no further action.

Referring back to the incremental backup process to initiate an incremental backup process at a subsequent time t2 backup agent makes a new snapshot. As shown in virtual disk layer creates a new virtual disk having an empty allocation map and that references virtual disk via predecessor field and designates virtual disk as the current disk for VM . Virtual disk layer increments successors field of virtual disk and designates virtual disk as the new snapshot.

Backup agent may use virtual disk layer to compare a new snapshot e.g. virtual disk with a previous retired snapshot e.g. virtual disk and retrieve a result set comprising data blocks that have changed between snapshots. In one embodiment to compare a first virtual disk against a second virtual disk virtual disk layer first determines whether there is any predecessor chain from the first virtual disk to the second virtual disk. In many cases the first virtual disk may be considered the later more recent snapshot and the second virtual disk is the earlier less recent snapshot although any virtual disks in any order may be compared for various effects. If no chain exists virtual disk layer may raise an error. Otherwise virtual disk layer proceeds as follows.

In one embodiment for the chain of predecessors starting from the first virtual disk through to but not including the second virtual disk virtual disk layer processes each block in the block allocation map of the current predecessor. In some embodiments responsive to determining that a block in the block allocation map is allocated that block may be added to the result set if that block address is not already in the result set. In some embodiments responsive to determining that a block in the block allocation map is unallocated that block may be skipped. In some embodiments responsive to determining that a block in the block allocation map has been trimmed an error may be raised because only the oldest disk in the chain may be trimmed. Virtual disk layer returns the result set comprising the accumulated set of allocated blocks determined based on the comparison between snapshots.

In the example shown in virtual disk layer may compare virtual disk against retired virtual disk as depicted by arrow . Starting from the chain of predecessors from virtual disk through to but not including virtual disk i.e. a chain containing just virtual disk virtual disk layer processes each block in block allocation map of the current predecessor i.e. virtual disk . Virtual disk layer determines that LBA 0 and LBA 2 of block allocation map are allocated and therefore includes data blocks and into a result set. Virtual disk layer skips LBA 1 LBA 3 and LBA 4 of block allocation map because LBA 1 LBA 3 and LBA 4 are unallocated in block allocation map . In one embodiment backup agent may write data blocks and as an incremental backup linked to the full backup which represents file and data which have changed since the full backup has been made to backup storage system .

In one embodiment backup agent may then deletes the previous retired snapshot for example virtual disk . A delete operation on virtual disks having shared block allocation maps is shown in greater detail in .

At step virtual disk layer receives a request to delete a target virtual disk e.g. virtual disk . At step virtual disk layer determines whether the target virtual disk has no successors by checking if successors field is equal to zero. If there are no successors i.e. successors 0 at step virtual disk layer determines whether the predecessor disk has been marked as deleted i.e. via deleted field . If not deleted at step virtual disk layer updates the predecessor disk by updating the predecessor disk s successors field to represent the target disk is being deleted for example by decrementing the predecessor disk s successors field. Otherwise if the predecessor is marked deleted at step virtual disk layer recursively applies the algorithm described in method to the predecessor disk marked deleted.

At step virtual disk layer de allocates all allocated blocks in block allocation map of the target disk which may include invoking a TRIM operation of the storage device. It has been determined that because the target disk has no successors e.g. in step all allocated blocks of the target disk do not need to be propagated up any chain of virtual disks and may be de allocated. At step virtual disk layer may de allocate the block allocation map of the target disk and may complete deletion of the target disk including any files related therewith .

At step virtual disk layer determines whether the target virtual disk has exactly one successor for example by checking successor field is equal to 1. If there is one successor i.e. successors 1 at step virtual disk layer determines whether the predecessor disk has been marked as deleted i.e. via deleted field . If not deleted at step virtual disk layer decrements the predecessor disk s successor field. Otherwise if the predecessor disk is marked deleted at step virtual disk layer recursively applies the algorithm described in method to the predecessor disk marked deleted.

At step virtual disk layer finds an immediate successor to the target disk starting at the current disk for the VM based on the chain of virtual disks e.g. via references in predecessor field . At step for each allocated block in the block allocation map of the target disk that is not allocated in the immediate successor virtual disk layer moves the data block from the target disk to the successor. In some embodiments virtual disk layer moves or copies a physical block address of a data block allocated in the target disk to the corresponding entry in the block allocation map of the successor disk. This process ensures data blocks relied upon by successor disks continue to be persisted within the virtual disk after the base or predecessor disks have been deleted. At step virtual disk layer de allocates the allocation map of the target disk and completes deletion of the target disk including any files related therewith. It should be recognized that the recursive operation of step may result in movement of data blocks from predecessor disks to an immediate successor and then to another immediate successor and so forth from multiple links down the chain of virtual disks.

At step responsive to determining there are more than one successors to the target disk i.e. successors not equal to either zero or one virtual disk layer sets deleted flag of the target virtual disk.

In the example shown in the previously retired snapshot i.e. virtual disk is being deleted. Virtual disk layer determines that virtual disk has one successor i.e. successor field is equal to 1 and proceeds to update virtual disks. As there are no predecessors i.e. predecessor field is null virtual disk layer proceeds to find an immediate successor disk starting at the current disk e.g. virtual disk . Based on the chain of predecessors virtual disk layer identifies virtual disk as being the immediate successor and identifies blocks relied upon by the immediate successor. In the example shown virtual disk layer identifies blocks LBA 1 and LBA 3 allocated in block allocation map that are not allocated in virtual disk according to block allocation map . As such data blocks and respectively are moved to block allocation map of the successor. depicts LBA 1 and LBA 3 of block allocation map having been updated to include physical block addresses to data blocks and respectively. In some implementations physical block address for data blocks and may be moved to entries of block allocation map while underlying data blocks remain in place on the underlying storage device i.e. storage . In other implementations data blocks and may be de allocated using a TRIM operation and corresponding new data blocks are allocated for the immediate successor disk.

In the example shown in because LBA 0 of block allocation map has a data block allocated i.e. newer data block and a data block was trimmed for LBA 0 of block allocation map no action may be needed for LBA 0. Similarly because LBA 2 of block allocation map has a data block allocated and a data block was never allocated for LBA 2 of block allocation map no further action may be needed for LBA 1. Finally because neither LBA 4 of block allocation map nor LBA 2 of block allocation map have ever been allocated i.e. as represented by the null value no further action may be needed for LBA 4.

In one embodiment backup agent may retire a new snapshot for example virtual disk according to a similar process described earlier. In the example shown in virtual disk layer sets retired field of virtual disk to indicate virtual disk has been retired. Virtual disk layer then selectively cleans up and trims data blocks of virtual disk based on whether virtual disk has successor virtual disks that might rely on data blocks referenced by block allocation map of virtual disk . In the successor of retired virtual disk i.e. virtual disk has no blocks allocated within block allocation map and as such no blocks are trimmed from retired virtual disk .

Although discussed above in conjunction with a specific stack of virtualization layers techniques described herein are not limited thereto and may be extended to embodiments where storage devices e.g. storage are configured to handle TRIM and other such operations. In such embodiments one or more of the described operations of the virtual disk layer for example may be implemented and executed instead by the underlying physical storage device itself.

Furthermore although discussed above primarily with respect to virtual disks associated with VMs techniques discussed herein are not limited thereto and may be employed on any virtual disks or generic files such as backup files in computer systems generally. is a block diagram depicting a computer system configured to perform incremental backups according to one embodiment of the present disclosure. Computer system may be similar to system shown in and includes host that includes a hardware platform having a CPU memory disk interface and network interface .

In one embodiment host is coupled to a storage device similar to storage device in . In one embodiment storage device may be a block addressable device configured to quickly and efficiently make a branch of storage device by recording the logical block address of each block e.g. data block that has been written as of some moment in time e.g. within block allocation map . In some embodiments storage device is further configured to capture the changes to the device after a particular moment by making a branch at that moment then using copy on write techniques to record subsequently written blocks in the list of addresses for the branch and not the trunk or vice versa . In one embodiment storage device is configured to quickly and efficiently compare a branch to a trunk to discover exactly the list of addresses of changed blocks.

These features of branching and comparing branches are used for example to facilitate incremental backups. To create an incremental backup a backup agent periodically branches storage device compares the new branch to an earlier created branch and copies the changed data blocks to backup storage system . In one embodiment storage device may be configured to provide functionality similar to virtual disk layer such that branches may be trimmed and retired and used as a basis for comparison in future incremental backups. Accordingly storage device need not retain an entire duplicate copy of the latest branch until the time of a next backup to be a basis for comparison with the next backup since the incremental backup made a copy of exactly that retained data to backup storage system already.

The various embodiments described herein may employ various computer implemented operations involving data stored in computer systems. For example these operations may require physical manipulation of physical quantities usually though not necessarily these quantities may take the form of electrical or magnetic signals where they or representations of them are capable of being stored transferred combined compared or otherwise manipulated. Further such manipulations are often referred to in terms such as producing identifying determining or comparing. Any operations described herein that form part of one or more embodiments of the invention may be useful machine operations. In addition one or more embodiments of the invention also relate to a device or an apparatus for performing these operations. The apparatus may be specially constructed for specific required purposes or it may be a general purpose computer selectively activated or configured by a computer program stored in the computer. In particular various general purpose machines may be used with computer programs written in accordance with the teachings herein or it may be more convenient to construct a more specialized apparatus to perform the required operations.

The various embodiments described herein may be practiced with other computer system configurations including hand held devices microprocessor systems microprocessor based or programmable consumer electronics minicomputers mainframe computers and the like.

One or more embodiments of the present invention may be implemented as one or more computer programs or as one or more computer program modules embodied in one or more computer readable media. The term computer readable medium refers to any data storage device that can store data which can thereafter be input to a computer system computer readable media may be based on any existing or subsequently developed technology for embodying computer programs in a manner that enables them to be read by a computer. Examples of a computer readable medium include a hard drive network attached storage NAS read only memory random access memory e.g. a flash memory device a CD Compact Discs CD ROM a CD R or a CD RW a DVD Digital Versatile Disc a magnetic tape and other optical and non optical data storage devices. The computer readable medium can also be distributed over a network coupled computer system so that the computer readable code is stored and executed in a distributed fashion.

Although one or more embodiments of the present invention have been described in some detail for clarity of understanding it will be apparent that certain changes and modifications may be made within the scope of the claims. Accordingly the described embodiments are to be considered as illustrative and not restrictive and the scope of the claims is not to be limited to details given herein but may be modified within the scope and equivalents of the claims. In the claims elements and or steps do not imply any particular order of operation unless explicitly stated in the claims.

Plural instances may be provided for components operations or structures described herein as a single instance. Finally boundaries between various components operations and data stores are somewhat arbitrary and particular operations are illustrated in the context of specific illustrative configurations. Other allocations of functionality are envisioned and may fall within the scope of the invention s . In general structures and functionality presented as separate components in exemplary configurations may be implemented as a combined structure or component. Similarly structures and functionality presented as a single component may be implemented as separate components. These and other variations modifications additions and improvements may fall within the scope of the appended claim s .

