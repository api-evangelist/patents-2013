---

title: Sharing encryption-related metadata between a host and an external intermediate device
abstract: A method performed in a device is provided. The method includes (a) receiving key identification information from a key controller module on an external host, (b) obtaining a key identified by the key identification information from an external key server, (c) decrypting encrypted data from an encrypted storage system using the key, and (d) processing the decrypted data. A corresponding computer program product is also provided.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09160526&OS=09160526&RS=09160526
owner: EMC Corporation
number: 09160526
owner_city: Hopkinton
owner_country: US
publication_date: 20130522
---
This Patent Application is a Divisional of U.S. patent application Ser. No. 12 977 789 filed on Dec. 23 2010 entitled SHARING ENCRYPTION RELATED METADATA BETWEEN MULTIPLE LAYERS IN A STORAGE I O STACK. The contents and teachings of the above identified Patent Applications are hereby incorporated by reference in their entirety.

In computer systems it is sometimes desirable to encrypt some or all of the data stored in storage devices in the system. In some arrangements data is encrypted in an I O filter driver running on a host of the computer system. In some configurations the I O filter driver is configured to use a key securely provided by a network key server so that multiple hosts within a security domain can securely access the same data.

The above described approach to encryption in computer systems may not be entirely optimal because encryption is a cycle intensive task so performing the encryption in a software filter driver on the host can cause slow performance. It may be desirable to offload data encryption tasks to specialized hardware devices which operate under the control of supervisory software components. In other systems there may be other system components that perform data encryption tasks under such supervision. In these kinds of systems it is necessary for such data encrypting components to obtain encryption metadata such as data encryption keys for use in the data encryption operations.

Embodiments of the present invention are directed to techniques for sharing encryption related metadata between layers of a storage I O stack so that the metadata can be effectively transferred thereby to specialized hardware devices or other encrypting components in a computer system. The disclosed techniques can provide for efficient and secure passing of encryption information among system elements to enable a variety of system functions.

A method performed in a device is provided. The method includes a receiving key identification information from a key controller module on an external host b obtaining a key identified by the key identification information from an external key server c decrypting encrypted data from an encrypted storage system using the key and d processing the decrypted data. A corresponding computer program product is also provided.

In operation the hosts execute application programs that utilize the storage devices for non volatile data storage. The storage interconnect may employ a storage oriented protocol such as iSCSI or Fibre Channel to enable block oriented read and write commands and the accompanying data to be transferred between the hosts and storage devices . Additionally the system provides selective encryption of storage data by the hosts and potentially the external intermediate device . The key manager server and host interconnect provide support for the data encryption function as described in more detail below.

Key manager server provides key manager functionality i.e. the generation protection storage replacement and elimination of data encryption keys and related data that are used in data encryption decryption operations. In one embodiment key manager server is a server appliance. One example of a key manager server usable in some embodiments is the RSA Key Manager appliance manufactured by EMC Corp. of Hopkinton Mass. It should be understood that this is by way of example only other products may also serve as the key manager server .

Key manager server and hosts connect to each other via host interconnect . Host interconnect may be for example a network such as a local area network LAN or a wide area network WAN . Host interconnect may also be realized by a collection of one or more switches interconnecting key manager server and hosts .

Hosts are computers executing applications that store data on the data storage devices . In addition to connecting to the host interconnect each host also connects to the storage interconnect typically via a plurality of independent connections. In one embodiment the hosts employ a multipathing function which establishes and utilizes multiple paths from a given host to a given storage device which can provide higher performance as well as redundancy for greater availability. Further detail regarding hosts is provided below in connection with .

The storage interconnect can be any type of network or input output I O bus capable of interconnecting storage devices with host computers . In some embodiments the storage devices and host are interconnected in a manner such that to the operating systems running on the hosts the storage devices appear as locally attached but this is not required for the invention. The storage interconnect may be a shared public or private network and encompasses a wide area or local area and can be implemented through any suitable combination of wired and or wireless communication networks. Furthermore the storage interconnect may include a LAN a WAN an intranet the Internet or a set of switches. For example in one embodiment the storage interconnect works with Fibre Channel connectivity and is implemented in the form of a storage area network SAN . In another embodiment the storage interconnect works with internet protocol IP connectivity and is implemented via an Internet Small Computer System Interface iSCSI e.g. for Fibre Channel . Those of skill in the art will recognize that other implementations are of course possible.

Storage devices may be any sort of storage equipment capable of connecting to storage interconnect . In some embodiments each storage device is a disk array. As is well known in the art a typical disk array includes a disk array controller disk enclosures holding a plurality of disk drives and a power supply. A disk array may also include a cache. Examples of disk arrays include the Symmetrix Integrated Cache Disk Array System and the CLARiiON Disk Array System both available from EMC Corp. of Hopkinton Mass.

In some embodiments an external intermediate device also attaches to host interconnect and storage interconnect for example to provide a data de duplication feature or in connection with WAN tunnel and remote storage device a remote replication feature. Additional detail is provided below.

As mentioned key manager server controls the generation protection storage replacement and elimination of data encryption keys. In particular key manager server creates encryption keys and corresponding key identifiers. Each key identifier referred to as a key id is associated with a corresponding encryption key and can be used to obtain the key from the key manager server provided that all permissions and credentials are in place.

OS which contains many well known components that are not shown or described herein includes a file system and a logical volume manager . OS also includes an input output I O filter driver and an HBA driver . I O filter driver may be for example a component of the PowerPath Encryption With RSA software available from EMC Corp. of Hopkinton Mass. I O filter driver includes an OS interface an HBA interface and a set of common application programming interfaces APIs . I O filter driver also includes a key controller module KCM or encryption manager and one or more intermediate layers IL . ILs may include for example one or more virtualization modules and multipathing modules . Crypto kernel may also be considered to be part of I O filter driver . Portions of the I O filter driver and the HBA driver may also make up storage I O stack . It should be understood that this arrangement is by way of example only in some embodiments one or more components of the storage I O stack may be external to the I O filter driver . In any case for purposes of this Disclosure the storage I O stack includes components between the KCM and a software interface to the encryption endpoint EE where encryption is performed e.g. HBA driver or in some cases a driver for external intermediate device .

The KCM is generally responsible for managing the data encryption aspects of operation of the host in which it resides. In some arrangements the KCM may arrange for the encryption to be performed by crypto kernel . However since KCM and crypto kernel both run in software running on processor such operation may impose a performance penalty in terms of latency and or throughput of data storage operations. Therefore in some arrangements KCM is able to arrange for the encryption to be performed by a hardware encrypting circuit referred to as a hardware assist which may be located within one or more HBAs as mentioned above. An HBA that includes a hardware assist may be referred to as an encrypting HBA or EHBA while an HBA that does not include a hardware assist may be referred to as a non encrypting HBA or NHBA .

A logical disk L is defined by virtualization module . Virtualization module provides a virtualization system function presenting a logical unit of data LU as a logical disk or logical volume LV to KCM and to the OS via OS interface even though the LV may not actually be a contiguous physical entity which is assumed to result in assigning logical blocks of L to specific storage devices . This virtualization may be for example a mirroring a striping or some combination thereof. In arrangement logical disk L is shown as being virtualized across two storage devices D and D . It should be understood that throughout this Description the term LU is used to refer to a logical unit of data at any level of abstraction e.g. as seen by the KCM as seen by one of the ILs or as seen by an HBA while the term LV is used to specifically refer to an LU as seen by the KCM .

A multipathing module provides a multipathing system function by which multiple paths to these storage devices are established through the storage interconnect and utilized in operation for greater parallelism availability and performance. As depicted multipathing module connects to EHBA EHBA EHBA and NHBA via the HBA driver interface and HBA driver of and the following paths exist 

It should be noted that presents a simplified example which assumes that each HBA and storage device has only one connection to the storage interconnect . In general as depicted in each HBA and storage device may have multiple such connections and it will be appreciated that the number of potential paths between a given HBA and storage device may be correspondingly greater.

In the configuration of the only path to disk D is via NHBA which means that there is no hardware assisted encryption available for encrypting decrypting data of that disk. The significance of this incapability is described below.

In an arrangement such as that of the multipathing module is responsible for maintaining an awareness of which disks it can reach engage in I O operations with as well as the corresponding set of usable paths to each reachable disk. The virtualization module maintains an awareness of the disks e.g. D and D which underlie each logical volume e.g. L . Upon receiving storage commands I O commands including reads and writes of storage data directed to logical volume L the virtualization module generates corresponding storage commands to D and D and issues these commands to the multipathing module . The multipathing module responds by selecting a path for each command and issuing the command to the HBA for the selected path. Storage commands directed to an encrypted region of a disk may utilize the hardware assist provided by an EHBA along a selected path. In the event that a disk is not reachable via an EHBA such as disk D as mentioned above any such storage commands will utilize the encryption functionality of the crypto kernel .

The above description in connection with FIGS. and A B illustrates certain important aspects of using hardware assisted encryption in a system such as that of . First it must be possible for an EHBA to obtain the encryption metadata including encryption key for those regions of encrypted storage for which that EHBA will handle data storage commands so that the hardware encryption circuitry of the EHBA can perform the correct encryption decryption operation using the correct key for each distinct region of storage. As the KCM is the overall manager of encryption operations for the host in which an EHBA resides a mechanism is needed to enable the KCM to communicate the encryption metadata to its EHBAs . Additionally a mechanism is needed for the KCM to ascertain whether hardware assisted encryption is available for any given region of storage. Both these needs are further complicated by the presence of ILs especially those like virtualization module which are remapping layers that effect a translation or mapping between two different representations of a given storage volume. Additionally even non remapping layers like the multipathing module create potential problems because hardware encryption assist may not be available on all paths for a given disk yet the system must ensure that encryption is performed reliably. All these issues point to the need for a communications protocol among the different layers of the storage I O stack to support the data encryption function.

By up and down the storage I O stack it is meant that a DEK management protocol command may be created by KCM then passed to a top level IL such as virtualization module . That IL examines the command and in most cases exceptional cases are discussed below will send one or more corresponding commands to the next IL down the stack such as multipathing module . This pattern repeats until one or more commands reach HBA driver s . Responses flow in the other direction from the HBA drivers upward to the KCM . In some cases commands may not travel completely down the storage I O stack and responses may be generated and sent upwards by one or more ILs . By this chain like communications mechanism information required for proper encryption related operation is shared among the various components of the storage I O stack .

In one embodiment KCM uses the DEK management protocol to first determine whether or not there is an EHBA or a set of multiple EHBAs that can provide hardware encryption for each encrypted region of the logical disk L . If not then it is deemed that hardware encryption is not available and the KCM assumes responsibility for encryption decryption operations for the logical disk L using the crypto kernel . If the KCM determines that such hardware encryption is available it uses the DEK management protocol to provide the required encryption metadata to each EHBA that requires it. Subsequently storage commands directed to the logical disk L are sent down the stack for execution relying on operation of one or more EHBAs for the data encryption decryption part of operation for the encrypted regions.

As previously noted encryption may be applied to separate regions of a given volume or disk . Here region refers to a span of contiguous logical block addresses LBAs . To illustrate the concept assume a hypothetical simple volume having 16 blocks of storage with addresses through . The volume may have an encryption patterns as follows 

The overall pattern for a given logical unit of data LU is referred to below as a LUN map the term LUN is commonly used in the industry to refer to an LU . In operation it is necessary for the KCM to provide the LUN map for each volume to any EHBA that will handle I O for that volume. It is assumed herein that only one data encryption key is used for each volume although in general it is possible to use different keys for different regions for example.

In a somewhat more realistic example an encrypted LU may store metadata and formatting information in plaintext form. In addition certain additional regions of an encrypted LU may be designated as unencrypted for various reasons e.g. to enhance performance on a region that is frequently accessed . For example logical disk L may be an encrypted LU having a size of 10 megabytes. Given a 512 byte block size logical disk L has 20 480 blocks. Blocks may be unencrypted and reserved for operating system use while blocks may be unencrypted and reserved for storing encryption metadata. Blocks may be encrypted blocks may be unencrypted for performance reasons and blocks encrypted. Thus only blocks and of logical disk L are subject to encryption.

Additionally the virtualization module distributes the blocks of logical disk L out across D and D . For example blocks may be stored on D while blocks are stored on D . This arrangement places portions of logical disk L subject to encryption on both D and D . It should be noted that the mapping between L and D D may not and in many cases will not preserve LBAs. Thus blocks of L may be mapped to blocks of D for example.

Referring again to in step KCM determines if there exist one or more EEs e.g. EHBA s that can perform encryption decryption for all encrypted regions of an encrypted logical volume LV . If step returns an affirmative response execution proceeds with step while if step returns a negative response execution may proceed with step . At step it is concluded that there is no EE to perform encryption decryption for the subject volume disk which means that any required encryption decryption operations are to be performed by the KCM using the crypto kernel . As described above with reference to in the present example the condition of step is satisfied for logical disk L . However for logical disk L step evaluates in the negative because there is no encrypted path to D and thus the method will execute step with respect to logical disk L . It should be noted that in some embodiments even if an EHBA is present in all paths to a storage device condition could still fail if an essential path or an essential group of paths is blocked by an error in the EHBA e.g. the EHBA has no remaining capacity or is temporarily offline .

As shown in step may be accomplished by performing some or all of sub steps and which perform handshake and query operations. In connection with these sub steps different specific commands and responses of the DEK management protocol are used as described more fully below. Table 1 provides a general structure for a DEK management protocol command block used in performing these operations 

The general command block format is a structure having a format as shown in Table 1. In some embodiments all commands are a maximum of 1536 bytes 3 512 byte blocks long although this is by way of example only. In some embodiments DEK management protocol command blocks are implemented within the read buffer of SCSI Read commands. The fields and arguments are described below. In the description below the label In means the parameter is an input passed from the KCM in down to the EE via one or more ILs while Out means the parameter is an output returned by the EE out up to the KCM via one or more ILs . Initiator means the KCM or cooperating IL that generates a protocol command. Device Object means a device managed by a driver in the storage I O stack . It may be a volume an LV an LU a path device or a storage device.

The following is a description of the various fields in the general command block shown in Table 1 above 

Referring again to in step which may be omitted KCM sends a Handshake command down to the next IL in order to test for the existence of a cooperating EE in the storage I O stack .

The KCM sends the Handshake command as the first DEK management protocol command to a Device Object. Only one handshake at a time should be outstanding to a given device object. The EE should not trigger an internal state change upon receipt of a Handshake e.g. a Handshake command should not reset associations currently in effect for a Device Object.

Generally KCM will send one Handshake command per LV that it manages. As long as KCM receives one affirmative Handshake response command block in response to the Handshake command KCM will proceed to step . Otherwise KCM will proceed with software encryption.

When a cooperating IL receives a Handshake command from above in the storage I O stack it passes the command down to the next level down in the storage I O stack . If the LU potentially involves multiple EEs of the storage I O stack then the IL will replicate the command block potentially with modification as discussed below and send a copy down the storage I O stack toward each such EE.

For example if the IL is a virtualization module that virtualizes the LU across two storage devices and then virtualization module sends two copies of the Handshake command block down the storage I O stack one referencing storage device as the device object and the other referencing storage device as the device object. If the virtualization module receives any affirmative Handshake response command blocks the virtualization module responds back to the KCM with an affirmative response. This indicates to the KCM that there is at least one EE that may require encryption metadata. However it should be understood that in some embodiments some ILs may be configured to respond negatively if any of the Handshake response command blocks from below are negative.

The DEK management protocol supports multiple classes of EEs. An EE of a cooperating class ignores Handshake commands that do not contain its class name and acknowledges a Handshake addressed to its EE class name by filling in the Endpoint ID field.

See Table 2 below for an example layout of a Handshake command block with Handshake specific definitions of bytes .

The following is a description of the various fields in the Handshake command block shown in Table 2 above 

The EE is expected to update the version field if the version supported by EE is different than requested by KCM . The ILs are also expected to ensure version compatibility with the EE. If the EE supports a lower version than required by the IL IL should fail the Handshake request.

Referring again to in step KCM sends a Query command down to the next IL to determine if an encryption capability such as hardware assisted encryption is supported for a specified range on an LV. Each IL between the KCM and the EE responds to the Query based on the encryption capabilities of the underlying devices.

An IL broadcasts the Query command to all the underlying devices and aggregates the results of individual queries into one response to the KCM or an IL above it . The response from an IL should not lead to data corruption. For example an IL managing a virtual volume spanning two underlying LUs should support hardware assisted encryption on the virtual volume only if the paths to both the LUs have hardware assist available.

For example if the IL is a virtualization module that virtualizes a logical volume across two storage devices and then virtualization module sends two copies of the Query command block down the storage I O stack one referencing storage device as the device object and the other referencing storage device as the device object. Generally only if the virtualization module receives affirmative Query response command blocks for both storage devices and will the virtualization module respond back to the KCM with an affirmative response however this behavior may differ if a particular form of virtualization is performed that allows otherwise. For example in the case of a read only LV mirrored onto two or more distinct LUs as long as one of the LUs is readable with encryption at the level of an EHBA the virtualizing IL may return an affirmative response even if a negative response is returned for one of the LUs.

As an alternate example if the IL is a multipathing module having paths through multiple HBAs to a given storage device then the multipathing module sends copies of the Query command block to all such HBAs down the storage I O stack . If the multipathing module receives any affirmative Query response command blocks the virtualization module respond back to the KCM with an affirmative response.

An EE looks for the Endpoint ID in the payload that matches its ID i.e. the Endpoint ID that is sent up by the EE to the KCM in the Handshake response and returns affirmatively if it can perform its encryption capabilities on the specified ranges for the device object. Otherwise the EE may return in the negative e.g. if the EE does not have a connection to the appropriate storage device if the EE was not initialized or if the EE is temporarily busy and the command should be retried .

Included within the Query command is a LUN Map which defines the areas subject to encryption. Each area is provided with reference to a Logical Block Address LBA which is an abstraction of the block addresses at a given layer of logical abstraction. Returning to the example provided above in which logical disk L is an encrypted LV 10 megabytes in size blocks and of logical disk L would be listed as subject to encryption.

Some ILs may remap the LUN map as appropriate. These ILs are referred to as remapping ILs . For example a virtualization module is an example of a remapping IL while a typical multipathing module is not a remapping IL . Recall that in the example blocks of logical disk L are stored on D while blocks are stored on D . Further suppose that the encrypted blocks stored on D begin at local block while the encrypted blocks stored on D begin at local block but actually are spread out across ranges and . Therefore in the Query command passed on to storage device D the LUN Map will indicate LBAs and in the Query command passed on to storage device D the LUN Map will indicate LBAs and .

The following is a description of the various fields in the Query command block shown in Table 3 above 

Recall that if step returns an affirmative response execution proceeds with step while if step returns a negative response execution may proceed with step . In some embodiments step may also be executed on its own without first performing step .

In step KCM sends encryption metadata associated with the encrypted LV from the KCM to the EE via ILs the encryption metadata identifying an encryption key and one or more encrypted regions of the LV. The encryption metadata may also identify other associate encryption information needed to perform the encryption algorithm such as for example an identification of the encryption algorithm. The sending results in establishment of one or more shared associations between the KCM and the EE the shared associations associating the encrypted LV with the encryption metadata for the encrypted LV. In one embodiment this step is accomplished using the DEK management protocol by sending a DEK Management Associate command.

The Associate command creates an association of 1 an Encryption Key Blob with 2 a LUN Map on 3 a Device Object thereby effectively turning on encryption for the LU and LBA Range s . The Key Blob is a set of encryption metadata storing the key and all the other information needed to perform encryption decryption that is stored on the key manager as described below. Although in the on host case the key blob is sent within the Associate command in an off host case the key ID may be sent within the Associate command instead of the key blob or in some embodiments an encrypted version of the key blob referred to as a wrapped key blob may be sent . Multiple Key Blob LUN Map Associations can be made for a Device Object. Associate commands can be generated by the KCM and by ILs although ILs do not originate an association but rather pass on one or more copies with modifications as necessary of an Associate command received from above. In some cases the association may also include Application information.

If the Association Handle is NULL it means the KCM or an IL is creating a new Association so the EE should 

Any Associate command whether the first or a repeat should be preceded by a Query command though the EE does not need to enforce this.

Upon successful completion of an Associate during step an EE is ready to apply encryption decryption to the encrypted regions of a LU as defined in the LUN map using the encryption metadata from the Key Blob and the application information. As long as the association remains active subsequent read write commands directed to these regions employ decryption encryption using the encryption metadata. This operation is depicted in step .

The DEK management protocol may also employ Update and Disassociate commands. An Update command tells the EE to update the association for the Device Object with the Key Object and LUN map information in the protocol command block. It provides an atomic way for an EE to effectively delete and create an association in one step. It would be used for example to support resizing of an encrypted LU.

The Disassociate Command deletes the association that had been created with a previous Associate command for a Device Object. Subsequent read and write commands in the LBA range s covered for that association are no longer encrypted decrypted by the EE. Disassociate is used when the EE can no longer perform its duties and a switch to encrypting using the crypto kernel is needed. Switching back happens through a new Associate command. An example looking back at would be if EHBA failed for some reason. D and D would still be reachable by EHBA and NHBA respectively but the Crypto kernel would have to be used so the Disassociate would be sent on L.

Both the Update which in some embodiments is an Associate command containing a valid non null handle and Disassociate commands include an Association Handle to identify the subject association.

In some embodiments the invention may be applied to the sharing of encryption metadata with an external encryption endpoint such as the external intermediate device . depicts a method which may be performed by an external intermediate device . At step key identification information e.g. the key ID is retrieved from a key controller module e.g. KCM on an external host e.g. host . At a key which is identified by the key identification information is obtained from an external key server e.g. key manager server . In some embodiments this is done by sending the key ID from the external intermediate device to key manager server which then responds by sending key blob to external intermediate device securely across host interconnect . The key is sent indirectly in this manner because security restrictions typically prevent an encryption key from being sent off host. The key must be retrieved separately from the key manager server in order to enforce access limitations. In some cases it may be possible to instead send the key directly to the external intermediate device if it is embedded within an encrypted wrapped key blob. It should be understood that in some embodiments step may be performed using a command similar to the Associate command depicted in however the key blob would be either omitted from the command block or sent in wrapped format.

At step the key is used for encrypting decrypting data and at step the encrypted decrypted data is processed appropriately.

Two specific examples are shown in . In one case the external intermediate device provides a remote replication function to replicate storage volumes on a remote storage device . To make efficient use of long distance communications bandwidth it is desirable to compress the data prior to transmitting it. However encrypted data benefits very little from compression because encryption generally removes the large redundancy that is present in cleartext data which is exploited by compression techniques. Thus the external intermediate device in this case first reads and decrypts data of a local storage device which is being replicated step compresses the decrypted data step encrypts the compressed data and then sends the encrypted compressed data across the tunnel to the remote storage device . In the event of needing to retrieve data from the remote storage device for local use the external intermediate device performs these operations in reverse.

Steps depict a set of similar operations for so called data de duplication a function that also exploits redundancy and thus is better performed on cleartext rather than encrypted data.

It should be understood that in either the remote replication case or the data de duplication case the external intermediate device may alternatively receive the encrypted data directly from an HBA e.g. via storage interconnect rather than by reading it from a storage device .

While various embodiments of the invention have been particularly shown and described it will be understood by those skilled in the art that various changes in form and details may be made therein without departing from the spirit and scope of the invention as defined by the appended claims.

It should be understood that although various embodiments have been described as being methods software embodying these methods is also included. Thus one embodiment includes a tangible computer readable medium such as for example a hard disk a floppy disk an optical disk computer memory flash memory etc. programmed with instructions which when performed by a computer or a set of computers cause one or more of the methods described in various embodiments to be performed. Another embodiment includes a computer which is programmed to perform one or more of the methods described in various embodiments.

Furthermore it should be understood that all embodiments which have been described may be combined in all possible combinations with each other except to the extent that such combinations have been explicitly excluded.

Finally nothing in this Specification shall be construed as an admission of any sort. Even if a technique method apparatus or other concept is specifically labeled as prior art or as conventional Applicants make no admission that such technique method apparatus or other concept is actually prior art under 35 U.S.C. 102 such determination being a legal determination that depends upon many factors not all of which are known to Applicants at this time.

