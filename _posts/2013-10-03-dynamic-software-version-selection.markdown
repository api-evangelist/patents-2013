---

title: Dynamic software version selection
abstract: Dynamic software version selection is performed by executing a software component on a processing device having a binding library associated with a software component, where the binding library comprising a loader component and a binding component. The loader component serves as an intermediary between the software component and the binding component and the binding component comprises software component-side logic. The binding library is utilized to interface the software component with a remote server across a network environment. In response to a request to update to a different version of the library, the loader component selects a desired version of the library. The desired version of the library is loaded into memory of the processing device by logically disconnecting from the remote server, unloading a previously loaded library, loading the updated version of the library, and reconnecting to the remote server.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09047162&OS=09047162&RS=09047162
owner: INTERNATIONAL BUSINESS MACHINES CORPORATION
number: 09047162
owner_city: Armonk
owner_country: US
publication_date: 20131003
---
This application is a continuation of U.S. patent application Ser. No. 12 982 970 filed Dec. 31 2010 entitled DYNAMIC SOFTWARE VERSION SELECTION now patented as U.S. Pat. No. 8 595 715 the disclosure of which is incorporated herein by reference.

Various aspects of the present invention relate generally to software version selection and in particular to the dynamic selection of a of software version with minimal or no interruption to the supported process or service during a version change.

Middleware allows multiple processes running on one or more machines to interact. Accordingly middleware is useful in supporting complex distributed applications such as transaction systems and messaging and queuing systems. As an example middleware in the form of an Online Transaction Processing OLTP system is often used to support key business processes and services. For instance an online transaction processing system may be utilized to facilitate and manage transaction oriented applications that capture new data update existing data handle data entry and retrieval etc. within an order entry system. As another example middleware in the form of a message queuing system may be utilized to facilitate program to program communication by writing and retrieving application specific messages to and from queues without necessarily requiring a dedicated logical connection between communicating programs.

Middleware including modern OLTP systems message and queuing systems etc. typically support transactions that span a network and may cross one or more domains controlled by different entities. As such middleware applications such as OLTP applications and message and queuing applications are typically implemented using client server processing and brokering that allow transactions to run on different computer platforms within a network. Accordingly software upgrades to such middleware systems usually drive a requirement that the applications are shut down taking associated applications off line to allow software installation and configuration where necessary.

According to aspects of the present disclosure dynamic software version selection is performed by executing a software component on a processing device. Dynamic software version selection is further performed by associating a binding library with the software component where the binding library comprising a loader component and a binding component. Here the loader component serves as an intermediary between the software component and the binding component and the binding component comprises software component side logic. Dynamic version selection is further performed by utilizing the binding library to interface the software component with a remote server through communication across a network environment and by providing a request to the loader component to update memory of the processing device with a new version of a library of the binding component. Dynamic software version selection is still further performed by selecting by the loader component in response to the request a desired version of the library where the desired version of the library is selected from at least two versions of the library associated with the binding component of the binding library. Also dynamic software version selection is performed by loading the desired version of the library into memory of the processing device. Loading is performed by logically disconnecting from the remote server unloading a previously loaded library loading the updated version of the library and reconnecting to the remote server.

Various aspects of the present invention provide techniques that enable a software system to be modified with new software without shutting the software system down or without otherwise providing service interruption. Software modifications include for example the implementation of software upgrades reversion back to an earlier software version reloading of a software version repair or patching of a software version etc. Accordingly software systems are provided which can without interruption be upgraded with new software e.g. containing fixes to known problems and or new features and whose parts may be using different versions e.g. service levels of software etc. Software systems can also be retro graded to an earlier version. Moreover both client side and server side systems can be modified with new software.

Further various aspects of the present invention described herein provide for managing versioned implementations at an application programming interface API boundary within a continuously running process such that no process restart is required for the associated software code. The ability to implement an update without restarting the process can be carried out even where the process is a third party application e.g. a customer application which is not under the control of an update mechanism provided to carry out the software modification. Thus run time updating and modification of native code libraries are readily implemented. Also the update mechanism can implement dynamic internal state handling to enable functional library version changeover underneath a running process e.g. in systems that utilize dynamic linked libraries.

Still further aspects of the present invention provide an update mechanism that facilitates the ability to make and control migration decisions such as how and when to upgrade downgrade or otherwise replace software code which may be stored in libraries. Accordingly the update mechanism can exhibit dynamic behavior that provides flexibility in software version modification processes and decisions. Moreover the update mechanism can implement selective software versioning e.g. on a program by program basis or based upon other selection criteria.

According to still further aspects of the present invention the update mechanism may comprise a binding library which is associated with a software component calling component . In this manner the calling component calls the binding library from time to time to implement application programming interface API calls. The binding library is implemented as a loader component and a binding component. The loader component serves as an intermediary to receive calls from the software component and to issue equivalent API calls to the binding component. The binding component comprises software component side logic including at least two versions of a library. Each library version includes logic for responding to application programming interface calls from the calling component.

The loader component recognizes or otherwise detects a trigger and in response thereto implements decision logic. The decision logic may check for the presence of a new library version detect a desired version of the library that should be loaded direct the loader component to select and load a desired version of the library from the binding component into memory of a processing device etc. If a version of the library loaded into memory is replaced the unloading of the old library version and loading of the new library version is performed without requiring that the associated software component restart.

For instance in a first illustrative example only select API calls e.g. connect disconnect or analogous API s have decision logic to cause a library version reload. Thus the loader component may be triggered to check the version of a library loaded into memory and to update the version if necessary in response to receiving the specific command or commands e.g. connect and disconnect API calls from the associated software component. As will be described in greater detail herein in this illustrative example no state migration is needed to implement the library version reload.

As another illustrative example all API calls to the loader component have decision logic. As such the loader component is triggered to check the version of a library loaded into memory and to update the version if necessary in response to receiving any API call from the associated software component. In this illustrative example state migration should be supported as will be described in greater detail herein. Still further regardless of whether select API calls or all API calls have decision logic to trigger library version checking the loader component may support program level or program specific controls that allow control over which programs will migrate library versions and which will not in response to received API calls.

Referring now to the drawings and in particular to a schematic of a system is illustrated which is suitable for implementing dynamic software version selection according to aspects of the present invention. The system may be implemented on a single physical processing device. Alternatively the system can be distributed across multiple physical processing devices that are communicably connected together such as by a network. In this regard each processing device may comprise hardware and or software processing components for carrying out aspects of the invention as described in greater detail herein.

As illustrated the system comprises at least one software component and an associated binding library . The software component may comprise for example any software that invokes the services of another component e.g. the associated binding library . The software component may be implemented for example as a software application program object service agent operating system etc. In this regard the software component may also be referred to herein as a calling component .

The binding library is implemented in two components including a loader component and a binding component . The loader component interacts with the software component s and the binding component to load the correct version of an associated library of the binding component into memory . The loader component may also optionally interact with one or more optional information sources which may be provided for assistance in carrying out version management. For instance as will be described in greater detail herein an information source may be implemented as a table either stored in the memory or as a separate file which indicates a current version of the associated library maintained by the binding component .

The binding component comprises one or more versions of a library which contains software component side logic including at least two versions of a library. Each library version includes logic for responding to application programming interface API calls from the calling component . As used herein the term library is intended to be general and non limiting. For instance the library versions may each comprise any relevant packaging unit for software e.g. a jar file program module dynamic linked library etc. Moreover each library version is not limited to a native code library and can thus be used with implementations such Java.

The loader component serves as an intermediary between the software component and the binding component of the binding library . In this regard the loader component may be the only component that is statically linked with the software component s . According to aspects of the present invention the loader component may be implemented as a library itself In this exemplary implementation the loader component functions primarily a forwarding library. That is most of the time the loader component accepts API calls from the software component and in response thereto calls the equivalent API in the currently loaded library version associated with the binding library .

According to further aspects of the present invention decision logic may be inserted into the execution path of the forwarding functions from the loader component to the appropriate library of the binding component . The choice of which forwarding functions should have decision logic and those that should not depends on the specific implementation examples of which are described in greater detail below.

The binding component comprises one or more versions of a library. For example as illustrated the binding component comprises N versions of a library where N can represent any number of library versions. Each library version may comprise for example a dynamic link library that provides software component side logic for use by the software component for carrying out a particular operations or functions e.g. for carrying out API calls associated with a middleware process. For instance the binding component may comprise logic that implements or otherwise responds to API calls from the software component .

As noted in greater detail above the binding component can be implemented in various forms. As illustrated a file system stores a plurality of binding component versions each binding component version having an associated library. In another exemplary implementation such as where all necessary programs and code are encapsulated with a library the binding component may comprise a file system library that stores each of the library versions an example of which is illustrated in . Other binding component configurations may alternatively be implemented.

The loader component does not contain any of the logic needed to support calls by the software component . Rather the loader component dynamically loads the correct version of a library associated with the binding component of the binding library into memory of a corresponding computer processing system. The process of loading the library is effected without requiring the associated software component program to restart. Once the appropriate library has been selected and loaded into memory the loader component receives calls from the software component and forwards equivalent calls from the software component to the appropriate logic loaded from the library into memory . Thus the loader component intercepts and mediates calls from the software component . Once a library has been loaded into memory the loader component occasionally checks for the presence of new binding library versions or instructions to revert to an existing but different binding library version . If the loader component detects the need to change the library version loaded into memory the change is implemented without requiring the underlying software component to be restarted.

In an illustrative implementation based upon a condition such as when the loader component notices that the currently loaded or otherwise used library version of the binding component is at an earlier level than the latest available binding component the loader component can dynamically unload the current version of the library loaded into memory and dynamically load the latest version of the library from the binding component into memory. The loading component can also optionally call migration logic e.g. which may be provided in the newly selected library version to re arrange any internal data structures to conform to the requirements of the new library version if necessary. Thus internal state migration is automatically and dynamically managed by the binding library . Once the new version of the library is loaded into memory and internal state data structures have been migrated as necessary the loader component can complete the processing of the current call from the software component if a call had been made using the new library.

As will be described in greater detail herein the loader component may utilize a resource such as one or more information sources s in order to select the appropriate version of the library from the binding component to load. In this regard the information source may comprise a file system symbolic link e.g. on Unix like file systems etc. a control file one or more tables or databases saved as a file or loaded into memory a pointer or other source to identify the desired library from the binding component .

According to still further aspects of the present invention a common control feature e.g. a manager function administrator function supervisor function etc. can oversee or supervise software version control. For instance a manager can direct e.g. via the loader component that all connected software components to use a desired library version the next time that application makes a call to the loader component . A manager can also update the binder component with new library versions from time to time. Thus the binding library implements an update mechanism either alone or in combination with one or more additional processes e.g. manager or supervisory logic etc.

The techniques described herein can be driven by rules or other processes that allow the dynamic upgrade downgrade of the binding software via the library versions within the binding component . Moreover dynamic upgrade downgrade of the binding software may occur for only a subset of customer application programs may occur for specific applications or may occur at certain time and date etc.

Referring to a flow chart illustrates the overall flow of a process of performing dynamic software version selection according to various aspects of the invention. The process may be implemented as a method or as part of a system that includes a combination of hardware and software. For instance software may be stored in a physical memory device such that when the software is processed by at least one processor the software causes the corresponding physical machine to implement the actions specified by the illustrated process . Thus for example the process may be implemented on the system illustrated and described with reference to . Still further the process may be implemented as a computer program product comprising a tangible computer readable storage medium having computer readable program code embodied therewith.

The process comprises associating a binding library with a software component at . The binding library comprises a loader component and a binding component where the loader component serves as an intermediary between the software component and the binding component and the binding component comprises software component side logic. According to certain aspects of the present invention it is the job of the loader component to recognize or decide that a binding library reload is required. In this regard the loader component recognizes that a different binding library must be loaded.

The process further comprises triggering a verification of the version of the loaded library at by the loader component. For instance the loader component may execute decision logic to decide e.g. based upon rules conditions or other information whether the currently loaded library should be modified e.g. upgraded to a new version or retrograded to an earlier version. The trigger may be implemented by receiving specific API calls associated with decision logic to trigger the verification of the library version. As another illustrative example all API calls received by the loader component may have the decision logic associated therewith. If no library is loaded the loader component may utilize the same rules conditions or other information to select a library version to load into memory.

If there is no need to modify a version of the library loaded into memory then the process is complete. Otherwise the process further comprises selecting at by the loader component a desired version of the requested library. The desired version of the library may be selected from at least two versions of the library associated with the binding component of the binding library. The desired version of the requested library may be selected for example using a file such as a file system symbolic link a control file that directs the selection etc. As an alternative example the loader component may consult a table or other information source to ascertain the identification of the desired version to be loaded into memory. For instance the process e.g. via the loader component may utilize a library version table to identify versions of the library. As such the process may store a library version variable that tracks the current version of the library which can be accessed and utilized by the loader component. Thus for example the loader component may read the value of the library version variable and select the desired version of the library based upon the value of the library version variable.

The process still further comprises loading the desired version of the library into memory of a computer processing system without requiring that the associated software component restart. Once a library version has been selected and loaded into memory the process may further comprise receiving by the loader component software application program interface calls from the software component and forwarding the received calls to corresponding software application programming interfaces of the desired version of the library loaded into memory.

Various aspects of the present invention facilitate dynamic version control in an environment such as a middleware environment by bringing new dynamic linked libraries into a middleware system without downtime or service interruption. Such implementations further provide for the management of versioning in a middleware environment.

Referring to a schematic is illustrated of a system for implementing dynamic software version selection. The system implements aspects of the present invention which are in many ways analogous to that set out with regard to the system of . However the system is illustrated in the exemplary context of a messaging system environment to illustrate certain features according to further aspects of the present invention.

The system includes a plurality of software components which are implemented as customer applications. Each software component is associated with a binding library comprising a loader component and a binding component . The binding component contains all of the software component side logic needed to process messaging and queuing system application programming interface calls. In general the binding library including the loader component and the binding component are analogous to like named components described with reference to .

The illustrative system can integrate a message and queuing system such as an MQSeries middleware system for messaging and queuing by International Business Machines of Armonk New York. Using such an arrangement the various software components can communicate with each other by writing and retrieving application specific data messages to from queues without having a private dedicated logical connection to link the applications. In this regard each binding library may contain for example a set of executables that implement a client for communicating using the messaging and queuing system.

The system further includes a plurality of client processing devices that communicates across a network with a server computer during the course of executing their associated customer software components . A typical physical processing device may include for example a server computer a personal computer a notebook computer a netbook computer a tablet computer a transactional system a purpose driven appliance a pervasive computing device such as a personal data assistant PDA a palm computer a cellular access processing device a smart phone or any other device capable of executing computer code etc.

The network provides communications links between the various processing devices and the server and may be supported by networking components including for example routers hubs firewalls network interfaces wired or wireless communications links and corresponding interconnections cellular stations and corresponding cellular conversion technologies e.g. to convert between cellular and tcp ip etc. Moreover the network may comprise connections using one or more intranets extranets local area networks LAN wide area networks WAN wireless networks WIFI the Internet including the world wide web and or other arrangements for enabling communication between the processing devices and the server computer in either real time or otherwise e.g. via time shifting batch processing etc.

The server computer may be utilized for example to execute a queue manager which may be embodied as a set of long running service processes. The queue manager defines the runtime application that manages sending and queuing messages for each of the customer software components . In this illustrative example the messaging and queuing system is implemented in a client server configuration. Alternatively an instance of the queue manager could be implemented as a long running process on each processing device .

In general terms the customer software components use API calls to communicate via their associated client with the queue manager e.g. to send messages to queues associated with other customer applications or to retrieve messages from an associated queue which have been deposited by other software components . Thus the queue manager interacts with potentially many different customer software components associated with different client processing devices accessing those service processes each using a product specific binding library . Such an arrangement may occur regardless of whether the queue manager is remote e.g. on a server computer as part of a client server implementation or co located with the binding library in a local configuration of a corresponding processing devices .

From time to time it is desirable to update software of the various components operating within the system . Assume that the messaging and queuing system needs to perform an update. According to various aspects of the present invention new versions of the message and queuing system software can be dynamically deployed without service interruption. Such software modifications include changes to software that is bound with each customer software component e.g. the associated version of a library loaded by an associated instance of the binding library . Software modifications further comprise changes to the internal processes of the messaging and queuing system e.g. changes to the queue manager changes additions or deletions to library versions stored associated with the binding component etc.

In the case of modifications to software internal to the messaging and queuing system such internal processes can be designed to be re startable when or soon after a software upgrade becomes available. To the contrary customer software components have process lifecycle requirements that are determined by customer business requirements and are under customer control not control of the messaging and queuing system.

In general the service processes associated with the queue manager can be implemented as conventional operating system processes. Examples in a MQSeries queue manager are the Message Channel Agents MCA which as used to read and write messages over the network to other MCAs and Local Queue Manager Agents LQMA which form the basic queuing engines. These processes are managed in the sense that the queue manager itself maintains a pool of available MCA and LQMA processes that are reused as needed. Idle instances of both the MCA and LQMA processes are reused as new work arrives. When new software e.g. in the form of either new libraries or programs is installed in the file system the queue manager can shutdown any idle instances of these programs and start new processes. The processes will without any other help use the new software. Similarly software downgrades are also possible by reversing the file system changes that installed the new software files.

Customer software components obtain access to the messaging and queuing system services using the binding library e.g. a library named libmqm in the case of MQSeries. The binding library in one regard presents a fixed and well defined interface to the application . Moreover the binding library interfaces with the internals of the queue manager .

Customer software components cannot in general be forced to restart even though new software is available. For instance in general a process on the server computer cannot force a restart of a software component on a remote processing device . However in the illustrative example both a current set of program library executables and a new set of program library executables are available together in each file system as illustrated by each binding component comprising a plurality of different library versions. In this regard software executed by each software component associated with the messaging and queuing system e.g. the client etc. can be updated in a manner analogous to that described with reference to and .

To allow new versions of the binding library to be deployed without requiring customers to restart their software components each binding library is divided into two different components including a loader component and a binding library in a manner analogous to the loader component and binding component described with reference to . The loader component may be implemented for example as a small library. However the loader component does not contain any of the logic needed to support application programming interfaces of messaging and queuing system. Rather the loader component loads the correct version of the binding library into memory on the corresponding client processing device . The loader component then forwards equivalent API calls from the application program to the appropriate interfaces in the loaded library e.g. the client to implement sending messages to message queues retrieving messages from message queues or otherwise interacting with the messaging and queuing system.

Once the loader component has selected and loaded a library from the binding component the loader component forwards equivalent versions of all API calls from the software component to the loaded library from the binding component . The loader component thus effectively intercepts and mediates all API calls between the customer software components and the library loaded from the binding component which are associated with the messaging and queuing system.

To perform a software modification to the library on a customer processing device the server or any other source provides a new version of the corresponding library to the binding component . The binding component stores the library in such a way that each version of the library can be uniquely identified by the corresponding loader components . Further the loader component may be provided with information that identifies the version of the library to be loaded as described more fully herein. However a running instance of the customer software components may continue to use whatever library version is currently loaded into memory of the associated processing device until an appropriate command is given to cause the loader component to update the memory of the corresponding client computer with the new version of the library.

Upon the timing of a predetermined event the loader component can unload a previous library version if a previous version was already loaded. Correspondingly the loader component can load a new version of the library from the binding component .

According to an illustrative example the customer software components may use a designated disconnect and reconnect API sequence to trigger the loading of a new library from the binding component . Until the customer software components performs this sequence of application programming interface calls the customer software components will continue to use the older library version software.

In an illustrative implementation the software library modification may be triggered by the customer software components issuing disconnect and reconnect API calls to the binding application . Thus the loader component may dynamically unload the current version of the library loaded into memory upon customer application disconnect and subsequently dynamically load a new version of the library upon customer application connect. In the exemplary implementation of MQSeries loading and unloading of the library from the binding component is implemented in the loader component s MQCONN MQ series connect and MQDISC MQ series disconnect processing. The commands to load and or unload a library in this illustrative example are implemented by the corresponding customer software components thus enabling the customer application to control the timing of updates.

According to aspects of the present invention in the above illustrative implementation only the connect disconnect forwarding APIs need to have decision logic in them. For connect disconnect APIs the decision logic may be executed before the call is forwarded to the corresponding library. As such if a need arises to modify the currently loaded library version such a change may be implemented before executing the called API. The other APIs can trigger equivalent API calls from the loader component to the corresponding library version of the associated binding library thus implementing forwarding functions with no decision logic within them. In this case the loader component only checks for the presence of new binding library versions in these special APIs or similar designated initialization de initialization APIs . Other APIs will not trigger the loader component to perform version checking The connect disconnect APIs are considered special because they setup and teardown the internal state used by the binding library to process the other APIs. As such there is no need to support the loader component triggered migration of state because the connect disconnect APIs setup and teardown the state data themselves. Thus no state migration is needed.

According to yet another illustrative example all any APIs or a subset of APIs have decision logic to check the library version and to trigger a library modification if necessary. The decision logic may be executed for example before the equivalent call is forwarded to the loaded library version. Because all or a subset of API executions need to run the decision logic that logic may be efficient such as by using a memory based shared library version table that stores an indication of the currently desired library version and or a list of available library versions. Since the binding library is likely to be carrying internal state data at the time the API is called the loader component should be able to migrate the binding library state e.g. using a migration API in the new binding library.

Thus according to aspects of the present invention the selection of the version of library from the binding component to be loaded into memory is taken out of the control of the operating system and can be placed under direct control of the loader component . The loader component can perform whatever validation is needed before loading the library and can implement more sophisticated loading techniques and strategies than are possible by simply relying on the underlying operating system library loading mechanisms. Moreover the loader component is capable of performing fallback to an earlier library version software level e.g. provided the internal state migration is possible and supported by the migration API in the later binding library.

As such aspects of the present invention contribute to continuous availability by eliminating planned outages for maintenance updates to system software e.g. middleware in this illustrative example. In this regard the software capabilities described herein can allow changes without requiring the system software to be restarted and even without requiring applications to be quiesced during the changes. Thus applications can continue using the system software even when the changes affect the application interfaces so that two or more different application interfaces can be presented by the same system software during the process of applying the change.

The discussion of dynamically updating software associated with a middleware system e.g. a messaging and queuing system is presented by way of illustration and not by way of limitation to illustrate techniques for performing dynamic software modifications without service interruption as set out more fully herein.

Referring to a schematic is illustrated of a system for implementing dynamic software version selection. The system includes in general a software component and an associated binding library . The binding library is implemented in two distinct components including a loader component and a binding component . In this regard the software component binding library loader component and binding component are substantially analogous to like named components described with reference to any one or more of .

According to further aspects of the present invention the loading and use of new library software can in general be triggered when the customer application issues API calls. As discussed in greater detail herein triggering of version checking and library reloading can occur in response to the loader component receiving special APIs e.g. connect and disconnect APIs. As yet another illustrative example the triggering of version checking and library reloading can occur in response to the loader component receiving all APIs from corresponding calling software component s .

In the illustrated exemplary implementation the system further comprises a shared library version table . The shared library version table stores information related to the various versions of the library stored by the binding component . For instance as illustrated the library table contains the names and version numbers of all available libraries associated with a corresponding binding component . Additionally the shared table may contain a library version variable which stores an indication of which version of the libraries e.g. which shared table entry represents the current version of the library that should be loaded into memory.

The shared table may be populated by any management process such as the queue manager described with reference to . Moreover a mechanism may be implemented to publish available library versions e.g. to the shared library table .

Upon a predefined triggering event e.g. the receipt of a special API call associated with corresponding decision logic upon receipt of all API calls all API calls associated with appropriate decision logic or based upon other decision logic depending upon the specific implementation the loader component inspects the shared table to see whether the customer program is using the correct current version of the available libraries. If the software component is not using the correct version of the library the loader component orchestrates unloading the old library version and loads the correct new version. For instance the loader component can compare the value stored in the library version variable with the version of the library loaded into memory.

Thus for example whenever the customer software component makes an API call associated with corresponding decision logic the loader component can perform an inspection of available libraries against the library version currently being used. When the loader component notices that the currently loaded library is at a different level than the latest available library the loader component can dynamically unload the current library and dynamically load the specified library. Optionally a call to a special migration API in the new library may be implemented e.g. to re arrange any internal state data structures to conform to the requirements of the new library if necessary and complete the processing of the current API call using the new library.

In certain exemplary implementations a manager or other supervisory process e.g. the queue manager described with reference to can direct all connected customer application programs to use a different e.g. newer or older version of the library software the next time the application makes an API call. Alternatively other rules timing conditions etc. can dictate when a software version modification is performed.

Referring to a schematic is illustrated of a system for implementing dynamic software version selection which extends the dynamic software version selection to support program specific controls that allow some control over which programs will migrate to new different versions and which should not. The system includes in general a software component and an associated binding library . The binding library is implemented in two distinct components including a loader component and a binding component . In this regard the software component binding library loader component and binding component are substantially analogous to like named components of described with reference to any one or more of .

In general all software components may tend to migrate to a designated current version usually the latest version of the library as they execute application programming interface calls. However according to further aspects of the present invention control is provided over which programs should migrate to the current version and whether there are certain programs that should not migrate.

As illustrated may include a shared library version table which is analogous to the shared library table described with reference to . However the illustrated implementation further comprises a shared program version table . The shared program version table stores a plurality of software components and the corresponding library version for each application. For instance as illustrated a first software program UPDATE is configured to utilize library version . However the software program REPORT is configured to use library version .

Thus if the software component calling the loader component is the software program UPDATE the loader component when triggered by an appropriate API associated with corresponding decision logic ensures that library version is loaded before processing the call. Correspondingly if the software component calling the loader component is the program REPORT the loader component when triggered by an appropriate API associated with corresponding decision logic ensures that library version is loaded before processing the call. By centrally controlling the shared program version table a management component can determine when individual programs should begin migrating to a new or different library version.

The program library version table maps program names or patterns that match program names etc. to library versions. The program library version table is populated by a suitable management process e.g. the queue manager in the example of or any other suitable supervisory process. Moreover the program library version table contains the names or name patterns of programs that have specific library versions associated therewith. The loader component locates the calling program s name in the program library version table before making a version upgrade or down grade decision.

The program specific decision logic of the loader component can be extended e.g. to migrate all programs by having a single row that matches all program names e.g. using a wildcard or other suitable language that refers to the latest available or current library version. The implementation could require that all programs match at least one row in the program library version table or an implementation could simply default to a predetermined or previous version if the program name doesn t match any row for example.

Various aspects of the present invention have been described with reference to software implementations that utilize dynamic loaded libraries. In this regard software implementations that traditionally utilize programs can be encapsulated into in dynamically loadable libraries rather than in traditional program format. Once encapsulated various software modification techniques can be utilized as described more fully with reference to herein. For example dynamic software version management may be implemented by encapsulating the bulk or all of an online transaction processing OLTP system for an application into dynamically loadable libraries rather than in programs. When this is done new OLTP software can be loaded and used without shutting down a program that interacts with the OLTP system. Program functions not related to the OLTP system are not interrupted at all while program functions related to the OLTP system are upgraded with new software.

Dynamic software library selection for zero downtime upgrades in client side environments and many server side environments can be implemented by embodying OLTP functionality as a set of libraries that are used by the customer business programs or the OLTP system itself. Here supporting zero downtime upgrades is accomplished by allowing programs to at a time of their own choosing logically disconnect from the OTLP system dynamically unload the existing OLTP software libraries dynamically load the new OLTP software libraries and reconnect to the OLTP system using the new software as described in greater detail herein.

Although strictly speaking service is interrupted while performing unloading the old library and loading the new library the interruption is brief and is limited to the particular client process performing the steps. Moreover the selection of the library software version to be used is no longer an operating system operation but is rather placed under direct control of the OLTP software suite. The OLTP software can perform whatever validation is required and can implement more sophisticated loading techniques and strategies than are possible by simply relying on the underlying operating system. Additionally fallback to an earlier software level is also possible using this method.

Referring to a block diagram of a data processing system implemented as a computer system is depicted in accordance with aspects of the present invention. The computer system is operational with numerous general purpose or special purpose computing system environments or configurations. Moreover the computer system may be described in the general context of computer system executable instructions such as program modules being executed by a computer system. Generally program modules may include routines programs objects components logic data structures and so on that perform particular tasks or implement particular abstract data types.

The components of the computer system may include but are not limited to one or more processors or processing units such as a symmetric multiprocessor SMP system or other configuration including a plurality of processors connected to the system bus. Alternatively a single processor may be employed. Components of the computer system further include a system memory and a bus that couples various system components including system memory to the processor s . The memory can include computer system readable media in the form of volatile memory such as random access memory RAM and or cache memory . The memory may also include other removable non removable volatile non volatile computer system storage media such as a storage system e.g. one or more hard drives. Memory may also include at least one computer readable storage medium having computer readable program code embodied therewith the computer readable program code comprising computer readable program code configured to carry out the functions of embodiments of the invention described more fully herein.

The computer system may also comprise input output I O interface s and or a network adapter that communicate with the processor across the bus . The computer system may also interface with external devices and or a display . Other hardware and or software components could be used in conjunction with computer system .

The data processing system may comprise for example an IBM RS 6000 system a product of International Business Machines Corporation in Armonk New York running the Advanced Interactive Executive AIX operating system. An object oriented programming system such as Java may run in conjunction with the operating system and provides calls to the operating system from Java programs or applications executing on data processing system.

As will be appreciated by one skilled in the art aspects of the present invention may be embodied as a system method or computer program product. Accordingly aspects of the present invention may take the form of an entirely hardware embodiment an entirely software embodiment including firmware resident software micro code etc. or an embodiment combining software and hardware aspects that may all generally be referred to herein as a circuit module or system. Furthermore aspects of the present invention may take the form of a computer program product embodied in one or more computer readable storage medium s having computer readable program code embodied thereon.

Any combination of one or more computer readable medium s may be utilized. The computer readable medium may be a computer readable signal medium or a computer readable storage medium. A computer readable storage medium may be for example but not limited to an electronic magnetic optical electromagnetic infrared or semiconductor system apparatus or device or any suitable combination of the foregoing. More specific examples a non exhaustive list of the computer readable storage medium would include the following an electrical connection having one or more wires a portable computer diskette a hard disk a random access memory RAM a read only memory ROM an erasable programmable read only memory EPROM or Flash memory an optical fiber a portable compact disc read only memory CD ROM an optical storage device a magnetic storage device or any suitable combination of the foregoing. In the context of this document a computer readable storage medium may be any tangible medium that can contain or store a program for use by or in connection with an instruction execution system apparatus or device.

A computer readable signal medium may include a propagated data signal with computer readable program code embodied therein for example in baseband or as part of a carrier wave. Such a propagated signal may take any of a variety of forms including but not limited to electro magnetic optical or any suitable combination thereof. A computer readable signal medium may be any computer readable medium that is not a computer readable storage medium and that can communicate propagate or transport a program for use by or in connection with an instruction execution system apparatus or device.

Program code embodied on a computer readable medium may be transmitted using any appropriate medium including but not limited to wireless wireline optical fiber cable RF etc. or any suitable combination of the foregoing.

Computer program code for carrying out operations for aspects of the present invention may be written in any combination of one or more programming languages including an object oriented programming language such as Java Smalltalk C or the like and conventional procedural programming languages such as the C programming language or similar programming languages. The program code may execute entirely on the user s computer partly on the user s computer as a stand alone software package partly on the user s computer and partly on a remote computer or entirely on the remote computer or server. In the latter scenario the remote computer may be connected to the user s computer through any type of network including a local area network LAN or a wide area network WAN or the connection may be made to an external computer for example through the Internet using an Internet Service Provider .

Aspects of the present invention are described herein with reference to flowchart illustrations and or block diagrams of methods apparatus systems and computer program products according to embodiments of the invention. It will be understood that each block of the flowchart illustrations and or block diagrams and combinations of blocks in the flowchart illustrations and or block diagrams can be implemented by computer program instructions. These computer program instructions may be provided to a processor of a general purpose computer special purpose computer or other programmable data processing apparatus to produce a machine such that the instructions which execute via the processor of the computer or other programmable data processing apparatus create means for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

These computer program instructions may also be stored in a computer readable medium that can direct a computer other programmable data processing apparatus or other devices to function in a particular manner such that the instructions stored in the computer readable medium produce an article of manufacture including instructions which implement the function act specified in the flowchart and or block diagram block or blocks.

The computer program instructions may also be loaded onto a computer other programmable data processing apparatus or other devices to cause a series of operational steps to be performed on the computer other programmable apparatus or other devices to produce a computer implemented process such that the instructions which execute on the computer or other programmable apparatus provide processes for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

The flowchart and block diagrams in the Figures illustrate the architecture functionality and operation of possible implementations of systems methods and computer program products according to various embodiments of the present invention. In this regard each block in the flowchart or block diagrams may represent a module segment or portion of code which comprises one or more executable instructions for implementing the specified logical function s . It should also be noted that in some alternative implementations the functions noted in the block may occur out of the order noted in the figures. For example two blocks shown in succession may in fact be executed substantially concurrently or the blocks may sometimes be executed in the reverse order depending upon the functionality involved. It will also be noted that each block of the block diagrams and or flowchart illustration and combinations of blocks in the block diagrams and or flowchart illustration can be implemented by special purpose hardware based systems that perform the specified functions or acts or combinations of special purpose hardware and computer instructions.

The terminology used herein is for the purpose of describing particular embodiments only and is not intended to be limiting of the invention. As used herein the singular forms a an and the are intended to include the plural forms as well unless the context clearly indicates otherwise. It will be further understood that the terms comprises and or comprising when used in this specification specify the presence of stated features integers steps operations elements and or components but do not preclude the presence or addition of one or more other features integers steps operations elements components and or groups thereof.

The corresponding structures materials acts and equivalents of all means or step plus function elements in the claims below are intended to include any structure material or act for performing the function in combination with other claimed elements as specifically claimed. The description of the present invention has been presented for purposes of illustration and description but is not intended to be exhaustive or limited to the invention in the form disclosed. Many modifications and variations will be apparent to those of ordinary skill in the art without departing from the scope and spirit of the invention. Aspects of the invention were chosen and described in order to best explain the principles of the invention and the practical application and to enable others of ordinary skill in the art to understand the invention for various embodiments with various modifications as are suited to the particular use contemplated.

