---

title: System and method for exploiting scene graph information in construction of an encoded video sequence
abstract: A system method and computer program product for creating a composited video frame sequence for an application. A current scene graph state for the application is compared to a previous scene graph state wherein each scene graph state includes a plurality of hierarchical nodes that represent one or more objects at each node. A video construction engine determines if one or more objects have moved based upon a comparison of the scene graph states. If one or more objects have moved based upon the scene graph comparison, motion information about the objects is determined and the motion information is forwarded to a stitcher module. The motion information is used to define motion vectors for use by the stitcher module in construction of the composited video frame sequence.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09219922&OS=09219922&RS=09219922
owner: ACTIVEVIDEO NETWORKS, INC.
number: 09219922
owner_city: San Jose
owner_country: US
publication_date: 20130606
---
The present invention relates to the creation of an encoded video sequence and more particularly to using scene graph information for encoding the video sequence.

It is known in the prior art to encode and transmit multimedia content for distribution within a network. For example video content may be encoded as MPEG video wherein pixel domain data is converted into a frequency domain representation quantized and entropy encoded and placed into an MPEG stream format. The MPEG stream can then be transmitted to a client device and decoded and returned to the spatial pixel domain for display on a display device.

The encoding of the video may be spatial temporal or a combination of both. Spatial encoding generally refers to the process of intraframe encoding wherein spatial redundancy information is exploited to reduce the number of bits that represent a spatial location. Spatial data is converted into a frequency domain over a small region. In general for small regions it is expected that the data will not drastically change and therefore there much of the information will be stored at DC and low frequency components with the higher frequency components being at or near zero. Thus the lack of high frequency information of small area is used to reduce the representative data size. Data may also be compressed using temporal redundancy. One method for exploiting temporal redundancy is through the calculation of motion vectors. Motion vectors establish how objects or pixels move between frames of video. Thus a ball may move between a first frame and a second frame by a number of pixels in a given direction. Thus once a motion vector is calculated the information about the spatial relocation of the ball information from the first frame to the second frame can be used to reduce the amount of information that is used to represent the motion in an encoded video sequence.

Motion vector calculation is perhaps the most time consuming and processor intensive step in compressing video content. Typically a motion vector search algorithm is employed to attempt to match elements within the video frames and to define motion vectors that point to the new location that objects or portions of objects. This motion vector search compares macroblocks between video frames to find a best match. If a best match is identified that is above a certain threshold the process assumes that a motion vector match has been found and uses this information in the compression process. It would be beneficial if a mechanism existed in which motion vectors could be more easily calculated.

In a first embodiment of the invention there is provided a method for creating a composited video frame sequence for an application wherein the video frame sequence is encoded according to a predetermined specification such as MPEG 2 H264 or other block based encoding protocol or variant thereof. A current scene graph state for the application is compared to a previous scene graph state wherein each scene graph state includes a plurality of hierarchical nodes that represent one or more objects at each node. A video construction engine determines if one or more objects have moved based upon a comparison of the scene graph states. If one or more objects have moved based upon the scene graph state comparison motion information about the objects is determined and the motion information is forwarded to a stitcher module. The motion information is used to define motion vectors for use by the stitcher module in construction of the composited video frame sequence. In certain embodiments of the invention the motion vectors are two dimensional motion vectors.

In order to determine the motion information the current scene graph state and the previous scene graph state may be converted from a three dimensional representation into a two dimensional representation. The three dimensional representation may be for a worldview of the objects to be rendered and displayed on a display device. The two dimensional representation may be a screen view for displaying the objects on a display device. In addition to the motion information in general there will be residual graphical information because the edges of moving objects generally do not map exactly on macroblock boundaries or objects are partially translucent overlay or have quantization effects etc.

Embodiments of the invention may construct an MPEG encoded video sequence using the motion information including the corresponding motion vectors and residual graphical information that can be encoded. The scene graph states previous and current may result as the output of an application engine such as an application execution engine. The application execution engine may be a web browser a script interpreter operating system or other computer based environment that is accessed during operation of the application. The scene graph state may be transcoded using a library such as an API. One example of a library is an OpenGL API application programming interface . The transcoded scene graph state results in a graphical processing schema that accesses the library.

The current scene graph state includes a plurality objects having associated parameters. Some examples of parameters are the location of objects to be rendered lighting effects textures and other graphical characteristics that may be used in rendering the object s . A hash may be created for objects within a scene. The hash may be compared to a table of hashes that represent objects from previous scenes. If the current hash matches a hash within the table of hashes MPEG encoded elements for the identified object are retrieved. The MPEG encoded elements can then be sent to a stitcher that can stitch together the MPEG encoded elements to form one or more MPEG encoded video frames in a series of MPEG encoded video frames.

In order to create the hash for the objects the scene graph state is converted to a 2D or display representation. It is then determined which non overlapping rectangles of the display represent state changes of the scene graph state. A hash is created for each rectangle i.e. object the previous and current state of the objects within these rectangles is hashed. These hashes are compared to hashes available in the table of hashes.

If the current hash does not match a hash in the table and no motion information can be determined by the scene graph state comparison for an object the spatial data from the hashing process where the object is converted from a three dimensional representation to a two dimension screen representation is provided to an encoder wherein the encoder compresses the data using at least spatial techniques to produce one or more encoded elements. The encoder may encode according to a predetermined protocol such as MPEG H264 or another block based encoding protocol. The encoded elements are passed to a stitching module. The stitching module forms an encoded MPEG frame from the encoded elements where the encoded MPEG frame is part of an MPEG video sequence.

The methodology may be embodied as a computer program product where the computer program product includes a non transitory computer readable medium having computer code thereon for creating an encoded video sequence. The above described method may be embodied as a system that includes one or more processors that perform specified functions in the creation of the encoded video sequence.

As used in this description and the accompanying claims the following terms shall have the meanings indicated unless the context otherwise requires 

The term application refers to an executable program or a listing of instructions for execution that defines a graphical user interface GUI for display on a display device. An application may be written in a declarative language such as HTML or CSS a procedural language such as C JavaScript or Perl any other computer programming language or a combination of languages.

 Application execution environment is an environment that receives in an application including all of its components and manages the components and execution of the components to define a graphical layout and manages the interactions with the graphical layout. For example Trident WebKit and Gecko are software layout engines that convert web pages into a collection of graphical objects text strings images and so on arranged according to various instructions within a page display area of a web browser. The instructions may be static as in the case of parts of HTML or dynamic as in the case of JavaScript or other scripting languages and the instructions may change as a function of user input. Trident is developed by Microsoft Corporation and used by the Internet Explorer web browser WebKit is developed by a consortium including Apple Nokia Google and others and is used by the Google Chrome and Apple Safari web browsers Gecko is developed by the Mozilla Foundation and is used by the Firefox web browser. Operating systems such as Google s Android and Apple s iOS may be considered application execution environment because these operating systems can execute applications. The output of an application execution environment is a screen state either absolute or relative to a previous screen state . The screen state may be presented as a scene graph state.

 Rendering Engine transforms a model of an image to actual data that can generate the image on a display device. The model of the image may contain two dimensional or three dimensional data as would be represented in a world space and the rendering engine takes the data and transforms the data into a screen space representation wherein the data may be represented as pixels.

 Encoding Engine transforms data representative on an image or a portion of an image into one or more encoded elements. An encoding engine may take pixel data and perform spatial frequency and temporal transformations to represent the data in an encoded format.

 Stitching Engine receives as input one or more encoded elements e.g. MPEG encoded elements along with layout information and then constructs complete video frames for a video sequence e.g. MPEG video frames for an MPEG elementary stream .

 Scene graph is a hierarchical model of an image i.e. a scene generated by an application including nodes and the attributes for the nodes 

 Scene graph state is a scene graph a particular moment in time including nodes and the attributes for the nodes at that time.

 DOM document object model is a convention for representing and interacting with objects in markup languages such as HTML and XML documents.

 DOM tree is a representation of a DOM document object model for a document e.g. an HTML file having nodes wherein the topmost node is the document object.

 CSS cascading style sheets provide the graphical layout information for a document e.g. an HTML document and how each object or class of objects should be represented graphically. The combination of a DOM object and the corresponding CSS files i.e. layout is referred to as a rendering object.

 Render layer is a representation of the rendering objects according to one or more nodes within a scene graph state which may be a modified scene graph state. For example a group of objects that have a geographical relationship such as an absolute or a relative position to each other may form a layer. An object may be considered to be a separate render layer if the object is transparent has an alpha mask or has a reflection for example. A render layer may be defined by a screen area such as a screen area that can be scrolled. A render layer may be designated for an area that may have an overlay e.g. a pop up . A render layer could be defined for a portion of a screen area if that area is to have an applied graphical filter such as a blur color manipulation or shadowing. A layer could be defined by a screen area that has associated video content. Thus a render layer may be a layer within a scene graph state or a modification of a scene graph state layer in which objects are grouped according to a common characteristic

 MPEG element is one or more MPEG encoded macroblocks as disclosed in U.S. patent application Ser. No. 12 443 571 filed Oct. 1 2007 the contents of which are incorporated by reference in their entirety. An MPEG element may be intra encoded within a frame or inter encoded between frames .

Embodiments of the present invention provide for the extraction of spatial information as well as other graphical information from an application execution environment by using software integration points that are for example intended for communication between the application execution environment and Graphical Processing Unit GPU driver software. This spatial information can then be used for the creation of motion vectors for encoding of graphical content in a frequency based encoding format such as MPEG AVS VC 1 H.264 and other block based encoding formats and variants that employ motion vectors.

Embodiments of the invention use the motion information exposed by an Application Execution Environment s GPU interface or another suitable interface that allows access to the scene graph state to obtain spatial and temporal information of the screen objects to be rendered and to use that information to more efficiently encode the screen objects into a stream of MPEG frames.

In order to determine the motion information the application execution Environment may access Z ordering information from a scene graph for the rendering of objects. For example the application execution environment can separate a background layer from a foreground image layer and the scene graph state may specify objects that are partially translucent. This information can be used to determine what information will be rendered from a 3 dimensional world view in a 2 dimensional screen view. Once the visible elements are determined motion information can be determined and the motion information can be converted into motion vectors. Multiple motion vectors may be present for a particular screen area. For example if two different layers on different Z indices are moving in different directions the area would have different associated motion vectors. The encoder will determine a dominant vector given its knowledge on what is being rendered including translucency surface area of the moving object texture properties i.e. is it a solid or a pattern etc.

As shown the Application Execution Engine may produce an output for graphical processing. Examples of application execution environments include both computer software and hardware and combinations thereof for executing the application. Applications can be written for certain application execution environments including WebKit JAVA compilers script interpreters Perl etc. and various operating systems including iOS and Android OS for example.

The video construction engine takes advantage of the data that it receives from the application execution environment in order to exploit redundancies in requests for the presentation of information within user sessions and between user sessions as well as determining motion changes of objects from a previous video frame or scene graph state to a current frame or scene graph state. The present system may be used in a networked environment wherein multiple user sessions are operational simultaneously wherein requested applications may be used by multiple users simultaneously.

The video construction engine may receive in OpenGL data and can construct a scene graph from the OpenGL data. The video construction engine can then compare the current scene graph state to one or more previous scene graph states to determine if motion occurs between objects within the scene. If motion occurs between the objects this motion can be translated into a motion vector and this motion vector information can be passed to an encoding module . Thus the encoding module need not perform a motion vector search and can add the motion vectors into the video frame format e.g. MPEG video frame format . The MPEG elements can be constructed that are encoded MPEG macroblocks that are inter frame encoded. These macroblocks are passed to the stitching module that receives stitching information about the video frame layout and stitches together encoded MPEG elements to form complete MPEG encoded video frames in accordance with the scene graph. Either simultaneously or in sequence the MPEG video construction engine may hash the parameters for objects within the scene graph according to a known algorithm. The construction engine will compare the hash value to hash values of objects from previous scene graphs and if there is a match within the table of hashes the construction engine will locate MPEG encoded macroblocks MPEG elements that are stored in memory and are related to the hash. These MPEG elements can be passed directly to the stitching engine wherein the MPEG elements are stitched together to form complete MPEG encoded video frames. Thus the output of the stitching module is a sequence of encoded video frames that contain both intra frame encoded macroblocks and inter frame encoded macroblocks. Additionally the video construction engine outputs pixel based information to the encoder. This pixel based information may be encoded using spatial based encoding algorithms including the standard MPEG DCT processes. This pixel based information occurs as a result of changes in the scene visual display in which objects represented by rectangles are altered. The encoded macroblocks can then be passed to the stitcher. The processes of the video construction engine will be explained in further detail with respect to the remaining figures.

The application execution engine may be proximate to the client device operational on the client device or may be remote from the client device such as in a networked client server environment. The control signal for the dirty rectangle causes the application execution engine to generate a scene graph having a scene graph state that reflects the changes to the screen e.g. dirty rectangles of the screen display . For example the application execution environment may be a web browser operating within an operating system. The web browser represents a page of content in a structured hierarchical format such as a DOM and corresponding DOM tree. Associated with the DOM tree is a CSS that specifies where and how each object is to be graphically rendered on a display device. The web browser creates an output that can be used by a graphics engine. The output that is produced is the scene graph state which may have one or more nodes and objects associated with the nodes forming a layer i.e. a render layer . As requests occur from a client device for updates or updates are automatically generated as in a script a new or current scene graph state is generated. Thus the current scene graph state represents a change in the anticipated output video that will be rendered on a display device. An exemplary scene graph state is shown in described below.

Once the current scene graph state is received by the video construction engine the scene graph state can be compared with a previous scene graph state . The comparison of scene graph states can be performed hierarchically by layer and by object. For each object associated with a node differences in the positions of objects from the scene graph states can be identified as well as differences in characteristics such as translucence and lighting.

For example in a simple embodiment a circle may be translated by a definable distance between the current scene graph state and a previous scene graph state. The system queries whether one or more objects within the scene graph state have moved. If one or more objects have been identified as moving between scene graph states information about the motion translation are determined . This information may require the transformation of position data from a three dimensional world coordinate view to a two dimensional screen view so that pixel level motion two dimensional motion vectors can be determined. This motion information can then be passed on to an encoder in the form of a motion vector . Thus the motion vector information can be used by the encoder which to create interframe encoded video frames. For example the video frames may be P or B frame MPEG encoded frames.

In addition to objects moving scene elements may also change. Thus a two dimensional representation of information to be displayed on a screen can be ascertained from the three dimensional scene graph state data. Rectangles can be defined as dirty rectangles which identify data on the screen that has changed . These rectangles can by hashed according to a known formula that will take into account properties of the rectangles . The hash value can then be compared to a listing of hash values associated with rectangles that were updated from previous scene graph states . The list of hash values may be for the current user session or for other user sessions. Thus if a request for a change in the content being displayed in an application is received from multiple parties the redundancy in information being requested can be exploited and processing resources conserved. More specifically if the hash matches a hash within the searchable memory encoded graphical data e.g. either a portion of an entire video frame of encoded data or an entire frame of encoded data that is linked to the hash value in the searchable memory is retrieved and the data can be combined with other encoded video frames .

Additionally if a rectangle is identified as being dirty and a hash is not identified the spatial information for that rectangle can be passed to the encoder and the MPEG encoder will spatially encode the data for the rectangle. As used herein the term content may refer to a dirty rectangle or an object from a scene graph state.

The application execution environment creates a current scene graph . The current scene graph may be translated using a library of functions such as the OpenGL library . The resulting OpenGL scene graph state is passed to the video construction engine . The OpenGL scene graph state for the current scene graph is compared to a previous scene graph state in a comparison module . This may require the calculation and analysis of two dimensional projections of three dimension information that are present within the scene graph state. Such transformation are known by one of ordinary skill in the art. It should be recognized that OpenGL is used herein for convenience and that only the creation of a scene graph state is essential for the present invention. Thus the scene graph state need not be converted into OpenGL before a scene graph state comparison is performed.

Differences between the scene graphs are noted and dirty rectangles can be identified . A dirty rectangle represents a change to an identifiable portion of the display e.g. a button changing from an on state to an off state . There may be more than one dirty rectangle that is identified in the comparison of the scene graph states. Thus multiple objects within a scene may change simultaneously causing the identification of more than one dirty rectangle.

From the list of dirty rectangles a list of MPEG fragment rectangles i.e. spatially defined fragments such as a plurality of macroblocks on macroblock boundaries can be determined for the dirty rectangle. It should be recognized that the term MPEG fragment rectangle as used in the present context refers to spatial data and not frequency transformed data and is referred to as an MPEG fragment rectangle because MPEG requires a block based formatting schema i.e. macroblocks that are generally 16 16 pixels in shape. Defining dirty rectangles as MPEG fragment rectangles can be achieved by defining an MPEG fragment rectangle for a dirty rectangle wherein the dirty rectangle is fully encompassed within a selection of macroblocks. Thus the dirty rectangle fits within a rectangle composed of spatially defined macroblocks. Preferably the dirty rectangles are combined or split to limit the number of MPEG fragment rectangles that are present or to avoid small changes in large rectangles.

For each MPEG fragment rectangle a listing of nodes according to z order depth in the scene graph that contributed to the rectangle contents is determined. This can be achieved by omitting nodes that are invisible have a low opacity or have a transparent texture.

For each MPEG fragment rectangle a hash value is created based upon relevant properties of all nodes that have contributed to the rectangle contents for example absolute position width height transformation matrix hash of texture bitmap opacity . If the cache contains an encoded MPEG fragment associated with that hash value then the encoded MPEG fragment is retrieved from the cache. In the present context the term encoded MPEG fragment refers to a portion of a full frame of video that has been encoded according to the MPEG standard. The encoding may simply be DCT encoding for blocks of data or may also include MPEG specific header information for the encoded material. If the calculated hash value does not match an MPEG fragment in the cache then the dirty rectangle contents using the scene graph state are rendered from a three dimensional world view to a two dimensional screen view and the rendered pixel data i.e. spatial data are encoded in an encoder such as an MPEG encoder . The encoded MPEG data e.g. encoded MPEG fragment s for the scene is stored into the cache.

As part of the encoding process the fragment is analyzed to determine whether the encoding can best be performed as inter encoding an encoding relative to the previous screen state or whether it is encoded as intra encoding an independent encoding . Inter encoding is preferred in general because it results in less bandwidth and may result in higher quality streams. All changes in nodes between scene graphs are determined including movement changes of opacity and changes in texture for example. The system then evaluates whether these changes contribute to a fragment and whether it is possible to express these changes efficiently into the video codec s primitives. If the evaluation indicates that changes to dominant nodes can be expressed well in the videocodec s primitives then the fragment is inter encoded. These steps are repeated for every screen update. Since the new scene graph will become previous scene graph in a next screen update intermediate results can be reused from previous frames.

The tree like structure provides a hierarchical representation wherein attributes of parent objects can be attributed to the child objects. The root object represents the entire scene while child nodes of a certain node may contain a decomposition of the parent node into smaller objects. The nodes contain may contain a texture bitmap object a 3D transformation matrix that specifies how the texture is positioned in a 3D space and or other graphical attributes such as visibility and transparency. A child node inherits all attributes transformations filters from the parent node.

For example movement between scene graphs for an object such as the cover list would indicate that each of the child objects cover1 cover2 cover3 and cover4 would also move by an equal amount. As shown the screen shot of includes a hierarchy wherein there is a static layer a cover list layer and a background layer and cover1 cover2 cover3 and cover4 are at a sub layer for the cover list layer. The choice of objects that are associated with a specific layer is performed by the application execution environment such as in a web browser.

The scene graph comparison between the previous scene graph and the current scene graph may be performed in the following manner wherein the scene graph is transformed from a 3D to a 2D space. A node in a scene graph consists of an object having a texture 2D bitmap and a transformation how that object is floating in space. It also contains the z order absolute order to render things . In OpenGL the transformation consists of a matrix 

This transformation is applied to an element a in a 3D space by matrix multiplication. The element a is identified by four points the origin and the three top positions of the object in x y and z direction. The bottom row i.e. elements m 12 m 13 and m 14 specify translation in 3D space. Elements m 0 m 4 m 8 m 1 m 5 m 9 m 2 m 6 m 10 specify the three top positions of an object i.e. furthest point out in x y z direction where that particular point will end up by using matrix multiplication. This allows for object or frame rotation slanting shearing shrinking zooming and translation etc. and repositioning of the object in world space at any time.

When two transformations have been applied to an object according to matrix m from the previous scene graph and n from the current scene graph then the difference between the two is m n matrix subtraction. The result of the matrix subtraction gives the amount of rotation slanting shearing shrinking zooming translation etc. that has been performed to the object between the previous frame and the current frame.

Projecting a 3D image to a 2D surface is well known in the art. In one embodiment the system first calculates projections of the 3D scene graphs onto a 2D plane where the transformation matrices also become 2D. The motion vector obtained by subtracting the transformation matrices is then 2D and can be directly applied by the MPEG encoder. One motion vector per destination macroblock is passed if motion was detected. The motion vector has a defined x y direction having a certain length that indicates direction and distance covered between the current frame and the previous frame. The encoder then assumes that the reference information for a macroblock is located in the reverse direction of the motion vector. If no motion was detected then either the macroblock did not change or it changed entirely and then it is intra encoded.

Hashing and caching of dirty rectangles on individual layers of a scene graph state is more efficient compared to hashing and caching of 2D projection of these layers because the layers represent independent changes.

It should be noted that some Application Execution Environments might use one background layer where it renders objects for which it chooses not to create a separate render layer. This could be a wall clock for example. Changes to this layer are analyzed resulting in one or more dirty rectangles. In principle all rectangles depend on the background if the background changes parts of the background are likely visible in the rectangle due to the macroblock snapping . To avoid the background being part of every rectangle s hash function and thus to avoid a re rendering and re encoding of all rectangles when the background changes e.g. when the seconds hand moves in the wall clock object the background is excluded from the scene graph and it is not available as an MPEG fragment.

The present invention may be embodied in many different forms including but in no way limited to computer program logic for use with a processor e.g. a microprocessor microcontroller digital signal processor or general purpose computer programmable logic for use with a programmable logic device e.g. a Field Programmable Gate Array FPGA or other PLD discrete components integrated circuitry e.g. an Application Specific Integrated Circuit ASIC or any other means including any combination thereof. In an embodiment of the present invention predominantly all of the reordering logic may be implemented as a set of computer program instructions that is converted into a computer executable form stored as such in a computer readable medium and executed by a microprocessor within the array under the control of an operating system.

Computer program logic implementing all or part of the functionality previously described herein may be embodied in various forms including but in no way limited to a source code form a computer executable form and various intermediate forms e.g. forms generated by an assembler compiler networker or locator. Source code may include a series of computer program instructions implemented in any of various programming languages e.g. an object code an assembly language or a high level language such as Fortran C C JAVA or HTML for use with various operating systems or operating environments. The source code may define and use various data structures and communication messages. The source code may be in a computer executable form e.g. via an interpreter or the source code may be converted e.g. via a translator assembler or compiler into a computer executable form.

The computer program may be fixed in any form e.g. source code form computer executable form or an intermediate form either permanently or transitorily in a tangible storage medium such as a semiconductor memory device e.g. a RAM ROM PROM EEPROM or Flash Programmable RAM a magnetic memory device e.g. a diskette or fixed disk an optical memory device e.g. a CD ROM a PC card e.g. PCMCIA card or other memory device. The computer program may be fixed in any form in a signal that is transmittable to a computer using any of various communication technologies including but in no way limited to analog technologies digital technologies optical technologies wireless technologies networking technologies and internetworking technologies. The computer program may be distributed in any form as a removable storage medium with accompanying printed or electronic documentation e.g. shrink wrapped software or a magnetic tape preloaded with a computer system e.g. on system ROM or fixed disk or distributed from a server or electronic bulletin board over the communication system e.g. the Internet or World Wide Web. 

Hardware logic including programmable logic for use with a programmable logic device implementing all or part of the functionality previously described herein may be designed using traditional manual methods or may be designed captured simulated or documented electronically using various tools such as Computer Aided Design CAD a hardware description language e.g. VHDL or AHDL or a PLD programming language e.g. PALASM ABEL or CUPL. 

While the invention has been particularly shown and described with reference to specific embodiments it will be understood by those skilled in the art that various changes in form and detail may be made therein without departing from the spirit and scope of the invention as defined by the appended clauses. As will be apparent to those skilled in the art techniques described above for panoramas may be applied to images that have been captured as non panoramic images and vice versa.

Embodiments of the present invention may be described without limitation by the following clauses. While these embodiments have been described in the clauses by process steps an apparatus comprising a computer with associated display capable of executing the process steps in the clauses below is also included in the present invention. Likewise a computer program product including computer executable instructions for executing the process steps in the clauses below and stored on a computer readable medium is included within the present invention.

