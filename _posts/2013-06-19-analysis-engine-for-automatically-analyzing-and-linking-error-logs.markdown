---

title: Analysis engine for automatically analyzing and linking error logs
abstract: Test results can be analyzed and linked using an automated system. In a first embodiment, an error log can be received including log data associated with an error. The log data can be parsed to transform it into a standardized format to allow for easier searching and comparison. Once standardized, an automatic comparison can be made between the parsed log data and previous errors obtained from error logs. If a match is found between the parsed log data and a previous error, then the parsed log data can be linked to the previous error so as to generate a relationship between the two.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09424115&OS=09424115&RS=09424115
owner: SuccessFactors, Inc.
number: 09424115
owner_city: San Mateo
owner_country: US
publication_date: 20130619
---
Developing new applications can involve intensive tests to ensure that application goals are met. For example application designers typically have quality considerations that must be taken into account. In order to test the applications the application designer writes specific test cases conducts usability studies and performs time intensive ad hoc testing to ensure that design goals are met. For efficiency automated tests can be created that mimic human interaction with the application such as automatically selecting buttons menu items etc. Based on the tests an error log is typically generated. The error log can include test results with various fields of information about the error. The error log can be analyzed to determine the cause of the error so that corrections can be made to the application.

Currently analysis of error logs consume significant time and money. The application designer analyzes the reason for the error and makes a determination of how to implement corrective action. The same errors can re occur multiple times and if the person reviewing the error log does not recall the reason for the error he or she must re determine the cause and solution.

Error logs can be analyzed and linked using an automated system. In a first embodiment an error log can be received including log data associated with an error. The log data can be parsed to transform it into a standardized format to allow for easier searching and comparison. Once standardized an automatic comparison can be made between the parsed log data and previous errors obtained from error logs. If a match is found between the parsed log data and a previous error then the parsed log data can be linked to the previous error so as to generate a relationship there between.

In another embodiment a user can change the stored linking information. By receiving user supplied corrective linking information the system can be educated in how to handle future situations so that linking can be more accurate. Thus a self learning mechanism allows increased accuracy as more results are obtained. Ultimately as the system continues to link results together more accurate matching of test failures with a root cause can be obtained.

In another embodiment a set of rules can be implemented in order customize whether a match occurs. For example a matcher can filter results based on an error type an error message trace data a location in source code etc. By customizing which or how many of such matching criteria are met before a match is found allows a user to configure a range of matched results. Thus a user can increase the range by requiring less criteria to match. Alternatively the user can decrease the range less matches by requiring more criteria to be matched.

This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used to limit the scope of the claimed subject matter.

The foregoing and other objects features and advantages of the invention will become more apparent from the following detailed description which proceeds with reference to the accompanying figures.

It is well understood that certain of the above fields can be eliminated and others added. Once the parser stores the transformed error log in the library including the fields identified above it calls a matcher . The matcher can read a configuration file which can be dynamically configured by a user such as through a user interface . The configuration file can instruct the matcher how to customize the matching. For example the matcher can filter results based on one or more of the following fields described above an error type an error message trace data a location in source code etc. By customizing which or how many of such matching criteria are met before a match is found allows a user to configure a range of matched results. Thus a user can increase the range by requiring less criteria to match. Alternatively the user can decrease the range by requiring more criteria to be matched.

In one example the matcher can match the error type and the error message. The error message stored in the library can include a list of possible error expressions used to identify a single error type. Different users can describe errors differently and the list of error expressions allows for alternative expressions that can identify the same error. An example list is shown below.

If the matcher matches any one of the expressions in the list than the error message can be considered matched. Thus the matcher can methodically compare the parsed log data to a plurality of candidate errors in the library . First the error type can be compared and if there is a match between the error type of the parsed log data and the candidate error then further analysis can be performed. For example an error message of the parsed log data can be compared to the error message of the candidate error. If the parsed log data matches both the error type and the error message then depending on the configuration file either a match has occurred or additional data can be compared. For example the matcher can continue to determine if one or both of a trace and or a source context are matched. In any event if a match is found the linking type of the candidate error can be used as the linking type of the parsed log data. Thus a relationship can be established between the parsed log data and the candidate error.

A result fetcher can be responsive to the user interface in order to search the library for desired results. For example the user interface can be used to communicate with the result fetcher requesting stored errors of a certain type. This can allow a user to identify errors that have occurred in the past. Searches can be performed on any of the fields associated with an error.

When a new error log is received the result portal stores the error log in a log event feeder including the fields previously described in a text format. The log event feeder can then pass the error log to a parser . The parser can read through the error log to identify the various fields and transform the error log into a standardized format for storage in the library . The standardized format can be any of a variety of formats depending on the particular implementation. For example the fields in the error log can be rearranged formatted and or truncated etc. in order that the library has a standardized database suitable for searching. Depending on customization information supplied by the user the parser can also access a source code via a source indexer . Using the source indexer a location in the source code associated with the error log can be identified and stored together with the parsed error log in the library . Additionally the parser can generate a unique identifier the event identifier to associate with the error log after it is stored in the library . Once the parser has completed the transformation it can notify a matcher that a new error log has been stored. Such a notification can include the event identifier so that the matcher can identify the error log. The matcher can then access the library and perform a search to automatically compare the parsed log data the new error log to one or more previous errors stored in the library . Specifically the previous errors have associated error logs stored in a similar format to the new error log and the matcher can compare the error logs in accordance with customization options provided by a user. If a match is found between the parsed log data and a previous error then the matcher can use the linking type of the matched previous error for associating the two errors together. Thus the matcher can assess the linking type of the parsed log data and insert the appropriate linking type based on a comparison with previous errors associated with error logs. The error log stored in the library can include a field describing why the error occurred. Such a field can be provided by the user to document information about the error that is useful for evaluation of similar future errors.

With reference to the computing environment includes one or more processing units and memory . In this basic configuration is included within a dashed line. The processing units execute computer executable instructions. A processing unit can be a general purpose central processing unit CPU processor in an application specific integrated circuit ASIC or any other type of processor. In a multi processing system multiple processing units execute computer executable instructions to increase processing power. For example shows a central processing unit as well as a graphics processing unit or co processing unit . The tangible memory may be volatile memory e.g. registers cache RAM non volatile memory e.g. ROM EEPROM flash memory etc. or some combination of the two accessible by the processing unit s . The memory stores software implementing one or more innovations described herein in the form of computer executable instructions suitable for execution by the processing unit s .

A computing system may have additional features. For example the computing environment includes storage one or more input devices one or more output devices and one or more communication connections . An interconnection mechanism not shown such as a bus controller or network interconnects the components of the computing environment . Typically operating system software not shown provides an operating environment for other software executing in the computing environment and coordinates activities of the components of the computing environment .

The tangible storage may be removable or non removable and includes magnetic disks magnetic tapes or cassettes CD ROMs DVDs or any other medium which can be used to store information in a non transitory way and which can be accessed within the computing environment . The storage stores instructions for the software implementing one or more innovations described herein.

The input device s may be a touch input device such as a keyboard mouse pen or trackball a voice input device a scanning device or another device that provides input to the computing environment . For video encoding the input device s may be a camera video card TV tuner card or similar device that accepts video input in analog or digital form or a CD ROM or CD RW that reads video samples into the computing environment . The output device s may be a display printer speaker CD writer or another device that provides output from the computing environment .

The communication connection s enable communication over a communication medium to another computing entity. The communication medium conveys information such as computer executable instructions audio or video input or output or other data in a modulated data signal. A modulated data signal is a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example and not limitation communication media can use an electrical optical RF or other carrier.

Although the operations of some of the disclosed methods are described in a particular sequential order for convenient presentation it should be understood that this manner of description encompasses rearrangement unless a particular ordering is required by specific language set forth below. For example operations described sequentially may in some cases be rearranged or performed concurrently. Moreover for the sake of simplicity the attached figures may not show the various ways in which the disclosed methods can be used in conjunction with other methods.

Any of the disclosed methods can be implemented as computer executable instructions stored on one or more computer readable storage media e.g. one or more optical media discs volatile memory components such as DRAM or SRAM or nonvolatile memory components such as flash memory or hard drives and executed on a computer e.g. any commercially available computer including smart phones or other mobile devices that include computing hardware . The term computer readable storage media does not include communication connections such as signals and carrier waves. Any of the computer executable instructions for implementing the disclosed techniques as well as any data created and used during implementation of the disclosed embodiments can be stored on one or more computer readable storage media. The computer executable instructions can be part of for example a dedicated software application or a software application that is accessed or downloaded via a web browser or other software application such as a remote computing application . Such software can be executed for example on a single local computer e.g. any suitable commercially available computer or in a network environment e.g. via the Internet a wide area network a local area network a client server network such as a cloud computing network or other such network using one or more network computers.

For clarity only certain selected aspects of the software based implementations are described. Other details that are well known in the art are omitted. For example it should be understood that the disclosed technology is not limited to any specific computer language or program. For instance the disclosed technology can be implemented by software written in C Java Perl JavaScript Adobe Flash or any other suitable programming language. Likewise the disclosed technology is not limited to any particular computer or type of hardware. Certain details of suitable computers and hardware are well known and need not be set forth in detail in this disclosure.

It should also be well understood that any functionality described herein can be performed at least in part by one or more hardware logic components instead of software. For example and without limitation illustrative types of hardware logic components that can be used include Field programmable Gate Arrays FPGAs Program specific Integrated Circuits ASICs Program specific Standard Products ASSPs System on a chip systems SOCs Complex Programmable Logic Devices CPLDs etc.

Furthermore any of the software based embodiments comprising for example computer executable instructions for causing a computer to perform any of the disclosed methods can be uploaded downloaded or remotely accessed through a suitable communication means. Such suitable communication means include for example the Internet the World Wide Web an intranet software applications cable including fiber optic cable magnetic communications electromagnetic communications including RF microwave and infrared communications electronic communications or other such communication means.

The disclosed methods apparatus and systems should not be construed as limiting in any way. Instead the present disclosure is directed toward all novel and nonobvious features and aspects of the various disclosed embodiments alone and in various combinations and subcombinations with one another. The disclosed methods apparatus and systems are not limited to any specific aspect or feature or combination thereof nor do the disclosed embodiments require that any one or more specific advantages be present or problems be solved.

For example although the embodiments described herein relate to application testing the embodiments can equally be applied to error logs of any type generated by automation testing.

In view of the many possible embodiments to which the principles of the disclosed invention may be applied it should be recognized that the illustrated embodiments are only preferred examples of the invention and should not be taken as limiting the scope of the invention. Rather the scope of the invention is defined by the following claims. We therefore claim as our invention all that comes within the scope of these claims.

