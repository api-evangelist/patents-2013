---

title: Storage of keyID in customer data area
abstract: A key identifier for an encryption key repository is stored with customer data on a logical device. When the customer data is compressible, the key identifier is stored in space freed by compressing the customer data. When the customer data is not compressible, a portion of the customer data is copied to a key record in the key repository identified by the key identifier, and the key identifier overwrites the copied customer data.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09324123&OS=09324123&RS=09324123
owner: Brocade Communications Systems, Inc.
number: 09324123
owner_city: San Jose
owner_country: US
publication_date: 20130816
---
This application is a continuation of U.S. patent application Ser. No. 12 580 918 filed Oct. 16 2009 titled Storage of KeyID in Customer Data Area the entire contents of which is incorporated herein by reference for all purposes.

The present invention relates to the field of computers and in particular to a technique for storing encryption keys.

Managing operational risk by protecting valuable digital assets has become increasingly critical in modern enterprise information technology IT environments. In addition to achieving compliance with regulatory mandates and meeting industry standards for data confidentiality IT organizations must also protect against potential litigation and liability following a reported breach.

In the context of data center fabric security operators of Storage Area Networks SANs have desired fabric based encryption services to secure data assets either selectively or on a comprehensive basis.

Most sensitive corporate data is stored in the data center and the vast majority of data from critical applications resides in a SAN enabling organizations to employ the intelligence of the storage fabric as a centralized framework in which to deploy manage and scale fabric based data security solutions.

The storage fabric enables centralized management to support various aspects of the data center from server environments and workstations to edge computing and backup environments providing a place to standardize and consolidate a holistic data at rest security strategy. Organizations can also implement data at rest encryption in other parts of the data center helping to protect data throughout the enterprise.

Most current industry solutions include either host based software encryption device embedded encryption or edge encryption all of which provide isolated services to specific applications but typically cannot scale across extended enterprise storage environments.

Some solutions have provided centralized encryption services that employ key repositories such as provided by several vendors. These key repositories can be considered specialized secure databases of the encryption keys used by the SAN for encrypting data at rest on the media controlled by the SAN. Each key stored by the key repository is associated with a key identifier keyID that can be used to obtain the key from the key repository.

In addition operators of SANs have a need from time to time to move customer data from one logical unit LUN to another. If the data being moved is encrypted operators have desired a way of keeping track of the keyID corresponding to that LUN without the expense and performance impacts of an external database associating keyIDs with LUNs which would increase I O costs and also increase risks of data inconsistencies should the bookkeeping necessary to keep the external database accurate fail.

In one embodiment a method is disclosed. The method comprises copying a first customer data from a first portion of a customer data area of a logical device to an encryption key record of a key repository corresponding to a key identifier and overwriting the first customer data in the first portion of the customer data area with the key identifier.

In another embodiment a method is disclosed. The method comprises reading a first customer data from a first portion of a customer data area of a logical device checking for a signature data in a first portion of the first customer data extracting a key identifier corresponding to an encryption key record in a key repository from the first portion of the first customer data if the signature data is found in the first portion of the first customer data decompressing a second portion of the first customer data and replacing the first customer data with the decompressed second portion of the first customer data.

In yet another embodiment a method is disclosed. The method comprises reading a sequence of customer data areas from a first portion of a logical device checking for a signature data in each of the sequence of customer data areas until one of the sequence of customer data areas contains the signature data extracting a key identifier corresponding to an encryption key record in a key repository from a first portion of the one of the sequence of customer data areas decompressing a second portion of the one of the sequence of customer data areas and replacing the one of the sequence of customer data areas with the decompressed second portion.

In yet another embodiment a network device is disclosed. The network device comprises a processor a program storage device coupled to the processor configured to store instructions that when executed by the processor cause the processor to perform actions. The actions comprise copying a first customer data from a first portion of a customer data area of a logical device to an encryption key record of a key repository corresponding to a key identifier and overwriting the first customer data in the first portion of the customer data area with the key identifier.

In yet another embodiment a network device is disclosed. The network device comprises a processor a program storage device coupled to the processor configured to store instructions that when executed by the processor cause the processor to perform actions. The actions comprise reading a first customer data from a first portion of a customer data area of a logical device checking for a signature data in a first portion of the first customer data extracting a key identifier corresponding to an encryption key record in a key repository from the first portion of the first customer data if the signature data is found in the first portion of the first customer data decompressing a second portion of the first customer data and replacing the first customer data with the decompressed second portion of the first customer data.

In yet another embodiment a system is disclosed. The system comprises a logical device and a network device communicatively coupled with the logical device. The logical device comprises a first customer data area. The network device comprises a processor a program storage device coupled to the processor configured to store instructions that when executed by the processor cause the processor to perform actions. The actions comprise copying a first customer data from the first customer data area to an encryption key record of a key repository corresponding to a key identifier and overwriting the first customer data in the first customer data area with the key identifier.

Various embodiments described below provide a way to keep the keyIDs associated with data stored in a logical device in the customer data of the logical device transparently to the customer s use of the data.

In the following description for purposes of explanation numerous specific details are set forth in order to provide a thorough understanding of the invention. It will be apparent however to one skilled in the art that the invention may be practiced without these specific details. In other instances structure and devices are shown in block diagram form in order to avoid obscuring the invention. References to numbers without subscripts are understood to reference all instance of subscripts corresponding to the referenced number. Moreover the language used in this disclosure has been principally selected for readability and instructional purposes and may not have been selected to delineate or circumscribe the inventive subject matter resort to the claims being necessary to determine such inventive subject matter. Reference in the specification to one embodiment or to an embodiment means that a particular feature structure or characteristic described in connection with the embodiments is included in at least one embodiment of the invention and multiple references to one embodiment or an embodiment should not be understood as necessarily all referring to the same embodiment.

Although the following disclosure is written in the context of a SAN the scope of the present invention is not limited to a SAN but includes any type of system in which a key repository is accessed by a key identifier for an encryption key that is associated with media that has been or will be encrypted or decrypted using that key. Furthermore although the embodiments describe below employ disclosed techniques for generating keyIDs in an encryption switch the scope of the present invention is not so limited and includes the use of such techniques in other types of devices such as hosts or storage devices.

Other servers or hosts switches and storage devices can be used in the SAN illustrated in . The elements shown in are illustrative and by way of example only and other elements and other numbers and arrangements of elements including other numbers of fabrics can be included as desired. In particular the switch can be a standalone switch or a blade in a larger backbone switch.

As shown in the encryption switch provides for data at rest encryption of data stored on the RAID array the tape library and the JBOD allowing access to the encrypted data that is stored in the SAN . Thus information about encryption keys must be available to the encryption switch . In some embodiments single elements shown in may be implemented as redundant components with two or more redundant elements provisioned into the network for reliability and performance reasons. For example in a preferred embodiment the encryption switch can be provisioned as two or more redundant encryption switches .

In addition to the elements listed above a key management system provides for operator control over the encryption services typically as part of a configuration management system for the SAN which is not described further herein. Furthermore a key repository provides key management services to encryption switch .

In order to provide enterprise wide consistent and secure encryption keys the encryption switches uses key services provided by the key repository . There are multiple vendors of key repositories each of which may store keys differently and have a different interface for requesting keys from the key repository and storing keys in the key repository . Example key repositories include without limitation the NetApp Lifetime Key Management Appliance LKM from NetApp the RSA Key Manager RKM from RSA the HP StorageWorks Secure Key Manager from Hewlett Packard Development Company L.P. the IBM Tivoli Key Lifecycle Manager TKLM from IBM Corporation and Thales Encryption Manager for Storage TEMS from Thales e Security Inc. The specific protocol used for communicating with a specific vendor s key repository as well as the techniques used for storing keys internal to the key repository and other internal structure of the key repository is outside the scope of the present invention.

The initiator initiates a read or write request to the target . Data at rest encryption has been used to encrypt the data stored in the logical device . The switch fabric carries the request from the initiator to the encryption switch . The SAN fabric is typically a Fibre Channel fabric and uses Fibre Channel protocols to pass requests and responses between the initiator and the target . The encryption switch encrypts and decrypts the data read from or written to a logical unit LUN of the target .

At no time does the initiator have access to the key referred to herein as a Data Encryption Key DEK that is used to encrypt or decrypt data stored on the LUN of the target . Instead encrypted data received from the target is decrypted by the encryption switch before transmitting the decrypted data to the initiator . In one embodiment the encryption switch limits access to DEKs to a cryptographic module of the switch in compliance with the standards of Federal Information Processing Standard Publication 140 2 FIPS 140 2 Security Requirements for Cryptographic Modules a copy of which is incorporated by reference herein.

The key repository manages the DEKs providing the DEKs to the encryption switch . The encryption switch does not store the DEKs but obtains them from the key repository as needed.

In addition a management Local Area Network LAN typically an Ethernet LAN is used to link the management system and the SAN fabric devices including the encryption switch .

Any desired protocol can be used to communicate between the key repository and encryption switch . One example of such a protocol is the NetApp OpenKey Application Programming Interface OpenKey API . Using the OpenKey API keys that are communicated between the encryption device and the key repository are wrapped encrypted in another key before sending them within a Transport Layer Security TLS session. The key repository manages the DEKs and performs other tasks related to managing keys for a network.

In a redundant embodiment DEKs are synchronized between the encryption device through the SAN fabric and interconnected fabrics as necessary. The redundant key repositories also synchronize with each other to ensure access to keys if one key repository fails. These redundant key exchanges attempt to ensure that the data can be encrypted or decrypted without a single point of failure. In such a redundant embodiment a separate cluster LAN typically comprised of Gigabit Ethernet GbE links between the encryption devices and key repositories is typically used for exchanging DEKs between the redundant key repositories and encryption switches in a cluster.

As described above key repositories may be considered as a secure database for storing keys among other things using a keyID as the database key for accessing a key record associated with the keyID with information about a given DEK. Thus in order to obtain a key from the key repository the encryption switch must determine the keyID value that corresponds to the desired key.

A Key Archive Client KAC module provides the encryption switch with a general interface to interact with the various key repositories via specific plug in modules or adapters that perform the necessary translations for specific key repositories . For example if the key repository is a NetApp LKM repository then the plugin is an LKM plugin.

A security processor management module provides an interface between a security processor module and the key archive client . The security processor module performs key generation key encryption and key injection into the cryptographic engines of the encryption switch . In one embodiment the security processor module is a security processor operating system that provides FIPS Level 3 compliance.

Turning to a block diagram illustrates major hardware components of the encryption switch that execute the software architecture of . The encryption switch may be constructed as a standalone switch or as a blade in a larger data center switch chassis. If the encryption switch is a blade then the portion of enclosed in the dotted line may be sufficient while the additional components may be used for a standalone switch. The dashed line indicates a secure cryptographic module which performs encryption and decryption for the encryption switch . The cryptographic module preferably is protected from physical tampering by physical security techniques such as a hardened case and tampering detection hardware that interface with the security processor contained in the cryptographic module so that an attempt to tamper with the cryptographic module will cause the security processor to destroy encryption information contained in the cryptographic module including destruction of encryption key information used for communication with the key repository .

According to this embodiment a plurality of encryption FPGAs that perform the actual algorithms for encryption and decryption of data interact with a pair of Fibre Channel protocol ASICs for transmitting and receiving data from initiators and targets on the SAN . A control FPGA controls the operation of the encryption FPGAs and provides an interface to a blade processor and the security processor .

The blade processor provides processing capability for the switch operating system including software for interacting with the key repository such as the key archive client . The blade processor also controls Gigabit Ethernet ports and a smart card interface used for authentication purposes. In a standalone switch an additional control processor provides additional control functions for the encryption switch through a PCIe bridge and connections to the blade processor . The control processor and a USB controller provide further control for RS232 and 10 100 M Ethernet links .

As previously stated the embodiments described below may be implemented in other types of devices. For example illustrates an embodiment in which the techniques are implemented in a host bus adaptor HBA .

In addition to the host HBA and logical device illustrates the use of a key repository similar to the embodiment of . The key repository provides secure storage for encryption keys that may be used by the HBA to encrypt and decrypt data at rest on the logical device . The HBA communicates with the key repository via a communications link typically a local area network LAN .

In one embodiment the HBA provides encryption and decryption services using a keyID to locate and retrieve an encryption key record in the key repository from which an encryption key can be extracted for use in reading from or writing to the logical device .

According to various embodiments the encryption switch or the HBA may store the keyID value to use in the customer data of the logical device allocated on the target as described in more detail below. For clarity of the discussion only encryption switch embodiments are discussed below but the discussion applies to any other device embodying the techniques discussed.

Typically each vendor of a key repository provides a description of the key record and attributes or fields in the key record data structure can be used for arbitrary data provided by the encryption switch .

In one embodiment in order to preserve the keyID used for obtaining the encryption key from the key repository with the customer data stored on the logical device the keyID may be stored in the customer data written to the logical device . In a further embodiment depending on the customer data itself some of the customer data may be copied to the key repository replacing the customer data on the logical device with keyID information as described in more detail below.

Logical devices particularly ones used in a SAN are typically allocated as a collection of fixed size data blocks typically 512 bytes in size corresponding to physical device sectors of the same size. These are addressed with a data block number typically beginning at data block . Data blocks are illustrated in . In the area illustrated in data blocks hold data written to the logical device using write commands. Data block typically contains information regarding the attributes of the logical device such as the size or number of data blocks allocated to the logical device. Because the attribute data is frequently less than 512 bytes in length and is written to the beginning of the 512 byte data block the end portion of the data block is often filled out with a string of binary zeros.

In one embodiment software in the encryption switch may read data blocks of the logical device caching the data in memory coupled to a processor of the encryption switch . In other embodiments data block is also read and cached. When needing to store an encryption keyID in the logical device the encryption switch software may examine each of the 16 data blocks of customer data to determine whether the keyID can be stored in one of those data blocks. If the keyID cannot be stored in one of data blocks then in one embodiment a portion of data block may be used to store the keyID copying the previous contents of that portion of data block to a predetermined attribute of the key record in the key repository identified by the keyID.

In block the size of the compressed data is evaluated to determine if it is small enough to allow room for the keyID data in the 512 byte data block. In one embodiment the keyID data uses 32 bytes 16 bytes for the actual keyID 8 bytes for a signature data 4 reserved bytes and 4 bytes to store the length of the compressed user data. Thus in this embodiment compression of the user data must compress the user data by at least 32 bytes to allow insertion of the keyID data. Other embodiments may use other keyID data resulting in a different requirement for compression size reduction.

If the compression of customer data in data block allows room for insertion of the keyID then in block the keyID data is stored into data block and the data rewritten to the logical device . If the compression does not shrink the customer data sufficiently to leave room for the keyID data then the technique is repeated on data blocks sequentially as shown by block .

If in block none of the first 16 data blocks of the logical device is compressible sufficiently to store the keyID data then in block a portion of the data from data block is written to a predetermined attribute or field of the key record in the key repository identified by the keyID. In block the portion of data block copied to the key repository is overwritten by the keyID data.

From then on whenever the encryption switch needs to read or write encrypted data from or to the logical device the encryption switch may obtain the keyID from the customer data and use it to access the corresponding key record from the key repository .

Because future writes of customer data to data blocks may change the compressibility of the data e.g. changing it from non compressible image data to compressible text data the technique of may be repeated any time data is written to data blocks .

In block the compressed customer data is decompressed and the read operation itself is performed in block returning the decompressed customer data if that data block is the data block being read. The keyID extracted in block may then be used by the encryption switch to access the corresponding key record in the key repository for decrypting the data read from the logical device .

If the signature is not present in the data block then in block if the current data block is not data block the actions of blocks and are repeated for the next data block allowing finding the signature and keyID data in any of data blocks .

If the signature and thus the keyID data is not found in any of data blocks then in block data block of the logical device is read to obtain the keyID. The keyID is then used in block to access the corresponding key record from the key repository to get the actual customer data from data block that was overwritten by the keyID data replacing the keyID data in data block . Finally in block the actual real operation is performed which may use the keyID to obtain the key record from the key repository to allow decryption of the read data.

In another embodiment instead of copying data from data block to the key repository and overwriting the copied data with the keyID data data may be copied from and overwritten in one of data blocks or any other selected data block . In such an embodiment the actions of attempting to compress the data may be omitted eliminating computational costs for the compression at the cost of additional I O operations in situations where compression would have been able to provide space to store the keyID data after compression.

In the preceding description the use of blocks is illustrative and exemplary only. A different portion of the customer data area could be used or the size of the portion of the customer data area where compression is attempted may be larger or smaller than 16 blocks as desired.

By providing a place to store the keyID in the customer data either by compressing the customer data or by copying a portion of the customer data to the key repository record corresponding to a keyID then overwriting that portion of the customer data the keyID data may be kept with the customer data when the customer data is moved or copied to another logical or physical device without loss of the keyID data or requiring any bookkeeping in an external data store.

While certain exemplary embodiments have been described in details and shown in the accompanying drawings it is to be understood that such embodiments are merely illustrative of and not devised without departing from the basic scope thereof which is determined by the claims that follow.

