---

title: Homomorphic cryptography on numerical values in digital computing
abstract: Homomorphic cryptography on numerical values in digital computing is described, including converting a numerical value encoded in a bit string of a first size to another bit string of a second size, which is different from the first size; encrypting the numerical value in the another bit string to produce a ciphertext; and storing the ciphertext.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09094378&OS=09094378&RS=09094378
owner: Google Inc.
number: 09094378
owner_city: Mountain View
owner_country: US
publication_date: 20130816
---
The subject matter discussed herein relates generally to data processing and more particularly to mixing of secure and insecure operations at the server such that the server cannot determine secure data and cannot determine the query and further homomorphic cryptography on numerical values in digital computing as may applied on the query and query results at the client side.

In the related art a database database as service or cloud database operation may be performed. More specifically the database server may holds the data of the user e.g. user transport data and the user may perform an operation on the data e.g. a query . The user may have data which is sensitive which he or she does not want the server e.g. cloud owner to know.

However the user also may have much more data that he or she wants to load into the server. The user may want all of the data regardless of level of sensitivity to reside within the same database. Accordingly if the data resides together the operations at the server as well as at the client by the user needs to include secure data e.g. encrypted data operations. Both data transport and addition and deletion must handle both types e.g. secure and insecure and queries must be also performed over mixed data. In the related art a secure e.g. encrypted database may be provided in its entirety but not over mixed data and not as augmenting a given engine.

The related art approach may lose its security over time and there is thus a need to retain security and not reduce security as queries are performed.

Additionally homomorphic cryptography such as Paillier cryptography includes many properties. For example given two values V1 and V2 referred to as plaintexts E V1 C1 i.e. encrypting V1 resulting the ciphertext C1 and E V2 C2. One of the properties of homomorphic cryptography is that the product of two ciphertexts C1 and C2 will decrypt to the sum of their corresponding plaintexts V1 and V2.

However homomorphic cryptography and its properties cannot be used on many numerical values as currently represented in digital computing.

The subject matter includes methods for converting a numerical value encoded in a bit string of a first size to another bit string of a second size which is different from the first size encrypting the numerical value in the another bit string to produce a ciphertext and storing the ciphertext.

The methods may be implemented using one or more computing devices and or systems. The methods may be stored in computer readable media.

The subject matter described herein is taught by way of example implementations. Various details have been omitted for the sake of clarity and to avoid obscuring the subject matter. The examples below are directed to structures and functions for performing a query on mixed data based on a request from a client while not permitting the server to determine the actual values of the queries or the data provided by the user at the client.

According to an example implementation data may be stored at the server in encrypted form while supporting a subset of client query types that are typically supported by the server maintaining scalable performance and keeping the client data and the content of the queries hidden from the server. Further the examples shown below are directed to structures and functions for implementing homomorphic cryptography on numerical values in digital computing e.g. at the client side to encrypt the query of the user.

The client provides an output to the client side module CSM which performs a securing process on the received input. More specifically the CSM may receive a query from the client and may encrypt the query in such a manner that a server receiving the encrypted query cannot know the contents of the encrypted query. For example the server cannot decrypt the query as explained below.

It should be noted that the client is not limited to a single client unit but may include multiple clients e.g. a plurality of clients . The plurality of clients may be commonly coupled to a single CSM in a many to one relation or to respective CSMs in a many to many relationship.

A server side module SSM is the server that receives the query from the CSM in an encrypted form via the Internet . The SSM also contains data previously input from the client via the CSM . The data may include secure information as well as regular data imported to the SSM at an earlier time e.g. offline.

The encrypted query is further processed by a server query tool . The server query tool includes a query tool operator which provides functions required for the processing of the query as related to its encrypted status.

According to an aspect of the example implementations the SSM is augmented by the addition of a database engine e.g. the server query tool . The functionality of a security e.g. cryptographic component is provided at the CSM of the user at the user. Moreover minimal changes are required to the engine of the server e.g. crypto related functions in the query tool operator .

The CSM is configured to interface with existing databases and user facing databases and can be provided to a user as an add on such that the user e.g. enterprise can load all of their data into a cloud server e.g. SSM while keeping at least some of the data hidden from the cloud provider e.g. SSM . On the other hand the server continues to be able to perform a database operation e.g. select record where field value or a query e.g. sum of all salaries of workers where rank manager . Such server side operations may be performed while not sacrificing the security of the data items themselves so the server cannot determine anything more about the individual data items than could be determined based on the initial presentation of items as encrypted values via the CSM .

The CSM has two separate roles data import which is done offline and quite rarely and querying which is done interactively. The CSM modifies imported client data and client queries before sending them to the SSM . The CSM owns a key or a set of keys which will be unknown to the SSM running the database.

During data import the CSM encrypts the data and adds additional fields as required to support queries on the encrypted data this may be done offline i.e. before queries are provided to the server .

During queries the CSM modifies the query so that 1 the modified query can perform the desired functionality on the encrypted data and 2 the original query is hidden from the SSM . After receiving the answer from the SSM the CSM decrypts and post processes the answer before forwarding the answer to the client .

Optionally a user may implement their own version of the CSM based on specs provided by the SSM . Accordingly users may ensure that their data is encrypted before being imported and that the server query tool has no access to their plaintext data.

The SSM does not need to perform significant cryptographic tasks. It is not required to change data that is imported to the server query tool or received queries because these changes would be made by the CSM . The SSM might handle some metadata coordination. Alternatively the server query tool may commonly handle all data imported by the client regardless of whether it has been encrypted.

The query tool operator is used for implementing certain functionality in the server query tool and may include software modules functionalities that are called by the server query tool . For example the query tool operator may be used when a query requires that the server query tool change the query itself per each record of the database. Since queries are performed in parallel in many shards each shard may use its own copy of the query tool operator to modify the queries processed by it.

The encryption of values must be done in a different way per record by the client via the CSM . Otherwise the SSM can identify whether the same value is stored in different records since these records will all store the same ciphertext . Therefore in query time the SSM must change the query per record so that the modified query agrees with the encryption of that record. This process may require a single application of an encryption function or a hash function per record and should therefore be substantially efficient. After this modification the queries will be processed as regular server query tool queries.

When aggregating values of selected records to compute the result of the query e.g. the sum of the salary field of the selected records the function used for aggregation might be nonstandard. Such a function may be implemented by the query tool operator.

As shown in in a process associated with the data import at the client an initial import process is performed to secure the data. The data import process to the server query tool is performed before any queries are processed.

At the user provides initial data at the client. The initial data may for example be in a regular unencrypted form that is fully readable. The client imports its data to the CSM together with the following two types of instructions 

1. A list of fields and of substrings of these fields that can be used for SELECT operations e.g. SELECTable substrings .

2. A list of fields whose values can be used for aggregate answers e.g. enabling queries to request as answer the sum of a value of a field over the selected records .

1. In a simple form the client may define the SELECTable substrings of a specific field as a list of tuples i j where i

2. A more complex criteria might depend on the contents of the string. For example assume that the string is a url. The SELECTable substrings can be defined as all substrings which begin after the domain name and are bordered by two I characters.

Note that in this case the specification of the i j pairs defining the SELECTable substrings is not universal for the occurrences of the field in all records but rather depends on the contents of the field in each record. Namely each record might have a different set of i j pairs defining the SELECTable substrings of the occurrence of the field in that record. 

3. An even more complex criteria might depend on the values of other fields of the record. For example a client might define that the SELECTable substrings of the name field of a record will be defined in a way which depends on the value of the salary field of the record.

If the input criteria given by the client is not a simple list of i j tuples then the CSM processes each record based on the criteria computes the i j tuples which agree with the criteria and sets them as the SELECTable substrings of the field. Note again that the occurrences of the same field in different records might have different SELECTable substrings.

The structure of the entire system is such that the server will not learn the locations of the SELECTable substrings or their exact number. SELECT operations will be performed by providing a string X and a field name F. The system will select all records that contain X as one of the SELECTable substrings of the occurrence of the field F in them. This definition enables a large set of SELECT operations.

At the data may be secured at the CSM via cryptographic operation the user may specify the data to be secured and the data that is not secured. Techniques associated with the encryption of the data are discussed in greater detail below. Before importing the data to the SSM the CSM will first encrypt it using a suitable encryption schemes and generate tables which support the server executing SELECT operations on the SELECTable substrings.

Encryption Two types of fields include 1 fields whose values can be aggregated as part of an answer to a SELECT query and 2 all other fields. Fields of the first type will only be of numerical values. For example this could be a salary field if the client expects that it will issue queries whose answer is say the average salary of employees whose ages match a certain criteria.

Fields of the first type will be encrypted by the CSM using an encryption scheme which supports aggregation namely which enables to compute a function of the plaintext by computing a function on the ciphertexts. For example an additively homomorphic encryption scheme may include Paillier s encryption scheme or El Gamal encryption in the exponent. Using this type of functions supports the SUM and COUNT functions. Fields of the second type will be encrypted by the CSM using arbitrary encryption schemes which is secure but does not have to support aggregation of plaintext values .

For each field that can be used in a SELECT query the CSM constructs a table which enables to select the corresponding record by matching any of the SELECTable substrings. This table is generated in encrypted form which will not disclose the values and locations of the SELECTable substrings to the server or the SSM . The table will be stored as an additional field of the record. Namely the CSM will add to each record additional fields which contain encodings of the SELECTable substrings of fields which are searchable by SELECT queries.

At the secured data is then transported from the client to the server e.g. imported to the server where the data is stored in encrypted form. Optionally additional data may be transported from the client to the server or data previous imported to the server may be deleted. Some regular data may also be provided from the client to the server.

The modified database generated by the CSM will be transferred to the SSM . All fields of this database will be encrypted by the CSM and the plaintext will be unreadable by the SSM e.g. the server . When the SSM receives the database it stores it as any server query tool .

As shown in in a process associated with the query at the client may perform a query on the database that includes the foregoing imported mixed data at the server. More specifically to perform a query the client submits the query to the CSM .

At the initial processing of the query as provided by the user is performed at the client side to generate a secure query e.g. encryption . The processing of the query involves one or more cryptographic operations on the data the details of which are discussed further below with regard to for example.

At the secure query is provided to the server where operations e.g. quick manipulation are performed on the some of the data sets at the server including the secured data as well as regular data e.g. clear data .

At a query result is generated and provided to the client in the encrypted form. The processing of the encrypted query may include manipulation and matching of the encrypted data. For example the performing of the query on the encrypted data includes one of multiplication and manipulation of ciphertext. The encrypted data at the server as well as the encrypted query remains encrypted and the actual values of the data as provided by the client are not determined by the server.

The query that the server receives is a plain server query tool query with the following exception. When performing a SELECT . . . CONTAINS . . . query instead of searching for the same string in all records the string is modified per each record. This modification is done by the query tool operator and involves hashing or encrypting the string with a key parameter corresponding to each record.

If the query requests returning the entire selected records or certain fields of the selected records then the server returns them in encrypted form to the client side where the CSM decrypts these results and returns them to the client.

If the query requests returning aggregate values of certain fields of selected records then the server performs the corresponding aggregation function on these fields and returns the results to the client.

At the client then performs further processing e.g. interpretation of the query result e.g. decryption to provide the result to the user at the client as clear data information. The desired result is then provided to the user. Throughout the operations the cryptographic keys remain at the client and the server performs all operations without accessing the cryptographic keys of the client.

In the foregoing operations fast aggregation of data e.g. counting adding summing averaging of data is performed where the server performs data aggregation over encrypted rows of data resulting in an aggregated encrypted value e.g. ciphertext of aggregation . Further clients are provided with this result and can decrypt the result and obtain the actual cleartext aggregated result for the user which the server cannot determine. The criteria for which record in a row of data is to be processed is based on criteria that is a mix of cleartext data and cryptographically manipulated data.

Various types of select operations may be implemented having privacy properties and functions that can be applied to selected records. For example for an average of an encrypted field assuming that each record contains a zip code an encrypted customer count per zip code E CZ and a nonencrypted count of the population PZ in that zip code the result of the query may be an encryption of the total number of customers in selected zip codes but may also be an encryption of the mean percentage of customers in each zip code namely the average of E CZ PZ.

The query tool operator may support different privacy levels for select operations. For example in a public select query the client does not hide the select criteria. The client might be interested in hiding the result of the query. For example the client might request all sales records for customers having an address on 8Ave. but may not be interested in hiding from the server the address fields of records and that 8Ave. is the selection criterion of the query. Other fields of the records might be

Encrypted and therefore the server does not learn the contents of those fields. The result of the query may be that all encrypted records with an 8th Ave. address or some fields of these records as defined by the client are sent to the client.

Alternatively the client might be interested in the total amount of sales to businesses on 8th Ave. The client may want to hide sales numbers but may does not care about revealing to the server that the query is about records with a certain address. Thus the sales fields may be encrypted with an additively homomorphic encryption scheme as explained in greater detail below. The server may find the selected records add their encrypted sales fields and send the encrypted result to the client which can then decrypt it.

According to an example implementation a level of privacy can be provided by combining the foregoing approach with a use of pseudonyms. For example if the client replaces each address field with a pseudonym for the street name and optionally keeps all other records encrypted the client can perform previous queries by selecting the records with a street field equal to the pseudonym of 8th Ave. . This select operation can be performed as a standard select operation. This approach may reveal some information to the server. For example by observing the number of records having an address equal to the pseudonym of 8th Ave. the server may deduce that the records are all associated with an avenue rather than a small street.

In addition to the foregoing a private select criteria may be provided in which the selection criteria is kept secret from the server yet the identities of the selected records are revealed to the server. The server cannot determine the criterion e.g. the street name used for the selection and might not even learn which fields of the record are being used for the selection process. The server can learn the identities of the records which match the select criterion. For example the server may be asked to return the selected records to the client or to perform some aggregation of fields of these records.

According to the example implementation the server query tool can support the foregoing queries in a manner that the overhead of answering a query does not change substantially.

In addition according to a private select process the selection criterion as well as the identities of the records which match this criterion cannot be determined by the server. For example but not by way of limitation the client might query the server for the average salary of employees having a family name of Smith . The server will not know the selection criterion and will also not know which or even how many records match this criterion and further cannot determine any information about salaries.

Queries in which the selection criterion is public can be implemented by the server query tool including by use of queries where the selection is based on a field which is not encrypted or in which the plaintext is replaced with a pseudonym. The query tool operator may also support the selection of all records or of all records in which a certain field is nonNULL. Other commands which that may be implemented include but are not limited to SELECT field name FROM table name the SHOW TABLES DESCRIBE and DESCRIBE WHERE statements.

In addition the query tool operator can support private selection queries based on the following criterion a record is selected if the field specified in the query has a certain value as a substring. Further details are explained below. The server does not learn the selection criteria or the identities of the field whose value is used for the selection process e.g. that the select operation is done based on a prescribed field e.g. name field. .

The CONTAINS function can only be applied to string fields rather than to numerical fields . Thus the CONTAINS operation only matches with a subset of all possible substrings of the relevant field. This subset of all substrings is defined in advance by the client. For example the client may define a field containing a url that matches could be made to any substring of the url which begins and end with a .

With respect to numerical queries if the value of the field comes from a small range it may be replaced with a pseudonym and the selection is performed as explained above. Alternative methods may also be substituted therefor with departing from the scope of the inventive concept. The pseudonym may be different for every record to prevent the server from identifying records which have the same value. There are alternative methods for supporting queries of this type. For example if values comes from the range 1 n and a field has a value j replace the field with a field which includes the encodings of j j 1 . . . n to enable efficient searches for operations. This example process may require the expansion of fields by a factor of O n to support queries on a range of size n.

If the value comes from a range which is substantially larger a solution may be employed that is based on order preserving encryption. This approach may reveal to the server information about the order of ciphertexts.

According to an example implementation supported functions include but are not limited to returning either all selected records returning arbitrary fields of the selected records as defined by the client or returning aggregate functions of fields of the selected records a privacy preserving implementation for SUM and COUNT can be performed as well as MAX MIN NTH and TOP if the size of the domain of the relevant values is not large .

For example with respect to the SUM and COUNT queries it would be possible to compute the sum of the salary field of all records which match a certain criteria. Since the relevant fields are encrypted the aggregate function will have to be computed over the ciphertexts. This can be done by encrypting all salary fields using an additively homomorphic encryption scheme such as Paillier s encryption scheme. Encryption schemes of this type have the property that multiplying two ciphertexts which encrypt say the values A and B gives a ciphertext which encrypts the value A B. This operation can be done without knowledge of the private decryption key. The server can therefore multiply the ciphertexts of the salaries of the selected records.

The aggregation operation e.g. multiplying ciphertexts will most likely be implemented in the query tool operator which could either be called for each record that is processed or alternatively be called after all records are selected by the shard and then asked to multiply all of their ciphertexts. It is also possible to implement the aggregation at the SSM and compute it after obtaining all encrypted output fields of the selected records. However implementation at the query tool operator may have the advantage of utilizing the distributed power of all shards of the server query tool whereas an implementation in the SSM requires this single server to compute the aggregation of all selected fields. This may be plausible only if the number of selected records is relatively small.

For the TOP NTH ORDER BY MAX and MIN queries one solution is for the case where the domain size is small replaces that field with a field whose length is about 2032 bits per possible value of the original field. This solution is therefore reasonable if the size of the domain of the original field is not large. If the number selected records is small then the server can send the encrypted relevant fields to the client. The CSM can then decrypt these fields and compute the relevant query e.g. MAX TOP .

Supporting functions for which the server query tool computes approximations such as COUNT DISTINCT and QUANTILE depends on the approximation algorithm that is used. The LIMIT clause which limits the number of answers that are sent to the client can be implemented on the server side since its implementation does not require knowledge of the actual values of the results.

The SSM allows a json specification of table schema however it is extended to be able to specify which fields are encrypted and with what type of encryption. Hence another key value pair is added with key name encrypt as shown in which may have a vvalue of 

2. pseudonym specifies that the field is encrypted deterministically so a reencryption always results in the same ciphertext. Uses AES CBC encryption with a fixed IV . This is useful for both retrieving the encrypted field value as in SELECT Year Make from mydataset.cars WHERE Year 1996 . Make data pseudonym encrypted and stored on the servers. When retrieved the client displays the clear values for both Year and Make data. This is also useful for testing for equality using the encrypted value for example SELECT Year from mydataset.cars WHERE MAKE Jeep . Here since Make is deterministically encrypted it can be used to privately select records e.g. using equality .

3. probabilistic specifies that the field is encrypted probabilistically so that a reencryption creates a new ciphertext . Uses AES CBC encryption with a random IV. Thus this cannot be used in selecting rows.

4. searchwords specifies that the field allows for substring lookup even though the data is hidden from the servers. This is not an encryption mode in fact hashes are used to perform substring searches . The substring search is limited as follows only subsequences of words can be searched for where words are characters separated by a separator character. A maximum number of words is also specified.

First split string using separator into words and create all word sequences using all starting point and end points up to some maximum number of words.

Then create keyed hash of the utf8 encoding of each word sequence using HMAC then hash the keyed hash with a prepended IV and return space separated base64 encoded hashes also prepend the IV to the string of hashes.

5. probabilistic searchwords specifies that the field should be both probabilistically encrypted and also allow for substring lookup .

A load command example is ebq load master key filename key file1 mydataset.cars2 cars.csv cars.schema A master key filename pathname needs to be specified or else it will create a master key and store it in a default file. The key is needed to encrypt and key hash data.

A extended schema file cars.schema needs to be specified so that the load command will know which fields to encrypt and with what type of encryption.

Since the SSM does not understand extended schema it is converted to a standard schema by replacing field names by an extended field names pseudonym probabilistic and homomorphic encrypted fields are renamed to begin with prefixes PSEUDONYM  PROBABILISTIC and HOMOMORPHICrespectively. For searchwords a field is added with the prefix SEARCHWORDS  and for probabilistic searchwords both a field is added with prefix SEARCHWORDS  and the original field is renamed with a prefix PROBABILISTIC  . In all cases the encrypt key value pair entry is removed. An example of the converted schema is in . When a field is both renamed and added as in probabilistic searchwords it allows for distinguishing between the two fields.

The data is encrypted based on the algorithm specified and the hashes is added for encrypted search. The resulting ciphertext and hashes are byte values whereas the SSM does not yet have a established mechanism for uploading and retrieving byte strings hence for the time being all byte strings are base64 encoded before uploading.

The master key filename needs to be specified in order to know what key to use to decrypt returned data. Also the extended schema file needs to be supplied in order to know which fields are encrypted and with what type of encryption. The above query SELECT part is rewritten before sending to the server as follows and the content preceding is dropped SELECT since it is the same as below 

The Make is renamed which allows the client to detect returned data as something that requires decryption. A regexp may be used to detect and decrypt data but for robustness full parsing may also be used. The above query results in display of the clear values of Make even though they are stored encrypted on the server 

Second validating an rewriting the original schema ensures that the data file fits into the schema s definition. Then the data file is rewritten by encrypting all fields that the user defined. The names of a field might also be changed e.g. in the case of json data files as to match the rewritten schema.

Third loading of the rewritten data file using a rewritten scheme is performed. The original premise of rewriting both the schema and the data file was to make them become a proper schema and data file that can be loaded using the SSM load command. However the actual loading is done by the SSM .

At parsing of the query is performed by small hacks that make ease later aspects of in the process. A main premise of this operation is to read and parse the sql command such that the result expression can be manipulated and evaluated. Operation is described in further detail as follows 

The select clause consists of multiple expressions comma separated with possible aliasing for each expression. These complex math or string expressions cannot be sent directly to the SSM since they could contain encrypted fields whose ciphertext need to be decrypted to plaintext before any modifications or computations can occur. Each math expression may be converted to postfix. This provides a way to evaluate the expression in the future.

This structure is referred to as postfix stacks or stacks throughout the code. The alias will be stored in a dictionary d.

This clause is identical to the three above clauses except it only takes one number. Thus it is stored in the same structure 

These are somewhat different in that they include expressions that need to be parsed. Therefore the expressions are parsed into RPN but the same structure c is used.

After parsing is finished three structures are returned. The first two structures returned are postfix stacks list of postfix expressions for each comma separated expression and alias dictionary maps aliases to index of expressions in postfix stacks . Finally the last structure returned is a commands list which is a list of all structure c s which are built from all the clauses except SELECT and FLATTEN .

Here conversion of expressions to RPN is considered. This is very trivial for binary and unary operations. The harder part is incorporating builtin and aggregation functions to the new RPN. The actual hard part of this is that labels can have the same name as these functions. An example is that count can be a field or an aggregation function. To handle this built in functions are prepended with FUNCTION  and aggregation functions with AGGREGATION  .

Aggregation functions may be overloaded e.g. the same function can have different number of arguments . To address this situation their arguments are taken to concat together. Now all aggregation functions only have one argument.

At rewriting of structures from the parser is performed. First the structures all aliases are replaced with their full representative RPN expressions. This allows for creation of aliasing later on for benefit. Next using the given schema all encrypted field names are prepended with the correct respective prefix. Finally the aggregation functions are rewritten. Currently they are in the form of AGGREGATION i function . Here i represents the number of arguments of this function and function represents its name. Each argument precedes the this label in the stack. Here is also where checks e.g. complicated can be performed to ensure that aggregations can occur in the given expression. All aggregation functions may be rewritten as outline above where function is the name of the aggregation function i.e. GROUP COUNT becomes AGGREGATION i GROUP CONCAT . However exceptions may exist with COUNT and SUM as follows 

In the case of nondistinct field can be any field or alias regardless of encryption type. However the distinct case is more complicated. Only in PSEUDONYM encryption is it guaranteed that

c c . Therefore only on PSEUDONYM encryption or none can distinct count be done. Otherwise an error occurs.

GROUP CONCAT does not require any extra error checks. Any field alias or string is accepted and can be sent to the server. The only hazard is that the field alias must be of string type otherwise the result is a fail.

TOP has the same constraint as distinct count. The field is required to be PSEUDONYM encryption or not encrypted at all.

This requires a lot of manipulation and changes to the structure. The first restriction that is required is that any expression inside field is required to either be encrypted homomorphically either integer or float or not be encrypted either. If any other encryption is found an error will result.

For SUM the expression is separated into affines mx ny . . . z form. This requires that field be linear on homomorphically encrypted fields. However due to the complexity of the problem different requirements may be employed. For example it may be required that a homomorphically encrypted field is never multiplied or divided with any other field regardless of it being encrypted or unencrypted . If this occurs the program will error and terminate. Also functions are not accepted that that involve homomorphically encrypted fields i.e. SUM abs encrypted field . This case will also result in an error.

Once the expression is converted to a sum of affines where the variables are linear on homomorphically encrypted fields it is possible to convert this into an expression that can be queried by the SSM . Assume that there exists an PAILLIER SUM function which can do Paillier.

This can be converted to f1 SUM x1 f2 SUM x2 . . . fi SUM xi SUM c . If any of x1 . . . xi are homomorphically encrypted use PAILLIER SUM instead. This allows us to do SUM over linear homomorphically encrypted variable expressions.

AVG field is rewritten to SUM field SUM 1 . SUM 1 is equivalent to the number of rows considered in the query. Therefore it is equivalent to AVG field . SUM field is then rewritten based on the above conditions for SUM.

These functions do not have special checks that occur. The rewriting is as expected where i represents the number of arguments and function represents the name of aggregation function.

At all fields and aggregations of fields are extracted that need to be sent to the SSM . Since all the rewriting was done in the previous operation fields can be easily found for query. This is separated into two lists one list consists of aggregation queries and the second list consists of all fields that need to be queried.

At the query that needs to be sent to the SSM is constructed. For the FROM GROUP BY ORDER BY and LIMIT clauses list of arguments is combined with comma separation. The WHERE and HAVING clause require more attention. Both these clauses have expressions that are in RPN. So these need to be converted back to infix. During this infix transformation other transformations also need to occur including equality and contains. For equality if either field is encrypted with any type other PSEUDONYM this error cannot be handled. In the case that a field is encrypted by PSEUDONYM the other operand must be a literal or a PSEUDONYM field. If the field is a literal then the literal must also be encrypted to ciphertext before being sent.

For contains consider the expression A contains B. A must either unencrypted or be of SEARCHWORDS encryption. B must be a literal if the A is SEARCHWORD encrypted. B must be converted to ciphertext.

There is another small modification that needs to occur. The SSM converts all periods to underscores in the returned table. This is a problem with nested fields. To resolve this all periods are replaced with a long nonsense string  ebq period replacement  . This way it can later be replaced and lost periods can be tracked. The replaced strings are then sent as alias.

At operation the constructed query is provided to the SSM . The values are retrieved from the server and all the fields are then decrypted back to their plaintexts at the CSM .

At to generate a format for the table since all the fields have been provided in plaintext it is possible to replace the fields in the original RPN expressions with their actual plaintext values. Once this occurs it is possible to evaluate and output the table.

Homomorphic cryptography such as Paillier homomorphic includes properties that may be used for example by a service provider to clients while protecting the clients data privacy and or confidentiality. For example a client may encrypt data and store the encrypted data with or without unencrypted data with a service provider and or use services of the provider to manipulate the encrypted data without revealing the actual data to the service provider.

Taking advantage of the additive property for example a client may encrypt values V1 V2 . . . Vm plaintexts to produce C1 C2 . . . Cm ciphertext . The client then uploads C1 C2 . . . Cm and possibly other plaintexts and or ciphertexts to a service provider e.g. cloud storage . The service provider may provide services using C1 C2 . . . Cm without knowing V1 V2 . . . Vm i.e. without needing to decrypt C1 C2 . . . Cm to V1 V2 . . . Vm .

In digital computing values are represented in binary bit strings e.g. values encoded in strings of registers of 8 bits 16 bits 32 bits 64 bits other bit length etc. . The additive property of homomorphic cryptography such as Paillier homomorphic are useful only on positive values e.g. encoded as unsigned binary values in bit strings due to the homomorphic addition of ciphertexts i.e. product of C1 C2 . . . Cm modulo N which only results in an unsigned binary addition i.e. the sum of V1 V2 . . . Vm .

The subject matter herein describes example techniques that allow the application of homomorphic cryptography on numerical values that are positive negative or a combination thereof and the values may be integers and or floating numbers.

To enable the summation of two or more plaintexts e.g. in the form a product of the respective ciphertexts bit string is expanded into a longer bit string . The length of bit string also increases the protection of the value encoded in bit string in the encrypted form e.g. protecting the corresponding ciphertext from deciphering by hacking without the private key .

The length of bit string may be any length that is longer than the length of bit string i.e. bit string is at least one bit longer than bit string . The length may be chosen according to implementations and or requirements. The total length of bit string may be determined based on a desired cryptography security system performance and or other factors. For example 128 bit cryptography is easier to hack than cryptography with a longer bit length e.g. 256 bits 512 bits 1024 bits 2048 bits etc. . The longer the bit length the harder it is to hack and or the more computing power it takes to hack. However the longer the bit length the higher the demand or drain on system performance.

For illustration purposes bit string may be chosen to be 1024 bits in length. This length provides a balance of cryptography security and system performance with the current state of computing technologies. The length may be increased along with the advancement of computing technologies.

Bit string includes regions . Region holds bit string which may be any number of bits e.g. 64 bit as shown . To handle both positive and negative numbers using addition operations on both types a negative number is encoded using two s complement in region . Two s complement allows using the same addition operations to add positive and or negative numbers. Region may be implemented to allow summation of a number of values. For example to allow up to 2number of plaintexts being added region may be X number of bits in. For example to allow up to 2number of plaintexts being added bit string would have a 32 bit region . In some implementations the sign bit of bit string may be replicated in region e.g. X number of times .

Region would equal to the chosen total length minus the lengths of regions and . In this example region is of 958 bits in length. In some implementations the bit values in region are not significant and region may contain any bit values such as all zeros all ones or any combination thereof. All zeros are shown for example. In some implementations there may be other usages and or regions in place of or in addition to region the length of which is determined based on the total length and lengths of other regions.

An example implementation of homomorphic encryption of 1024 bit plaintexts would product 2048 bit ciphertexts. Paillier cryptography or cryptosystem is described as an example homomorphic cryptosystem which is not limited to Paillier cryptography or Paillier technique . Paillier cryptosystem is a well known probabilistic asymmetric algorithm for public key cryptography. The details of Paillier cryptography which are readily available and can be located on the Internet are omitted to avoid obscuring the subject matter.

For public key cryptography a public key is used to encrypt a plaintext into a ciphertext and a corresponding private key is required to decrypt the ciphertext. The public key is n g where n pq and as an example p and q may be chosen to be 512 bit prime numbers g can be any random integer e.g. g n 1 for simplicity . The private key used to decrypt a ciphertext into the corresponding plaintext is X where lease common multiple p 1 q 1 L g mod n mod n where L 1 n.

An example of encrypting a positive integer is illustrated using an integer 15. The value 15 is stored in bit string as all zeros in every bit except bits which store 1111 . The value in bit string may be referred to as plaintext. The plaintext is then converted to bit string which includes regions . Region and with a combined length of 96 in this example may be referred to as an extended plaintext. For a positive integer the sign bit is zero. Region holds in this example 32 copies of the sign bit e.g. 32 zeros . Region holds the same value as bit string . In combination the binary representation of the 96 bit extended plaintext is all zeros bits except the four least significant bits i.e. the four leftmost bits which is 1111 .

After a 64 bit positive plaintext is converted to a 96 bit extended plaintext bit string the entire length including region is encrypted using Paillier s encryption technique to produce a corresponding ciphertext. The ciphertext is twice as long e.g. 2048 bits as the length of bit string .

Encrypting a negative integer is performed the same way as encrypting a positive integer with the additional operation of converting the plaintext to a two s complement binary string before the plaintext is converted to an extended plaintext as described above or after the plaintext is converted to an extended plaintext convert the extended plaintext to a two s complement binary string before encrypting. An example formula for converting a number e.g. 15 to a two s complement representation is Abs 15 XOR all ones bit string of same length 1

For example Abs 15 000 . . . 0001111 a string of 96 bits or 64 bits with all zeros except bits being 1111 .

Using two s complement to represent the numbers e.g. V1 V2 . . . Vm allows the numbers to be added in their encrypted form e.g. C1 C2 . . . Cm by multiplying them together then modulo n referred to herein as Paillier summation using just addition operations. The numbers can be any combination of positive and negative numbers. Since positive numbers do not change in two s complement representation only the negative numbers need to be converted to two s complement represented numbers. After all the additions in their encrypted form e.g. C1 C2 . . . Cm Mod n Cproduct the resulting ciphertext Cproduct would be decrypted into Vsum i.e. Vsum V1 V2 . . . Vm . Then Vsum can be converted back from two s complement representation to signed bit representation of an extended plaintext which can be converted to a 64 bit representation of a positive or negative number with the most significant bit the 64bit being a sign bit.

Region is implemented to support Paillier summation of a number of values and the length depends on implementation. For example to support the summation of 2 32 i.e. to the power of 32 values the appropriate length is at least 32 bits. This length allows up to 2 32 additions e.g. Paillier summation to be performed i.e. Cproduct is the product of up to 2 32 ciphertexts mod n . Region allows the detection of overflow by for example treating the extended plaintexts underlying the corresponding ciphertexts as a 96 bit extended two s complement numbers including the 32 bits in region which would be all ones or all zeros based on the sign bit of the 64 bit plaintext. With the length of 32 bits in region up to 2 32 numbers positive or negative can be added before a carryover beyond the 96th bit which essentially means that there will be no carry overs as long as less than 2 32 Paillier additions occur.

After decryption overflow of the extended plaintext is detected if the sign bits i.e. bits to in region are neither all zeros nor all ones. In case the extended plaintext contains a positive number i.e. sign bits are all zeros the 96 bit positive number may be converted to a 64 bit number using the lower 63 bits with a 64bit being zero e.g. returning or copying the lower 63 bits in region with the 64 zero . In case the number is negative i.e. sign bits are all ones the 96 bit negative number may be converted to a negative 64 bit number e.g. returning or copying the lower 63 bits in region . The converted 64 bit number may be stored in a bit string such as bit string .

An example decryption algorithm is described below. For simplicity the least significant bit LSB is referred to as bit number one in the example. First a ciphertext which may be any one of C1 C2 . . . Cm or Cproduct is decrypted using the Paillier technique e.g. using the private key generated using Paillier cryptography . The decryption operation yields an extended plaintext e.g. a 1024 bit value with 96 LSB bits being used . Bits to may be referred to as valuebitsto e.g. a copy of bits of the extended plaintext and bits to signbitsto e.g. a copy of bits of the extended plaintext . If valuebitsto is neither all zeros nor all ones then an overflow is indicated and detected e.g. may raise an overflow error or exception in implementation . If signbitsto is all zeros valuebitsto is a positive integer. If signbitsto is all ones convert the 96 LSB bits of the extended plaintext to a two s complement representation e.g. positive96 bit value 96 LSB bits XOR 96 bits of all ones 1 . Take the 64 LSB of positive96 bit value multiply by negative one and return the result as a negative value which may be stored in bit string as a signed integer with the sign bit being 1 .

To enable Paillier summation of two or more floating numbers as plaintexts e.g. in the form a product of the respective ciphertexts bit string is expanded into a longer bit string . The length of bit string may be further increased to increase the protection of the value encoded in bit string in the encrypted form e.g. protecting the corresponding ciphertext from deciphering by hacking without the private key .

The length of bit string may be any length that is longer than the length of bit string i.e. bit string is at least one bit longer than bit string . The length may be chosen according to implementations and or requirements. The total length of bit string may be determined based on a desired cryptography security system performance and or other factors as described in the case of integer numbers.

For illustration purposes bit string may be chosen to be at least 1024 bits in length e.g. 1024 bits . This length provides a balance of cryptography security and system performance with the current state of computing technologies. The length may be increased along with the advancement of computing technologies. To enable Paillier summation to work with both positive and negative float values of different magnitudes the mantissa and exponent are represented using two s complement values.

For a 64 bit float value the maximum exponent value in the extended form is 389 bits of a 1024 bit plaintext due to the limitations of the IEEE 754 standard. If larger values are needed to accommodate application needs a larger plaintext e.g. 2048 bits may be implemented. For the example in bit string is illustrated with the length of 1024 bits which allows 389 bits maximum for representing the exponent. The subject matter is not limited to this 1024 bit example.

Bit string includes the most significant bit MSB being set to 0 for example to avoid any wraparound if the plaintext value becomes larger than p minus 1 p is one of two prime numbers used in Paillier encryption . Floating point representation includes NaN not a number inf positive infinity and inf negative infinity indications. In the example of bit string each of NaN inf and inf is implemented using a 32 bit length to accommodate up to 2 32 number of NaN inf and inf in each Paillier summation.

Region may be implemented as a NaN indicator. If the 64 bit float represents a NaN then a 1 is entered in this region which provides a positive value in the region for detecting the occurrence of a NaN. Regions and may be implemented as inf and inf respectively. Region may be implemented to indicate carryover from Paillier summation that does not result in a NaN inf or inf. The example length of 32 bits allows up to 2 32 number of float values being added. Region is a sign bit region that functions similar to region e.g. to detect overflow resulting from Paillier summation described above . Here an example length of 64 bits is illustrated. When a number is converted from bit string to bit string the sign bit of bit string is replicated in the 64 bits of region .

Region is 831 bits wide that holes two s complement representation of the 64 bit float value from bit string . The float value of bit string is expanded into 831 bits by taking a 53 bit mantissa i.e. a 52 bit mantissa prepended with an explicit 1 and shifting it based on the exponent value i.e. shifting to the right for a negative exponent and to the left for positive exponent . A region that is 831 bits wide can only store a float number with maximum 389 bit exponents i.e. 831 53 2 389 . The 831 bit extended float may be referred to as an extended plaintext value is represented using two s complement.

Regions are for example only. In some implementations these regions may be arranged differently and or with different sizes. In some implementations there may be other usages and or regions in place of or in addition to some of regions .

Examples of encrypting float numbers are illustrated using the values 15.0 and 15.0. The value 15.0 is represented by a 52 bit plaintext mantissa 111000 . . . 000 binary . The plaintext exponent undecoded is 10000000010 binary or 1026 in decimal. The decoded exponent is 1026 exponent bias of 1023 3. The sign bit is 0 for the positive 15.0 and is 1 for the 15.0. A float value is described by the formula 1 2 1.mantissa

Thus 1 2 1.111000 . . . 000 1111.000 . . . 0000 since in binary multiplying by 2is shifting the point to the right three times. For positive 15.0 the result is 1 1111.000 . . . 0000 1111.000 . . . 0000 in binary. Converting 1111.000 . . . 0000 to the 831 bit region is performed by ignoring the point after 1111 and fill the rest of the least significant bits with zeros i.e. 11110000000 . . . 00000 with the four most significant bits being ones and the rest of the bits being zeros . For a positive number in the extended representation the value in region does not need to be converted to two s complement representation and all 64 bits in region are all zeros.

For a negative number in the extended representation all 64 bits in region are all ones and the value in region is converted to two s complement representation. The resulting two s complement value in region shown in hexadecimal is 

0x7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff fe2000000000000000000000000000000000000000000000000000000000000000000000000000 00000000000000000000000000000000000L

In binary bit string in region is 111 . . . 111 383 bits of ones follows by 11100010 the binary of the hex characters e2 follows by 000 . . . 000 440 bits of zeros .

Encrypting and decrypting extended plaintexts that represent float values are the same as encrypting and decrypting integer values described above. After a ciphertext is decrypted. The underlying extended plaintext is determined to identify whether the plaintext value is an integer described in or float. If it is a float value the regions are examined to identify whether there is a NaN indicator a inf indicator a inf indicator or a carryover indicator. Of none the extended float value e.g. in regions and may be converted to the format of bit string . If one or more indicators in regions are detected appropriate actions depending on implementation may be taken e.g. raising one or more error statuses and or exceptions .

In some examples process may be implemented with different fewer or more blocks. Process may be implemented as computer executable instructions which can be stored on a medium loaded onto one or more processors of one or more computing devices and executed as a computer implemented method.

An example of one or more devices may be computing device described below in . Devices may include but are not limited to a computer e.g. a laptop computing device a mobile device e.g. smartphone or tablet a television a device associated with a vehicle a server computer computing devices storage devices and .

In some implementations devices may be considered user devices or client devices e.g. devices used by users or clients to perform encryption and or decryption of data . Devices may be devices associated with service providers e.g. used by service providers to provide services and or store data such as storing plaintexts and or ciphertexts on behave of one or more devices .

For example a client may encrypt some data to produce ciphertexts. The client may upload or send the ciphertexts with or without sending along other data for storage and or processing to one or more devices of a service provider. The service provider is able to provide services to the client without decrypting and revealing the client s encrypted data in plain view. For example the client may perform queries of the client s data in the form of ciphertext. The client may perform linear operations e.g. addition subtraction averaging summation etc. on the client s data in the form of ciphertext. The results which may include results in ciphertext are provided to the client which can be decrypted on the client s side in the privacy of the client s choosing.

Computing device can be communicatively coupled to input user interface and output device interface . Either one or both of input user interface and output device interface can be a wired or wireless interface and can be detachable. Input user interface may include any device component sensor or interface physical or virtual that can be used to provide input e.g. buttons touch screen interface keyboard a pointing cursor control microphone camera braille motion sensor optical reader and or the like . Output device interface may include a display television monitor printer speaker braille or the like. In some example implementations input user interface and output device interface can be embedded with or physically coupled to the computing device . In other example implementations other computing devices may function as or provide the functions of input user interface and output device interface for a computing device .

Examples of computing device may include but are not limited to highly mobile devices e.g. smartphones devices in vehicles and other machines devices carried by humans and animals and the like mobile devices e.g. tablets notebooks laptops personal computers portable televisions radios and the like and devices not designed for mobility e.g. desktop computers other computers information kiosks televisions with one or more processors embedded therein and or coupled thereto radios and the like .

Computing device can be communicatively coupled e.g. via I O interface to external storage and network for communicating with any number of networked components devices and systems including one or more computing devices of the same or different configuration. Computing device or any connected computing device can be functioning as providing services of or referred to as a server client thin server general machine special purpose machine or another label.

I O interface can include but is not limited to wired and or wireless interfaces using any communication or I O protocols or standards e.g. Ethernet 802.11x Universal System Bus WiMax modem a cellular network protocol and the like for communicating information to and or from at least all the connected components devices and network in computing environment . Network can be any network or combination of networks e.g. the Internet local area network wide area network a telephonic network a cellular network satellite network and the like .

Computing device can use and or communicate using computer usable or computer readable media including transitory media and non transitory media. Transitory media include transmission media e.g. metal cables fiber optics signals carrier waves and the like. Non transitory media include magnetic media e.g. disks and tapes optical media e.g. CD ROM digital video disks Blu ray disks solid state media e.g. RAM ROM flash memory solid state storage and other non volatile storage or memory.

Computing device can be used to implement techniques methods applications processes or computer executable instructions in some example computing environments. Computer executable instructions can be retrieved from transitory media and stored on and retrieved from non transitory media. The executable instructions can originate from one or more of any programming scripting and machine languages e.g. C C C Java Visual Basic Python Perl JavaScript and others .

Specific to processor s can execute under any operating system OS not shown in a native or virtual environment. One or more applications can be deployed that include logic unit application programming interface API unit input unit output unit conversion engine cryptographic engine 3rd party interface and inter unit communication mechanism for the different units to communicate with each other with the OS and with other applications not shown . For example conversion engine cryptographic engine and 3rd party interface may implement one or more processes described and or shown in . The described units and elements can be varied in design function configuration or implementation and are not limited to the descriptions provided.

In some example implementations when information or an execution instruction is received by API unit it may be communicated to one or more other units e.g. logic unit input unit output unit conversion engine cryptographic engine and 3rd party interface . For example data may be converted from some binary representations to other binary representation at conversion engine then encrypted at cryptographic engine . The encrypted data and or other data may be uploaded or sent to a third party service provider using 3rd party interface . Data which may include encrypted data may be received from a third party via 3rd party interface . Any encrypted data received can be decrypted at cryptographic engine . If needed the decrypted data may be converted from some binary representations to other binary representation at conversion engine .

In some instances logic unit may be configured to control the information flow among the units and direct the services provided by API unit input unit output unit conversion engine cryptographic engine and 3rd party interface in some example implementations described above. For example the flow of one or more processes or implementations may be controlled by logic unit alone or in conjunction with API unit .

Specific to processor s can execute under any operating system OS not shown in a native or virtual environment. One or more applications can be deployed that include logic unit application programming interface API unit input unit output unit server side module unit server query unit query tool operator unit and inter unit communication mechanism for the different units to communicate with each other with the OS and with other applications not shown . For example server side module unit server query unit and query tool operator unit may implement one or more processes described and or shown in . The described units and elements can be varied in design function configuration or implementation and are not limited to the descriptions provided.

In some example implementations when information or an execution instruction is received by API unit it may be communicated to one or more other units e.g. logic unit input unit output unit server side module unit server query unit and query tool operator unit . For example the encrypted query may be received via the internet at server side module unit and a query then may then be parsed rewritten and constructed by the server query unit . The functions associated with the encryption of the query may be provided by the query tool operator unit . Data which may include encrypted data may be the subject of the encrypted query at the server side module unit . The result is provided to the client from the server query unit without being decrypted.

In some instances logic unit may be configured to control the information flow among the units and direct the services provided by API unit input unit output unit server side module unit server query unit and query tool operator unit in some example implementations described above. For example the flow of one or more processes or implementations may be controlled by logic unit alone or in conjunction with API unit .

The example implementation may have various advantages or benefits. For example implementing the CSM can be performed independently of the operation of the server query tool and does not require knowledge of the server query tool architecture. Further the modifications that the CSM performs to queries may be rather minimal and can be computed efficiently. A time consuming operation at the CSM is data modification during data import but because this is an offline operation and is rather rare data modification during data import does not constitute an impediment to implementation of the CSM in an efficient manner or use of a multiserver architecture for running the CSM . The CSM is run on the client side not at the server infrastructure.

Aspects of the example implementation may have various benefits or advantages. For example but not by way of limitation the foregoing operations may be implemented by a database engine at the server and a cryptographic add on to the client to achieve security of client data from the server. Further the operations may focus on fast processing. Additionally a large set of queries may be covered by a server that can perform the above described operations for the client without learning the real values of the data items of the client.

As a result clients e.g. companies employing the services of the server may employ the service while hiding only their sensitive data e.g. 10 15 of the data and process all of the data efficiently e.g. 85 90 of the data is not encrypted and may be more quickly processed by cleartext processing moreover encrypted may be manipulated more quickly. It should be noted that the user interface to the data service may be similar for encrypted and nonencrypted data as changes in local processing are provided at the add on rather than the user interface.

In situations in which the systems discussed here collect personal information about users or may make use of personal information the users may be provided with an opportunity to control whether programs or features collect user information e.g. information about a user s social network social actions or activities profession a user s preferences or a user s current location or to control whether and or how to receive content from the content server that may be more relevant to the user. In addition certain data may be treated in one or more ways before it is stored or used so that personally identifiable information is removed. For example a user s identity may be treated so that no personally identifiable information can be determined for the user or a user s geographic location may be generalized where location information is obtained such as to a city ZIP code or state level so that a particular location of a user cannot be determined. Thus the user may have control over how information is collected about the user and used by a content server.

Although a few example implementations have been shown and described these example implementations are provided to convey the subject matter described herein to people who are familiar with this field. It should be understood that the subject matter described herein may be implemented in various forms without being limited to the described example implementations. The subject matter described herein can be practiced without those specifically defined or described matters or with other or different elements or matters not described. It will be appreciated by those familiar with this field that changes may be made in these example implementations without departing from the subject matter described herein as defined in the appended claims and their equivalents.

