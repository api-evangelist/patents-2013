---

title: Database cache survivability across database failures
abstract: A database system may implement database cache survivability across database failures. In various embodiments, a database cache may be maintained independent of a failure of a database. A database cache may be maintained in a non-volatile memory device or maintained in a shared memory segment of system memory. Upon recovery from a database failure, a recovery point may be determined that indicates a consistent state of the database. Cache entries of the database cache inconsistent with the consistent state of the database may be invalidated, and the database cache may be made available for access requests directed toward the database. Valid cache entries from before the database failure may be made available without accessing a back-end data store for the database.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09251003&OS=09251003&RS=09251003
owner: Amazon Technologies, Inc.
number: 09251003
owner_city: Reno
owner_country: US
publication_date: 20130814
---
As increasing amounts of data are stored and maintained for a variety of different purposes optimizing the performance of access requests and other operations performed by database systems with regard to stored data is becoming increasingly important when handling larger amounts of data and greater numbers of access requests. Typically database systems have implemented database caches that are efficient to access and or modify. However in order to maintain their efficiency database caches are generally implemented in a ways that leaves data maintained in the database cache vulnerable to loss to due to system or process failure. Upon losing data maintained in a database cache the burden on database systems to respond to access requests as well as perform other management operations increases dramatically.

While embodiments are described herein by way of example for several embodiments and illustrative drawings those skilled in the art will recognize that the embodiments are not limited to the embodiments or drawings described. It should be understood that the drawings and detailed description thereto are not intended to limit embodiments to the particular form disclosed but on the contrary the intention is to cover all modifications equivalents and alternatives falling within the spirit and scope as defined by the appended claims. The headings used herein are for organizational purposes only and are not meant to be used to limit the scope of the description or the claims. As used throughout this application the word may is used in a permissive sense i.e. meaning having the potential to rather than the mandatory sense i.e. meaning must . The words include including and includes indicate open ended relationships and therefore mean including but not limited to. Similarly the words have having and has also indicate open ended relationships and thus mean having but not limited to. The terms first second third and so forth as used herein are used as labels for nouns that they precede and do not imply any type of ordering e.g. spatial temporal logical etc. unless such an ordering is otherwise explicitly indicated.

Various components may be described as configured to perform a task or tasks. In such contexts configured to is a broad recitation generally meaning having structure that performs the task or tasks during operation. As such the component can be configured to perform the task even when the component is not currently performing that task e.g. a computer system may be configured to perform operations even when the operations are not currently being performed . In some contexts configured to may be a broad recitation of structure generally meaning having circuitry that performs the task or tasks during operation. As such the component can be configured to perform the task even when the component is not currently on. In general the circuitry that forms the structure corresponding to configured to may include hardware circuits.

Various components may be described as performing a task or tasks for convenience in the description. Such descriptions should be interpreted as including the phrase configured to. Reciting a component that is configured to perform one or more tasks is expressly intended not to invoke 35 U.S.C. 112 paragraph six interpretation for that component.

 Based On. As used herein this term is used to describe one or more factors that affect a determination. This term does not foreclose additional factors that may affect a determination. That is a determination may be solely based on those factors or based at least in part on those factors. Consider the phrase determine A based on B. While B may be a factor that affects the determination of A such a phrase does not foreclose the determination of A from also being based on C. In other instances A may be determined based solely on B.

The scope of the present disclosure includes any feature or combination of features disclosed herein either explicitly or implicitly or any generalization thereof whether or not it mitigates any or all of the problems addressed herein. Accordingly new claims may be formulated during prosecution of this application or an application claiming priority thereto to any such combination of features. In particular with reference to the appended claims features from dependent claims may be combined with those of the independent claims and features from respective independent claims may be combined in any appropriate manner and not merely in the specific combinations enumerated in the appended claims.

Various embodiments of database cache survivability across database failures are disclosed herein. As part of optimizing the performance of access operations of a database system such as read and write operations database systems may implement a database cache. A database cache may generally be a copy or version of data stored for a database system that may be more efficiently accessed by a database system to process access requests instead of accessing the data in persistent database storage which may be less efficient e.g. slower . When an access request is received a database system may first evaluate a database cache to determine if the requested data associated with the access request is also stored in the database cache. If yes often termed a cache hit then the access request may be processed utilizing the data maintained in the database cache without accessing data stored in persistent database storage for the database system. If not often termed a cache miss persistent database storage may be accessed to process the access request. Often times the data accessed in persistent database storage may then be copied to the database cache to process future access requests. Over time copying data accessed for cache misses to the database cache allows the database cache to become warm.

A warm database cache maintains data that may be frequently used to process access requests saving time and resources for the database system as data need not be obtained from persistent database storage. Typically a database cache is implemented in volatile memory such as various types of system memory wherein upon the occurrence of a database failure e.g. power failure or process failure data maintained in the database cache may not survive losing in effect the frequently accessed data used to process access requests. Upon recovery the database system may process access requests with few to none database cache hits which may slow the processing of access requests as the cache may no longer maintain the frequently accessed data requests also referred to as the database cache being cold .

A database failure is illustrated at . Database engine may for instance be a process performed on a computing device that may have become halted or frozen such as due to some form of deadlock among threads and may need to be restarted. Alternatively a larger system failure such as a power failure or other type of failure of the computing device implementing database may also occur. However database failure occurs the database cache is no longer warm having lost the frequently accessed data of the database as a result of database failure becoming a cold database cache . As illustrated at upon recovery from the database failure database may once again receive access requests . Cold database cache may be available for reads writes from database engine however many cache misses may occur requiring access of database storage in order to restore cache entries to the cold database cache . This warming process of restoring a cold database cache to a warm state may hinder access request processing. Moreover it may be difficult to determine when cold database cache is no longer cold but has returned to a warm state.

In various embodiments a database may implement database cache survivability across database failures. is a series of block diagrams illustrating database cache survivability across database failures according to some embodiments. Database may receive one or more access requests for processing. Similar to database illustrated in database may also implement a database engine database engine which may process access requests among other functions. As part of processing access requests database engine may perform various cache reads writes for cache hits with regard to warm database cache . For cache misses database storage typically one or more persistent storage devices may be accessed to process the access requests . Database engine may also perform various other actions or functions some of which may involve other memory operations upon database engine allocated memory . Database engine allocated memory may in various embodiments be a portion of system memory specifically allocated to database engine for performing various functions.

Independent from database engine allocated memory database may also implement warm database cache . As noted above warm database cache may maintain frequently accessed data for database . In some embodiments warm database cache may be implemented as a shared segment of system memory. A shared segment of system memory may be a portion of system memory that is maintained independent of processes that may have access to the shared segment. In the event of a failure of one or more of the processes that access the shared memory segment the data maintained by the shared memory segment may still be available. For example in various embodiments database engine may be a process that accesses both its own specifically allocated memory database engine allocated memory and warm database cache . As illustrated at a database failure may occur that causes the process of the database engine to fail. Database engine allocated memory may also fail as it is specifically allocated to database engine and is maintained so long as database engine is functioning. However warm database cache may still survive database failure as it is implemented in a shared memory segment which may be maintained independent from database engine .

In another example warm database cache may be implemented on a non volatile memory device which may preserve data irrespective of system or other failure of database such as a power failure that causes the loss of all data maintained in non volatile storage. A non volatile memory device may be one of many different types of memory which may implement the same similar or near system memory like performance characteristics for access operations. Examples may include but are not limited to Non Volatile Random Access Memory NV RAM or some other form of battery backed memory device which may implement flash based storage to maintain data stored in system memory in the event of a system failure as well as various post nand flash technologies such as ferroelectric random access memory Ferroelectric RAM magnetoresistive random access memory MRAM resistive random access memory Resistive RAM and or phase change random access memory PC RAM . Please note that the terms similar or near system memory performance are not intended to be limiting to any specific set of characteristics or attributes. As the performance characteristics of system memory may vary widely so too may the characteristics or attributes of memory relative to typical system memory devices such as dynamic random access memory DRAM or static random access memory SRAM in addition to countless varieties of these and other random access memory technologies including but not limited to dual in line memory module DIMM synchronous dynamic random access memory SDRAM double data rate synchronous random access memory DDR SDRAM . As a result of implementing warm database cache on a non volatile memory device such as the examples given above warm database cache may survive database failure .

As illustrated at database may recover from database failure . Upon recovery from database failure database engine may determine a recovery point for the database cache. In various embodiments a recovery point may be or determined based on a consistent state of the database prior to database failure . Once a recovery point is identified For instance database may have started processing such as by updating entries of warm database cache prior to database failure but not yet committed i.e. made durable some access requests or operations transactions resulting from access requests . Uncommitted access requests transactions or other database operations may not be consistent with the data stored at database storage . In order to prevent inconsistent and possibly erroneous versions of the entries in warm database cache from being used to process access requests inconsistent cache entries may be invalidated e.g. marked as invalid removed etc. from warm database cache . In at least some embodiments cache entries may be invalidated lazily such as when an access request for a specific cache entry is received.

In some embodiments database storage implemented as distributed storage service described in below may maintain a consistent state of the database. A request to database storage for example may in some embodiments return an identifier such as log sequence number that indicates a consistent state of the database. In some embodiments a consistent state of the database may be determined by scanning one or more log records indicating updates made to data of which the cache entries maintain versions or copies of in order to locate a consistency point e.g. a particular log sequence number LSN of the database. However a consistent state is determined it may be used as part of identifying and or determining the recovery point.

As illustrated at warm database cache is once again available for database engine to access when processing access requests. Valid cache entries from before the database failure may be retained in some embodiments. Note that in various embodiments these valid cache entries may be made available for servicing access requests without accessing a back end data stored such as database storage . Thus recovery from database failure may be performed without accessing or receiving data from database storage as valid data may still be maintained in the warm database cache . In other embodiments warm database cache may maintain identifiers of data for cache entries such as the particular data pages or blocks maintained in database storage that are also stored in a database cache in system memory such as in database engine allocated memory . Although not illustrated upon recovery database engine may access these identifiers in warm database cache restore copies of the data such as the data pages from database storage to the cache in database engine allocated memory . Thus the cache in database engine allocated memory may be warm for processing access requests without waiting to warm the cache over time when processing cache misses.

Although various embodiments of database cache survivability across database failures may be implemented in many different database systems the specification first describes an example network based database service configured to implement database cache survivability across database failures. Included in the description of the example network based database service are various aspects of the example network based database service such as a database engine and a separate distributed database storage service. The specification then describes a flowchart of various embodiments of methods for database cache survivability across database failures. Next the specification describes an example system that may implement the disclosed techniques. Various examples are provided throughout the specification.

The systems described herein may in some embodiments implement a network based service that enables clients e.g. subscribers to operate a data storage system in a cloud computing environment. In some embodiments the data storage system may be an enterprise class database system that is highly scalable and extensible. In some embodiments queries may be directed to database storage that is distributed across multiple physical resources and the database system may be scaled up or down on an as needed basis. The database system may work effectively with database schemas of various types and or organizations in different embodiments. In some embodiments clients subscribers may submit queries in a number of ways e.g. interactively via an SQL interface to the database system. In other embodiments external applications and programs may submit queries using Open Database Connectivity ODBC and or Java Database Connectivity JDBC driver interfaces to the database system.

More specifically the systems described herein may in some embodiments implement a service oriented database architecture in which various functional components of a single database system are intrinsically distributed. For example rather than lashing together multiple complete and monolithic database instances each of which may include extraneous functionality such as an application server search functionality or other functionality beyond that required to provide the core functions of a database these systems may organize the basic operations of a database e.g. query processing transaction management caching and storage into tiers that may be individually and independently scalable. For example in some embodiments each database instance in the systems described herein may include a database tier which may include a single database engine head node and a client side storage system driver and a separate distributed storage system which may include multiple storage nodes that collectively perform some of the operations traditionally performed in the database tier of existing systems .

As described in more detail herein in some embodiments some of the lowest level operations of a database e.g. backup restore snapshot recovery log record manipulation and or various space management operations may be offloaded from the database engine to the storage layer and distributed across multiple nodes and storage devices. For example in some embodiments rather than the database engine applying changes to a database or data pages thereof and then sending the modified data pages to the storage layer the application of changes to the stored database and data pages thereof may be the responsibility of the storage layer itself. In such embodiments redo log records rather than modified data pages may be sent to the storage layer after which redo processing e.g. the application of the redo log records may be performed somewhat lazily and in a distributed manner e.g. by a background process . In some embodiments crash recovery e.g. the rebuilding of data pages from stored redo log records may also be performed by the storage layer and may also be performed by a distributed and in some cases lazy background process.

In some embodiments because only redo logs and not modified data pages are sent to the storage layer there may be much less network traffic between the database tier and the storage layer than in existing database systems. In some embodiments each redo log may be on the order of one tenth the size of the corresponding data page for which it specifies a change. Note that requests sent from the database tier and the distributed storage system may be asynchronous and that multiple such requests may be in flight at a time.

In general after being given a piece of data a primary requirement of a database is that it can eventually give that piece of data back. To do this the database may include several different components or tiers each of which performs a different function. For example a traditional database may be thought of as having three tiers a first tier for performing query parsing optimization and execution a second tier for providing transactionality recovery and durability and a third tier that provides storage either on locally attached disks or on network attached storage. As noted above previous attempts to scale a traditional database have typically involved replicating all three tiers of the database and distributing those replicated database instances across multiple machines.

In some embodiments the systems described herein may partition functionality of a database system differently than in a traditional database and may distribute only a subset of the functional components rather than a complete database instance across multiple machines in order to implement scaling. For example in some embodiments a client facing tier may be configured to receive a request specifying what data is to be stored or retrieved but not how to store or retrieve the data. This tier may perform request parsing and or optimization e.g. SQL parsing and optimization while another tier may be responsible for query execution. In some embodiments a third tier may be responsible for providing transactionality and consistency of results. For example this tier may be configured to enforce some of the so called ACID properties in particular the Atomicity of transactions that target the database maintaining Consistency within the database and ensuring Isolation between the transactions that target the database. In some embodiments a fourth tier may then be responsible for providing Durability of the stored data in the presence of various sorts of faults. For example this tier may be responsible for change logging recovery from a database crash managing access to the underlying storage volumes and or space management in the underlying storage volumes.

In some embodiments the database systems described herein may retain functions such as query parsing and optimization query execution and transactionality and consistency but may redistribute responsibility for at least portions of the backup restore snapshot recovery and or various space management operations to a storage tier. Redistributing functionality in this manner and tightly coupling log processing between the database tier and the storage tier may improve performance increase availability and reduce costs when compared to previous approaches to providing a scalable database. For example network and input output bandwidth requirements may be reduced since only redo log records which are much smaller in size than the actual data pages may be shipped across nodes or persisted within the latency path of write operations. In addition the generation of data pages can be done independently in the background on each storage node as foreground processing allows without blocking incoming write operations. In some embodiments the use of log structured non overwrite storage may allow backup restore snapshots point in time recovery and volume growth operations to be performed more efficiently e.g. by using metadata manipulation rather than movement or copying of a data page. In some embodiments the storage layer may also assume the responsibility for the replication of data stored on behalf of clients and or metadata associated with that data such as redo log records across multiple storage nodes. For example data and or metadata may be replicated locally e.g. within a single availability zone in which a collection of storage nodes executes on its own physically distinct independent infrastructure and or across availability zones in a single region or in different regions.

In various embodiments the database systems described herein may support a standard or custom application programming interface API for a variety of database operations. For example the API may support operations for creating a database creating a table altering a table creating a user dropping a user inserting one or more rows in a table copying values selecting data from within a table e.g. querying a table canceling or aborting a query creating a snapshot and or other operations.

In some embodiments the database tier of a database instance may include a database engine head node server that receives read and or write requests from various client programs e.g. applications and or subscribers users then parses them and develops an execution plan to carry out the associated database operation s . For example the database engine head node may develop the series of steps necessary to obtain results for complex queries and joins. In some embodiments the database engine head node may manage communications between the database tier of the database system and clients subscribers as well as communications between the database tier and a separate distributed database optimized storage system.

In some embodiments the database engine head node may be responsible for receiving SQL requests from end clients through a JDBC or ODBC interface and for performing SQL processing and transaction management which may include locking locally. However rather than generating data pages locally the database engine head node or various components thereof may generate redo log records and may ship them to the appropriate nodes of a separate distributed storage system. In some embodiments a client side driver for the distributed storage system may be hosted on the database engine head node and may be responsible for routing redo log records to the storage system node or nodes that store the segments or data pages thereof to which those redo log records are directed.

In some embodiments the database tier or more specifically the database engine head node may include a cache in which recently accessed data pages are held temporarily such as warm cache described above with regard to . In such embodiments if a write request is received that targets a data page held in such a cache in addition to shipping a corresponding redo log record to the storage layer the database engine may apply the change to the copy of the data page held in its cache. However unlike in other database systems a data page held in this cache may not ever be flushed to the storage layer and it may be discarded at any time e.g. at any time after the redo log record for a write request that was most recently applied to the cached copy has been sent to the storage layer and acknowledged . The cache may implement any of various locking mechanisms to control access to the cache by at most one writer or multiple readers at a time in different embodiments. Note however that in embodiments that include such a cache the cache may not be distributed across multiple nodes but may exist only on the database engine head node for a given database instance. Therefore there may be no cache coherency or consistency issues to manage.

In some embodiments the database tier may support the use of synchronous or asynchronous read replicas in the system e.g. read only copies of data on different nodes of the database tier to which read requests can be routed. In such embodiments if the database engine head node for a given database receives a read request directed to a particular data page it may route the request to any one or a particular one of these read only copies. In some embodiments the client side driver in the database engine head node may be configured to notify these other nodes about updates and or invalidations to cached data pages e.g. in order to prompt them to invalidate their caches after which they may request updated copies of updated data pages from the storage layer .

In some embodiments the client side driver running on the database engine head node may expose a private interface to the storage tier. In some embodiments it may also expose a traditional iSCSI interface to one or more other components e.g. other database engines or virtual computing services components . In some embodiments storage for a database instance in the storage tier may be modeled as a single volume that can grow in size without limits and that can have an unlimited number of IOPS associated with it. When a volume is created it may be created with a specific size with a specific availability durability characteristic e.g. specifying how it is replicated and or with an IOPS rate associated with it e.g. both peak and sustained . For example in some embodiments a variety of different durability models may be supported and users subscribers may be able to specify for their database a number of replication copies zones or regions and or whether replication is synchronous or asynchronous based upon their durability performance and cost objectives.

In some embodiments the client side driver may maintain metadata about the volume and may directly send asynchronous requests to each of the storage nodes necessary to fulfill read requests and write requests without requiring additional hops between storage nodes. For example in some embodiments in response to a request to make a change to a database the client side driver may be configured to determine the one or more nodes that are implementing the storage for the targeted data page and to route the redo log record s specifying that change to those storage nodes. The storage nodes may then be responsible for applying the change specified in the redo log record to the targeted data page at some point in the future. As writes are acknowledged back to the client side driver the client side driver may advance the point at which the volume is durable and may acknowledge commits back to the database tier. As previously noted in some embodiments the client side driver may not ever send data pages to the storage node servers. This may not only reduce network traffic but may also remove the need for the checkpoint or background writer threads that constrain foreground processing throughput in previous database systems.

In some embodiments many read requests may be served by the database engine head node cache. However write requests may require durability since large scale failure events may be too common to allow only in memory replication. Therefore the systems described herein may be configured to minimize the cost of the redo log record write operations that are in the foreground latency path by implementing data storage in the storage tier as two regions a small append only log structured region into which redo log records are written when they are received from the database tier and a larger region in which log records are coalesced together to create new versions of data pages in the background. In some embodiments an in memory structure may be maintained for each data page that points to the last redo log record for that page backward chaining log records until an instantiated data block is referenced. This approach may provide good performance for mixed read write workloads including in applications in which reads are largely cached.

In some embodiments because accesses to the log structured data storage for the redo log records may consist of a series of sequential input output operations rather than random input output operations the changes being made may be tightly packed together. It should also be noted that in contrast to existing systems in which each change to a data page results in two input output operations to persistent data storage one for the redo log and one for the modified data page itself in some embodiments the systems described herein may avoid this write amplification by coalescing data pages at the storage nodes of the distributed storage system based on receipt of the redo log records.

One embodiment of a service system architecture that may be configured to implement a network based database service is illustrated in . In the illustrated embodiment a number of clients shown as database clients may be configured to interact with a network based services platform via a network . Network based platform may be configured to interface with one or more instances of a database service a distributed database optimized storage service and or one or more other virtual computing services . It is noted that where one or more instances of a given component may exist reference to that component herein may be made in either the singular or the plural. However usage of either form is not intended to preclude the other.

In various embodiments the components illustrated in may be implemented directly within computer hardware as instructions directly or indirectly executable by computer hardware e.g. a microprocessor or computer system or using a combination of these techniques. For example the components of may be implemented by a system that includes a number of computing nodes or simply nodes each of which may be similar to the computer system embodiment illustrated in and described below. In various embodiments the functionality of a given service system component e.g. a component of the database service or a component of the storage service may be implemented by a particular node or may be distributed across several nodes. In some embodiments a given node may implement the functionality of more than one service system component e.g. more than one database service system component .

Generally speaking clients may encompass any type of client configurable to submit web services requests to network based services platform via network including requests for database services e.g. access requests a request to generate a snapshot etc. . For example a given client may include a suitable version of a web browser or may include a plug in module or other type of code module configured to execute as an extension to or within an execution environment provided by a web browser. Alternatively a client e.g. a database service client may encompass an application such as a database application or user interface thereof a media application an office application or any other application that may make use of persistent storage resources to store and or access one or more databases. In some embodiments such an application may include sufficient protocol support e.g. for a suitable version of Hypertext Transfer Protocol HTTP for generating and processing network based services requests without necessarily implementing full browser support for all types of web based data. That is client may be an application configured to interact directly with web services platform . In some embodiments client may be configured to generate web services requests according to a Representational State Transfer REST style web services architecture a document or message based web services architecture or another suitable network based services architecture.

In some embodiments a client e.g. a database service client may be configured to provide access to web services based storage of databases to other applications in a manner that is transparent to those applications. For example client may be configured to integrate with an operating system or file system to provide storage in accordance with a suitable variant of the storage models described herein. However the operating system or file system may present a different storage interface to applications such as a conventional file system hierarchy of files directories and or folders. In such an embodiment applications may not need to be modified to make use of the storage system service model. Instead the details of interfacing to network based services platform may be coordinated by client and the operating system or file system on behalf of applications executing within the operating system environment.

Clients may convey network based services requests e.g. a snapshot request parameters of a snapshot request read request restore a snapshot etc. to and receive responses from network based services platform via network . In various embodiments network may encompass any suitable combination of networking hardware and protocols necessary to establish network based communications between clients and platform . For example network may generally encompass the various telecommunications networks and service providers that collectively implement the Internet. Network may also include private networks such as local area networks LANs or wide area networks WANs as well as public or private wireless networks. For example both a given client and network based services platform may be respectively provisioned within enterprises having their own internal networks. In such an embodiment network may include the hardware e.g. modems routers switches load balancers proxy servers etc. and software e.g. protocol stacks accounting software firewall security software etc. necessary to establish a networking link between given client and the Internet as well as between the Internet and web services platform . It is noted that in some embodiments clients may communicate with network based services platform using a private network rather than the public Internet. For example clients may be provisioned within the same enterprise as a database service system e.g. a system that implements database service and or distributed database optimized storage service . In such a case clients may communicate with platform entirely through a private network e.g. a LAN or WAN that may use Internet based communication protocols but which is not publicly accessible .

Generally speaking network based services platform may be configured to implement one or more service endpoints configured to receive and process network based services requests such as requests to access data pages or records thereof . For example network based services platform may include hardware and or software configured to implement a particular endpoint such that an HTTP based network based services request directed to that endpoint is properly received and processed. In one embodiment network based services platform may be implemented as a server system configured to receive network based services requests from clients and to forward them to components of a system that implements database service distributed database optimized storage service and or another virtual computing service for processing. In other embodiments network based services platform may be configured as a number of distinct systems e.g. in a cluster topology implementing load balancing and other request management features configured to dynamically manage large scale network based services request processing loads. In various embodiments web services platform may be configured to support REST style or document based e.g. SOAP based types of network based services requests.

In addition to functioning as an addressable endpoint for clients network based services requests in some embodiments network based services platform may implement various client management features. For example platform may coordinate the metering and accounting of client usage of network based services including storage resources such as by tracking the identities of requesting clients the number and or frequency of client requests the size of data tables or records thereof stored or retrieved on behalf of clients overall storage bandwidth used by clients class of storage requested by clients or any other measurable client usage parameter. Platform may also implement financial accounting and billing systems or may maintain a database of usage data that may be queried and processed by external systems for reporting and billing of client usage activity. In certain embodiments platform may be configured to collect monitor and or aggregate a variety of storage service system operational metrics such as metrics reflecting the rates and types of requests received from clients bandwidth utilized by such requests system processing latency for such requests system component utilization e.g. network bandwidth and or storage utilization within the storage service system rates and types of errors resulting from requests characteristics of stored and requested data pages or records thereof e.g. size data type etc. or any other suitable metrics. In some embodiments such metrics may be used by system administrators to tune and maintain system components while in other embodiments such metrics or relevant portions of such metrics may be exposed to clients to enable such clients to monitor their usage of database service distributed database optimized storage service and or another virtual computing service or the underlying systems that implement those services .

In some embodiments platform may also implement user authentication and access control procedures. For example for a given network based services request to access a particular database platform may be configured to ascertain whether the client associated with the request is authorized to access the particular database. Platform may determine such authorization by for example evaluating an identity password or other credential against credentials associated with the particular database or evaluating the requested access to the particular database against an access control list for the particular database. For example if a client does not have sufficient credentials to access the particular database platform may reject the corresponding network based services request for example by returning a response to the requesting client indicating an error condition. Various access control policies may be stored as records or lists of access control information by database service distributed database optimized storage service and or other virtual computing services .

It is noted that while network based services platform may represent the primary interface through which clients may access the features of a database system that implements database service it need not represent the sole interface to such features. For example an alternate API that may be distinct from a network based services interface may be used to allow clients internal to the enterprise providing the database system to bypass network based services platform . Note that in many of the examples described herein distributed database optimized storage service may be internal to a computing system or an enterprise system that provides database services to clients and may not be exposed to external clients e.g. users or client applications . In such embodiments the internal client e.g. database service may access distributed database optimized storage service over a local or private network shown as the solid line between distributed database optimized storage service and database service e.g. through an API directly between the systems that implement these services . In such embodiments the use of distributed database optimized storage service in storing databases on behalf of clients may be transparent to those clients. In other embodiments distributed database optimized storage service may be exposed to clients through network based services platform to provide storage of databases or other information for applications other than those that rely on database service for database management. This is illustrated in by the dashed line between web services platform and distributed database optimized storage service . In such embodiments clients of the distributed database optimized storage service may access distributed database optimized storage service via network e.g. over the Internet . In some embodiments a virtual computing service may be configured to receive storage services from distributed database optimized storage service e.g. through an API directly between the virtual computing service and distributed database optimized storage service to store objects used in performing computing services on behalf of a client . This is illustrated in by the dashed line between virtual computing service and distributed database optimized storage service . In some cases the accounting and or credentialing services of platform may be unnecessary for internal clients such as administrative clients or between service components within the same enterprise.

Note that in various embodiments different storage policies may be implemented by database service and or distributed database optimized storage service . Examples of such storage policies may include a durability policy e.g. a policy indicating the number of instances of a database or data page thereof that will be stored and the number of different nodes on which they will be stored and or a load balancing policy which may distribute databases or data pages thereof across different nodes volumes and or disks in an attempt to equalize request traffic . In addition different storage policies may be applied to different types of stored items by various one of the services. For example in some embodiments distributed database optimized storage service may implement a higher durability for redo log records than for data pages.

In this example one or more client processes may send database query requests which may include read and or write requests targeting data stored on one or more of the storage nodes to database tier components and may receive database query responses from database tier components e.g. responses that include write acknowledgements and or requested data . Each database query request that includes a request to write to a data page may be parsed and optimized to generate one or more write record requests which may be sent to client side driver for subsequent routing to distributed database optimized storage system . In this example client side driver may generate one or more redo log records corresponding to each write record request and may send them to specific ones of the storage nodes of distributed database optimized storage system . Distributed database optimized storage system may return a corresponding write acknowledgement for each redo log record to database engine specifically to client side driver . Client side driver may pass these write acknowledgements to database tier components as write responses which may then send corresponding responses e.g. write acknowledgements to one or more client processes as one of database query responses .

In this example each database query request that includes a request to read a data page may be parsed and optimized to generate one or more read record requests which may be sent to client side driver for subsequent routing to distributed database optimized storage system . In this example client side driver may send these requests to specific ones of the storage nodes of distributed database optimized storage system and distributed database optimized storage system may return the requested data pages to database engine specifically to client side driver . Client side driver may send the returned data pages to the database tier components as return data records and database tier components may then send the data pages to one or more client processes as database query responses .

In some embodiments various error and or data loss messages may be sent from distributed database optimized storage system to database engine specifically to client side driver . These messages may be passed from client side driver to database tier components as error and or loss reporting messages and then to one or more client processes along with or instead of a database query response .

In some embodiments the APIs of distributed database optimized storage system and the APIs of client side driver may expose the functionality of the distributed database optimized storage system to database engine as if database engine were a client of distributed database optimized storage system . For example database engine through client side driver may write redo log records or request data pages through these APIs to perform or facilitate the performance of various operations of the database system implemented by the combination of database engine and distributed database optimized storage system e.g. storage access change logging recovery and or space management operations . Distributed database optimized storage system may store data blocks on storage nodes each of which may have multiple attached SSDs. In some embodiments distributed database optimized storage system may provide high durability for stored data block through the application of various types of redundancy schemes.

Note that in various embodiments the API calls and responses between database engine and distributed database optimized storage system e.g. APIs and or the API calls and responses between client side driver and database tier components e.g. APIs in may be performed over a secure proxy connection e.g. one managed by a gateway control plane or may be performed over the public network or alternatively over a private channel such as a virtual private network VPN connection. These and other APIs to and or between components of the database systems described herein may be implemented according to different technologies including but not limited to Simple Object Access Protocol SOAP technology and Representational state transfer REST technology. For example these APIs may be but are not necessarily implemented as SOAP APIs or RESTful APIs. SOAP is a protocol for exchanging information in the context of network based services. REST is an architectural style for distributed hypermedia systems. A RESTful API which may also be referred to as a RESTful web service is a web service API implemented using HTTP and REST technology. The APIs described herein may in some embodiments be wrapped with client libraries in various languages including but not limited to C C Java C and Perl to support integration with database engine and or distributed database optimized storage system .

As noted above in some embodiments the functional components of a database system may be partitioned between those that are performed by the database engine and those that are performed in a separate distributed database optimized storage system. In one specific example in response to receiving a request from a client process or a thread thereof to insert something into a database e.g. to update a single data block by adding a record to that data block one or more components of the database engine head node may perform query parsing optimization and execution and may send each portion of the query to a transaction and consistency management component. The transaction and consistency management component may ensure that no other client process or thread thereof is trying to modify the same row at the same time. For example the transaction and consistency management component may be responsible for ensuring that this change is performed atomically consistently durably and in an isolated manner in the database. For example the transaction and consistency management component may work together with the client side storage service driver of the database engine head node to generate a redo log record to be sent to one of the nodes in the distributed database optimized storage service and to send it to the distributed database optimized storage service along with other redo logs generated in response to other client requests in an order and or with timing that ensures the ACID properties are met for this transaction. Upon receiving the redo log record which may be considered an update record by the storage service the corresponding storage node may update the data block and may update a redo log for the data block e.g. a record of all changes directed to the data block . In some embodiments the database engine may be responsible for generating an undo log record for this change and may also be responsible for generating a redo log record for the undo log both of which may be used locally in the database tier for ensuring transactionality. However unlike in traditional database systems the systems described herein may shift the responsibility for applying changes to data blocks to the storage system rather than applying them at the database tier and shipping the modified data blocks to the storage system .

As previously noted each database instance may include a single database engine head node that receives requests e.g. a snapshot request etc. from various client programs e.g. applications and or subscribers users then parses them optimizes them and develops an execution plan to carry out the associated database operation s . In the example illustrated in a query parsing optimization and execution component of database engine head node may perform these functions for queries that are received from database client and that target the database instance of which database engine head node is a component. In some embodiments query parsing optimization and execution component may return query responses to database client which may include write acknowledgements requested data pages or portions thereof error messages and or other responses as appropriate. As illustrated in this example database engine head node may also include a client side storage service driver which may route read requests and or redo log records to various storage nodes within distributed database optimized storage service receive write acknowledgements from distributed database optimized storage service receive requested data pages from distributed database optimized storage service and or return data pages error messages or other responses to query parsing optimization and execution component which may in turn return them to database client .

In this example database engine head node includes a data page cache in which data pages that were recently accessed may be temporarily held such as also described above with regard to warm database cache in . Database engine head node may implement memory which may be one or more memory components or devices implemented on a computing system such as those discussed below with regard to . Memory may also be one or more components or devices discussed with regard to . Various different methods or techniques may be performed e.g. by database engine with regard to database cache such as discussed below with regard to discussed below describe some of the various ways database cache may be implemented in order to survive across database failures.

As illustrated in database engine head node may also include a transaction and consistency management component which may be responsible for providing transactionality and consistency in the database instance of which database engine head node is a component. For example this component may be responsible for ensuring the Atomicity Consistency and Isolation properties of the database instance and the transactions that are directed that the database instance. As illustrated in database engine head node may also include a transaction log and an undo log which may be employed by transaction and consistency management component to track the status of various transactions and roll back any locally cached results of transactions that do not commit. Various records from transaction log and undo log may also be used to determine a recovery point for a database cache as discussed below with regard to . Although illustrated as included in memory transaction log and undo log may in some embodiments be maintained in separate portions or devices of memory than data page cache .

Note that each of the other database engine head nodes illustrated in e.g. and may include similar components and may perform similar functions for queries received by one or more of database clients and directed to the respective database instances of which it is a component.

In some embodiments the distributed database optimized storage systems described herein may organize data in various logical volumes segments and pages for storage on one or more storage nodes. For example in some embodiments each database is represented by a logical volume and each logical volume is segmented over a collection of storage nodes. Each segment which lives on a particular one of the storage nodes contains a set of contiguous block addresses. In some embodiments each data page is stored in a segment such that each segment stores a collection of one or more data pages and a change log also referred to as a redo log e.g. a log of redo log records for each data page that it stores. As described in detail herein the storage nodes may be configured to receive redo log records which may also be referred to herein as ULRs and to coalesce them to create new versions of the corresponding data pages and or additional or replacement log records e.g. lazily and or in response to a request for a data page or a database crash . In some embodiments data pages and or change logs may be mirrored across multiple storage nodes according to a variable configuration which may be specified by the client on whose behalf the databases is being maintained in the database system . For example in different embodiments one two or three copies of the data or change logs may be stored in each of one two or three different availability zones or regions according to a default configuration an application specific durability preference or a client specified durability preference.

As used herein the following terms may be used to describe the organization of data by a distributed database optimized storage system according to various embodiments.

Volume A volume is a logical concept representing a highly durable unit of storage that a user client application of the storage system understands. More specifically a volume is a distributed store that appears to the user client application as a single consistent ordered log of write operations to various user pages of a database. Each write operation may be encoded in a User Log Record ULR which represents a logical ordered mutation to the contents of a single user page within the volume. As noted above a ULR may also be referred to herein as a redo log record. Each ULR may include a unique identifier e.g. a Logical Sequence Number LSN . Each ULR may be persisted to one or more synchronous segments in the distributed store that form a Protection Group PG to provide high durability and availability for the ULR. A volume may provide an LSN type read write interface for a variable size contiguous range of bytes.

In some embodiments a volume may consist of multiple extents each made durable through a protection group. In such embodiments a volume may represent a unit of storage composed of a mutable contiguous sequence of Volume Extents. Reads and writes that are directed to a volume may be mapped into corresponding reads and writes to the constituent volume extents. In some embodiments the size of a volume may be changed by adding or removing volume extents from the end of the volume.

Segment A segment is a limited durability unit of storage assigned to a single storage node. More specifically a segment provides limited best effort durability e.g. a persistent but non redundant single point of failure that is a storage node for a specific fixed size byte range of data. This data may in some cases be a mirror of user addressable data or it may be other data such as volume metadata or erasure coded bits in various embodiments. A given segment may live on exactly one storage node. Within a storage node multiple segments may live on each SSD and each segment may be restricted to one SSD e.g. a segment may not span across multiple SSDs . In some embodiments a segment may not be required to occupy a contiguous region on an SSD rather there may be an allocation map in each SSD describing the areas that are owned by each of the segments. As noted above a protection group may consist of multiple segments spread across multiple storage nodes. In some embodiments a segment may provide an LSN type read write interface for a fixed size contiguous range of bytes where the size is defined at creation . In some embodiments each segment may be identified by a Segment UUID e.g. a universally unique identifier of the segment .

Storage page A storage page is a block of memory generally of fixed size. In some embodiments each page is a block of memory e.g. of virtual memory disk or other physical memory of a size defined by the operating system and may also be referred to herein by the term data block . More specifically a storage page may be a set of contiguous sectors. It may serve as the unit of allocation in SSDs as well as the unit in log pages for which there is a header and metadata. In some embodiments and in the context of the database systems described herein the term page or storage page may refer to a similar block of a size defined by the database configuration which may typically a multiple of 2 such as 4096 8192 16384 or 32768 bytes.

Log page A log page is a type of storage page that is used to store log records e.g. redo log records or undo log records . In some embodiments log pages may be identical in size to storage pages. Each log page may include a header containing metadata about that log page e.g. metadata identifying the segment to which it belongs. Note that a log page is a unit of organization and may not necessarily be the unit of data included in write operations. For example in some embodiments during normal forward processing write operations may write to the tail of the log one sector at a time.

Log Records Log records e.g. the individual elements of a log page may be of several different classes. For example User Log Records ULRs which are created and understood by users clients applications of the storage system may be used to indicate changes to user data in a volume. Control Log Records CLRs which are generated by the storage system may contain control information used to keep track of metadata such as the current unconditional volume durable LSN VDL . Null Log Records NLRs may in some embodiments be used as padding to fill in unused space in a log sector or log page. In some embodiments there may be various types of log records within each of these classes and the type of a log record may correspond to a function that needs to be invoked to interpret the log record. For example one type may represent all the data of a user page in compressed format using a specific compression format a second type may represent new values for a byte range within a user page a third type may represent an increment operation to a sequence of bytes interpreted as an integer and a fourth type may represent copying one byte range to another location within the page. In some embodiments log record types may be identified by GUIDs rather than by integers or enums which may simplify versioning and development especially for ULRs.

Payload The payload of a log record is the data or parameter values that are specific to the log record or to log records of a particular type. For example in some embodiments there may be a set of parameters or attributes that most or all log records include and that the storage system itself understands. These attributes may be part of a common log record header structure which may be relatively small compared to the sector size. In addition most log records may include additional parameters or data specific to that log record type and this additional information may be considered the payload of that log record. In some embodiments if the payload for a particular ULR is larger than the user page size it may be replaced by an absolute ULR an AULR whose payload includes all the data for the user page. This may enable the storage system to enforce an upper limit on the size of the payload for ULRs that is equal to the size of user pages.

Note that when storing log records in the segment log the payload may be stored along with the log header in some embodiments. In other embodiments the payload may be stored in a separate location and pointers to the location at which that payload is stored may be stored with the log header. In still other embodiments a portion of the payload may be stored in the header and the remainder of the payload may be stored in a separate location. If the entire payload is stored with the log header this may be referred to as in band storage otherwise the storage may be referred to as being out of band. In some embodiments the payloads of most large AULRs may be stored out of band in the cold zone of log which is described below .

User pages User pages are the byte ranges of a fixed size and alignments thereof for a particular volume that are visible to users clients of the storage system. User pages are a logical concept and the bytes in particular user pages may or not be stored in any storage page as is. The size of the user pages for a particular volume may be independent of the storage page size for that volume. In some embodiments the user page size may be configurable per volume and different segments on a storage node may have different user page sizes. In some embodiments user page sizes may be constrained to be a multiple of the sector size e.g. 4 KB and may have an upper limit e.g. 64 KB . The storage page size on the other hand may be fixed for an entire storage node and may not change unless there is a change to the underlying hardware.

Data page A data page is a type of storage page that is used to store user page data in compressed form. In some embodiments every piece of data stored in a data page is associated with a log record and each log record may include a pointer to a sector within a data page also referred to as a data sector . In some embodiments data pages may not include any embedded metadata other than that provided by each sector. There may be no relationship between the sectors in a data page. Instead the organization into pages may exist only as an expression of the granularity of the allocation of data to a segment.

Storage node A storage node is a single virtual machine that on which storage node server code is deployed. Each storage node may contain multiple locally attached SSDs and may provide a network API for access to one or more segments. In some embodiments various nodes may be on an active list or on a degraded list e.g. if they are slow to respond or are otherwise impaired but are not completely unusable . In some embodiments the client side driver may assist in or be responsible for classifying nodes as active or degraded for determining if and when they should be replaced and or for determining when and how to redistribute data among various nodes based on observed performance.

SSD As referred to herein the term SSD may refer to a local block storage volume as seen by the storage node regardless of the type of storage employed by that storage volume e.g. disk a solid state drive a battery backed RAM a non volatile RAM device e.g. one or more NV DIMMs or another type of persistent storage device. An SSD is not necessarily mapped directly to hardware. For example a single solid state storage device might be broken up into multiple local volumes where each volume is split into and striped across multiple segments and or a single drive may be broken up into multiple volumes simply for ease of management in different embodiments. In some embodiments each SSD may store an allocation map at a single fixed location. This map may indicate which storage pages that are owned by particular segments and which of these pages are log pages as opposed to data pages . In some embodiments storage pages may be pre allocated to each segment so that forward processing may not need to wait for allocation. Any changes to the allocation map may need to be made durable before newly allocated storage pages are used by the segments.

As illustrated above in a database engine head node may implement a database cache in order to service access requests for frequently accessed data without requesting the data from storage service . illustrate example memory components configured to implement database cache survivability across database failures according to some embodiments. Although discussed in the context of a network based database service memory components and or system memory may be implemented in a variety of different database systems and are not limited to network based database services.

Volatile system memory may be implemented using a variety of different conventional system memory technologies components or devices. System memory devices including but not limited to dynamic random access memory DRAM or static random access memory SRAM may be used in order to implement volatile system memory as well as countless varieties of these and other random access memory technologies including but not limited to dual in line memory module DIMM synchronous dynamic random access memory SDRAM double data rate synchronous random access memory DDR SDRAM .

Non volatile system memory may be implemented using a variety of different non volatile memory technologies that provide similar or near conventional system memory performance characteristics. For instance if non volatile system memory may be within various ranges of read and or write speed that are only a certain percentage slower than conventional system memory performance. As mentioned above conventional system memory performance may vary and thus the following examples are not intended to be limiting. In some embodiments Ferroelectric RAM may be used as non volatile storage memory . Generally ferroelectric RAM may implement a ferroelectric layer in order to store data in storage elements e.g. storage cells . In some embodiments MRAM may be used as non volatile memory . Generally MRAM may implement ferromagnetic plates to store data in storage elements. In some embodiments resistive random access memory may be used as non volatile memory . Resistive random access memory may generally implement resistive memory cells which can conduct through a dielectric switching between high or low resistance. In some embodiments phase change random access memory may be used to implement non volatile system memory . Generally phase change random access memory implements chalcogenide glass in low resistance and high resistance states.

As illustrated in non volatile system memory may implement data page cache . Cache access requests such as various read write operations may be performed according to the various different mechanisms or protocols of non volatile system memory . In the event of database failure such as a power failure of the computing device implementing the database non volatile system memory may preserve the data maintaining a warm database cache. In some embodiments data may be persisted without a power or other energy supply to the non volatile system memory . Then upon recovery from the database system failure non volatile system memory may be directly accessed by the database in order to invalidate inconsistent cache entries with a determined recovery point and make the database cache available for processing access requests. Valid cache entries from before the database failure may be made available without rebuilding the database cache in various embodiments.

Turning now to in some embodiments data page cache may be implemented in a memory component that implements non volatile system backup storage for data persisted in volatile system memory . Various different components or devices may implement data backup for system memory such as non volatile random access memory NV RAM or other battery or super capacitor backed memory devices e.g. NV DIMM . Generally non volatile system backup storage may be a flash based storage device that communicates with volatile system memory such as SRAM or DRAM. In the event of a system failure a controller or other device copies data from volatile system memory to non volatile system backup storage as depicted by the dotted arrow . Thus in some embodiments data page cache may be maintained in the event of database failure maintaining a warm state of the database cache. In at least some embodiments the data page cache may be accessed and or restored from non volatile system backup storage to volatile system memory in order to process cache access requests upon recovery from a database failure.

Turning now to in some embodiments data page cache may be implemented as part of system memory . System memory may be one or more conventional system memory types such as dynamic random access memory DRAM or static random access memory SRAM as well as countless varieties of these and other random access memory technologies including but not limited to dual in line memory module DIMM synchronous dynamic random access memory SDRAM double data rate synchronous random access memory DDR SDRAM . System memory may as part of an operating system component memory allocation component or some other system component allocate system memory such as a block of memory allocated via a virtual memory management technique to one or more processes operating on computing device implementing a database. For example database engine may be a process performing on one or more computing devices implementing database engine head node . Various other processes may also be concurrently performing on the computing device such as client side storage service driver .

The shaded portion of system memory represents other various portions of memory that are allocated to these other processes as well as unallocated portions of memory. A portion of system memory may also be specifically allocated to a database engine process as illustrated at in . Database engine allocated memory may include program instructions and or other data necessary to perform the various functions of the database engine process. In at least some embodiments data page cache may be implemented in a shared memory segment in system memory that is accessible by other processes including the database engine process and yet independent of those processes. For example if the database engine process deadlocks fails or is otherwise stopped database engine allocated memory which is allocated solely to the database engine process may be deallocated thus losing the data stored in the portion of allocated memory . Data page cache however is in an independent segment of memory and thus a memory manager operation system or other memory allocation component may continue to maintain the data page cache irrespective of the failure of the database engine process or other processes performing on the computing device implementing the database. Thus when processing cache access requests data page cache may remain warm even in the event of a failure of the database engine process.

The previous examples of a network based database service given above describe various embodiments of a database system that may implement database cache survivability across database failures. The various methods and techniques discussed above as well as the various components implementing those techniques such as database engine and the various different memory configurations illustrated in may also be implemented on a wide variety of different database systems. These components along with many other components may be configured to implement methods and techniques to ensure database cache survivability across database failures. is a high level flowchart of various techniques to implement database cache survivability across database failures according to some embodiments.

As indicated at in various embodiments a database cache may be maintained independent of a database failure of a database. A database cache as discussed above may generally provide frequently accessed data for a database to process access requests without accessing a back end data store such as one or more persistent storage devices or distributed data storage service discussed above with regard to . Typically database caches include a plurality of cache entries each of which may contain a respective copy or version of data such as a database page that is persistently stored in a back end data store such as on one or more persistent storage devices accessible by a database system or persisted as part of a storage system such as storage service discussed above with regard to . Accessing a database cache may be performed much more efficiently than accessing data persisted in storage back end data store as typically devices maintaining a database cache are have faster read write performance capabilities in addition to being locally accessible to computing devices implementing a database .

Maintaining a database cache may in some embodiments be implementing by storing the database cache on one or more non volatile memory devices such as those described above with regard to . Non Volatile Random Access Memory NV RAM or some other form of battery backed memory device which may implement flash based storage to maintain data stored in system memory irrespective of a system failure as well as various post nand flash technologies such as ferroelectric random access memory Ferroelectric RAM magnetoresistive random access memory MRAM resistive random access memory Resistive RAM and or phase change random access memory PC RAM are just some examples of various different kinds of non volatile memory storage devices that may be implemented to preserve a database cache irrespective of database failure. Please note that flash based technologies with similar or near system memory performance may also be used as a non volatile memory device to maintain a warm database cache.

In some embodiments maintaining a database cache may be performed by storing a database cache in a shared memory segment of system memory. As discussed above with regard to a shared memory segment may be accessed by multiple processes. However irrespective of a failure of one or more of the processes accessing the shared memory segment such as the database process or other process that interacts with the database cache the shared memory segment may still maintain the data stored within the shared memory segment. Thus a database cache maintained in shared memory segment may be maintained irrespective of a failure of a database engine process or other process accessing the database cache. A shared memory segment or other out of process with respect to a database engine process may be implemented to maintain a warm database cache in the event of a failure of the database engine process.

As indicated at a database failure may be recovered from. Various types of database failures may occur. For example in some embodiments database failures may be a failure of a database engine process or other process that process access requests or accesses a database cache. A process failure may have any number of causes such as deadlock. In at least some embodiments a process failure may be initiated by an operator external system or other component located on the computing device implementing the database engine process. Another example of database failure may be a system or power failure. System or power failures in various embodiments may cause system memory implemented as part of a computing device implementing a database to lose power and thus a loss data maintained in system memory.

Upon recovery from a database failure a recovery point may be determined that indicates a consistent state of the database as indicated at . A recovery point may be determined in some embodiments based at least in part on a consistent state of the database. A consistent state or indicator of the consistent state of the database may be received from database storage such as storage service described above with regard to . For example in some embodiments database storage may maintain an indicator or value such as a Log Sequence Number which may indicate the consistent state of the database in database storage. Various types of log records accessible to a database engine process for instance the undo log records and the transaction log records discussed above with regard to may then be used to determine a recovery point for the database using the LSN. In various embodiments a recovery point may be determined by scanning one or more log records to a previous state of the database. For example redo log records undo log records and transaction records may be maintained as part of a write ahead logging recovery schema in a database. Upon recovery from a database failure recovery algorithms such as Algorithms for Recovery and Isolation Exploiting Semantics ARIES may be used to scan the various log records to locate a consistent point of the database. In at least some embodiments a consistent point of the database may be represented by an LSN.

In at least some embodiments one or more entries of the database cache that are inconsistent with the database at the determined recovery point may be invalidated as indicated at . Invalidating cache entries may be performed by marking inconsistent entries such as by changing a value in the entry or a value in metadata describing the entry or by removing erasing or otherwise making inaccessible the inconsistent cache entry. Determining particular cache entries to be invalidated may be performed by evaluating a state identifier such as a sequence number to be compared with the determined recovery point. For example each cache entry may include a sequence number. The entries of the database cache may then be compared with an LSN that is determined to be the recovery point for the database. For those entries with sequence numbers inconsistent with the LSN the cache entry may be invalidated. In at least some embodiments cache entries may be invalidated lazily. For instance in some embodiments when an access request is received for a cache entry the cache entry may be evaluated to determine whether the cache entry is inconsistent with the recovery point. This may be performed multiple times for different cache entries invalidating inconsistent cache entries on the fly.

As indicated at the database cache may then be made available for access requests directed toward the database in various embodiments. Valid cache entries from before the database failure may be made available for servicing access requests. In at least some embodiments the valid cache entries may be made available without accessing a back end data store and or rebuilding the valid cache entries from the back end data store.

In at least some embodiments a database cache may be maintained independent of a database failure by storing in a non volatile memory device identifiers that identify respective data pages that are maintained in a database cache stored in volatile system memory. Upon recovery from a database failure the identifiers may be accessed to determine the warm state of the database cache in volatile system memory at the time of the database failure. The identified data pages may be obtained from database storage and restored to the database cache in system memory. In some embodiments upon restoring the data pages to the database cache the database cache may be indicated as warm.

In at least some embodiments a copy of the database cache may be maintained in system memory in addition to a database cache maintained in a non volatile memory device. Various updates may be performed at the database cache implemented in system memory. Corresponding updates may be made at the database cache maintained in the non volatile memory device. For example a write through policy may be applied where updates made to the database cache in system memory are concurrently made at the database cache maintained in the non volatile memory device.

The methods described herein may in various embodiments be implemented by any combination of hardware and software. For example in one embodiment the methods may be implemented by a computer system e.g. a computer system as in that includes one or more processors executing program instructions stored on a computer readable storage medium coupled to the processors. The program instructions may be configured to implement the functionality described herein e.g. the functionality of various servers and other components that implement the database services systems and or storage services systems described herein .

Computer system includes one or more processors any of which may include multiple cores which may be single or multi threaded coupled to a system memory via an input output I O interface . Computer system further includes a network interface coupled to I O interface . In various embodiments computer system may be a uniprocessor system including one processor or a multiprocessor system including several processors e.g. two four eight or another suitable number . Processors may be any suitable processors capable of executing instructions. For example in various embodiments processors may be general purpose or embedded processors implementing any of a variety of instruction set architectures ISAs such as the x86 PowerPC SPARC or MIPS ISAs or any other suitable ISA. In multiprocessor systems each of processors may commonly but not necessarily implement the same ISA. The computer system also includes one or more network communication devices e.g. network interface for communicating with other systems and or components over a communications network e.g. Internet LAN etc. . For example a client application executing on system may use network interface to communicate with a server application executing on a single server or on a cluster of servers that implement one or more of the components of the database systems described herein. In another example an instance of a server application executing on computer system may use network interface to communicate with other instances of the server application or another server application that may be implemented on other computer systems e.g. computer systems .

In the illustrated embodiment computer system also includes one or more persistent storage devices and or one or more I O devices . In various embodiments persistent storage devices may correspond to disk drives tape drives solid state memory other mass storage devices or any other persistent storage device. Computer system or a distributed application or operating system operating thereon may store instructions and or data in persistent storage devices as desired and may retrieve the stored instruction and or data as needed. For example in some embodiments computer system may host a storage system server node and persistent storage may include the SSDs attached to that server node.

Computer system includes one or more system memories that are configured to store instructions and data accessible by processor s . In various embodiments system memories may be implemented using any suitable memory technology e.g. one or more of cache static random access memory SRAM DRAM RDRAM EDO RAM DDR 10 RAM synchronous dynamic RAM SDRAM Rambus RAM EEPROM non volatile Flash type memory or any other type of memory . System memory may contain program instructions that are executable by processor s to implement the methods and techniques described herein. In various embodiments program instructions may be encoded in platform native binary any interpreted language such as Java byte code or in any other language such as C C Java etc. or in any combination thereof. For example in the illustrated embodiment program instructions include program instructions executable to implement the functionality of a database engine head node of a database tier or one of a plurality of storage nodes of a separate distributed database optimized storage system that stores databases and associated metadata on behalf of clients of the database tier in different embodiments. In some embodiments program instructions may implement multiple separate clients server nodes and or other components.

In some embodiments program instructions may include instructions executable to implement an operating system not shown which may be any of various operating systems such as UNIX LINUX Solaris MacOS Windows etc. Any or all of program instructions may be provided as a computer program product or software that may include a non transitory computer readable storage medium having stored thereon instructions which may be used to program a computer system or other electronic devices to perform a process according to various embodiments. A non transitory computer readable storage medium may include any mechanism for storing information in a form e.g. software processing application readable by a machine e.g. a computer . Generally speaking a non transitory computer accessible medium may include computer readable storage media or memory media such as magnetic or optical media e.g. disk or DVD CD ROM coupled to computer system via I O interface . A non transitory computer readable storage medium may also include any volatile or non volatile media such as RAM e.g. SDRAM DDR SDRAM RDRAM SRAM etc. ROM etc. that may be included in some embodiments of computer system as system memory or another type of memory. In other embodiments program instructions may be communicated using optical acoustical or other form of propagated signal e.g. carrier waves infrared signals digital signals etc. conveyed via a communication medium such as a network and or a wireless link such as may be implemented via network interface .

In some embodiments system memory may include data store which may be configured as described herein. For example the information described herein as being stored by the database tier e.g. on a database engine head node such as a transaction log an undo log cached page data or other information used in performing the functions of the database tiers described herein may be stored in data store or in another portion of system memory on one or more nodes in persistent storage and or on one or more remote storage devices at different times and in various embodiments. Similarly the information described herein as being stored by the storage tier e.g. redo log records coalesced data pages and or other information used in performing the functions of the distributed storage systems described herein may be stored in data store or in another portion of system memory on one or more nodes in persistent storage and or on one or more remote storage devices at different times and in various embodiments. In general system memory e.g. data store within system memory persistent storage and or remote storage may store data blocks replicas of data blocks metadata associated with data blocks and or their state database configuration information and or any other information usable in implementing the methods and techniques described herein.

In one embodiment I O interface may be configured to coordinate I O traffic between processor system memory and any peripheral devices in the system including through network interface or other peripheral interfaces. In some embodiments I O interface may perform any necessary protocol timing or other data transformations to convert data signals from one component e.g. system memory into a format suitable for use by another component e.g. processor . In some embodiments I O interface may include support for devices attached through various types of peripheral buses such as a variant of the Peripheral Component Interconnect PCI bus standard or the Universal Serial Bus USB standard for example. In some embodiments the function of I O interface may be split into two or more separate components such as a north bridge and a south bridge for example. Also in some embodiments some or all of the functionality of I O interface such as an interface to system memory may be incorporated directly into processor .

Network interface may be configured to allow data to be exchanged between computer system and other devices attached to a network such as other computer systems which may implement one or more storage system server nodes database engine head nodes and or clients of the database systems described herein for example. In addition network interface may be configured to allow communication between computer system and various I O devices and or remote storage . Input output devices may in some embodiments include one or more display terminals keyboards keypads touchpads scanning devices voice or optical recognition devices or any other devices suitable for entering or retrieving data by one or more computer systems . Multiple input output devices may be present in computer system or may be distributed on various nodes of a distributed system that includes computer system . In some embodiments similar input output devices may be separate from computer system and may interact with one or more nodes of a distributed system that includes computer system through a wired or wireless connection such as over network interface . Network interface may commonly support one or more wireless networking protocols e.g. Wi Fi IEEE 802.11 or another wireless networking standard . However in various embodiments network interface may support communication via any suitable wired or wireless general data networks such as other types of Ethernet networks for example. Additionally network interface may support communication via telecommunications telephony networks such as analog voice networks or digital fiber communications networks via storage area networks such as Fibre Channel SANs or via any other suitable type of network and or protocol. In various embodiments computer system may include more fewer or different components than those illustrated in e.g. displays video cards audio cards peripheral devices other network interfaces such as an ATM interface an Ethernet interface a Frame Relay interface etc. 

It is noted that any of the distributed system embodiments described herein or any of their components may be implemented as one or more web services. For example a database engine head node within the database tier of a database system may present database services and or other types of data storage services that employ the distributed storage systems described herein to clients as web services. In some embodiments a web service may be implemented by a software and or hardware system designed to support interoperable machine to machine interaction over a network. A web service may have an interface described in a machine processable format such as the Web Services Description Language WSDL . Other systems may interact with the web service in a manner prescribed by the description of the web service s interface. For example the web service may define various operations that other systems may invoke and may define a particular application programming interface API to which other systems may be expected to conform when requesting the various operations.

In various embodiments a web service may be requested or invoked through the use of a message that includes parameters and or data associated with the web services request. Such a message may be formatted according to a particular markup language such as Extensible Markup Language XML and or may be encapsulated using a protocol such as Simple Object Access Protocol SOAP . To perform a web services request a web services client may assemble a message including the request and convey the message to an addressable endpoint e.g. a Uniform Resource Locator URL corresponding to the web service using an Internet based application layer transfer protocol such as Hypertext Transfer Protocol HTTP .

In some embodiments web services may be implemented using Representational State Transfer RESTful techniques rather than message based techniques. For example a web service implemented according to a RESTful technique may be invoked through parameters included within an HTTP method such as PUT GET or DELETE rather than encapsulated within a SOAP message.

The various methods as illustrated in the figures and described herein represent example embodiments of methods. The methods may be implemented manually in software in hardware or in a combination thereof. The order of any method may be changed and various elements may be added reordered combined omitted modified etc.

Although the embodiments above have been described in considerable detail numerous variations and modifications may be made as would become apparent to those skilled in the art once the above disclosure is fully appreciated. It is intended that the following claims be interpreted to embrace all such modifications and changes and accordingly the above description to be regarded in an illustrative rather than a restrictive sense.

