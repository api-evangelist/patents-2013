---

title: Scalable content delivery network request handling mechanism to support a request processing layer
abstract: Described herein are improved systems, methods, and devices for delivering and managing metadata in a distributed computing platform such as a content delivery network (CDN) so as to configure content servers to handle client requests. The teachings hereof provide, among other things, scalable and configurable solutions for delivering and managing metadata, preferably by leveraging dynamically obtained control information. For example, in one embodiment, a given content server may store metadata, e.g., in a configuration file, that references dynamic, late-bound control information for use in satisfying dependencies. This dynamic control information can be requested by the CDN content server, typically from a remote host, when needed to parse and execute the metadata.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09509804&OS=09509804&RS=09509804
owner: Akami Technologies, Inc.
number: 09509804
owner_city: Cambridge
owner_country: US
publication_date: 20131219
---
This application is a non provisional of and claims the benefit of priority of U.S. Application No. 61 740 598 filed Dec. 21 2012 and of U.S. Application No. 61 740 627 filed Dec. 21 2012 and of U.S. Application No. 61 827 398 filed May 24 2013 and of U.S. Application No. 61 841 822 filed Jul. 1 2013 and of U.S. Application No. 61 884 756 filed Sep. 30 2013. The contents of the each of the foregoing applications are hereby incorporated by reference in their entireties.

This patent document contains material which is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure as it appears in Patent and Trademark Office patent files or records but otherwise reserves all copyright rights whatsoever.

This application relates generally to distributed data processing systems and to the delivery of content over computer networks.

Distributed computer systems are known in the art. One such distributed computer system is a content delivery network or CDN that is operated and managed by a service provider. The service provider typically provides the content delivery service on behalf of third parties. A distributed system of this type typically refers to a collection of autonomous computers linked by a network or networks together with the software systems protocols and techniques designed to facilitate various services such as content delivery or the support of outsourced site infrastructure. The CDN represents an infrastructure shared by multiple third parties sometimes referred to as multi tenant infrastructure. Typically content delivery refers to the storage caching or transmission of content such as web pages streaming media and applications on behalf of content providers and ancillary technologies used therewith including without limitation DNS query handling provisioning data monitoring and reporting content targeting personalization and business intelligence.

In a known system such as that shown in a distributed computer system is configured as a content delivery network CDN and is assumed to have a set of machines distributed around the Internet. Typically most of the machines are configured as CDN content servers . Such machines may be located near the edge of the Internet i.e. at or adjacent end user access networks. A network operations command center NOCC may be used to administer and manage operations of the various machines in the system. Third party sites affiliated with content providers such as web site hosted at origin server offload delivery of content e.g. HTML embedded page objects streaming media software downloads and the like to the distributed computer system and in particular to the servers which are sometimes referred to as edge servers in light of the possibility that they are near an edge of the Internet . Such servers may be grouped together into a point of presence POP .

Typically content providers offload their content delivery by aliasing e.g. by a DNS CNAME given content provider domains or sub domains to domains that are managed by the service provider s authoritative domain name service. End user client machines that desire such content may be directed to the distributed computer system to obtain that content more reliably and efficiently. The CDN servers respond to the client requests for example by obtaining requested content from a local cache from another CDN server from the origin server or other source.

Although not shown in detail in the distributed computer system may also include other infrastructure such as a distributed data collection system that collects usage and other data from the content servers aggregates that data across a region or set of regions and passes that data to other back end systems and to facilitate monitoring logging alerts billing management and other operational and administrative functions. Distributed network agents monitor the network as well as the server loads and provide network traffic and load data to a domain name system DNS query handling mechanism which is authoritative for content domains being managed by the CDN. A distributed data transport mechanism may be used to distribute control information e.g. metadata to manage content to facilitate load balancing and the like to the servers .

As illustrated in a given machine in the CDN e.g. a given CDN server comprises commodity hardware e.g. an Intel processor running an operating system kernel such as Linux or variant that supports one or more applications . To facilitate content delivery services for example given machines typically run a set of applications such as an HTTP proxy server a name server a local monitoring process a distributed data collection process and the like. The HTTP proxy sometimes referred to herein as a global host or ghost typically includes a manager process for managing a cache and delivery of content from the machine. For streaming media the machine typically includes one or more media servers such as a Windows Media Server WMS or Flash server as required by the supported media formats.

The machine shown in may be configured to provide one or more extended content delivery features preferably on a domain specific content provider specific basis preferably using configuration files that are distributed to the CDN servers using a configuration system. A given configuration file preferably is extensible markup language XML based and includes a set of content handling rules and directives that facilitate one or more advanced content handling features. The configuration file may be delivered to a CDN server via the data transport mechanism . U.S. Pat. No. 7 240 100 the contents of which are hereby incorporated by reference illustrate a useful infrastructure for delivering and managing CDN server content control information and this and other content server control information referred to as metadata can be provisioned by the CDN service provider itself or via an extranet or the like the content provider customer who operates the origin server .

The contents of U.S. Pat. No. 7 111 057 titled Method and system for purging content from a content delivery network are hereby incorporated by reference.

In a typical operation a content provider identifies a content provider domain or sub domain that it desires to have served by the CDN. The CDN service provider associates e.g. via a canonical name or CNAME or other aliasing technique the content provider domain with a CDN hostname and the CDN provider then provides that CDN hostname to the content provider. When a DNS query to the content provider domain or sub domain is received at the content provider s domain name servers those servers respond by returning the CDN hostname. That network hostname points to the CDN and that hostname is then resolved through the CDN name service. To that end the CDN name service returns one or more IP addresses. The requesting client browser then makes a content request e.g. via HTTP or HTTPS to a CDN server associated with the IP address. The request includes a host header that includes the original content provider domain or sub domain. Upon receipt of the request with the host header the server checks its configuration file to determine whether the content domain or sub domain requested is actually being handled by the CDN. If so the server applies its content handling rules and directives for that domain or sub domain as specified in the configuration. As noted above these content handling rules and directives may be located within an XML based metadata configuration file.

As an overlay the CDN resources may be used to facilitate wide area network WAN acceleration services between enterprise data centers which may be privately managed and third party software as a service SaaS providers.

CDN customers may subscribe to a behind the firewall managed service product to accelerate Intranet web applications that are hosted behind the customer s enterprise firewall as well as to accelerate web applications that bridge between their users behind the firewall to an application hosted in the Internet cloud e.g. from a SaaS provider . To accomplish these two use cases CDN software may execute on machines potentially virtual machines running on customer hardware hosted in one or more customer data centers and on machines hosted in remote branch offices. The CDN software executing in the customer data center typically provides service configuration service management service reporting remote management access customer SSL certificate management as well as other functions for configured web applications. The software executing in the branch offices provides last mile web acceleration for users located there. The CDN itself typically provides CDN hardware hosted in CDN data centers to provide a gateway between the nodes running behind the customer firewall and the service provider s other infrastructure e.g. network and operations facilities . This type of managed solution provides an enterprise with the opportunity to take advantage of CDN technologies with respect to their company s intranet. This kind of solution extends acceleration for the enterprise to applications served anywhere on the Internet such as SaaS Software As A Service applications. By bridging an enterprise s CDN based private overlay network with the existing CDN public internet overlay network an end user at a remote branch office obtains an accelerated application end to end.

The CDN may have a variety of other features and adjunct components. For example the CDN may include a network storage subsystem sometimes referred to herein as NetStorage which may be located in a network datacenter accessible to the CDN servers such as described in U.S. Pat. No. 7 472 178 the disclosure of which is incorporated herein by reference. The CDN may operate a server cache hierarchy to provide intermediate caching of customer content one such cache hierarchy subsystem is described in U.S. Pat. No. 7 376 716 the disclosure of which is incorporated herein by reference.

For live streaming delivery the CDN may include a live delivery subsystem such as described in U.S. Pat. No. 7 296 082 and U.S. Publication No. 2011 0173345 the disclosures of which are incorporated herein by reference.

As noted above when a given content server in a CDN or in another distributed computing platform receives a content request it typically needs to have information about the identity and characteristics of the requested objects as well as information about the features of the CDN that should be invoked when delivering those objects. In short the CDN and by extension its constituent servers needs to have information about how to handle a content request. Such information referred to as metadata can be distributed in configuration files to the content servers as noted above with respect to U.S. Pat. No. 7 240 100.

However as a CDN grows and its feature set diversifies the volume and complexity of metadata rises significantly. Moreover the continuing move to cloud providers platform as a service PaaS infrastructure as a service IaaS and or software as a service SaaS further complicates the management of metadata for a CDN. Improved approaches for delivering and managing metadata are necessary to meet such challenges.

Described herein are improved methods devices and systems for delivering and managing metadata in a distributed computing platform such as a content delivery network CDN . The teachings hereof provide among other things scalable and configurable solutions for delivering and managing metadata preferably by leveraging dynamically obtained control information. For example in one embodiment a given CDN content server may receive and store metadata e.g. in a configuration file . The metadata can contain references to dynamic late bound control information for use in satisfying dependencies in the metadata. This dynamic control information is preferably requested by the CDN content server when needed to parse and execute the metadata and in many cases though without limitation from a remote host at the time of the client request for an object. The dynamic control information may be parameters e.g. an input to a function in the metadata configuration file. The dynamic control information may be functions or logic. In this way the dynamic control information represents a layer of abstraction within the metadata configuration file. The injected dynamic control information is well suited for among other things information that is desired to be highly dynamic more easily changeable or rotatable and or of high cardinality. The retrieved dynamic control information may be cached locally for use in handling to subsequent requests. A variety of further details uses and alternatives are described in this document.

By way of further illustration in an embodiment an apparatus can comprise a first server comprising circuitry forming one or more processors coupled to memory holding non transitory computer program instructions. The execution of the instructions can cause the first server to receive a request e.g. a request for service accessible via an API from a client device over a network interface and identify a content control that indicates how to handle the request from within a set of content controls stored at the first server wherein the content control comprises any of request validation client authentication and client authorization. The content control can have at least one dependency on particular control information. The first server further can send a request to a remote host for the particular control information receive the particular control information from the remote host satisfy the at least one dependency with the particular control information and apply the content control to the request. After applying the content control the first server can send at least a portion of the client device request to a second server which can be a server that provides the requested service accessible via the API.

In certain embodiments the request is directed to universal resource locator URL that represents an API endpoint the URL comprising any of a hostname and a path. The particular control information may be for example an API resource model a client identifier and an authentication secret logic for validating the client device request logic for authenticating or authorizing the client device or an application executing thereon or otherwise.

The service provided by the second server may enables for example interaction with a multi tenant storage system operated by the CDN on behalf of content providers a multi tenant computing system operated by the CDN on behalf of content providers and or a configuration service for CDN delivery services.

The subject matter described herein has a wide variety of applications in content delivery and online platform architectures.

As those skilled in the art will recognize the foregoing description merely refers to certain examples of the invention for overview purposes. It is not limiting and the teachings hereof may be realized in a variety of systems methods apparatus and non transitory computer readable media. It should also be noted that the allocation of functions to particular machines is not limiting as the functions recited herein may be combined or split amongst different machines in a variety of ways.

The following description sets forth embodiments of the invention to provide an overall understanding of the principles of the structure function manufacture and use of the methods and apparatus disclosed herein. The systems methods and apparatus described herein and illustrated in the accompanying drawings are non limiting examples the scope of the invention is defined solely by the claims. The features described or illustrated in connection with one exemplary embodiment may be combined with the features of other embodiments. Such modifications and variations are intended to be within the scope of the present invention. All patents publications and references cited herein are expressly incorporated herein by reference in their entirety. Throughout this disclosure the term e.g. is used as an abbreviation for the non limiting phrase for example .

Content delivery can be provided by directing client requests for content e.g. objects such as markup language files images scripts CSS streaming media and the like to the content delivery network or more particularly to one of the CDN s constituent servers. When the CDN receives client requests for content it typically needs to have information about the identity and characteristics of the requested objects as well as information about the features of the CDN platform that should be invoked when delivering those objects. In short the CDN and by extension its constituent servers needs to have information about how to handle a content request.

This information is referred to herein to as metadata. Metadata may include data about the content provider s objects and more generally may include the set of all control options and parameters that determine how a given CDN server will handle a request for an object be it an HTML file images CSS scripts streaming media or other digital content . For example a given object may have metadata associated with it that reflects such things as 

Metadata may also specify that certain features of the CDN should be invoked when handling the request and how to do so. These features may range from the use of certain routing technologies or cache hierarchy parents to the modification of the content before serving it e.g. particular web content optimizations or client device specific adaptations to the selective invocation of redirect responses to the application of certain security procedures e.g. a web application firewall to content posted HTTP Post from the client. These are merely examples. Such features may be applied at various stages in CDN server operation when processing the client request when generating a forward request to an origin server or other remote source when receiving a response from origin when generating a response to a client and so on.

As a CDN grows and its feature set diversifies the volume and complexity of metadata rises significantly. Moreover the continuing move to cloud providers such as providers of platform as a service PaaS infrastructure as a service IaaS and or software as a service SaaS further complicates the management of metadata for a CDN.

For example a CDN may have as a customer a cloud provider who is offering a cloud based service to its own cloud customers or in other words to the cloud users . For purposes of illustration assume the cloud based service enables each cloud customer to host their websites on the cloud provider platform. The cloud provider then works with the CDN to have the CDN actually deliver the content from the hosting platform. From the CDN s perspective there is one direct customer relationship with the cloud provider. However that cloud provider may want to have the ability to independently configure at least some or potentially all of its direct cloud customer sites be it for internal operational purposes or to be able to pass on a level of customization to its cloud customers.

As an illustration consider a cloud provider who is a SaaS provider and offers a web application to its cloud customers. The SaaS provider may want to configure its web application differently for each cloud customer again with the content being delivered by the CDN on behalf of the SaaS provider.

Consider further the case of a more traditional content provider as described previously but who desires dozens hundreds or even thousands of unique websites or other digital properties due the scale of their online operations. A single configuration will likely not suffice as there will likely be a need for many different configurations for this one content provider customer of the CDN.

With the foregoing by way of introduction described below are embodiments of improved metadata systems and methods that address these and similar issues and provide other functionality as will become clearer below.

 This is merely an example. The cloud customer s hostname could equally well be the name www.cloud customer.com which is aliased e.g. via CNAME to the cloud provider.com domain but the hostname above provides a suitable example for illustrative purposes. 

Assume further that a user operating a client device seeks content at that hostname. The client device running a client application such as a browser initiates a DNS lookup on the hostname cloud customer.site.cloud provider.com which is aliased e.g. CNAME to a CDN domain and thus through a CDN name service the client device given the address of a particular CDN server . This can all be done in the manner described previously and in U.S. Pat. No. 6 108 703 incorporated herein by reference.

The client device sends a content request e.g. an HTTP Get or other HTTP method to the CDN server with a hostname header of cloud customer.cloud provider.com. The CDN server locates and binds the request to a metadata configuration file s that it has for the cloud provider.com domain. This may be done for example by the CDN server executing a DNS lookup and examining the CNAME chain to determine the CDN customer and customer identifier to use for example as described in U.S. patent application Ser. No. 13 666 068 filed Nov. 1 2012 and titled Multi domain configuration handling in an edge network server now published as 2013 0191499 the teachings of which are hereby incorporated by reference in their entirety.

The metadata configuration file which in one embodiment is an XML file can contain certain invariant functions and possibly certain parameters used by those functions as known in the art and described in U.S. Pat. No. 7 240 100 and it may be periodically be distributed and updated at the CDN server as described therein prior to being needed for client requests . However the metadata in the configuration file sometimes referred to as static or invariant control data can also contain references to dynamic late bound parameters for use in the metadata functions. These parameters are preferably obtained by the CDN server when needed to parse and execute the metadata configuration file e.g. at the time of the client request or at some other stage of processing . It should be noted that the approach is not limited to injected parameter values for use in defined functions. In some cases the injected information can represent certain metadata functions or logic. For convenience of description all such kinds of dynamic information will be generally referred to herein as dynamic control information . The dynamic control information represents a layer of abstraction within the metadata configuration file and can be thought of as a just in time item of control information for the CDN server . In some embodiments the dynamic control information is a complex delivered in the form a content policy which may contain both parameters and logic that effects the desired policy. Content policies are described in more detail below.

By way of illustration consider a metadata function in the configuration file that checks the HTTP referrer header of an incoming request against a white list of permitted referrers e.g. a list of permitted hostnames . The function might be a regular expression match run by the CDN server on the referrer header against the whitelist e.g. expressed in XML. Rather than hard coding the whitelist into the metadata configuration file the whitelist is declared as a parameter whose value s must be retrieved by the CDN server to evaluate the function. This is but one example of the concept.

As noted above the CDN server is responsible for obtaining the required late bound dynamic control information from a remote host . In one embodiment before processing the request the CDN server invokes an intermediate processing routine that parses the metadata configuration file determines the data dependencies and obtains and injects the necessary dynamic control information to fulfill these dependencies in the metadata configuration file . The complete metadata configuration file can then be applied to process the client request.

As shown in in one embodiment the CDN server makes a call e.g. a service provider interface SPI call to a remote host to obtain the requisite dynamic control information . As those skilled in the art will recognize the SPI means that the CDN as the calling party will define the interface specifics in this embodiment. Thus in this implementation the remote host may be any system compliant with the SPI e.g. a system run by the CDN system run by the CDN customer the cloud provider or even a system run by the cloud provider s customers the cloud customers . In the illustrated embodiment the remote host is a CDN operated system in a highly available platform such as managed network storage facility aka NetStorage or otherwise storing a database . The database has the dynamic control information . The CDN may provide a web enabled portal or other user interface through which for example a particular cloud provider and or cloud provider s cloud customer can configure or update the database. Alternatively the cloud provider may have its own infrastructure storing its control information which is periodically communicated through an appropriate applications programming interface API to the CDN s remote host .

Preferably the system utilizes the concept of a content realm to manage the retrieval and use of dynamic control information . The content realm defines the context for which the dynamic control information is being retrieved. Hence a given CDN customer may be associated with many different defined content realms. If the CDN customer is a cloud provider for example a content realm might be defined for each of the cloud provider s cloud customers. For a CDN customer that uses the functionality defined herein to manage several different websites or other digital properties the content realm might correspond to each site etc. A content realm could also be associated with a particular area of a site or with a particular category of products displayed on a given site and the like.

Preferably the CDN customer defines the scope and meaning of the content realm. Then during the processing of a content request from a client device the CDN server determines the content realm identifier ID and passes it via the SPI to the remote host which uses the content realm ID to return the appropriate corresponding set of dynamic control information. In this way assuming the content realm ID corresponds to a cloud provider s cloud customer the dynamic control information for the appropriate cloud customer is retrieved and injected into the metadata configuration file . illustrates this process. In the CDN server makes an SPI request for dynamic control information consisting of two parameters x y and sends a content realm ID with value A B or C. Assume that the content realm ID corresponds to a particular cloud customer. In the database the value of x y depends on the content realm ID since different cloud customers may need or desire different content handling features. The remote host looks up the values based on the content realm ID and returns them to the server for binding to the variables that were declared in the metadata configuration file

The CDN server can determine the content realm identifier in a variety of ways. As mentioned preferably the CDN customer defines the desired content realm and logic for determining the content realm ID may be included in the configuration file . The specific logic to determine the identifier will be dependent on what it signifies. Preferably the CDN server extracts the content realm ID from some aspect of the content request transaction message exchange that occurs between itself and the client device . For example if the identifier represents a cloud provider s cloud customer the server might extract a content realm identifier from the host header of the request e.g. the subdomain cloud customer from cloud customer.cloud provider.com . The identifier also might come from an intermediate hostname or portion thereof in an DNS aliasing e.g. CNAMING chain that the CDN server obtains by performing a DNS lookup on the host header hostname for example as described in U.S. patent application Ser. No. 13 666 068 filed Nov. 1 2012 and titled Multi domain configuration handling in an edge network server now published as U.S. Patent Publication No. 2013 0191499 the contents of which are hereby incorporated by reference . Alternatively the CDN server might extract the identifier from the requested URI pathname or other URI component or from some other HTTP request header. Note that the term URI used herein includes universal resource locators or URLs as known in the art. Hence the content realm ID might correspond to a product identifier in the universal resource identifier URI pathname such that for example objects under pathfoo products1 are identified as a different content realm and thus controlled by different dynamic control information than objects under pathfoo products2 . The content realm ID might be derived from the user agent header field such that a client Windows machine matches to a different content realm and thus warrants different dynamic control information than a client machine running another operating system for example or such that a wireless client matches to a different content realm than a desktop PC.

Fetched dynamic control information is preferably cached locally at the CDN server after it is received from the remote host . Thus in one embodiment the CDN server will pull needed dynamic control information from the remote host the first time that a client request necessitates it. For example the information needed to respond to a request for a particular HTML file will be retrieved and cached note that the control information needed to handle requests for embedded objects in the HTML file and or for other likely to be requested HTML files might be pre fetched at the same time . For subsequent requests by the same or another client device the CDN server can use the locally cached information. The local cache entries can be associated with a time to live TTL so that the CDN server periodically refreshes dynamic control information . Preferably the refreshing of the information is synchronous to client requests as described above. However in alternate embodiments this periodic refresh of dynamic control information may be asynchronous to the client requests.

Local caching does not require storing dynamic control information for all objects or for all parties served by the CDN. Rather the CDN server preferably retrieves only the dynamic control information necessary to respond to the particular client content requests that it is receiving caching the data as space permits and evacuating old entries the cache with a least recently used or other cache management algorithm. The CDN server is typically one of many in the CDN and typically sees some portion of the overall traffic. This means that mapping and load balancing algorithms implemented with the CDN which spread client content request load amongst various CDN servers in the platform will concomitantly result in spreading the load of requesting and storing dynamic control information and provide a scalable solution for the metadata control infrastructure. Put another way in a preferred embodiment the load for dynamic control information will follow load for client content requests.

For example U.S. Pat. No. 6 108 703 describes in one embodiment a method for intelligently routing and replicating content over a large network of distributed servers. The teachings of U.S. Pat. No. 6 108 703 are hereby incorporated by reference in their entirety.

The foregoing is by way of example only. Any mapping traffic shaping load balancing or similar policy in the network can be leveraged. Further it should be noted that it is possible to impose a policy for the dynamic control information that differs from the policies in place for the client content requests e.g. it may be desirable in certain situations to push or pre populate dynamic control information to certain regions of CDN servers in a way that is not related to how objects are distributed .

In one embodiment the system can be used to purge on demand objects cached in the CDN servers. Purging objects involves invalidating them e.g. marking their TTL as expired so that they are not served from the CDN server s cache in response to client requests but instead are retrieved from or revalidated from the origin source server thus refreshing the cache.

For example for a given content request for a particular object the CDN server can execute an invalidate function defined in the associated metadata configuration file . The function can determine whether the requested content should be purged and depends on a late bound parameter from the remote host . In this way the purge function can be at least in one embodiment accomplished selectively and quickly as it will take effect once the database on the remote host is updated.

In one implementation a function in the metadata configuration file takes as a parameter an identifier for an object or set of objects e.g. the identifier may be a URI pointing to a specific object or a URI path with wildcard pathfoo covering objects in that path and sets the TTL of the identified object s to be expired. The late bound parameter is pulled from the remote host . The remote host responds with the particular URI causing the function to set the objects cached under the particular returned URI to expired. This technique can be used to purge not only the requested object but other objects at the same time.

In another implementation the function in the metadata configuration file expects a Boolean true false and sets the TTL of the requested object to expired or not depending on the answer. The CDN server sends a content realm ID to the remote host comprising an object URI or other identifier. The remote host looks up the object URI or other identifier among URIs or other identifiers that have been designated in the database for purging and returns true if a match is found.

These are just two of a variety of possible implementations and are provided merely for illustrative purposes. is a flowchart illustrating the first implementation of the purge process described above.

Referring to in one embodiment the traffic for dynamic control information that flows between the CDN server s and the remote host can be logged measured and used for billing purposes. Hence the more complex the configuration for a particular customer s websites and other digital properties the more they might be charged.

In an alternate embodiment the dynamic control information at the remote server is embodied in a content policy document with embedded logic that enables the remote host to return for a given content realm ID different answers that depend on other data that the CDN server sends with the SPI request. This additional layer adds a further dimension of control to the infrastructure.

In one use case the dimension ID could be a geographical identifier or country name derived from the client IP address by the CDN server . Then the category could represent a geographical region allowing a website owner to configure the site to respond differently for different regions based essentially on data injected into the flow at the CDN server . Similarly the CDN server might inject data about the requesting client device e.g. its browser screen size support for certain software support for touchscreen whether it is a mobile device etc. as the dimension ID which the CDN server can determine based on the user agent or other header in the client s content request. The dimension ID might also be representative of the client s connectivity e.g. broadband mobile etc. as measured by the CDN server or as otherwise determined.

As shown in a variety of logic and functionality can be included in the policy document. This logic is evaluated by the remote host taking the inputted data the dimension ID s and returning control information .

As noted previously with respect to in some embodiments the late bound dynamic control information may include functions or logic. Such functions and logic can be transmitted to the CDN server bound to the appropriate metadata configuration file reference and executed by the CDN server to help determine how to handle the traffic.

Such dynamic control information may have a dependency on any of a wide range of information known at the CDN server . Examples include information the CDN server obtains from a HTTP request header field request method request URI or portion thereof information in a cookie a time of day a geography associated with the client information about the client device e.g. such as screen or operating system or OS installed and derived from an HTTP user agent header or otherwise client bandwidth information and so on.

For example as is known a metadata logical component can be written in XML and can instruct the CDN server to take certain actions or apply certain CDN features when certain metadata conditions are met. The metadata might also employ a scripting language or other desired instruction sets or program language. U.S. Pat. No. 7 240 100 mentioned earlier and incorporated by reference describes a metadata component that rewrites an origin request URI based on the CDN server s knowledge of the client s bandwidth. If this component is active requests from clients identified as high bandwidth are rewritten accordingly e.g. from foo bar.gif to foo bar.hi.gif Request from clients identified as low bandwidth preferably are not rewritten.

According to the teachings hereof the dynamic control information may be metadata logic such as the above conditional rewrite logic. More specifically the metadata configuration file shown in can contain a reference to dynamic control information which would represent a chunk of code e.g. XML or otherwise instructing the CDN server to effect the conditional high low bandwidth rewrite on requests from clients.

As another example consider the HTTP referrer check function discussed previously and assume that it is desired to have the HTTP referrer check functionality applied only to image objects that is only for client requests for images are checked to see if the referring URI is a valid one . The metadata in the configuration file might specify that a client request is to be denied if it fails the referrer check and reference dynamic control information for how to execute the referrer check logic. The late bound logic could contain code that instructs the CDN server to apply a referrer check only if the request is for a certain image type e.g. jpg gif etc. and indicate that the referrer check is otherwise has been satisfied i.e. it is unnecessary. In case the request is for an image the logic could also supply the values for the whitelist e.g. the hostnames IP addresses etc. that are on the whitelist for evaluation by the CDN server against the actual client request. Thus both the way that the referrer check functionality operates and the values data that it relies on can be specified on a per content realm basis and obtained by the CDN server as needed.

The foregoing referrer check functionality may be implemented in one embodiment by having the logic expressed in a chunk of code in the same language as the metadata configuration file e.g. XML . The metadata configuration file would contain a reference to the dynamic control information and in response the CDN server would obtain the referenced chunk of XML code and insert it inline into the configuration file in this case also XML executing it as it does the remainder of the configuration file

Complex units of dynamic control information may be thought of as content policies. In effect the remote host stores a content policy represented by dynamic control information for a given content realm ID and the CDN server executes the logic to enforce that content policy. The policy may both set the value of variables in the configuration file and provide functions and logic.

A content policy can be implemented using the syntax and structure described below in which the dynamic control information is referred to as a content policy encoded as a policy assertion resource. Here is an example of a protobuf file format for use in generating and sending policy assertion resources 

The root Envelope message contains a content policy which lists policies and taxonomies that categorize traffic e.g. request messages from clients responses from origin servers or other messages being processed at the server into categories and subcategories. In this example the Envelope also includes a version a generation id that acts as a handle for a class of content policies e.g. to enable revocation of a given class of policies all at once a content realm to verify that the content policy is indeed for the content realm that was requested from the remote host and a signature with a key and some data that can be used to verify the authenticity of the policy.

A policy contains a set of rules each rule has a category path selector and a list of name value pairs that define the outcome for that selector match e.g. by setting the named variable to the specified value. The specified value of the variable can then be used by the CDN server when evaluating the metadata configuration file and encountering any references to that variable. Thus the categorization of traffic using taxonomies and application of rules selectors can be used to effect logic representing dynamic control information as described previously.

A selector may contain wildcards so would mean any category protected would mean any category that has a subcategory protected that matches. The lack of a selector means the policy applies to all traffic which can be the same as but more efficient. A selector forces the evaluation of category conditions. A category has a list of conditions that all have to be true except for conditions marked as NEGATED which have to be false.

Category trees are segmented into mutually exclusive taxonomies. One can use the URI syntax of to dereference the taxonomy in a selector for example europe images . In case of the absence of in the URI the first taxonomy is assumed.

Selectors can combine multiple category path URIs with the following Boolean operators AND OR NOT. Parentheses and can be used as part of the Boolean expression.

In operation the CDN server pulls a particular policy from the remote host and enforces the policy by evaluating the selector and the conditions traffic categories on which it depends thereby setting variables and the like. As before preferably the remote host stores many different policies with their own potentially different selectors conditions variable values etc. and returns a particular policy based on a content realm ID presented by the CDN server which policy is then evaluated. 

The above code implements a REFERRER CHECK policy that is subject to a rule with a selector named images indicating that the WHITE LIST values shall apply to traffic that meets the condition of being image traffic i.e. falling within the image category of traffic . The images category is defined in the taxonomy to be traffic with a .jpg .gif or .png file extension in the requested URI in the client request.

The corresponding metadata configuration file could contain the following XML code referencing the policy 

Thus the metadata inside the is executed when the REFFERER CHECK policy evaluates to true i.e. the traffic is for an image. The embedded evaluates whether the current client request has a referrer header that is on the whitelist with the value of the variable whitelist having been set by the REFFERER CHECK policy. If not then the embedded traffic denial function is executed to deny the client request.

As another example consider a policy that specifies when to take particular action and does not set the value of a whitelist or other variable. The particular action might be to deny the traffic e.g. deny a particular client request at the CDN server for example. The action is either performed or not performed based on the evaluation of the policy.

By way of illustration below is an excerpt of a configuration file containing a reference to such a policy in XML format 

If the UNAUTHORIZED REQUEST policy rules evaluates to true the traffic will be denied per the encapsulated tag for auth traffic.deny. There are no variables for the policy to set in this example.

This policy has defined a selector that the CDN server will need to resolve evaluate . As mentioned if the selector evaluates to true the action traffic.deny will be applied to the message at hand e.g. the client request otherwise not.

The selector rule is dependent on two arbitrary namespaces that have been declared for traffic categories specifically host and country under the authz taxonomy a namespace of authorizations . The host and country namespaces are conditional classes of traffic and the CDN server must evaluate the conditions. In this case the author of the content policy has decided to create the authz taxonomy which includes one category of traffic for authorized Host headers host and another category of traffic for authorized client countries country . In this example REQUEST HOST and GEOGRAPHY are types of conditional computation performed by the CDN server that the customer is entitled to as part of their product definition contract.

In sum traffic that is for an unauthorized host or from an unauthorized country causes the rule selector to evaluate to true which is reflected in the metadata configuration file and causes the execution of the deny function and thus the CDN server denies the given request.

In this example the policy effectively acts a firewall rule determining under what circumstances the deny function should be invoked. The policy as dynamic control information is obtained by the CDN server when needed and can be changed while keeping the metadata configuration file static. Further since a different policy can be maintained for each content realm ID the above approach enables one version of metadata configuration file to be linked to and apply multiple firewall policies. For example a configuration file for a given cloud provider can be linked to a variety of custom policies for the cloud provider s cloud customers with the content realm ID identifying each cloud customer.

In some embodiments the techniques described herein can be leveraged to create a request processing layer that can validate authenticate authorize and or perform other processing on client requests. This layer can be implemented in a given CDN server enabling a set of geographically distributed CDN servers to serve as a distributed request processing gateway to resources behind them. For convenience of description this validation authentication authorization layer will be referred to herein as a VAA layer although not all these functions need be performed in every implementation. The resources behind this layer are preferably CDN platform resources with the VAA layer fronting access to platform machines. For example a CDN typically provides tools for provisioning and configuring the CDN platform that enable a CDN user to provision and configure CDN features services for their websites web applications and other digital properties being delivered on their behalf over the CDN. A CDN also might offer shared storage resources e.g. NetStorage shared computing resources e.g. multi tenant shared computing and other shared infrastructure and services. Note that a CDN user in this context might be a direct CDN customer a cloud provider or a cloud provider s customer. In these cases the CDN itself will often define the content policies and other dynamic control information for use in managing access to resources it provides rather than the CDN user defining a content policy for e.g. delivery of its content over the CDN.

When a CDN user wants to make a request to such resources the VAA layer in a given CDN server can perform request validation authentication and authorization on the given request before transmitting it to the appropriate machine within the platform that will actually fulfill the request for the resource e.g. by returning a requested object a requested result of a particular command etc. Typically the resource is accessed using a client application that makes requests to an application programming interface API for accessing the given resource that has been made available by the CDN to the CDN user. The machine that actually provides the resource in response to the API calls is referred to herein as the API origin server or API origin.

As one skilled in the art will understand an API often acts as a wrapper around a service database or system made by one team of programmers for another team. In a general sense an API is often realized as a documented set of calls that come with a definition on how they will behave and usually the data they will return. In the context of the web an API often comprises a pattern of HTTP requests understood at a certain domain or URL path that will act inside the recipient system and with connected systems and return information back out to the web client or take an action and report a result back to the client. Data is often passed into a web API using GET and POST or other HTTP calls and returned from the web API using XML or JSON other open formats or proprietary formats. Of course APIs outside of the HTTP context are also possible.

Thus for example assume a given CDN user wants to provision and or configure some feature of the CDN that affects e.g. the delivery of content on its website web application or other digital property. The CDN user can utilize a client application to transmit an API request to the appropriate API endpoint e.g. available at a particular URL . Via known DNS aliasing techniques e.g. CNAME and mapping techniques the client application can be directed to send the request to a particular CDN server . The client API request can be received at the edge by the CDN server and VAA layer functions can be performed to create a verified forward request from the CDN server to the appropriate API origin. The API origin is then relieved of the functions already performed by the VAA layer.

Similarly if a given CDN user wants to upload change or view content on a network storage resource using the CDN s storage API the CDN user client application can transmit an API request to the appropriate API endpoint for such storage resources. The request can be received at the edge by CDN server where validation authentication authorization and other functions can be performed to create a verified forward request from the CDN server to the storage platform or more specifically to the storage platform s API origin.

Likewise if a given CDN customer wants to send data to an application hosted by the computing platform provided by the CDN the request can be received at the CDN server and authentication authorization validation and other functions can be performed to create a verified forward request from the CDN server to the computing platform s API origin.

In one embodiment the VAA layer described above can be implemented in a CDN server by using information in a metadata file to define certain information that may not be changed often or for which there are not a high number of possible values. Examples might include a list of API endpoints e.g. URLs recognized at the machine how to forward the request and the like. Dynamic control information can be used to supply at request time information that is desired to be highly dynamic more easily changeable or rotatable and or of high cardinality. Such kinds of data might include credentials for a given client application the resource model for a given API endpoint authentication and or authorization secrets needed to for authentication authorization algorithms access policies for client applications and the like more examples will be described below. It should be understood that no particular functional allocation or apportionment between the slowly changing periodically updated control information in the configuration file and the dynamic control information is required or contemplated as the allocation of particular functions to one or the other will vary with the design requirements and implementation.

The use of dynamic control information for a VAA type functions can be advantageous in that among other things the dynamic control information can be changed easily e.g. periodically rotating secrets or changing access policies and such information does not need to reside on every CDN server but rather only where needed since it will be cached based on pull based approach offering a scalable front end to CDN services thus providing a scalable architecture. The VAA layer also provides offload for the underlying API origins and a measure of attack protection e.g. against DDOS attacks .

By way of further illustration in one embodiment a given request to an API can be evaluated in a given CDN server in stages using various components 

At each stage the content policy agent can fetch dynamic control information to apply or can obtain locally cached versions thereof if not stale . The content policy agent can fetch on the basis of a reference to the components above in a metadata configuration file and based on a content realm ID that is extracted from the client request or based on other information available to the CDN server at the time of processing the API request. For example for a given client application associated with a particular CDN user a different set of policies might apply for each type of service that they try to use. Thus the client s call to an API at user1.purge.cdn.com foo can be treated differently than user1.upload.cdn.com foo. This is merely an example.

Turning to the particular routines in more detail is an illustration of a request validation process in one embodiment. In this stage the CDN server can parse the client request checking that the request has the form and substance to constitute a valid request to a valid API endpoint and that the request is seeking to interact with the API in a way that will be allowed and recognized by the API. Note that while not limiting follow HTTP conventions so error codes are intended to refer to HTTP error codes headers refer to HTTP headers etc.

In the flow illustrated in the CDN server receives a client request directed to a particular API endpoint or service. Box The server can perform a variety of general checks such as whether the endpoint is a valid endpoint whether the request has necessary headers or other information and whether it has supported correct signing algorithms and has a valid timestamp to prevent replay attacks. It also can check tokens in the request to ensure they are in a proper format and have not been tampered with. Examples of tokens in a request include tokens corresponding to a user a client application user group and or access to a particular set of services.

In box of the CDN server fetches dynamic control information preferably in the form of a content policy. The policy fetched in is referred to as an API endpoint content policy. The content realm ID used to fetch this content policy might be a variety of things as the approach is flexible but by way of illustration the content realm ID in this situation might be the particular API endpoint that was requested e.g. the domain and or possibly other component of the requested URL . The API endpoint content policy can provide such information such as the resource model for the particular API endpoint including what request methods are supported by the requested API whether the requested resource is valid e.g. whether the particular URL path and query parameters are valid what other arguments parameters data might be needed and whether they are present in the request certain parameters and limits such as maximum size of a POST body that may have been specified for this user as well as what are supported HTTP methods.

Preferably the API endpoint content policy contains algorithms to compare the model to the contents of the pending request. In other words the API endpoint content policy can be executed to determine whether the given client request conforms to what the API origin will expect. In the endpoint content policy is executed and if the request is determined to be valid the validation routine canonicalizes request headers and calls a client authentication routine. 

The CDN server can use the credentials provided by the credential content policy to authenticate the client request. As one skilled in the art will appreciate a variety of authentication mechanisms and approaches can be employed using the credentials. The ability of the CDN server to fetch and have at authentication time a set of credentials for the given client as defined in the dynamically obtained credential content policy means that it can perform a variety of checks using narrowly scoped credentials for use in client request decryption client request signature calculation and verification and or other processes as part of authentication.

Note that the client credential policy can also contain instructions for the CDN server to make authentication dependent on some other piece of data available to the server at client request time such as a client IP address geography cookie etc. Hence a client IP address that is not on a whitelist which is provided by the content policy can result in an overriding determination that the client is not authentic. The client credential policy can leverage a client IP reputation module in the CDN server instructing the CDN server to obtain the reputation score of the particular client IP address and to make an overriding authentication determination based on the returned score. This is merely an example to illustrate the flexibility and power of using dynamic control information in this case in the form of a credential content policy for authentication. The authorization routine may be called at upon completion of authentication.

The authorization routine begins at box when the client request is forwarded from the authentication routine. The authorization routine retrieves an authorization content policy from one of many at a remote host. An example of a content realm ID for retrieving the authorization routine might be for example the value of a client access token that was provided in the request. Data obtained in prior routines e.g. data in the fetched endpoint and client credential content policies might also be used and or combined with information from the request to define a content realm ID. The authorization content policy preferably determines whether the particular client is allowed the access to a resource that it is implicitly asking for with its request. The authorization content policy could contain logic to return for example a Boolean value indicating whether access is allowed. As mentioned with respect to the client credential policy the authorization content policy can be used to enforce authorization policies dependent on a variety of data available to the CDN server fielding the client request. For example such data might include request token client IP API endpoint request method and request parameters geography e.g. derived from client IP address time of day request method cookie value and the like. Those can be used to make authorization decisions as set forth by logic in the dynamically obtained content policy. As a result the authorization content policy can be used to enforce different authorization scope on a CDN user by user basis on the basis of roles within a CDN user s organization on the basis of particular client applications and so on.

Returning to following a determination that the client has the required scope to make the client request a request decoration routine can be invoked. Request decoration can involve adding headers or other information to the client request prior to sending it to the API origin. As with other processing request decoration can be driven by dynamic control information which in is in the form of a request decoration policy. This policy can provide data and or logic that instructs the CDN server how to decorate a client request before forwarding it to a particular API origin in the CDN platform. For example the decoration policy can supply appropriate headers to add to the request e.g. given the particular API endpoint and particular data from the request and or can append additional identity information as to who is requesting service information about the CDN server that processed the client request for tracking or auditing purposes and so on. The request can also be decorated with signatures from the CDN server to indicate successful validation authentication and or authorization so that this signature can be verified later by the API origin.

After the request decoration processing is finished the decorated client request can be sent to the API origin as was illustrated previously in . The CDN server may encapsulate the client request and send it to the API origin in a message using a separately encrypted and authenticated channel dedicated to CDN server and API origin communication. The CDN server can look up the appropriate API origin for the API endpoint. The result of this lookup may yield a DNS hostname for the API origin which the CDN server can then look up in the DNS system to determine a particular API origin machine to which to send the request.

While the description above has focused on accessing CDN provided resources through a CDN server enabled with dynamic control information it should be appreciated that in other embodiments the same techniques can be used to provide a distributed VAA layer as a service for CDN customers. The CDN can provide a set of CDN servers with an VAA layer driven by customer defined content policies and the API origin can be the customer s own origin server e.g. a public facing website or alternatively part of their enterprise infrastructure . The customer origin server may still perform its own additional validation authentication authorization if desired but the CDN servers can provide a distributed front end that provides offload and a measure of security and protection from attack e.g. distribute denial of service attacks . The customer origin servers can then be configured to accept API requests only from CDN servers providing the VAA layer using the teachings of U.S. Pat. No. 7 260 639 titled Method and system for protecting web sites from public internet threats the teachings of which are incorporated by reference in their entirety.

The complexity of the logic that can be expressed with content policies and other forms of dynamic control information may vary widely across CDN users. Thus in some embodiments the CDN can charge customers based on the complexity of the policy that they wish to have the CDN server enforce. In other words the computing cost of the control information for a given user is the basis for billing on the CDN platform.

Preferably the unit of measure for cost is central processing unit CPU cycles so as to reflect the complexity of the instruction that the CPU must execute with the data that on which it is performing the instruction and to reflect the cost in a way independent of the clock frequency at which the processor is running. Preferably the CDN server logs a transaction along with the CPU cycles associated with evaluating content policies. In the examples above a policy will generally invoke a tag which in turn evaluates rule selectors which in turn evaluate traffic category conditions. The CPU cycles spent on the thread executing the match tag is recorded and aggregated. This can then be used for billing purposes.

Tracking the number of CPU cycles spent executing the policy also has another purpose to determine if the policy is taking too many computing resources as evidenced by exceeding a pre defined and configurable CPU cycle maximum limit. Policies that exceed the limit can be aborted for CDN server safety purposes.

Preferably the cost of determining the CPU cycles spent evaluating a particular policy is performed in a cheap way from a computing perspective so that it does not significantly interfere with or affect the traffic related duties of the CDN server . Further preferably the computation of the CPU cycle metric is generally consistent on the same machine OS or capable of being normalized across disparate environments.

In one embodiment CPU cycles can be measured by reading a CPU cycle count register which provides a cycle count for a given CPU. On x86 and Intel processors this register is called the Time Stamp Counter TSC register. Other kinds of processors provide registers that can be used similarly. The TSC is 64 bit register. It is read using the rdtsc instruction. The rdtsc instruction returns in about eight nanoseconds the number of CPU cycles elapsed however the value is specific to the CPU and not to the executing user thread so execution in other threads artificially inflate the value.

When applying a policy at the CDN server the operation is preferably performed in a serialized manner on one of the CPUs. While performing the operation a CPU cycle count reading from TSC is taken before during and after the execution of the policy. Frequent readings of TSC are taken during the application of the rule expressions and condition evaluations and these readings are accumulated. In one implementation for example a reading is taken about every ten condition evaluations.

By taking frequent readings it becomes easier to implement a strategy of enforcing a maximum CPU cycle limit for policy application. It also becomes easier to identify and or remove outlier CPU readings caused by infrequent thread context switches that are not easily eliminated when running software in user space. For example the frequency of the readings enables one to detect large spikes caused by a thread context switch and filter them out.

The result is a more accurate measure of computational effort in a heterogenous environment that allows for usage based billing and that facilitates the enforcement of limits on policy computations in order to provide service quality guarantees across CDN users. The CDN service provider can define such limits in order to manage its platform and prevent execution of a particular content policy from excessively consuming a CDN server s resources.

Even if read frequently however the TSC may not be sufficiently accurate because of the off thread execution problem identified above. Hence another embodiment for measuring the number of CPU cycles m reading the TSC register as above and adapting the operating system kernel to identify and capture the CPU cycle count when a context switch occurs. The kernel can make these count markers available to the process that is calculating the CPU cost so that the inapplicable off thread CPU cycles can be eliminated deducted from the TSC count reducing the error associated with context switches.

Yet another embodiment for measuring CPU cycles involves using a combination of counters. In this embodiment the counters are the Time Stamp Counter TSC described above and a Performance Counter for Linux PCL which is a monitoring interface available for the Linux kernel e.g. in versions 2.6.31 and later . PCL supports a method of getting per thread CPU cycle measurements using a kernel API. Using PCL involves opening an instance to the API for the thread of interest the thread executing the content policy calling RESET and ENABLE and then periodically taking readings with a system read call. Reading TSC involves less computing cost that reading PCL but PCL can be more accurate because it is specific to a given thread whereas the TSC is not and therefore can give an artificially high reading as noted previously.

Assuming the CPU cycle limit is not reached eventually the execution of the policy finishes normally. The PCL is read at the end to accurately calculate total CPU cycles spent on execution of the content policy match PLC End minus PLC Start . and . This number is used for logging and billing purposes.

Preferably in addition to logging the CPU cycle count the CDN server also logs the machine type to provide a better context of how the CPU count value relates to time spent e.g. the MHz GHz rating and CPU number type of the machine and potentially other hardware characteristics . Given the CPU cycle count and these metrics the actual processing time spent can be calculated.

It should be noted that other techniques for determining computing cost can be used in certain implementations depending on design goals and billing approaches. For example the clock gettime and gettimeofday functions are also available although these generally consume more CPU time than for instance the rdstc register technique.

Further it should be noted that other approaches may be used to charge for the execution of the dynamic control information such as measuring the size of the control information retrieved policy size the number of conditional or other statements policy complexity and or measuring the amount of traffic between the CDN server and the remote host created by fetching the policies policy traffic .

The subject matter described herein may be implemented with computer systems as modified by the teachings hereof with the processes and functional characteristics described herein realized in special purpose hardware general purpose hardware configured by software stored therein for special purposes or a combination thereof.

Software may include one or several discrete programs. A given function may comprise part of any given module process execution thread or other such programming construct. Generalizing each function described above may be implemented as computer code namely as a set of computer instructions executable in one or more microprocessors to provide a special purpose machine. The code may be executed using conventional apparatus such as a microprocessor in a computer digital data processing device or other computing apparatus as modified by the teachings hereof. In one embodiment such software may be implemented in a programming language that runs in conjunction with a proxy on a standard Intel hardware platform running an operating system such as Linux. The functionality may be built into the proxy code or it may be executed as an adjunct to that code.

While in some cases above a particular order of operations performed by certain embodiments is set forth it should be understood that such order is exemplary and that they may be performed in a different order combined or the like. Moreover some of the functions may be combined or shared in given instructions program sequences code portions and the like. References in the specification to a given embodiment indicate that the embodiment described may include a particular feature structure or characteristic but every embodiment may not necessarily include the particular feature structure or characteristic.

Computer system includes a processor coupled to bus . In some systems multiple microprocessor and or microprocessor cores may be employed. Computer system further includes a main memory such as a random access memory RAM or other storage device coupled to the bus for storing information and instructions to be executed by processor . A read only memory ROM is coupled to the bus for storing information and instructions for processor . A non volatile storage device such as a magnetic disk solid state memory e.g. flash memory or optical disk is provided and coupled to bus for storing information and instructions. Other application specific integrated circuits ASICs field programmable gate arrays FPGAs or circuitry may be included in the computer system to perform functions described herein.

Although the computer system is often managed remotely via a communication interface for local administration purposes the system may have a peripheral interface communicatively couples computer system to a user display that displays the output of software executing on the computer system and an input device e.g. a keyboard mouse trackpad touchscreen that communicates user input and instructions to the computer system . The peripheral interface may include interface circuitry and logic for local buses such as Universal Serial Bus USB or other communication links.

Computer system is coupled to a communication interface that provides a link between the system bus and an external communication link. The communication interface provides a network link . The communication interface may represent an Ethernet or other network interface card NIC a wireless interface modem an optical interface or other kind of input output interface.

Network link provides data communication through one or more networks to other devices. Such devices include other computer systems that are part of a local area network LAN . Furthermore the network link provides a link via an internet service provider ISP to the Internet . In turn the Internet may provide a link to other computing systems such as a remote server and or a remote client . Network link and such networks may transmit data using packet switched circuit switched or other data transmission approaches.

In operation the computer system may implement the functionality described herein as a result of the processor executing code. Such code may be read from or stored on a non transitory computer readable medium such as memory ROM or storage device . Other forms of non transitory computer readable media include disks tapes magnetic media CD ROMs optical media RAM PROM EPROM and EEPROM. Any other non transitory computer readable medium may be employed. Executable code may also be read from network link e.g. following storage in an interface buffer local memory or other circuitry .

