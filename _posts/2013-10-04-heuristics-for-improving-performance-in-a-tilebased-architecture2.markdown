---

title: Heuristics for improving performance in a tile-based architecture
abstract: One embodiment of the present invention includes a technique for processing graphics primitives in a tile-based architecture. The technique includes storing, in a buffer, a first plurality of graphics primitives and a first plurality of state bundles received from a world-space pipeline, and transmitting the first plurality of graphics primitives to a screen-space pipeline for processing while a tiling function is enabled. The technique further includes storing, in the buffer, a second plurality of graphics primitives and a second plurality of state bundles received from the world-space pipeline. The technique further includes determining, based on a first condition, that the tiling function should be disabled and that the second plurality of graphics primitives should be flushed from the buffer, and transmitting the second plurality of graphics primitives to the screen-space pipeline for processing while the tiling function is disabled.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09542189&OS=09542189&RS=09542189
owner: NVIDIA Corporation
number: 09542189
owner_city: Santa Clara
owner_country: US
publication_date: 20131004
---
This application claims benefit of U.S. provisional patent application Ser. No. 61 719 271 filed Oct. 26 2012 and titled An Approach for Tiled Caching. The subject matter of this related application is hereby incorporated herein by reference.

Embodiments of the present invention relate generally to graphics processing and more specifically to heuristics for improving performance in a tile based architecture.

Various graphics systems implement a tiling architecture that divides the screen space into tiles and processes data associated with each tile in a particular order. That is data associated with a first tile is processed first data associated with a second tile is processed second and so on. In such graphics systems a highly parallel architecture may be implemented such that the work associated with one or more tiles is distributed to different processing entities.

In one approach to distributing work in a highly parallel architecture graphics data received from a world space pipeline is buffered prior to being transmitted to a number of different processing entities in one or more screen space pipelines. By buffering the graphics data the graphics data can be sorted and transmitted to the screen space pipeline according to the tile s with which the graphics data is associated. Consequently the graphics data can be distributed to and processed by the one or more screen space pipelines in a more efficient manner. As an example graphics data may be buffered and analyzed to determine the most efficient order in which to process the data and or to determine which processing entities can process the data most efficiently.

One drawback to buffering graphics data as described above is that under certain circumstances buffering graphics data may negatively impact processing efficiency. For example in some cases buffering certain types of graphics data may consume resources e.g. shared memory in a graphics system such that insufficient resources are available when rendering operations are later performed with respect to the buffered graphics data. As a result overall processing efficiency may be decreased.

In addition under certain circumstances dividing the screen space into tiles and processing data associated with each tile in a particular order may be less efficient than simply processing data in the original order specified by the application programming interface API . For example dividing the screen space into tiles may increase the overhead associated with processing certain types of graphics data to the point where tile based processing is less efficient than simply processing the data according to the original API order.

As the foregoing illustrates what is needed in the art are more effective approaches to implementing tiling functionality in graphics processing systems.

One embodiment of the present invention includes a method for processing graphics primitives in a tile based architecture. The method includes storing in a buffer a first plurality of graphics primitives received from a world space pipeline and a first plurality of state bundles associated with the first plurality of graphics primitives and received from the world space pipeline. The method further includes transmitting the first plurality of graphics primitives to a screen space pipeline for processing while a tiling function is enabled. The method further includes storing in the buffer a second plurality of graphics primitives received from the world space pipeline and a second plurality of state bundles associated with the second plurality of graphics primitives and received from the world space pipeline. The second plurality of graphics primitives and the second plurality of state bundles are received from the world space pipeline after the first plurality of graphics primitives and the first plurality of state bundles. The method further includes determining based on a first condition that the tiling function should be disabled and that the second plurality of graphics primitives should be flushed from the buffer and transmitting the second plurality of graphics primitives to the screen space pipeline for processing while the tiling function is disabled.

One advantage of the disclosed techniques is that tiling can be enabled and disabled in an intelligent manner in order to reduce overhead in the processing pipeline. In addition when tiling is enabled the buffering of graphics primitives and associated state can be controlled to further decrease overhead in the processing pipeline and as a result decrease power consumption of the graphics system.

In the following description numerous specific details are set forth to provide a more thorough understanding of the present invention. However it will be apparent to one of skill in the art that the present invention may be practiced without one or more of these specific details.

In operation I O bridge is configured to receive user input information from input devices such as a keyboard or a mouse and forward the input information to CPU for processing via communication path and memory bridge . Switch is configured to provide connections between I O bridge and other components of the computer system such as a network adapter and various add in cards and .

As also shown I O bridge is coupled to a system disk that may be configured to store content and applications and data for use by CPU and parallel processing subsystem . As a general matter system disk provides non volatile storage for applications and data and may include fixed or removable hard disk drives flash memory devices and CD ROM compact disc read only memory DVD ROM digital versatile disc ROM Blu ray HD DVD high definition DVD or other magnetic optical or solid state storage devices. Finally although not explicitly shown other components such as universal serial bus or other port connections compact disc drives digital versatile disc drives film recording devices and the like may be connected to I O bridge as well.

In various embodiments memory bridge may be a Northbridge chip and I O bridge may be a Southbrige chip. In addition communication paths and as well as other communication paths within computer system may be implemented using any technically suitable protocols including without limitation AGP Accelerated Graphics Port HyperTransport or any other bus or point to point communication protocol known in the art.

In some embodiments parallel processing subsystem comprises a graphics subsystem that delivers pixels to a display device that may be any conventional cathode ray tube liquid crystal display light emitting diode display or the like. In such embodiments the parallel processing subsystem incorporates circuitry optimized for graphics and video processing including for example video output circuitry. As described in greater detail below in such circuitry may be incorporated across one or more parallel processing units PPUs included within parallel processing subsystem . In other embodiments the parallel processing subsystem incorporates circuitry optimized for general purpose and or compute processing. Again such circuitry may be incorporated across one or more PPUs included within parallel processing subsystem that are configured to perform such general purpose and or compute operations. In yet other embodiments the one or more PPUs included within parallel processing subsystem may be configured to perform graphics processing general purpose processing and compute processing operations. System memory includes at least one device driver configured to manage the processing operations of the one or more PPUs within parallel processing subsystem .

In various embodiments parallel processing subsystem may be integrated with one or more other elements of to form a single system. For example parallel processing subsystem may be integrated with CPU and other connection circuitry on a single chip to form a system on chip SoC .

It will be appreciated that the system shown herein is illustrative and that variations and modifications are possible. The connection topology including the number and arrangement of bridges the number of CPUs and the number of parallel processing subsystems may be modified as desired. For example in some embodiments system memory could be connected to CPU directly rather than through memory bridge and other devices would communicate with system memory via memory bridge and CPU . In other alternative topologies parallel processing subsystem may be connected to I O bridge or directly to CPU rather than to memory bridge . In still other embodiments I O bridge and memory bridge may be integrated into a single chip instead of existing as one or more discrete devices. Lastly in certain embodiments one or more components shown in may not be present. For example switch could be eliminated and network adapter and add in cards would connect directly to I O bridge .

In some embodiments PPU comprises a graphics processing unit GPU that may be configured to implement a graphics rendering pipeline to perform various operations related to generating pixel data based on graphics data supplied by CPU and or system memory . When processing graphics data PP memory can be used as graphics memory that stores one or more conventional frame buffers and if needed one or more other render targets as well. Among other things PP memory may be used to store and update pixel data and deliver final pixel data or display frames to display device for display. In some embodiments PPU also may be configured for general purpose processing and compute operations.

In operation CPU is the master processor of computer system controlling and coordinating operations of other system components. In particular CPU issues commands that control the operation of PPU . In some embodiments CPU writes a stream of commands for PPU to a data structure not explicitly shown in either or that may be located in system memory PP memory or another storage location accessible to both CPU and PPU . A pointer to the data structure is written to a pushbuffer to initiate processing of the stream of commands in the data structure. The PPU reads command streams from the pushbuffer and then executes commands asynchronously relative to the operation of CPU . In embodiments where multiple pushbuffers are generated execution priorities may be specified for each pushbuffer by an application program via device driver to control scheduling of the different pushbuffers.

As also shown PPU includes an I O input output unit that communicates with the rest of computer system via the communication path and memory bridge . I O unit generates packets or other signals for transmission on communication path and also receives all incoming packets or other signals from communication path directing the incoming packets to appropriate components of PPU . For example commands related to processing tasks may be directed to a host interface while commands related to memory operations e.g. reading from or writing to PP memory may be directed to a crossbar unit . Host interface reads each pushbuffer and transmits the command stream stored in the pushbuffer to a front end .

As mentioned above in conjunction with the connection of PPU to the rest of computer system may be varied. In some embodiments parallel processing subsystem which includes at least one PPU is implemented as an add in card that can be inserted into an expansion slot of computer system . In other embodiments PPU can be integrated on a single chip with a bus bridge such as memory bridge or I O bridge . Again in still other embodiments some or all of the elements of PPU may be included along with CPU in a single integrated circuit or system of chip SoC .

In operation front end transmits processing tasks received from host interface to a work distribution unit not shown within task work unit . The work distribution unit receives pointers to processing tasks that are encoded as task metadata TMD and stored in memory. The pointers to TMDs are included in a command stream that is stored as a pushbuffer and received by the front end unit from the host interface . Processing tasks that may be encoded as TMDs include indices associated with the data to be processed as well as state parameters and commands that define how the data is to be processed. For example the state parameters and commands could define the program to be executed on the data. The task work unit receives tasks from the front end and ensures that GPCs are configured to a valid state before the processing task specified by each one of the TMDs is initiated. A priority may be specified for each TMD that is used to schedule the execution of the processing task. Processing tasks also may be received from the processing cluster array . Optionally the TMD may include a parameter that controls whether the TMD is added to the head or the tail of a list of processing tasks or to a list of pointers to the processing tasks thereby providing another level of control over execution priority.

PPU advantageously implements a highly parallel processing architecture based on a processing cluster array that includes a set of C general processing clusters GPCs where C 1. Each GPC is capable of executing a large number e.g. hundreds or thousands of threads concurrently where each thread is an instance of a program. In various applications different GPCs may be allocated for processing different types of programs or for performing different types of computations. The allocation of GPCs may vary depending on the workload arising for each type of program or computation.

Memory interface includes a set of D of partition units where D 1. Each partition unit is coupled to one or more dynamic random access memories DRAMs residing within PPM memory . In one embodiment the number of partition units equals the number of DRAMs and each partition unit is coupled to a different DRAM . In other embodiments the number of partition units may be different than the number of DRAMs . Persons of ordinary skill in the art will appreciate that a DRAM may be replaced with any other technically suitable storage device. In operation various render targets such as texture maps and frame buffers may be stored across DRAMs allowing partition units to write portions of each render target in parallel to efficiently use the available bandwidth of PP memory .

A given GPCs may process data to be written to any of the DRAMs within PP memory . Crossbar unit is configured to route the output of each GPC to the input of any partition unit or to any other GPC for further processing. GPCs communicate with memory interface via crossbar unit to read from or write to various DRAMs . In one embodiment crossbar unit has a connection to I O unit in addition to a connection to PP memory via memory interface thereby enabling the processing cores within the different GPCs to communicate with system memory or other memory not local to PPU . In the embodiment of crossbar unit is directly connected with I O unit . In various embodiments crossbar unit may use virtual channels to separate traffic streams between the GPCs and partition units .

Again GPCs can be programmed to execute processing tasks relating to a wide variety of applications including without limitation linear and nonlinear data transforms filtering of video and or audio data modeling operations e.g. applying laws of physics to determine position velocity and other attributes of objects image rendering operations e.g. tessellation shader vertex shader geometry shader and or pixel fragment shader programs general compute operations etc. In operation PPU is configured to transfer data from system memory and or PP memory to one or more on chip memory units process the data and write result data back to system memory and or PP memory . The result data may then be accessed by other system components including CPU another PPU within parallel processing subsystem or another parallel processing subsystem within computer system .

As noted above any number of PPUs may be included in a parallel processing subsystem . For example multiple PPUs may be provided on a single add in card or multiple add in cards may be connected to communication path or one or more of PPUs may be integrated into a bridge chip. PPUs in a multi PPU system may be identical to or different from one another. For example different PPUs might have different numbers of processing cores and or different amounts of PP memory . In implementations where multiple PPUs are present those PPUs may be operated in parallel to process data at a higher throughput than is possible with a single PPU . Systems incorporating one or more PPUs may be implemented in a variety of configurations and form factors including without limitation desktops laptops handheld personal computers or other handheld devices servers workstations game consoles embedded systems and the like.

Operation of GPC is controlled via a pipeline manager that distributes processing tasks received from a work distribution unit not shown within task work unit to one or more streaming multiprocessors SMs . Pipeline manager may also be configured to control a work distribution crossbar by specifying destinations for processed data output by SMs .

In one embodiment GPC includes a set of M of SMs where M 1. Also each SM includes a set of functional execution units not shown such as execution units and load store units. Processing operations specific to any of the functional execution units may be pipelined which enables a new instruction to be issued for execution before a previous instruction has completed execution. Any combination of functional execution units within a given SM may be provided. In various embodiments the functional execution units may be configured to support a variety of different operations including integer and floating point arithmetic e.g. addition and multiplication comparison operations Boolean operations AND OR XOR bit shifting and computation of various algebraic functions e.g. planar interpolation and trigonometric exponential and logarithmic functions etc. . Advantageously the same functional execution unit can be configured to perform different operations.

In operation each SM is configured to process one or more thread groups. As used herein a thread group or warp refers to a group of threads concurrently executing the same program on different input data with one thread of the group being assigned to a different execution unit within an SM . A thread group may include fewer threads than the number of execution units within the SM in which case some of the execution may be idle during cycles when that thread group is being processed. A thread group may also include more threads than the number of execution units within the SM in which case processing may occur over consecutive clock cycles. Since each SM can support up to G thread groups concurrently it follows that up to G M thread groups can be executing in GPC at any given time.

Additionally a plurality of related thread groups may be active in different phases of execution at the same time within an SM . This collection of thread groups is referred to herein as a cooperative thread array CTA or thread array. The size of a particular CTA is equal to m k where k is the number of concurrently executing threads in a thread group which is typically an integer multiple of the number of execution units within the SM and m is the number of thread groups simultaneously active within the SM .

Although not shown in each SM contains a level one L1 cache or uses space in a corresponding L1 cache outside of the SM to support among other things load and store operations performed by the execution units. Each SM also has access to level two L2 caches not shown that are shared among all GPCs in PPU . The L2 caches may be used to transfer data between threads. Finally SMs also have access to off chip global memory which may include PP memory and or system memory . It is to be understood that any memory external to PPU may be used as global memory. Additionally as shown in a level one point five L1.5 cache may be included within GPC and configured to receive and hold data requested from memory via memory interface by SM . Such data may include without limitation instructions uniform data and constant data. In embodiments having multiple SMs within GPC the SMs may beneficially share common instructions and data cached in L1.5 cache .

Each GPC may have an associated memory management unit MMU that is configured to map virtual addresses into physical addresses. In various embodiments MMU may reside either within GPC or within the memory interface . The MMU includes a set of page table entries PTEs used to map a virtual address to a physical address of a tile or memory page and optionally a cache line index. The MMU may include address translation lookaside buffers TLB or caches that may reside within SMs within one or more L1 caches or within GPC .

In graphics and compute applications GPC may be configured such that each SM is coupled to a texture unit for performing texture mapping operations such as determining texture sample positions reading texture data and filtering texture data.

In operation each SM transmits a processed task to work distribution crossbar in order to provide the processed task to another GPC for further processing or to store the processed task in an L2 cache not shown parallel processing memory or system memory via crossbar unit . In addition a pre raster operations preROP unit is configured to receive data from SM direct data to one or more raster operations ROP units within partition units perform optimizations for color blending organize pixel color data and perform address translations.

It will be appreciated that the core architecture described herein is illustrative and that variations and modifications are possible. Among other things any number of processing units such as SMs texture units or preROP units may be included within GPC . Further as described above in conjunction with PPU may include any number of GPCs that are configured to be functionally similar to one another so that execution behavior does not depend on which GPC receives a particular processing task. Further each GPC operates independently of the other GPCs in PPU to execute tasks for one or more application programs. In view of the foregoing persons of ordinary skill in the art will appreciate that the architecture described in in no way limits the scope of the present invention.

The PD collects vertex data associated with high order surfaces graphics primitives and the like from the front end and transmits the vertex data to the VAF .

The VAF retrieves vertex attributes associated with each of the incoming vertices from shared memory and stores the vertex data along with the associated vertex attributes into shared memory.

The VTG is a programmable execution unit that is configured to execute vertex shader programs tessellation programs and geometry programs. These programs process the vertex data and vertex attributes received from the VAF and produce graphics primitives as well as color values surface normal vectors and transparency values at each vertex for the graphics primitives. for further processing within the graphics processing pipeline . Although not explicitly shown the VTG may include in some embodiments one or more of a vertex processing unit a tessellation initialization processing unit a task generation unit a task distributor a topology generation unit a tessellation processing unit and a geometry processing unit.

The vertex processing unit is a programmable execution unit that is configured to execute vertex shader programs lighting and transforming vertex data as specified by the vertex shader programs. For example the vertex processing unit may be programmed to transform the vertex data from an object based coordinate representation object space to an alternatively based coordinate system such as world space or normalized device coordinates NDC space. The vertex processing unit may read vertex data and vertex attributes that is stored in shared memory by the VAF and may process the vertex data and vertex attributes. The vertex processing unit stores processed vertices in shared memory.

The tessellation initialization processing unit is a programmable execution unit that is configured to execute tessellation initialization shader programs. The tessellation initialization processing unit processes vertices produced by the vertex processing unit and generates graphics primitives known as patches. The tessellation initialization processing unit also generates various patch attributes. The tessellation initialization processing unit then stores the patch data and patch attributes in shared memory. In some embodiments the tessellation initialization shader program may be called a hull shader or a tessellation control shader.

The task generation unit retrieves data and attributes for vertices and patches from shared memory. The task generation unit generates tasks for processing the vertices and patches for processing by later stages in the graphics processing pipeline .

The task distributor redistributes the tasks produced by the task generation unit. The tasks produced by the various instances of the vertex shader program and the tessellation initialization program may vary significantly between one graphics processing pipeline and another. The task distributor redistributes these tasks such that each graphics processing pipeline has approximately the same workload during later pipeline stages.

The topology generation unit retrieves tasks distributed by the task distributor. The topology generation unit indexes the vertices including vertices associated with patches and computes U V coordinates for tessellation vertices and the indices that connect the tessellated vertices to form graphics primitives. The topology generation unit then stores the indexed vertices in shared memory.

The tessellation processing unit is a programmable execution unit that is configured to execute tessellation shader programs. The tessellation processing unit reads input data from and writes output data to shared memory. This output data in shared memory is passed to the next shader stage the geometry processing unit as input data. In some embodiments the tessellation shader program may be called a domain shader or a tessellation evaluation shader.

The geometry processing unit is a programmable execution unit that is configured to execute geometry shader programs thereby transforming graphics primitives. Vertices are grouped to construct graphics primitives for processing where graphics primitives include triangles line segments points and the like. For example the geometry processing unit may be programmed to subdivide the graphics primitives into one or more new graphics primitives and calculate parameters such as plane equation coefficients that are used to rasterize the new graphics primitives.

The geometry processing unit transmits the parameters and vertices specifying new graphics primitives to the VPC . The geometry processing unit may read data that is stored in shared memory for use in processing the geometry data. The VPC performs clipping culling perspective correction and viewport transform to determine which graphics primitives are potentially viewable in the final rendered image and which graphics primitives are not potentially viewable. The VPC then transmits processed graphics primitives to the tiling unit .

The tiling unit is a graphics primitive sorting engine that resides between a world space pipeline and a screen space pipeline as further described herein. Graphics primitives are processed in the world space pipeline and then transmitted to the tiling unit . In various embodiments the tiling unit includes a buffer in which graphics primitives and state may be stored prior to transmission to the screen space pipeline . The screen space is divided into cache tiles where each cache tile is associated with a portion of the screen space. For each graphics primitive the tiling unit identifies the set of cache tiles that intersect with the graphics primitive a process referred to herein as tiling. After tiling a certain number of graphics primitives the tiling unit processes the graphics primitives on a cache tile basis where graphics primitives associated with a particular cache tile are transmitted to the setup unit . The tiling unit transmits graphics primitives to the setup unit one cache tile at a time. Graphics primitives that intersect with multiple cache tiles are typically processed once in the world space pipeline but are then transmitted multiple times to the screen space pipeline .

Such a technique improves cache memory locality during processing in the screen space pipeline where multiple memory operations associated with a first cache tile access a region of the L2 caches or any other technically feasible cache memory that may stay resident during screen space processing of the first cache tile. Once the graphics primitives associated with the first cache tile are processed by the screen space pipeline the portion of the L2 caches associated with the first cache tile may be flushed and the tiling unit may transmit graphics primitives associated with a second cache tile. Multiple memory operations associated with a second cache tile may then access the region of the L2 caches that may stay resident during screen space processing of the second cache tile. Accordingly the overall memory traffic to the L2 caches and to the render targets may be reduced. In some embodiments the world space computation is performed once for a given graphics primitive irrespective of the number of cache tiles in screen space that intersects with the graphics primitive.

The setup unit receives vertex data from the VPC via the tiling unit and calculates parameters associated with the graphics primitives including without limitation edge equations partial plane equations and depth plane equations. The setup unit then transmits processed graphics primitives to rasterizer .

The rasterizer scan converts the new graphics primitives and transmits fragments and coverage data to the pixel shading unit . Additionally the rasterizer may be configured to perform z culling and other z based optimizations.

The pixel shading unit is a programmable execution unit that is configured to execute fragment shader programs transforming fragments received from the rasterizer as specified by the fragment shader programs. Fragment shader programs may shade fragments at pixel level granularity where such shader programs may be called pixel shader programs. Alternatively fragment shader programs may shade fragments at sample level granularity where each pixel includes multiple samples and each sample represents a portion of a pixel. Alternatively fragment shader programs may shade fragments at any other technically feasible granularity depending on the programmed sampling rate.

In various embodiments the pixel shading unit may be programmed to perform operations such as perspective correction texture mapping shading blending and the like to produce shaded fragments that are transmitted to ROP . The pixel shading unit may read data that is stored in shared memory.

The ROP is a processing unit that performs raster operations such as stencil z test blending and the like and transmits pixel data as processed graphics data for storage in graphics memory via the memory interface where graphics memory is typically structured as one or more render targets. The processed graphics data may be stored in graphics memory parallel processing memory or system memory for display on display device or for further processing by CPU or parallel processing subsystem . In some embodiments the ROP is configured to compress z or color data that is written to memory and decompress z or color data that is read from memory. In various embodiments the ROP may be located in the memory interface in the GPCs in the processing cluster array outside of the GPCs or in a separate unit not shown within the PPUs .

The graphics processing pipeline may be implemented by any one or more processing elements within PPU . Foe example one of the SMs of could be configured to perform the functions of one or more of the VTG and the pixel shading unit . The functions of the PD the VAF the VPC the tiling unit the setup unit the rasterizer and the ROP may also be performed by processing elements within a particular GPC in conjunction with a corresponding partition unit . Alternatively graphics processing pipeline may be implemented using dedicated fixed function processing elements for one or more of the functions listed above. In various embodiments PPU may be configured to implement one or more graphics processing pipelines .

In some embodiments the graphics processing pipeline may be divided into a world space pipeline and a screen space pipeline . The world space pipeline processes graphics objects in 3D space where the position of each graphics object is known relative to other graphics objects and relative to a 3D coordinate system. The screen space pipeline processes graphics objects that have been projected from the 3D coordinate system onto a 2D planar surface representing the surface of the display device . For example the world space pipeline could include pipeline stages in the graphics processing pipeline from the PD through the VPC . The screen space pipeline could include pipeline stages in the graphics processing pipeline from the setup unit through the ROP . The tiling unit would follow the last stage of the world space pipeline namely the VPC . The tiling unit would precede the first stage of the screen space pipeline namely the setup unit .

In some embodiments the world space pipeline may be further divided into an alpha phase pipeline and a beta phase pipeline. For example the alpha phase pipeline could include pipeline stages in the graphics processing pipeline from the PD through the task generation unit. The beta phase pipeline could include pipeline stages in the graphics processing pipeline from the topology generation unit through the VPC . The graphics processing pipeline performs a first set of operations during processing in the alpha phase pipeline and a second set of operations during processing in the beta phase pipeline. As used herein a set of operations is defined as one or more instructions executed by a single thread by a thread group or by multiple thread groups acting in unison.

In a system with multiple graphics processing pipeline the vertex data and vertex attributes associated with a set of graphics objects may be divided so that each graphics processing pipeline has approximately the same amount of workload through the alpha phase. Alpha phase processing may significantly expand the amount of vertex data and vertex attributes such that the amount of vertex data and vertex attributes produced by the task generation unit is significantly larger than the amount of vertex data and vertex attributes processed by the PD and VAF . Further the task generation unit associated with one graphics processing pipeline may produce a significantly greater quantity of vertex data and vertex attributes than the task generation unit associated with another graphics processing pipeline even in cases where the two graphics processing pipelines process the same quantity of attributes at the beginning of the alpha phase pipeline. In such cases the task distributor redistributes the attributes produced by the alpha phase pipeline such that each graphics processing pipeline has approximately the same workload at the beginning of the beta phase pipeline.

Please note as used herein references to shared memory may include any one or more technically feasible memories including without limitation a local memory shared by one or more SMs or a memory accessible via the memory interface such as a cache memory parallel processing memory or system memory . Please also note as used herein references to cache memory may include any one or more technically feasible memories including without limitation an L1 cache an L1.5 cache and the L2 caches.

The screen space represents one or more memory buffers configured to store rendered image data and other data transmitted by functional units within the graphics processing pipeline . In some embodiments the one or more memory buffers may be configured as one or more render targets. The screen space represents a memory buffer configured to store the image rendered by the graphics processing pipeline . The screen space may be associated with any number of render targets where each render target may be configured independently of other render targets to include any number of fields. Each field within a render target may be configured independently of other fields to include any number of bits. Each render target may include multiple picture elements pixels and each pixel may in turn include multiple samples. In some embodiments the size of each cache tile may be based on the size and configuration of the render targets associated with the screen space. In operation once rendering completes the pixels in the one or more render targets may be transmitted to a display device in order to display the rendered image.

By way of example a set of render targets for the screen space could include eight render targets. The first render target could include four fields representing color including red green and blue component colors and transparency information associated with a corresponding fragment. The second render target could include two fields representing depth and stencil information associated with the corresponding fragment. The third render target could include three fields representing surface normal vector information including an x axis normal vector a y axis normal vector and a z axis normal vector associated with the corresponding fragment. The remaining five render targets could be configured to store additional information associated with the corresponding fragment. Such configurations could include storage for various information including without limitation 3D positional data diffuse lighting information and specular lighting information.

Each cache tile represents a portion of the screen space . For clarity only five cache tiles are shown in . In some embodiments cache tiles may have an arbitrary size in X and Y screen space. For example if a cache tile were to reside in a cache memory that also is used to store other data then the cache tile could be sized to consume only a specific portion of the cache memory. The size of a cache tile may be based on a number of factors including the quantity and configuration of the render targets associated with the screen space the quantity of samples per pixel and whether the data stored in the cache tile is compressed. As a general matter a cache tile is sized to increase the likelihood that the cache tile data remains resident in the cache memory until all graphics primitives associated with the cache tile are fully processed.

The raster tiles represent a portion of the cache tile . As shown the cache tile includes sixteen raster tiles arranged in an array that is four raster tiles wide and four raster tiles high. In systems that include multiple GPCs processing associated with a given cache tile may be divided among the available GPCs . In the example shown if the sixteen raster tiles of cache tile were processed by four different GPCs then each GPC could be assigned to process four of the sixteen raster tiles in the cache tile . Specifically the first GPC could be assigned to process raster tiles and . The second GPC could be assigned to process raster tiles and . The third GPC could be assigned to process raster tiles and . The fourth GPC would then be assigned to process raster tiles and . In other embodiments the processing of the different raster tiles within a given cache tile may be distributed among GPCs or any other processing entities included within computer system in any technically feasible manner.

When tiling is enabled the tiling unit buffers graphics primitives and state received from the world space pipeline prior to transmitting the graphics primitives and state to the screen space pipeline . Once a sufficient number of graphics primitives and state have been buffered the tiling unit initiates a replay. During a replay of buffered graphics primitives and state the tiling unit selects a cache tile associated with the screen space and determines which of the buffered graphics primitives intersect the cache tile . If a graphics primitive intersects the cache tile then the tiling unit transmits the graphics primitive and one or more state bundles associated with the graphics primitive to the screen space pipeline for processing. While a single cache tile is selected the tiling unit repeats the process of determining which graphics primitives intersect the cache tile for all of the graphics primitives buffered in the tiling unit . Once all of the graphics primitives buffered in the tiling unit are examined for a particular cache tile the tiling unit selects the next cache tile . With the next cache tile selected the tiling unit repeats the process of determining which of the buffered graphics primitives if any intersect the cache tile and transmitting the intersecting graphics primitives and associated state to the screen space pipeline . During a single replay this process is repeated for multiple cache tiles associated with the screen space .

In one embodiment during a single replay the tiling unit repeats the process of determining which of the buffered graphics primitives intersect a cache tile and transmitting the intersecting graphics primitives if any and associated state to the screen space pipeline for all of the cache tiles associated with the screen space . For example with reference to the tiling unit would first process cache tile i.e. by determining which buffered graphics primitives intersect the cache tile and transmitting the graphics primitives and associated state to the screen space pipeline followed by cache tile followed by cache tile and so on until all of the cache tiles associated with the screen space have been processed. In other embodiments the replay may be performed by processing all or less than all of the cache tiles in a non sequential order.

Under certain circumstances buffering graphics primitives and state received from the world space pipeline and or transmitting graphics primitives and state to the screen space pipeline with tiling enabled may negatively impact processing efficiency. Accordingly in various embodiments the buffer may be flushed and or the tiling function may be disabled when one or more conditions are detected by the tiling unit front end unit and or buffer manager. For example buffering graphics primitives and state for a given replay may deplete a shared system resource to the point that buffering additional graphics primitives and state will decrease processing efficiency. As an example buffering graphics primitives and state causes shader registers e.g. shader banks to be bound to entries in a constant buffer. However if the number of shader constant buffer bindings reaches a threshold level then an insufficient number of binding table entries may be available to the front end unit during a replay causing overall processing efficiency to decrease. Thus once the number of shader constant buffer bindings reaches a threshold level the buffer may be flushed and the buffered graphics primitives and state may be transmitted to the screen space pipeline for processing. Additionally when entries in the constant buffer are updated data associated with the updated constant buffer entry may be stored in a constant buffer page pool. However if the number of available constant buffer page pool entries falls below a threshold level then overall processing efficiency may decrease. Thus once the number of constant buffer updates or the number of allocated constant buffer page pool entries reaches a threshold level the buffer may be flushed and the buffered graphics primitives and state may be transmitted to the screen space pipeline for processing.

In addition under certain circumstances dividing the screen space into cache tiles and transmitting the graphics primitives and state associated with each cache tile in a particular order may be less efficient than simply processing the graphics primitives and state in the order specified by the application programming interface API . For example when the amount of state buffered by the tiling unit is disproportionately high relative to the number of buffered graphics primitives then the overhead associated with transmitting the state to the screen space pipeline multiple times e.g. once for each cache tile may negatively impact processing efficiency. That is repeatedly transmitting the state to the screen space pipeline when processing multiple cache tiles during a replay may be less efficient than disabling the tiling function and transmitting the graphics primitives and state in the order specified by the application programming interface API . As such in order to avoid such inefficiencies once the amount of state buffered by the tiling unit reaches a threshold level the buffer may be flushed and the buffered graphics primitives and state may be transmitted to the screen space pipeline for processing.

Accordingly in various embodiments the tiling unit front end unit and or buffer manager are configured cause a buffer to be flushed and or a tiling function to be disabled when one or more conditions are detected. Such techniques are discussed below in further detail in conjunction with .

As shown a method begins at step where the tiling unit receives graphics primitives and state from the world space pipeline . At step the tiling unit stores the graphics primitives and state in a buffer such as a buffer included in the tiling unit . At step the tiling unit front end unit and or buffer manager determines whether a replay condition has been met. If the replay condition has not been met then the method returns to steps and where additional graphics primitives and state are received and stored in the buffer. If the replay condition has been met then at step the tiling unit initiates a replay of the buffered graphics primitives and state.

The replay condition detected by the tiling unit front end unit and or buffer manager may be based on a variety of criteria several of which are described below in detail in conjunction with . However in general the replay condition is based on one or more criteria which indicate that buffering additional graphics primitives and or state may negatively impact processing efficiency and thus a replay of the buffered graphics primitives and state should be initiated. In one embodiment the tiling unit may determine that the replay condition has been met by determining that the buffer or a specified percentage of the buffer is full. In other embodiments the tiling unit may determine that the replay condition has been met by determining that graphics data stored in the buffer has a particular composition. For example the tiling unit may determine that a ratio of graphics primitives to state has reached a threshold level that graphics primitives or state occupy a percentage of the buffer capacity and or that other types of graphics data stored in the buffer have reached a threshold level e.g. ratio percentage and the like . In yet another embodiment the tiling unit may determine that the replay condition has been met based on temporal considerations such as by determining that a threshold period of time has elapsed since a replay was performed. In still other embodiments the tiling unit may determine that the replay condition has been met by determining that certain types of state have been received from the world space pipeline . For example the tiling unit may determine that state indicative of a rendering transition such as a transition from early z testing to late z testing was received and in response initiate a replay.

In addition other units may be responsible for determining when the replay condition has been met. In one embodiment the front end unit and or the buffer manager may monitor shared system resources such as shader constant buffer bindings and binding table entries and determine when the shared system resources have been depleted to a threshold level. In response the front end unit may transmit state e.g. a data packet to the tiling unit which indicates that a replay should be initiated.

After the tiling unit initiates a replay at step the tiling unit selects a cache tile for processing. At step the tiling unit optionally sets a scissor rectangle to a value that corresponds to the cache tile . Next at step the tiling unit processes buffered graphics primitives to determine which graphics primitives intersect the cache tile . In one embodiment the tiling unit determines which graphics primitives intersect the cache tile by comparing the graphics primitives to the scissor rectangle. If a particular graphics primitive intersects the cache tile then at step the tiling unit transmits the graphics primitive and state associated with the graphics primitive to the screen space pipeline for processing.

Finally at step the tiling unit determines whether the current cache tile selected at step is the last cache tile to be processed during the replay. In one embodiment the tiling unit determines whether the current cache tile is the last cache tile to be processed during the replay by determining whether all of the cache tiles associated with the screen space have been processed during the replay. If the current cache tile is not the last cache tile to be processed during the replay then the method returns to step where the tiling unit selects an additional cache tile for processing. If the current cache tile is the last cache tile to be processed during the replay then the method ends.

As shown a method begins at step where the tiling unit buffers graphics primitives and state received from the world space pipeline . At step the tiling unit front end unit and or buffer manager determine whether to disable a tiling function based on a disable tiling condition. If the disable tiling condition has not been met then the method proceeds to step and determines whether a replay of the buffered graphics primitives and state should be initiated. The tiling unit may determine that a replay should be initiated based on any of the replay conditions described above with respect to the method of . If at step the tiling unit determines that a replay should not be initiated then the method returns to step where additional graphics primitives and state are received and stored in the buffer.

If at step the tiling unit determines that a replay should be initiated then at step the tiling unit selects a cache tile for processing and optionally sets a scissor rectangle to a value that corresponds to the cache tile . Steps and are then performed in the same manner as described above with respect to steps and in the method of .

Next at step the tiling unit determines whether the current cache tile selected at step is the last cache tile to be processed during the replay. If the current cache tile is not the last cache tile to be processed during the replay then the method returns to step where the tiling unit selects an additional cache tile for processing. If the current cache tile is the last cache tile to be processed during the replay then the method returns to step where another set of graphics primitives and state are received from the world space pipeline and buffered by the tiling unit .

If at step the tiling unit front end unit and or buffer manager determine that the disable tiling condition has been met then the method proceeds to step . The disable tiling condition detected the tiling unit front end unit and or buffer manager may be based on variety of criteria several of which are described below in detail in conjunction with . However in general tiling may be disabled based on one or more criteria which indicate that replaying the buffered graphics primitives and or state with respect to multiple cache tiles may negatively impact processing efficiency. In one embodiment the tiling unit may determine that the disable tiling condition has been met by determining that graphics data stored in the buffer has a particular composition. For example the tiling unit may determine that a ratio of graphics primitives to state has reached a threshold level that graphics primitives or state occupy a percentage of the buffer capacity and or that other types of graphics data stored in the buffer has reached a threshold level e.g. ratio percentage and the like .

In other embodiments the tiling unit may determine that the disable tiling condition has been met based on temporal considerations such as by determining that a threshold period of time has elapsed since a replay was performed. For example the tiling unit may determine that the rate at which graphics primitives and or state are received from the world space pipeline is below a threshold level and as a result replays are occurring too infrequently. In response the tiling unit may flush the buffer and process additional graphics primitives and state received from the world space pipeline in a pass through mode as described below with respect to step .

In still other embodiments the tiling unit may determine that the disable tiling condition has been met by determining that certain types of state have been received from the world space pipeline . For example the tiling unit may receive state e.g. an instruction transmitted by the API indicating that a late binding decision was made to disable tiling and flush the buffer. In another example the tiling unit may determine that state indicative of a rendering transition such as a transition from early z testing to late z testing was received. In response the tiling unit may temporarily disable tiling and process one or more graphics primitives and or state in a pass through mode as described in further detail in conjunction with .

In addition other units may be responsible for determining when the disable tiling condition has been met. In one embodiment the front end unit and or the buffer manager may monitor shared system resources such as shader constant buffer bindings and binding table entries and determine when the shared system resources have been depleted to a threshold level. In response the front end unit may transmit state to the tiling unit which indicates that the buffer should be replayed with tiling enabled.

After determining that the disable tiling condition has been met at step the tiling unit disables the tiling function and sets a scissor rectangle to a value that corresponds to the full screen space . Then at step the tiling unit flushes the buffer by transmitting the graphics primitives and state to the screen space pipeline with tiling disabled. That is at step the tiling unit transmits the graphics primitives and state stored in the buffer to the screen space pipeline without regard to the cache tile s intersected by the graphics primitives.

Next at step after flushing the buffer the tiling unit determines whether the next set of graphics primitives and state should be received from the world space pipeline with the tiling enabled. That is at step the tiling unit determines whether the next set of graphics primitives and state should be buffered to enable the graphics primitives and state to be replayed for multiple cache tiles associated with the screen space . If the tiling unit determines that the tiling function should be re enabled then the tiling unit re enables tiling and the method returns to step . If the tiling unit determines that the tiling function should not be re enabled i.e. the tiling function should remain disabled then the method proceeds to step where the tiling unit optionally transmits the next set of graphics primitives and state received from the world space pipeline to the screen space pipeline in a pass through mode. Specifically when the tiling unit is in the optional pass through mode the tiling unit transmits graphics primitives and state to the screen space pipeline in the order they are received from the world space pipeline and does not buffer or re order the graphics primitives and state.

Finally at step the tiling unit determines whether additional graphics primitives and state are to be processed. If additional graphics primitives and state are to be processed then the method returns to step where the tiling unit determines whether the tiling function should be re enabled. If no additional graphics primitives and state are to be processed then the method ends.

As shown a method begins at step where the tiling unit buffers graphics primitives and state received from the world space pipeline . At step the tiling unit detects a transition from early z testing to late z testing or from late z testing to early z testing. For example the tiling unit may detect the transition by determining that state received from the world space pipeline e.g. an instruction transmitted by the API indicates that a transition between early z testing and late z testing is going to take place or has already taken place. In response at step the tiling unit initiates a replay of the graphics primitives and state stored in the buffer. In one embodiment the replay is performed with respect to graphics primitives and state that are received by the tiling unit before the transition from early z testing to late z testing or from late z testing to early z testing but not for graphics primitives and state are received after the transition was detected.

Next at step the tiling unit selects a cache tile for processing and optionally sets a scissor rectangle to a value that corresponds to the cache tile . Steps and are then performed in the same manner as described above with respect to steps and in the method of . At step the tiling unit determines whether the current cache tile selected at step is the last cache tile to be processed during the replay. If the current cache tile is not the last cache tile to be processed during the replay then the method returns to step where the tiling unit selects an additional cache tile for processing. If the current cache tile is the last cache tile to be processed during the replay then the method proceeds to step where the tiling unit is set to the pass through mode.

At step the tiling unit enters the pass through mode and at step processes state received from the world space pipeline in the pass through mode. As described above with respect to step of method when in the pass through mode the tiling unit transfers graphics primitives and state received from the world space pipeline to the screen space pipeline without buffering or re ordering the graphics primitives and state. In order to reduce the hysteresis associated with switching between early z testing and late z testing state associated with the transition is transmitted e.g. passed through to the screen space pipeline once instead of being replayed for multiple cache tiles . In one embodiment the state associated with the transition is state that is received from the world space pipeline immediately after a transition between early z testing and late z testing is detected.

Once the state associated with the transition from late z testing or from late z testing to early z testing is passed through to the screen space pipeline the tiling function may be re enabled. In one embodiment at step the tiling unit determines whether all of the state associated with the transition has been passed through to the screen space pipeline by determining whether a graphics primitive has been received from the world space pipeline since the buffer was replayed. If a graphics primitive has not been received from the world space pipeline then the tiling unit continues to process state in a pass through mode. If a graphics primitive was received from the world space pipeline then the method proceeds to step . At step the tiling function is re enabled additional graphics primitives and state received from the world space pipeline are buffered and the method ends.

As shown a method begins at step where the tiling unit buffers graphics primitives and state received from the world space pipeline . At step the tiling unit determines whether the amount of state received from the world space pipeline has reached a threshold level. As described above if the amount of state buffered by the tiling unit is disproportionately high relative to the capacity of the buffer and or the number of buffered graphics primitives then the overhead associated with transmitting the state to the screen space pipeline for each cache tile processed during a replay may negatively impact processing efficiency. Thus the tiling unit may monitor the amount of state stored in the buffer and initiate a replay when the amount of state reaches a threshold level. Once the amount of state reaches the threshold level a replay may be initiated.

In one embodiment the threshold level may correspond to a percentage of the capacity of a buffer in which the state in stored e.g. one quarter one third or one half of the buffer capacity or an amount of state e.g. a specified amount of state above which processing efficiency may be negatively impacted for example during replay. In other embodiments the threshold level may correspond to a ratio of the number of buffered state bundles to the number of buffered graphics primitives e.g. 3 1 5 1 10 1 etc. above which processing efficiency may be negatively impacted.

If at step the tiling unit determines that the amount of state has not reached the threshold level then the method proceeds to step . At step the tiling unit determines whether a replay is to be initiated. The tiling unit may determine that a replay should be initiated based on any of the replay conditions described above with respect to the method of . If the tiling unit determines that a replay should not be initiated then the method returns to step where additional graphics primitives and state are buffered. If the tiling unit determines that a replay should be initiated then the method proceeds to step .

If at step the tiling unit determines that the amount of state has reached the threshold level then the method proceeds to step . At step the tiling unit determines whether the buffered graphics primitives and state should be transmitted to the screen space pipeline with the tiling function enabled. In one embodiment the tiling unit determines whether the tiling function should be enabled based on whether tiling is likely to increase or decrease processing efficiency as described above in conjunction with . If at step the tiling unit determines that the buffered graphics primitives and state should be transmitted to the screen space pipeline with the tiling function enabled then the method proceeds to step .

At step the tiling unit selects a cache tile for processing and optionally sets a scissor rectangle to a value that corresponds to the cache tile . Steps and are performed in the same manner as described above with respect to steps and in the method of . At step the tiling unit determines whether the current cache tile selected at step is the last cache tile to be processed during the replay. If the current cache tile is not the last cache tile to be processed during the replay then the method returns to step where the tiling unit selects an additional cache tile for processing. If the current cache tile is the last cache tile to be processed during the replay then the method returns to step where the tiling unit buffers the next set of graphics primitives and state received from the world space pipeline .

If at step the tiling unit determines that the buffered graphics primitives and state should be transmitted to the screen space pipeline with the tiling function disabled then the method proceeds to step . At step the tiling unit disables the tiling function and sets a scissor rectangle to a value that corresponds to the full screen space . Then at step the tiling unit flushes the buffer by transmitting the graphics primitives and state to the screen space pipeline with tiling disabled.

Next at step after flushing the buffer the tiling unit determines whether the next set of graphics primitives and state should be received from the world space pipeline with the tiling function enabled. If the tiling unit determines that the tiling function should be re enabled then the tiling unit re enables tiling and the method returns to step . If the tiling unit determines that the tiling function should not be re enabled then the method proceeds to step where the tiling unit optionally transmits the next set of graphics primitives and state received from the world space pipeline to the screen space pipeline in the pass through mode. As described above when the tiling unit is in the optional pass through mode the tiling unit transmits graphics primitives and state to the screen space pipeline in the order they are received from the world space pipeline and does not buffer or re order the graphics primitives and state.

Finally at step the tiling unit determines whether additional graphics primitives and state are to be processed. If additional graphics primitives and state are to be processed then the method returns to step where the tiling unit determines whether the tiling function should be re enabled. If no additional graphics primitives and state are to be processed then the method ends.

As shown a method begins at step where the tiling unit determines whether a buffer in which graphics primitives and state received from the world space pipeline are stored e.g. the buffer in tiling unit is empty. If the buffer is empty the tiling unit continues to monitor the buffer to determine whether the buffer contains graphics primitives and or state. If the buffer is not empty then at step the tiling unit determines whether a threshold period of time has elapsed since a replay was performed. If a threshold period of time has elapsed since the last replay was performed then the method proceeds to step where the tiling unit initiates a replay of buffered graphics primitives and state. In one embodiment the threshold period of time is based on a number of clock cycles since the last replay was performed e.g. 500 or 1000 clock cycles .

In one embodiment as described above with respect to the tiling unit may determine that the rate at which graphics primitives and or state are received from the world space pipeline is below a threshold level. As a result replays may be occurring too infrequently causing the screen space pipeline to run out of work and thus decreasing processing efficiency. In response the tiling unit may initiate a replay so that the screen space pipeline is not idle for extended period of time. This technique is further illustrated in which is a conceptual diagram illustrating a replay of graphics primitives and state according to one embodiment of the present invention. As shown when a buffer is in a non empty state and a threshold period of time elapses since the last replay a replay is initiated at time .

At step the tiling unit selects a cache tile for processing. Steps and are then performed in the same manner as described above with respect to steps and in the method of . At step the tiling unit determines whether the current cache tile selected at step is the last cache tile to be processed during the replay. If the current cache tile is not the last cache tile to be processed during the replay then the method returns to step where the tiling unit selects an additional cache tile for processing. If the current cache tile is the last cache tile to be processed during the replay then the method proceeds to step .

At step the tiling unit determines whether additional graphics primitives and or state are to be processed. If additional processing is to be performed then the method returns to step . If no additional processing is to be performed then the method ends.

In sum various techniques are disclosed for buffering and replaying graphics primitives and associated state prior to transmitting the graphics primitives and associated state to a screen space pipeline for processing. While graphics primitives and state are being received from a world space pipeline and stored in a buffer the tiling unit front end unit and or buffer manager may monitor various conditions including the number of state bundles stored in the buffer a number of buffer register allocations and or rendering state changes. Upon detecting a condition indicating that buffering additional graphics primitives and or state may reduce processing efficiency the tiling unit flushes the buffer and transmits the buffered graphics primitives and state to the screen space pipeline. The tiling unit front end unit and or buffer manager further determines based on various criteria whether the graphics primitives and associated state should be transmitted to the screen space pipeline with the tiling function either enabled or disabled.

One advantage of the disclosed techniques is that tiling can be enabled and disabled in an intelligent manner in order to reduce overhead in the processing pipeline. In addition when tiling is enabled the buffering of graphics primitives and associated state can be controlled to further decrease overhead in the processing pipeline and as a result decrease power consumption of the graphics system.

One embodiment of the invention may be implemented as a program product for use with a computer system. The program s of the program product define functions of the embodiments including the methods described herein and can be contained on a variety of computer readable storage media. Illustrative computer readable storage media include but are not limited to i non writable storage media e.g. read only memory devices within a computer such as compact disc read only memory CD ROM disks readable by a CD ROM drive flash memory read only memory ROM chips or any type of solid state non volatile semiconductor memory on which information is permanently stored and ii writable storage media e.g. floppy disks within a diskette drive or hard disk drive or any type of solid state random access semiconductor memory on which alterable information is stored.

The invention has been described above with reference to specific embodiments. Persons of ordinary skill in the art however will understand that various modifications and changes may be made thereto without departing from the broader spirit and scope of the invention as set forth in the appended claims. The foregoing description and drawings are accordingly to be regarded in an illustrative rather than a restrictive sense.

