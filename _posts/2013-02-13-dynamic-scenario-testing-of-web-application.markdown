---

title: Dynamic scenario testing of web application
abstract: A test automation system can include a web controller configured to provide access to at least one container displayed by an application and a web user interface (UI) configured to be controlled using the web controller. The system can include an application controller object configured to implement an application controller interface and expose methods for performing operations on application controls of the application and an application query object. The application query object can include at least one filter with at least one condition, the at least one condition defining an attribute or property of a UI element to check for. The application query object can be configured to return at least one UI control when the UI control includes at least one UI element that includes features that match criteria defined by the at least one filter and the at least one condition.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09021442&OS=09021442&RS=09021442
owner: SAP SE
number: 09021442
owner_city: Walldorf
owner_country: DE
publication_date: 20130213
---
Test engineers often need in depth knowledge of the syntax and structure of the application that they are testing. Many applications adjust how they display data and objects depending on the size of the window to display the objects in. For example data that appears in a certain row on one display can appear in a different row using a different display. Such variability in display can make application testing difficult.

There are some situations where a generated test will not run properly without being adapted. A test can be adapted when testing dynamic scenarios where the application displays data retrieved from a database. The data displayed may not always appear at the same position because the data displayed can depend on the amount of data available from the database.

Various embodiments herein include at least one of systems methods and software to help reduce the complexity in testing software. One or more embodiments can include a system including a web controller configured to provide access to at least one container displayed by an application and a web user interface UI configured to be controlled using the web controller. The system can include an application controller object configured to implement an application controller interface and expose methods for performing operations on application controls of the application and an application query object. The application query object can include at least one filter with at least one condition the at least one condition defining an attribute or property of a UI element to check for. The application query object can be configured to return at least one UI control when the UI control includes at least one UI element that includes features that match criteria defined by the at least one filter and the at least one condition.

A test automation process can be simplified by having a script return a control of an element displayed in an application as compared to having the process directly search for and perform actions on the element displayed. By providing an entity testing the program the ability to search controls a test automation process can become data agnostic and the process can allow the tester to have less knowledge about the specifics of the application being tested while still allowing the tester to test the application.

A purpose of the test automation can include reducing the testing effort by using software to generate maintain and run automated tests. Test automation tools commonly provide features to record business scenarios that can then be stored in a repository and converted into tests. The test framework can execute the generated tests to check and validate software applications.

Creating tests by recording business scenarios can have some limitations. There are some situations where a generated test will not run properly without being adapted. Such situations can include the testing of dynamic scenarios where the application displays data coming from a database. The data displayed may not always appear at the same position depending on the amount of data available. For example a test selecting the first line in a table is not sure to select the same information when executed again because the first line can display information that has been inserted in the database since the last test.

Test engineers when facing such situations often write custom scripts to solve the issue. However automating the testing of common business scenarios can be difficult in view of complex technologies used for displaying the content. The situation can be even more difficult when testing web applications displaying information in a browser such as HyperText Markup Language HTML pages that may be augmented with scripting. The HTML coupled with its scripting capabilities can be flexible and most modern web applications do not restrict their User Interface UI to simple HTML elements. In practice web applications are built on top of a UI framework e.g. running server side which can be responsible for generating web or other HTML content. The output of such a UI framework can be very sophisticated. It can for instance rely on page composition techniques e.g. using frame elements to organize the page layout. It can also create complex UI elements that have their own semantics. There are many examples of such complex UI elements. Some examples include tables combo boxes tabs trees lists collapsible panels grids traffic lights or progress bars among others. Each one has its own semantic and because of the HTML language flexibility each one can be implemented differently by the UI framework.

A common problem when testing an application can be that the information that the test operates upon can be in different positions in a display depending on the amount of information retrieved from the database. The test engineer can adapt their test to the display and to account for the amount of information retrieved. This problem can arise when searching a web page of a web application for the content of the UI element and not the identification ID . This can be possible but can have drawbacks. An example of a drawback can include the test becoming complex from recursively iterating through a list of HTML UI elements displayed by a web page. Another example of a drawback can include the creation and the maintenance of the test can rely upon a deep knowledge of the UI technology. Yet another example of a drawback can include a UI element not using attribute for displaying the content. Each HTML UI element can have its own semantic and may not use the same attribute for displaying the content. A consequence can be that the test can become sensitive to the internal structure of the UI element e.g. HTML element . Even a minor change in the way the HTML content is generated can affect the execution of the HTML content.

Each of the various embodiments described herein can address one or more of the issues drawbacks or problems that can be faced when testing dynamic scenarios. One or more problems encountered in test automation of an application can be solved by using a query Application Programming Interface API that hides the HTML complexity and allows a tester to search the displayed information such as by using filters and conditions. The API can be implemented for testing applications that are built on top of a Web Common User InterFace WebCUIF framework. Examples of applications that utilize the WebCUIF framework to display HTML content are the Customer Relationship Management CRM applications from SAP. However the implementation is not restricted to the WebCUIF Framework technology. The same approach can be reused or specialized to handle the content generated by a wide variety of UI frameworks.

The WebCUIF framework can be the presentation layer that generates the content e.g. HTML content shown by an application e.g. a CRM Application . This framework can generate UI elements e.g. input fields dropdown list boxes and checkboxes that are a composition of several HTML elements. To help automate the tests of such generated UIs the WebCUIF framework can put some meta information in the page e.g. in a hidden HTML SPAN element . This meta information may not be session dependent and can be used by the test automation framework to generate stable tests.

When testing dynamic scenarios the test automation of these applications can access HTML content via a native Component Object Model COM Interface from Microsoft that the Internet Explorers browser exposes. An advantage of the Microsoft API can be that the HTML content can be explored and manipulated at runtime. The drawback can be that this HTML content can be very complex and the direct manipulation of the internal hierarchy of HTML UI elements can lead to unstable tests. An alternative to the native COM interfaces from Microsoft can be to use one of the query APIs described herein. The API systems described herein can be used by a test that is generated out of a recorded scenario.

Several test frameworks are available for testing business applications. Some examples include Component Based Test Automation CBTA which can be a Solution Manager capability that extends the Test Composition Environment TCE and System Analysis and Program development SAP Test Automation and Optimization TAO which can be a product integrated with third party products. SAP TAO provides for example the ability to generate tests that are compliant with Hewlett Packard HP Quality Center HP Application Lifecycle Management ALM and HP Quick Test Professional. Both CBTA and SAP TAO can benefit from one or more embodiments of the query API disclosed. The query API can be used to test applications that are based on web UI technologies such as Business Server Page BSP Web Dynpro Advanced Business Application Programming ABAP Web Dynpro Java or Enterprise Portal among others.

The query APIs discussed herein can have one or more advantages including the ability to obfuscate the UI element e.g. HTML element complexity and provide the ability to search for UI elements and UI element controls using filters and conditions. Another potential advantage is that the query API can be specialized to simplify common needs e.g. the API can target by default a WorkArea page or frame where an application displays its content . Another potential advantage can include the tester not needing to understand the internal page composition structure of the object or application being tested. Yet another advantage of the API can include the API being exposed via the COM interface of a test player COM object and can therefore be called from different languages such as Visual Basic or other programming languages or scripting languages such as VBScript or other scripting languages. Yet another advantage of the query API can include the ability to interact with a UI of an application rather than working directly with the application.

One or more embodiments that include one or more of the advantages discussed are described in detail below with reference to the figures.

The API system can include a filter interface and a condition interface defining the criteria that an attribute or property of a UI element must match before being selected by a query. The API system can include a web application control interface that can wrap an underlying UI element interface e.g. an HTML element interface or provide convenient methods for retrieving meta information. The API system can include an application control collection interface for handling collections of UI elements when several UI elements match the query criteria. The application query interface can provide access to a UI control e.g. a button text box tables entry in a table link e.g. hyperlink drop down list scroll button or title box among others and can help hide the complexity of the underlying native application element.

The API system can include a web controller interface that can be an entry point providing access to the browser session and to the browser window. The API system can include a web query interface that can be exposed by a query object . The query object can be executed to retrieve UI elements or UI element controls. The API system can include a web control collection interface for handling collections of UI elements when more than one UI element matches the query criteria. The web query interface can provide access to the application content e.g. HTML content via the web control interface .

The API system can include an operation result interface that can provide a result of an operation performed on a UI element . The UI elements e.g. HTML elements or CRM web controls can be identified using a Unified Resource Identifier URI . Examples of UI controls include input fields dropdown list boxes check boxes or other controls that are composed of multiple UI elements. Each UI control can include a specific identifier element e.g. an HTML SPAN element that includes one or more attributes or properties that can provide meta information. A condition can search for a specific meta attribute or a meta property. The meta attribute or meta property can be an attribute that is retrieved from the meta information. The meta information can be specific to the UI element or the UI technology.

When executing a test script the script coding corresponding to the test can be sent to the client computer and executed using a script interpreter. A runtime library can be a set of scripts providing helper classes functions and procedures that help simulate user interactions with the UI.

Test components are components performing operations on UI elements . A runtime library can support several UI technologies and can include a set of test components. A test component implementation can delegate operations to be performed to one or more objects e.g. COM objects . When testing a web application this can be done by calling one or more methods of the web controller interface or the application controller interface .

The test components targeting a UI element can have an input parameter specifying the URI of the UI element . The URI can be a string identifying the UI element. The URI concept can be used by the query API for identifying the UI element e.g. web controls or CRM web controls . The URI parameter can be resolved at runtime when searching for a UI element . The URI can be generated when recording user interactions.

The UI elements A B can include one or more attributes or properties. Attributes or properties of a UI element A or can include the value of the UI element A or B or the identification ID or URI of the UI element A or B which can be unique within the application UI or the application container . Other attributes or properties include the type of UI element A or B or the tagtype e.g. sub type of the UI element A or B e.g. checkbox for a UI element that can be a checkbox dropdown list box for a combo box or value help for input fields with a button or link that opens a help box such as the F4 help popup box . Yet other attributes or properties include the name of the UI element A or B the view of the UI element A or B the context of the UI element A or B the interface associated with the UI element A or B the row at which the UI element A or B appears the key of UI element A or B or the column title that contains the UI element A or B.

Other attributes or properties can include read only as a Boolean that indicates whether the UI element A or B can be read only or read write disabled as a Boolean which indicates whether the UI element A or B can be active or inactive class as a list of one or more styles that are applied to the UI element A or B or href which can be used by a UI element A or B to define where a link should navigate to among others.

A query object can be accessible through the application controller interface or the web controller interface . The query object can be configured to search the application UI or a specific portion of the application UI such as the application container . The query object can search for one or more UI elements A B that include one or more attributes or properties that match criteria specified by a filter condition A or B or sub filter of the application query object .

The one or more conditions A or B can specify one or more properties or attributes to look for in a UI element A or B. Conditions can compare operands e.g. an attribute or property of a UI element A or B or a user specified string or value as strings and the comparison can be case sensitive. In one or more embodiments the query object can do non case sensitive comparisons. This non case sensitive comparison can be accomplished using one or more options . The one or more conditions A B can include the one or more options that specify an operation that can be performed on an attribute or property specified by the condition A and the corresponding attribute or property of the UI element . The operation defined by the option can be performed on the relevant attributes or properties before they are compared to determine if they are the same. Examples of operations that can be defined by the options include converting to uppercase or lowercase trimming to remove heading and trailing spaces converting to Boolean converting to integer or converting to float among others. The Boolean option can be implicit for attributes such as read only or enabled or disabled . Converting to integer can include truncating or rounding the relevant value.

The one or more conditions can support a plurality or operators to use in comparing the attribute or property specified in the condition to a corresponding attribute or property of the UI element . Such operators include equals e.g. does not equal e.g. or less than e.g. less than or equal to e.g. contains starts with ends with or matches among others.

The web controller interface can provide access to a browser session and the browser window. The web controller interface can be exposed by an object that can be implicitly created and maintained by a runtime library such as during test execution. The web controller interface can expose a createquery method. The createquery method can be created by the UI controller class and can be an entry point to the query API. The web controller interface can expose other methods for performing operations on or retrieving information about UI elements . These exposed methods can include a URI as an input parameter and return a result through the operation result interface . An example of code defining a web controller interface is provided 

The query class can implement the query interface e.g. the web query interface or the application query interface and provide the ability to search for the UI elements e.g. controls such as web controls or CRM web controls .

The query interface can be implemented by objects created by the createquery method of the UI controller class . The web query interface can include methods for defining filters . The web query interface can include a setfilter method that creates a filter after removing existing filters. The web query interface can include an addfilter method that adds a filter without removing the existing filters. The web query interface can use a parent control uri property that makes it possible to reduce the scope of the query by specifying the URI of a UI container e.g. an application container to search for a child element of the parent element.

The web query interface can include one or more methods configured to execute a query object . Such methods can include a method that returns the first UI element A that matches the criteria defined by the filters sub filters and the conditions or a method that returns a collection of UI elements A B that match the criteria specified by the filters or conditions . A max hits parameter can be specified to indicate to stop searching when a specified number of UI elements A B has been found. An example of code defining the web query interface is provided 

The query class e.g. a web query class or application query class can hold a list of filter objects that have a specific filter class that can implement the filter interface . The filter class holds a list of filter objects which can provide the ability to define sub filters . The filter class can hold a list of condition objects that can implement the condition interface .

There can be one web control object per UI element . These controls or UI elements can be retrieved through executing a web query. The web control interface can expose one or more methods for providing access to underlying UI element A or B attributes or properties. One such method is a GetControlURI method which can provide the URI identifying the UI element A or B. The GetControlURI method can return a string that identifies a UI element A or B in the application UI or the application container . An example of code defining a web control interface is provided 

The GetControlURI method can be used when calling methods of the web control interface such as to simulate user actions. The web UI element class and a corresponding UI element interface e.g. HTML element can be exposed such as by using the MSHTML COM API.

The application controller class can implement an application controller interface that can provide an entry point for creating an application query object of a specific query class . The application controller interface can provide access to an application UI session. The application controller interface can be exposed by an object that can be created and maintained by a runtime library such as while testing the application UI . The application controller interface can expose a createquery method. The createquery method can be an entry point to the query API. The application controller interface can include one or more methods configured to perform one or more operations on a UI element . One or more of these methods can include a URI as an input parameter and can return a result through an operation result interface . An example of code defining an application controller interface is provided 

The query class e.g. application query class can implement the application query interface and provide the ability to search for a UI element . The query class can include a list of filter objects that have a specific filter class that can implement the filter interface . The filter class can hold a list of filter objects which can enable the ability to define sub filters indicated by the line and arrow originating and ending at the filter class . The filter class can hold a list of condition objects that can implement a condition interface .

The application query interface can be implemented by objects created by the createquery method of the application controller class . The application query interface can be similar to the web query interface with the application query interface returning one or more objects that implement an application control interface instead of a web control interface . The application query interface can include one or more methods for defining filters e.g. filter objects .

The application query interface can include a setfilter method that creates a filter after removing existing filters or an addfilter method that adds a filter without removing the existing filters. The application query interface can use a parent control uri property that can help reduce the scope of the query by specifying the URI of a user interface container to search for a child element. The application query interface can include methods configured to execute a query. Such methods can include a method that returns the first UI element A that matches the criteria defined by the filters sub filters or the conditions or a method that returns a collection of UI elements A B that match the criteria specified by the filters sub filters or conditions . A max hits parameter can be specified to stop searching when a specified number of UI elements A B can be found. An example of source code defining the application query interface is provided 

When targeting a UI element the test can access some meta information of the UI element . The web application control class can act as a fa ade to a UI element class and also to a UI element meta information class that can provide the meta information e.g. an HTML SPAN element object can be a member of this class . The UI element class and a corresponding UI element interface or the UI element meta information class and a corresponding UI element meta information interface can be exposed by an HTML COM API such as an HTML COM API provided by Microsoft .

A UI element meta information class e.g. an HTML SPAN element can provide meta information about the UI element . The meta information can have an ID attribute that can be unique in the web application UI or the application container . This ID can be session independent and in such a case the test can use it to find the UI element . The UI element can then be used by the test when simulating user actions. When generated by the web CUIF framework this unique ID can be made of several fragments using a specific syntax and can provide the following information 1 the application name A fragment 2 the view name V fragment 3 the type of the CRM Web Control T fragment 4 the context C fragment or 5 the interface e.g. the attribute name in the context I fragment . Note that additional fragments can provide further information such as the row number when the control can be part of or embedded in a UI element that can be a table such as a table HTML element or a key when the UI element can be selected using its key such as items in a dropdown list box . The meta information object can have a dynamicid attribute providing the ID of the child element that represents the UI element . This information can be session dependent and as such may not be able to be reused by a test automation framework.

The Test Player can be an object such as a Component Object Model COM object deployed on a tester s machine. It can include an implementation of test components components used to simulate user actions on the application page . The Test Player can provide access to the UI elements via the query API that can be configured to hide the complexity of the application UI such as a web application implemented using HTML. The runtime library can invoke the Test Player COM object to get access to a web controller interface of the application UI .

The web controller class can be an entry point to a browser window. An object in the web controller class can be bound to the browser session and provide access to the hierarchy of UI containers e.g. HTML documents being displayed by the tested application UI . The web controller objects in the web controller class can implement the web controller interface and expose methods for performing actions against UI elements . They can perform for example a mouse click on an anchor HTML element displayed by an HTML document.

The application controller can be an entry point to an application controller interface . This object can be bound to an application session and can be a handle for the application UI being tested. The application controller can implement the application controller interface and expose methods for performing operations on UI elements . The following methods can be used to set and retrieve a value from an input field IOperationResult InputField SetValue string uri string aValue or IOperationResult InputField GetValue string uri . Both methods can return an operation result object implementing the operation result interface . The operation result interface can expose information about the operation and can be used to write some human readable feedback about the status of the operation in an execution report shown in . An example of code defining an operation result interface is provided 

An application query object can allow a search for one or more application controls that wrap the UI elements e.g. UI elements or controls that the application UI displays . A query object which can include one or more filters can be created using the application controller interface . The filter can include one or more conditions or sub filters . The sub filter can include a condition B. A condition can check a value of a UI element attribute or property. A filter interface can be implemented by a filter object. The filter interface can include methods for defining sub filters or conditions . An example of code defining the filter interface is provided 

The filter interface can include methods for defining sub filters and conditions . The SetFilter method can be configured to create a filter after removing existing filters if any . The AddFilter method can be configured to add a filter without removing existing filters. Similar to the AddFilter and SetFilter methods the SetCondition method can create a condition after removing the existing conditions and the AddCondition method can be configured to add a condition without removing the existing conditions. The AddCondition or SetCondition method of the filter interface can implement a condition interface . The condition interface can expose some properties or attributes or allow a user to change the condition before executing a query object . The condition interface can include properties that expose the data members of the condition . An example of code defining the condition interface is provided 

The query object can be used several times. The query object can be bound to a specific UI container and thus can have a restricted life cycle. The query object can be used for the current set of one or more UI containers . After navigating to another UI container a new query object can be created e.g. after each round trip to an HTTP Server .

A test script including a query object can iterate through a collection of application controls and count the number of UI elements that match the criteria specified.

The Select method of the application query interface can return a collection implementing the web control collection interface . A test script can iterate through the collection using the count property and the ControlAt method.

The next example shows an example of how to use a result and manipulate a retrieved UI element . The script shown in shows code configured to invoke the SelectSingle method that can expose the UI element interface to retrieve a single UI element A. The script checks whether the crmControl variable is set before using it. The script then asks for the URI identifying the UI element A by calling the GetControlUri method. This call can return a URI that identifies the UI element A. This URI can be passed as an input parameter to a method exposed by the application controller interface . The URI identifying the UI element A in this example is 

Knowing the URI the script can now invoke a method exposed by the application controller interface such as to simulate actions performed by a user. In this example the script is configured to set the value of the input field to 1234 . The script does this by calling the SetElementValue method.

The examples presented so far include static variables. The next example will explain how to select one or more UI elements by filtering on the actual values of an input HTML element that a browser displays. shows an HTML table UI container displayed by the application UI when creating an appointment. The contents of the HTML table container can have a different type and eventually a sub type depending on the nature of the container .

In this example the task is to automate a dynamic scenario where the script selects the first row where the function is set to sales employee and ID is set to 244 . The row selection can typically be done by selecting e.g. doing a mouse click on the row selector element in the first column . As a consequence the conditions are to be checked not against the row selector UI element being searched but against the cells that are in the same row but different columns of a table UI container . This kind of query can be very complex when going through the internal hierarchy of UI elements such as an HTML element hierarchy. To make it simple the filters and the conditions of the query API can be specialized to hide the complexity and handle common use cases like this one.

The condition can check the value of these fragments using application attributes where the crm.application attribute checks the application title the crm.view attribute checks the view name the crm.type attribute checks for the UI element type etc. The following script is configured to return the row selectors of the table UI container 

In a non dynamic scenario e.g. where the row number is stable the row could be selected using a URI or the row number can be hardcoded such as by using the following ID A btpartner V Partner T ROW SELECTOR C btpartner I  R2

An application query can by default search for UI elements in a specific container e.g. WorkArea Frame of the browser window. Consequently the query object can analyze the whole content of the body of the container and compare UI element attributes or properties to the filters conditions or sub filters for each of the UI elements that are found.

For performance reasons it might help to reduce the scope of the query and specify where to search for a UI element . For example when searching for a UI element of type ROW SELECTOR it can make sense to narrow the search to the parent table UI container . Narrowing the search can be done by setting the ParentControlUri property of the query object with the URI of the table UI container . The following code shows an example of code configured to narrow the search using the ParentControlUri property 

As already mentioned queries e.g. query objects can search such as by default for UI elements in the WorkArea page of a browser window. The default searching behavior can be changed such as by using the ParentControlUri property. shows an example of a container e.g. a popup window of an application UI . shows an example of code configured for searching for a UI element attribute or property in the container . The script shown in uses some conditions to select the Transaction with Transaction Type of 1001 and a Description of Meeting . The script specifies that the Work Area FRAME of the container is to be searched by setting the ParentControlUri property. In this example it would have been possible to restrict the scope even more by specifying the URI of the table like shown in this example code 

All examples so far demonstrate using one filter with several conditions . The conditions can be evaluated one by one and the UI elements can be excluded as soon as a condition is not met. In other words a logical AND operator can be used between conditions .

The next example can retrieve a collection of UI elements that are either check boxes or input fields associated with an F4 Help popup. This can be done by combining several filters and sub filters . An example of code configured to accomplish this is shown in .

In this example the main filter does not check for the ROW SELECTOR type. As a consequence all cells within the row match its criteria. Two sub filters have been defined where the exact type of the UI element A to look for can be specified. The first sub filter checks for attributes or properties that are associated with an F4 Help popup using the valueHelp tagType. The second one checks for a checkbox UI element . Two sub filters have been defined where each of them has a single condition checking for the crm.tagType attribute. The call to a SetFilter method on the main filter object creates the first sub filter . The second one can be added calling the AddFilter method. By defining several filters e.g. a filter and one or more sub filters in this example cells matching both tagTypes can be looked for by the query object . A logical OR operator can be used between filters or sub filters .

Another embodiment can be in the form of a system that can be implemented on one or more computers such as computer . Such a system includes at least one processor at least one memory device and at least one network interface device. The system further includes a first network and system management system stored on the at least one memory device and executable by the at least one processor to receive metric messages broadcast on a first network by network entities. The system further includes a metric message connector module stored on the at least one memory device and executable by the at least one processor.

The metric message connector module can be executable by the at least one processor in some embodiments to perform different data processing tasks. Such data processing tasks can include processing metric messages received by the first network and system management system to identify based on configuration data and data of the received metric messages metric messages to be forwarded to a second network and system management system on a second network. Further for each received metric message identified to be forwarded to the second network and system management system the metric message connector module can perform additional data processing tasks.

The addition data processing tasks of the metric message connector module with regard to each metric message identified to be forwarded to the second network and system management system can include retrieving from the at least one memory device an XML template to populate with data of the identified metric message and mapping data that maps metric message data to fields of the XML template. The metric message connector module can then populate the XML template with data of the identified metric message according to the mapping data. Once the XML template can be populated the metric message connector module can then transmit via the at least one network interface device encoded within a SOAP message the populated XML template to the second network and system management system on the second network.

Computer readable instructions stored on a computer readable medium are executable by the processing unit of the computer . A hard drive. CD ROM and RAM are some examples of articles including a non transitory computer readable medium. For example a computer program capable of performing one or more of the methods illustrated and described herein can be stored on a non transitory computer readable medium. An example of such a computer program can include a computer readable storage device including instructions stored thereon the instructions which when executed by a machine cause the machine to perform operations including controlling a web user interface UI through a web controller object that provides access to a UI of an application through a web controller interface. The computer program can include instructions that cause the machine to perform operations on application controls of the application using an application controller object configured to implement an application controller interface and expose methods for performing the operations and execute an application query object the application query object including at least one filter with at least one condition. The computer program can include instructions that cause the machine to compare an attribute or property specified in the at least one condition to an attribute or property of a UI element of a UI control and return the UI control when the UI control includes a UI element that includes features that match the criteria defined by the at least one filter and the at least one condition.

It will be readily understood to those skilled in the art that various other changes in the details material and arrangements of the parts and method stages which have been described and illustrated in order to explain the nature of the inventive subject matter can be made without departing from the principles and scope of the inventive subject matter as expressed in the subjoined claims.

