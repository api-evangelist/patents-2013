---

title: Scheduling distribution of logical control plane data
abstract: A controller for distributing logical control plane data to other controllers is described. The controller includes an interface for receiving user inputs to define logical datapath sets. The controller includes a translator for translating the user inputs to output logical control plane data. The logical control plane data is for subsequent translation into logical forwarding plane data by several other controllers. The controller includes a scheduler for (1) storing the output logical control plane data in a plurality of storage structures, each storage structure corresponding to one of the other controllers and (2) sending the output logical control plane data to the other controllers from the corresponding storage structure.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09319336&OS=09319336&RS=09319336
owner: NICIRA, INC.
number: 09319336
owner_city: Palo Alto
owner_country: US
publication_date: 20130131
---
This application is a continuation application of U.S. patent application Ser. No. 13 589 077 filed on Aug. 17 2012 now issued as U.S. Pat. No. 9 178 833. U.S. patent application Ser. No. 13 589 077 now issued as U.S. Pat. No. 9 178 833 claims the benefit of U.S. Provisional Application 61 551 425 filed Oct. 25 2011 U.S. Provisional Application 61 551 427 filed Oct. 25 2011 U.S. Provisional Application 61 577 085 filed Dec. 18 2011 U.S. Provisional Application 61 595 027 filed Feb. 4 2012 U.S. Provisional Application 61 599 941 filed Feb. 17 2012 U.S. Provisional Application 61 610 135 filed Mar. 13 2012 U.S. Provisional Application 61 635 056 filed Apr. 18 2012 U.S. Provisional Application 61 635 226 filed Apr. 18 2012 and U.S. Provisional Application 61 647 516 filed May 16 2012. This application claims the benefit of U.S. Provisional Application 61 595 027 filed Feb. 4 2012 U.S. Provisional Application 61 599 941 filed Feb. 17 2012 U.S. Provisional Application 61 610 135 filed Mar. 13 2012 U.S. Provisional Application 61 635 056 filed Apr. 18 2012 U.S. Provisional Application 61 635 226 filed Apr. 18 2012 and U.S. Provisional Application 61 647 516 filed May 16 2012. U.S. patent application Ser. No. 13 589 077 now issued as U.S. Pat. No. 9 178 883 and U.S. Provisional Applications 61 551 425 61 551 427 61 577 085 61 595 027 61 599 941 61 610 135 61 635 056 61 635 226 and 61 647 516 are incorporated herein by reference.

Many current enterprises have large and sophisticated networks comprising switches hubs routers servers workstations and other networked devices which support a variety of connections applications and systems. The increased sophistication of computer networking including virtual machine migration dynamic workloads multi tenancy and customer specific quality of service and security configurations require a better paradigm for network control. Networks have traditionally been managed through low level configuration of individual components. Network configurations often depend on the underlying network for example blocking a user s access with an access control list ACL entry requires knowing the user s current IP address. More complicated tasks require more extensive network knowledge forcing guest users port traffic to traverse an HTTP proxy requires knowing the current network topology and the location of each guest. This process is of increased difficulty where the network switching elements are shared across multiple users.

In response there is a growing movement towards a new network control paradigm called Software Defined Networking SDN . In the SDN paradigm a network controller running on one or more servers in a network controls maintains and implements control logic that governs the forwarding behavior of shared network switching elements on a per user basis. Making network management decisions often requires knowledge of the network state. To facilitate management decision making the network controller creates and maintains a view of the network state and provides an application programming interface upon which management applications may access a view of the network state.

Some of the primary goals of maintaining large networks including both datacenters and enterprise networks are scalability mobility and multi tenancy. Many approaches taken to address one of these goals results in hampering at least one of the others. For instance one can easily provide network mobility for virtual machines within an L2 domain but L2 domains cannot scale to large sizes. Furthermore retaining user isolation greatly complicates mobility. As such improved solutions that can satisfy the scalability mobility and multi tenancy goals are needed.

Some embodiments of the invention provide a network control system that allows several different logical datapath sets to be specified for several different users through one or more shared forwarding elements without allowing the different users to control or even view each other s forwarding logic. These shared forwarding elements are referred to below as managed switching elements or managed forwarding elements as they are managed by the network control system in order to implement the logical datapath sets.

In some embodiments the network control system includes one or more controllers also called controller instances below that allow the system to accept logical datapath sets from users and to configure the switching elements to implement these logical datapath sets. These controllers allow the system to virtualize control of the shared switching elements and the logical networks that are defined by the connections between these shared switching elements in a manner that prevents the different users from viewing or controlling each other s logical datapath sets and logical networks while sharing the same switching elements.

In some embodiments each controller instance is a device e.g. a general purpose computer that executes one or more modules that transform the user input from a logical control plane to a logical forwarding plane and then transform the logical forwarding plane data to physical control plane data. These modules in some embodiments include a control module and a virtualization module. A control module allows a user to specify and populate a logical datapath set while a virtualization module implements the specified logical datapath set by mapping the logical datapath set onto the physical switching infrastructure. In some embodiments the control and virtualization modules are two separate applications while in other embodiments they are part of the same application.

In some of the embodiments the control module of a controller receives logical control plane data e.g. data that describes the connections associated with a logical switching element that describes a logical datapath set from a user or another source. The control module then converts this data to logical forwarding plane data that is then supplied to the virtualization module. The virtualization module then generates the physical control plane data from the logical forwarding plane data. The physical control plane data is propagated to the managed switching elements. In some embodiments the control and virtualization modules use an nLog engine to generate logical forwarding plane data from logical control plane data and physical control plane data from the logical forwarding plane data.

The network control system of some embodiments uses different controllers to perform different tasks. For instance in some embodiments there are three or four types of controllers. The first controller type is an application protocol interface API controller. API controllers are responsible for receiving configuration data and user queries from a user through API calls and responding to the user queries. The API controllers also disseminate the received configuration data to the other controllers. These controllers serve as the interface between users and the network control system. A second type of controller is a logical controller which is responsible for implementing logical datapath sets by computing universal flow entries that are generic expressions of flow entries for the managed switching element that realize the logical datapath sets. A logical controller in some embodiments does not interact directly with the physical switching elements but pushes the universal flow entries to a third type of controller a physical controller.

Physical controllers in different embodiments have different responsibilities. In some embodiments the physical controllers generate customized flow entries from the universal flow entries and push these customized flow entries down to the managed switching elements. In other embodiments the physical controller identifies for a particular managed physical switching element a fourth type of controller a chassis controller that is responsible for generating the customized flow entries for a particular switching element and forwards the universal flow entries it receives from the logical controller to the chassis controller. The chassis controller then generates the customized flow entries from the universal flow entries and pushes these customized flow entries to the managed switching elements. In yet other embodiments physical controllers generate customized flow entries for some managed switching elements while directing chassis controllers to generate such flow entries for other managed switching elements.

Depending on the size of the deployment managed by a controller cluster any number of each of the four types of controller may exist within the cluster. In some embodiments a leader controller has the responsibility of partitioning the load over all the controllers and effectively assigning a list of logical datapath sets for each logical controller to manage and a list of physical switching elements for each physical controller to manage. In some embodiments the API responsibilities are executed at each controller in the cluster. However similar to the logical and physical responsibilities some embodiments only run the API responsibilities on a subset of controllers. This subset in some such embodiments only performs API processing which results in better isolation between the API operations and the rest of the system.

In some embodiments the computation results i.e. the creation of flows not only flow from the top of the hierarchy towards the switching elements but also may flow in the opposite direction from the managed switching elements to the logical controllers. The primary reason for the logical controller to obtain information from the switching elements is the need to know the location of various virtual interfaces or virtual network interfaces VIFs among the managed switching elements. That is in order to compute the universal flow entries for a logical datapath set the logical controller is required to know the physical location in the network of the managed switching elements and the VIFs of the managed switching elements.

In some embodiments each managed switching elements reports its VIFs to the physical controller responsible for the switch. The physical controller then publishes this information to all of the logical controllers. As such the information flow from the switching elements to the logical controllers is done in a hierarchical manner but one that is upside down compared to the hierarchy used for computing the flow entries. Because this information may potentially reach more and more controllers as it traverses up the hierarchy the information should be limited in volume and not overly dynamic. This allows the publication of the information to avoid becoming a scalability bottleneck for the system while enabling the information to be obtained by the upper layers of the hierarchy as soon as or very shortly after the information is generated at the switching elements.

There are other uses for publishing information upwards beyond the need to know the location of the VIFs in the network. In some embodiments various error reporting subsystems at the controllers benefit from obtaining error reports from the switching elements in the case that such errors exist . As with the VIF information the switching elements of some embodiments only publish minimal information about the errors in order to limit the information volume e.g. a simple piece of data indicating that chassis X has some error . Any interested controller may then pull additional information from the switch.

Instead of requiring all the information needed by the controllers to be published proactively the network control system of some embodiments has the controllers pull the information from the lower layers as needed. For certain types of information it may be difficult to determine in advance whether the information is needed by any of the controllers and if it is needed which of the controllers needs the information. For this sort of information the controllers of some embodiments pull the information instead of passively receiving information automatically published by the lower layers. This enables the network control system in such embodiments to avoid the overhead of publishing all the information even when the information is not needed. The overhead cost is paid only when the information is actually needed when the controllers pull the information.

Examples of information better off pulled by the controllers than automatically published by the managed switching elements include the API operations that read information from the lower layers of the system. For instance when the API requests statistics of a particular logical port this information must be obtained from the switch to which the particular logical port maps. As not all of the statistical information would be consumed constantly it would be a waste of CPU resources to have the switching elements publishing this information regularly. Instead the controllers request this information when needed. Some embodiments combine the use of the upwards directed publishing push based information dissemination with the pull based dissemination. Specifically the switching elements publish a minimal amount of information indicating that more information is available and the controllers at the upper layers can then determine when they need to pull the additional information.

The preceding Summary is intended to serve as a brief introduction to some embodiments of the invention. It is not meant to be an introduction or overview of all inventive subject matter disclosed in this document. The Detailed Description that follows and the Drawings that are referred to in the Detailed Description will further describe the embodiments described in the Summary as well as other embodiments. Accordingly to understand all the embodiments described by this document a full review of the Summary Detailed Description and the Drawings is needed. Moreover the claimed subject matters are not to be limited by the illustrative details in the Summary Detailed Description and the Drawing but rather are to be defined by the appended claims because the claimed subject matters can be embodied in other specific forms without departing from the spirit of the subject matters.

In the following detailed description of the invention numerous details examples and embodiments of the invention are set forth and described. However it will be clear and apparent to one skilled in the art that the invention is not limited to the embodiments set forth and that the invention may be practiced without some of the specific details and examples discussed.

Some embodiments of the invention provide a network control system that allows several different logical datapath sets to be specified for several different users through one or more shared forwarding elements without allowing the different users to control or even view each other s forwarding logic. The shared forwarding elements in some embodiments can include virtual or physical network switches software switches e.g. Open vSwitch routers and or other switching devices as well as any other network elements such as load balancers etc. that establish connections between these switches routers and or other switching devices. Such forwarding elements e.g. physical switches or routers are also referred to below as switching elements. In contrast to an off the shelf switch a software forwarding element is a switching element that in some embodiments is formed by storing its switching table s and logic in the memory of a standalone device e.g. a standalone computer while in other embodiments it is a switching element that is formed by storing its switching table s and logic in the memory of a device e.g. a computer that also executes a hypervisor and one or more virtual machines on top of that hypervisor.

These managed shared switching elements are referred to below as managed switching elements or managed forwarding elements as they are managed by the network control system in order to implement the logical datapath sets. In some embodiments described below the control system manages these switching elements by pushing physical control plane data to them as further described below. Switching elements generally receive data e.g. a data packet and perform one or more processing operations on the data such as dropping a received data packet passing a packet that is received from one source device to another destination device processing the packet and then passing it to a destination device etc. In some embodiments the physical control plane data that is pushed to a switching element is converted by the switching element e.g. by a general purpose processor of the switching element to physical forwarding plane data that specify how the switching element e.g. how a specialized switching circuit of the switching element processes data packets that it receives.

In some embodiments the network control system includes one or more controllers also called controller instances below that allow the system to accept logical datapath sets from users and to configure the switching elements to implement these logical datapath sets. These controllers allow the system to virtualize control of the shared switching elements and the logical networks that are defined by the connections between these shared switching elements in a manner that prevents the different users from viewing or controlling each other s logical datapath sets and logical networks while sharing the same managed switching elements.

In some embodiments each controller instance is a device e.g. a general purpose computer that executes one or more modules that transform the user input from a logical control plane to a logical forwarding plane and then transform the logical forwarding plane data to physical control plane data. These modules in some embodiments include a control module and a virtualization module. A control module allows a user to specify and populate a logical datapath set while a virtualization module implements the specified logical datapath set by mapping the logical datapath set onto the physical switching infrastructure. In some embodiments the control and virtualization modules express the specified or mapped data in terms of records that are written into a relational database data structure. That is the relational database data structure stores both the logical datapath input received through the control module and the physical data to which the logical datapath input is mapped by the virtualization module. In some embodiments the control and virtualization applications are two separate applications while in other embodiments they are part of the same application.

The above describes several examples of the network control system. Several more detailed embodiments are described below. First Section I introduces a network controlled by distributed controller instances. Section II then describes the virtualized control system of some embodiments. Section III follows with a description of scheduling in the control system of some embodiments. Next Section IV describes the universal forwarding state used in some embodiments. Section V describes the use of transactionality. Next Section VI describes the distribution of network state between switching elements in some embodiments of the control system. Section VII then describes logical forwarding environment for some embodiments. Finally Section VIII describes an electronic system with which some embodiments of the invention are implemented.

As mentioned some of the embodiments described below are implemented in a novel network control system that is formed by one or more controllers controller instances for managing several managed switching elements. In some embodiments the control application of a controller receives logical control plane data e.g. network control plane and converts this data to logical forwarding plane data that is then supplied to the virtualization application. The virtualization application then generates the physical control plane data from the logical forwarding plane data. The physical control plane data is propagated to the managed switching elements.

In some embodiments the controller instance uses a network information base NIB data structure to send the physical control plane data to the managed switching elements. Several examples of using the NIB data structure to send the data down to the managed switching elements are described in U.S. patent application Ser. Nos. 13 177 529 now issued as U.S. Pat. No. 8 743 889 and 13 177 533 now issued as U.S. Pat. No. 8 817 620 which are incorporated herein by reference. As described in the U.S. application Ser. Nos. 13 177 529 and 13 177 533 a controller instance of some embodiments uses an nLog engine to generate logical forwarding plane data from logical control plane data and physical control plane data from the logical forwarding plane data. The controller instances of some embodiments communicate with each other to exchange the generated logical and physical data. In some embodiments the NIB data structure may serve as a communication medium between different controller instances. However some embodiments of the invention described below do not use the NIB data structure and instead use one or more communication channels e.g. RPC calls to exchange the logical data and or the physical data between different controller instances and to exchange other data e.g. API calls between the controller instances. The following describes such a network control system in greater detail.

The network control system of some embodiments uses different controllers to perform different tasks. The network control system of some embodiments includes groups of controllers with each group having different kinds of responsibilities. Some embodiments implement a controller cluster in a dynamic set of physical servers. Thus as the size of the deployment increases or when a particular controller or physical server on which a controller is operating fails the cluster and responsibilities within the cluster are reconfigured among the remaining active controllers. In order to manage such reconfigurations the controllers in the cluster of some embodiments run a consensus algorithm to determine a leader controller. The leader controller partitions the tasks for which each controller instance in the cluster is responsible by assigning a master controller for a particular work item and in some cases a hot standby controller to take over in case the master controller fails.

Within the controller cluster of some embodiments there are three or four types of controllers categorized based on three kinds of controller responsibilities. The first controller type is an application protocol interface API controller. API controllers are responsible for receiving configuration data and user queries from a user through API calls and responding to the user queries. The API controllers also disseminate the received configuration data to the other controllers. These controllers serve as the interface between users and the network control system. In some embodiment the API controllers are referred to as input translation controllers. A second type of controller is a logical controller which is responsible for implementing logical datapath sets by computing universal flow entries that realize the logical datapath sets. Examples of universal flow entries are described below. A logical controller in some embodiments does not interact directly with the physical switching elements but pushes the universal flow entries to a third type of controller a physical controller.

Physical controllers in different embodiments have different responsibilities. In some embodiments the physical controllers generate customized flow entries from the universal flow entries and push these customized flow entries down to the managed switching elements. In other embodiments the physical controller identifies for a particular managed physical switching element a fourth type of controller a chassis controller that is responsible for generating the customized flow entries for a particular switching element and forwards the universal flow entries it receives from the logical controller to the chassis controller. The chassis controller then generates the customized flow entries from the universal flow entries and pushes these customized flow entries to the managed switching elements. In yet other embodiments physical controllers generate customized flow entries for some managed switching elements while directing chassis controllers to generate such flow entries for other managed switching elements.

Depending on the size of the deployment managed by a controller cluster any number of each of the four types of controller may exist within the cluster. In some embodiments the leader controller has the responsibility of partitioning the load over all the controllers and effectively assigning a list of logical datapath sets for each logical controller to manage and a list of physical switching elements for each physical controller to manage. In some embodiments the API responsibilities are executed at each controller in the cluster. However similar to the logical and physical responsibilities some embodiments only run the API responsibilities on a subset of controllers. This subset in some such embodiments only performs API processing which results in better isolation between the API operations and the rest of the system.

In some embodiments the design spectrum for the computing the forwarding state by the controllers spans from either a completely centralized control system to a completely distributed control system. In a fully centralized system for example a single controller manages the entire network. While this design is simple to analyze and implement it runs into difficulty in meeting practical scalability requirements. A fully distributed network control system on the other hand provides both redundancy and scaling but comes with the challenge of designing a distributed protocol per network control problem. Traditional routing protocols distributed among the routers of a network are an example of such a distributed solution.

In the virtualization solution of some embodiments the network controller system strikes a balance between these goals of achieving the necessary scaling and redundancy without converging towards a fully decentralized solution that would potentially be very complicated to both analyze and implement. Thus the controllers of some embodiments are designed to run in a hierarchical manner with each layer in the hierarchy responsible for certain functionalities or tasks. The higher layers of the hierarchy focus on providing control over all of the aspects managed by the system whereas the lower layers become more and more localized in scope.

At the topmost level of the hierarchy in some embodiments are the logical controllers. In some embodiments each logical datapath set is managed by a single logical controller. Thus a single controller has full visibility to the state for the logical datapath set and the computation e.g. to generate flows for any particular logical datapath set is centralized in a single controller without requiring distribution over multiple controllers. Different logical controllers are then responsible for different logical datapath sets which provides the easy scalability at this layer. The logical controllers push the results of the computation which are universal flow based descriptions of the logical datapath sets to the physical controllers at the next layer below.

In some embodiments the physical controllers are the boundary between the physical and logical worlds of the control system. Each physical controller manages a subset of the managed switching elements of the network and is responsible for obtaining the universal flow information from the logical controllers and either 1 generating customized flow entries for its switching elements and pushing the customized flow entries to its switching elements or 2 pushing the received universal flow information to each switching element s chassis controller and having this chassis controller generate the customized flow entries for its switching element and push the generated flow entries to its switching element. In other words the physical controllers or chassis controllers of some embodiments translate the flow entries from a first physical control plane a universal physical control plane that is generic for any managed switching element used to implement a logical datapath set into a second physical control plane a customized physical control plane that is customized for a particular managed switching element associated with the physical controller or chassis controller.

As the number of switching elements e.g. both hardware and software switching elements managed by the system increases more physical controllers can be added so that the load of the switch management does not become a scalability bottleneck. However as the span of the logical datapath set i.e. the number of physical machines that host virtual machines connected to the logical datapath set increases the number of the logical datapath sets for which a single physical controller is responsible increases proportionally. If the number of logical datapath sets that the physical controller is required to handle grows beyond its limits the physical controller could become a bottleneck in the system. Nevertheless in embodiments where the physical controllers of some embodiments is primarily responsible for moving universal flow entries to chassis controller of physical switching elements that need the universal flows the computational overhead per logical datapath set should remain low.

In some embodiments the chassis controllers of the managed switching elements are at the lowest level of the hierarchical network control system. Each chassis controller receives universal flow entries from a physical controller and customizes these flow entries into a custom set of flow entries for its associated managed switching element. In some embodiments the chassis controller runs within its managed switching element or adjacent to its managed switching element.

The chassis controller is used in some embodiments to minimize the computational load on the physical controller. In these embodiments the physical controllers primarily act as a relay between the logical controllers and the chassis controller to direct the universal flow entries to the correct chassis controller for the correct managed switching elements. In several embodiments described below by reference to figures the chassis controllers are shown to be outside of the managed switching elements. Also in several of these embodiments the chassis controllers operate on the same host machine e.g. same computer on which the managed software switching element executes. In some embodiments the switching elements receive OpenFlow entries and updates over the configuration protocol from the chassis controller.

When placing the chassis controllers within or adjacent to the switching elements is not possible the physical controllers in some embodiments continue to perform the computation to translate universal flow information to customized flow information and send the physical flow information using OpenFlow and configuration protocols to the switching elements in which the chassis controllers are not available. For instance some hardware switching elements may not have the capability to run a controller. When the physical controller does not perform such customization and no controller chassis is available for a particular managed switching element another technique used by some embodiments is to employ daemons to generate custom physical control plane data from the universal physical control plane data. These alternative techniques are further described below.

As described above the computation results i.e. the creation of flows flow from the top of the hierarchy towards the switching elements. In addition information may flow in the opposite direction from the managed switching elements to the logical controllers. The primary reason for the logical controller to obtain information from the switching elements is the need to know the location of various virtual interfaces or virtual network interfaces VIFs among the managed switching elements. That is in order to compute the universal flow entries for a logical datapath set the logical controller is required to know the physical location in the network of the managed switching elements and the VIFs of the managed switching elements.

In some embodiments each managed switching elements reports its VIFs to the physical controller responsible for the switch. The physical controller then publishes this information to all of the logical controllers. As such the information flow from the switching elements to the logical controllers is done in a hierarchical manner but one that is upside down compared to the hierarchy used for computing the flow entries. Because this information may potentially reach more and more controllers as it traverses up the hierarchy the information should be limited in volume and not overly dynamic. This allows the publication of the information to avoid becoming a scalability bottleneck for the system while enabling the information to be obtained by the upper layers of the hierarchy as soon as or very shortly after the information is generated at the switching elements.

There are other uses for publishing information upwards beyond the need to know the location of the VIFs in the network. In some embodiments various error reporting subsystems at the controllers benefit from obtaining error reports from the switching elements in the case that such errors exist . As with the VIF information the switching elements of some embodiments only publish minimal information about the errors in order to limit the information volume e.g. a simple piece of data indicating that chassis X has some error . Any interested controller may then pull additional information from the switch.

Instead of requiring all the information needed by the controllers to be published proactively the network control system of some embodiments has the controllers pull the information from the lower layers as needed. For certain types of information it may be difficult to determine in advance whether the information is needed by any of the controllers and if it is needed which of the controllers needs the information. For this sort of information the controllers of some embodiments pull the information instead of passively receiving information automatically published by the lower layers. This enables the network control system in such embodiments to avoid the overhead of publishing all the information even when the information is not needed. The overhead cost is paid only when the information is actually needed when the controllers pull the information.

Examples of information better off pulled by the controllers than automatically published by the managed switching elements include the API operations that read information from the lower layers of the system. For instance when the API requests statistics of a particular logical port this information must be obtained from the switch to which the particular logical port maps. As not all of the statistical information would be consumed constantly it would be a waste of CPU resources to have the switching elements publishing this information regularly. Instead the controllers request this information when needed.

The downside to pulling information as opposed to receiving published information is responsiveness. Only by pulling a particular piece of information does a controller know whether the information was worth retrieving e.g. whether the pulled value has changed or not since the last pull . To overcome this downside some embodiments combine the use of the upwards directed publishing push based information dissemination with the pull based dissemination. Specifically the switching elements publish a minimal amount of information indicating that more information is available and the controllers at the upper layers can then determine when they need to pull the additional information.

Various mechanisms are used by some embodiments in order to realize the network control system described above. This application will describe both computational mechanisms e.g. for translating the forwarding state between data planes as well as mechanisms for disseminating information both intra controller communication and controller switch communication .

The computation of the forwarding state within a single controller may be performed by using an nLog engine in some embodiments. For both directions of information flow logical controller to switch and switch to logical controller the nLog engine running in a controller takes as input events received from other controllers or switching elements and outputs new events to send to the other controllers switching elements. To compute the forwarding state at each level of the hierarchy an nLog engine is responsible for receiving the network state e.g. in the form of tuples from the higher layers computing the state in a new data plane e.g. also in the form of tuples and pushing the computed information downwards. To publish information upwards the controllers and switching elements use the same approach in some embodiments with only the direction and type of computations performed by the nLog engine being different. That is the nLog engine receives the network state tuples from the lower layers and computes the state in a new data plane tuples to be published or pulled upwards.

API queries are computed in some embodiments. In some embodiments the API query processing can be transformed into nLog processing an incoming event corresponds to a query which may result in a tuple being computed locally. Similarly the query processing may result in recursive query processing the query processing at the first level controllers results in a new tuple that corresponds to a query to be sent to next level controllers and the first query does not finish before it receives the response from the controller below.

Thus some embodiments include a hierarchy of controllers that each locally uses nLog to process received updates requests and produce new updates responses. In order to carry out such a hierarchy the controllers need to be able to communicate with each other. As the computation in these embodiments is based on nLog tuples are the primary for of state information that needs to be transferred for the forwarding state and API querying. As such some embodiments allow the nLog instances to directly integrate with a channel that provides a tuple level transport between controllers so that nLog instances can easily send tuples to other controllers. Using this channel nLog can provide the publishing of information both upwards and downwards as well as implement the query like processing using tuples to correspond queries and the responses to the queries.

The channel used for this communication in some embodiments is a remote procedure call RPC channel providing batching of tuple updates so that an RPC call is not required for every tuple and an RPC call handles a batch of tuples . In addition the transactional aspects utilize a concept of commit both blocking and non blocking from the channel in some embodiments.

By using the RPC channels to exchange tuples directly among controllers and switching elements the network control system of some embodiments can avoid using an objected oriented programming presentation e.g. the NIB presentation described in U.S. patent application Ser. No. 13 177 529 of the state exchanged between the controllers. That is the nLog instances in some embodiments transform the inputs outputs between the NIB and tuple formats when entering or leaving the nLog runtime system while in other embodiments such translation becomes unnecessary and the implementation becomes simpler because the tuples can be exchanged directly among controllers and switching elements. Thus in these embodiments the state dissemination mechanism is actually point to point between controllers.

However the information flows among the controllers of these embodiments possess two identifiable patterns built on the point to point channels. The first such information flow pattern is flooding. Certain information e.g. the location of VIFs is flooded to a number of controllers by sending the same information across multiple RPC channels. The second such pattern is point to point information flow. Once minimal information has been flooded so that a controller can identify which available information is actually needed the controllers can then transfer the majority of the information across RPC channels directly between the producing and consuming controllers without reverting to more expensive flooding.

Prior to a more extensive discussion of the network control system of some embodiments some examples of its use will now be provided. First in order to compute flows an API controller of some embodiments creates an RPC channel to a logical controller responsible for a logical datapath set and sends logical datapath set configuration information to the logical controller. In addition the API controller sends physical chassis configuration information to a physical controller managing the chassis. The physical controller receives VIF locations from its managed switching elements and floods the VIF locations to all of the logical controllers. This information allows the logical controller to identify the one or more physical chassis that host the VIFs belonging to the logical datapath set. Using this information the logical controller computes the universal flows for the logical datapath set and creates an RPC channel to the physical controllers that manage the chassis hosting the logical datapath set in order to push the universal flow information down to these physical controllers. The physical controller can then relay the universal flows or translated physical flows down to the chassis controller at the managed switch.

A second example use of the network control system is the processing of an API query. In some embodiments an API controller receives a request for port statistics for a particular logical port. The API controller redirects the request to the logical controller responsible for managing the logical datapath set that contains the particular logical port. The logical controller then queries the physical controller that hosts the VIF bound to the particular logical port and the physical controller in turn queries the chassis or chassis controller at which the VIF is located for this information and responds back. Each of these information exchanges API controller to logical controller to physical controller to chassis and back occurs over RPC channels.

As shown in the system includes one or more switching elements and a network controller . The switching elements include N switching devices where N is a number equal to one or greater that form the network infrastructure switching elements of the system . In some embodiments the network infrastructure switching elements includes virtual or physical network switches software switches e.g. Open vSwitch routers and or other switching devices as well as any other network elements such as load balancers etc. that establish connections between these switches routers and or other switching devices. All such network infrastructure switching elements are referred to below as switching elements or forwarding elements.

The virtual or physical switching devices typically include control switching logic and forwarding switching logic . In some embodiments a switch s control logic specifies 1 the rules that are to be applied to incoming packets 2 the packets that will be discarded and 3 the packet processing methods that will be applied to incoming packets. The virtual or physical switching elements use the control logic to populate tables governing the forwarding logic . The forwarding logic performs lookup operations on incoming packets and forwards the incoming packets to destination addresses.

As further shown in the network controller includes a control application through which switching logic is specified for one or more users e.g. by one or more administrators or users in terms of LDP sets. The network controller also includes a virtualization application that translates the LDP sets into the control switching logic to be pushed to the switching devices . In this application the control application and the virtualization application are referred to as control engine and virtualization engine for some embodiments.

In some embodiments the virtualization system includes more than one network controller . The network controllers include logical controllers that each is responsible for specifying control logic for a set of switching devices for a particular LDPS. The network controllers also include physical controllers that each pushes control logic to a set of switching elements that the physical controller is responsible for managing. In other words a logical controller specifies control logic only for the set of switching elements that implement the particular LDPS while a physical controller pushes the control logic to the switching elements that the physical controller manages regardless of the LDP sets that the switching elements implement.

In some embodiments the virtualization application of a network controller uses a relational database data structure to store a copy of the switch element states tracked by the virtualization application in terms of data records e.g. data tuples . The switch element tracking will be described in detail further below. These data records represent a graph of all physical or virtual switching elements and their interconnections within a physical network topology and their forwarding tables. For instance in some embodiments each switching element within the network infrastructure is represented by one or more data records in the relational database data structure. However in other embodiments the relational database data structure for the virtualization application stores state information about only some of the switching elements. For example as further described below the virtualization application in some embodiments only keeps track of switching elements at the edge of a network infrastructure. In yet other embodiments the virtualization application stores state information about edge switching elements in a network as well as some non edge switching elements in the network that facilitate communication between the edge switching elements.

In some embodiments the relational database data structure is the heart of the control model in the virtualized network system . Under one approach applications control the network by reading from and writing to the relational database data structure. Specifically in some embodiments the application control logic can 1 read the current state associated with network entity records in the relational database data structure and 2 alter the network state by operating on these records. Under this model when a virtualization application needs to modify a record in a table e.g. a control plane flow table of a switching element the virtualization application first writes one or more records that represent the table in the relational database data structure. The virtualization application then propagates this change to the switching element s table.

In some embodiments the control application also uses the relational database data structure to store the logical configuration and the logical state for each user specified LDPS. In these embodiments the information in the relational database data structure that represents the state of the actual switching elements accounts for only a subset of the total information stored in the relational database data structure.

In some embodiments the control and virtualization applications use a secondary data structure to store the logical configuration and the logical state for a user specified LDPS. This secondary data structure in these embodiments serves as a communication medium between different network controllers. For instance when a user specifies a particular LDPS using a logical controller that is not responsible for the particular LDPS the logical controller passes the logical configuration for the particular LDPS to another logical controller that is responsible for the particular LDPS via the secondary data structures of these logical controllers. In some embodiments the logical controller that receives from the user the logical configuration for the particular LDPS passes the configuration data to all other controllers in the virtualized network system. In this manner the secondary storage structure in every logical controller includes the logical configuration data for all LDP sets for all users in some embodiments.

The operating system of some embodiments provides a set of different communication constructs not shown for the control and virtualization applications and the switching elements of different embodiments. For instance in some embodiments the operating system provides a managed switching element communication interface not shown between 1 the switching elements that perform the physical switching for any one user and 2 the virtualization application that is used to push the switching logic for the users to the switching elements. In some of these embodiments the virtualization application manages the control switching logic of a switching element through a commonly known switch access interface that specifies a set of APIs for allowing an external application such as a virtualization application to control the control plane functionality of a switching element. Specifically the managed switching element communication interface implements the set of APIs so that the virtualization application can send the records stored in the relational database data structure to the switching elements using the managed switching element communication interface. Two examples of such known switch access interfaces are the OpenFlow interface and the Open Virtual Managed switching element communication interface which are respectively described in the following two papers McKeown N. 2008 . which can be retrieved from http www.openflowswitch.org documents openflow wp latest.pdf and Pettit J. 2010 . which can be retrieved from http openvswitch.org papers dccaves2010.pdf . These two papers are incorporated herein by reference.

It is to be noted that for those embodiments described above and below where the relational database data structure is used to store data records a data structure that can store data in the form of object oriented data objects can be used alternatively or conjunctively. An example of such data structure is the NIB data structure.

In order to define the control switching logic for switching elements when the switching elements are physical switching elements as opposed to software switches the virtualization application of some embodiments uses the Open Virtual Switch protocol to create one or more control tables within the control plane of a switch. The control plane is typically created and executed by a general purpose CPU of the switching element. Once the system has created the control table s the virtualization application then writes flow entries to the control table s using the OpenFlow protocol. The general purpose CPU of the physical switching element uses its internal logic to convert entries written to the control table s to populate one or more forwarding tables in the forwarding plane of the switching element. The forwarding tables are created and executed typically by a specialized switching chip of the switching element. Through its execution of the flow entries within the forwarding tables the switching chip of the switching element can process and route packets of data that it receives.

In some embodiments the virtualized network system includes a chassis controller in addition to logical and physical controllers. In these embodiments the chassis controller implements the switch access APIs to manage a particular switching element. That is it is the chassis controller that pushes the control logic to the particular switching element. The physical controller in these embodiments functions as an aggregation point to relay the control logic from the logical controllers to the chassis controllers interfacing the set of switching elements for which the physical controller is responsible. The physical controller distributes the control logic to the chassis controllers managing the set of switching elements. In these embodiments the managed switching element communication interface that the operating system of a network controller establishes a communication channel e.g. a Remote Procedure Call RPC channel between a physical controller and a chassis controller so that the physical controller can send the control logic stored as data records in the relational database data structure to the chassis controller. The chassis controller in turn will push the control logic to the switching element using the switch access APIs or other protocols.

The communication constructs that the operating system of some embodiments provides also include an exporter not shown that a network controller can use to send data records to another network controller e.g. from a logical controller to another logical controller from a physical controller to another physical controller from a logical controller to a physical controller from a physical controller to a logical controller etc. . Specifically the control application and the virtualization application of a network controller can export the data records stored in the relational database data structure to one or more other network controllers using the exporter. In some embodiments the exporter establishes a communication channel e.g. an RPC channel between two network controllers so that one network controller can send data records to another network controller over the channel.

The operating system of some embodiments also provides an importer that a network controller can use to receive data records from an network controller. The importer of some embodiments functions as a counterpart to the exporter of another network controller. That is the importer is on the receiving end of the communication channel established between two network controllers. In some embodiments the network controllers follow a publish subscribe model in which a receiving controller subscribes to channels to receive data only from the network controllers that supply the data in which the receiving controller is interested.

In the first stage the control application writes three new values d e f to the record in this example. The values d e f represent logical data e.g. a logical flow entry generated by the control engine . The second stage shows that the virtualization engine detects and reads the values d e f to use as an input to generate physical data e.g. a physical flow entry . The third stage illustrates that the virtualization engine generates values x y z based on the values d e f and writes the values x y z into the relational database data structure specifically into the record .

Next the network controller writes the values x y z into the managed switching element . In some embodiments the network controller performs a translation operation that modifies the format of the record before writing the record into the switch. These operations are pictorially illustrated in by showing the values x y z translated into x y z and the writing of these new values into the managed switching element . In these embodiments the managed switching element communication interface not shown of the network controller would perform the translation and send the translated record to the managed switching element using switch access APIs e.g. OpenFlow .

The network controller illustrated in has a single relational database data structure in some embodiments. However in other embodiments the network controller has more than one relational database data structure to store records written and read by the control and virtualization engines. For instance the control engine and the virtualization engine may each have a separate relational database data structure from which to read data and to which to write data.

As mentioned above the relational database data structure in some embodiments stores data regarding each switching element within the network infrastructure of a system while in other embodiments the relational database data structure only stores state information about switching elements at the edge of a network infrastructure. illustrate an example that differentiates the two differing approaches. Specifically illustrates the switch infrastructure of a multi user server hosting system. In this system six switching elements are employed to interconnect six machines of two users A and B. Four of these switching elements are edge switching elements that have direct connections with the machines of the users A and B while two of the switching elements and are interior switching elements i.e. non edge switching elements that interconnect the edge switching elements and connect to each other. All the switching elements illustrated in the Figures described above and below may be software switching elements in some embodiments while in other embodiments the switching elements are mixture of software and physical switching elements. For instance the edge switching elements as well as the non edge switching elements are software switching elements in some embodiments. Also machines described in this application include virtual machines and physical machines such as computing devices.

The controller of some embodiments only controls edge switching elements i.e. only maintains data in the relational database data structure regarding edge switching elements for several reasons. Controlling edge switching elements provides the controller with a sufficient mechanism for maintaining isolation between machines e.g. computing devices which is needed as opposed to maintaining isolation between all switching elements which is not needed. The interior switching elements forward data packets between switching elements. The edge switching elements forward data packets between machines and other network elements e.g. other switching elements . Thus the controller can maintain user isolation simply by controlling the edge switching element because the edge switching element is the last switching element in line to forward packets to a machine.

Controlling only edge switching element also allows the controller to be deployed independent of concerns about the hardware vendor of the non edge switching elements because deploying at the edge allows the edge switching elements to treat the internal nodes of the network as simply a collection of elements that moves packets without considering the hardware makeup of these internal nodes. Also controlling only edge switching elements makes distributing switching logic computationally easier. Controlling only edge switching elements also enables non disruptive deployment of the controller because edge switching solutions can be added as top of rack switching elements without disrupting the configuration of the non edge switching elements.

In addition to controlling edge switching elements the network controller of some embodiments also utilizes and controls non edge switching elements that are inserted in the switch network hierarchy to simplify and or facilitate the operation of the controlled edge switching elements. For instance in some embodiments the controller requires the switching elements that it controls to be interconnected in a hierarchical switching architecture that has several edge switching elements as the leaf nodes and one or more non edge switching elements as the non leaf nodes. In some such embodiments each edge switching element connects to one or more of the non leaf switching elements and uses such non leaf switching elements to facilitate its communication with other edge switching elements. Examples of functions that a non leaf switching element of some embodiments may provide to facilitate such communications between edge switching elements in some embodiments include 1 forwarding of a packet with an unknown destination address e.g. unknown MAC address to the non leaf switching element so that this switching element can route this packet to the appropriate edge switch 2 forwarding a multicast or broadcast packet to the non leaf switching element so that this switching element can convert this packet to a series of unicast packets to the desired destinations 3 bridging remote managed networks that are separated by one or more networks and 4 bridging a managed network with an unmanaged network.

Some embodiments employ one level of non leaf non edge switching elements that connect to edge switching elements and to other non leaf switching elements. Other embodiments on the other hand employ multiple levels of non leaf switching elements with each level of non leaf switching element after the first level serving as a mechanism to facilitate communication between lower level non leaf switching elements and leaf switching elements. In some embodiments the non leaf switching elements are software switching elements that are implemented by storing the switching tables in the memory of a standalone computer instead of an off the shelf switch. In some embodiments the standalone computer may also be executing in some cases a hypervisor and one or more virtual machines on top of that hypervisor. Irrespective of the manner by which the leaf and non leaf switching elements are implemented the relational database data structure of the controller of some embodiments stores switching state information regarding the leaf and non leaf switching elements.

The above discussion relates to the control of edge switching elements and non edge switching elements by a network controller of some embodiments. In some embodiments edge switching elements and non edge switching elements leaf and non leaf nodes may be referred to as managed switching elements. This is because these switching elements are managed by the network controller as opposed to unmanaged switching elements which are not managed by the network controller in the network in order to implement LDP sets through the managed switching elements.

Network controllers of some embodiments implement a logical switching element across the managed switching elements based on the physical data and the logical data described above. A logical switching element can be defined to function any number of different ways that a switching element might function. The network controllers implement the defined logical switching element through control of the managed switching elements. In some embodiments the network controllers implement multiple logical switching elements across the managed switching elements. This allows multiple different logical switching elements to be implemented across the managed switching elements without regard to the network topology of the network.

The managed switching elements of some embodiments can be configured to route network data based on different routing criteria. In this manner the flow of network data through switching elements in a network can be controlled in order to implement multiple logical switching elements across the managed switching elements.

The managed switching elements of some embodiments route network data e.g. packets frames etc. between network elements in the network that are coupled to the managed switching elements . As shown the managed switching element routes network data between the machines and and the switching element . Similarly the switching element routes network data between the machine and the managed switching elements and and the switching element routes network data between the machines and the switching element .

Moreover each of the managed switching elements routes network data based on the switch s forwarding logic which in some embodiments are in the form of tables. In some embodiments a forwarding table determines where to route network data e.g. a port on the switch according to routing criteria. For instance a forwarding table of a layer 2 switching element may determine where to route network data based on MAC addresses e.g. source MAC address and or destination MAC address . As another example a forwarding table of a layer 3 switching element may determine where to route network data based on IP addresses e.g. source IP address and or destination IP address . Many other types of routing criteria are possible.

As shown in the forwarding table in each of the managed switching elements includes several records. In some embodiments each of the records specifies operations for routing network data based on routing criteria. The records may be referred to as flow entries in some embodiments as the records control the flow of data through the managed switching elements .

The following will describe the conceptual flow entries for implementing the flow of network data originating from the machine and destined for the machine and originating from the machine and destined for the machine . First the flow entries for routing network data originating from the machine and destined for the machine will be described followed by the flow entries for routing network data originating from the machine and destined for the machine .

The flow entry A to A in the managed switching element s forwarding table instructs the managed switching element to route network data that originates from machine and is destined for the machine to the switching element . The flow entry A to A in the forwarding table of the switching element instructs the switching element to route network data that originates from machine and is destined for the machine to the machine . Therefore when the machine sends network data that is destined for the machine the managed switching elements and route the network data along datapath based on the corresponding records in the switching elements forwarding tables.

Furthermore the flow entry A to A in the managed switching element s forwarding table instructs the managed switching element to route network data that originates from machine and is destined for the machine to the switching element . The flow entry A to A in the forwarding table of the switching element instructs the switching element to route network data that originates from machine and is destined for the machine to the switching element . The flow entry A to A in the forwarding table of the switching element instructs the switching element to route network data that originates from machine and is destined for the machine to the machine . Thus when the machine sends network data that is destined for the machine the managed switching elements route the network data along datapaths and based on the corresponding records in the switching elements forwarding tables.

While conceptual flow entries for routing network data originating from the machine and destined for the machine and originating from the machine and destined for the machine are described above similar flow entries would be included in the forwarding tables of the managed switching elements for routing network data between other machines in user A s logical network . Moreover similar flow entries would be included in the forwarding tables of the managed switching elements for routing network data between the machines in user B s logical network .

The conceptual flow entries shown in includes both the source and destination information for the managed switching elements to figure out the next hop switching elements to which to send the packets. However the source information does not have to be in the flow entries as the managed switching elements of some embodiments can figures out the next hope switching elements using the destination information e.g. a context identifier a destination address etc. only.

In some embodiments tunnels provided by tunneling protocols e.g. control and provisioning of wireless access points CAPWAP generic route encapsulation GRE GRE Internet Protocol Security IPsec etc. may be used to facilitate the implementation of the logical switching elements and across the managed switching elements . By tunneling a packet is transmitted through the switches and routers as a payload of another packet. That is a tunneled packet does not have to expose its addresses e.g. source and destination MAC addresses as the packet is forwarded based on the addresses included in the header of the outer packet that is encapsulating the tunneled packet. Tunneling therefore allows separation of logical address space from the physical address space as a tunneled packet can have addresses meaningful in the logical address space while the outer packet is forwarded routed based on the addresses in the physical address space. In this manner the tunnels may be viewed as the logical wires that connect managed switching elements in the network in order to implement the logical switches and .

In some embodiments unidirectional tunnels are used. For instance a unidirectional tunnel between the managed switching element and the switching element may be established through which network data originating from the machine and destined for the machine is transmitted. Similarly a unidirectional tunnel between the managed switching element and the switching element may be established through which network data originating from the machine and destined for the machine is transmitted. In some embodiments a unidirectional tunnel is established for each direction of network data flow between two machines in the network.

Alternatively or in conjunction with unidirectional tunnels bidirectional tunnels can be used in some embodiments. For instance in some of these embodiments only one bidirectional tunnel is established between two switching elements. Referring to as an example a tunnel would be established between the managed switching elements and a tunnel would be established between the managed switching elements and and a tunnel would be established between the managed switching elements and .

Configuring the switching elements in the various ways described above to implement multiple logical switching elements across a set of switching elements allows multiple users from the perspective of each user to each have a separate network and or switching element while the users are in fact sharing some or all of the same set of switching elements and or connections between the set of switching elements e.g. tunnels physical wires .

Although illustrates implementation of logical switching elements in a set of managed switching elements it is possible to implement a more complex logical network e.g. that includes several logical L3 routers by configuring the forwarding tables of the managed switching elements. conceptually illustrates an example of a more complex logical network. illustrates an network architecture of some embodiments which implements a logical router and logical switching elements and . Specifically the network architecture represents a physical network that effectuate logical networks whose data packets are switched and or routed by the logical router and the logical switching elements and . The figure illustrates in the top half of the figure the logical router and the logical switching elements and . This figure illustrates in the bottom half of the figure the managed switching elements and . The figure illustrates machines in both the top and the bottom of the figure.

In this example the logical switching element forwards data packets between the logical router machine and machine . The logical switching element forwards data packets between the logical router machine and machine . As mentioned above the logical router routes data packets between the logical switching elements and and other logical routers and switches not shown . The logical switching elements and and the logical router are logically coupled through logical ports not shown and exchange data packets through the logical ports. These logical ports are mapped or attached to physical ports of the managed switching elements and .

In some embodiments a logical router is implemented in each managed switching element in the managed network. When the managed switching element receives a packet from a machine that is coupled to the managed switching element the managed switching element performs the logical routing. In other words a managed switching element that is a first hop switching element with respect to a packet performs the logical routing in these embodiments.

In this example the managed switching elements and are software switching elements running in hosts and respectively. The managed switching elements and have flow entries which implement the logical switching elements and to forward and route the packets the managed switching element and receive from machines . The flow entries also implement the logical router . Using these flow entries the managed switching elements and can forward and route packets between network elements in the network that are coupled to the managed switching elements and .

As shown the managed switching elements and each have three ports e.g. VIFs through which to exchange data packets with the network elements that are coupled to the managed switching elements and . In some cases the data packets in these embodiments will travel through a tunnel that is established between the managed switching elements and e.g. the tunnel that terminates at port of the managed switching element and port of the managed switching element . This tunnel makes it possible to separate addresses in logical space and the addresses in physical space. That is information about the logical ports e.g. association between the machines MAC addresses and logical ports of logical switching elements association between network addresses and logical ports of the logical router etc. can be encapsulated by the header of the outer packet that establishes the tunnel. Also because the information is encapsulated by the outer header the information will not be exposed to the network elements such as other switches and routers not shown in the network .

In this example each of the hosts and includes a managed switching element and several machines as shown. The machines are virtual machines that are each assigned a set of network addresses e.g. a MAC address for L2 an IP address for network L3 etc. and can send and receive network data to and from other network elements. The machines are managed by hypervisors not shown running on the hosts and . The machines and are associated with logical ports and respectively of the same logical switch . However the machine is associated with the port of the managed switching element and the machine is associated with the port of the managed switching element . The logical ports and are therefore mapped to the ports and respectively but this mapping does not have to be exposed to any of the network elements not shown in the network. This is because the packets that include this mapping information will be exchanged between the machines and over the tunnel based on the outer header of the outer packets that carry the packets with mapping information as payloads.

In some embodiments these four layers are in the same controller instance. However other arrangements of these layers exist in other embodiments. For instance in other embodiments only the control and virtualization layers and are in the same controller instance but the functionality to propagate the customized physical control plane data reside in a customization layer of another controller instance e.g. a chassis controller not shown . In these other embodiments the universal control plane data is transferred from the relational database data structure not shown of one controller instance to the relational database data structure of another controller instance before this other controller instance generates and pushes the customized physical control plane data to the managed switching element. The former controller instance may be a logical controller that generates universal control plane data and the latter controller instance may be a physical controller or a chassis controller that customizes the universal control plane data in to customized physical control plane data.

As shown in the input translation layer in some embodiments has a logical control plane that can be used to express the output of this layer. In some embodiments an application e.g. web based application not shown is provided to the users for them to supply inputs specifying the LDP sets. This application sends the inputs in the form of API calls to the input translation layer which translates them into logical control plane data in a format that can be processed by the control layer . For instance the inputs are translated into a set of input events that can be fed into nLog table mapping engine of the control layer. The nLog table mapping engine and its operation will be described further below.

The control layer in some embodiments has the logical control plane and the logical forwarding plane that can be used to express the input and output to this layer. The logical control plane includes a collection of higher level constructs that allow the control layer and its users to specify one or more LDP sets within the logical control plane for one or more users. The logical forwarding plane represents the LDP sets of the users in a format that can be processed by the virtualization layer . In this manner the two logical planes and are virtualization space analogs of the control and forwarding planes and that typically can be found in a typical managed switching element as shown in .

In some embodiments the control layer defines and exposes the logical control plane constructs with which the layer itself or users of the layer define different LDP sets within the logical control plane. For instance in some embodiments the logical control plane data includes logical ACL data etc. Some of this data e.g. logical ACL data can be specified by the user while other such data e.g. the logical L2 or L3 records are generated by the control layer and may not be specified by the user. In some embodiments the control layer generates and or specifies such data in response to certain changes to the relational database data structure which indicate changes to the managed switching elements and the managed datapaths that the control layer detects.

In some embodiments the logical control plane data i.e. the LDP sets data that is expressed in terms of the control plane constructs can be initially specified without consideration of current operational data from the managed switching elements and without consideration of the manner by which this control plane data will be translated to physical control plane data. For instance the logical control plane data might specify control data for one logical switch that connects five computers even though this control plane data might later be translated to physical control data for three managed switching elements that implement the desired switching between the five computers.

The control layer includes a set of modules for converting any LDPS within the logical control plane to a LDPS in the logical forwarding plane . In some embodiments the control layer uses the nLog table mapping engine to perform this conversion. The control layer s use of the nLog table mapping engine to perform this conversion is further described below. The control layer also includes a set of modules for pushing the LDP sets from the logical forwarding plane of the control layer to a logical forwarding plane of the virtualization layer .

The logical forwarding plane includes one or more LDP sets of one or more users. The logical forwarding plane in some embodiments includes logical forwarding data for one or more LDP sets of one or more users. Some of this data is pushed to the logical forwarding plane by the control layer while other such data are pushed to the logical forwarding plane by the virtualization layer detecting events in the relational database data structure as further described below for some embodiments.

In addition to the logical forwarding plane the virtualization layer includes a universal physical control plane . The universal physical control plane includes a universal physical control plane data for the LDP sets. The virtualization layer includes a set of modules not shown for converting the LDP sets within the logical forwarding plane to universal physical control plane data in the universal physical control plane . In some embodiments the virtualization layer uses the nLog table mapping engine to perform this conversion. The virtualization layer also includes a set of modules not shown for pushing the universal physical control plane data from the universal physical control plane of the virtualization layer into the relational database data structure of the customization layer .

In some embodiments the universal physical control plane data that is sent to the customization layer allows managed switching element to process data packets according to the LDP sets specified by the control layer . However in contrast to the customized physical control plane data the universal physical control plane data is not a complete implementation of the logical data specified by the control layer because the universal physical control plane data in some embodiments does not express the differences in the managed switching elements and or location specific information of the managed switching elements.

The universal physical control plane data has to be translated into the customized physical control plane data for each managed switching element in order to completely implement the LDP sets at the managed switching elements. For instance when the LDP sets specifies a tunnel that spans several managed switching elements the universal physical control plane data expresses one end of the tunnel using a particular network address e.g. IP address of the managed switching element representing that end. However each of the other managed switching elements over which the tunnel spans uses a port number that is local to the managed switching element to refer to the end managed switching element having the particular network address. That is the particular network address has to be translated to the local port number for each of the managed switching elements in order to completely implement the LDP sets specifying the tunnel at the managed switching elements.

The universal physical control plane data as intermediate data to be translated into customized physical control plane data enables the control system of some embodiments to scale assuming that the customization layer is running in another controller instance. This is because the virtualization layer does not have to convert the logical forwarding plane data specifying the LDP sets to customized physical control plane data for each of the managed switching elements that implements the LDP sets. Instead the virtualization layer converts the logical forwarding plane data to universal physical control data once for all the managed switching elements that implement the LDP sets. In this manner the virtualization application saves computational resources that it would otherwise have to spend to perform conversion of the LDP sets to customized physical control plane data for as many times as the number of the managed switching elements that implement the LDP sets.

The customization layer includes the universal physical control plane and a customized physical control plane that can be used to express the input and output to this layer. The customization layer includes a set of modules not shown for converting the universal physical control plane data in the universal physical control plane into customized physical control plane data in the customized physical control plane . In some embodiments the customization layer uses the nLog table mapping engine to perform this conversion. The customization layer also includes a set of modules not shown for pushing the customized physical control plane data from the customized physical control plane of the customization layer into the managed switching elements .

As mentioned above customized physical control plane data that is pushed to each managed switching element is specific to the managed switching element. The customized physical control plane data allows the managed switching element to perform physical switching operations in both the physical and logical data processing domains. In some embodiments the customization layer runs in a separate controller instance for each of the managed switching elements .

In some embodiments the customization layer does not run in a controller instance. The customization layer in these embodiments reside in the managed switching elements . Therefore in these embodiments the virtualization layer sends the universal physical control plane data to the managed switching elements. Each managed switching element will customize the universal physical control plane data into customized physical control plane data specific to the managed switching element. In some of these embodiments a controller daemon will be running in each managed switching element and will perform the conversion of the universal data into the customized data for the managed switching element. A controller daemon will be described further below.

The input module of a controller instance is similar to the input translation layer described above by reference to in that the input module takes inputs from users and translates the inputs into logical control plane data that the control module would understand and process. As mentioned above the inputs are in the form of API calls in some embodiments. The input module sends the logical control plane data to the control module .

The control module of a controller instance is similar to the control layer in that the control module converts the logical control plane data into logical forwarding plane data and pushes the logical forwarding plane data into the virtualization module . In addition the control module determines whether the received logical control plane data is of the LDPS that the controller instance is managing. If the controller instance is the master of the LDPS for the logical control plane data the virtualization module of the controller instance will further process the data. Otherwise the control module stores the logical control plane data in the secondary storage .

The virtualization module of a controller instance is similar to the virtualization layer in that the virtualization module converts the logical forwarding plane data into the universal physical control plane data. The virtualization module of some embodiments then sends the universal physical control plane data to another controller instance through inter instance communication interface or to the managed switching elements through the managed switching element communication interface .

The virtualization module sends the universal physical control plane data to another instance when the other controller instance is a physical controller that is responsible for managing the managed switching elements that implement the LDPS. This is the case when the controller instance on which the virtualization module has generated the universal control plane data is just a logical controller responsible for a particular LDPS but is not a physical controller or a chassis controller responsible for the managed switching elements that implement the LDPS.

The virtualization module sends the universal physical control plane data to the managed switching elements when the managed switching elements are configured to convert the universal physical control plane data into the customized physical control plane data specific to the managed switching elements. In this case the controller instance would not have a customization layer or module that would perform the conversion from the universal physical control plane data into the customized physical control plane data.

The records in some embodiments is a set of records stored in the relational database data structure of a controller instance. In some embodiments some or all of the input module the control module and the virtualization modules use update and manage the records stored in the relational database data structure. That is the inputs and or outputs of these modules are stored in the relational database data structure.

In some embodiments the system maintains the same switching element data records in the relational database data structure of each instance while in other embodiments the system allows the relational database data structures of different instances to store different sets of switching element data records based on the LDPS s that each controller instance is managing.

The PTD is a secondary storage structure for storing user specified network configuration data e.g. logical control plane data converted from the inputs in the form of API calls . In some embodiments the PTD of each controller instance stores the configuration data for all users using the system . The controller instance that receives the user input propagates the configuration data to the PTDs of other controller instances such that every PTD of every controller instance has all the configuration data for all users in these embodiments. In other embodiments however the PTD of a controller instance only stores the configuration data for a particular LDPS that the controller instance is managing.

By allowing different controller instances to store the same or overlapping configuration data and or secondary storage structure records the system improves its overall resiliency by guarding against the loss of data due to the failure of any network controller or failure of the relational database data structure instance and or the secondary storage structure instance . For instance replicating the PTD across controller instances enables a failed controller instance to quickly reload its PTD from another instance.

The inter instance communication interface is similar to an exporter of a controller instance described above in that this interface establishes a communication channel e.g. an RPC channel with another controller instance. As shown the inter instance communication interfaces facilitate the data exchange between different controller instances .

The managed switching element communication interface as mentioned above facilitates the communication between a controller instance and a managed switching element. In some embodiments the managed switching element communication interface converts the universal physical control plane data generated by the virtualization module into the customized physical control plane data specific to each managed switching element that is not capable of converting the universal data into the customized data.

For some or all of the communications between the distributed controller instances the system uses the coordination managers CMs . The CM in each instance allows the instance to coordinate certain activities with the other instances. Different embodiments use the CM to coordinate the different sets of activities between the instances. Examples of such activities include writing to the relational database data structure writing to the PTD controlling the switching elements facilitating inter controller communication related to fault tolerance of controller instances etc. Also CMs are used to find the masters of LDPS and the masters of managed switching elements.

As mentioned above different controller instances of the system can control the operations of the same switching elements or of different switching elements. By distributing the control of these operations over several instances the system can more easily scale up to handle additional switching elements. Specifically the system can distribute the management of different switching elements to different controller instances in order to enjoy the benefit of efficiencies that can be realized by using multiple controller instances. In such a distributed system each controller instance can have a reduced number of switching elements under management thereby reducing the number of computations each controller needs to perform to distribute flow entries across the switching elements. In other embodiments the use of multiple controller instances enables the creation of a scale out network management system. The computation of how best to distribute network flow tables in large networks is a CPU intensive task. By splitting the processing over controller instances the system can use a set of more numerous but less powerful computer systems to create a scale out network management system capable of handling large networks.

To distribute the workload and to avoid conflicting operations from different controller instances the system of some embodiments designates one controller instance e.g. within the system as the master of a LDPS and or any given managed switching element i.e. as a logical controller or a physical controller . In some embodiments each master controller instance stores in its relational database data structure only the data related to the managed switching elements which the master is handling.

In some embodiments as noted above the CMs facilitate inter controller communication related to fault tolerance of controller instances. For instance the CMs implement the inter controller communication through the secondary storage described above. A controller instance in the control system may fail due to any number of reasons. e.g. hardware failure software failure network failure etc. . Different embodiments may use different techniques for determining whether a controller instance has failed. In some embodiments a consensus protocol is used to determine whether a controller instance in the control system has failed. While some of these embodiments may use Apache Zookeeper to implement the consensus protocols other embodiments may implement the consensus protocol in other ways.

Some embodiments of the CM may utilize defined timeouts to determine whether a controller instance has failed. For instance if a CM of a controller instance does not respond to a communication e.g. sent from another CM of another controller instance in the control system within an amount of time i.e. a defined timeout amount the non responsive controller instance is determined to have failed. Other techniques may be utilized to determine whether a controller instance has failed in other embodiments.

When a master controller instance fails a new master for the LDP sets and the switching elements needs to be determined. Some embodiments of the CM make such determination by performing a master election process that elects a master controller instance e.g. for partitioning management of LDP sets and or partitioning management of switching elements . The CM of some embodiments may perform a master election process for electing a new master controller instance for both the LDP sets and the switching elements of which the failed controller instance was a master. However the CM of other embodiments may perform 1 a master election process for electing a new master controller instance for the LDP sets of which the failed controller instance was a master and 2 another master election process for electing a new master controller instance for the switching elements of which the failed controller instance was a master. In these cases the CM may determine two different controller instances as new controller instances one for the LDP sets of which the failed controller instance was a master and another for the switching elements of which the failed controller instance was a master.

Alternatively or conjunctively the controllers in the cluster of some embodiments run a consensus algorithm to determine a leader controller as mentioned above. The leader controller partitions the tasks for which each controller instance in the cluster is responsible by assigning a master controller for a particular work item and in some cases a hot standby controller to take over in case the master controller fails.

In some embodiments the master election process is further for partitioning management of LDP sets and or management of switching elements when a controller instance is added to the control system. In particular some embodiments of the CM perform the master election process when the control system detects a change in membership of the controller instances in the control system . For instance the CM may perform the master election process to redistribute a portion of the management of the LDP sets and or the management of the switching elements from the existing controller instances to the new controller instance when the control system detects that a new network controller has been added to the control system . However in other embodiments redistribution of a portion of the management of the LDP sets and or the management of the switching elements from the existing controller instances to the new controller instance does not occur when the control system detects that a new network controller has been added to the control system . Instead the control system in these embodiments assigns unassigned LDP sets and or switching elements e.g. new LDP sets and or switching elements or LDP sets and or switching elements from a failed network controller to the new controller instance when the control system detects the unassigned LDP sets and or switching elements.

In the example illustrated in both control applications and of both controllers and can modify records of the switching element S for both users A and B but only controller is the master of this switching element. This example illustrates two different scenarios. The first scenario involves the controller updating the record in switching element S for the user B. The second scenario involves the controller updating the records in switching element S after the control application updates a record for switching element S and user A in the relational database data structure . In the example illustrated in this update is routed from relational database data structure of the controller to the relational database data structure of the controller and subsequently routed to switching element S.

Different embodiments use different techniques to propagate changes to the relational database data structure of controller instance to the relational database data structure of the controller instance . For instance to propagate this update the virtualization application of the controller in some embodiments sends a set of records directly to the relational database data structure by using inter controller communication modules or exporter importer . In response the virtualization application would send the changes to the relational database data structure to the switching element S.

Instead of propagating the relational database data structure changes to the relational database data structure of another controller instance the system of some embodiments uses other techniques to change the record S in the switching element S in response to the request from control application . For instance the distributed control system of some embodiments uses the secondary storage structures e.g. a PTD as communication channels between the different controller instances. In some embodiments the PTDs are replicated across all instances and some or all of the relational database data structure changes are pushed from one controller instance to another through the PTD storage layer. Accordingly in the example illustrated in the change to the relational database data structure could be replicated to the PTD of the controller and from there it could be replicated in the PTD of the controller and the relational database data structure .

Other variations to the sequence of operations shown in could exist because some embodiments designate one controller instance as a master of a LDPS in addition to designating a controller instance as a master of a switching element. In some embodiments different controller instances can be masters of a switching element and a corresponding record for that switching element in the relational database data structure while other embodiments require the controller instance to be master of the switching element and all records for that switching element in the relational database data structure.

In the embodiments where the system allows for the designation of masters for switching elements and relational database data structure records the example illustrated in illustrates a case where the controller instance is the master of the relational database data structure record S while the controller instance is the master for the switching element S. If a controller instance other than the controller instance and was the master of the relational database data structure record S then the request for the relational database data structure record modification from the control application would have had to be propagated to this other controller instance. This other controller instance would then modify the relational database data structure record and this modification would then cause the relational database data structure and the switching element S to update their records through any number of mechanisms that would propagate this modification to the controller instances .

In other embodiments the controller instance might be the master of the relational database data structure record S or the controller instance might be the master of switching element S and all the records of its relational database data structure. In these embodiments the request for the relational database data structure record modification from the control application would have to be propagated to the controller instance which would then modify the records in the relational database data structure and the switching element S.

As mentioned above different embodiments employ different techniques to facilitate communication between different controller instances. In addition different embodiments implement the controller instances differently. For instance in some embodiments the stack of the control application s e.g. or in and the virtualization application e.g. or is installed and runs on a single computer. Also in some embodiments multiple controller instances can be installed and run in parallel on a single computer. In some embodiments a controller instance can also have its stack of components divided amongst several computers. For example within one instance the control application e.g. or can be on a first physical or virtual computer and the virtualization application e.g. or can be on a second physical or virtual computer.

The controller instance in this example is a controller instance for distributing inputs. That is the controller instance of some embodiments takes the inputs from the users in the form of API calls. Through the API calls the users can specify requests for configuring a particular LDPS i.e. configuring a logical switching element or a logical router to be implemented in a set of managed switching elements . The input module of the controller instance receives these API calls and translates them into the form e.g. data tuples or records that can be stored in a PTD and sent to another controller instance in some embodiments.

The controller instance in this example then sends these records to another controller instance that is responsible for managing the records of the particular LDPS. In this example the controller instance is responsible for the records of the LDPS. The controller instance receives the records from the PTD of the controller instance and stores the records in the PTD which is a secondary storage structure of the controller instance . In some embodiments PTDs of different controller instances can directly exchange information each other and do not have to rely on inter controller interfaces.

The control application then detects the addition of these records to the PTD and processes the records to generate or modify other records in the relational database data structure . In particular the control application generates logical forwarding plane data. The virtualization application in turn detects the modification and or addition of these records in the relational database data structure and modifies and or generates other records in the relational database data structure. These records represent the universal physical control plane data in this example. These records then get sent to another controller instance that is managing at least one switching element that implements the particular LDPS through the inter controller interface of the controller instance .

The controller instance in this example is a controller instance that is managing the switching element . The switching element implements at least part of the particular LDPS. The controller instance receives the records representing the universal physical control plane data from the controller instance through the inter controller interface . In some embodiments the controller instance would have a control application and a virtualization application to perform a conversion of the universal physical control plane data to the customized physical control plane data. However in this example the controller instance just identifies a set of managed switching elements to which to send the universal physical control plane data. In this manner the controller instance functions as an aggregation point to gather data to send to the managed switching elements that this controller is responsible for managing. In this example the managed switching element is one of the switching elements managed by the controller instance .

In some embodiments the controller instances in a multi instance distributed network control system such as the system described above by reference to partitions the LDP sets. That is the responsibility for managing LDP sets is distributed over the controller instances. For instance a single controller instance of some embodiments is responsible for managing one or more LDP sets but not all of the LDP sets managed by the system. In these embodiments a controller instance that is responsible for managing a LDPS i.e. the master of the LDPS maintains different portions of the records for all LDP sets in the system in different storage structures of the controller instance. illustrates an example of maintaining the records in different storage structures. This figure illustrates two controller instances of a multi instance distributed network control system . One of the ordinary skill in the art would recognize that there could be many more controller instances in the system for managing many other LDP sets. This figure also illustrates a global view of the state of the network for two LDP sets that the system is managing in this example.

The controller instance is a master of one of the two LDP sets. The view represents the state of the network for this LDPS only. The controller instance maintains the data for this view in the relational datapath data structure . On the other hand the controller instance is a master of the other LDPS that the system is managing. The controller instance maintains the data for the view which represents the state of the network for this other LDPS only. Because a controller instance that is a master of a LDPS may not need the global view of the state of the network for all LDP sets the master of the LDPS does not maintain the data for the global view.

In some embodiments however each controller instance in the system maintains the data for the global view of the state of the network for all LDPS that the system is managing in the secondary storage structure e.g. a PTD of the controller instance. As mentioned above keeping the data for the global data in each controller instance improves overall resiliency by guarding against the loss of data due to the failure of any network controller or failure of the relational database data structure instance and or the secondary storage structure instance . Also the secondary storage structures in these embodiments serve as a communication medium among the controller instances. In particular when a controller instance that is not a master of a particular LDPS receives updates for this particular LDPS e.g. from a user the controller instance first stores the updates in the PTD and propagates the updates to the controller instance that is the master of this particular LDPS. As described above these updates will be detected by the control application of the master of the LDPS and processed.

In some embodiments the input translation application supports a set of API calls for specifying LDP sets and information inquires. In these embodiments the user interface application that allows the user to enter input values is written to send the inputs in the form of API calls to the input translation application . These API calls therefore specify the LDPS e.g. logical switch configuration specified by the user and the user s information inquiry e.g. network traffic statistics for the logical ports of the logical switch of the user . Also the input translation application may get inputs from logical controllers physical controllers and or physical controllers as well as from another input translation controller in some embodiments.

The input parser of some embodiments receives inputs in the form of API calls from the user interface application. In some embodiments the input parser extracts the user input values from the API calls and passes the input values to the filter . The filter filters out the input values that do not conform to certain requirements. For instance the filter filters out the input values that specify an invalid network address for a logical port. For those API calls that contain non conforming input values the response manager sends a response to the user indicating the inputs are not conforming.

The request generator generates requests to be sent to one or more controller instances which will process requests to produce responses to the requests. An example request may ask for statistical information of a logical port of a logical switch that the user is managing. The response to this request would include the requested statistical information prepared by a controller instance that is responsible for managing the LDPS associated with the logical switch.

The request generator of different embodiments generates requests of different formats depending on the implementation of the controller instances that receive and process the requests. For instance the requests that the request generator of some embodiments generates are in the form of records e.g. data tuples suitable for storing in the relational database data structures of controller instances that receives the requests. In some of these embodiments the receiving controller instances use an nLog table mapping engine to process the records representing the requests. In other embodiments the requests are in the form of object oriented data objects that can interact with the NIB data structures of controller instances that receive the request. In these embodiments the receiving controller instances processes the data object directly on the NIB data structure without going through the nLog table mapping engine. The NIB data structure will be described further below.

The request generator of some embodiments deposits the generated requests in the requests repository so that the dispatcher can send the requests to the appropriate controller instances. The dispatcher identifies the controller instance to which each request should be sent. In some cases the dispatcher looks at the LDPS associated with the request and identifies a controller instance that is the master of that LDPS. In some cases the dispatcher identifies a master of a particular switching element i.e. a physical controller as a controller instance to send the request when the request is specifically related to a switching element e.g. when the request is about statistical information of a logical port that is mapped to a port of the switching element . The dispatcher sends the request to the identified controller instance.

The inter instance communication interface is similar to the inter instance communication interface described above by reference to in that the inter instance communication interface establishes a communication channel e.g. an RPC channel with another controller instance over which requests can be sent. The communication channel of some embodiments is bidirectional while in other embodiments the communication channel is unidirectional. When the channel is unidirectional the inter instance communication interface establishes multiple channels with another controller instance so that the input translation application can send requests and receive responses over different channels.

The response manager receives the responses from the controller instances that processed requests through the channel s established by the inter instance communication interface . In some cases more than one response may return for a request that was sent out. For instance a request for statistical information from all logical ports of the logical switch that the user is managing would return a response from each controller. The responses from multiple physical controller instances for multiple different switching elements whose ports are mapped to the logical ports may return to the input translation application either directly to the input translation application or through the master of the LDPS associated with the logical switch. In such cases the response manager merges those responses and sends a single merged response to the user interface application.

As mentioned above the control application running in a controller instance converts data records representing logical control plane data to data records representing logical forwarding plane data by performing conversion operations. Specifically in some embodiments the control application populates the LDPS tables e.g. the logical forwarding tables that are created by the virtualization application with LDP sets.

As shown in the process initially receives at data regarding an input event. The input event data may be logical data supplied by an input translation application that distributes the input records i.e. requests to different controller instances. An example of user supplied data could be logical control plane data including access control list data for a logical switch that the user manages. The input event data may also be logical forwarding plane data that the control application generates in some embodiments from the logical control plane data. The input event data in some embodiments may also be universal physical control plane data received from the virtualization application.

At the process then performs a filtering operation to determine whether this instance of the control application is responsible for the input event data. As described above several instances of the control application may operate in parallel in several different controller instances to control multiple LDP sets in some embodiments. In these embodiments each control application uses the filtering operation to filter out input data that does not relate to the LDPS that the control application is not responsible for managing. To perform this filtering operation the control application of some embodiments includes a filter module. This module of some embodiments is a standalone module while in other embodiments it is implemented by a table mapping engine e.g. implemented by the join operations performed by the table mapping engine that maps records between input tables and output tables of the control application as further described below.

Next at the process determines whether the filtering operation has filtered out the input event data. The filtering operation filters out the input event data in some embodiments when the input event data does not fall within one of the LDP sets that the control application is responsible for managing. When the process determines at that the filtering operation has filtered out the input event data the process transitions to which will be described further below. Otherwise the process transitions to .

At a converter of the control application generates one or more sets of data tuples based on the received input event data. In some embodiments the converter is an table mapping engine that performs a series of table mapping operations on the input event data to map the input event data to other data tuples to modify existing data or generate new data. As mentioned above this table mapping engine also performs the filtering operation in some embodiments. One example of such a table mapping engine is an nLog table mapping engine which will be described below.

As mentioned above the data that the process filters out at include data e.g. configuration data that the control application is not responsible for managing. The process pushes down these data to a secondary storage structure e.g. PTD which is a storage structure other than the relational database data structure that contains the input and output tables in some embodiments. Accordingly at the process of some embodiments translates the data in a format that can be stored in the secondary storage structure so that the data can be shared by the controller instance that is responsible for managing the data. As mentioned above the secondary storage structure such as PTD of one controller instance is capable of sharing data directly with the secondary storage structure of another controller instance. The process of some embodiments also pushes down configuration data in the output tables from the relational database data structure to the secondary storage structure for data resiliency.

At the process sends the generated data tuples to a virtualization application. The process also sends the configuration data that is stored in the secondary storage structure to one or more other controller instances that are responsible for the configuration data. The process then ends.

The control application in some embodiments performs its mapping operations by using the nLog table mapping engine which uses a variation of the datalog table mapping technique. Datalog is used in the field of database management to map one set of tables to another set of tables. Datalog is not a suitable tool for performing table mapping operations in a virtualization application of a network control system as its current implementations are often slow. Accordingly the nLog engine of some embodiments is custom designed to operate quickly so that it can perform the real time mapping of the LDPS data tuples to the data tuples of the managed switching elements. This custom design is based on several custom design choices. For instance some embodiments compile the nLog table mapping engine from a set of high level declaratory rules that are expressed by an application developer e.g. by a developer of a control application . In some of these embodiments one custom design choice that is made for the nLog engine is to allow the application developer to use only the AND operator to express the declaratory rules. By preventing the developer from using other operators such as ORs XORs etc. these embodiments ensure that the resulting rules of the nLog engine are expressed in terms of AND operations that are faster to execute at run time.

Another custom design choice relates to the join operations performed by the nLog engine. Join operations are common database operations for creating association between records of different tables. In some embodiments the nLog engine limits its join operations to inner join operations also called as internal join operations because performing outer join operations also called as external join operations can be time consuming and therefore impractical for real time operation of the engine.

Yet another custom design choice is to implement the nLog engine as a distributed table mapping engine that is executed by several different virtualization applications. Some embodiments implement the nLog engine in a distributed manner by partitioning management of LDP sets. Partitioning management of the LDP sets involves specifying for each particular LDPS only one controller instance as the instance responsible for specifying the records associated with that particular LDPS. For instance when the control system uses three switching elements to specify five LDP sets for five different users with two different controller instances one controller instance can be the master for records relating to two of the LDP sets while the other controller instance can be the master for the records for the other three LDP sets.

Partitioning management of the LDP sets also assigns in some embodiments the table mapping operations for each LDPS to the nLog engine of the controller instance responsible for the LDPS. The distribution of the nLog table mapping operations across several nLog instances reduces the load on each nLog instance and thereby increases the speed by which each nLog instance can complete its mapping operations. Also this distribution reduces the memory size requirement on each machine that executes a controller instance. As further described below some embodiments partition the nLog table mapping operations across the different instances by designating the first join operation that is performed by each nLog instance to be based on the LDPS parameter. This designation ensures that each nLog instance s join operations fail and terminate immediately when the instance has started a set of join operations that relate to a LDPS that is not managed by the nLog instance.

More specifically the control application allows different users to define different LDP sets which specify the desired configuration of the logical switches that the users manage. The control application through its mapping operations converts data for each LDPS of each user into a set of data tuples that specify the logical forwarding plane data for the logical switch associated with the LDPS. In some embodiments the control application is executed on the same host on which the virtualization application is executed. The control application and the virtualization application do not have to run on the same machine in other embodiments.

As shown in the control application includes a set of rule engine input tables a set of function and constant tables an importer a rules engine a set of rule engine output tables a translator an exporter a PTD and a compiler . The compiler is one component of the application that operates at a different instance in time than the application s other components. The compiler operates when a developer needs to specify the rules engine for a particular control application and or virtualized environment whereas the rest of the application s modules operate at runtime when the application interfaces with the virtualization application to deploy LDP sets specified by one or more users.

In some embodiments the compiler takes a relatively small set e.g. few hundred lines of declarative instructions that are specified in a declarative language and converts these into a large set e.g. thousands of lines of code i.e. object code that specifies the operation of the rules engine which performs the application s table mapping. As such the compiler greatly simplifies the control application developer s process of defining and updating the control application. This is because the compiler allows the developer to use a high level programming language that allows a compact definition of the control application s complex mapping operation and to subsequently update this mapping operation in response to any number of changes e.g. changes in the logical networking functions supported by the control application changes to desired behavior of the control application etc. . Moreover the compiler relieves the developer from considering the order at which the events would arrive at the control application when the developer is defining the mapping operation.

In some embodiments the rule engine RE input tables include tables with logical data and or switching configurations e.g. access control list configurations private virtual network configurations port security configurations etc. specified by the user and or the control application. They also include tables that contain physical data i.e. non logical data from the switching elements managed by the virtualized control system in some embodiments. In some embodiments such physical data includes data regarding the managed switching elements e.g. universal physical control plane data and other data regarding network configuration employed by the virtualized control system to deploy the different LDP sets of the different users.

The RE input tables are partially populated with logical control plane data provided by the users as will be further described below. The RE input tables also contain the logical forwarding plane data and universal physical control plane data. In addition to the RE input tables the control application includes other miscellaneous tables that the rules engine uses to gather inputs for its table mapping operations. These tables include constant tables that store defined values for constants that the rules engine needs to perform its table mapping operations. For instance the constant tables may include a constant zero that is defined as the value 0 a constant dispatch port no as the value 4000 and a constant broadcast MAC addr as the value 0xFF FF FF FF FF FF.

When the rules engine references constants the corresponding value defined for the constants are actually retrieved and used. In addition the values defined for constants in the constant tables may be modified and or updated. In this manner the constant tables provide the ability to modify the value defined for constants that the rules engine references without the need to rewrite or recompile code that specifies the operation of the rules engine . The tables further include function tables that store functions that the rules engine needs to use to calculate values needed to populate the output tables .

The rules engine performs table mapping operations that specifies one manner for converting logical control plane data to logical forwarding plane data. Whenever one of the rule engine RE input tables is modified the rules engine performs a set of table mapping operations that may result in the modification of one or more data tuples in one or more RE output tables.

As shown in the rules engine includes an event processor several query plans and a table processor . Each query plan is a set of rules that specifies a set of join operations that are to be performed upon the occurrence of a modification to one of the RE input tables. Such a modification is referred to below as an input table event. Each query plan is generated by the compiler from one declaratory rule in the set of declarations . In some embodiments more than one query plan is generated from one declaratory rule. For instance a query plan is created for each of the tables joined by one declaratory rule. That is when a declaratory rule specifies to join four tables four different query plans will be created from that one declaration. In some embodiments the query plans are defined by using the nLog declaratory language.

In some embodiments the compiler does not just statically generate query plans but rather dynamically generates query plans based on performance data it gathers. The compiler in these embodiments generates an initial set of query plans and lets the rules engine operate with the initial set of query plans. The control application gathers the performance data or receives performance feedback e.g. from the rules engine . Based on this data the compiler is modified so that the control application or a user of this application can have the modified compiler modify the query plans while the rules engine is not operating or during the operation of the rules engine.

For instance the order of the join operations in a query plan may result in different execution times depending on the number of tables the rules engine has to select to perform each join operation. The compiler in these embodiments can be re specified in order to re order the join operations in a particular query plan when a certain order of the join operations in the particular query plan has resulted in a long execution time to perform the join operations.

The event processor of the rules engine detects the occurrence of each input table event. The event processor of different embodiments detects the occurrence of an input table event differently. In some embodiments the event processor registers for callbacks with the RE input tables for notification of changes to the records of the RE input tables. In such embodiments the event processor detects an input table event when it receives notification from an RE input table that one of its records has changed.

In response to a detected input table event the event processor 1 selects the appropriate query plan for the detected table event and 2 directs the table processor to execute the query plan. To execute the query plan the table processor in some embodiments performs the join operations specified by the query plan to produce one or more records that represent one or more sets of data values from one or more input and miscellaneous tables and . The table processor of some embodiments then 1 performs a select operation to select a subset of the data values from the record s produced by the join operations and 2 writes the selected subset of data values in one or more RE output tables .

In some embodiments the RE output tables store both logical and physical network element data attributes. The tables are called RE output tables as they store the output of the table mapping operations of the rules engine . In some embodiments the RE output tables can be grouped in several different categories. For instance in some embodiments these tables can be RE input tables and or control application CA output tables. A table is an RE input table when a change in the table causes the rules engine to detect an input event that requires the execution of a query plan. A RE output table can also be an RE input table that generates an event that causes the rules engine to perform another query plan. Such an event is referred to as an internal input event and it is to be contrasted with an external input event which is an event that is caused by an RE input table modification made by the control application or the importer .

A table is a control application output table when a change in the table causes the exporter to export a change to the virtualization application as further described below. A table in the RE output tables can be an RE input table a CA output table or both an RE input table and a CA output table.

The exporter detects changes to the CA output tables of the RE output tables . The exporter of different embodiments detects the occurrence of a CA output table event differently. In some embodiments the exporter registers for callbacks with the CA output tables for notification of changes to the records of the CA output tables. In such embodiments the exporter detects an output table event when it receives notification from a CA output table that one of its records has changed.

In response to a detected output table event the exporter takes some or all of modified data tuples in the modified CA output tables and propagates this modified data tuple s to the input tables not shown of the virtualization application . In some embodiments instead of the exporter pushing the data tuples to the virtualization application the virtualization application pulls the data tuples from the CA output tables into the input tables of the virtualization application. In some embodiments the CA output tables of the control application and the input tables of the virtualization may be identical. In yet other embodiments the control and virtualization applications use one set of tables so that the CA output tables are essentially CA input tables.

In some embodiments the control application does not keep in the output tables the data for LDP sets that the control application is not responsible for managing. However such data will be translated by the translator into a format that can be stored in the PTD and gets stored in the PTD. The PTD of the control application propagates this data to one or more other control application instances of other controller instances so that some of other control application instances that are responsible for managing the LDP sets associated with the data can process the data.

In some embodiments the control application also brings the data stored in the output tables i.e. the data that the control application keeps in the output tables to the PTD for resiliency of the data. Such data is also translated by the translator stored in the PTD and propagated to other control application instances of other controller instances. Therefore in these embodiments a PTD of a controller instance has all the configuration data for all LDP sets managed by the virtualized control system. That is each PTD contains the global view of the configuration of the logical network in some embodiments.

The importer interfaces with a number of different sources of input data and uses the input data to modify or create the input tables . The importer of some embodiments receives from the input translation application through the inter instance communication interface not shown the input data. The importer also interfaces with the PTD so that data received through the PTD from other controller instances can be used as input data to modify or create the input tables . Moreover the importer also detects changes with the RE input tables and the RE input tables CA output tables of the RE output tables .

As mentioned above the virtualization application of some embodiments specifies the manner by which different LDP sets of different users of a network control system can be implemented by the switching elements managed by the network control system. In some embodiments the virtualization application specifies the implementation of the LDP sets within the managed switching element infrastructure by performing conversion operations. These conversion operations convert the LDP sets data records also called data tuples below to the control data records e.g. universal physical control plane data that are initially stored within the managed switching elements and then used by the switching elements to produce forwarding plane data e.g. flow entries for defining forwarding behaviors of the switching elements. The conversion operations also produce other data e.g. in tables that specify network constructs e.g. tunnels queues queue collections etc. that should be defined within and between the managed switching elements. The network constructs also include managed software switching elements that are dynamically deployed or pre configured managed software switching elements that are dynamically added to the set of managed switching elements.

At the process then performs a filtering operation to determine whether this instance of the virtualization application is responsible for the input event data. As described above several instances of the virtualization application may operate in parallel to control multiple sets of LDP sets in some embodiments. In these embodiments each virtualization application uses the filtering operation to filter out input data that does not relate to the virtualization application s LDP sets. Also the virtualization application of some embodiments filters out input data that does not relate to the managed switching elements that this instance of the virtualization application is responsible for managing.

To perform this filtering operation the virtualization application of some embodiments includes a filter module. This module in some embodiments is a standalone module while in other embodiments it is implemented by a table mapping engine e.g. implemented by the join operations performed by the table mapping engine that maps records between input tables and output tables of the virtualization application as further described below.

Next at the process determines whether the filtering operation has filtered out the received input event data. As mentioned above the instance of the virtualization application filters out the input data when the input data is related to a LDPS that is not one of the LDP sets of which the virtualization application is the master or when the data is for a managed switching element that is not one of the managed switching elements of which the virtualization application is the master. When the process determines at that the filtering operation has filtered out the input event the process transitions to which will be described further below. Otherwise the process transitions to .

At a converter of the virtualization application generates one or more sets of data tuples based on the received input event data. In some embodiments the converter is a table mapping engine that performs a series of table mapping operations on the input event data to map the input event data to other data tuples. As mentioned above this table mapping engine also performs the filtering operation in some embodiments. One example of such a table mapping engine is an nLog table mapping engine which will be further described further below.

As mentioned above the data that the process filters out at include data e.g. configuration data that the virtualization application is not responsible for managing. The process pushes down these data to a secondary storage structure e.g. PTD which is a storage structure other than the relational database data structure that contains the input and output tables in some embodiments. Accordingly at the process of some embodiments translates the data in a format that can be stored in the secondary storage structure so that the data can be shared by the controller instance that is responsible for managing the data. The process of some embodiments also pushes down configuration data in the output tables from the relational database data structure to the secondary storage structure for data resiliency.

At the process sends out the generated data tuples. In some cases the process sends the data tuples to a number of chassis controllers so that the chassis controllers can convert the universal physical control plane data into customized physical control plane data before passing the customized physical control data to the switching elements. In some cases the process sends the data tuples to the switching elements of which the instance of the virtualization application is the master. In some cases the process also sends the configuration data that is stored in the secondary storage structure to one or more other controller instances that are responsible for the configuration data. The process then ends.

More specifically the control application allows different users to define different LDP sets which specify the desired configuration of the logical switches that the users manage. The control application through its mapping operations converts data for each LDPS of each user into a set of data tuples that specify the logical forwarding plane data for the logical switch associated with the LDPS. In some embodiments the control application is executed on the same host on which the virtualization application is executed. The control application and the virtualization application do not have to run on the same machine in other embodiments.

As shown in the virtualization application includes a set of rule engine input tables a set of function and constant tables an importer a rules engine a set of rule engine output tables a translator an exporter a PTD and a compiler .

The compiler is similar to the compiler described above by reference to . In some embodiments the rule engine RE input tables include tables with logical data and or switching configurations e.g. access control list configurations private virtual network configurations port security configurations etc. specified by the user and or the virtualization application. In some embodiments they also include tables that contain physical data i.e. non logical data from the switching elements managed by the virtualized control system. In some embodiments such physical data includes data regarding the managed switching elements e.g. universal physical control plane data and other data regarding network configuration employed by the virtualized control system to deploy the different LDP sets of the different users.

The RE input tables are partially populated by the LDPS data e.g. by logical forwarding plane data provided by the control application . The control application generates part of the LDPS data based on user input regarding the LDP sets.

In addition to the RE input tables the virtualization application includes other miscellaneous tables that the rules engine uses to gather inputs for its table mapping operations. These tables include constant tables that store defined values for constants that the rules engine needs to perform its table mapping operations.

When the rules engine references constants the corresponding value defined for the constants are actually retrieved and used. In addition the values defined for constants in the constant table may be modified and or updated. In this manner the constant tables provide the ability to modify the value defined for constants that the rules engine references without the need to rewrite or recompile code that specifies the operation of the rules engine . The tables further include function tables that store functions that the rules engine needs to use to calculate values needed to populate the output tables .

The rules engine performs table mapping operations that specify one manner for implementing the LDP sets within the managed switching element infrastructure. Whenever one of the RE input tables is modified the rules engine performs a set of table mapping operations that may result in the modification of one or more data tuples in one or more RE output tables.

As shown in the rules engine includes an event processor several query plans and a table processor . In some embodiments each query plan is a set of join operations that are to be performed upon the occurrence of a modification to one of the RE input tables. Such a modification is referred to below as an input table event. Each query plan is generated by the compiler from one declaratory rule in the set of declarations . In some embodiments more than one query plan is generated from one declaratory rule as described above. In some embodiments the query plans are defined by using the nLog declaratory language.

The event processor of the rules engine detects the occurrence of each input table event. The event processor of different embodiments detects the occurrence of an input table event differently. In some embodiments the event processor registers for callbacks with the RE input tables for notification of changes to the records of the RE input tables. In such embodiments the event processor detects an input table event when it receives notification from an RE input table that one of its records has changed.

In response to a detected input table event the event processor 1 selects the appropriate query plan for the detected table event and 2 directs the table processor to execute the query plan. To execute the query plan the table processor in some embodiments performs the join operations specified by the query plan to produce one or more records that represent one or more sets of data values from one or more input and miscellaneous tables and . The table processor of some embodiments then 1 performs a select operation to select a subset of the data values from the record s produced by the join operations and 2 writes the selected subset of data values in one or more RE output tables .

In some embodiments the RE output tables store both logical and physical network element data attributes. The tables are called RE output tables as they store the output of the table mapping operations of the rules engine . In some embodiments the RE output tables can be grouped in several different categories. For instance in some embodiments these tables can be RE input tables and or virtualization application VA output tables. A table is an RE input table when a change in the table causes the rules engine to detect an input event that requires the execution of a query plan. A RE output table can also be an RE input table that generates an event that causes the rules engine to perform another query plan after it is modified by the rules engine. Such an event is referred to as an internal input event and it is to be contrasted with an external input event which is an event that is caused by an RE input table modification made by the control application via the importer .

A table is a virtualization application output table when a change in the table causes the exporter to export a change to the managed switching elements or other controller instances. As shown in a table in the RE output tables can be an RE input table a VA output table or both an RE input table and a VA output table .

The exporter detects changes to the VA output tables of the RE output tables . The exporter of different embodiments detects the occurrence of a VA output table event differently. In some embodiments the exporter registers for callbacks with the VA output tables for notification of changes to the records of the VA output tables. In such embodiments the exporter detects an output table event when it receives notification from a VA output table that one of its records has changed.

In response to a detected output table event the exporter takes each modified data tuple in the modified VA output tables and propagates this modified data tuple to one or more of other controller instances e.g. chassis controller or to one or more the managed switching elements. In doing this the exporter completes the deployment of the LDPS e.g. one or more logical switching configurations to one or more managed switching elements as specified by the records.

As the VA output tables store both logical and physical network element data attributes in some embodiments the PTD in some embodiments stores both logical and physical network element attributes that are identical or derived from the logical and physical network element data attributes in the output tables . In other embodiments however the PTD only stores physical network element attributes that are identical or derived from the physical network element data attributes in the output tables .

In some embodiments the virtualization application does not keep in the output tables the data for LDP sets that the virtualization application is not responsible for managing. However such data will be translated by the translator into a format that can be stored in the PTD and then gets stored in the PTD. The PTD of the virtualization application propagates this data to one or more other virtualization application instances of other controller instances so that some of other virtualization application instances that are responsible for managing the LDP sets associated with the data can process the data.

In some embodiments the virtualization application also brings the data stored in the output tables i.e. the data that the virtualization application keeps in the output tables to the PTD for resiliency of the data. Such data is also translated by the translator stored in the PTD and propagated to other virtualization application instances of other controller instances. Therefore in these embodiments a PTD of a controller instance has all the configuration data for all LDP sets managed by the virtualized control system. That is each PTD contains the global view of the configuration of the logical network in some embodiments.

The importer interfaces with a number of different sources of input data and uses the input data to modify or create the input tables . The importer of some embodiments receives from the input translation application through the inter instance communication interface the input data. The importer also interfaces with the PTD so that data received through the PTD from other controller instances can be used as input data to modify or create the input tables . Moreover the importer also detects changes with the RE input tables and the RE input tables VA output tables of the RE output tables .

In some embodiments the control application and the virtualization application each uses a variation of the datalog database language called nLog to create the table mapping engine that maps input tables containing LDPS data and switching element attributes to the output tables. Like datalog nLog provides a few declaratory rules and operators that allow a developer to specify different operations that are to be performed upon the occurrence of different events. In some embodiments nLog provides a smaller subset of the operators that are provided by datalog in order to increase the operational speed of nLog. For instance in some embodiments nLog only allows the AND operator to be used in any of the declaratory rules.

The declaratory rules and operations that are specified through nLog are then compiled into a much larger set of rules by an nLog compiler. In some embodiments this compiler translates each rule that is meant to respond to an event into several sets of database join operations. Collectively the larger set of rules forms the table mapping rules engine that is referred to below as the nLog engine. For simplicity of discussion are described below by referring to the rules engine and the virtualization application although the description for these figures are also applicable to the rules engine and the control application .

One example of such a rule is illustrated in . This example is a multi conditional rule that specifies that an Action X has to be taken if four conditions A B C and D are true. The expression of each condition as true in this example is not meant to convey that all embodiments express each condition for each rule as True or False. For some embodiments this expression is meant to convey the concept of the existence of a condition which may or may not be true. For example in some such embodiments the condition A True might be expressed as Is variable Z A In other words A in this example is the value of a parameter Z and the condition is true when Z has a value A.

Irrespective of how the conditions are expressed a multi conditional rule in some embodiments specifies the taking of an action when certain conditions in the network are met. Examples of such actions include creation or deletion of new packet flow entries creation or deletion of new network constructs modification to existing network constructs etc. In the virtualization application these actions are often implemented by the rules engine by creating deleting or modifying records in the output tables. In some embodiments an action entails a removal or a creation of a data tuple.

As shown in the multi conditional rule uses only the AND operator to express the rule. In other words each of the conditions A B C and D has to be true before the Action X is to be taken. In some embodiments the declaration toolkit only allows the developers to utilize the AND operator because excluding the other operators such as ORs XORs etc. that are allowed by datalog allows nLog to operate faster than datalog.

The compiler converts each rule specified by the declaration toolkit into a query plan of the rules engine. illustrates the creation of three query plans for three rules . Each query plan includes one or more sets of join operations. Each set of join operations specifies one or more join operations that are to be performed upon the occurrence of a particular event in a particular RE input table where the particular event might correspond to the addition deletion or modification of an entry in the particular RE input table.

In some embodiments the compiler converts each multi conditional rule into several sets of join operations with each set of join operations being specified for execution upon the detection of the occurrence of one of the conditions. Under this approach the event for which the set of join operations is specified is one of the conditions of the multi conditional rule. Given that the multi conditional rule has multiple conditions the compiler in these embodiments specifies multiple sets of join operations to address the occurrence of each of the conditions.

These four sets of operations collectively represent the query plan that the rules engine performs upon the occurrence of an RE input table event relating to any of the parameters A B C or D. When the input table event relates to one of these parameters e.g. parameter B but one of the other parameters e.g. parameters A C and D is not true then the set of join operations fails and no output table is modified. But when the input table event relates to one of these parameters e.g. parameter B and all of the other parameters e.g. parameters A C and D are true then the set of join operations does not fail and an output table is modified to perform the action X. In some embodiments these join operations are internal join operations. In the example illustrated in each set of join operations terminates with a select command that selects entries in the record s resulting from the set of join operations to output to one or more output tables.

To implement the nLog engine in a distributed manner some embodiments partition management of LDP sets by assigning the management of each LDPS to one controller instance. This partition management of the LDPS is also referred to as serialization of management of the LDPS. The rules engine of some embodiments implements this partitioned management of the LDPS by having a join to the LDPS entry be the first join in each set of join operations that is not triggered by an event in a LDPS input table.

The four sets of join operations and are operational sets that are each to be performed upon the occurrence of one of the conditions A B C and D. The first join operations in each of these four sets and is a join with the LDPS table managed by the virtualization application instance. Accordingly even when the input table event relates to one of these four parameters e.g. parameter B and all of the other parameters e.g. parameters A C and D are true the set of join operations may fail if the event has occurred for a LDPS that is not managed by this virtualization application instance. The set of join operations does not fail and an output table is modified to perform the desire action only when 1 the input table event relates to one of these four parameters e.g. parameter B all of the other parameters e.g. parameters A C and D are true and 3 the event relates to a LDPS that is managed by this virtualization application instance. How the insertion of the join operation to the LDPS table allows the virtualization application to partition management of the LDP sets is described in detail further below.

As shown in the process initially detects at a change in an RE input table . In some embodiments the event processor is the module that detects this change. Next at the process identifies the query plan associated with the detected RE input table event. As mentioned above each query plan in some embodiments specifies a set of join operations that are to be performed upon the occurrence of an input table event. In some embodiments the event processor is also the module that performs this operation i.e. is the module that identifies the query plan .

At the process executes the query plan for the detected input table event. In some embodiments the event processor directs the table processor to execute the query plan. To execute a query plan that is specified in terms of a set of join operations the table processor in some embodiments performs the set of join operations specified by the query plan to produce one or more records that represent one or more sets of data values from one or more input and miscellaneous tables and .

Two records in two tables match when values of a common key e.g. a primary key and a foreign key that the two tables share are the same in some embodiments. In the example in the records and in tables and match because the values C in these records match. Similarly the records and in tables and match because the values F in these records match. Finally the records and in tables and match because the values R in these records match. The joining of the records and results in the combined record . In the example shown in the result of a join operation between two tables e.g. tables and is a single record e.g. ABCDFGH . However in some cases the result of a join operation between two tables may be multiple records.

Even though in the example illustrated in a record is produced as the result of the set of join operations the set of join operations in some cases might result in a null record. For instance as described further below a null record results when the set of join operations terminates on the first join because the detected event relates to a LDPS not managed by a particular instance of the virtualization application. Accordingly at the process determines whether the query plan has failed e.g. whether the set of join operations resulted in a null record . If so the process ends. In some embodiments the operation is implicitly performed by the table processor when it terminates its operations upon the failure of one of the join operations.

When the process determines at that the query plan has not failed it stores at the output resulting from the execution of the query plan in one or more of the output tables. In some embodiments the table processor performs this operation by 1 performing a select operation to select a subset of the data values from the record s produced by the join operations and 2 writing the selected subset of data values in one or more RE output tables . illustrates an example of this selection operation. Specifically it illustrates the selection of values B F P and S from the combined record and the writing of these values into a record of an output table .

As mentioned above the RE output tables can be categorized in some embodiments as 1 an RE input table only 2 a VA output table only or 3 both an RE input table and a VA output table. When the execution of the query plan results in the modification a VA output table the process exports at the changes to this output table to one or more other controller instances or one or more managed switching elements. In some embodiments the exporter detects changes to the VA output tables of the RE output tables and in response it propagates the modified data tuple in the modified VA output table to other controller instances or managed switching elements. In doing this the exporter completes the deployment of the LDP sets e.g. one or more logical switching configurations to one or more managed switching elements as specified by the output tables.

At the process determines whether the execution of the query plan resulted in the modification of the RE input table. This operation is implicitly performed in some embodiments when the event processor determines that the output table that was modified previously at modified an RE input table. As mentioned above an RE output table can also be an RE input table that generates an event that causes the rules engine to perform another query plan after it is modified by the rules engine. Such an event is referred to as an internal input event and it is to be contrasted with an external input event which is an event that is caused by an RE input table modification made by the control application or the importer . When the process determines at that an internal input event was created it returns to to perform operations for this new internal input event. The process terminates when it determines at that the execution of the query plan at did not result in an internal input event.

One of ordinary skill in the art will recognize that process is a conceptual representation of the operations used to map a change in one or more input tables to one or more output tables. The specific operations of process may not be performed in the exact order shown and described. The specific operations may not be performed in one continuous series of operations and different specific operations may be performed in different embodiments. For instance the process in some embodiments batches up a set of changes in RE input tables and identifies at a query plan associated with the set of detected RE input table events. The process in these embodiments executes at the query plan for the whole set of the RE input table events rather than for a single RE input table event. Batching up the RE input table events in some embodiments results in better performance of the table mapping operations. For example batching the RE input table events improves performance because it reduces the number of instances that the process will produce additional RE input table events that would cause it to start another iteration of itself.

As mentioned above some embodiments implement the nLog engine as a distributed table mapping engine that is executed by different virtualization applications of different controller instances. To implement the nLog engine in a distributed manner some embodiments partition the management of the LDP sets by specifying for each particular LDPS only one controller instance as the instance responsible for specifying the records associated with that particular LDPS. Partitioning the management of the LDP sets also assigns in some embodiments the table mapping operations for each LDPS to the nLog engine of the controller instance responsible for the LDPS.

As described above some embodiments partition the nLog table mapping operations across the different instances by designating the first join operation that is performed by each nLog instance to be based on the LDPS parameter. This designation ensures that each nLog instance s join operations fail and terminate immediately when the instance has started a set of join operations that relate to a LDPS that is not managed by the nLog instance.

In the example illustrated in the two query plans and are not executed because an input table event A has occurred for a LDPS and these two plans are not associated with such an event. Instead the two query plans and are executed because they are associated with the input table event A that has occurred. As shown in this figure the occurrence of this event results in two sets of join operations being performed to execute the two query plans and .

The first set of join operations for the query plan fails on the first join operation because it is a join with the LDPS table which for the virtualization application instance does not contain a record for the LDPS which is a LDPS not managed by the virtualization application instance . In some embodiments even though the first join operation has failed the remaining join operations not shown of the query plan will still be performed and fail. In other embodiments the remaining join operations of the query plan will not be performed as shown.

The second set of join operations does not fail however because it is for the LDPS which is a LDPS managed by the virtualization application instance and therefore has a record in the LDPS table of this application instance. This set of join operations has four stages that each performs one join operation. Also as shown in the set of join operations terminates with a selection operation that selects a portion of the combined record produced through the join operations. The distribution of the nLog table mapping operations across several nLog instances reduces the load on each nLog instance and thereby increases the speed by which each nLog instance can complete its mapping operations.

The bottom half of this figure illustrates the table mapping operations of the control application and the virtualization application. As shown in this half the control application s input tables store logical control plane LCP data as the LCP data along with data in the constant and function tables not shown is used by the control application s nLog engine in some embodiments to generate logical forwarding plane LFP data. The exporter sends the generated data to the virtualization application for further processing.

This figure shows that the importer receives the LCP data from the user e.g. thru an input translation application and update input tables of the control application with the LCP data. This figure further shows that the importer detects or receives changes in the PTD e.g. LCP data changes originated from the other controller instances in some embodiments and in response to such changes the importer may update input tables .

The bottom half of this figure also illustrates the table mapping operations of the virtualization application . As shown the virtualization application s input tables store logical forwarding plane LFP data as the LFP data along with data in the constant and function tables not shown is used by the virtualization application s nLog engine in some embodiments to generate universal physical control plane UPCP data and or customized physical control plane CPCP data. In some embodiments the exporter sends the generated UPCP data to one or more other controller instances e.g. a chassis controller to generate CPCP data before pushing this data to the managed switching elements or to one or more managed switching elements that convert the UPCP data to CPCP data specific to the managed switching elements. In other embodiments the exporter sends the generate CPCP data to one or more managed switching elements to define the forwarding behaviors of these managed switching elements.

This figure shows that the importer receives the LFP data from the control application and update input tables of the virtualization application with the LFP data. This figure further shows that the importer detects or receives changes in the PTD e.g. LCP data changes originated from the other controller instances in some embodiments and in response to such changes the importer may update input tables .

As mentioned above some of the logical or physical data that an importer pushes to the input tables of the control or virtualization application relates to data that is generated by other controller instances and passed to the PTD. For instance in some embodiments the logical data regarding logical constructs e.g. logical ports logical queues etc. that relates to multiple LDP sets might change and the translator e.g. translator of the controller instance may write this change to the input tables. Another example of such logical data that is produced by another controller instance in a multi controller instance environment occurs when a user provides logical control plane data for a LDPS on a first controller instance that is not responsible for the LDPS. This change is added to the PTD of the first controller instance by the translator of the first controller instance. This change is then propagated across the PTDs of other controller instances by replication processes performed by the PTDs. The importer of a second controller instance which is the master of the LDPS eventually takes this change and then writes the change to the one of the application s input tables e.g. the control application s input table . Accordingly in such cases the logical data that the importer writes to the input tables in some cases may originate from the PTD of another controller instance.

As mentioned above the control application and the virtualization application are two separate applications that operate on the same machine or different machines in some embodiments. Other embodiments however implement these two applications as two modules of one integrated application with the control application module generating logical data in the logical forwarding plane and the virtualization application generating physical data in the universal physical control plane or in the customized physical control plane.

Still other embodiments integrate the control and virtualization operations of these two applications within one integrated application without separating these operations into two separate modules. illustrates an example of such an integrated application . This application uses an nLog table mapping engine to map data from an input set of tables to an output set of tables which like the above described embodiments may include one or more tables in the input set of tables. The input set of tables in this integrated application may include LCP data that need to be mapped to LFP data or it may include LFP data that need to be mapped to CPCP or UPCP data. The input set of tables may also include UPCP data that need to be mapped to CPCP data.

In this integrated control and virtualization application the importer gets the input data from the users or other controller instances. The importer also detects or receives the changes in the PTD that is replicated to the PTD. The exporter exports output table records to other controller instances or managed switching elements.

When sending the output table records to managed switching elements the exporter uses a managed switching element communication interface not shown so that the data contained in the records are sent to a managed switching element over two channels. One channel is established using a switch control protocol e.g. OpenFlow for controlling the forwarding plane of the managed switching element and the other channel is established using a configuration protocol to send configuration data.

When sending the output table records to a chassis controller the exporter in some embodiments uses a single channel of communication to send the data contained in the records. In these embodiments the chassis controller accepts the data through this single channel but communicates with the managed switching element over two channels. A chassis controller is described in more details further below by reference to .

The integrated application uses the nLog table mapping engine to map data from the input set of tables to the output set of tables . In some embodiments some of the data in the output set of tables is exported by the exporter to one or more other controller instances or one or managed switching elements. Such exported data include UPCP or CPCP data that would define flow behaviors of the managed switching elements. These data may be backed up in the PTD by the translator in the PTD for data resiliency.

Some of the data in the output set of tables is published to the NIB by the NIB publisher . These data include configuration information of the logical switches that the users manage using the integrated application . The data stored in the NIB is replicated to other NIBs of other controller instances by the coordination manager .

The NIB monitor receives notifications of changes from the NIB and for some notifications e.g. those relating to the LDP sets for which the integrated application is the master pushes changes to the input tables via the importer .

The query manager interfaces with an input translation application to receive queries regarding configuration data. As shown in this figure the manager of some embodiments also interfaces with the NIB in order to query the NIB to provide the state information e.g. logical port statistics regarding the logical network elements that the user is managing. In other embodiments however the query manager queries the output tables to obtain the state information.

In some embodiments the application uses secondary storage structures other than the PTD and the NIB. These structures include a persistent non transactional database PNTD and a hash table. In some embodiments these two types of secondary storage structures store different types of data store data in different manners and or provide different query interfaces that handle different types of queries.

The PNTD is a persistent database that is stored on disk or other non volatile memory. Some embodiments use this database to store data e.g. statistics computations etc. regarding one or more switching element attributes or operations. For instance this database is used in some embodiment to store the number of packets routed through a particular port of a particular switching element. Other examples of types of data stored in the PNTD include error messages log files warning messages and billing data.

The PNTD in some embodiments has a database query manager not shown that can process database queries but as it is not a transactional database this query manager cannot handle complex conditional transactional queries. In some embodiments accesses to the PNTD are faster than accesses to the PTD but slower than accesses to the hash table.

Unlike the PNTD the hash table is not a database that is stored on disk or other non volatile memory. Instead it is a storage structure that is stored in volatile system memory e.g. RAM . It uses hashing techniques that use hashed indices to quickly identify records that are stored in the table. This structure combined with the hash table s placement in the system memory allows this table to be accessed very quickly. To facilitate this quick access a simplified query interface is used in some embodiments. For instance in some embodiments the hash table has just two queries a Put query for writing values to the table and a Get query for retrieving values from the table. Some embodiments use the hash table to store data that change quickly. Examples of such quick changing data include network entity status statistics state uptime link arrangement and packet handling information. Furthermore in some embodiments the integrated application uses the hash tables as a cache to store information that is repeatedly queried for such as flow entries that will be written to multiple nodes. Some embodiments employ a hash structure in the NIB in order to quickly access records in the NIB. Accordingly in some of these embodiments the hash table is part of the NIB data structure.

The PTD and the PNTD improve the resiliency of the controller by preserving network data on hard disks. If a controller system fails network configuration data will be preserved on disk in the PTD and log file information will be preserved on disk in the PNTD.

In some cases the modified input tables become the output tables without being further modified by the rules engine as if the importer had directly modified the output tables in response to receiving certain input data. Such input data in some embodiments relate to some of the changes to the state and configuration of the managed switching elements. That is these changes originate from the managed switching elements. By directly writing such data to the output tables the importer keeps the output tables updated with the current state and configuration of the managed switching elements.

As shown the application conceptually includes a difference assessor . The difference assessor detects a change in the first representation or in the second representation . A change in the first representation may occur when the rules engine puts the result of its mapping operations in the output tables . A change in the second representation may occur when the importer directly updates the output tables when the changes come from the managed switching element s . Upon detecting a change in the output tables the difference assessor in some embodiments examines both the first representation and the second representation to find the difference if any between these two representations.

When there is no difference between these two representations the difference assessor takes no further action because the current state and configuration of the managed switching elements are already what they should be. However when there is a difference the different assessor may have the exporter export the difference e.g. data tuples to the managed switching elements so that the state and configuration of the managed switching elements will be the state and configuration specified by the first representation . Also the translator will translate and store the difference in the PDT so that the difference will be propagated to other controller instances.

Also when the difference assessor detects a difference between the two representations the difference assessor in some embodiments may call the input tables of the integrated application to initiate additional table mapping operations to reconcile the difference between the desired and current values. Alternatively in other embodiments the importer will end up updating the input tables based on the changes in the PTD at the same time it updates the output tables and these will trigger the nLog operations that might update the output table.

In some embodiments the integrated application does not store the desired and current representations and of the universal or customized physical control plane data and does not use a difference assessor to assess whether two corresponding representations are identical. Instead the integrated application stores each set of universal or customized physical control plane data in a format that identifies differences between the desired data value and the current data value. When the difference between the desired and current values is significant the integrated application of some embodiments may have the exporter to push a data tuple change to the managed switching elements or may call the input tables of the integrated application to initiate additional table mapping operations to reconcile the difference between the desired and current values.

The operation of the integrated application will now be described with an example network event i.e. a change in the network switching elements . In this example the switching elements managed by the integrated application include a second level managed switching element. A second level managed switching element is a managed non edge switching element which in contrast to an managed edge switching element does not send and receive packets directly to and from the machines. A second level managed switching element facilitates packet exchanges between non edge managed switching elements and edge managed switching elements. A pool node and an extender which are described in U.S. patent application Ser. No. 13 177 535 are also second level managed switching elements. The pool node shuts down for some reason e.g. by hardware or software failure and the two bridges of the pool node get shut down together with the pool node.

The importer in this example then receives this update and subsequently writes information to both the input tables and the output tables specifically the second representation . The rules engine performs mapping operations upon detecting the change in the input tables but the mapping result i.e. the first representation in this example will not change the desired data value regarding the pool node and its bridges. That is the desired data value would still indicate that the pool node and the two bridges should exist in the configuration of the system. The second representation would also indicate the presence of the pool node and its bridges in the configuration.

The pool node then restarts but the root bridge and the patch bridge do not come back up in this example. The pool node will let the importer know that the pool node is back up and the importer updates the input tables and the second representation of the output tables accordingly. The rules engine performs mapping operations on the modified input tables but the resulting desired data value would still not change because there was no change as to the existence of the pool node in the configuration of the system. However the current data value in the second representation would indicate at this point that the pool node has come back up but not the bridges.

The difference assessor detects the changes in the first and second representations and compares the desired and current data values regarding the pool node and its bridges. The difference assessor determines the difference which is the existence of the two bridges in the pool node. The difference assessor notifies the exporter of this difference. The exporter exports this difference to the pool node so that the pool node creates the root and patch bridges in it. The translator will also put this difference in the PTD and the coordination manager subsequently propagates this difference to one or more other controller instances.

Traditionally in routing protocol based distributed networking computing the computation of forwarding state e.g. computation of physical control plane data by a control plane of a switching element needs to be quick enough to meet the convergence requirements of the forwarding plane that is locally attached to the switching element. That is the control plane needs to compute the control logic of the switching element quickly so that the forwarding plane can update flow entries quickly to correctly forward data packets entering the switching element according to the flow entries.

When centralizing the control plane i.e. when the control plane data is managed by a centralized network controller the efficiency of the computation of the forwarding state becomes more critical. In particular moving the computation from many switching elements to one or more central controller instances may cause the central controller cluster to become a bottleneck to scalability because the central controller s computational resources e.g. memory CPU cycles etc. may not be sufficient to rapidly handle the computations despite the central controller instances typically having more computational resources than traditional forwarding elements such as routers physical switches virtual switches etc. . Also while these central computational resources can be scaled economical deployment factors may limit the amount of computational resources for the central controller instances e.g. the central controller instances have a limited number of servers and CPUs for economic reason . This makes an efficient implementation of the state computation a critical factor in building a centralized control plane that can scale to large scale networks while remaining practically deployable.

In network virtualization the opportunities for optimization are especially large. The computation of the forwarding state for a single LDPS involves computing the state for all involved physical switching elements over which the LDPS spans for all switching elements that implement the LDPS including individual switching elements that host the smallest portions of the LDPS such as a single logical port . In case of a large LDPS e.g. one with hundreds or even thousands of ports the degree of the span can be significant. However at the high level the state across the elements still realizes only a single forwarding behavior as it is still fundamentally only about a single LDPS.

Nevertheless often the forwarding state must be computed for each switching element because the forwarding state entries i.e. flow entries include components local or specific to the switching element e.g. specific ports of the switching element . This per element computation requirement may result in computational overhead that makes the computational requirements grow quickly enough to render the centralized computation of the forwarding state significantly more difficult. In particular irrespective of the logical ports present in a switching element one can assume that the forwarding state for a single switching element is of complexity O N where N is the number of logical ports the particular LDPS has in total. As the size of the LDPS grows N increases i.e. the load introduced by a single switching element increases as does the number of switching elements and the size of the state that has to be recomputed grows. Together this implies the resulting state complexity will be approximately O N which is clearly undesirable from an efficiency point of view as it may require a large amount of computational resources. As N grows large enough this may result in a computational load that becomes very difficult to meet by the centralized controller instances.

In some embodiments two factors exist that require per element computation of forwarding state for a LDPS. First the forwarding state itself may be uniquely specific to a switching element. For instance a particular switching element may have completely different forwarding hardware from any other switching element in the network. Second the forwarding state may be artificially bound to the switching element. For instance the forwarding state may have to include identifiers that are local to the switching element e.g. consider a forwarding entry that has to refer to a port number which is assigned by the switching element itself . Similarly the forwarding state may be uniquely specific to a switching element if the state includes dependencies to network state that are location specific. For instance a forwarding entry could refer to a multiprotocol label switching MPLS label that is meaningful only at the link that is local to the switching element.

Some embodiments of the invention provide a network control system that removes these two sources of dependencies in order to make the computation of the forwarding state as efficient as possible at the central controller instances. The network control system of such embodiments allows the forwarding state for a LDPS to be computed only once and then merely disseminated to the switching element layer. This decouples the physical instantiation of the forwarding state from its specification. Once the forwarding state becomes completely decoupled from the physical instantiation the forwarding state becomes universal as it can be applied at any switching element regardless of the switching element s type and location in the network.

Thus the network control system of some embodiments provides universal physical control plane data that enables the control system of some embodiments to scale even when there is a large number of managed switching elements that implement a LDPS. Universal physical control plane data in some embodiments abstracts common characteristics of different managed switching elements that implement a LDPS. More specifically the universal physical control plane data is an abstraction that is used to express physical control plane data without considering differences in the managed switching elements and or location specific information of the managed switching elements.

As mentioned above the control system s virtualization application of some embodiments converts the logical forwarding plane data for the LDPS to the universal physical control plane data and pushes down the universal physical control plane data to the chassis controller of the managed switching elements from a logical controller through one or more physical controllers in some embodiments . Each chassis controller of a managed switching element converts the universal physical control plane data into the physical control plane data that is specific to the managed switching element. Thus the computation to generate the physical control plane data specific to each managed switching element is offloaded to the managed switching element s chassis controller. By offloading the computation to the managed switching element layer the control system of some embodiments is able to scale in order to handle a large number of managed switching elements that implement a LDPS.

In some embodiments the universal physical control plane data that is pushed into the chassis controller may be different for different groups of managed switching elements. For instance the universal physical control plane data that is pushed for a first group of software switching elements e.g. OVSs that run a first version of software may be different than the universal physical control plane data that is pushed for a second group of software switching elements that run a second version of the software. This is because for example the formats of the universal physical control plane data that the different versions of software can handle may be different.

In the following description of the network controllers the managed forwarding state is assumed to include only flow entries. While there may be additional states other than the forwarding states managed by other out of band means these additional states play less critical roles in the actual establishing of the packet forwarding function and tend to be more auxiliary. In addition the realization of a LDPS itself requires use of virtual forwarding primitives effectively the physical datapath has to be sliced over the switching elements.

Even when the flow entries are made universal by following these principles a small portion of flow entries may remain that still require per switching element computation in some embodiments. The goal of these principles is to make this portion sufficiently small so that the computation of forwarding states can easily scale with larger deployments.

Similarly the following description does not imply that the forwarding elements will always or even should always follow the principles mentioned below but instead merely suggests that the pushed forwarding entries i.e. the entries pushed from a central controller to the switching element layer follow these principles. Once the universal entries are pushed to the physical switching element layer the chassis controller of the switching elements perform the necessary translations to the specifics of the switching elements. Again when some switching elements are not able to handle universal flow entries at all the central controller can still prepare the flow entries completely for the switching elements i.e. can customize the flow entries for the switching elements but with the cost of reduced scalability. Hence the universalization does not need to be complete throughout the flow entries nor throughout all the switching elements. The goal of universalization is to make the flow entries pervasive enough to allow for scaling.

Having stated these considerations several features principles of the universal forwarding network control system of some embodiments will now be described. These features include 1 making the matching entries independent of the local state of the switching elements 2 making actions independent of the local state of the switching elements 3 reducing the burden of disseminating flow entries from the central controller s to the switching elements and 4 simplifying the translation of universal state to switching element specific forwarding state by categorizing the universal flow entries accounting for switching element limitations when computing flow entries and including metadata in the universal flow entries.

All existing packet header matching expressions are usable in the universalization of some embodiments because by definition header matching expressions do not contain any location specific information and only refer to a packet which does not change for any specific switching element that receives the packet. However when packets contain identifiers and labels that are specific to a receiving network the universalization of the flow entries may not be applicable. In such case use of the local identifiers and labels has to be resolved at a higher level if such use becomes a scalability issue.

Any scratchpad register matching expression is usable in the universalization as long as the register is guaranteed to exist at any switching element or the switching element can simulate the register. The hardware limitations for the universalization will be discussed further below.

When matching to an ingress port the central controller of some embodiments uses a location independent identifier instead of a local port number of any sort to universalize the forwarding state. For instance for virtual interface VIF and physical network interface card e.g. NIC attachments e.g. VLAN attachments a globally unique identifier e.g. universally unique identifier UUID with possible VLAN attachment information should serve as the identifier to use in the universal forwarding state instead of a port number which is switch specific. Also for encapsulated traffic i.e. tunneled traffic which are data packets routed according to the information in their outer headers the central controller should be able to perform matching over the outer headers source IP address as well as over the tunnel type. Matching over the tunnel type helps minimize the number of flow entries because a flow entry is not required per traffic source. For instance if a central controller writes a single flow entry to receive from each source of type X it would result in X Y extra flow entries assuming there are Y switching elements for which to write such a flow entry.

Any packet modifying flow actions are universal in some embodiments. However operations that involve ports require special consideration. Also actions for routing packets to a physical port and a tunnel should not refer to any state that may be specific to the switching element. This has two implications.

First any identifier that refers to an existing state has to be globally unique. A port number that is local to a switching element is an example of an identifier that refers to an existing state but is not globally unique. There are several different ways for an identifier to be deemed globally unique. For instance an identifier is globally unique when the identifier guarantees a statistical uniqueness. Alternatively an identifier is globally unique when it includes a network locator e.g. an IP address . However an identifier that includes a network locator may not be globally unique when there are two different kinds of tunnels e.g. Internet Protocol Security IPsec and Generic Routing Encapsulation GRE towards the same destination. That is using an IP address alone as a tunnel identifier is not enough to make the identifier globally unique because an identical IP address may be used for both kinds of tunnels.

Second the flow entry should contain a complete specification of the tunnel to be created when the state does not exist e.g. when a tunnel should be explicitly created before any flow entry sends a packet through the tunnel . At a minimum the flow entry should include the tunnel type and a destination network locator. The flow entry may also additionally include information about any security transformations e.g. authentication and encryption etc. done for the packet as well as information about the layering relationships e.g. the OSI layers of various tunnels. If the flow entry is not self contained i.e. if the flow entry does not contain the complete specification of the tunnel to be created some embodiments create the tunnel i.e. a state for each switching element by other means such as configuration protocols of Open vSwitch OVS .

It is to be noted that physical ports are an exception to the universalization principles. While a forwarding entry that forwards a packet to a local physical port may use a physical interface identifier e.g. eth0 and a VLAN identifier in the action forwarding a packet to a local physical port still involves a state that is specific to a switching element. A physical interface identifier may be specific to a switching element because it is not guaranteed that most of the switching elements share an identical interface name for the interface to use for a given LDPS. A physical interface identifier may not be specific to a switching element when the network interfaces are named in such a way that the names remain the same across switching elements. For instance in some embodiments the control system exposes only a single bonded network interface to the flow entries so that the flow entries would never get exposed to any of the underlying differences in bonding details.

Finally there are actions that actually result in modifying local state at a switching element for each packet. Traditional MAC learning is an example of modifying local state at a switching element for each packet. The discussion above regarding having the matching entries and actions be independent of a local state does not apply to a local state established by the packets as long as the entries and actions operating on that packet s established state can be identical across switching elements. For instance in some embodiments the following universal learning action provides the necessary functionality for the controller to implement the learning in a location independent manner. This action s input parameters include in some embodiments 1 learning broadcast domain identifier e.g. 32 bit VLAN 2 traffic source identifier to be learned 3 a result to return for indicating flooding e.g. a 32 bit number and 4 a scratchpad register for writing the result e.g. either a source identifier or a flooding indicator . The action s output parameters in some embodiments include a scratchpad register that contains the learning decision. In some embodiments the learning state would be updated for any subsequent packets to be forwarded.

Universalization of the flow entries minimizes the computational overhead at the central controller instances by removing the redundancy in computation of flow entries. However there is still a non linear amount of non universal flow entries to be disseminated from the central location to the switching element layer. The universal forwarding network control system of some embodiments provides two solutions to alleviate the burden of disseminating such flow entries to the switching element layer.

First the control system reduces the transmission cost of the flow entries. In particular the system of some embodiments optimizes on wire encoding and representation of the flow entries to exploit any remaining redundancy that the universalization did not remove. For instance the flow state is likely to contain encapsulation entries that are seemingly similar if sending to logical port X1 send to IP1 using tunnel configuration C1 and then a number of similar entries for X2 IP2 C2 X3 IP3 C3 and so on. Similarly when flow entries are about packet replication the flow entries contain a significant level of repetition in the actions. That is these actions could be a long sequence of a small number of actions repeated with minor changes. Removing such redundancy calls for special flow entries that can capture the repetitive nature of the flow state. For instance a base flow template can be defined once and then updated with the parameter values that are changing. Alternatively a standard data compression technique can be used to compress the flow entries.

Second to alleviate the burden of disseminating flow entries to the switching element layer the control system of some embodiments offloads the transmission of the flow entries from controllers as much as possible. To implement this solution the switching elements should provide a failure tolerant mechanism for disseminating the universal flow state updates among the switching elements. In practice such implementation requires building a reliable publish subscribe infrastructure e.g. multicast infrastructure with the switching elements. In this manner the central controllers can take advantage of the switching elements ability to disseminate any updates timely and reliably among themselves and with little help from the central controllers.

In some embodiments the universal forwarding control system categorizes the universal flow entries into different types based on type information. That is the type information is used to precisely categorize every flow entry according to the entry s high level semantic purpose. Without the type information the chassis controller of the switching element may have difficulties in performing translation of the universal flow entries into flow entries specific to the local forwarding plane.

However even with type information the universal flow entries may not be translated for every switching element because of certain hardware limitations. In particular the forwarding hardware e.g. ASICs tend to come with significant limitations which the local control plane CPU running next to the ASIC s may not be able to overcome. Therefore the central controller that computes the universal flow entries in some embodiments accounts for these hardware limitations when computing the flow entries. Considering the hardware limitations the central controller of some embodiments disables some high level features provided by the LDP sets or constrains the implementation of those high level features by some other means such as placing an upper limit on them. However computation by factoring in the hardware limitations of switching elements does not mean the computation would become specific to a switching element. Rather the central controller can still remove redundancy in computation across the switching elements because the hardware limitations may be common to multiple switching elements.

In some embodiments the network control system has the universal flow entries include additional metadata that is not used by the most switching elements so that the translation of such universal flow entries remains feasible at as many switching elements as possible. The trade off between ballooning the state and savings computational resources in removing redundancy in computation is something to consider carefully for each flow entry type.

In some embodiments each of the controllers in a network control system has a full stack of different modules and interfaces described above by reference to . However each controller does not have to use all the modules and interfaces in order to perform the functionalities given for the controller. Alternatively in some embodiments a controller in the system has only those modules and interfaces that are necessary to perform the functionalities given for the controller. For instance the logical controller which is a master of a LDPS does not include an input module i.e. an input translation application but does include the control module and the virtualization module i.e. a control application or a virtualization application or an integrated application to generate universal physical control plane data from the input logical control plane data.

Moreover different combinations of different controllers may be running in a same machine. For instance the input translation controller and the logical controller may run in the same computing device. Also one controller may function differently for different LDP sets. For instance a single controller may be a master of a first LDPS and a master of a managed switching element that implements a second LDPS.

The input translation controller includes an input translation application such as the input translation application described above by reference to that generates logical control plane data from the inputs received from the user that specify a particular LDPS. The input translation controller identifies from the configuration data for the system the master of the LDPS. In this example the master of the LDPS is the logical controller . In some embodiments more than one controller can be masters of the same LDPS. Also one logical controller can be the master of more than one LDP sets.

The logical controller is responsible for the particular LDPS. The logical controller thus generates the universal physical control plane data from the logical control plane data received from the input translation controller. Specifically the control module not shown of the logical controller generates the logical forwarding plane data from the received logical control plane data and the virtualization module not shown of the logical controller generates the universal physical control plane data from the logical forwarding data.

The logical controller identifies physical controllers that are masters of the managed switching elements that implement the LDPS. In this example the logical controller identifies the physical controllers and because the managed switching elements are configured to implement the LDPS in this example. The logical controller sends the generated universal physical control plane data to the physical controllers and .

Each physical controllers and can be a master of one or more managed switching elements. In this example the physical controller is the master of two managed switching elements and and the physical controller is the master of the managed switching element . As the master of a set of managed switching elements the physical controllers of some embodiments generate from the received universal physical control plane data customized physical control plane data specific for each of the managed switching elements. Therefore in this example the physical controller generates the physical control plane data customized for each of the managed switching elements and . The physical controller generates physical control plane data customized for the managed switching element . The physical controllers send the customized physical control data to the managed switching elements of which the controllers are masters. In some embodiments multiple physical controllers can be the masters of the same managed switching elements.

In addition to sending customized control plane data the physical controllers of some embodiments receive data from the managed switching elements. For instance a physical controller receives configuration information e.g. identifiers of VIFs of a managed switching element of the managed switching elements. The physical controller maintains the configuration information and also sends the information up to the logical controllers so that the logical controllers have the configuration information of the managed switching elements that implement the LDP sets of which the logical controllers are masters.

Each of the managed switching elements generates physical forwarding plane data from the customized physical control plane data that the managed switching element received. As mentioned above the physical forwarding plane data defines the forwarding behavior of the managed switching element. In other words the managed switching element populates its forwarding table using the customized physical control plane data. The managed switching elements forward data among the machines according to the forwarding tables.

The input translation controller is similar to the input translation controller in that the input translation controller includes an input translation application that generates logical control plane data from the inputs received from the user that specify a particular LDPS. The input translation controller identifies from the configuration data for the system the master of the LDPS. In this example the master of the LDPS is the logical controller .

The logical controller is similar to the logical controller in that the logical controller generates the universal physical control plane data from the logical control plane data received from the input translation controller . The logical controller identifies physical controllers that are masters of the managed switching elements that implement the LDPS. In this example the logical controller identifies the physical controllers and because the managed switching elements are configured to implement the LDPS in this example. The logical controller sends the generated universal physical control plane data to the physical controllers and .

Like the physical controllers and each physical controllers and can be a master of one or more managed switching elements. In this example the physical controller is the master of two managed switching elements and and the physical controller is the master of the managed switching element . However the physical controllers and do not generate customized physical control plane data for the managed switching elements . As a master of managed switching elements the physical controller sends the universal physical control plane data to the chassis controller that is responsible for each managed switching element of which the physical controller is the master. That is the physical controller of some embodiments identifies the chassis controllers that interface the managed switching elements of which the physical controller is master. In some embodiments the physical controller identifies those chassis controllers by determining whether the chassis controllers are subscribing to a channel of the physical controller.

A chassis controller of some embodiments has a one to one relationship with a managed switching element. The chassis controller receives universal control plane data from the physical controller that is the master of the managed switching element and generates customized control plane data specific for the managed switching element. An example architecture of a chassis controller will be described further below by reference to . The chassis controller in some embodiments runs in the same machine in which the managed switching element that the chassis controller manages runs while in other embodiments the chassis controller and the managed switching element run in different machines. In this example the chassis controller and the managed switching element run in the same computing device.

Like the managed switching elements each of the managed switching elements generates physical forwarding plane data from the customized physical control plane data that the managed switching element received. The managed switching elements populate their respective forwarding tables using the customized physical control plane data. The managed switching elements forward data among the machines according to the flow tables.

As mentioned above a managed switching element may implement more than one LDPS in some cases. In such cases the physical controller that is the master of such a managed switching element receives universal control plane data for each of the LDP sets. Thus a physical controller in the network control system may be functioning as an aggregation point for relaying universal control plane data for the different LDP sets for a particular managed switching element that implements the LDP sets to the chassis controllers.

Even though the chassis controllers illustrated in are a level above the managed switching elements the chassis controllers typically operate at the same level as the managed switching elements do because the chassis controllers of some embodiments within the managed switching elements or adjacent to the managed switching elements.

In some embodiments a network control system can have a hybrid of the network control systems and . That is in this hybrid network control system some of the physical controllers generate customized physical control plane data for some of the managed switching elements and some of the physical controllers do not generate customized physical control plane data for some of the managed switching elements. For the latter managed switching elements the hybrid system has chassis controllers to generate the customized physical control plane data.

As mentioned above a chassis controller of some embodiments is a controller for managing a single managed switching element. A chassis controller of some embodiments does not have a full stack of different modules and interfaces described above by reference to . One of the module that a chassis controller does have is a chassis control application that generates customized physical control plane data from universal control plane data it receives from one or more physical controllers. illustrates an example architecture for a chassis control application . This application uses an nLog table mapping engine to map input tables that contain input data tuples that represent universal control plane data to data tuples that represent the logical forwarding plane data. This application manages the managed switching element in this example by exchanging data with the managed switching element . In some embodiments the application i.e. the chassis controller runs in the same machine in which the managed switching element is running.

As shown in the chassis control application includes a set of rule engine input tables a set of function and constant tables an importer a rules engine a set of rule engine output tables an exporter a managed switching element communication interface and a compiler . This figure also illustrates a physical controller and a managed switching element .

The compiler is similar to the compilers in . In some embodiments the rule engine RE input tables include tables with universal physical data and or switching configurations e.g. access control list configurations private virtual network configurations port security configurations etc. that the physical controller that is master of the managed switching element sent to the chassis control application . The input tables also include tables that contain physical data i.e. non logical data from the managed switching element . In some embodiments such physical data includes data regarding the managed switching element e.g. customized physical control plane data physical forwarding data and other data regarding configuration of the managed switching element .

The input tables are partially populated by the universal physical control plane data provided by the physical controller . The physical controller of some embodiments receives the universal physical control plane data from one or more logical controllers not shown .

In addition to the input tables the virtualization application includes other miscellaneous tables that the rules engine uses to gather inputs for its table mapping operations. These tables include constant tables that store defined values for constants that the rules engine needs to perform its table mapping operations.

When the rules engine references constants the corresponding value defined for the constants are actually retrieved and used. In addition the values defined for constants in the constant table may be modified and or updated. In this manner the constant tables provide the ability to modify the value defined for constants that the rules engine references without the need to rewrite or recompile code that specifies the operation of the rules engine . The tables further include function tables that store functions that the rules engine needs to use to calculate values needed to populate the output tables .

The rules engine performs table mapping operations that specify one manner for implementing the LDP sets within the managed switching element . Whenever one of the RE input tables is modified the rules engine performs a set of table mapping operations that may result in the modification of one or more data tuples in one or more RE output tables.

As shown in the rules engine includes an event processor several query plans and a table processor . In some embodiments each query plan is a set of join operations that are to be performed upon the occurrence of a modification to one of the RE input table. Such a modification is referred to below as an input table event. Each query plan is generated by the compiler from one declaratory rule in the set of declarations . In some embodiments more than one query plan is generated from one declaratory rule as described above. In some embodiments the query plans are defined by using the nLog declaratory language.

The event processor of the rules engine detects the occurrence of each input table event. The event processor of different embodiments detects the occurrence of an input table event differently. In some embodiments the event processor registers for callbacks with the input tables for notification of changes to the records of the input tables. In such embodiments the event processor detects an input table event when it receives notification from an input table that one of its records has changed.

In response to a detected input table event the event processor 1 selects the appropriate query plan for the detected table event and 2 directs the table processor to execute the query plan. To execute the query plan the table processor in some embodiments performs the join operations specified by the query plan to produce one or more records that represent one or more sets of data values from one or more input and miscellaneous tables and . The table processor of some embodiments then 1 performs a select operation to select a subset of the data values from the record s produced by the join operations and 2 writes the selected subset of data values in one or more output tables .

In some embodiments the RE output tables store both logical and physical network element data attributes. The tables are called RE output tables as they store the output of the table mapping operations of the rules engine . In some embodiments the RE output tables can be grouped in several different categories. For instance in some embodiments these tables can be RE input tables and or chassis controller application CCA output tables. A table is an RE input table when a change in the table causes the rules engine to detect an input event that requires the execution of a query plan. A RE output table can also be an RE input table that generates an event that causes the rules engine to perform another query plan after it is modified by the rules engine. Such an event is referred to as an internal input event and it is to be contrasted with an external input event which is an event that is caused by an RE input table modification made by the control application via the importer . A table is a CCA output table when a change in the table causes the exporter to export a change to the managed switching elements or other controller instances.

The exporter detects changes to the CCA output tables of the RE output tables . The exporter of different embodiments detects the occurrence of a CCA output table event differently. In some embodiments the exporter registers for callbacks with the CCA output tables for notification of changes to the records of the CCA output tables. In such embodiments the exporter detects an output table event when it receives notification from a CCA output table that one of its records has changed.

In response to a detected output table event the exporter takes each modified data tuple in the modified output tables and propagates this modified data tuple to one or more of other controller instances e.g. physical controller or to the managed switching element . The exporter uses an inter instance communication interface not shown to send the modified data tuples to the other controller instances. This inter instance communication interface is similar to inter instance communication interface described above in that the inter instance communication interface establishes communication channels e.g. an RPC channel with other controller instances.

The exporter of some embodiments uses the managed switching element communication interface to send the modified data tuples to the managed switching element . The managed switching element communication interface of some embodiments establishes two channels of communication. The managed switching element communication interface establishes a first of the two channels using a switching control protocol. One example of a switching control protocol is the OpenFlow protocol. The Openflow protocol in some embodiments is a communication protocol for controlling the forwarding plane e.g. forwarding tables of a switching element. For instance the Openflow protocol provides commands for adding flow entries to removing flow entries from and modifying flow entries in the managed switching element .

The managed switching element communication interface establishes a second of the two channels using a configuration protocol to send configuration information. In some embodiments configuration information includes information for configuring the managed switching element such as information for configuring ingress ports egress ports QoS configurations for ports etc.

The managed switching element communication interface receives updates in the managed switching element from the managed switching element over the two channels. The managed switching element of some embodiments sends updates to the chassis control application when there are changes with the flow entries or the configuration of the managed switching element not initiated by the chassis control application . Examples of such changes include dropping of a machine that was connected to a port of the managed switching element a VM migration to the managed switching element etc. The managed switching element communication interface sends the updates to the importer which will modify one or more input tables . When there is output produced by the rules engine from these updates the exporter will send this output to the physical controller .

As mentioned above a physical controller in a network control system of some embodiments such as the network control system does not customize the universal control plane data for the managed switching elements of which the physical controller is a master. When the network control system does not have chassis controllers to customized the universal control plane data for the managed switching elements the network control system of some embodiments puts a controller daemon in the hosts on which the managed switching elements run so that the controller daemon can perform the conversion of the universal control plane data into customized control plane data specific to the switching elements.

The managed switching element in this example is a software switch. The managed switching element includes a configuration database and the flow table that includes flow entries. For simplicity of discussion other components e.g. ports forwarding tables etc. are not depicted in this figure. The managed switching element of some embodiments receives the universal physical control plane data over two channels a first channel using a switch control protocol e.g. OpenFlow and a second channel using a configuration protocol. As mentioned above the data coming over the first switching element includes flow entries and the data coming over the second switching element includes configuration information. The managed switching element therefore puts the universal data coming over the first channel in the flow table and the universal data coming over the second channel in the configuration database . However the universal data is not written in terms of specifics of the managed switching element. The universal data thus has to be customized by rewriting the data in terms of the specifics of the managed switching element.

In some embodiments the managed switching element keeps the configuration information in terms of the specifics of the managed switching element in the configuration database . The controller daemon uses this configuration information in order to translate the universal data stored in the configuration database . For instance the universal data may specify a port of the managed switching element using a universal identifier. The controller daemon has logic to map this universal identifier to a local port identifier e.g. port number that is also stored in the configuration database . The controller daemon then uses this customized configuration information to modify the flow entries that are written in terms of universal data.

As shown in the first stage the logical switch forwards data between the VMs and . Specifically data comes to or from VM through a logical port of the logical switch and data comes to or from VM through a logical port of the logical switch . The logical switch is implemented by the managed switching element in this example. That is the logical port is mapped to port of the managed switching element and the logical port is mapped to port of the managed switching element .

The network control system in this example includes a controller cluster and two chassis controller and . The controller cluster includes input translation controllers not shown logical controllers not shown and physical controllers not shown that collectively generate universal control plane data based on the inputs that the controller cluster receives. The chassis controllers receive the universal control plane data and customize the universal data into physical control plane data that is specific to the managed switching element that each chassis controller is managing. The chassis controllers and pass the customized physical control plane data to the managed switching elements and respectively so that the managed switching elements and can generate physical forwarding plane data which the managed switching elements use to forward the data between the managed switching elements and .

At the second stage an administrator of the network that includes managed switching element creates VM in the host not shown in which the managed switching element runs. The administrator creates port of the managed switching element and attaches VM to the port. Upon creation of port the managed switching element of some embodiments sends the information about the newly created port to the controller cluster . In some embodiments the information may include port number network addresses e.g. IP and MAC addresses transport zone to which the managed switching element belongs machine attached to the port etc. As mentioned above this configuration information goes through the chassis controller managing the managed switching element and then through physical controllers and logical controllers all the way up to the user that manages the logical switch . To this user a new VM has become available to be added to the logical switch that the user is managing.

At stage the user in this example decides to use VM and attaches VM to the logical switch . As a result a logical port of the logical switch is created. Data coming to or from VM therefore will go through the logical port . In some embodiments the controller cluster directs all the managed switching elements that implement the logical switch to create a tunnel between each pair of managed switching elements that has a pair of ports to which a pair of logical ports of the logical switch are mapped. In this example a tunnel can be established between managed switching elements and to facilitate data exchange between the logical port and the logical port i.e. between VMs and and between the logical port and the logical port i.e. between VMs and . That is data being exchanged between port of the managed switching element and port of the managed switching element and data being exchanged between port of the managed switching element and port of the managed switching element can go through the tunnel established between the managed switching elements and .

A tunnel between two managed switching elements is not needed to facilitate data exchange between the logical port and the logical port i.e. between VMs and because the logical port and the logical port are mapped onto two ports on the same managed switching element .

The third stage further shows that the controller cluster sends universal physical control plane data specifying instructions to create a tunnel from the managed switching element to the managed switching element . In this example the universal physical control plane data is sent to the chassis controller which will customize the universal physical control plane data to physical control plane data specific to the managed switching element .

The fourth stage shows that the chassis controller sends the tunnel physical control plane data that specifies instructions to create a tunnel and to forward packets to the tunnel. The managed switching element creates a tunnel to the managed switching element based on the customized physical control plane data. More specifically the managed switching element creates port and establishes a tunnel e.g. GRE tunnel to port of the managed switching element . More detailed operations to create a tunnel between two managed switching elements will be described below.

The process begins by receiving universal physical control plane data from a logical controller or a physical controller. In some embodiments universal physical control plane data have different types. One of the types of universal physical control plane data is universal tunnel flow instructions which specify creation of a tunnel in a managed switching element and the use of the tunnel. In some embodiments the universal tunnel flow instructions include information about a port created in a managed switching element in a network. This port is a port of a managed switching element to which a user has mapped a logical port of the logical switch. This port is also a destination port which the tunneled data needs to reach. The information about the port includes 1 a transport zone to which the managed switching element that has the port belongs 2 a tunnel type which in some embodiments is based on tunnel protocols e.g. GRE CAPWAP etc. used to build a tunnel to the managed switching element that has the destination port and 3 a network address e.g. IP address of the managed switching element that has the destination port e.g. IP address of a VIF that will function as one end of the tunnel to establish .

Next the process determines at whether the received universal physical control plane data is a universal tunnel flow instruction. In some embodiments the universal control plane data specifies its type so that the process can determine the type of the received universal plane data. When the process determines at that the received universal data is not a universal tunnel flow instruction the process proceeds to to process the universal control plane data to generate customized control plane data and send the generated data to the managed switching element that the process is managing. The process then ends.

When the process determines at that the received universal control plane data is the universal tunnel flow instructions the process proceeds to to parse the data to obtain the information about the destination port. The process then determines at whether the managed switching element that has the destination port is in the same transport zone in which the managed switching element that has a source port is. The managed switching element that has the source port is the managed switching element that the chassis controller or the physical controller that performs the process manages. In some embodiments a transport zone includes a group of machines that can communicate with each other without using a second level managed switching element such as a pool node.

When the process determines at that the managed switching element with the source port and the managed switching element with the destination port are not in the same transport zone the process proceeds to which is described above. Otherwise the process proceeds to to customize the universal tunnel flow instructions and send the customized information to the managed switching element that has the source port. Customizing the universal tunnel flow instructions will be described in detail below. The process then ends.

The process begins by generating at instructions for creating a tunnel port. In some embodiments the process generates instructions for creating a tunnel port in the managed switching element that the controller manages based on the port information. The instructions include for example the type of tunnel to establish and the IP address of the NIC which will be the destination end of the tunnel. The tunnel port of the managed switching element managed by the controller will be the other end of the tunnel.

Next the process sends at the generated instructions for creating the tunnel port to the managed switching element that the controller manages. As mentioned above a chassis controller of some embodiments or a physical controller that directly interfaces with a managed switching element uses two channels to communicate with the managed switching element. One channel is a configuration channel to exchange configuration information with the managed switching element and the other channel is a switch control channel e.g. a channel established using OpenFlow protocol for exchanging flow entries and event data with the managed switching element. In some embodiments the process uses the configuration channel to send the generated instructions for creating the tunnel port to the managed switching element that the controller manages. Upon receiving the generated instructions the managed switching element of some embodiments creates the tunnel port in the managed switching element and establishes a tunnel between the tunnel port and a port of the managed switching element that has the destination port using a tunnel protocol specified by the tunnel type. When the tunnel port and the tunnel are created and established the managed switching element of some embodiments sends the value e.g. four of the identifier of the tunnel back to the controller instance.

The process of some embodiments then receives at the value of the identifier of the tunnel port e.g. tunnel port 4 through the configuration channel. The process then modifies a flow entry that is included in the universal tunnel flow instructions using this received value. This flow entry when sent to the managed switching element causes the managed switching element to perform an action. However being universal data this flow entry identifies the tunnel port by a universal identifier e.g. tunnel port and not by an actual port number. For instance this flow entry in the received universal tunnel flow instructions may be If destination destination machine s UUID send to tunnel port. The process modifies at the flow entry with the value of the identifier of the tunnel port. Specifically the process replaces the identifier for the tunnel port with the actual value of the identifier that identifies the created port. For instance the modified flow entry would look like If destination destination machine s UUID send to 4. 

The process then sends at this flow entry to the managed switching element. In some embodiments the process sends this flow entry to the managed switching element over the switch control channel e.g. OpenFlow channel . The managed switching element will update its flow entries table using this flow entry. The managed switching element from then on forwards the data headed to a destination machine through the tunnel by sending the data to the tunnel port. The process then ends.

As shown the chassis controller includes input tables a rules engine and output tables which are similar to the input tables the rules engine and the output tables . The chassis controller manages the managed switching element . Two channels and are established between the chassis controller and the managed switching element in some embodiment. The channel is for exchanging configuration data e.g. data about creating ports current status of the ports queues associated with the managed switching element etc. . The channel is an OpenFlow channel OpenFlow control channel over which to exchange flow entries in some embodiments.

The first stage shows that the chassis controller has updated the input tables using universal tunnel flow instructions received from a physical controller not shown . As shown the universal tunnel flow instructions include an instruction for creating a tunnel and a flow entry . As shown the instruction includes the type of the tunnel to be created and the IP addresses of the managed switching element that has the destination port. The flow entry specifies the action to take in terms of universal data that is not specific to the managed switching element . The rules engine performs table mapping operations onto the instruction and the flow entry .

The second stage shows the result of the table mapping operations performed by the rules engine . An instruction results from the instruction . In some embodiments the instructions and may be identical while they may not be in other embodiments. For instance the values in the instructions and that represent the tunnel type may be differ. The instruction includes the IP address and the type of the tunnel to be created among other information that may be included in the instruction . The flow entry did not trigger any table mapping operation and thus remains in the input tables .

The third stage shows that the instruction has been pushed to the managed switching element over the configuration channel . The managed switching element creates a tunnel port and establishes a tunnel between the managed switching element and another managed switching element that has the destination port. One end of the tunnel is the tunnel port created and the other end of the tunnel is the port that is associated with the destination IP address in some embodiments. The managed switching element of some embodiments uses the protocol specified by the tunnel type to establish the tunnel.

The fourth stage shows that the managed switching element has created a tunnel port port in this example and a tunnel . This stage also shows that the managed switching element sends back the actual value of the tunnel port identifier. The managed switching element sends this information over the configuration channel in this example. The information goes into the input tables as input event data. The fifth stage shows that the input tables are updated with the information from the managed switching element . This update triggers the rules engine to perform table mapping operations.

The sixth stage shows the result of the table mapping operations performed at the previous stage . The output tables now has a flow entry that specifies the action to take in terms of information that is specific to the managed switching element . Specifically the flow entry specifies that when a packet s destination is the destination port the managed switching element should sent out the packet through port . The seventh stage shows that the flow entry has been pushed to the managed switching element which will forward packets using the flow entry .

It is to be noted that the instruction and the data exchanged between the chassis controller and the managed switching element as shown in are conceptual representation of the universal tunnel flow instructions and the customized instructions and may not be in actual expressions and formats.

Moreover the example of is described in terms of the operation of the chassis controller . This example is also applicable to a physical controller of some embodiments that translate universal physical control plane data into customized physical control plane data for the managed switching elements of which the physical controller is a master.

A sequence of events for creating a tunnel in each of the three examples will now be described. For a tunnel between a managed switching element and a pool node the pool node is first provisioned and then the managed switching element is provisioned. A VM gets connected to a port of the managed switching element. This VM is the first VM that is connected to the managed switching element. This VM is then bound to a logical port of a logical switch by mapping the logical port to the port of the managed switching element. Once the mapping of the logical port to the port of the managed switching element is done a logical controller sends e.g. via physical controller s universal tunnel flow instructions to the chassis controller or to the physical controller that interfaces the managed switching element.

The chassis controller then instructs the managed switching element to create a tunnel to the pool node. Once the tunnel is created another VM that is subsequently provisioned and connected to the managed switching element will share the same tunnel to exchange data with the pool node if this new VM is bound to a logical port of the same logical switch. If the new node is bound to a logical port of a different logical switch the logical controller will send the same universal tunnel flow instructions that was passed down when the first VM was connected to the managed switching element. However the universal tunnel flow instructions will not cause to create a new tunnel to the pool node because for example a tunnel has already been created and operational.

If the established tunnel is a unidirectional tunnel another unidirectional tunnel is established from the pool node side. When the logical port to which the first VM is bounded is mapped to the port of the managed switching element the logical controller also sends universal tunnel flow instructions to the pool node. Based on the universal tunnel flow instructions a chassis controller that interfaces the pool node will instruct the pool node to create a tunnel to the managed switching element.

For a tunnel between a managed edge switching element and a managed switching element providing L3 gateway service it is assumed that a logical switch with several VMs of a user have been provisioned and a logical router is implemented in a transport node that provides the L3 gateway service. A logical patch port is created in the logical switch to link the logical router to the logical switch. In some embodiments an order in which the creation of the logical patch and provisioning of VMs do not make a difference to tunnel creation. The creation of the logical patch port causes a logical controller to send universal tunnel flow instructions to the chassis controllers or physical controllers interfacing all the managed switching elements that implement the logical switch i.e. all the managed switching elements that each has at least one port to which a logical port of the logical switch is mapped . Each chassis controller for each of these managed switching elements instructs the managed switching element to create a tunnel to the transport node. The managed switching elements each creates a tunnel to the transport node resulting in as many tunnels as the number of the managed switching elements that implement the logical switch.

If these tunnels are unidirectional the transport node is to create a tunnel to each of the managed switching elements that implement the logical switch. The logical switch pushes universal tunnel flow instructions to the transport node when the logical patch port is created and connected to the logical router. A chassis controller interfacing the transport node instructs the transport node to create tunnels and the transport node creates tunnels to the managed switching elements.

In some embodiments a tunnel established between two managed switching elements can be used for data exchange between any machine attached to one of the managed switching element and any machine attached to the other managed switching element regardless of whether these two machines are using logical ports of the same logical switch or of two different switches. That is one example case where tunneling enables different users that are managing different LDP sets to share the managed switching elements while being isolated.

A creation of a tunnel between two managed switching elements in which a logical port and another logical port that is attached to L2 gateway service starts when a logical port gets attached to L2 gateway service. The attachment causes the logical controller to send out universal tunnel flow instructions to all the managed switching elements that implement other logical ports of the logical switch. Based on the instructions tunnels are established from these managed switching elements to a managed switching element that implements the logical port attached to L2 gateway service.

As shown the logical switch includes logical ports and . These logical ports of some embodiments can be both ingress ports and egress ports. The logical switch also includes forwarding tables . The logical switch receives network data e.g. packets through the ingress ports and routes the network data based on the logical flow entries specified in the forwarding tables to the egress ports through which the logical switch sends out the network data.

This figure also illustrates a UI . The UI is provided by a user interface application that allows the user to enter input values. The UI may be a web application a command line interface CLI or any other form of user interface through which the user can provide inputs. This user application of some embodiments sends the inputs in the form of API calls to an input translation application. As mentioned above an input translation application of some embodiments supports the API and sends the user input data to one or more logical controllers. The UI of some embodiments displays the current configuration of the logical switch that the user is managing.

VM is a virtual machine that sends data to the logical switch through port . That is port of the logical switch is serving as an ingress port for VM . The logical switch performs logical ingress lookups using an ingress ACL table not shown which is one of forwarding tables in order to control the data e.g. packets coming through the ingress ports. For instance the logical switch reads information stored in the header of a packet that is received through an ingress port looks up the matching flow entry or entries in the ingress ACL table and determines an action to perform on the received packet. As described above a logical switch may perform further logical lookups using other forwarding tables that are storing flow entries. Also mentioned above the operation of a logical switch is performed by a set of managed switching elements that implement the logical switch by performing a logical processing pipeline.

When a logical port is enabled for QoS the logical port needs a logical queue to en queue the packets that are going into the logical switch through the logical port. In some embodiments the user assigns a logical queue to a logical port. A logical queue may be created based on the inputs in some embodiments. The user may also specify the minimum and maximum bitrates for the queue. When enabling a logical port for QoS the user may then point the logical port to the logical queue. In some embodiments multiple logical ports can share the same logical queue. By sharing the same logical queue the machines that send data to the logical switch through these logical ports can share the minimum and maximum bitrates associated with the logical queue.

In some embodiments the control application of a logical controller creates a logical queue collection for the logical port. The control application then has the logical queue collection point to the logical queue. The logical port and the logical queue collection have a one to one relationship in some embodiments. However in some embodiments several logical ports and corresponding logical queue collections can share one logical queue. That is the traffic coming through these several logical ports together are guaranteed for some level of performance specified for the logical queue.

Once a logical port points to a logical queue once the relationship between logical port the logical queue collection and the logical queue is established a physical queue collection and physical queue are created. The steps that lead to the creation of a physical queue collection and a physical queue will be described in detail further below by reference to .

In some embodiments the logical queue collection and the logical queue are mapped to a physical queue collection and a physical queue respectively. When the packets are coming into the logical switch through a logical port that points to a logical queue the packets are actually queued in the physical queue to which the logical queue is mapped. That is a logical queue is a logical concept that does not actually queue packets. Instead a logical queue indicates that the logical port that is associated with the logical queue is enabled for QoS.

In the first stage neither of the logical ports and of the logical switch is enabled for QoS. The logical switch routes packets that are coming from VM and VM through ports and to the egress ports without guaranteeing certain performance level because logical ports and are not enabled for QoS. On the physical side packets from VM are sent through port of the managed switching element .

In the second stage a user using the UI enables port of the logical switch for QoS by specifying information in the box next to port in the UI in this example. The user specifies LQ as the ID of the logical queue to which to point port . The user also specifies A and B as the minimum and maximum bitrates respectively of the logical queue. A and B here represent bitrates which are numerical values that quantify the amount of data that the port allows to go through per unit of time e.g. 1 024 bit second etc. .

The control application creates a logical queue according to the specified information. The control application also creates a logical queue collection that would be set between port and the logical queue LQ. The logical queue LQ queues the packets coming into the logical switch through port in order to guarantee that the packets are routed at a bitrate between the minimum and the maximum bitrates. For instance the logical queue LQ will hold some of the packets in the queue when the packets are coming into the logical queue LQ through port at a higher bitrate than the maximum bitrate. The logical switch will send the packets to the egress ports at a bitrate that is lower than the maximum bitrate but at a higher bitrate than the minimum bitrate . Conversely when the packets coming through port are routed at a bitrate above but close to the minimum bitrate the logical queue LQ may prioritize the packets in the queue such that the logical switch routes these packets first over other packets in some embodiments.

On the physical side the managed switching element creates a physical queue collection and a physical queue in the host and associates the physical queue collection and the physical queue with PIF . A physical queue collection of some embodiments may include more than one physical queue in some embodiments. The physical queue collection in this example includes physical queue . The logical queue is mapped to the physical queue actual queuing takes place. That is the packets coming through port of the logical switch in this example are queued in the physical queue . The physical queue in some embodiments is implemented as a storage structure for storing packets. The packets from VM are queued in the physical queue before the packets are sent out through PIF so that the packets that come in through port are sent out at a bitrate between the minimum and maximum bitrates.

The input translation application the control application and the virtualization application are similar to the input translation application the control application and the virtualization application described above in Section I respectively. In this example the input translation application runs in an input translation controller and the control application and the virtualization application run in a logical controller.

The first stage shows that the control application includes input tables rules engine and an output tables which are similar to their corresponding components of the control application in . Not all components of the control application are shown for the control application for simplicity of discussion. This stage also shows a UI which is similar to the UI in .

In the first stage the UI displays QoS information of ports and of the logical switch . As indicated by the UI the logical ports of the logical switch are not enabled for QoS. The UI displays whether ports and of the logical switch which is identified by an identifier LSW are enabled for QoS. The unchecked boxes in the UI indicate that ports and of the logical switch are not enabled for QoS. In some embodiments the UI allows the user to specify a logical queue to which to point a logical port.

In the second stage the user provides input to indicate that user wishes to enable port of the logical switch for QoS. As shown the user has checked a box next to port in the UI and entered LQ as the logical queue ID to which to point port . The user has also entered a command to create the logical queue with A and B as the minimum and maximum bitrates respectively. The input translation application receives the user s inputs in the form of API calls. The input translation application translates the user s inputs into data that can be used by the control application and sends the translated inputs to the control application because the logical controller on which the control application runs is the master of the LDPS.

In the third stage the control application receives the inputs from the input translation application . Based on the received inputs the control application modifies three input tables . The input table shows whether a logical port of the logical switch has a logical queue collection for the logical port. In this example the control application first creates a logical queue collection identifier LQC for the logical queue that the user wants to create. The control application updates the entry in the input table for the logical port to indicate that the logical queue collection identifier is created and associated with the logical port .

Upon creation of the logical queue collection identifier for the logical queue i.e. for the logical port the rules engine performs table mapping operations to modify the input table . The input table shows whether a logical queue collection identifier is associated with a logical queue identifier. The control application creates a logical queue identifier LQ as the user has specified. The control application updates the input table to indicate the logical queue collection identifier LQC is related to the logical queue identifier LQ.

The control application also updates the input table which has a list of logical queue identifiers of the logical switch and each logical queue s minimum and the maximum bitrates. The control application creates an entry in the input table for the logical queue LQ having the minimum bitrate A and the maximum bitrate B that the user has specified. Based on the updates to the input tables the rules engine performs table mapping operations.

The fourth stage shows the result of the table mapping operations performed by the rules engine . As shown the rules engine has modified and or created an output table . The table is a table that specifies logical actions to be performed on a packet coming into the logical switch through the logical port by the logical switch . The entry of the output table indicates that logical switch should accept the packet and set a logical queue for the logical port i.e. associate a logical queue with the logical port if the packet has correct logical context and has a source mac address that matches to the logical port s default MAC address. The entry of the output table indicates that the logical switch should drop the packet if it does not match the conditions specified in the entry .

The fifth stage shows that the control application has sent the output table to the input tables of the virtualization application . Based on a function table not shown the rules engine performs table mapping operations to unpack the table . In some embodiments unpacking a table means specifying a physical action i.e. an action that a managed switching element which has a port to which the logical port is mapped is to perform for each logical action specified in the table. The table shows the unpacked logical actions of the table . The entry specifies that the matching physical action for setting a logical queue is setting a physical queue with the minimum and maximum bitrates A and B. The entry specifies that setting context to the next context i.e. moving to the next operation of the logical processing pipeline is the matching physical action of the logical accept action. The entry specifies that the managed switching element should drop the packet when the logical switch s action is dropping the packet.

Once unpacking is done the rules engine performs table mapping actions to pack the unpacked table. In some embodiments packing an unpacked table means gathering all physical actions that match the logical actions in an entry of a table that was originally unpacked. The sixth stage shows that the table that results from packing has an expressions column that is identical to the expressions column of the table that was originally unpacked. Each entry of the table includes a set of physical actions that matches the set of logical actions specified for the corresponding entry in the table . Thus the table specifies all physical actions to be performed on a packet coming into the managed switching element through the port to which the logical port is mapped. The rules engine performs table mapping operations to generate universal flow tables.

The seventh stage shows a table which is the result of performing the table mapping operations at the previous stage . As shown the table has three columns for LDPS identifiers flow types and abstract switch identifiers in addition to the table . A LDPS identifier identifies a LDPS. A flow type specifies the type of universal physical control plane data. As mentioned above one of the types of universal physical control plane data is universal tunnel flow instructions. An abstract switch identifier identifies a channel between two controller instances. The abstract switch identifiers are used to send the data only to those controller instances that are subscribing to this channel to get the data.

The eighth stage shows a physical controller which subscribes to the channel of the virtualization application . The virtualization application along with the control application is running in a logical controller as mentioned above. The table is fed into the rules engine as an input table. The rules engine performs table mapping operations to determine whether the entries of the table are implemented by one of the managed switching elements of which the physical controller is a master. In this example the rules engine does not filter out the table and thus puts into the output tables as shown in the ninth stage .

At this stage the physical controller sends the output table to all chassis controllers which subscribe to a channel of the physical controller to get data from the physical controller.

The next stage shows a chassis controller which subscribes to a channel of the physical controller . In this example the chassis controller manages the managed switching element . As shown the table is fed into the rules engine of the chassis controller . The rules engine performs table mapping operations to parse the entries in the universal flow table .

The eleventh stage shows a table which includes entries for specifying a set of actions to be performed by the managed switching element that has a port to which the logical port is mapped. Specifically physical actions actions before and actions after represent the operations in a logical processing pipeline that the managed switching element is to perform. Also some of these actions are expressed in terms of identifiers that are not specific to the managed switching element that the chassis controller is managing. In other words the entries in the table have not been customized by the chassis controller. The rules engine performs table mapping operations to generate several requests to pass down to the managed switching element that the chassis controller is managing. The generated requests are shown in the next stage . These requests are in separate tables and . The table includes a request to create a queue collection for the PIF of the host not shown . The table includes a request to create a queue with the minimum and maximum bitrates of A and B. The chassis controller sends the requests to the managed switching element . In some embodiments these requests are sent over a configuration channel established between the chassis controller and the managed switching element .

The next stage shows that the managed switching element sends a physical queue identifier not shown and a physical queue collection identifier not shown that are created for a physical queue not shown and a physical queue collection not shown that the managed switching element has created in response to the requests. This information is sent back to the chassis controller over the configuration channel in some embodiments. The chassis controller updates the input tables and based on the information received from the managed switching element . In particular the table specifies the association of the logical queue identifier LQ and the physical queue identifier PQ. The rules engine then generates flow entries based on the unpacked flows in the table shown in stage and the input tables and .

The fourteenth stage shows a table which is the result of the table mapping operations performed at the previous stage . The table includes flow entries that are expressed in terms of the information that is specific to the managed switching element that the chassis controller is managing. The chassis controller sends these flow entries to the managed switching element over a switch control channel e.g. OpenFlow channel . The managed switching element would then forward the packets coming to the managed switching element based on the flow entries received from the chassis controller .

As shown illustrates that the logical switch has a set of logical ports including logical port . The logical switch also includes forwarding tables which include an ingress ACL table and an egress ACL table among other forwarding tables. also illustrates a UI which is similar to the UI in .

VM is a virtual machine that sends and receives network data to and from the logical switch through port . That is port of the logical switch is serving both as an ingress port and an egress port for VM. VM has A as the virtual machine s MAC address. A represents a MAC address in the proper MAC address format e.g. 01 23 45 67 89 ab . This MAC address is a default MAC address assigned to VM when VM is created. An IP address is usually not assigned to a virtual machine but a MAC address is always assigned to a virtual machine when it is initially created in some embodiments.

The logical switch performs logical ingress lookups using the ingress ACL table in order to control the network data e.g. packets coming through the ingress ports. For instance the logical switch reads information stored in the header of a packet that is received through an ingress port looks up the matching flow entry or entries in the ingress ACL table and determines an action to perform on the received packet. As described above a logical switch may perform further logical lookups using other forwarding tables that are storing flow entries.

In the first stage none of the logical ports of the logical switch is enabled for port security. However the ingress ACL table in some embodiments specifies that packets coming through port must have a MAC address that matches a default MAC address which in this example is B. 

In this example the logical switch receives packets from VM through port . Each of packets includes in the packet header a source MAC address and a source IP address. Each of packets may include other information e.g. destination MAC and IP addresses etc. that the logical switch may use when performing logical lookups. For packet the source MAC address field of the header includes a value B to indicate that the MAC address of the sender of packet i.e. VM is B. Packet also includes in the source IP address field of the header the IP address of VM a value D to indicate that the IP address of VM is D. D represents an IP address in the proper IP address format e.g. an IPv4 or IPv6 format etc. . By putting D in packet as a source IP address VM indicates that the virtual machine s IP address is D. However VM may or may not have an IP address assigned to VM.

Packet includes in packet s header B and C as VM s MAC and IP addresses respectively. In addition packet includes an Address Resolution Protocol ARP response with A and C as VM s MAC and IP addresses respectively. A represents a MAC address in the proper MAC address format. VM is sending this ARP message in response to an ARP request that asks for information about a machine that has a certain IP address. As shown the MAC addresses in the header of packet and in the ARP response do not match. That is VM did not use the virtual machine s MAC address i.e. B in the ARP response. As shown in the stage the logical switch routes packets and from port to the packets respective egress ports because port security is not enabled and the packets and have source MAC addresses that match the default MAC.

Packet includes in packet s header A and C as VM s MAC and IP addresses respectively. The logical switch drops packet because source MAC address of packet does not match the default MAC address B .

In the second stage a user using the UI enables port of the logical switch for port security by checking the box in the UI in this example. The user also sets B and C as the MAC and IP addresses to which a packet that is coming in or going out through port is restricted. The ingress ACL table is modified according to the user input. As shown the ingress ACL table specifies that the packets coming into the logical switch must have B and C as the sender s i.e. VM s MAC and IP addresses respectively in the headers of the packets and in the ARP responses if any ARP responses are included in the packets. In other words VM cannot use a MAC address or an IP address that is not the addresses specified in the ACL table .

In the stage the logical switch receives packets from VM through port . Packets are similar to packets respectively that the logical switch received from VM in the stage . Packets have the same source MAC and IP addresses as packets respectively. The logical switch drops all three packets . The logical switch drops packet because packet s source IP address is D which is different than the IP address to which a packet that is coming in through port is restricted i.e. C . The logical switch drops packet because packet s ARP response has A as a MAC address which is different than the MAC address to which a packet that is coming in through port is restricted i.e. B . The logical switch drops packet even though the packet has source MAC and IP addresses in the header that match the addresses to which a packet that is coming in through port is restricted. The logical switch also drops packet because packet includes A as source MAC address in the header which is different than the MAC address B. 

The input translation application the control application and the virtualization application are similar to the input translation application the control application and the virtualization application described above in Section I respectively. In this example the input translation application runs in an input translation controller and the control application and the virtualization application run in a logical controller.

In the first stage the ports of the logical switch are not enabled for port security. As shown the UI displays whether the ports of the logical switch which is identified by an identifier LSW are enabled for port security. The unchecked boxes in the UI indicate that ports and of the logical switch are not enabled for port security. In some embodiments the UI allows the user to specify one or both of the MAC and IP addresses to which a particular port of the switching element is to be restricted. However in some such embodiments the particular port of the switching element is by default restricted to a default MAC and IP address pair.

The input table includes a list of all the logical ports of all the logical switches that the control application is managing. For each of the logical ports the input table indicates whether the port is port security enabled. The table also lists MAC addresses of these logical ports. In some embodiments the table lists default MAC addresses of the logical ports to which these ports are restricted by default. The table also lists IP addresses of the logical ports. The table is deemed unfiltered meaning this table includes all the logical ports of all the logical switches that different users manage. The input table lists default MAC addresses of all logical ports of all the logical switches that the control application is managing.

In the second stage the user provides input to indicate that user wishes to enable port of the logical switch for port security. As shown the user has checked a box next to port in the UI and entered B and C as the MAC and IP addresses respectively to which to restrict port . B is in the proper MAC address format and C is in the proper IP address format. The input translation application receives the user s inputs in the form of API calls. The input translation application translates the user s inputs into data that can be used by the control application and sends the translated inputs to the control application because the logical controller on which the control application runs is the master of the LDPS that the user is managing.

The third stage shows that the control application has updated input tables based on the inputs. Specifically the table is updated to indicate that the logical port is enabled for port security and is restricted to a MAC address B and an IP address C. Based on this update to the table the rules engine performs table mapping operations to filter the entries of the table to filter out entries for the logical ports of the logical switches that the users other than the user that provided the inputs manage. The table includes the filtered result and shows only those logical ports of the logical switch that the user is managing. This in turn causes the table to be updated. The table lists only those logical ports of the logical switch that are enabled for port security. The control application also updates the table to replace the default MAC address of the logical port with the MAC address that the user has specified.

The fourth stage shows a table which shows the result of table mapping operations that the rules engine performed based on the updates to the input tables . The table specifies logical actions to be performed on a packet coming into the logical switch through the logical port by the logical switch . The entry of the output table indicates that logical switch should accept the packet if the packet has correct logical context and has a source mac address and a source IP address that match the MAC and IP addresses to which the logical port is restricted. The entry indicates that logical switch should accept the packet if the packet has correct logical context and has an ARP response with a source mac address and a source IP address that match the MAC and IP addresses to which the logical port is restricted. The entry indicates that the logical switch should drop the packet that does not match the conditions specified in the entries and .

The fifth stage shows that the control application has sent the output table to the input tables of the virtualization application . Based on a function table not shown the rules engine performs table mapping operations to unpack the table . The table shows the unpacked logical actions of the table . The entry specifies that setting context to the next context i.e. moving to the next operation of the logical processing pipeline is the matching physical action of the logical accept action. The entry specifies that the managed switching element should drop the packet when the logical switch s action is dropping the packet.

Once unpacking is done the rules engine performs table mapping actions to pack the unpacked table. In some embodiments packing an unpacked table means gathering all physical actions that match the logical actions in an entry of a table that was originally unpacked. The sixth stage shows that the table that results from packing has an expressions column that is identical to the expressions column of the table . Each entry of the table includes a set of physical actions that matches the set of logical actions specified for the corresponding entry in the table . Thus the table specifies all physical actions to be performed on a packet coming into the managed switching element through the port to which the logical port is mapped. The rules engine performs table mapping operations to generate universal flow tables.

The seventh stage shows a table which is the result of performing the table mapping operations at the previous stage . The virtualization application will send this table to a physical controller not shown that manages the managed switching elements that implement the logical switch . The physical controller will then pass this table to each chassis controller not shown that manages one of those managed switching elements in some embodiments. The chassis controller will customize these universal flows. However in some embodiments the flows that are customized from the universal flows for enabling port security will be identical to the universal flows.

In computer networking a network control plane computes the state for packet forwarding forwarding state . The forwarding state is stored in the forwarding information base FIB of a switching element such as a router a physical switch a virtual switch etc. . The forwarding plane of the switching element uses the stored forwarding state to process the incoming packets at high speed and transmit the packets to a next hop of the network towards the ultimate destination of the packet. The realization of the forwarding state computation can be either distributed or centralized in nature. When a distributed routing model is used to compute the state the switching elements compute the state collectively. In contrast when a centralized computational model is used to compute the state a single controller is responsible for computing the state for a set of switching elements. These two models have different costs and benefits.

When the network control plane e.g. a control application receives an event requiring updates to the forwarding state the network control plane initiates the re computation of the state. When the state is re computed the network control plane which may be implemented by one controller or several controllers pushes the updated forwarding state to the forwarding plane of the switching element s . The time it takes to compute and update the state is referred to as network convergence time. 

Regardless of the way the computation is performed the forwarding state in the forwarding plane has to be correct in order to guarantee that the packets reach the intended destinations. Any transient inconsistency of the forwarding state during the network convergence time may cause one or more switching elements to fail to forward the packets towards the intended destinations and may thus result in packet loss. The longer it takes to compute disseminate and apply any forwarding state updates to the switching elements that use the forwarding state the longer the window for inconsistencies will become. As the window for inconsistencies becomes longer the end to end packet communication service for the users of the network will degrade accordingly.

For this reason some embodiments of the invention carefully account for updates to the forwarding state. A network event may require immediate actions by the control plane. For instance when a link carrier goes down the control plane has to re compute the forwarding state to find an alternative link or route towards the destinations of the packets. During the time period after the network event occurs and before the network has converged to the new updated forwarding state the network users will experience a partial or total loss of connectivity.

To address the loss of connectivity issue some embodiments use proactive preparation processes which have the network control plane pre compute alternative or backup forwarding states for the forwarding plane based on the conditions under which the control plane operates. With the alternative forwarding states for the forwarding plane the switching elements using the forwarding plane may correctly forward the packets while the control plane is updating the forwarding state for a network event. For instance in the case of a link going down the forwarding plane could be prepared in advance with the alternative backup path s for re directing the packets. While proactive preparations may introduce significant computation load for the control plane proactive preparations can remove the requirement of instantaneous reaction to avoid the forwarding plane failures.

Even with proactive preparations the network control plane still needs to address several other issues in applying the forwarding state updates to the forwarding plane. These issues are addressed below. However before addressing these issues the network control system of some embodiments should be first described. Some embodiments of the invention provide a novel network control system that is formed by one or more controller instances for managing several managed switching elements.

Traditionally the switching elements offer no transactional updates for updating the forwarding state in the FIB. Even when a centralized computation model is used the need to distribute the transactions might result in undue complexity because of the distributed chassis architecture of the switching elements or the physical separation of the computational and forwarding switching elements.

Without resorting to distributing transactions that are undesirable the network control system carefully schedules pushing the forwarding state updates to the managed switching elements because the overall forwarding state for the forwarding plane in the managed switching elements may still remain inconsistent after a single update is pushed to the forwarding plane. Thus the network control system pushes all the related updates together to minimize the window of inconsistency and the overall experienced end user downtime in her networking services.

The network control system in some embodiments utilizes the isolation of the virtualization. That is since the network forwarding states of individual LDP sets remain isolated from each other as do those of individual logical networks the network control system computes any updates on different LDP sets independently. Hence the network control system can dedicate all the available resources to a single LDPS or a few LDP sets and the datapath s state re computation and thereby finishes the state computation for all the related forwarding states faster.

Localizing the computation still offers benefits even when the computation of the forwarding state updates takes long enough to warrant aggregating updates to the forwarding plane in order to minimize the experienced downtime in packet forwarding. For instance there will be less data to buffer and aggregate in total as the updates are produced only for one LDPS or a few LDP sets at a time.

In this manner the network control system effectively delays reacting to network events for some of the LDP sets affected by the network events. However when the network control system reacts to a particular event the network control system can complete the computation of all the resulting state updates as quickly as possible by focusing on a particular LDPS affected by the particular event. Described at a high level the network control system has to factor the network virtualization when scheduling the computation of the forwarding state updates.

In a network control system of some embodiments a single controller instance can be responsible for computing state updates for several LDP sets. As with any network control plane the controller instance may have to re compute and update the forwarding state for all the affected LDP sets when the controller instance receives an event from the user of the controller or from the network. As discussed above a simple way of updating the forwarding state would be computing updates for all affected LDP sets in parallel.

To minimize the per LDPS convergence time some embodiments localize the computation in time. To accomplish this the controller instance of some embodiments has a scheduler that takes a unit of virtualization e.g. a LDPS in consideration in two ways. First on an occurrence of a network event the controller instance classifies the event to determine the LDPS that the event affects. Second as the computation for the event begins the scheduler does not preempt the computation until the computation for the event completes i.e. until the LDPS state converges .

In this manner the controller instance achieves faster convergence times for the given computation context. In addition as with schedulers in general the scheduler of the controller can implement various scheduling policies to better match certain high level requirements. One such policy is giving a preference to a computation that affects physical only forwarding state because a physical only forwarding state may affect multiple LDP sets and thus may be more important than the state of any single LDPS. Another such policy is prioritizing a given LDPS over another LDPS in order to process a network event that affects a LDPS with a higher priority first. The prioritization of the LDP sets may reflect the tiered pricing structure of the provided network services in multi user environments.

The considerations of the scheduling extend beyond a single controller instance when solutions that split the computation of the forwarding state over multiple controller instances for improved scaling are applied. For instance a controller instance may prepare the state in the first stage while in the second stage other controller instances consume the results of the first stage. That is each of the controller instances computes for a slice of the overall final forwarding state.

Similarly the computation of the forwarding state may span over a controller instance and several switching elements when the switching elements perform computation of the forwarding state prepared by the controller instance. For instance spanning the computation of the forwarding state may be necessary when the forwarding state is expressed in universal physical control plane data.

In the case of a controller instance failing the forwarding state computation may take longer than the time it would have taken without the failure. Therefore any switching element or controller instances consuming the state updates from a previous stage should not use the state updates until the initial re computation has converged or completed. To prevent the use of the state updates until the convergence of the initial re computation the scheduler of the state computing controller instance informs through an out of band communication channel any consumers of the state updates about the convergence for a given LDPS. By delaying the consumption and computation of the subsequent state until the computation of the state from the earlier stage is completed the controller instances involved in the computation of the states minimize the possible downtime for the network services.

When no controller instance fails the state re computing controller instance computes state updates for one virtualization unit e.g. a LDPS at a time and feeds the state updates to any switching element or controller that consumes the state updates. While the volume of the state updates for any given LDPS may be relatively modest when there is no controller instance failure multiple controller instances at one stage of the computation and multiple consumers of a next stage of the computation share a communication channel. For instance multiple computational processes for multiple LDP sets might operate concurrently in order to exploit all the processing power of the modern multi core CPUs.

When computations for multiple LDP sets are being performed the reach of the scheduling has to extend into the communication channel itself. Specifically when computations for multiple LDP sets are not being performed the channel sharing could introduce convergence delays as the transmission of the state updates for a single LDPS could be effectively preempted. This may result in an extended downtime of the network services. To address this problem the scheduler factors the delays in the scheduling policy. That is such a policy will not start the transmission of queued updates for a single LDPS until the computation for the LDPS has converged. Alternatively a policy will start the transmission of the updates but not preempt before the convergence occurs.

The above described techniques for temporally localizing the computation of forwarding state updates avoid an explicit heavyweight synchronization mechanism between the computation processes of multiple LDP sets across network elements.

The controllers of a network control system of some embodiments use schedulers and or channel optimizers to minimize the network convergence time. A scheduler of a controller instance in some embodiments schedules updates to the input tables in such a manner that the nLog table mapping engine can process updates related to a LDPS together. A channel optimizer of some embodiments optimizes the use of the channels established between controller instances when sending updates between controller instances.

As described above the dispatcher sends the requests generated by the request generator to one or more controller instances. The dispatcher uses a communication channel established with a particular controller instance by the inter instance communication interface to send the requests for the particular controller. In some embodiments the dispatcher sends the requests as the requests arrive from the request generator . In some of these embodiments each request is sent as an RPC remote procedure call over the channel. Therefore the dispatcher would have to make as many RPCs as the number of the requests.

In some embodiments the channel optimizer minimizes the number of RPCs by batching up the requests to be sent over an RPC channel. Different embodiments use different criteria to batch up the requests. For instance the channel optimizer of some embodiments makes an RPC only after a certain number e.g. of requests are batched for a communication channel. Alternatively or conjunctively the channel optimizer of some embodiments batches up requests that arrived for a certain period of time e.g. milliseconds .

As described above the importer interfaces with a number of different sources of input event data and uses the input event data to modify or create the input tables . In some embodiments the importer does not modify or create the input tables directly. Instead the importer sends the input data to the event classifier .

The event classifier receives input event data and classifies the input event data. The event classifier of some embodiments classifies the received input event data according to the LDPS that the input event data affects. The input event data affects a LDPS when the input event data is about a change in a logical switch for the LDPS or about a change at one or more managed switching elements that implement the LDPS. For instance when the LDPS specifies a tunnel established between two network elements the input event data that affects the LDPS are from any of the managed switching elements that implement the tunnel. Also when the user specifies input event data to define or modify a logical switch defined by LDPS data this input event data affects the LDPS. In some embodiments the event classifier adds a tag to the input event data to identify the LDPS that the input event data affects. The event classifier notifies the scheduler of the received input event data and the classification e.g. the tag identifying the LDPS of the input event data.

The scheduler receives the input event data and the classification from the event classifier . In some embodiments the scheduler communicates with the rules engine to find out whether the rules engine is currently processing the input tables i.e. whether the rules engine is performing join operations on the input tables to generate the output tables . When the rules engine is currently processing the input tables the scheduler identifies the LDPS of those input tables that are being processed by the rules engine . The scheduler then determines whether the received input event data affects the identified LDPS. When the scheduler determines that the received input event data affects the identified LDPS the scheduler modifies one or more input tables based on the received input event data. When the scheduler determines that the received input event data does not affect the identified LDPS the scheduler holds the received input event data. In this manner the scheduler allows the rules engine to process all the input event data affecting the same LDPS together while the LDPS is being modified or created.

When the rules engine is not currently processing the input tables the scheduler modifies one or more input tables based on the oldest input event data that has been held. The scheduler will be further described below by reference to .

As described above the exporter sends the output event data in the output tables to one or more controller instances e.g. when the virtualization application is running in another controller instance . The exporter uses a communication channel established with a particular controller instance by an inter instance communication interface not shown to send the output event data for sending to the particular controller. In some embodiments the exporter sends the output event data as the exporter detects the output event data in the output tables . In some of these embodiments each output event data is sent as an RPC remote procedure call over the channel. Therefore the dispatcher would have to make as many RPCs as the number of the output events.

In some embodiments the channel optimizer minimizes the number of RPCs by batching up the requests to be sent over an RPC channel. Different embodiments use different criteria to batch up the requests. For instance the channel optimizer of some embodiments makes an RPC only after a certain number e.g. 32 of requests are batched for a communication channel. Alternatively or conjunctively the channel optimizer of some embodiments batches up requests that arrived for a certain period of time e.g. milliseconds .

As described above the importer interfaces with a number of different sources of input event data and uses the input event data to modify or create the input tables . In some embodiments the importer does not modify or create the input tables directly. Instead the importer sends the input data to the event classifier .

The event classifier receives input event data and classifies the input event data. The event classifier of some embodiments classifies the received input event data according to the LDPS that the input event data affects. The input event data affects a LDPS when the input event data is about a change in a logical switch for the LDPS or about a change at one or more managed switching elements that implement the LDPS. For instance when the LDPS specifies a tunnel established between two network elements the input event data that affects the LDPS are from any of the managed switching elements that implement the tunnel. Also when the user specifies input event data to define or modify a logical switch defined by LDPS data this input event data affects the LDPS. In some embodiments the event classifier adds a tag to the input event data to identify the LDPS that the input event data affects. The event classifier notifies the scheduler of the received input event data and the classification e.g. the tag identifying the LDPS of the input event data.

The scheduler receives the input event data and the classification from the event classifier . In some embodiments the scheduler communicates with the rules engine to find out whether the rules engine is currently processing the input tables i.e. whether the rules engine is performing join operations on the input tables to generate the output tables . When the rules engine is currently processing the input tables the scheduler identifies the LDPS of those input tables that are being processed by the rules engine . The scheduler then determines whether the received input event data affects the identified LDPS. When the scheduler determines that the received input event data affects the identified LDPS the scheduler modifies one or more input tables based on the received input event data. When the scheduler determines that the received input event data does not affect the identified LDPS the scheduler holds the received input event data. In this manner the scheduler allows the rules engine to process all the input event data affecting the same LDPS together while the LDPS is being modified or created.

When the rules engine is not currently processing the input tables the scheduler modifies one or more input tables based on the oldest input event data that has been held. The scheduler will be further described below by reference to .

As described above the exporter sends the output event data in the output tables to one or more controller instances e.g. a chassis controller . The exporter uses a communication channel established with a particular controller instance by an inter instance communication interface not shown to send the output event data for sending to the particular controller. In some embodiments the exporter sends the output event data as the exporter detects the output event data in the output tables . In some of these embodiments each output event data is sent as an RPC remote procedure call over the channel. Therefore the dispatcher would have to make as many RPCs as the number of the output events.

In some embodiments the channel optimizer minimizes the number of RPCs by batching up the requests to be sent over an RPC channel. Different embodiments use different criteria to batch up the requests. For instance the channel optimizer of some embodiments makes an RPC only after a certain number e.g. of requests are batched for a communication channel. Alternatively or conjunctively the channel optimizer of some embodiments batches up requests that arrived for a certain period of time e.g. milliseconds .

The buckets is conceptual groupings of input event data coming from the classifier . In some embodiments a bucket is associated with a LDPS. Whenever the scheduler receives input event data the grouper places the input event data into a bucket that is associated with a LDPS that the input event data affects. When there is no bucket to place the input event data the grouper in some embodiments creates a bucket and associates the bucket with the LDPS that the input event data affects.

The bucket selector selects a bucket and designates the selected bucket as the bucket from which the bucket processor retrieves events. In some embodiments the bucket selector selects a bucket that is associated with the LDPS that is currently being processed a rules engine not shown in this figure . That is the bucket selector selects a bucket that contains the input data that affects the LDPS that is being processed by the rules engine.

The bucket processor in some embodiments removes input event data for one input event from the bucket selected by the bucket selector . The bucket processor updates one or more input tables using the input event data retrieved from the bucket so that the rules engine can perform table mapping operations on the updated input tables to modify the LDPS.

When the retrieved input event data is the only remaining event data in the selected bucket the bucket selector in some embodiments destroys the bucket or leaves the bucket empty. When the bucket is destroyed the grouper re creates the bucket when an event data that is received at a later point in time affects the same LDPS that was associated with the destroyed bucket. When input event data for an input event comes in and there is no bucket or all buckets are empty the grouper places the input event data in a bucket so that the bucket processor immediately retrieves the input event data and starts updating one or more input tables .

The bucket from which input event data was removed most recently is the current bucket for the scheduler . In some embodiments the bucket selector does not select another bucket until the current bucket becomes empty. When input event data for an input event comes in while a LDPS is currently being updated the grouper places the input event data into the current bucket if the input event data affects the LDPS being modified. If the input event data does not affect the LDPS that is currently being modified but rather affects another LDPS the grouper places the input event data into another bucket the grouper creates this bucket if the bucket does not exist that is associated with the other LDPS. In this manner the bucket processor uses input event data for as many input events affecting one LDPS as possible.

When the current bucket is destroyed or becomes empty the bucket selector designates the oldest bucket as the current bucket. Then the bucket processor starts using the input event data from the new current bucket to update the input tables . In some embodiments the oldest bucket is a bucket that includes the oldest input event data.

Several exemplary operations of the scheduler are now described by reference to . illustrate in three different stages and that the scheduler s processing of the input event data for an input event. Specifically these figures show that the scheduler processes input event data for an event right away without waiting for more input event data when the scheduler has no other input event data to process. These figures also illustrate the classifier and the input tables .

At stage the classifier sends to the scheduler the input event data that the classifier has classified. All the buckets including buckets and are empty or deemed non existent because the bucket processor has just used the last input event data not shown from the last non empty bucket to update the input tables or because the input event data is the first input event data brought into the scheduler after the scheduler starts to run.

At stage the grouper places the input event data in the bucket because the bucket is associated with a LDPS that the input event data affects. The bucket selector selects the bucket so that the bucket processor can take event input event data from the bucket . At stage the bucket processor retrieves the input event data and uses the input event data to update one or more input tables .

At stage the buckets include three buckets and . In the bucket the grouper previously placed the input event data . The other two buckets and are empty. The buckets are associated with three different LDP sets. The classifier sends the input event data that the classifier has classified to the grouper . The input event data affects the LDPS that is associated with the bucket . The bucket is the bucket that the bucket selector has designated as the current bucket. That is the bucket processor is retrieving input event data from bucket .

At stage the grouper places the input event data in the bucket . The bucket selector does not change designation of the current bucket from the bucket . The bucket processor takes out the input event data from the bucket and updates the input tables using the input event data .

At stage the classifier has not classified another input event data because the classifier has not received another input event data for an input event. The bucket selector selects the bucket and designates the bucket as the new current bucket because the previous current bucket has become empty after the input event data was taken out from the bucket . The bucket processor takes out the input event data from the new current bucket and updates the input tables using the input event data .

In addition to a scheduling scheme based on LDP sets that has been described so far different embodiments employ other different scheduling schemes to determine the order in which the input event data triggers the table mapping process. The different scheduling schemes include i a priority based scheduling scheme ii scheduling based on critical input event data and non critical input event data and iii scheduling based on start and end tags also referred to as barriers in some embodiments that may be associated with input event data. These different scheduling schemes may be used alone or in combination. One of ordinary skill in the art will recognize that other scheduling schemes may be employed in order to determine the order in which the input event data is used to update input tables.

In the priority based scheme the event classifier assigns a priority level to the input event data. In some embodiments the event classifier attaches a tag to the input event data to indicate the priority level for the input event data. Usually the event classifier assigns the same priority level to different input event data when the different input event data affects the same LDPS. Therefore a bucket includes different input event data with the same priority level and this priority level is the priority level for the bucket.

In some embodiments the bucket selector designates a bucket with the highest priority level as the current bucket. That is when input event data for an input event which the grouper places in a particular bucket other than the current bucket has a priority level that is higher than the priority level of the current bucket the particular bucket becomes the new current bucket even if the old current bucket had not become empty. Thus from that instance in time the bucket processor uses the input event data from the new current bucket to update the input tables . In this manner the input event data with a higher priority level gets ahead of the input event data with a lower priority level. When the input event data that the scheduler receives from the event classifier and the current bucket have the same priority level the bucket selector does not change the designation of the current bucket.

An example operation of the scheduler employing the priority based scheduling scheme will now be described by reference to . illustrate that the scheduler processes input event data and for two different input events in three different stages . These figures also illustrate the classifier and the input tables .

At stage the buckets includes three buckets and . In the bucket the grouper previously placed the input event data . The input event data has a priority level that the classifier assigned to the input event data . The other two buckets and are empty. The buckets are associated with three different LDP sets. The classifier sends the input event data that the classifier has assigned a priority level that is higher than the priority level of the input event data . The input event data also affects the LDPS that is associated with the bucket . The bucket is designated as the current bucket from which the bucket processor is retrieving input event data to update one or more input tables .

At stage the grouper places the input event data in the bucket because the input event data affects the same LDPS with which the bucket is associated. The rules engine not shown is still performing table mapping operations on the input tables which were previously updated by the bucket processor using the input event data not shown . Thus the input event data has not been taken out of the current bucket yet.

At stage the bucket selector designates the bucket as the new current bucket even though the previous current bucket has not become empty because the input event data has a priority level that is higher than the priority level of the input event data that is in the bucket . The bucket processor then uses the input event data ahead of the input event data to update the input tables .

In the scheduling scheme that is based on critical and non critical input event data the event classifier and the scheduler of some embodiments operate based on critical input event data and non critical input event data. Critical input event data is input event data for a critical input event that should immediately update one or more managed switching elements for proper functioning of the network elements. For instance a chassis e.g. a host machine disconnection or connection is a critical event. This is because a chassis may be hosting several managed switching elements. Thus the disconnection or connection of the chassis means deletion or addition of new managed switching elements for which other managed switching elements have to adjust to properly forward data packets. Another example of a critical input event is an event related to creation of the receiving end of a tunnel. The receiving end of a tunnel is critical because when the receiving end of a tunnel is not created the packets going towards the receiving end will be dropped.

A non critical input event data is input event data for a non critical event that is not as important or critical to the proper functioning of the network elements. For instance events related to testing a newly added node to see whether the node gets all the required logical flows before other nodes start sending packets to this node else the node may drop packets are non critical events. Another example of a non critical input data is an event related to creation of the sending end of a tunnel.

The event classifier in some embodiments classifies input event data based on whether the input event data is for a critical event or a non critical event or neither of the two kinds of event. That is the event classifier in some embodiments attaches a tag to the input event data to indicate that the input event data is a critical input event data or a non critical input event data. In some embodiments the event classifier attaches no such tag to input event data that is neither a critical input event data nor a non critical input event data. Such input data may be attached with a tag for the priority level and or a tag for a LDPS so that the scheduler can handle this input event data with other scheduling schemes described above.

The scheduler in some embodiments immediately uses a critical input event data to modify one or more input tables when the scheduler receives the critical input event data. That is the critical input event data gets ahead of any other input event data. On the other hand the scheduler uses a non critical input event data only when no other input event data held by the scheduler is critical input event data or input event data that is neither critical input event data nor non critical input event data. A non critical input event data is therefore the last input event data of a set of input event data used by the scheduler .

In the scheduling scheme based on start and end tags input event data that the event classifier receives and classifies may have a start tag or an end tag attached to the input event data. In some embodiments the start tag indicates that the input event data to which the start tag is attached is the first input event data of a group of input event data. The end tag indicates that the input event data to which the end tag is attached is the last input event data of the group of input event data. In some cases a group of input event data is for different input events. In other cases a group of input event data may be for a single input event.

In some embodiments start tags and end tags are attached to input event data by the origin of the input event. The start tags and end tags are used to indicate that a group of input event data should be processed together and to indicate that a segment of a control data pipeline is completed so that the next segment of the control data pipeline can be performed in a distributed multi instance control system of some embodiments. For example a controller application attaches the start tags and the end tags to the logical forwarding plane data that the controller application sends to a virtualization application. As another example a virtualization application of one controller instance attaches these tags when the virtualization application is sending universal physical control plane data for a group of input events to another virtualization application of another controller instance so that the other virtualization application can recognize the end of universal physical control plane data and convert the universal physical control plane data to customized physical control plane data. Furthermore in some embodiments an origin of a group of input event data does not send out the group unless the origin has generated the whole group of input event data.

In some embodiments that use start and end tags the bucket selector does not designate a particular bucket that contains input event data with a start tag as the current bucket until the grouper places another input event data with an end tag in the particular bucket. In other words the bucket processor does not process a group of input event data until the whole group of input event data is received. In some embodiments the bucket selector does not designate the particular bucket even if the bucket has the highest priority level among other buckets that each contain input event data.

An example operation of the scheduler that uses start and end tags will now be described. At stage the buckets includes three buckets and that each is associated with a different LDPS. In the bucket the grouper previously placed the input event data . The input event data has a priority level that the classifier assigned to the input event data . The bucket has two input event data and . The input event data and in the bucket have an assigned priority level that is lower than the priority level assigned to input event data in the bucket . The input event data is illustrated as bold parallelogram to indicate that the input event data has a start tag. That is the input event data is the first input event data of a group of input event data. Also in the stage the classifier has classified the input event data and sends the input event data to the scheduler . The input event data has an assigned priority level that is lower than the priority level assigned to input event data and .

At stage the bucket processor retrieves the input event data from the bucket and updates the input tables because the bucket is the current bucket. The grouper places the input event data in the bucket because the event data affects the LDPS with which the bucket is associated. The bucket selector needs to designate a new current bucket because the old current bucket is now empty. The bucket selector designates the bucket as the new current bucket even though the priority level of the input event in the bucket is lower than the priority level of the input event data and in the bucket . This is because input event data that has an end tag for the group of input event data that includes the input event data and has not arrived at the bucket of the scheduler .

At stage the bucket processor retrieves the input event data from the bucket and updates the input tables because the bucket is the current bucket. At stage the classifier has classified the input event data and sends the input event data to the scheduler . The input event data illustrated as a bold parallelogram has an end tag to indicate that the input event data is the last input event data of the group of input event data that include the input event data and . The bucket selector does not designate the bucket as the current bucket even though the bucket is the only non empty bucket of the buckets because the input event data and do not make up a complete group of input event data.

At stage the grouper places the input event data in the bucket because the input event data affects the LDPS with which the bucket is associated. The bucket selector designates the bucket as the new current bucket because the bucket now has a complete group of input event data that consist of the input event data and . At stage the bucket processor retrieves the input event data because the input event data is the oldest input event data in the current bucket. The bucket processor uses the input event data to update the input tables .

It is to be noted that the six different stages in as well as any group of stages in other figures of this application do not necessarily represent regular intervals of time. That is for example the length of time elapsed between a pair of consecutive stages is not necessarily the same as the length of time elapsed between another pair of consecutive stages.

At the process classifies the received event data. In some embodiments the process classifies the received event data based on a LDPS that the received event data affects. As mentioned above input event data affects a LDPS when the input event data is about a change in the logical switch specified by the LDPS or about a change at one or more managed switching elements that implement the LDPS. Also input event data affects a LDPS when the input event data is for defining or modifying the LDPS. In addition the process in some embodiments assigns a priority level to the received event data.

Next the process determines at whether a LDPS is being updated. In some embodiments the process inspects the rules engine to find out whether a LDPS is being updated by the rules engine. When the process determines at that a LDPS is not being updated i.e. when the process determines that the rules engine is not currently processing any input tables the process identifies at the oldest input event data. When there is no other input event data held the process identifies the received input event data as the oldest input event data.

The process then determines whether the identified oldest input event data belongs to a group of input event data i.e. whether the identified oldest input event data is in a batch of input event data that should be processed together to improve efficiency . The process in some embodiments determines that the identified oldest input event data belongs to a group of input event data when the identified oldest input event data has a start tag or a barrier . The process determines that the identified oldest input event data does not belong to a group of input event data when the identified oldest input event data does not have a start tag. When the process determines that the identified oldest input event data does not belong to a group of input event data the process proceeds to to update the input tables with the identified oldest input event data.

When the process determines that the identified oldest input event data belongs to a group of event data the process determines whether the group of input event data to which the identified oldest input event data belongs is a complete group. In some embodiments the process determines at that the group is complete when there is a particular input event data that affects the same LDPS that the identified oldest input event data affects and that particular input event data has an end tag.

When the process determines at that the group of input event data to which the identified oldest input event data belongs is a complete group the process updates at the input tables with the identified oldest input event data. The process then ends. When the process determines at that the group of input event data to which the identified oldest input event data belongs is not a complete group the process proceeds to to determine whether there is another input event data that affects a LDPS different than the LDPS that the identified oldest input event data affects.

When the process determines at that there is no such other input event data the process loops back to to receive another input event data. When the process determines at determines at that there is such an input event data the process loops back to to identify the oldest input event data among other input event data that do not affect the LDPS s that any of the previously identified oldest input event data affects.

When the process determines at that a LDPS is currently being updated the process determines at whether the received input event data affects the LDPS that is being updated. In some embodiments the input event data includes an identifier for a LDPS that the input event data affects. The process uses this identifier to determine whether the input event data affects the LDPS that is being updated.

When the process determines at that the received input event data affects the LDPS that is being updated the process proceeds to which will be described further below. When the process determines at that the received input event data does not affect the LDPS that is being updated the process in some embodiments determines at whether the received input event data has a priority level that is higher than the priority level that was assigned to input event data that is being used to update the LDPS.

When the process determines at that the priority level of the received input event data is higher the processor proceeds to which will be described further below. Otherwise the process holds at the received input event data. That is the process does not update the input tables based on the received input event data. As mentioned above the process later uses the input event data that is held when the rules engine of the control application is done with updating the LDPS that is currently being updated.

At the process determines whether the received input event data belongs to a group of input event data. In some embodiments the process determines that the received input event data belongs to a group of input event data when the received input event data has a start tag or an end tag. When the process determines at that the received input event data does not belong to a group of input event data the process proceeds to which will be described further below. Otherwise the process proceeds to to determine whether the group to which the received input event data belongs is a complete group. The process in some embodiments determines that the group is complete when the received input event data has an end tag.

When the process determines at that the group of input event data to which the received input event data belongs is a complete group the process proceeds to . When the process determines at that the group of input event data to which the received input event data belongs is not a complete group the process proceeds to to hold the received input event data.

After the process holds at the received input event data the process goes to to determine whether there is another input event data held that is held and affects a LDPS different than the LDPS being updated. When the process determines at that there is no such input event data the process loops back to to receive another input event data. When the process determines at that three is such input event data the process proceeds to to identify the oldest input event data among other input event data that do not affect the LDPS being updated.

At the process updates the input tables with the received input event data. When the received input event data has an end tag the process in some embodiments uses the group of input event data to which the received input event data with an end tag belongs in order to update input tables.

By updating the input tables based on the input event data only when the input event data affects the LDPS that is being updated and by holding the input event data otherwise the process effectively aggregates the input event data based on the LDPS. That is the process aggregates all input event data for a LDPS that the process receives while the LDPS is being updated so that all the input event data for the LDPS are processed together by the rules engine of the control application.

Within networks it is the network forwarding state that carries packets from their network entry points to their exits. Hop by hop the state makes the network elements forward a packet to an element that is a step closer to the destination. Clearly computing forwarding state that is in compliance with the configured network policies is crucial for the operation of the network without the proper forwarding state the network will not deliver packets to their destinations nor will the forwarding be done according to the configured policies.

There are several challenges to updating the forwarding state i.e. migrating from a previously computed state to a newly computed state after the network configuration has changed. Several solutions are described below. These solutions consider the problem in two dimensions correctness and efficiency. That is these solutions consider how the state that is currently present in the network can guarantee that the network policies are obeyed correctly not only before and after the update but also during the update. In terms of efficiency these solutions consider how the cost of potentially large state updates can be minimized.

In the discussion below the network control system includes a centralized cluster of controllers that compute the forwarding state for the forwarding elements in order to manage the network forwarding elements. Also in the discussion below network policy includes any configurational aspects not only security policies but also policies regarding how to route the network traffic as well as any physical or logical network configuration. Hence in this discussion policy is used for anything that relates to user configured input.

A packet is what the forwarding state operates over. Hence in the end the only thing that matters is that a single packet is forwarded according to a single consistent policy and not a mixture of states representing old and new policy. Subsequent packets may be treated by different versions of the policy as long as the transition from an old version to a new version occurs in a manner that prevents a packet from being treated by a mixture of old and new policies.

The requirement for an atomic transition to a new policy implies that the updates to the forwarding state have to be transactional. However as discussed above it does not imply the whole network forwarding state should be atomically updated at the same time. In particular the network control system of some embodiments relaxes this requirement in two regards 

1. For a stream of packets from a source towards one or more destinations it is not critical to specify at which point the policy changes from an old one to new one. It is only essential that no packet get forwarded according to a mixture of policies. Each packet should either be forwarded according to the old policy or the new policy.

2. Similarly the network control system of some embodiments allows different policies to be transiently applied to different streams of packets that ingress into the network at different locations. Again these embodiments only require that a single packet experience only a single policy and not a mixture of the old and new policies.

Given these requirements and relaxations the implementation of these transactional updates will now be considered. In M. Reitblatt et al Updates for Software Defined Networks Change You Can Believe in In Cambridge Mass. November 2011 the Reitblatt article it has been proposed that packets be tagged at network ingress with a version of the forwarding state used at the ingress. Hence when the packet makes progress through the network any subsequent network element knows which version to use. This effectively realizes transactional network wide updates for any network forwarding state.

However this approach comes with a few practical challenges. First without assuming slicing of the network updates to the network have to be serialized the whole network has to be prepared for a particular version then the ingresses are updated to use the prepared version and only after that the preparations for the next version can begin.

Second the packet needs to have an explicit version tag and hence enough bits somewhere in the packet headers need to be allocated for the tag. If the network has a requirement to operate with legacy tunneling protocols it might be challenging to find such free bits for the tag in the headers.

Hence the network wide transactional updates as described in the Reitblatt article while powerful come with practical challenges that ideally should be avoided. Thus instead of this approach described in the Reitblatt article the network control system of some embodiments exploits placement of the managed switching elements on the edge of the network. The network control system of some embodiments makes the logical forwarding decision that is a decision on which logical port s should receive the packet at the first hop as described in U.S. patent application Ser. No. 13 222 554 any subsequent steps are merely forwarding the packet based on this forwarding decision towards the selected destination.

This implies that the transactional updates across the network can be split into two parts 1 transactional updates to the first hop managed switching element and 2 transactional updates to the path through the network from the first hop managed switching element to the last hop managed switching element. As long as these two can be implemented the global transactions can be provided by preparing any new required paths before updating the first hop with the new policies the overall state update becomes atomic. After these two steps any network paths not required by the new first hop state configuration can be removed. The composition of transactions to construct larger transactions will be further described below as this principle has other uses in the network control system.

As mentioned above a logical controller is a master of a LDPS and a physical controller is a master of managed switching elements. A master of the LDPS of some embodiments computes state updates e.g. in universal control plane data for all managed switching elements that implement the LDPS. A master of managed switching elements of some embodiments receives the state updates from the masters of LDPS and distributes the updates to those managed switching elements that implement the LDPS. The managed switching elements that receive the state updates may be some or all of the managed switching elements that the master of the managed switching elements manages.

In this example the logical controller is a master of a LDPS which is implemented by the managed switching elements . The physical controllers and are the masters of the managed switching elements . At stage the logical controller receives updates from the user e.g. through an input translation controller which is not depicted in this figure for a LDPS that the user is managing. In this example the updates represent a new policy e.g. a new QoS policy defining new allowable bandwidth . The logical controller then computes the state updates e.g. by an nLog engine that generates universal control plane data from input logical control plane data . In some embodiments the logical controller identifies all the managed switching elements that implement the LDPS. In particular for a path of a packet that will be forwarded from a first physical port to a second physical port that are mapped to a logical ingress port and logical egress port respectively the logical controller identifies the managed switching element that has the first physical port i.e. the first hop managed switching element and the managed switching element that has the second physical port i.e. the last hop managed switching element . The logical controller then categorizes the first hop managed switching element in one group and the last hop managed switching element as well as other managed switching elements that are in the path of the packet in another group.

In this example the managed switching element is a first hop managed switching element identified by the logical controller and the managed switching element is the last hop manage switch. The managed switching element is one of the middle managed and unmanaged switching elements not shown that forwards the packet towards the last hop managed switching element . As shown the managed switching element the managed switching element and the middle switching elements have the old policy. Thus the packets coming to the first physical port that is mapped to the logical ingress port are forwarded by these managed switching elements based on the old policy.

At the second stage the logical controller using its nLog engine computes the state updates for the last hop managed switching element and the middle switching elements including the manage switching element and sends the computed updates to these switching elements in a transactional manner e.g. by putting in barriers in the stream of updates to the manage switching elements . In this example the physical controller manages these switching elements and distributes the updates to these switching elements. As a result these managed switching elements have both new and old policies while the first hop managed switching element has only the old policy. However because the first hop managed switching element operates under the old policy the packets coming to the first physical port that is mapped to the logical ingress port are forwarded by the managed switching elements based on the old policy.

At the third stage the logical controller using its nLog engine computes the state updates for the first hop managed switching element and sends the computed updates to the managed switching element in a transactional manner. In this example the physical controller manages the managed switching element and thus sends the updates from the logical controller to the managed switching element . The first hop managed switching element has the new policy and the old policy and so do the managed switching elements and . The packets coming to the first physical port that is mapped to the logical ingress port are forwarded by the managed switching elements based on the old policy or the new policy depending on the policy applied to the packets by the first hop managed switching elements. In other embodiments the logical controller may put a higher priority on the updates for the new policy to the first hop managed switching element so that the packets are forwarded by the new policy.

At the fourth stage the logical controller sends instructions to the managed switching elements that implement the LDPS to remove the data for the old policy. The managed switching elements then forwards the packets based on the new policy.

In some embodiments the physical controllers identify the first hop managed switching element and hold the updates to the first hop managed switching elements in order to send the updates to the middle switching elements and the last hop managed switching elements first. Therefore in these embodiments the logical controller will compute the updates to send to all of the managed switching elements that implement a LDPS and then let the physical controllers and send updates to the middle and last hop switching elements before sending updates to the first hop managed switching elements. Moreover in some embodiments only the edge switching elements are managed and the middle switching elements with an exception of pool nodes are unmanaged. In some such embodiments all logical forwarding decisions are made in the first hop switching elements and the middle switching elements are used merely as fabric for interconnecting switching elements.

Also it is to be noted that the steps shown in the four stages in are shown in terms of updates for one path defined in the LDPS. Because there may be many other paths in a logical switch defined by a LDPS the logical controllers and the physical controllers have to perform the two step process described in terms of the four stages for all possible paths for the LDPS. The next figure conceptually illustrates a process that some embodiments perform to send the updates to the managed switching elements for all paths defined by the LDPS. The process in some embodiments is performed by a logical controller that is the master of a LDPS.

The process begins by receiving at inputs from the user. In some embodiments the process receives the inputs from an input translation controller which translates the inputs in API calls into a format e.g. data tuples that an nLog engine can process. In some cases the inputs specify a policy update to the LDPS.

Next the process computes at the updates for the middle switching elements and the last hop managed switching elements for all possible paths of packets that are defined by the LDPS. As mentioned above any logical port can be an ingress port and or an egress port and therefore there could be many paths for packets between many possible pairs of logical ports. These logical ports are mapped to physical ports of the managed switching elements that implement the LDPS. Hence any of the managed switching elements that implement the LDPS could be a first hop for one path a last hop for another path and a middle switching element for yet another path. Therefore the process computes at only the updates for the managed switching elements to function as the middle switching elements or the last hop managed switching elements. The process sends at the computed at updates to all managed switching elements that implement the logical switch.

The process then computes at the updates for the managed switching elements to function as the first hop managed switching elements. The updates computed at are for all possible paths defined by the LDPS data. The process then sends at these updates to all managed switching elements that implement the LDPS.

Next the process then sends at instructions to remove data related to the old policy to all managed switching elements that implement the LDPS. The managed switching elements will remove the old policy data so that the managed switching elements forward the packets based on the new policy specified by the received updates. The process then ends.

In the approach described above there is no requirement for encoding the packets with versions of any kind. At most the number of required path configurations in the network may increase while any new paths not required by the old configuration are being prepared and before any old paths not required by the new configuration are not yet removed. Similarly updating the forwarding state does not have to be ordered globally. Only serializing the updates per first hop element is required. That is if multiple first hop elements require state updates their updates can proceed in parallel independently. Only the computation has to be transactional.

In some embodiments the network control system might use the approach described in the Reitblatt article for updating the network wide state in limited cases where the forwarding state in the middle of the network changes enough that the old and new paths would be mixed. For instance this could happen when the addressing scheme of the path labels change between software versions of input translation application control application virtualization application chassis control application etc. . For that kind of condition the system might want to dedicate a network wide version bit or a few bits from the beginning of the path label address so that the structure of the path addressing can be changed if necessary. Having said this one should note that as long as the label address structure does not change the network wide updates can be implemented as described above by adding new paths and then letting the first hop edge migrate to the new paths after the rest of the path is ready.

The discussion above considered the requirements that are to be placed on the transactionality in the system and the implementation of transaction updates across the network e.g. by separating the updates to the first hop processing from the updates to the non first hop processing . The network control system also has to compute the update to the network forwarding state e.g. universal physical control plane data .

Clearly before updating anything transactionally the network control system lets the UPCP computation converge given the policy changes. As described above the network control system of some embodiments uses an nLog table mapping engine to implement the network controllers of the system. The nLog engine in some embodiments lets the computation reach its fixedpoint that is the nLog engine computes all the changes to the forwarding state based on the input changes received so far.

At the high level reaching a local fixedpoint is simple it is sufficient to stop feeding any new updates to the computation engine i.e. the nLog engine and to wait until the engine has no more work to do. However in networking the definition of a fixedpoint is a bit wider in its interpretation while the computation may reach a fixedpoint it does not mean that the computation reached an outcome that can be pushed further down towards the managed switching elements. For example when changing the destination port of a tunnel the UPCP data may only have a placeholder for the physical port that the destination port maps to.

It turns out that the computation may depend on external changes that have to be applied before the computation can finish and reach a fixedpoint that corresponds to a forwarding state that can be used and pushed down. To continue with our example the placeholder for the port number in the flow entry may only be filled after setting up a tunnel port that will result in a port number. In this case the UPCP computation cannot be considered finished before the dependencies to any new external state e.g. port numbers due to the created tunnel are met.

Hence these external dependencies have to be considered in the computation and included into the consideration of the fixedpoint. That is a fixedpoint is not reached until the computation finishes locally and no external dependencies are still unmet. In some embodiments the nLog computation is built on adding and removing intermediate results every modification of the configuration or to the external state results in additions and removals to the computed state.

In order to consider the external dependencies in the UPCP computation the nLog computation engine should 

1 when a modification results in a state that should be added before the new UPCP data can be pushed down e.g. when a tunnel has to be created to complete a UPCP flow entry let the modification be applied immediately. The nLog computation engine has to consider fixedpoint unreachable until the results e.g. the new port number of the modification are returned to the nLog computation engine.

2 when a modification results in a state that would affect the current UPCP data e.g. removing an old tunnel though the update cannot be let through before the transaction is committed i.e. the new network forwarding state is implemented . It should be applied only after the transaction has been committed. Otherwise the network forwarding could change before the transaction is committed. Supporting atomic modification of an external resource cannot be done with the above rules in place. Fortunately most of the resource modifications can be modeled as additions removals for instance in the case of changing the configuration of a port representing a tunnel towards a particular destination the new configuration can be considered as a new port co existing transiently with the old port.

Hence at the high level the above approach builds on the ability to add a new configuration next to the old one. In the case of networking managed resources within the datapaths this is typically the case. In the case that constraints exist say for some reason two tunnels towards the same IP cannot exist the approach does not work and the atomicity of such changes cannot be provided.

The discussion above noted that it is sufficient to compute the updates in a transactional manner and then push them to the first hop edge switching elements. Hence in addition to the computation one more additional requirement is imposed to the system transactional communication channels.

Accordingly in some embodiments the communication channel towards the switching elements e.g. communication channels from input translation controllers to logical controllers from logical controllers to physical controllers from physical controllers to chassis controllers or managed switching elements and or from chassis controllers to managed switching elements supports batching changes to units that are applied completely or not at all. In some of these embodiments the communication channel only supports the concept of the barrier i.e. start and end tags which signals the receiver regarding the end of the transaction. A receiving controller or managed switching element merely queues the updates until it receives a barrier as described above. In addition the channel has to maintain the order of the updates that are sent over or at least guarantee that the updates that are sent before a barrier do not arrive at the receiver after the barrier.

In this manner the sending controller can simply keep sending updates to the state as the computation makes progress and once it determines that the fixedpoint has been reached it signals the receiving first hop switching elements about the end of the transaction. As further described below the communication channel in some embodiments also supports synchronous commits so that the sending controller knows when a transaction has been processed computed by reaching a fixedpoint and pushed further down if required . One should note that this synchronous commit may result in further synchronous commits internally at the lower layers of the network control system in the case of nested transactions as discussed below.

By separating the beginning of the network from the rest of the network when it comes to the forwarding state updates as described above by reference to the network control system of some embodiments effectively creates a nested transaction structure one global transaction can be considered to include two sub transactions one for first hop ports and one for non first hop ports. The approach remains the same irrespective of whether the solution manages the non first hop ports at the finest granularity by knowing every physical hop in the middle of the network and establishing the required state or assumes an external entity can establish the connectivity across the network in a transactional manner.

In some embodiments this generalizes to a principle that allows for creation of basic distributed transactions from a set of more fine grained transactions. In particular consider a network element that has multiple communication channels towards the element with each channel providing transactionality but no support for transactions across the channels. That is the channels have no support for distributed transactions. In such a situation the very same composition approach works here as well. None of the other channels state is used as long as one of the channels that can be considered as a primary channel gets its transaction applied. With this sort of construction the secondary channels can again be prepared before the primary channel commits the transaction just like the non first hop ports were prepared before the edge committed its transaction . In this manner the net result is a single global transaction that gets committed as the edge transaction gets committed.

The controller cluster in this example includes logical and physical controllers. The physical controllers establish the channels to the managed switching element . As the physical controllers establish the channels with the managed switching element the physical controllers designate one of the channels as a primary channel and the rest of the channels as secondary channels. Different embodiments make these designations differently. For instance some embodiments assign different priorities to different updates sent through different channels. More specifically the physical controller that would have the primary channel to the managed switching element may send the updates with highest priority while the other physical controllers that would have the secondary channels to the managed switching element send the updates with lower priorities. Then the physical controllers send the low priority updates to the managed switching element over the secondary channels first and then send the highest priority updates to the manage switching element over the primary channel. The managed switching element holds the updates with the lower priority until the higher priority updates arrive. The managed switching element then commits the updates i.e. use the updates to forward incoming packets and thereby achieves an atomic transaction.

In this example the controller cluster designates the channel as the primary channel and the channels as the secondary channels. At stage updates depicted as number 1 enclosed by a parallelogram are prepared and being sent to the managed switching element over the secondary channel . The next stage shows that updates are prepared and being sent to the managed switching element over another secondary channel . The stage also shows that the updates are stored without being committed by the managed switching element . In other words the managed switching element does not forward the packets it receives based on the updates .

The third stage shows that the updates are prepared and being sent to the managed switching element over the primary channel . The stage shows that the updates and are stored without being committed by the managed switching element . The fourth stage shows that the updates are committed by the managed switching element upon the arrival of the updates .

It is to be noted that the generalization allows for nesting the transactions to arbitrary depths if so needed. In particular a transactional system may internally construct its transactionality out of nested transactions. The ability to construct the transactionality out of nested transactions comes useful not only in the hierarchical structure that the controllers may form but also in considering how the switching elements may internally provide a transactional interface for the controllers managing the switching elements as discussed below.

Consider the managed switching elements. The network control system of some embodiments introduces transactionality to a communication channel without any explicit support for transactionality in the underlying managed resource again by using the same principle of nesting. Consider a software datapath with an easily extendable table pipeline. Even if the flow table updates did not support transactions it is easy to add a stage to the front of the existing pipeline and have a single flow entry decide which version of the state should be used. Hence by then updating a single flow entry which is transactional the whole flow table can be updated transactionally. The details of this approach do not have to be exposed to the controllers above however effectively there is now a hierarchy of transactions in place.

The first stage shows that the managed switching element performs the processing pipeline based on flow entries in the forwarding table . The flow entry depicted as an encircled number 1 specifies a version of flow entries that the managed switching element should be using. In this example flow entries have the same version specified by the flow entry .

Upon receiving the packet the managed switching element performs a version verifying operation of the processing pipeline based on the flow entry . The flow entry further specifies that the packet be further processed by the managed switching element e.g. by sending the packet to a dispatch port . The dispatch port of some embodiments allows the packet to enter the managed switching element again so that the managed switching element can further process the packet. The managed switching element further processes the packet based on the flow entries and then . The managed switching element allows the packet to re enter the managed switching element by sending the packet to the dispatch port after processing the packet based on a flow entry. The last flow entry to be processed on the packet specifies that the packet be sent to the next hop switching element or to the destination . Packet processing by a managed switching element based on flow entries is described in U.S. patent application Ser. No. 13 177 535.

The second stage shows that several new flow entries have been added to the forwarding table . In some embodiments the managed switching element adds these flow entries based on the inputs e.g. customized physical control plane data received from a controller cluster. In this example the flow entries have a version that is newer than the version of the flow entries and the flow entries specify the corresponding operations of the processing pipeline that the flow entries specify respectively. Upon receiving the packet the managed switching element at the stage still uses flow entries to process the packet .

The third stage shows that the managed switching element has replaced the flow entry with the flow entry which specifies that the managed switching element should use the flow entries with the newer version. Upon replacing the flow entries the managed switching element then would use flow entries because these entries are the newer version of flow entries. The flow entries are thereby updated to the newer version in a transactional manner. Upon receiving the packet the managed switching element performs the processing pipeline based on the flow entries . The fourth stage shows that the managed switching element removes the flow entries .

While a typical user driven change to the policy configuration causes a minor incremental change and this incremental change to the forwarding state can be computed efficiently failover conditions may cause larger input changes to the nLog computation engine. Consider a receiving controller which is configured to receive inputs from a source controller after the source controller crashes and a new controller subsumes the source controller s tasks. While the new controller was a backup controller and therefore had the state pre computed the receiving controller still has to do the failover from the old source to a new source.

In some embodiments the receiving controller would simply tear down all the input received from the crashed controller revert the effects of the inputs and then feed the new inputs from the new controller to the nLog computation engine even if it would be predictable that the old and new inputs would most likely be almost identical if not completely identical. While the transactionality of the computation would prevent any changes in the forwarding state from being exposed before the new source activates and computation reaches its fixedpoint the computational overhead could be massive the entire forwarding state would be computed twice first to remove the state and then to re establish the state.

In some embodiments the receiving controller identifies the changes in the inputs from the old and new source and would compute forwarding state changes only for the changed inputs. This would eliminate the overhead completely. However with transactional computation and with the ability to reach a fixedpoint the receiving controller of some embodiments can achieve the same result without identifying the difference. To achieve a gradual efficient migration from an input source to another without identifying the difference the network control system simply does not start by tearing down the inputs from the old source but instead feeds the inputs from the new source to the computation engine while the inputs from the old source are still being used. The network control system then waits for the fixedpoint for the inputs from the new source and only after that deletes the inputs from the old source.

By re ordering the external inputs events in this manner the nLog computation engine of some embodiments can detect the overlap and avoid the overhead of completely tearing down the old state. This therefore requires the nLog computation engine to be clever enough to optimize away the computation for duplicate states. Without needing to tear down the state from the old source the receiving controller does not commit the transaction until the fixedpoint from the new source arrives. Once the fixedpoint arrives the receiving controller pushes any changes to the forwarding state i.e. the output state due to the changed inputs to the consuming switching elements. If the changes are significant this approach comes with the cost of increased transient memory usage.

The physical controller in this example runs an integrated application described above by reference to . For simplicity of discussion not all components e.g. an event classifier a translator an importer an exporter etc. of the physical controller are shown in . The input tables and the rules engine are similar to the input tables and the rules engine described above. The scheduler is similar to the scheduler in . The scheduler also uses the updates repository to manage the input event data from other controllers including the logical controller . The updates repository is a storage structure for storing the input event data that the scheduler receives.

The first stage shows that the scheduler has stored input event data and depicted as numbers 1 and 2 enclosed by parallelograms . In this example the scheduler does not push the event data and to the input tables because the scheduler has not received a barrier that indicates a complete set of transactional inputs have arrived from the logical controller . In this example the input event data and are input event data generated and sent to the managed switching element after the last barrier which defines the end of a set of transactional inputs is generated but before the barrier is sent to the managed switching element .

The next stage shows that the logical controller has failed and the logical controller as the back up of the logical controller subsumed the role of the logical controller by sending the input event data and . As mentioned above the logical controller as a back up to the logical has identical input event data i.e. output data from the perspective of these logical controllers as the logical does.

The third stage shows that the back up logical controller has computed and is sending input event data which contains a barrier that indicates the end of a set of input event data. This stage also shows that the duplicates input event data and are stored in the updates repository and the scheduler has not sent these duplicates to the input tables because the barrier has not arrived yet.

The fourth stage shows that upon receiving the input event data with the barrier the scheduler has deleted deletion indicated by crossing out input event data and received from the failed logical controller . The scheduler would then update the input tables using the input event data so that the rules engine can detect the changes in the input tables and perform table mapping operations based on the changes.

Consider a hierarchical setting where there are two or more layers of computational elements e.g. logical controllers and physical controllers feeding updates to the switching elements that may be receiving transactional updates from multiple controllers. In this situation the topmost controllers compute their updates in a transactional manner but the controllers below them may receive updates from multiple topmost controllers similarly the switching elements may receive updates from multiple second level controllers.

The transactions may flow down without any changes in their boundaries that is a top level transaction processed at the second level controller results in a transaction fed down to the switching elements containing only the resulting changes of that incoming transaction from the topmost controller. However the consistency of the policies can be maintained even if the transactions are aggregated on their way down towards the switching elements. Nothing prevents the second level controller from aggregating multiple incoming transactions possibly from different topmost controllers into a single transaction that is fed down to the switching elements. It is a local decision to determine which is the proper level of aggregation if any . For instance the system may implement an approach where the transactions are not aggregated by default at all but in overload conditions when the number of transactions in the queues grows the transactions are aggregated in hope of transactions from the same source having overlapping changes that can cancel each other. In the wider network context one could consider this approach as one kind of route flap dampening.

The input tables and the rules engine are similar to the input tables and the rules engine described above. The scheduler is similar to the scheduler in . The scheduler also uses the updates repository to manage the input event data from other controllers including the logical controller . The updates repository is a storage structure for storing the input event data that the scheduler receives.

The scheduler of some embodiments monitors the input tables and or communicates with the rules engine to find out the amount of updates to the input tables that have not been processed by the rules engine . Based on the amount of updates that have not been processed the scheduler determines whether to combine sets of input event data into a single set of input event data to update the input tables . The scheduler of different embodiments determine when to combine sets of input event data differently. For instance the scheduler uses the number of sets of input event data that have not been processed by the rules engine where each set of input event data is defined by a barrier or start and end tags described above . When the number of sets of input event data is over a certain threshold value e.g. five the scheduler combines several sets of input event data in the updates repository into a single set of input event data with one barrier.

Alternatively or conjunctively the scheduler of some embodiments uses the data size of the input event data that have not been processed by the rules engine . In these embodiments the scheduler combines several set of input event data in the updates repository into a single set of input event before sending them to the input tables when the size of unprocessed input data in the input tables is over a threshold value e.g. several hundreds of bytes . One of the ordinary skills in the art would recognize that there may be other ways to determine when to combine sets of input data events into a single set.

The first stage shows that the scheduler has stored input event data depicted as numbers 1 3 enclosed by parallelograms received from the logical controller . The logical controller is one of several logical controllers from which the physical controller receives input event data. In this example the input event data has a barrier indicated by a bold parallelogram indicating the end of a set of input event data e.g. one set of transactional input event data . However the scheduler has not pushed the event data to the input tables because for example the input event data does not affect the same LDPS that the rules engine is currently processing. The stage also shows that the logical controller which is another of the logical controllers that send input event data to the physical controller is sending the input event data . The input event data has a barrier indicated by a bold parallelogram indicating the end of a set of input event data.

The next stage shows that two sets of input event data one set having the input event data and another set having the input event data are stored in the updates repository . However the scheduler has not pushed the event data to the input tables because for example the input event data does not affect the same LDPS that the rules engine is currently processing. Also the scheduler pushes other event data not shown from other logical controllers to the input tables .

The third stage shows that the scheduler has combined the input event data into a single set of input event data with one barrier attached to or included in the input event data . In this example the scheduler combines the input event data because the number of sets of input event data that have not been processed by the rules engine is now over a threshold value e.g. five . The fourth stage shows that the scheduler has pushed the input event data together as one set of input event data to the input tables after the rules engine has processed the sets of input event data in the input tables .

The example shown in is described in terms of logical controllers and physical controllers. However one of the ordinary skill in the art will recognize similar operations may be performed by input translation controllers and logical controllers or physical controllers and chassis controllers when a logical controller receives inputs from several input translation controllers or when a chassis controller receives inputs from several physical controllers.

In some embodiments the transactions can be spliced to smaller ones. If that is to be done the splicing controller or switch should understand which changes result in a policy compliant forwarding state version.

As mentioned above the inputs defining LDP sets in the form of API calls are sent to an input translation controller supporting the API. The network control system of some embodiments renders the API updates atomic. That is a configuration change migrates the system from the old state to the new state in atomic manner. Specifically after receiving an API call the API receiving code in the system updates the state for an nLog engine and after feeding all the updates in the API receiving code in the system waits for a fixedpoint to let the computation converge and signals the transaction to be ended by committing the changes for the nLog. After this the forwarding state updates will be sent downwards to the controllers below in the cluster hierarchy or towards the switching elements all in a single transactional update. The update will be applied in a transactional manner by the receiving element.

In some embodiments the API update can be transmitted across a distributed storage system e.g. the PTDs in the controllers as long as the updates arrive as a single transactional update to the receiver. That is as long as the update is written to the storage as a single transactional update and the nLog processing controller receives the update as a single transaction it can write the update to the nLog computation process as a single transactional update as the process for pushing the state updates continues as described above.

Consider a master controller that manages a set of LDP sets. In some embodiments the controller has a hot backup computing the same state and pushing that state downwards in a similar manner as the master. One difference between the master and the hot backup is that the stream from the backup is ignored until the failover begins. Now as the master dies the receiving controller switching element can switch over to the backup by gradually migrating from the old state to the new state as follows.

Instead of the removing shutting down the stream of state updates from the old master and letting the computation converge towards a state where there is now an active stream of updates coming from the controllers above it merely turns on the new master lets the computation converge and effectively merges the old and new stream. That is this is building on the assumption that both sources produce almost identical streams. After doing this the controller waits for the computation to converge by waiting for the fixedpoint and only after it has reached the fixedpoint it removes the old stream completely. Again by waiting for the fixedpoint the controller lets the computation converge towards the use of the new source only. After this the controller can finalize the migration from the old source to the new source by committing the transaction. This signals the nLog runtime to effectively pass the barrier from the controllers switching elements below as a signal that the state updates should be processed.

Similar to the API and failover operations the migration from a controller version to another controller version i.e. software versions benefits from the transactions and fixedpoint computation support in the system. In this use case an external upgrade driver runs the overall upgrade process from one controller version to another. It is the responsibility of that driver to coordinate the upgrade to happen in a way that packet loss does not occur.

The overall process that the driver executes to compose a single global transaction of smaller sub transactions is as follows 

 1 Once a need for upgrading the forwarding state is required the driver asks for the computation of the new state for the network middle fabric to start. This is done for all the controllers managing the network middle state and the new middle state is expected to co exist with the old one.

 2 The driver then waits for each controller to reach a fixedpoint and then commits the transaction synchronously downwards to the receiving controllers switching elements. The driver does the committing in a synchronous manner because after the commit the driver knows the state is active in the switching elements and is usable by the packets.

 3 After this the driver asks for the controllers to update towards the new edge forwarding state that will also use the new paths established in 1 for the middle parts of the network.

 4 Again the driver asks for the fixedpoint from all controllers and then once reaching the fixedpoint also synchronously commits the updates.

 5 The update is finalized when the driver asks for the removal of the old network middle state. This does not need to wait for fixedpoint and commit the removal will be pushed down with any other changes the controllers will eventually push down.

In some cases the API request processing may be implemented using the nLog engine. In that case the request is fed into the nLog engine by translating the request to a set of tuples that will trigger the nLog computation of the API response again represented as a tuple. When the tuple request and response have a one to one mapping with request and response tuples waiting for the response is easy the API request processing simply waits for a response that matches with the request to arrive. Once the response that matches with the request arrives the computation for the response is ready.

However when the request response do not have a one to one mapping it is more difficult to know when the request processing is complete. In that case the API request processing may ask for the fixedpoint of the computation after feeding the request in once the fixedpoint is reached the request has all the responses produced. As long as the request and response tuples have some common identifier it is easy to identify the response tuples regardless of the number of the response tuples. Thus this use case does not require the use of commits as such but the enabling primitive is the fixedpoint waiting.

As described above in the network virtualization solution of some embodiments a controller instance uses a network information base NIB data structure to send physical control plane data to the managed switching elements. In other embodiments a controller instance does not use the NIB data structure but instead directly sends the physical control plane data to the managed switching elements over one or more communication channels.

In the network virtualization system the virtualization application manages the network state to implement LDP sets over a physical network. The network state is not a constant and as the state changes updates to the state must be distributed to the managed switching elements throughout the network. These updates to the network state may appear for at least three reasons. First when the logical policy changes because the network policy enforced by the logical pipeline is reconfigured e.g. the updating of access control lists by an administrator of the LDPS the network state changes. Second workload operational changes result in a change to the network state. For instance when a virtual machine VM migrates from a first hypervisor to a second hypervisor a first managed edge switching element to a second managed edge switching element the logical view remains unchanged. However the network state requires updating due to the migration as the logical port to which the VM attaches is now at a different physical location. Third physical reconfiguration events such as device additions removals upgrades and reconfiguration may result in changes to the network state.

These three different types of changes resulting in network state updates have different implications in terms of network state inconsistency i.e. in terms of the network state not being up to date for a given policy or physical configuration . For instance when the network state is not up to date because of a new policy the logical pipeline remains operational and merely uses the old policy. In other words while moving to enforce the new policies quickly is essential it is typically not a matter of highest importance because the old policy is valid as such. Furthermore the physical reconfiguration events come without time pressure as these events can be prepared for e.g. by moving VMs around within the physical network .

However when the network state shared among the switching elements has not yet captured all of the operational changes e.g. VM migrations the pipeline may not be functional. For example packets sent to a particular logical destination may be sent to a physical location that no longer correlates to that logical destination. This results in extra packet drops that translate to a non functional logical network and thus the avoidance of such out of date network states should be given the utmost priority.

Accordingly the virtualization application faces several challenges to maintain the network state. First the virtualization itself requires precise control over the network state by the network controllers in order to enforce the correct policies and to implement the virtualization. Once the controllers i.e. the control plane become involved the timescale for distributing updates becomes much longer than for solutions that exist purely within the data plane e.g. traditional distributed Layer 2 learning . Second the responsibility for the entire network state places a scalability burden on the controllers i.e. controller cluster because the volume of the network state itself may become a source of complications for the controller cluster.

Given these challenges it is preferable to offload the state update dissemination mechanisms to the managed switching elements to the largest extent possible at least for the time critical state updates. Similarly even for state updates that do not require rapid dissemination moving updates to the managed switching elements provides benefits for scaling of the logical network.

The differences in the operating environments between the controllers and the managed switching elements have implications on the state update dissemination mechanisms used. For instance the CPU and memory resources of managed switching elements tend to be constrained whereas the servers on which the controllers run are likely to have high end server CPUs. Similarly the controllers within a controller cluster tend to run on a number of servers several orders of magnitude less than the number of managed switching elements within a network e.g. tens or hundreds of controllers compared to tens of thousands of switching elements . Thus while the controller clusters may favor approaches amenable to a limited number of controllers the managed switching elements should ideally rely on mechanisms scalable to tens of thousands or more of switching elements.

The arrows in illustrate the transfer of control data within the network control system . In the above there is no direct communication of control data between the managed switching elements network traffic would be passed directly between the managed switching elements of course . However in the network control system control data is sent i between the controller cluster and the managed switching elements as well as ii directly between the managed switching elements. In some embodiments policy changes to the network state e.g. ACL rules are propagated down from the network controller cluster to the managed switching elements while operational updates to the network state e.g. VM migration information are propagated directly between the managed switching elements. In addition some embodiments also propagate the operational updates upward to the controller cluster so that the network controller s are aware of the VM locations as well.

At a high level the network state can be disseminated using two different approaches. First the network control systems of some embodiments use a push based approach that pushes state to the network state recipients. Such a solution proactively replicates the state to entities e.g. switching elements that might need the state whether or not those entities actually do need the update. The entire state is replicated because any missing state information could cause an incorrect policy e.g. allowing the forwarding of packets that should be dropped or an incorrect forwarding decision and the entity pushing the state e.g. a network controller a switch will not know in advance what specific information the receiving entity needs.

On the other hand the network control systems of some embodiments use a pull based approach. Rather than automatically sending state information for every state update to every entity that might need the update in a pull based approach the entities that actually do need the state update retrieve that information from other entities. Thus unlike in the push based approach extra network state updates are not disseminated. However because the state is not fetched until a packet requiring the state information is received by a managed switching element a certain level of delay is inherent in the pull based system. Some embodiments reduce this delay by caching the pulled state information which itself introduces consistency issues as a switching element should not use cached network state information that is out of date. That is if a switching element pulls state information and then caches it the switching element may continue to use the cached information even after it becomes out of date. As such the pull based approach of some embodiments uses mechanisms to revoke out of date state information from caches around the network.

The process for pushing state information in a push based system builds on existing state synchronization mechanisms of some embodiments. The managed switching elements disseminate the state updates as reliable streams of deltas i.e. indicating changes to the state . By applying these deltas to the already existing state information the receiving managed switching elements can reconstruct the complete network state. This does not make any assumptions about the structure of the state information.

Pull based systems of some embodiments on the other hand require the state to be amenable to partitioning. If every single update to the network state for a single LDPS required a managed switching element to retrieve the complete network state for the LDPS the large amount of wasted resources would make such dissemination inefficient. However in some embodiments the network state information is easily divisible into small pieces of information. That is a switching element can map each received packet to a well defined small portion of the state that the switching element can retrieve without also retrieving unnecessary information about the rest of the network. Thus for each packet received the managed switching element can quickly determine whether it already has the necessary state information or whether this information should be retrieved from another switch.

Thus even with the need for cache consistency the pull based approaches of some embodiments tend to be simpler and more lightweight than the push based approaches. However given the restrictions both in terms of state fetching delays and state structure the network control systems of some embodiments are designed to disseminate only certain network state updates through the pull based approaches.

In network control systems that remove the dissemination of the time critical state updates from the controller cluster relying instead on the managed switching elements the controller cluster becomes decoupled from the time scales of the physical events although the controllers will nevertheless need to be involved in part with some relatively short time range physical events e.g. VM migration . However these operations are typically known in advance and can therefore be prepared for accordingly by the controllers e.g. by pushing the VM related state information before or during the VM migration so that it is readily available once the migration finishes .

As indicated above some embodiments distribute the most time critical network state updates directly between managed switching elements using a pull based approach. The network state updates with the most time pressure are the workload operational changes e.g. VM migration whereas logical policy updates do not have such pressure. Specifically the most time critical network state information relates to mapping a first destination specific identifier to a second destination specific identifier with lower granularity. When a VM moves from one location to another location the binding between the logical port to which the VM is assigned and the physical location of that port changes and without a quick update packets sent to the VM will be forwarded to the wrong physical location. Similarly when a MAC address moves from a first logical port to a second logical port the binding between the MAC address and the logical port should be quickly updated lest packets sent to the MAC address be sent to the wrong logical port and thus most likely the wrong location . The same need for timely updates applies to the binding between a logical IP address and a MAC address in case the logical IP address moves from a first virtual interface to a second virtual interface.

This network state information is easily divisible into partitions. The binding of a logical IP address to a MAC address is defined per IP address the binding of a MAC address to a logical port is partitioned over MAC addresses and finally the binding of a logical port to a physical location is partitioned over the logical ports. Because the boundaries between these different units of network state information can be clearly identified the binding states are ideal candidates for pull based dissemination.

In addition to the time critical address and port bindings the network control system of some embodiments uses the pull based approach to update some destination specific state updates that do not have the same time sensitivity. For instance when the physical encapsulation e.g. the tunneling between managed switching elements uses destination specific labels for multiplexing packets destined to different logical ports onto the same tunnel between the same physical ports the labels used are destination specific and hence can be disseminated using a pull based mechanism. For example the sending switching element would know a high level port identifier of the destination port and would use that identifier to pull the mapping to a more compact label e.g. a label assigned by the destination . In addition the tunnel encapsulation information itself may also be distributed through the pull based mechanisms. This tunnel encapsulation information might include tunneling details such as security credentials to use in establishing a direct tunnel between a sender and a destination. This is an example of state information that would not need to be pushed to every managed switching element in a network as it only affects the two switching elements at either end of the tunnel.

To implement the pull based dissemination of network state information directly between managed switching elements the network control system of some embodiments employs a dissemination service that uses a key value pair interface. By implementing such an interface on the data plane level the network control system can operate at data plane time scales at least with regard to network state information distributed through this interface.

In the following description the key value pair interface of some embodiments employs three different operations. However one of ordinary skill in the art will recognize that different embodiments may use more fewer or different operations to implement pull based network state dissemination.

The three operations used by the key value pair interface of some embodiments include a register operation an unregister operation and a lookup operation. The register operation of some embodiments publishes a key value pair to a dissemination service e.g. to specific managed switching elements designated as registry nodes for a particular set time while the unregister operation of some embodiments retracts a published key value pair before its set time has expired. The lookup operation of some embodiments is used to pull a value that corresponds to a known key and returns either the published value for the key or a not found . In some embodiments the key value interface is the interface to both the service clients and the clients for the registry nodes. Managed switching elements issue both lookup operations in order to pull state information from the registry nodes as well as register operations to publish their state information to the registry nodes.

The edge managed switching element publishes its mappings to the second level managed switching element via a register operation that takes as its parameters a key a value and a time to live TTL . In some embodiments each managed switching element publishes its mappings to each registry node to which it connects e.g. each of the registry nodes within its clique . In other embodiments a managed switching element selects a subset of the registry nodes to which it publishes its information e.g. using a deterministic function such as a hash that accepts the key value as input . The selected registry nodes have as few disjointed failure domains as possible in some embodiments in order to maximize the availability of the published mappings The second level managed switching elements in a network e.g. the pool nodes serve as the registry nodes for the network in some embodiments.

To issue a register operation in some embodiments a managed switching element sends a special packet to the one or more registry nodes. This packet contains header information that separates the packet from network traffic over the LDP sets and identifies the packet as a register operation. The registry nodes of some embodiments contain a local daemon for handling network state updates. After identifying a register packet as such the registry node automatically sends the packet to the local daemon for the creation of a new flow table entry based on the received information. Alternatively the registry nodes of some embodiments use special flow entries to dynamically create new flow entries based on the information in the received register packet avoiding having to send the packet to a daemon. The established flow entries of some embodiments are designed to match any lookup messages sent with the corresponding key and to generate the proper response packets as will be described below.

In some embodiments the key in the key value pair represents a first piece of network state information over which the network state is partitioned and the value represents a second piece of network state information that is bound to the key. For instance examples of key value pairs include logical IP MAC MAC logical port and logical port physical location . The TTL for a published key value pair represents the length of time before the key value pair expires. However in some embodiments the managed edge switching elements are expected to re register mappings well before the TTL expires e.g. after half of the TTL time has elapsed in order to ensure that the network state is kept up to date.

As shown the registry node stores a table of key value pairs that it has received e.g. from the register messages sent by the managed edge switching elements . These pairs store for example logical IP to MAC address bindings MAC to logical port bindings and logical port to physical location bindings. In addition each row in the table stores the TTL for the binding pair. In some embodiments this table is implemented as the dynamically created flow entries stored by the registry node. If the TTL for an entry is reached some embodiments automatically remove the entry from the table i.e. remove the flow entry for the pair if the pair has not been republished.

In the managed edge switching element issues an unregister operation by sending a packet to the registry node . The unregister operation of some embodiments only includes a single parameter the key that is being unregistered. The switching element would have previously sent a register packet to the registry node indicating a mapping of the key to a particular value. Upon receiving the unregister packet the registry node removes the entry for the key and its mapped value from its table .

The flow entries established at the registry node in table are created to match any lookup messages issued to pull a corresponding key and to generate the proper response. To create such a response the registry node looks for a match within its flow entries. When the registry node matches one of its created flow entries it creates a response packet by changing the type of the received lookup packet to a response packet and embedding both the key and its bound value and then sends the response packet back to the requesting managed switching element.

When the registry node does not find a match within its tables the registry node sends the message to any remote cliques within the network. In the situation illustrated in the registry node does not have a match for the key looked up by the edge switching element . As such the registry node sends the lookup packet to the second level managed switching element part of a remote clique. The network state table at switching element includes an entry for the key value pair and sends back a response packet that includes the key and value. When the remote clique does not have a match the switching element replies with an empty response i.e. a not found response . The second level switching element both forwards this response packet to the managed switching element and caches the key value pair e.g. creates a new entry in the table in some embodiments. In some embodiments the lookup and subsequent response have symmetric travel routes. Because the delivery of these packets is unreliable in both directions the original issuer of the lookup packet e.g. switching element should be prepared to re issue the query as necessary after a proper timeout. By avoiding any contact with the network controllers the processing of the lookup state pulling packets at the registry nodes remains completely at the data plane and thus remains efficient providing low latency response times.

Much like the register packets the lookup packets of some embodiments and the responses contain header information that separates the packet from network traffic over the LDP sets and identifies the packet as a lookup operation. In addition to this type identification information the packets include an issuer identifier so that the response can be sent back to the issuer without having to hold any state about the pending lookup operation in the registry nodes. In addition of course the packet contains the key for which the originating switching element wishes to pull the corresponding value.

The lookup response packet of some embodiments contains the requested key value pair along with the TTL value for the pair. In addition the packet contains an issuer identifier so that if the response is relayed via an intermediate registry node then the packet identifies the destination for the response. In addition the lookup packet contains a second identifier that identifies the publishing switch which is useful in revocation processing discussed below.

Incoming packets arrive at the managed switching element either from the VM as well as other VMs running on the host or from other managed switching elements. The managed switching element contains a set of flow entries that it uses to forward incoming packets. However in a pull based system the flow entries may not include the information necessary for the managed switching to make a forwarding decision for the packet. In this case the switching element requests information from a mapping daemon that also operates on the host .

As shown the mapping daemon includes a registration manager and a lookup manager . The registration manager of some embodiments monitors the local switching element state which includes a configuration database as well as the flow entries . When a change is detected in the local switching element state the registration manager causes the switching element to issue a register packet to one or more registry nodes registering the state information for the switch. This state information may include e.g. the MAC address and logical port of a new VM operating on the host etc.

The lookup manager receives from the switching element any logical network traffic packets that require lookups in order to be processed by the switching element. That is the flow entries offload to the mapping daemon any packets that the flow entries cannot process and that require lookups. In some embodiments a single logical packet may trigger multiple lookups to the daemon before passing through the entire processing pipeline to be ready for the encapsulation and delivery to the physical next hop e.g. a first lookup to identify the logical port for a packet s destination MAC address and then a second lookup to determine the physical location corresponding to the returned logical port .

In some embodiments the daemon uses e.g. contains a queue to store packets while waiting for the lookup responses needed to forward the packets from the registry nodes. If the daemon becomes overloaded some embodiments allow the daemon to drop packets by either not issuing any lookups or issuing the lookups and only dropping the corresponding packet. Once the packet has been queued the daemon issues a lookup packet through the managed switching element and sends it back to the data plane for further processing. The daemon sends a copy of the lookup packet to several local registry nodes in some embodiments. Depending on the reliability goals of the system the daemon may issue multiple calls in parallel or wait for a first call to fail in order to retry sending to a new registry node.

Once a response packet is received back at the switching element the response is cached in the daemon. As shown in some embodiments the lookup manager manages a cache of key value pairs that also stores TTL information for each pair. In addition the switching element of some embodiments or the daemon in other embodiments adds a flow entry along with a TTL that corresponds to the key value pair to the flow table . Thus any packets sent to the particular destination that are required for the pulled state information can be processed completely on the data plane. The daemon later inspects the flow entry to determine whether it is actively used in some embodiments. When this is the case the daemon issues a new lookup packet before the TTL expires in order to keep the key value pair up to date.

Certain situations can result in potential problems in the pull based system if an aspect of the network state has changed while switching elements are still using an older cached version of the state. For instance in some embodiments if a switching element issues a lookup message and then receives a valid response the switching element caches the result e.g. by creating a flow entry for the TTL time in order to avoid issuing a new lookup message for every packet that uses the state information. However if the publisher of the state information changes the key value pair the now invalid entry will remain cached until the TTL expires at which point the switching element would issue a new lookup message in some embodiments. To address this potential situation some embodiments attempt to shorten the time of inconsistency to the absolute minimum while maintaining the pull based model.

When a switching element has an entry in its cache that stores invalid state information and receives a packet that needs the state information the switching element will forward the packet using that incorrect state information. In some embodiments the physical switching element that receives the incorrectly forwarded packet detects the use of the incorrect state. The packet may have been sent to a destination that is no longer attached to the receiving switch or the bindings used in the packet are known to be wrong. To detect this the receiving switching element of some embodiments matches over the bindings based on its local state information and therefore validates the bindings. If the switching element is unable to find a match it determines that the state information used to forward the packet is invalid.

Upon detecting that the invalid state has been used the receiving switching element of some embodiments sends a special revocation packet that includes the key of the key value pair used to create the invalid binding. The revocation packet also includes the packet s publisher identifier. In some embodiments the switching element sends the revocation packet either directly to the sender or via the pool nodes. In order to send such a packet the destination switching element has to determine the sender. When there is a direct tunnel between the source and the destination this can be determined easily. However when the source that used the incorrect bindings and the destination are located at different cliques the packet encapsulation needs to store enough information for the receiving switching element to identify the source. Accordingly some embodiments require the source managed switching element to include an identifier in the encapsulation.

In some embodiments once the original packet sending switching element receives the revocation the switching element not only revokes the key value pair from its cache assuming the current cache entry was originally published by the sender of the revocation packet but additionally sends this revocation packet to the registry nodes to which it sends its queries for the particular key and from which it may have received the now invalid state information . These registry nodes in some embodiments forward the revocation to registry nodes at other cliques and then remove the cached entries matching the key and publisher from their caches i.e. from their flow entry tables . Using this technique any switching element that holds invalid cached state information in its flow entries will converge towards the removal of the invalid information with only a transient packet loss e.g. only the first packet sent using the invalid state information .

As indicated above in some cases when a switching element issues a lookup packet in order to pull state information the registry nodes will not yet have the requested state information and therefore reply with a packet indicating the requested information is not found. In this case the expectation is that the state information will be available at the registry soon either directly from the publishing switch or from registry nodes in other cliques as otherwise packets that require such a lookup operation should not be sent unless someone is trying to maliciously forge packets .

In order to limit the extra load under such transient conditions caused by the publisher of the state information being slower than the switching element pulling the state information and to limit the effect of malicious packet forging when the switching element receives a not found response some embodiments cache that result as the switching element would with a positive response. However the switching element sets the TTL to a significantly lower time value than would be the case for a positive response. As the result is assumed to be only due to the transient conditions the lookup should be retried as soon as the system expects that the value should be available. Unlike the expired invalid lookup results described in the previous section these cached not found results are not removed quickly and automatically without the short TTL value. As they do not result in packets being sent to an incorrect destination or any destination at all there is no revocation packet send back to cause a correction to an inconsistency.

In a push based network control system in which the controller cluster pushes all of the network state information to the managed switching elements the security model for the network state at the switching elements is clear. So long as the channel to the switching elements from the controllers remains secure and the switching elements themselves are not breached then the state information at the switching elements remains correct.

However in the pull based system described herein in which the switching elements obtain at least some of the network state information from the registry nodes other switching elements the security model changes. Not only must the registry nodes be trusted but additionally the communication channels for transmitting the control related messages e.g. register unregister lookup response revoke etc. must be secured to prevent malicious entities from tampering with the messages at the physical network level. These communication channels include the channels between the registry nodes and other switching elements as well as between the switching elements themselves.

Some embodiments rely on a more content oriented approach to securing these channels for exchanging control messages as opposed to ordinary network data plane traffic . For instance in some embodiments the publisher of a key value pair cryptographically signs its register messages as well as unregister and revocation messages under the assumption that a receiver of the messages can verify the signature and thus the validity of the data contained therein. For these cryptographic signatures and for distribution of the necessary public keys some embodiments rely on standard public key infrastructure PKI techniques.

Several embodiments described above and below provide network control systems that completely separate the logical forwarding space i.e. the logical control and forwarding planes from the physical forwarding space i.e. the physical control and forwarding planes . These control systems achieve such a separation by using a mapping engine to map the logical forwarding space data to the physical forwarding space data. By completely decoupling the logical space from the physical space the control systems of these embodiments allow the logical view of the logical forwarding elements to remain unchanged while changes are made to the physical forwarding space e.g. virtual machines are migrated physical switches or routers are added etc. .

More specifically the control system of some embodiments manages networks over which machines e.g. virtual machines belonging to several different users i.e. several different tenants in a private or public hosted environment with multiple hosted computers and managed forwarding elements that are shared by multiple different related or unrelated tenants may exchange data packets for separate LDP sets. That is machines belonging to a particular user may exchange data with other machines belonging to the same user over a LDPS for that user while machines belonging to a different user exchange data with each other over a different LDPS implemented on the same physical managed network. In some embodiments a LDPS also referred to as a logical forwarding element e.g. logical switch logical router or logical network in some cases is a logical construct that provides switching fabric to interconnect several logical ports to which a particular user s machines physical or virtual may attach.

In some embodiments the creation and use of such LDP sets and logical ports provides a logical service model that to an untrained eye may seem similar to the use of a virtual local area network VLAN . However various significant distinctions from the VLAN service model for segmenting a network exist. In the logical service model described herein the physical network can change without having any effect on the user s logical view of the network e.g. the addition of a managed switching element or the movement of a VM from one location to another does not affect the user s view of the logical forwarding element . One of ordinary skill in the art will recognize that all of the distinctions described below may not apply to a particular managed network. Some managed networks may include all of the features described in this section while other managed networks will include different subsets of these features.

In order for the managed forwarding elements within the managed network of some embodiments to identify the LDPS to which a packet belongs the network controller clusters automatedly generate flow entries for the physical managed forwarding elements according to user input defining the LDP sets. When packets from a machine on a particular LDPS are sent onto the managed network the managed forwarding elements use these flow entries to identify the logical context of the packet i.e. the LDPS to which the packet belongs as well as the logical port towards which the packet is headed and forward the packet according to the logical context.

In some embodiments a packet leaves its source machine and the network interface of its source machine without any sort of logical context ID. Instead the packet only contains the addresses of the source and destination machine e.g. MAC addresses IP addresses etc. . All of the logical context information is both added and removed at the managed forwarding elements of the network. When a first managed forwarding element receives a packet directly from a source machine the forwarding element uses information in the packet as well as the physical port at which it received the packet to identify the logical context of the packet and append this information to the packet. Similarly the last managed forwarding element before the destination machine removes the logical context before forwarding the packet to its destination. In addition the logical context appended to the packet may be modified by intermediate managed forwarding elements along the way in some embodiments. As such the end machines and the network interfaces of the end machines need not be aware of the logical network over which the packet is sent. As a result the end machines and their network interfaces do not need to be configured to adapt to the logical network. Instead the network controllers configure only the managed forwarding elements. In addition because the majority of the forwarding processing is performed at the edge forwarding elements the overall forwarding resources for the network will scale automatically as more machines are added because each physical edge forwarding element can only have so many machines attached .

In the logical context appended e.g. prepended to the packet some embodiments only include the logical egress port. That is the logical context that encapsulates the packet does not include an explicit user ID. Instead the logical context captures a logical forwarding decision made at the first hop i.e. a decision as to the destination logical port . From this the user ID i.e. the LDPS to which the packet belongs can be determined implicitly at later forwarding elements by examining the logical egress port as that logical egress port is part of a particular LDPS . This results in a flat context identifier meaning that the managed forwarding element does not have to slice the context ID to determine multiple pieces of information within the ID.

In some embodiments the egress port is a 32 bit ID. However the use of software forwarding elements for the managed forwarding elements that process the logical contexts in some embodiments enables the system to be modified at any time to change the size of the logical context e.g. to 64 bits or more whereas hardware forwarding elements tend to be more constrained to using a particular number of bits for a context identifier. In addition using a logical context identifier such as described herein results in an explicit separation between logical data i.e. the egress context ID and source destination address data i.e. MAC addresses . While the source and destination addresses are mapped to the logical ingress and egress ports the information is stored separately within the packet. Thus at managed switching elements within a network packets can be forwarded based entirely on the logical data i.e. the logical egress information that encapsulates the packet without any additional lookup over physical address information.

In some embodiments the packet processing within a managed forwarding element involves repeatedly sending packets to a dispatch port effectively resubmitting the packet back into the switch. In some embodiments using software switches provides the ability to perform such resubmissions of packets. Whereas hardware forwarding elements generally involve a fixed pipeline due in part to the use of an ASIC to perform the processing software forwarding elements of some embodiments can extend a packet processing pipeline as long as necessary as there is not much of a delay from performing the resubmissions.

In addition some embodiments enable optimization of the multiple lookups for subsequent packets within a single set of related packets e.g. a single TCP UDP flow . When the first packet arrives the managed forwarding element performs all of the lookups and resubmits in order to fully process the packet. The forwarding element then caches the end result of the decision e.g. the addition of an egress context to the packet and the next hop forwarding decision out a particular port of the forwarding element over a particular tunnel along with a unique identifier for the packet that will be shared with all other related packets i.e. a unique identifier for the TCP UDP flow . Some embodiments push this cached result into the kernel of the forwarding element for additional optimization. For additional packets that share the unique identifier i.e. additional packets within the same flow the forwarding element can use the single cached lookup that specifies all of the actions to perform on the packet. Once the flow of packets is complete e.g. after a particular amount of time with no packets matching the identifier in some embodiments the forwarding element flushes the cache. This use of multiple lookups in some embodiments involves mapping packets from a physical space e.g. MAC addresses at physical ports into a logical space e.g. a logical forwarding decision to a logical port of a logical switch and then back into a physical space e.g. mapping the logical egress context to a physical outport of the switch .

Such logical networks that use encapsulation to provide an explicit separation of physical and logical addresses provide significant advantages over other approaches to network virtualization such as VLANs. For example tagging techniques e.g. VLAN use a tag placed on the packet to segment forwarding tables to only apply rules associated with the tag to a packet. This only segments an existing address space rather than introducing a new space. As a result because the addresses are used for entities in both the virtual and physical realms they have to be exposed to the physical forwarding tables. As such the property of aggregation that comes from hierarchical address mapping cannot be exploited. In addition because no new address space is introduced with tagging all of the virtual contexts must use identical addressing models and the virtual address space is limited to being the same as the physical address space. A further shortcoming of tagging techniques is the inability to take advantage of mobility through address remapping.

Many of the above described features and applications are implemented as software processes that are specified as a set of instructions recorded on a computer readable storage medium also referred to as computer readable medium . When these instructions are executed by one or more processing unit s e.g. one or more processors cores of processors or other processing units they cause the processing unit s to perform the actions indicated in the instructions. Examples of computer readable media include but are not limited to CD ROMs flash drives RAM chips hard drives EPROMs etc. The computer readable media does not include carrier waves and electronic signals passing wirelessly or over wired connections.

In this specification the term software is meant to include firmware residing in read only memory or applications stored in magnetic storage which can be read into memory for processing by a processor. Also in some embodiments multiple software inventions can be implemented as sub parts of a larger program while remaining distinct software inventions. In some embodiments multiple software inventions can also be implemented as separate programs. Finally any combination of separate programs that together implement a software invention described here is within the scope of the invention. In some embodiments the software programs when installed to operate on one or more electronic systems define one or more specific machine implementations that execute and perform the operations of the software programs.

The bus collectively represents all system peripheral and chipset buses that communicatively connect the numerous internal devices of the electronic system . For instance the bus communicatively connects the processing unit s with the read only memory the system memory and the permanent storage device .

From these various memory units the processing unit s retrieve instructions to execute and data to process in order to execute the processes of the invention. The processing unit s may be a single processor or a multi core processor in different embodiments.

The read only memory ROM stores static data and instructions that are needed by the processing unit s and other modules of the electronic system. The permanent storage device on the other hand is a read and write memory device. This device is a non volatile memory unit that stores instructions and data even when the electronic system is off. Some embodiments of the invention use a mass storage device such as a magnetic or optical disk and its corresponding disk drive as the permanent storage device .

Other embodiments use a removable storage device such as a floppy disk flash drive etc. as the permanent storage device. Like the permanent storage device the system memory is a read and write memory device. However unlike storage device the system memory is a volatile read and write memory such a random access memory. The system memory stores some of the instructions and data that the processor needs at runtime. In some embodiments the invention s processes are stored in the system memory the permanent storage device and or the read only memory . From these various memory units the processing unit s retrieve instructions to execute and data to process in order to execute the processes of some embodiments.

The bus also connects to the input and output devices and . The input devices enable the user to communicate information and select commands to the electronic system. The input devices include alphanumeric keyboards and pointing devices also called cursor control devices . The output devices display images generated by the electronic system. The output devices include printers and display devices such as cathode ray tubes CRT or liquid crystal displays LCD . Some embodiments include devices such as a touchscreen that function as both input and output devices.

Finally as shown in bus also couples electronic system to a network through a network adapter not shown . In this manner the computer can be a part of a network of computers such as a local area network LAN a wide area network WAN or an Intranet or a network of networks such as the Internet. Any or all components of electronic system may be used in conjunction with the invention.

Some embodiments include electronic components such as microprocessors storage and memory that store computer program instructions in a machine readable or computer readable medium alternatively referred to as computer readable storage media machine readable media or machine readable storage media . Some examples of such computer readable media include RAM ROM read only compact discs CD ROM recordable compact discs CD R rewritable compact discs CD RW read only digital versatile discs e.g. DVD ROM dual layer DVD ROM a variety of recordable rewritable DVDs e.g. DVD RAM DVD RW DVD RW etc. flash memory e.g. SD cards mini SD cards micro SD cards etc. magnetic and or solid state hard drives read only and recordable Blu Ray discs ultra density optical discs any other optical or magnetic media and floppy disks. The computer readable media may store a computer program that is executable by at least one processing unit and includes sets of instructions for performing various operations. Examples of computer programs or computer code include machine code such as is produced by a compiler and files including higher level code that are executed by a computer an electronic component or a microprocessor using an interpreter.

While the above discussion primarily refers to microprocessor or multi core processors that execute software some embodiments are performed by one or more integrated circuits such as application specific integrated circuits ASICs or field programmable gate arrays FPGAs . In some embodiments such integrated circuits execute instructions that are stored on the circuit itself.

As used in this specification the terms computer server processor and memory all refer to electronic or other technological devices. These terms exclude people or groups of people. For the purposes of the specification the terms display or displaying means displaying on an electronic device. As used in this specification the terms computer readable medium computer readable media and machine readable medium are entirely restricted to tangible physical objects that store information in a form that is readable by a computer. These terms exclude any wireless signals wired download signals and any other ephemeral signals.

While the invention has been described with reference to numerous specific details one of ordinary skill in the art will recognize that the invention can be embodied in other specific forms without departing from the spirit of the invention. In addition a number of the figures including conceptually illustrate processes. The specific operations of these processes may not be performed in the exact order shown and described. The specific operations may not be performed in one continuous series of operations and different specific operations may be performed in different embodiments. Furthermore the process could be implemented using several sub processes or as part of a larger macro process.

Also several embodiments were described above in which a user provides LDP sets in terms of logical control plane data. In other embodiments however a user may provide LDP sets in terms of logical forwarding plane data. In addition several embodiments were described above in which a controller instance provides physical control plane data to a switching element in order to manage the switching element. In other embodiments however the controller instance may provide the switching element with physical forwarding plane data. In such embodiments the relational database data structure would store physical forwarding plane data and the virtualization application would generate such data.

Furthermore in several examples above a user specifies one or more logical switches. In some embodiments the user can provide physical switching element configurations along with such logic switching element configurations. Also even though controller instances are described that in some embodiments are individually formed by several application layers that execute on one computing device one of ordinary skill will realize that such instances are formed by dedicated computing devices or other machines in some embodiments that perform one or more layers of their operations.

Also several examples described above show that a LDPS is associated with one user. One of the ordinary skill in the art will recognize that then a user may be associated with one or more sets of LDP sets in some embodiments. That is the relationship between a LDPS and a user is not always a one to one relationship as a user may be associated with multiple LDP sets. Thus one of ordinary skill in the art would understand that the invention is not to be limited by the foregoing illustrative details.

