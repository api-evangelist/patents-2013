---

title: Method and system of storing data files
abstract: A method and system for storing data files are provided. The method includes receiving a first data file and a first data file virtualization policy; associating the first data file with the first data file virtualization policy; and storing the first data file and the first data file virtualization policy on a storage device in communication with the computer system.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09584584&OS=09584584&RS=09584584
owner: PIXIA CORP.
number: 09584584
owner_city: Reston
owner_country: US
publication_date: 20130227
---
The present application is based on and claims priority to U.S. Provisional Application No. 61 733 228 filed on Dec. 4 2012 the entire contents of which is incorporated herein by reference.

The present invention pertains to data storage and retrieval and in particular to a method and system of storing a client provided data file along with an associated data file virtualization policy for retrieval and a method and system for the retrieval of data from the client provided data file.

Interchange of computer data using a client program and a server program is a well known technology. A client program communicates with a server program using a communication protocol over a network for example a LAN WAN or the Internet. Examples of a communication protocol are TCP UDP HTTP HTTPS socket based communication HTTP 1.1 WebDAV. A client program sends a request for data to a server program. Based on that request the server program sends data to the client program in response to the request.

The client program and the server program may be running on the same computer or on separate computers. For example a client program may be running on a client computer while a server program may be running a server computer. The server computer may be a computer system having one or more processors. However the client program and the server program may also be running on the same computer system. In addition a client program may be running on one or more computers. Similarly a server program may be running on one or more computers. The computers running client programs and server programs are connected to each other in some form over the network.

Server and client programs follow some type of communication protocol to be able to understand each other. One such method is when a client side asks a server side about its capabilities. The server side then responds to the client side with a list of services it offers. The client may utilize those services to fulfill its goals by making additional requests to the server.

A client program includes a set of one or more computer programs. A server program includes a set of one or more computer programs.

The HTTP protocol is popular and a well known standard over a computer network for example LAN WAN and the Internet or the World Wide Web WWW . A current HTTP protocol version is HTTP 1.1 and is described in the Internet Engineering Task Force Specification IETF RFC 2616. An extension to the HTTP 1.1 protocol is HTTP 1.1 WebDAV. This protocol is described in IETF RFC 4918.

The HTTP 1.1 WebDAV protocol in its simplest form allows a computer to read from and write to web resources on a remote storage device using the WWW. A web resource can be a file or a one or more files. The protocol also supports the equivalent of hierarchical folder listings file and folder metadata reporting file and folder deleting and such features that existing Portable Operating System Interface POSIX based file systems offer over the WWW using this protocol. In addition the protocol also supports file versioning over the WWW. The protocol allows for client programs to connect to remote storage solutions over the WWW and provision data at the remote location as if it were a network mounted POSIX file system.

For example the HTTP protocol supports the OPTIONS request. It allows the server to provide a list of WebDAV commands that it supports and how the commands are supported. The WebDAV protocol requires the implementation of some requests. The implementation of other or additional WebDAV requests is optional. The PROPFIND request in WebDAV is used to retrieve properties and metadata from a resource. It is equivalent to getting properties and metadata about a file and getting a hierarchical directory or folder list. The MKCOL request in WebDAV is used to create collections for example a collection could be a directory or folder. The GET request in WebDAV is used to retrieve a complete or partial resource for example a file from a remote location on the WWW. The PUT request in WebDAV is used to store a complete or partial resource for example a file from a remote location on the WWW. The COPY request in WebDAV duplicates a resource for example a file. Details regarding the various requests that can be implemented in WebDAV can be found in the IETF RFC 4918 specification.

On a POSIX based file system there are various techniques and methods available for reading and writing files. One of these methods is synchronous or asynchronous unbuffered direct I O.

Synchronous I O implies that if a program issues a POSIX request to read or write the control is returned to the program once the request is completed successfully or unsuccessfully and not before that. Asynchronous I O implies that as soon as a program issues a POSIX request to read or write the control is returned to the program. The actual read or write operation is completed at a later time and at that time the program that originally issued the write operation request is alerted regarding the completion status of the write operation.

Unbuffered Direct I O implies that if a program issues a POSIX request to read or write the operating systems does not do anything besides reading the data from storage into memory or writing the data from memory to storage. It does not perform caching of any sort.

Synchronous or asynchronous unbuffered direct I O has constraints imposed by file system implementations. Some file systems permit a single I O request of this type to be no larger than a certain number of bytes. For example in certain versions of the Microsoft Windows operating system a single direct I O read request can be no larger than approximately 64 Megabytes. A read or write operation operates on a file starting from a specific offset and is of a specific size in bytes. Most file systems require that a single I O request of this type be made starting at an offset and of a size that are an integer multiple of the storage device block size. For example a storage device block size may be 512 bytes or 4096 bytes. Most operating systems also require that the computer memory allocated for such an operation begin and end at an operating system memory page boundary for example begin and end at operating system memory page boundary of 4096 bytes.

Popular WebDAV implementations generally utilize some form of buffered I O. These implementations also utilize published or invented caching techniques to further improve performance. Caching methods are intended to improve aggregate performance based on pattern of access.

An aspect of the present invention is to provide a method implemented by a computer system for storing data files. The method includes receiving by the computer system a first data file and a first data file virtualization policy associating by the computer system the first data file with the first data file virtualization policy and storing by the computer system the first data file and the first data file virtualization policy on a storage device in communication with the computer system.

Another aspect of the present invention is to provide a method implemented by a computer system for retrieving at least a portion of a first data file stored in a storage device in communication with the computer system. The method includes receiving by the computer system from a client computer system in communication with the computer system a request for the at least a portion of the first data file the request including a start of the at least a portion of the first data file and a size of the at least a portion of the first data file computing by the computer system a data offset that is aligned to an integer multiple of a block size of the storage device and nearest to the start of the at least a portion of the first data file and computing by the computer system a byte range that is an integer multiple of the block size of the storage device the byte range being greater than and encompasses the size of the at least a portion of the first data file. The method further includes reading by the computer system data within the byte range and transferring the data within the byte range starting at the data offset into memory of the computer system and transmitting by the computer system to the client computer system the at least a portion of the first data file from the memory starting at an offset relative to the data offset that is aligned to an integer multiple of the block size of the storage device.

A further aspect of the present invention is to provide a system for storing data files. The system includes a computer system configured to receive a first data file and a first data file virtualization policy associate the first data file with the first data file virtualization policy and store the first data file and the first data file virtualization policy on a storage device in communication with the computer system.

Another aspect of the present invention is to provide a system for retrieving at least a portion of a first data file stored in a storage device in communication with a computer system. The computer system is configured to receive from a client computer system in communication with the computer system a request for the at least a portion of the first data file the request including a start of the at least a portion of the first data file and a size of the at least a portion of the first data file compute a data offset that is aligned to an integer multiple of a block size of the storage device and nearest to the start of the at least a portion of the first data file and compute a byte range that is an integer multiple of the block size of the storage device the byte range being greater than and encompasses the size of the at least a portion of the first data file. The computer system is further configured to read data within the byte range and transferring the data within the byte range starting at the data offset into memory of the computer system and transmit to a client computer system the at least a portion of the first data file from the memory starting at an offset relative to the data offset that is aligned to an integer multiple of the block size of the storage device.

Another aspect of the present invention is to provide a method implemented by a client computer system of requesting information from a server computer system. The method includes sending by the client computer system to the server computer system a request for policy capability of the server computer system for a data type receiving by the client computer system from the server computer system a response to the request including a list of derived data types that are supported by the server computer system generating by the client computer system a policy using the list of derived data types and sending by the client computer system to the server computer system a first data file and a first data file virtualization policy for storage.

Another aspect of the present invention is to provide a system having a client computer system. The client computer system is configured to send to a server computer system in communication with the client computer system a request for policy capability of the server computer system for a data type receive a response to the request including a list of derived data types that are supported by the server computer system generate a policy using the list of derived data types and send a first data file and a first data file virtualization policy for storage.

A further aspect of the present invention is to provide a method for retrieving at least a portion of a second derived virtual data file the second derived virtual data file being derived from a first data file based on a first data file virtualization policy the method being implemented by a computer system the first data file being stored in a storage device in communication with the computer system. The method includes receiving by the computer system from a client computer system in communication with the computer system a request for the at least a portion of the second derived virtual data file the request including a virtual offset of the at least a portion of the second derived virtual data file and a size of the at least a portion of the second derived virtual data file computing by the computer system a data offset and a size of at least a portion of the first data file to derive the requested at least a portion of the second derived virtual data file reading by the computer system data from the first data file based on the computed data offset and size of the at least a portion of the first data file generating by the computer system the requested at least a portion of the second derived data file using information in the first data file virtualization policy and the read data from the first data file and transmitting by the computer system to the client computer system the requested at least a portion of the second derived virtual data file.

Another aspect of the present invention is to provide a system for retrieving at least a portion of a second derived data file the second derived virtual data file being derived from a first data file based on a first data file virtualization policy the first data file being stored in a storage device in communication with a computer system. The computer system is configured to receive from a client computer system in communication with the computer system a request for the at least a portion of the second derived virtual data file the request including a virtual offset of the at least a portion of the second derived virtual data file and a size of the at least a portion of the second derived virtual data file compute a data offset and a size of at least a portion of the first data file to derive the requested at least a portion of the second derived virtual data file read data from the first data file based on the computed data offset and size of the at least a portion of the first data file generate the requested at least a portion of the second derived data file using information in the first data file virtualization policy and the read data from the first data file and transmit to the client computer system the requested at least a portion of the second derived virtual data file.

Although the various steps of the method are described in the above paragraphs as occurring in a certain order the present application is not bound by the order in which the various steps occur. In fact in alternative embodiments the various steps can be executed in an order different from the order described above or otherwise herein.

These and other objects features and characteristics of the present invention as well as the methods of operation and functions of the related elements of structure and the combination of parts and economies of manufacture will become more apparent upon consideration of the following description and the appended claims with reference to the accompanying drawings all of which form a part of this specification wherein like reference numerals designate corresponding parts in the various figures. In one embodiment of the invention the structural components illustrated herein are drawn to scale. It is to be expressly understood however that the drawings are for the purpose of illustration and description only and are not intended as a definition of the limits of the invention. As used in the specification and in the claims the singular form of a an and the include plural referents unless the context clearly dictates otherwise.

A data file is defined as one or more bytes that exist in computer memory or on a computer storage device such as a hard disk or a clustered storage device. A data file can be exposed to a computer program via a well known interface for example an Object Storage Solution interface or a POSIX file system interface. One or more data files are referred herein as a collection of data files. The symbol D is used herein to indicate the collection of data files.

A data file that is physically stored on a storage device is referred to as a first data file. A data file that is virtually presented to a consumer as if it were stored on a storage device but is not actually stored on a storage device and is derived from the first data file is referred to herein as a second virtual derived data file and also referred to as a second derived data file or a second derived virtual data file or a second virtual data file or a derived data file or a virtual data file.

A data type describes the byte layout and type of data stored in a data file. For example Point Cloud LiDAR data is stored in data files of a well known file format named LAS. Therefore a Collection of LAS Data Files containing Point Cloud LiDAR data are of data type Point Cloud LiDAR LAS. For example Wide Area Motion Imagery WAMI data is stored in data files of a well known file format named GeoJP2. Therefore a Collection of GeoJP2 Data Files containing WAMI data are of data type WAMI GeoJP2. For example Live Action Motion Picture frames captured at 24 or 48 frames per second is stored in data files of a well known file format named OpenEXR. Therefore a Collection of OpenEXR Data Files each data file including one live action motion picture frame are of data type Live Action Motion Picture OpenEXR. The symbol Trefers to the data type of a collection of data files D.

The various methods described herein depict multiple workflows. A workflow is a diagram that depicts primary phases of an operation or a sequence of connected steps in an operation. An example of a conventional circular workflow is depicted in . In this example a client program generates a request for a server program and sends it to the server program over a computer network. The server program receives the request processes the request and generates a response. The response is sent by the server program back to the client program over a computer network. The client program receives the response. The cycle continues.

In one embodiment for example a client program entrusts a server program with a first data file D that is of a known data type T. The goal for the client is to access the first data file D at a future time. A client program may also have to access additional data of same or different data types that are derived from D at a future time. If the server program does not provide for such derived data or provide the ability to create such derived data the client program would have to look for alternative services. If such services are not available the client program has to generate the derived data by itself. In the following paragraphs a method for storing and retrieving data files on a storage device is described.

In one embodiment the method allows for defining a data file virtualization policy that provides a client program with the ability to send the client program s intent to access the data stored in a first data file as well as an intent of the client program to access data files of other data types that are derived from the first data file.

A data file virtualization policy is defined as the intent by a client program of accessing a first data file D as well as derived data files D D. . . D. One or more derived data files D D. . . Dare derived from the first data file D and are virtual. The term virtual implies that one or more data files Ddo not physically exist on a storage device. The term virtual further implies that a directory listing of data files Dis available to the client program. The client program believes that data files exist on the server side storage device. The term virtual further implies that a derived data file D where 1 J N is generated by the server program by reading the first data file D wholly or partially dynamically on demand when a client requests for that specific derived data file. A data file virtualization policy is denoted herein as Por P. A client program sends a first data file D i.e. one or more first data files D to a server program accompanied by a virtualization policy Pthat corresponds to each first data file D in the one or more data files D. The one or more data files D are of the same data type T.

When a server program receives one or more first data files and P from a client program the server program takes the one or more first data files and Pand stores it on a storage device. Using either a database or a known structure or protocol it associates the one or more first data files with P. For example a known protocol would be for the server to save the one or more first data files and Pinto the same server side storage folder and append a server generated UUID for each file in the one or more first data files into P. In this example a first data file D would be one of the files in the one or more first data files.

A client program does not know what derived data types are supported by a server program for a data file of data type T. Therefore a client program may request a server program to send back a list of supported derived data types. The client program may also request a list of supported parameters for each supported derived data type. The parameters allow a client program to control the output of the derived data that will be subsequently generated on demand by the server program. Once the list of supported parameters is known a client program can announce its intent to request for all supported derived data types or only a subset of supported derived data types at a future time.

As shown in a policy Pfor a first data file D is interpreted by a server program that disseminates data files to any interested and permitted client program . The server program has a policy Pfor a first data file D. The policy Pindicates the intent of a client program to access derived data files D. The server program shows to the client program a list including the first data file D its size S and additional information about the file D. If Pindicates the intent for additional derived data files D then the server program also shows additional N file entries. Each data file entry is virtual starting from file D D up to D. This means the data files D D up to Ddo not exist on the storage device . When asked for they are generated on demand dynamically. The Primary Data Stream from Data File D of size Sand of data type Tis shown by the server program in the directory listing generated using information about D and information provided in P. If Palso indicates the client program s intent to use derived virtual data files D the server program generates N additional directory entries for dynamically generated virtual derived data file D dynamically generated virtual derived data file D up to and including dynamically generated virtual derived data file D.

An example of a RESTful HTTP GET request to obtain a list of PC for a Tof Point Cloud LiDAR LAS files is provided below as described above with respect to and .

An example of a RESTful HTTP POST request to obtain a list of PC for a Tof Point Cloud LiDAR LAS files is provided below as described above with respect to and . The value of length is the number of bytes of subsequent data in the HTTP request.

Based on the prior example of an HTTP GET or POST request of GetPolicyCapabilities an example of a response from the server program is provided below. Such a response is dependent on the specification for communication between a client program and the server program .

An example of a RESTful HTTP POST request to send Pto the data storage server program is provided below as described above with respect to and . The service may return a policy identifier UUID to permit subsequent data file D uploads that are linked to this policy.

An example of a RESTful HTTP POST request to send D to the data storage server program is provided below as described above with respect to and . The service could return a file identifier per file in D to permit client side data integrity management.

An example of a RESTful HTTP POST request to send both Pand D to the data storage server program is provided below as described above with respect to and an. The service could return a file identifier for file D to permit client side data integrity management.

In one embodiment the server program provides a service to any interested and permitted client program to get a directory listing of the first data file D and a one or more one or more derived virtual data files D. The total number and type of derived virtual data files depends on the intent of a client program to access the total number and type of derived virtual data files as specified in the data virtualization policy P where P is associated with the first data file D . The data file D physically exists on the server side storage device . A one or more second derived data files Dexist virtually on the server side i.e. the one or more second derived data files Ddo not exist physically as a sequence of bytes on the server side storage device but the server program presents to the client program that such files exist.

As shown in S and O may not be aligned to the storage device block size. To issue an unbuffered aligned direct I O operation to read S bytes starting from offset O we need to read S bytes starting from offset O where O is defined is an offset from the start of file D that is less than O and the nearest value to O that is an integer multiple of the storage device block size. Thus O is an integer multiple of B. The value of O is computed based on the formula O O O B . S is the number of bytes to read starting from offset O where S is an integer multiple of the storage device block size and S is a value such that if a computer program issues a read request of size S starting from O then the computer program has read at least S bytes starting from offset O. The value of S is computed based on the formula S O O S B O O S B B. To read S bytes starting from offset O from data file D we issue an unbuffered aligned direct I O read request to read aligned S bytes starting from aligned offset O for example READ UNBUFFERED USING DIRECT IO from a file for example FILE starting from offset O of size bytes into computer memory for example MEMORY BUFFER.

As it can be appreciated the operation A B between two integers A and B includes calculating the remainder of A divided by B. For example 1024 512 is 0 1023 512 is 511 and 1025 512 is 1. In A B the operator is the modulo operator representing the mathematical operation A modulo B also represented as A mod B or A MOD B. The operation A B between two integers A and B represents calculating the difference between A and B and taking the positive value of the difference between A and B. However as it can be appreciated if the difference between A and B is positive then the operation of taking the absolute value may not be needed. Therefore the symbol A B such as in O O should be interpreted herein broadly to mean calculating the difference between A and B with or without taking the absolute value of the difference.

As shown in S is a value that is greater than or equal to S and S is an integer multiple of B. Its value is computed as S S B S B B. To read the entire file D one needs to read Sbytes. Since we are using an unbuffered aligned direct I O operation we need to issue a read request of size aligned to B. That size is S . To read entire file D of size S we issue an unbuffered aligned direct I O read function for example READ UNBUFFERED USING DIRECT IO from a file for example FILE starting from offset O of size S bytes into computer memory for example MEMORY BUFFER.

As shown in the method begins at S. The server program receives a HTTP GET request Gfrom a client program at S. At S in the GET request G a client program has requested for one of two possible types of a GET request. The client program has either issued a first request of type GET byte range to GET one or more S bytes starting from offset 0 from a first data file D or has issued a second request to GET the entire data file D where the size data file D is Sbytes and Sis greater than 0. The first request size of one or more S bytes starting from offset of O such that O is greater than or equal to zero and S O is less than or equal to S. At S the request is validated for example for request syntax correctness valid data range existence of the file and security access rights. At S the method checks to see if the request was a first GET byte range request or a second request to get the entire data file D. If it was a first GET byte range request then the method continues at S. If it was not a GET byte range request then it was a second request to get the entire data file D of size S and the method continues at S. At S the method checks if the GET byte range request asked for the entire file that is it checks to see if S is Sand of O is zero. If yes the first byte range request is equivalent to the second request to get the entire file and the method continues at S. If no the first byte range request continues at S.

As shown in at S the method computes S that is aligned to B an integer multiple of the storage device block size using the formula S S B S B B. At S the method issues a read request for S bytes from the start of data file D. The read request includes one or more Unbuffered Aligned Direct JO read operations also aligned to B. The requested data is transferred into computer memory. Since S may be greater than S and since Sis the size of the data file D the read operation may request for data past the end of file EOF marker. Reading past the EOF marker is permitted in the POSIX standard. At S Sbytes of data file D are transmitted or sent from computer memory to the client program over a computer network as part of a response to the GET request G. The method ends at S.

As shown in just prior to S the method has verified that the request is a first GET byte range request for S bytes starting from offset O within the data file D. At S the method computes S and O aligned to B an integer multiple of the storage device block size using the formulae O O O B and S O O S B O O S B B. At S the method issues a read request to read S bytes starting from offset O relative to the start of data file D. The read request includes one or more Unbuffered Aligned Direct JO read operations also aligned to B. The requested data is transferred into computer memory. The first GET byte range request asked for data starting from offset O. Bytes from offset O to O were not requested. In computer memory the bytes start from offset O . Therefore at S the method sends or transmits S bytes starting from offset O O in the computer memory as a valid response to the GET request G to the client program over a computer network. The method ends at S.

As shown in the method begins at S. The server program receives a HTTP GET request Gfrom a client program at S. In G the client program has issued either a GET byte range request for a one or more S bytes starting from offset Ofrom a second virtual derived data file Dor has issued a GET request to retrieve the entire second virtual derived data file D. The request Gis validated at S for example for syntax and security. The server program loads the data virtualization policy P associated with D and validates Das a valid deliverable virtual derived data file at S. Using Pand D the size Sof Dis computed at S. The values of Oand Sare validated against S such that 0 O

As shown in at S the method generates partial data for virtual file D by reading and processing some or all bytes from the first data file D. The partial data is Sbytes in size and represents data within the virtual derived data file D starting from virtual offset O as if it were a physical file on a storage device. The method then continues to S where the S bytes are transmitted or sent to a client program as part of the response to G. At S the method generates the complete Sbytes for Din computer memory using data in Pand reading D as a whole or in part. The method then transmits at S Sbytes starting from offset Ofrom the Sbytes of computer memory to client program as part of the response to G. The method ends at S. When reading from the first data file D one or more unbuffered aligned direct I O read operations are performed. Each read operation reads a specified number of bytes that are an integer multiple of B from an offset that is an integer multiple of B where Bis an integer multiple of the storage device block size of the storage devices containing the data and is based on the method depicted in .

Various parts of the embodiments of the present invention perform one or more read operations from a first data file D for example as specified in S and S in the flowchart depicted in and in S and S in the flowchart depicted in . The read operation itself is implemented using an interface based on the POSIX standard. To read data starting from any offset O an aligned offset O O O B is computed. To read any S bytes starting from any offset O an aligned size S O O S B O O S B Bis computed. A read operation starting at O and having a size of S bytes is sufficient to efficiently read all data starting from 0 and having a size of S bytes. If for example the entire data file D of size Sis to be read an aligned size S S B S B Bis computed. S can be past the end of first data file D. The POSIX specification permits a read operation past the end of a data file. If the S is too large in size the read request can be broken up into more than one read requests each of a size that is an integer multiple of B. Bis an integer multiple of the storage device block size of the storage devices containing the data.

As it can be appreciated from the above paragraphs a server program is a computer program that is configured to run on a computer system e.g. a computer server having one or more processors and a client program is a computer program that is configured to run on a computer system e.g. a client computer having one or more processors . The computer systems running the client program and the server program can be the same or different computer systems. The computer system running the server program or the computer system running the client program or both can include one or more computers. The client program may be running on one or more computers. Similarly the server program may be running on one or more computers. The computer systems running client programs and server programs communicate with each other over a network. The network may be a wired network a wireless network e.g. a cellular network the internet etc.

In some embodiments programs for performing the methods or services in accordance with embodiments of the invention can be embodied as program products in a computer system such as a personal computer or server or in a distributed computing environment comprising a plurality of computers. The computer may include for example a desktop computer a laptop computer a handheld computing device such as a PDA a tablet etc. The computer program e.g. server program client program products may include a computer readable medium or storage medium or media having instructions stored thereon used to program a computer to perform the methods described above. Examples of suitable storage medium or media include any type of disk including floppy disks optical disks DVDs CD ROMs magnetic optical disks RAMs EPROMs EEPROMs magnetic or optical cards hard disk flash card e.g. a USB flash card PCMCIA memory card smart card or other media. Alternatively a portion or the whole computer program product can be downloaded from a remote computer or server via a network such as the internet an ATM network a wide area network WAN or a local area network.

Stored on one or more of the computer readable media the program may include software for controlling both the hardware of a general purpose or specialized computer or processor. The software also enables the computer or processor to interact with a user via output devices such as a graphical user interface head mounted display HMD etc. The software may also include but is not limited to device drivers operating systems and user applications.

Alternatively instead or in addition to implementing the methods described above as computer program product s e.g. as software products embodied in a computer the method described above can be implemented as hardware in which for example an application specific integrated circuit ASIC or graphics processing unit or units GPU can be designed to implement the method or methods of the present invention.

The various databases described herein may be include or interface to for example an Oracle relational database sold commercially by Oracle Corporation. Other databases such as Informix DB2 Database 2 or other data storage including file based or query formats platforms or resources such as OLAP On Line Analytical Processing SQL Standard Query Language a SAN storage area network Microsoft Access or others may also be used incorporated or accessed. The database may comprise one or more such databases that reside in one or more physical devices and in one or more physical locations. The database may store a plurality of types of data and or files and associated data or file descriptions administrative information or any other data.

Although the various steps of the above method s are described in the above paragraphs as occurring in a certain order the present application is not bound by the order in which the various steps occur. In fact in alternative embodiments the various steps can be executed in an order different from the order described above.

Although the invention has been described in detail for the purpose of illustration based on what is currently considered to be the most practical and preferred embodiments it is to be understood that such detail is solely for that purpose and that the invention is not limited to the disclosed embodiments but on the contrary is intended to cover modifications and equivalent arrangements that are within the spirit and scope of the appended claims. For example it is to be understood that the present invention contemplates that to the extent possible one or more features of any embodiment can be combined with one or more features of any other embodiment.

Furthermore since numerous modifications and changes will readily occur to those of skill in the art it is not desired to limit the invention to the exact construction and operation described herein. Accordingly all suitable modifications and equivalents should be considered as falling within the spirit and scope of the invention.

