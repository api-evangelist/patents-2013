---

title: Storing encrypted objects
abstract: An encrypted resource is stored in association with an access control list. A request to retrieve the resource is received. The wrapped key and the authentication credentials are sent, from the application server system, to a key server system. An unencrypted version of the resource encryption key is received from the key server system if the key server system determines that the authentication credentials correspond to a user in the group of users identified by the group identifier. The stored encrypted resource is decrypted using the received unencrypted version of the resource encryption key to generate an unencrypted version of the resource. The unencrypted version of the resource is sent, from the application server system, to the client application.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09148283&OS=09148283&RS=09148283
owner: Google Inc.
number: 09148283
owner_city: Mountain View
owner_country: US
publication_date: 20131030
---
The present application is a continuation application of and claims priority to U.S. application Ser. No. 13 110 361 filed May 18 2011 which claims priority from U.S. Provisional Application Ser. No. 61 346 005 filed May 18 2010. The contents of the prior application are incorporated herein by reference in their entirety.

Hosted or cloud based storage refers to off site or remote data storage that is typically provided by a third party. The third party may implement the hosted storage in a data center and provide access to the hosted storage over a network such as the Internet.

Encryption is the process of converting data sometimes called plaintext using an algorithm and an encryption key to make it unreadable to anyone except those possessing the encryption key. The result of the process is encrypted information sometimes called ciphertext.

In a first aspect a method performed by one or more processors includes storing an encrypted resource at a hosted storage service and in association with an access control list. The access control list specifies a group identifier that identifies a group of users that can access the resource and a wrapped key associated with the group identifier. The wrapped key includes an encrypted resource encryption key. The resource encryption key is able to decrypt the encrypted resource. The method includes receiving at an application server system of the hosted storage service and from a client application executing on a client system a request to retrieve the resource. The request includes authentication credentials. The method includes sending from the application server system the wrapped key and the authentication credentials to a key server system. The method includes receiving at the application server system an unencrypted version of the resource encryption key from the key server system if the key server system determines that the authentication credentials correspond to a user in the group of users identified by the group identifier. The method includes decrypting at the application server system the stored encrypted resource using the received unencrypted version of the resource encryption key to generate an unencrypted version of the resource. The method includes sending from the application server system the unencrypted version of the resource to the client application.

In a second aspect a computer system includes a key server system configured to store an encrypted resource at a hosted storage service and in association with an access control list. The access control list specifying a group identifier that identifies a group of users that can access the resource and a wrapped key associated with the group identifier. The wrapped key including an encrypted resource encryption key wherein the resource encryption key is able to decrypt the encrypted resource. The key server system is configured to receive at an application server system of the hosted storage service and from a client application executing on a client system a request to retrieve the resource. The request including authentication credentials. The key server system is configured to send from the application server system the wrapped key and the authentication credentials to a key server system. The key server system is configured to receive at the application server system an unencrypted version of the resource encryption key from the key server system if the key server system determines that the authentication credentials correspond to a user in the group of users identified by the group identifier. The key server system is configured to decrypt at the application server system the stored encrypted resource using the received unencrypted version of the resource encryption key to generate an unencrypted version of the resource. The key server system is configured to send from the application server system the unencrypted version of the resource to the client application.

In a third aspect a computer readable medium stores operations that when executed by one or more processing devices cause the one or more processing devices to perform operations including storing an encrypted resource at a hosted storage service and in association with an access control list. The access control list specifies a group identifier that identifies a group of users that can access the resource and a wrapped key associated with the group identifier. The wrapped key includes an encrypted resource encryption key. The resource encryption key is able to decrypt the encrypted resource. The operations include receiving at an application server system of the hosted storage service and from a client application executing on a client system a request to retrieve the resource. The request including authentication credentials. The operations include sending from the application server system the wrapped key and the authentication credentials to a key server system. The operations include receiving at the application server system an unencrypted version of the resource encryption key from the key server system if the key server system determines that the authentication credentials correspond to a user in the group of users identified by the group identifier. The operations include decrypting at the application server system. The stored encrypted resource using the received unencrypted version of the resource encryption key to generate an unencrypted version of the resource. The operations include sending from the application server system the unencrypted version of the resource to the client application.

Implementations of the foregoing aspects can include any all or none of the following features. The group of users can be managed by a provider of the hosted storage service for reasons other than storage permissions and existed prior to the storage of the encrypted resource at the hosted storage service. The group identifier can be a single username associated with the group of users an e mail address associated with the group of users or a domain name associated with the group of users. The group of users may not exist prior to the storage of the encrypted resource at the hosted storage service. The method can include receiving a group addition request from the client application. The group addition request can specify the group of users and the group identifier. The group identifier can be inserted into the access control list. The wrapped key can also include the group identifier in encrypted form.

Receiving an unencrypted version of the resource encryption key from the key server system if the key server system determines that the authentication credentials correspond to a user in the group of users identified by the group identifier can include decrypting at the key server system the received wrapped key to generate an unwrapped key that includes the resource encryption key and the group identifier in unencrypted form. The group identifier can be accessed from the unwrapped key at the key server system. The received authentication credentials can be determined to correspond to a user in the group of users identified by the accessed group identifier at the key server system. In response to determining that the received authentication credentials correspond to a user in the group of users identified by the accessed group identifier the resource encryption key in unencrypted form can be sent from the key server system to the application server system. A service associated with the wrapped key can be identified. Decrypting the received wrapped key can include decrypting the received wrapped key using a master key associated with the service.

The details of one or more implementations are set forth in the accompanying drawings and the description below. Other features and advantages will be apparent from the description and drawings and from the claims.

A hosted storage system can provide data storage for a variety of applications. The hosted data storage can receive data resources associate the resources with user accounts and provide access to the resources to authorized users. A system of buckets can be used to index the data storage space and permission properties can be assigned to the buckets or to the resources stored in the buckets.

The resources stored in the buckets can be encrypted with resource encryption keys held in wrapped keys. Access to the resource encryption key can be provided by a keystore server that can ensure a user of the application server has authorization to access the resource encryption key. If the user is authorized the keystore server can unwrap the wrapped key and provide the resource encryption key to the application server. The keystore need not store any of the wrapped keys instead only having access to a wrapped key when receiving a request to unwrap it.

The system can provide scalable stores for storing data resources. The client device can upload data resources to the hosted storage service and control access to the uploaded data resources. Access control can include a range of security levels from keeping data securely confidential to publishing it without restrictions. Data stored in hosted storage service can be secured from unauthorized access. The hosted storage service can use a simple and consistent application programming interface or API which can allow arbitrary quantities of structured or unstructured data to be kept private or shared between individuals organizations or with the world at large. The client device can store data in the hosted storage service for mutual business reasons e.g. submission of work product ordered by the owner of the hosted storage service or for use in data processing by other services e.g. images uploaded are used to automatically and dynamically create a photo gallery web page. 

The client device can be implemented using a computing device such as the computing device or the mobile device described with respect to . The client device can communicate with the hosted storage service via a network such as the Internet. The client device can communicate across the network using communication protocols such as for example one or more of Transmission Control Protocol Internet Protocol TCP IP Hypertext Transfer Protocol HTTP Secure Shell Remote Protocol SSH or Application Program Interfaces API . While only a single client device is shown there can be multiple client devices communicating across the network with the hosted storage service and or other services and devices.

The hosted storage service can be implemented such that client applications such as a client application can store retrieve or otherwise manipulate data resources in the hosted storage service . The hosted storage service can be implemented by one or more server devices which can be implemented using a computing device such as the computing device or mobile device described with respect to . For example the hosted storage service can be implemented by multiple server devices operating in the same or different data centers.

The hosted storage service generally includes an interface frontend an interface backend a storage backend metadata for resources stored in the storage backend and a keystore . In general the interface frontend may receive requests from and send responses to the client device . For instance the hosted storage service can be implemented as a Web Service with a corresponding set of Web Service Application Programming Interfaces APIs . The Web Service APIs may be implemented for example as a Representational State Transfer REST based HTTP interface or a Simple Object Access Protocol SOAP based interface.

An interface frontend can receive messages from the client and parse the request into a format usable by the hosted storage service such as a remote procedure call RPC to an interface backend . The interface frontend writes responses generated by the hosted storage service for transmission to the client . In some implementations multiple interface frontends are implemented for example to support multiple access protocols.

The interface frontend can include a graphical front end for example to display on a web browser for data access. The interface frontend can include a sub system to enable managed uploads and downloads of large files e.g. for functionality such as pause resume and recover from time out . The interface frontend can monitor load information and update logs for example to track and protect against denial of service DOS attacks.

As described above the Web Service API may be a REST based HTTP interface. In a REST based interface a data resource is accessed as a resource uniquely named using a URI and the client application and service exchange representations of resource state using a defined set of operations. For example requested actions can be represented as verbs such as by HTTP GET PUT POST HEAD and DELETE verbs. The GET verb may be used to retrieve a resource while the HEAD verb may be used to retrieve information about a resource without retrieving the resource itself. The DELETE verb may be used to delete a resource from the hosted storage service . The PUT and POST verbs may be used to upload a resource to the service . PUT requests can come from the client and contain authentication and authorization credentials and resource metadata in a header such as an HTTP header. POST requests can be received when a client wants to upload from a web browser form. The form POST upload protocol for the hosted storage service can involve multiple required form fields to provide authentication authorization and resource metadata. More generally any of the API requests may include credentials for authentication and authorization for example in a header of the request. For example an authorization header may be included in the REST requests which include an access key to identify the entity sending the request.

Alternatively or additionally a user can be authenticated based on credentials stored in a browser cookie which gets appended to the API requests. If no valid cookie is present a redirect to an authentication frontend can be generated and the authentication frontend can be used to generate the browser cookie. The authentication frontend can be used by systems and services in addition to the hosted storage service e.g. if the organization operating the hosted storage service also operates other web services such as email service. A user can also or alternatively be authenticated based on authentication credentials from an external credentialing service or an external service that includes credentialing functionality. User or group identifier information can be calculated from the external service s credential information. Requests sent by the client to the interface frontend can be translated and forwarded to the external service for authentication.

In general resources stored in the hosted storage service can be referenced by resource identifiers. The hosted storage service can define namespaces to which a valid resource identifier must conform. For example the namespace may require that resource identifiers be a sequence of Unicode characters whose UTF 8 encoding is at most 1024 bytes long. As another example the namespace may require that resource identifiers be globally unique identifiers GUIDs which may be 128 bit integers.

Resources can be stored in hosted storage service in buckets. In some examples each bucket is uniquely named in the hosted storage service each resource is uniquely named in a bucket and every bucket and resource combination is unique. Resources may be uniquely identified by a URI that includes the bucket name and the resource name and identifies the hosted storage service . For example a resource named long song.mp3 in a bucket named music could be specified using a URI pattern such as http s.hostedstoragesystem.com music long song.mp3 or http music.s.hostedstoragesystem.com long song.mp3. Alternatively the user of the client can create a bucket named www.music.org publish a CNAME alias redirecting that to http music.s.hostedstoragesystem.com and address the resource as http www.music.org long song.mp3. In some examples buckets do not nest.

The interface backend can handle request authentication and authorization can manage data and metadata and can track activity such as for billing. The interface backend can provide functionality for independent frontend backend scaling for resource utilization and responsiveness under localized heavy loads. Data management can be encapsulated in the interface backend while communication serving can be encapsulated in the interface frontend . The interface backend can isolate security mechanisms from the client facing interface frontend .

The interface backend can expose an interface usable by both the interface frontend and other systems. In some examples some features of the interface backend are accessible only by an interface frontend not shown used by the owners of the hosted storage service internal users . Such features can include those needed for administrative tasks e.g. resolving a resource reference to a low level disk address. The interface backend can handle request authentication e.g. ensuring a user s credentials are valid and authorization e.g. verifying that a requested operation is permitted. The interface backend can also provide encryption and decryption services to prevent unauthorized access to data even by internal users.

The interface backend can manage metadata associated with data resources for example in a structured data format such as a database e.g. MySQL or BigTable . User specified names labeling the buckets can be completely defined within the metadata and resource metadata can map a resource name to one or more data shares storing the resource. The metadata can also contain bucket and resource creation times resource sizes hashes and access control lists ACL for both buckets and resources. The interface backend can log activity and track storage consumption to support accounting for billing and chargebacks. In some examples this includes quota monitoring in each dimension in which customers are charged e.g. reads writes network transfers total storage in use. 

The ACLs define who is authorized to perform actions on corresponding buckets or resources and the nature of the permitted actions. The ACLs can be an unordered list of scope role pairs plus Boolean flags. The scope may define a user or group of users and the role may define the access permissions for the user or group. In some examples the union of all scope role pairs can define access rights. In some examples more specific scope role pairs override more general ones. Table 1 Bucket Roles below shows a list of example roles that can be included in ACLs for buckets. Table 2 Resource Roles below shows a list of example roles that can be included in ACLs for data resources.

Scopes can be defined to a single user or a group of users. In one implementation those users with a FULL CONTROL role and therefore able to modify the ACL for a given bucket or resource may define a group of users and then provide a role for the group. For example a group of users may be managed by the hosted storage service or more generally by the service provider that provides the hosted storage service for reasons other than storage permissions for example for a message board or other service that employs groups and those groups may be identified by a single username or other identifier associated with the group of users an e mail address associated with the group of users which may or may not also correspond to an identifier of the group or a domain name associated with a group. This may allow a user to specify a preexisting group managed by the service provider that is already defined by the identifier e mail address or domain name. Similarly users may be able to specify a group of users for example by user id or e mail address and associate an access key with the group. This may allow for the formation of ad hoc groups for the management of storage permissions rather than groups already managed by the service provider.

In this way a group of users can be given a particular role simply by managing the role of the group. Similarly if the ACL is associated with a bucket containing a number of resources or the ACL is otherwise associated with multiple resources the role with respect to those resources can be easily changed by simply changing the role of the group.

Table 3 Scopes below shows a list of example scopes that can be included in ACLs for buckets and or data resources.

The FULL CONTROL role can represent all possible capabilities such as those assigned to a resource or bucket owner connected to a financially responsible party. The bucket owner can be configured to always have FULL CONTROL for the bucket. In general the bucket and or resource owner can create or modify scopes and roles in the corresponding ACLs but in some implementations the pair bucket owner FULL CONTROL may be prevented from being removed from the bucket ACL or the resource ACL . To create a resource a user can have write permission on the bucket which can be granted by WRITE and FULL CONTROL. WRITE permission on the bucket can imply permission to delete or overwrite a resource in the bucket. Additional constraints can disallow certain modifications to ACLs . In some examples it is possible to create a resource that the bucket owner cannot read.

A given ACL can include a resource encryption key for an encrypted data resource associated with the ACL and stored in the hosted storage service or in other services not shown . The resource encryption key itself has been encrypted by the keystore . The encrypted key can also carry associated metadata that is cryptographically bound to the key itself. Such keys are referred to as wrapped keys. From the point of view of the interface backend the wrapped keys can be opaque resources. To obtain the cleartext key of a wrapped key for use e.g. to encrypt or decrypt a data resource the interface backend can provide the wrapped key and client authentication credentials to the keystore . The keystore can verify based in part on the wrapped key s metadata that the provided authentication credential is sufficient to authorize release of the key and if so can return the unwrapped key to the interface backend . The interface backend can use the key to encrypt or decrypt the data resource and then can discard the key.

In various implementations the group exercising administrative control of the interface backend and the group exercising administrative control over the keystore may be different. This may provide greater security for the stored data because two parties would need to cooperate to access resource encryption keys.

In some examples the resource encryption key is a symmetric key that can be used to both encrypt and decrypt a resource. A wrapped key can have associated metadata indicating multiple users or groups authorized to access the cleartext key.

In some cases the keystore can copy a wrapped key and rewrap the key for a different principal e.g. containing different metadata . This may be considered the basis for the sharing of resources using a transitive trust model which means a user must first have access to a resource before he or she can share that resource with another. As an example the interface backend may receive a request from a first user to share a wrapped key or a resource encrypted with a wrapped key with a second user. The interface backend can retrieve the wrapped key from an ACL and send to the keystore the wrapped key authentication credentials for the first user and a user identifier for the second user. They keystore can unwrap the wrapped key ensure that the first user s authentication credentials match the wrapped key s user identifier and rewrap the wrapped key with the second user s identifier. The keystore can return the new wrapped key to the interface backend who can store the new wrapped key in the ACL in association with the second user.

The resource encryption key can be generated by for example the interface backend and or the keystore . For example the interface backend can generate random or pseudo random data to use as the resource encryption key. In another example the interface backend can request a new resource encryption key from the keystore and the keystore can return random or pseudo random data for use as the resource encryption key.

Alternatively the interface backend can request a resource encryption key from the keystore . For example the interface backend can identify a seed value from a data resource to be encrypted and send that seed value to the keystore . The keystore can generate a resource encryption key from the seed value and return it to the interface backend.

In some implementations the keystore can use a deterministic process to produce resource encryption keys from seeds. That is the resource encryption key returned by the keystore may always be the same for a provided seed value. In these implementations if the interface backend uses a deterministic encryption technique to encrypt the data resources identical data resources will have identical ciphertexts.

In this case the hosted storage system may be designed to identify and deduplicate data resources that are identical. For example if the hosted storage system stores email attachments it may be likely that many emails may contain identical attachments e.g. a popular video image files in HTML newsletters . If the interface backend uses the attachment data resources or a hash calculated from the data resources as seed values the resultant resource encryption keys generated by the keystore will be identical for each identical data resource . If the interface backend uses a deterministic encryption algorithm to encrypt the data resources the resultant cypertext of the encrypted data resources can be identical. With multiple copies of identical encrypted data resources in the datastores the interface backend can perform deduplicating processes to reduce the storage space used by the identical encrypted data resources . For example if an encrypted data resource is identical to another encrypted data resource the interface backend may delete the extra copy and replace it with a pointer to the other instance of the encrypted data resource .

There are other cases in which the interface backend may request a resource encryption key from a seed value from the keystore . For example the interface backend may use user authentication data as a seed value. They keystore can require that the user be authenticated by the keystore before supplying a resource encryption key based on user authentication data. When storing user preferences as data resources the interface backend can use that user s authentication data as a seed value.

The storage backend can contain multiple datastores . Although three datastores are shown more or fewer are possible. Each of the datastores can store data resources in a particular format. For example data store can store a data resource as a Binary Large Object BLOB data store can store a data resource in a distributed file system e.g. Network File System and data store can store a data resource in a structured data format such as a database e.g. MySQL .

In some implementations the hosted storage system can receive a request to encrypt data from one user using another user s wrapped key. For example the client application can upload a data file and a wrapped key to the hosted storage service with a request to encrypt the data file with the resource encryption key in the wrapped key. In this example the user of the client application need not be the user specified in the wrapped key s user identifier. Here the keystore can act like a so called encryption oracle that provides similar functionality as that found in a public key cryptography system.

The interface backend can send the received data file and the wrapped key to keystore with a request to encrypt the data file with the wrapped key. The keystore can unwrap the wrapped key and use the resource encryption key to encrypt the data file. The wrapped key may be discarded by the keystore and the encrypted data file can be returned to the interface backend . The interface backend can then return the encrypted data file to the client application . As such the user of the client application can receive the encrypted data file without ever having access to the resource encryption key within the wrapped key.

The data resource is any resource that a system operator may want to protect via encryption. An ACL is associated with the data resource and describes the access permissions for the data resource . Here a user Alice has READ and WRITE access and a user Dr. Bob has READ access.

A resource encryption key K Bar can be generated by for example the interface backend or the keystore and used to encrypt the data resource . The ACL can be modified to store a wrapped key for each user entry. Each wrapped key can contain the resource encryption key K Bar metadata identifying the data resource and user identification information. Each of the wrapped key is generated by the keystore using a master key K Master.

The user identification information may be associated with a single user e.g. Alice or Dr. Bob as shown or with a group of users. For example user identification information for wrapped keys can identify any of the scopes for the ACL described previously in Table 3 including Service Group ID Group Restricted Key All Service Users and All Users.

The encrypted data resource and ACL may be stored together for example in adjacent memory locations which may result in the data resource and the associated wrapped keys being stored together minimize memory reading operations. Alternatively the data resource and ACL may be store separately for example in a datastore and metadata . When one of the users Alice or Dr. Bob attempt to access the encrypted data resource the wrapped key and the user s authentication credentials can be sent to the keystore . If the sent authentication credentials correspond to the user identifier or group identifier in the wrapped key the keystore can return the resource encryption key K Bar in unencrypted form to the interface backend and the encrypted data resource can be decrypted.

The ACL can contain one entry per principal with one wrapped key per entry. Each wrapped key can be completely decoupled from other wrapped key and entries in the same ACL . That is a change to one entry and or wrapped key does not affect the other wrapped keys. As such access to the data resource can be managed at a granular level by adding removing or editing individual ACL entries. For example to remove access for the Dr. Bob user the interface backend can delete the Dr. Bob entry in the ACL no adjustment to the other entries in the ACL or to the data resource may be needed.

In some implementations a wrapped key can be stored in the ACL for invited and or shared users. For example if Alice would like to share the data resource with other principals the interface backend can create an entry in the ACL for other users. The interface backend can request from the keystore a wrapped key for the data resource containing a secret token e.g. a random character string . The hosted storage system can provide the secret token to Alice to distribute or can distribute the secret token on Alice s behalf. For example the hosted storage system can generate an email for Alice that invites the recipients to access the data resource via a URI that has the secret token embedded. The URI can be an address of a request to the hosted storage system to access the data resource .

The interface backend can send the secret token wrapped key and the received secret token to the keystore . If the wrapped secret token and the received secret token match the keystore can return the resource encryption key permitting the interface backend to decrypt and provide the data resource .

In some implementations the secret token wrapped key can also contain a user identifier for example if Alice intends to only share the data resource with a particular principal. In these cases the keystore can verify the user authentication credentials of the requesting user as well as the secret token in order to return the resource encryption key.

A request is received by the interface frontend from the client application to store a resource . The request can include a HTTP PUT or POST request an authentication credential that authenticates the principal entity making the request a data resource and a target for the resource consisting of a bucket and data resource name. In some examples the authentication credentials can include an interoperable authentication header token or cookie. The interface frontend can make a RPC to the backend including the request headers.

The interface backend can examine and validate the authentication credentials . For example native credentials e.g. user ID token can be validated using internal validation features of the hosted storage service . External credentials e.g. user names and passwords for another system can be sent to the associated external system for validation.

The interface backend can query the request s target bucket s ACL to determine if the authenticated principal is permitted to create a resource in the bucket . For example the principal or a group the principal is a member of can have the WRITE or FULL CONTROL role assigned in the bucket s ACL which would allow the principal to create a resource in the bucket. If the principal is not authorized to create a resource the request is denied.

Otherwise the interface backend uploads the resource to the target bucket with the target data resource name to a datastore . In some examples each bucket is associated with only a single datastore and specifying a target bucket specifies a datastore . In some examples the interface backend can examine the data resource or use a parameter in the RPC from the interface frontend to determine which datastore to store the resource in with associated metadata indicating the location of the resource that is the particular datastore the resource is stored in and the resource s location in that datastore .

The interface backend can encrypt the resource using a resource encryption key. In some examples the interface backend can perform this encryption before or after uploading the resource to the target bucket. The interface backend can generate the resource encryption key for example by sampling a pseudo random number generator or calculating a hash value of data such as the resource or an input stream. Alternatively the interface backend can generate a seed value and request a resource encryption key from the keystore based on that seed value. Example seeds can include but are not limited to user identifier e.g. a userID or principalID scope values resource identifiers and arbitrary byte strings.

The interface backend re validates the principal s authentication and authorization . To support long running uploads expiry times of authentication credentials can be temporarily ignored and instead the action can be substantially repeated.

The interface backend generates a new resource key request to the keystore for a wrapped key for the newly uploaded resource . The request can include the resource encryption key a resource identifier for the newly uploaded resource and a user identifier for the principal that uploaded the resource. The keystore generates and encrypts a wrapped key and can provide the wrapped key to the interface backend . The wrapped key can include the resource encryption key resource identifier and user identifier in the request from the interface backend .

The interface backend creates an ACL representing the access control list for the newly created resource . In some example a default ACL is used or an ACL can be specified by the request from the client .

The interface backend generates a new wrapped key request to the keystore for a wrapped key for every principal user or group in the ACL with permissions to read the resource or modify the resource s ACL . Each new wrapped key is tied to a single principal user or group and contains the resource identifier and resource encryption key used to encrypt the resource.

For example the request received by the interface frontend from the client application may indicate one or more other principals that should have shared access to the resource. To create wrapped keys for each of the other principals the interface backend can send to the keystore a wrapped key authentication credentials for the principal that uploaded the resource and a user identifier for a different principal. The keystore can unwrap the key verify that that the received authentication credentials match the wrapped key s user identifier and rewrap the key with the user identifier for the different principal. The keystore can then return the new wrapped key for the different principal to the interface backend .

The interface backend stores the resource s ACL and wrapped keys in the resource s metadata . The resource encryption key or keys can be discarded by the interface backend .

A request is received by the interface frontend from the client application to download a resource . The request can include a HTTP GET request an authentication credential that authenticates the principal entity making the request and a target consisting of a bucket and optionally data resource name. In some examples the authentication credentials can include an interoperable authentication header token or cookie. The interface frontend can make a RPC to the backend including the request headers.

The interface backend examines and validates the authentication credentials included in the request . For example native credentials e.g. user ID token can be validated using internal validation features of the hosted storage service . External credentials e.g. user names and passwords for another system can be sent to the associated external system for validation.

The interface backend queries the request s bucket or resource ACL to determine if the authenticated principal is permitted to read the target . For example the principal or a group the principal is a member of can have the READ WRITE or FULL CONTROL role assigned which would allow the principal to read or otherwise access the target. If the principal is not authorized to read or access the resource the request is denied.

Otherwise the interface backend determines if the request is for a bucket or for a resource . If the request is for a bucket the interface backend queries for a list of the bucket s contents and the listing is returned to the client application .

If the request is for an resource the interface backend looks up the appropriate wrapped key for the given authenticated requestor from the resource s metadata . The interface backend sends the wrapped key and the authentication credentials to the keystore which can return the decrypted resource encryption key to the interface backend . The interface backend can fetch and decrypt the target resource to be returned to the client application .

Authentication credentials and a wrapped key are received at a key server system from an application server system . For example the keystore can receive authentication credentials and a wrapped key from the interface backend . The authentication credentials can specify one or more users and may take the form of a variety of formats. In one or more implementations wrapped keys may contain data that is only accessible by an application server with valid authentication credentials.

The wrapped key includes a resource identifier a resource encryption key and a user identifier that have been encrypted using a master key. The resource identifier identifies a resource encrypted with the resource encryption key and the user identifier identifies a user that is permitted to use the resource encryption key to decrypt the resource. For example the resource identifier can describe a resource with which the resource encryption key is associated. Resource ID file pathnames and universal resource locators are all examples of resource identifiers. The resource encryption key can be the cryptographic key that has been or will be used to encrypt the resource identified by the resource identifier. For the wrapped keys in the ACL the resource encryption key is K Bar the resource identifier is Bar and the user identifier is either Alice or Dr. Bob.

In some implementations the authentication credentials are a character string embedded in a uniform resource identifier URI . For example some user authentication schemes can produce a unique character string for an authorized user. That character string can be included in to URI request to identify a user associated with the request. A service associated with the wrapped key is identified . For example in addition to a wrapped key and authentication credentials a service identifier may be received. The wrapped key is decrypted with a master key associated with the service . For example the keystore may store a collection of master keys one per service which are used for encrypting and decrypting the wrapped keys associated with a single service. After identifying the service the keystore may access based on the identified service the master key associated with the identified service and use the master key to decrypt the wrapped key. For instance keystore may identify based on the identified service the master key associated with the service access the identified master key and use the accessed master key to decrypt the wrapped key. Likewise when wrapping keys keystore may identify the service identify based on the identified service the master key associated with the service access the identified master key and use the accessed master key to wrap the key. In other implementations the same master key may be used for different services.

The format of the authentication credentials and user identifier are identified . The keystore may recognize many authentication formats and the hosted storage system may use one or more of those formats to authenticate users and identify principals in the ACLs . For example the hosted storage system may use its own native authentication system and may also allow users of a third party authentication system use credentials from that third party authentication system. In this example entries in the ACLs and in wrapped keys may be in either the native or third party format. The keystore may as a preliminary authentication action determine that the format of the authentication credentials and the user identifier are the same or compatible. The keystore determines if the received authentication credentials correspond to the accessed user identifier according to the identified format . For example the keystore may use the identified format to determine the processes needed to compare the authentication credentials and user identifier. For some formats the keystore can provide the authentication credentials and user identifier to a third party authentication system and receive an indication of correspondence. For some other formats the keystore can perform the determination directly by selecting a format appropriate comparison function and using the authentication credentials and user identifier as parameters for the function. For example some formats of authentication credentials and user identifier may be comparable by determining if both consist of the same data e.g. character string cookie . If both consist of identical data then they can be considered to correspond. Some formats may require some pre processing of the authentication credentials and or user identifier for example to convert the authentication credentials into the format of the user identifier or vice versa.

In some implementations the user identifier may indicate no more than one user. For example in the ACL of each wrapped key user identifier indicates only one user Alice or Dr. Bob. In this case when more than one user is able to access the data resource multiple wrapped keys one for each user are stored in the ACL .

In some implementations the user identifier and or the authentication credentials may indicate multiple users in a group. That is the user identifier acts as a group identifier when used in relation to a group. For example Table 3 lists some example scopes that include groups of multiple users. When the keystore is determining if the authentication credentials correspond to the group specified in the user identifier the keystore may determine that the authentication credentials belong to a group identified by the user identifier instead of just strictly matching the user identifier.

If the received authentication credentials do not correspond to the accessed user identifier a failure indication is sent . For example the keystore can return to the interface backend an error or failure message that specifies that the authentication credentials do not match the user identifier in the received wrapped key.

If the received authentication credentials do correspond to the accessed user identifier the resource encryption key is sent in unencrypted form to the application server system . For example the keystore can transmit to the interface backend the resource encryption key in unencrypted form. The interface backend can then use the resource encryption key such as described in the processes and . In some implementations communication between the keystore and the interface backend can use an encrypted transfer protocol such as Transport Layer Security TLS so that the encryption key is encrypted in transport.

A seed value is received from the application server system . For example the interface backend can send a seed value to the keystore . The seed value can be based on data available to the interface backend and or arbitrary data. For example for use in encrypting user preferences the interface backend can use some data relating to each user as a seed value for a wrapped key for each user s preferences. Additionally an arbitrary character string can be appended to the seed data by the interface backend . In another case the seed can be based on the resource that is to be encrypted. For example the interface backend can send a copy of the resource to the keystore to be used as a seed value or a hash of the resource may be calculated by the interface backend and send to the keystore to be used as a seed value.

The resource encryption key is generated from the seed value . For example the keystore can use the seed value and a master key as parameters to a pseudo random function such as a keyed cryptographic hash function to generate a resource encryption key. Most or all one way functions that can be used to generate the resource encryption key are deterministic algorithm. Assuming keyed cryptographic hash function is deterministic the resource encryption key is determined by the seed value and any set of wrapped keys with identical seed values will also have identical resource encryption keys.

The resource encryption key is sent to the application server system . For example the keystore can return the newly generated resource encryption key to the interface backend for use in encrypting data resources .

The process can be used to encrypt data with a wrapped key by any actor even if the actor is not authorized to access the unwrapped key. This process can mimic functionality available in public key encryption schemes. In one or more implementations wrapped keys may be used to facilitate public key encryption functionality without requiring the computation of public key private key pairs.

A resource in unencrypted form and a wrapped key are received from an application server system . For example the keystore can receive from the interface backend an encryption request that includes an encrypted resource and a wrapped key. The request need not specify that the interface backend access or receive the resource encryption key from the wrapped key only that the keystore use it to encrypt the resource.

The wrapped key is decrypted to access the resource encryption key . For example the keystore can decrypt the wrapped key to gain access to the resource encryption key in the wrapped key. The resource is encrypted from unencrypted form into encrypted form with the resource encryption key . For example keystore can encrypt the resource using the accessed resource encryption key. Once the resource is encrypted the keystore may discard the wrapped key and the resource encryption key.

The encrypted resources are sent to the application server system . For example the keystore can return the encrypted resource to the interface backend which may forward the encrypted resource to an external system or store the encrypted resource as previously described.

Once encrypted the user identified in the wrapped key used encrypt the resource may access the resource. For example if the encrypted resource is stored in a datastore by the hosted storage system the identified user may log into the hosted storage system and access the encrypted resource. The interface backend can send to the keystore the user s authentication credentials and the wrapped key associated with the resource. Since the user s authentication credentials would match the user identifier in the wrapped key the keystore can return the resource encryption key to the interface backend. With the resource encryption key the interface backend can decrypt the resource and provide it to the user.

In some implementations a keystore that performs the process may later perform the process . For example an application server system can provide hosted email service to users. Email resources can be received by that application server even when the recipient user is not logged in. Since the recipient user may not logged in authentication credentials for that user may not available to the application server system and the application server system may not be able to successfully request the resource encryption key from the user s wrapped key. In order to encrypt the email for storage until it can be accessed by the user the application server system can send the email and the user s wrapped key to a keystore. The keystore can perform the process and return the email in encrypted form back to the application server system.

Later the user may log in making the user s authentication credentials available to the application server system. The application server system can send the user s authentication credentials to the same keystore along with the user s wrapped key. The keystore can perform the process and return the resource encryption key from the wrapped key permitting the application server system to decrypt the user s email.

Another implementation that uses the same keystore to perform the processes and could include a first user creating and giving a resource to a second user. For example a financial institution may us an application server system to generate reports or statements for each account holder. Each report or statement may be encrypted by a keystore using the process and stored on the application server system. When a user attempts to access the statement the application server system can send a request to the same keystore to perform the process so that the application server system can access the resource encryption key and decrypt the statement for the user.

In some implementations different keystores can perform the process and . For example a research firm may use an application server system to compile statistical data that includes sensitive information e.g. medical financial privacy or security information . The research firm s application server system may request a local keystore to encrypt the sensitive information with a client specific wrapped key using the process . The research firm may transmit the encrypted data to the client through any suitable type of communication channel including unsecure channels such as standard email parcel delivery or via a minimally secured internet connection. The client can receive the encrypted information at a different application server system which may offer different serves than the research firm s application server system without ever exposing the plaintext of the sensitive information to any other parties. The client s application server system can then request a different keystore to perform the process in order to access the resource encryption key to decrypt the sensitive information.

A bucket or resource is created by the backend interface based on requests from the client application . The client request can include a bucket name a resource name and or an ACL . The principal requesting the new bucket or resource is authenticated and made the owner of the bucket or resource.

If an ACL is specified in the request the specified ACL is associated with the bucket or resource. If the specified ACL does not include a scope role pair specifying the principal having FULL CONTROL one such scope role pair can be added to the ACL . In one implementation an ACL may be specified in a request by enumerating each scope and role pair to be included in the ACL or may be specified by reference to the name of a pre specified or canned ACL. A list of pre specified or canned ACLs is shown in Table 4 Canned ACLs below. The canned ACLs can be cataloged by the hosted storage system and referenced by the client application by name rather than requiring the request enumerate each scope and role pair.

If an ACL is not specified in the request a default ACL can be used . For example bucket and resource creation can default to the private canned ACL for authenticated users. For resource creation by unauthenticated users such as for new resources created in a public read write bucket a default of bucket owner full control can be used.

An ACL can be served for example to a principal with READ WRITE or FULL CONTROL of the associated bucket or resource . For example a client application can perform a HTTP GET to a target s URI with the query string acl to retrieve the ACL associated with the target. The ACL can be serialized and returned to the client application .

The serialization may be defined for example by the following extended Backus Naur form. Nonterminals appear in sans serif italics terminals appear in Courier Bold denote zero or more repetitions enclose optional entities separates alternatives and denote grouping. The terminal symbols canonical id email address and domain are defined in English below 

A canonical id or an email address can identify a user or a group. A canonical id is the encrypted service id for the user or group. Email addresses are a convenience for specifying canonical ids. In some implementations the ACLs returned from the system always contain canonical ids. The text element may be used for information purposes only such that it is otherwise ignored by the system and the system does not return it if there is no public name associated with the user or group.

An ACL can be updated for example by a principal with WRITE or FULL CONTROL of the associated bucket or resource . In some examples a client must read modify and write an ACL in order to update an ACL . In this example the ACL is served as part of modification . In some implementations a client application can send ACL update requests to the hosted storage system .

The computing device includes a processor a memory a storage device a high speed interface connecting to the memory and multiple high speed expansion ports and a low speed interface connecting to a low speed expansion port and the storage device . Each of the processor the memory the storage device the high speed interface the high speed expansion ports and the low speed interface are interconnected using various busses and may be mounted on a common motherboard or in other manners as appropriate. The processor can process instructions for execution within the computing device including instructions stored in the memory or on the storage device to display graphical information for a GUI on an external input output device such as a display coupled to the high speed interface . In other implementations multiple processors and or multiple buses may be used as appropriate along with multiple memories and types of memory. Also multiple computing devices may be connected with each device providing portions of the necessary operations e.g. as a server bank a group of blade servers or a multi processor system .

The memory stores information within the computing device . In some implementations the memory is a volatile memory unit or units. In some implementations the memory is a non volatile memory unit or units. The memory may also be another form of computer readable medium such as a magnetic or optical disk.

The storage device is capable of providing mass storage for the computing device . In some implementations the storage device may be or contain a computer readable medium such as a floppy disk device a hard disk device an optical disk device or a tape device a flash memory or other similar solid state memory device or an array of devices including devices in a storage area network or other configurations. A computer program product can be tangibly embodied in an information carrier. The computer program product may also contain instructions that when executed perform one or more methods such as those described above. The computer program product can also be tangibly embodied in a computer or machine readable medium such as the memory the storage device or memory on the processor .

The high speed interface manages bandwidth intensive operations for the computing device while the low speed interface manages lower bandwidth intensive operations. Such allocation of functions is exemplary only. In some implementations the high speed interface is coupled to the memory the display e.g. through a graphics processor or accelerator and to the high speed expansion ports which may accept various expansion cards not shown . In the implementation the low speed interface is coupled to the storage device and the low speed expansion port . The low speed expansion port which may include various communication ports e.g. USB Bluetooth Ethernet wireless Ethernet may be coupled to one or more input output devices such as a keyboard a pointing device a scanner or a networking device such as a switch or router e.g. through a network adapter.

The computing device may be implemented in a number of different forms as shown in the figure. For example it may be implemented as a standard server or multiple times in a group of such servers. In addition it may be implemented in a personal computer such as a laptop computer . It may also be implemented as part of a rack server system . Alternatively components from the computing device may be combined with other components in a mobile device not shown such as a mobile computing device . Each of such devices may contain one or more of the computing device and the mobile computing device and an entire system may be made up of multiple computing devices communicating with each other.

The mobile computing device includes a processor a memory an input output device such as a display a communication interface and a transceiver among other components. The mobile computing device may also be provided with a storage device such as a micro drive or other device to provide additional storage. Each of the processor the memory the display the communication interface and the transceiver are interconnected using various buses and several of the components may be mounted on a common motherboard or in other manners as appropriate.

The processor can execute instructions within the mobile computing device including instructions stored in the memory . The processor may be implemented as a chipset of chips that include separate and multiple analog and digital processors. The processor may provide for example for coordination of the other components of the mobile computing device such as control of user interfaces applications run by the mobile computing device and wireless communication by the mobile computing device .

The processor may communicate with a user through a control interface and a display interface coupled to the display . The display may be for example a TFT Thin Film Transistor Liquid Crystal Display display or an OLED Organic Light Emitting Diode display or other appropriate display technology. The display interface may comprise appropriate circuitry for driving the display to present graphical and other information to a user. The control interface may receive commands from a user and convert them for submission to the processor . In addition an external interface may provide communication with the processor so as to enable near area communication of the mobile computing device with other devices. The external interface may provide for example for wired communication in some implementations or for wireless communication in other implementations and multiple interfaces may also be used.

The memory stores information within the mobile computing device . The memory can be implemented as one or more of a computer readable medium or media a volatile memory unit or units or a non volatile memory unit or units. An expansion memory may also be provided and connected to the mobile computing device through an expansion interface which may include for example a SIMM Single In Line Memory Module card interface. The expansion memory may provide extra storage space for the mobile computing device or may also store applications or other information for the mobile computing device . Specifically the expansion memory may include instructions to carry out or supplement the processes described above and may include secure information also. Thus for example the expansion memory may be provide as a security module for the mobile computing device and may be programmed with instructions that permit secure use of the mobile computing device . In addition secure applications may be provided via the SIMM cards along with additional information such as placing identifying information on the SIMM card in a non hackable manner.

The memory may include for example flash memory and or NVRAM memory non volatile random access memory as discussed below. In some implementations a computer program product is tangibly embodied in an information carrier. The computer program product contains instructions that when executed perform one or more methods such as those described above. The computer program product can be a computer or machine readable medium such as the memory the expansion memory or memory on the processor . In some implementations the computer program product can be received in a propagated signal for example over the transceiver or the external interface .

The mobile computing device may communicate wirelessly through the communication interface which may include digital signal processing circuitry where necessary. The communication interface may provide for communications under various modes or protocols such as GSM voice calls Global System for Mobile communications SMS Short Message Service EMS Enhanced Messaging Service or MMS messaging Multimedia Messaging Service CDMA code division multiple access TDMA time division multiple access PDC Personal Digital Cellular WCDMA Wideband Code Division Multiple Access CDMA2000 or GPRS General Packet Radio Service among others. Such communication may occur for example through the transceiver using a radio frequency. In addition short range communication may occur such as using a Bluetooth WiFi or other such transceiver not shown . In addition a GPS Global Positioning System receiver module may provide additional navigation and location related wireless data to the mobile computing device which may be used as appropriate by applications running on the mobile computing device .

The mobile computing device may also communicate audibly using an audio codec which may receive spoken information from a user and convert it to usable digital information. The audio codec may likewise generate audible sound for a user such as through a speaker e.g. in a handset of the mobile computing device . Such sound may include sound from voice telephone calls may include recorded sound e.g. voice messages music files etc. and may also include sound generated by applications operating on the mobile computing device .

The mobile computing device may be implemented in a number of different forms as shown in the figure. For example it may be implemented as a cellular telephone . It may also be implemented as part of a smart phone personal digital assistant or other similar mobile device.

Various implementations of the systems and techniques described here can be realized in digital electronic circuitry integrated circuitry specially designed ASICs application specific integrated circuits computer hardware firmware software and or combinations thereof. These various implementations can include implementation in one or more computer programs that are executable and or interpretable on a programmable system including at least one programmable processor which may be special or general purpose coupled to receive data and instructions from and to transmit data and instructions to a storage system at least one input device and at least one output device.

These computer programs also known as programs software software applications or code include machine instructions for a programmable processor and can be implemented in a high level procedural and or object oriented programming language and or in assembly machine language. As used herein the terms machine readable medium and computer readable medium refer to any computer program product apparatus and or device e.g. magnetic discs optical disks memory Programmable Logic Devices PLDs used to provide machine instructions and or data to a programmable processor including a machine readable medium that receives machine instructions as a machine readable signal. The term machine readable signal refers to any signal used to provide machine instructions and or data to a programmable processor.

To provide for interaction with a user the systems and techniques described here can be implemented on a computer having a display device e.g. a CRT cathode ray tube or LCD liquid crystal display monitor for displaying information to the user and a keyboard and a pointing device e.g. a mouse or a trackball by which the user can provide input to the computer. Other kinds of devices can be used to provide for interaction with a user as well for example feedback provided to the user can be any form of sensory feedback e.g. visual feedback auditory feedback or tactile feedback and input from the user can be received in any form including acoustic speech or tactile input.

The systems and techniques described here can be implemented in a computing system that includes a back end component e.g. as a data server or that includes a middleware component e.g. an application server or that includes a front end component e.g. a client computer having a graphical user interface or a Web browser through which a user can interact with an implementation of the systems and techniques described here or any combination of such back end middleware or front end components. The components of the system can be interconnected by any form or medium of digital data communication e.g. a communication network . Examples of communication networks include a local area network LAN a wide area network WAN and the Internet.

The computing system can include clients and servers. A client and server are generally remote from each other and typically interact through a communication network. The relationship of client and server arises by virtue of computer programs running on the respective computers and having a client server relationship to each other.

