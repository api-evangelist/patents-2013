---

title: Performing application search based on entities
abstract: In one embodiment, a search query is received from a computing device, the search query including one or more search terms. Based on the one or more search terms, one or more entities are identified from a set of multiple entities. Each of the one or more identified entities is associated with one or more application functionalities. In addition, a set of applications are identified based on the one or more search terms. Based at least on a type of at least one of the identified one or more entities, a determination is made that a particular application from the set of applications supports the at least one of the identified one or more entities. Thereafter, the applications in the set are ranked based in part on the determination that the particular application supports the at least one of the identified one or more entities.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09092527&OS=09092527&RS=09092527
owner: Quixey, Inc.
number: 09092527
owner_city: Mountain View
owner_country: US
publication_date: 20130315
---
This application claims the benefit of U.S. Provisional Application No. 61 758 704 titled Performing Application Search Based on Entities filed Jan. 30 2013 which is incorporated by reference in its entirety.

Development of applications has exploded with the introduction of various application delivery channels e.g. app stores . In particular such application delivery channels enable developers to quickly and efficiently distribute their applications to end users. To enable the end users to rapidly locate relevant software applications various application search systems have been developed.

Many such application search systems perform searches based on keyword matches. For example a user provides a particular search query to an application search system. Responsive to the search query applications associated with keywords included in the search query are identified and search results listing the applications are returned.

The Figures FIGS. and the following description describe certain embodiments by way of illustration only. One skilled in the art will readily recognize from the following description that alternative embodiments of the structures and methods illustrated herein may be employed without departing from the principles described herein. Reference will now be made in detail to several embodiments examples of which are illustrated in the accompanying figures. It is noted that wherever practicable similar or like reference numbers may be used in the figures and may indicate similar or like functionality.

Performing searches based on keyword matching often does not provide the most relevant search results e.g. search results that are closely aligned with an intent indicated by a search query . For example a user may wish to identify and download relevant applications for the movie TOY STORY. Accordingly the user provides a search query including the terms TOY STORY to a conventional application search system. Responsive to the search query the conventional application search system performs a keyword search and identifies multiple applications with TOY STORY in their titles or descriptions. One problem with such an approach is that an important subset of relevant applications will be missing including NETFLIX which allows users to watch TOY STORY IMDB which allows users to obtain information about TOY STORY ROTTEN TOMATOES which allows users to browse reviews about TOY STORY and YOUTUBE which allows users to watch various trailers and extras for TOY STORY . Such a problem occurs because TOY STORY is not associated with the applications as keywords. Such is the case because the terms do not appear in the applications titles or descriptions.

Now referring again to the environment includes a computing device a data source and an application search system in communication with one another via a network . Only one computing device one data source and one application search system are shown in for purposes of clarity but those of skill in the art will recognize that typical environments can have hundreds thousands or millions of computing devices and data sources and can also have multiple application search systems . An example architecture for the computing device is described below and with respect to .

The network enables communications between the computing device the data source and the application search system . In one embodiment the network uses standard communications technologies and or protocols. Thus the network can include links using technologies such as Ethernet 802.11 worldwide interoperability for microwave access WiMAX 3G digital subscriber line DSL asynchronous transfer mode ATM InfiniBand PCI Express Advanced Switching etc. Similarly the networking protocols used on the network can include multiprotocol label switching MPLS the transmission control protocol Internet protocol TCP IP the User Datagram Protocol UDP the hypertext transport protocol HTTP the simple mail transfer protocol SMTP the file transfer protocol FTP etc. The data exchanged over the network can be represented using technologies and or formats including the hypertext markup language HTML the extensible markup language XML etc. In addition all or some of the links can be encrypted using conventional encryption technologies such as secure sockets layer SSL transport layer security TLS virtual private networks VPNs Internet Protocol security IPsec etc. In another embodiment the entities can use custom and or dedicated data communications technologies instead of or in addition to the ones described above. Depending upon the embodiment the network can also include links to other networks such as the Internet.

The computing device is an electronic device used by a user to access the application search system . The computing device can be any type of computer system such as a laptop desktop workstation or server. The computing device can also be another device having computer functionality such as a personal digital assistant PDA mobile telephone tablet device etc. In one embodiment the computing device is a conventional computer system executing for example a Microsoft Windows compatible operating system OS Apple OS X UNIX and or a Linux distribution. The computing device may additionally be configured to access the functionalities of various applications for varying computing environments. For example the computing device may be configured to execute a native application stored on the computing device . As used herein a native application may be a software application designed for a specific operating system executed by the computing device . As another example the computing device may be configured to execute a web browser that allows the computing device to access a web application. As used herein a web application is an application that is executed at least in part by a web server and accessed by a web browser of the computing device .

The data source is a computing system configured to provide at least one or more data records regarding various entities to the application search system . For example the data source may provide a set of data records for various movie entities. In one aspect the application search system may use the one or more data records to generate an index of entities usable for identifying entities in search queries received from the computing device .

The application search system is a computing system configured to perform searches for applications based on search queries received from the computing device . In one embodiment the application search system performs searches for applications based at least on entities identified in the search queries and application support for the identified entities. As shown in the application search system includes in some embodiments at least a search module and an entity processing module . The entity processing module may be used to identify and rank entities based on a received search query from the computing device . The search module may be used to identify and rank third party applications based on the received search query to generate a set of search results listing the identified third party applications. Such third party applications may be applications that are developed and or made available by sources different from an operator of the application search system . For example the application search system may be operated by a first company. The applications listed in the set of search results may each have been developed by other companies different from the first company. The applications listed in the set of search results may additionally be accessible from e.g. downloaded from systems different from the application search system . In one aspect the ranked entities generated by the entity processing module may be utilized by the search module to rank the identified applications.

Referring now to it shows a high level diagram of the search module and the entity processing module of the application search system . As shown in the entity processing module includes various modules for facilitating generation of search results based on entities. In particular the entity processing module includes an entities index an entity type store an application configuration store a generation module an entities index lookup module an entity parsing module and an entity ranking module .

The entity type store includes data regarding different types of entities that may be identified in search queries received from the computing device . For example the entity type store may include various entity type records including information for a movie entity type a book entity type a music entity type a math entity type a restaurant entity type etc. Any suitable information may be included in the entity type records. Illustratively an entity type record for a particular entity type may include at least an identifier for the entity type and a name for the entity type. The entity type record may furthermore indicate any data fields associated with the entity type and or a set of permitted values for each data field. As an example an entity type record for a restaurant entity type may include at least the following information 

In one aspect an entity type record may indicate an association between a corresponding entity type and a parsing function. The parsing function enables identification of an entity having the entity type in a search query. Such parsing functions may be required since certain types of entities cannot be indexed due to the total set of possible entities being very large or infinite in number e.g. the entities that are combinatorial expressions . As an example a search query may include a mathematical expression such as 81 412. Because the number of mathematical expressions is infinite it would not be possible to index all such expressions. Thus in order to identify an entity as having a math entity type a suitable parsing function for identifying well formed mathematical expressions is required. In one aspect such a parsing function may be a suitable regular expression.

In one aspect at least some of the entity type records may be associated with various data source field mappings keywords and or other indicators usable for associating a corresponding entity type with a particular entity indicated by a data record retrieved from the data source . For example a particular restaurant entity type may be associated with various keywords indicative of an entity having a restaurant entity type such as prix fixe lunch special steakhouse etc. The restaurant type entity may also be associated with a data source field mapping indicating certain data fields of data records retrieved from the data source that may include entity type information. Thus when a data record is retrieved from the data source a determination can be made as to whether an entity indicated by the data record has a restaurant entity type by checking a data field of the data record indicated by the data source field mapping for any of the keywords indicative of an entity having a restaurant entity type.

The entities index is an index of entities configured to enable the identification of entities within a received search query. In one aspect the entities index may include any suitable data regarding an entity. For example the entities index may include multiple entity records where each entity record includes an identifier for the entity keywords associated with the entity and one or more types of the entity. Each entity record may also include other data based on an entity type for an entity. For example data for an entity having a restaurant entity type may include a name for the entity and a food type associated with the entity. As a specific example data for an entity having the restaurant entity type may include name Chipotle foodType Mexican . As another example data for an entity having a movie entity type may include title data and actor data. As a specific example data for an entity having the movie entity type may include title Toy Story 3 actors Tom Hanks Tim Allen Joan Cusack . As yet another example data for an entity having an airport entity type may include airport code data and airport name data. As a specific example data for an entity having the airport type may include code SFO name San Francisco International Airport .

In one aspect the entities index may be a na ve inverted keyword index. For example an entity record for the entity TOY STORY may include the following information title Toy Story 3 actors Tom Hanks Tim Allen Joan Cusack . The entities index may be configured such that the entity record is indexed by the keywords Toy Story 3 Tom Hanks Tim Allen Joan and Cusak. Thus if any of the aforementioned keywords appear in a received search query the entity record for the TOY STORY entity would be retrieved.

The application configuration store includes one or more configuration records indicating configuration data and or other data for one or more applications. In one aspect each configuration record may indicate the entities that a corresponding application supports. For example a record for the application Wolfram Alpha may indicate that the application supports math type entities. As another example the application IMDB may indicate that the application supports television type entities.

The association between entity types and applications may be determined in any suitable manner. In one embodiment a suitable application crawler may be employed to locate and determine the entity types of various applications e.g. native applications by crawling various data sources over a network such as the Internet. In one specific embodiment to determine entity types for at least some applications the application crawler automatically assesses the supported functionalities of the at least some applications by executing and testing the at least some applications. Based on the testing various entity types may be identified and associated with the at least some applications. Such associations are then stored in the configuration records of the application configuration store corresponding to the at least some applications.

For example the application crawler may automatically identify and execute a native application. During execution the application crawler may use a set of test inputs to test the native application. Based on the testing the application crawler determines the entity types that which the native application supports. Illustratively the application crawler may execute a native media player application and automatically attempt to have the native media player application open various test files for playback. Those test files that are played successfully by the native media player application e.g. the native media player application successfully renders audio and or video streams of the test files may be determined to be supported by the native media player application. Accordingly the application crawler determines that the native media player application supports entity types associated with the successfully played test files. Such entity types may be indicated in the configuration record for the native media player application.

In one embodiment the application configuration store may be accessed by the search module to identify the types of entities supported by various applications. The application configuration store may additionally include other information about applications usable by the search module to generate search results.

The generation module generates the entities index . To generate the entities index the generation module obtains one or more data records from the data source . Then data source may be any suitable data source such as FREEBASE WIKIPEDIA etc. Each obtained data record from the data source may correspond to an entity. For example an individual data record obtained from the data source may include information for the TOY STORY entity.

For each obtained data record the generation module determines one or more entity types associated with the entity corresponding to the data record. Illustratively the generation module may determine that a TOY STORY entity is associated with a movie entity type. The generation module may determine the entity types associated with an entity in any suitable manner. For example the generation module may determine based on the entity type store the keywords and data source field mappings for different entity types. If a data record includes one or more keywords for a particular entity type within certain data fields indicated by the data source field mappings the generation module determines that the particular entity corresponding to the data record is associated with the particular entity type.

Based on the identified entity types for each entity the generation module generates one or more entity records for the entity. In one aspect the data to be included in an entity record is based on the identified type for a corresponding entity. For example an entity record for an entity corresponding to a movie entity type may include actor information. In one embodiment the specific data used to populate an entity record may be retrieved from the data record obtained from the data source corresponding to the entity. After generating the entity records for various entities the generation module builds the entities index based on the entity records. In particular the entity records may be indexed within the entities index based on the data included in the entity records.

The entity index lookup module identifies entities in the entities index based on a received search query. In one embodiment the entity index lookup module identifies entities by extracting one or more keywords from the search query and performing a search for the one or more keywords using the entities index . Illustratively a search query may include the words TOY STORY 3. Responsive to the request the entity index lookup module searches the entities index for the keywords Toy Story and 3. Based on the entities index the entity index lookup module determines an entity type common amongst the three keywords. In particular the entity index lookup module determines that all three of the keywords are each at least associated with an entity record having the movie entity type. Thus the entity lookup module selects the entity record which in the example is the entity record for TOY STORY 3. Thus the TOY STORY 3 entity record is selected for use in further processing. For example the entity record may be passed to the entity parsing module for identification of the entity types associated with the entity.

The entity parsing module identifies entity types within a search query. Identifying of the entity types may be performed in any suitable manner. In one embodiment the entity parsing module identifies the type of an entity by referencing one or more entity types included in the entity record corresponding to the entity identified by the entity index lookup module . In one embodiment the entity parsing module additionally or alternatively applies a parsing function to a received search query. The parsing function may identify types of entities included in a search query based on certain rules and or patterns identified in the search query. Illustratively the parsing function may determine that an entity includes a math entity type based on a pattern match between the search query and a predefined regular expression.

The entity ranking module scores and ranks identified entities in a search query. In particular the entity ranking module employs various heuristics to score each identified entity by an estimated probability of the entity being legitimate. For example based on contextual information for the user e.g. a geographic location that provided the search query the frequency of keywords in the search query the arrangement of keywords in the search query historical data for the user e.g. past application downloads previously requested searches etc. the entity ranking module scores each of the identified entities. Illustratively a search query may include the terms tom hanks toy movie. Because several keywords for the TOY STORY entity are included in the search query the entity ranking module may calculate a relatively high score for the TOY STORY entity. In contrast another search query may include the terms five story toy building. Because few keywords for the TOY STORY entity are included in the search query the entity ranking module may calculate a relatively low score for the TOY STORY entity. After scoring the identified entities the entity ranking module ranks the entities using the scores to generate a ranked set of entities. The ranked set of entities may then be provided to the search module for use in ranking any identified applications that match the search query.

Referring again to the search module includes various modules for generating search results e.g. a listing of applications responsive to receiving a search query. In particular the search module includes a search index a search query processing module a consideration set processing module a result set scoring module and a post processing module . Each of the modules can be processed by a one or more machines or computer systems for example having an architecture as described in the example machine in .

The search index may be an index suitably configured to enable identification of applications based on a received search query. In particular the search index may include and or is associated with one or more application records. Each application record may include information regarding one or more attributes of an application. As used herein an attribute may be any aspect of an application usable for facilitating a search for the application. For example each application record may indicate a title a developer and one or more functionalities corresponding to an application. Illustratively an application record may indicate that a particular application supports red eye removal. In one aspect the search index indexes the application records based on one or more of the application attributes. For example the search index may index the application records based on one or more application functionality attributes indicated by the application records.

The search query processing module performs preliminary processing of a search query. In one embodiment the search query processing module receives a search query from for example a computing device . The search query processing module then provides the received search query or a portion of the received search query to the entity processing module . The search query processing module may provide the received search query in any suitable manner. For example as shown in the search query processing module may perform an application programming interface API call to the entity processing module . The API call may include any suitable information. In one aspect the API call may include a command indicating to the entity processing module to identify and rank entities in a search query. The API call may additionally include as an argument the search query that which the entity processing module is to use to identify and rank entities. Responsive to providing the search query the search query processing module receives a set of ranked entities identified from the entity processing module . As will be discussed the set of ranked entities may be used to generate search results for the search query.

The consideration set processing module identifies an initial set of applications also referred to as a consideration set determined to be potentially relevant e.g. aligned with an intent of to the search query using the search index . After identifying the initial set of applications the consideration set processing module pares down the initial set of applications into a working subset of applications. The consideration set processing module may pare down the initial set of applications in any suitable manner. In one embodiment the consideration set processing module retrieves a subset of attributes corresponding to each application in the initial set. In one aspect at least some of the attributes indicate one or more functionalities of the application. For example an attribute may indicate that a particular application supports the removal of red eye. Such attributes for each application may be retrieved from a suitable source such as the search index and or the application configuration store . Based on the subset of attributes for each application the consideration set processing module generates a score for each application. The score may indicate how closely the subset of attributes of each application matches a determined intent of the search query. Based on the scores for the applications the consideration set processing module pares down the initial set of applications to generate a working subset of applications. For example the consideration set processing module may discard or remove applications that do not meet a threshold score. As another example the consideration set processing module may select a working subset of applications with the top scores.

The result scoring module scores and ranks applications in the working subset. In one aspect scoring and ranking of the applications may be based at least in part on the set of ranked entities generated by the entity processing module . In particular for each application in the working subset the result scoring module performs a lookup into the application configuration store to determine the entities that the application supports. For example the result scoring module may determine that a media player application supports playback of movie type entities. Thereafter the result scoring module computes an entity match value for each application based at least in part on the number of entities that the application supports from the set of ranked entities and or the rankings of the entities supported by the application in the set of ranked entities. For example the result scoring module may generate a higher entity match value for an application if the application supports at least one entity included in the ranked set of entities from the entity processing module and or supports an entity ranked relatively high in the ranked set. In contrast the result scoring module may generate a lower entity match value for the application if the application does not support an entity included in the ranked set and or supports an entity ranked relatively low in the ranked set.

In one aspect the result scoring module uses the entity match value for each application to influence the scoring and ranking of the applications in the working set. In one embodiment the result scoring module employs a machine learned regression model to generate scores for the applications in the working subset. In particular the result scoring module generates a feature vector for each application in the working subset. Each feature vector corresponding to an application may include feature vectors corresponding to data signals about the application e.g. information regarding different attributes of the application data signals for the received search query and or any other suitable information. In one embodiment the feature vector generated for each application may include the entity match values for the application as a feature.

Based on the feature vector the result scoring module uses the machine learned regression model to generate scores for each application. In one aspect because the feature vector for each application includes the entity match value as a feature the generated scores for each application accounts for the application s support for entities indicated in the search query. In one aspect the machine learned regression model may have been previously trained to score applications based at least in part on application support for entities indicated in the search query.

Based on the scores for the applications the resulting scoring module generates a ranked listing of applications for the search query where the ranked listing of applications is based at least in part on the entities supported by or correlated to the applications.

In one embodiment the post processing module performs post processing on the ranked listing of applications. More specifically the post processing module may obtain display related metadata for the results list such as application images e.g. application screenshots application descriptions application videos etc. Such information may be obtained from any suitable source such as the application configuration store . In one embodiment the ranked listing of applications is provided to the computing device from which the search query was received. The computing device may present for display the received ranked listing of applications to its user.

Thereafter the search module responsively receives a set of ranked entities from the entity processing module based on the search query. In addition the search module identifies and processes an initial consideration set of applications. In particular the search module leverages the search index to identify an initial consideration set of applications determined to be relevant to e.g. aligned to an intent of the received search query. The search module additionally pares down the initial consideration set to generate a working subset of applications. Thereafter the search module scores and ranks the applications in the working subset. In one aspect scoring and ranking of the applications is based at least in part on the set of ranked entities received from the entity processing module . The search module then performs any necessary post processing and provides a ranked listing of applications to the computing device for presentation e.g. display on a screen to the user of the computing device .

In particular the computing device receives a search query from a user operating the computing device . The search query may be received from the user via a graphical user interface presented by the computing device . Responsive to receiving the search query the computing device transmits the search query to the application search system . Thereafter the computing device receives from the application search system a listing of ranked applications. In one aspect the search results may be ranked based at least in part on one or more entities indicated in the search query. After receiving the listing of ranked applications the computing device presents the ranked listing to the user operating the computing device via for example a display of the computing device .

Referring now to it shows an example screenshot of a listing of ranked applications returned by the application search system responsive to a search query for TOY STORY 3. In the screenshot search results corresponding to the applications FANDANGO FLIXSTER YOUTUBE and IMDB are shown in the top 5 results because each of the applications supports a movie entity type with which the TOY STORY 3 entity indicated in the search query is associated. Referring now to it shows an example screenshot of a listing returned by the application search system responsive to a search query for 81 412. In the screenshot a listing for the WolframAlpha application is shown as being relevant to the search query. In one aspect the WolfranAlpha application may have been identified during processing of the search query by the application search system through using a parsing function to determine that the search query includes an entity having a math entity type. Thus the listing for the WolframAlpha application which supports the math entity type is returned.

The disclosed software structures and processes are configured for operation on a machine e.g. a computing system. is a block diagram illustrating components of an example machine able to read instructions from a machine readable medium and execute them in a processor or controller . Specifically shows a diagrammatic representation of a machine in the example form of a computer system within which instructions e.g. software for causing the machine to perform any one or more of the methodologies discussed herein may be executed. In alternative embodiments the machine operates as a standalone device or may be connected e.g. networked to other machines. In a networked deployment the machine may operate in the capacity of a server machine or a client machine in a server client network environment or as a peer machine in a peer to peer or distributed network environment.

The machine for this configuration may be a mobile computing devices such as a tablet computer an ultrabook or netbook computer a personal digital assistant PDA a cellular telephone a smartphone a web appliance or like machine capable of executing instructions sequential or otherwise that specify actions to be taken by that machine. Further while only a single machine is illustrated the term machine shall also be taken to include any collection of machines that individually or jointly execute instructions to perform any one or more of the methodologies discussed herein.

The example computer system includes one or more processors e.g. a central processing unit CPU and may also include a graphics processing unit GPU a digital signal processor DSP one or more application specific integrated circuits ASICs one or more radio frequency integrated circuits or chipset RFICs a wireless fidelity WiFi chipset a global positioning system GPS chipset an accelerometer one two or three dimensional or any combination of these . The computer system also includes a main memory and a static memory . The components of the computing system are configured to communicate with each other via a bus . The computer system may further include graphics display unit e.g. a plasma display panel PDP a liquid crystal display LCD which may be configured for capacitive or inductive touch sensitivity to allow for direct interaction with software user interfaces through the display . The computer system may also include alphanumeric input device e.g. a keyboard a cursor control device e.g. a mouse a trackball a joystick a motion sensor or other pointing instrument a storage unit a signal generation device e.g. a speaker and a network interface device which also are configured to communicate via the bus .

The storage unit includes a machine readable medium on which is stored instructions e.g. software embodying any one or more of the methodologies or functions described herein. The instructions e.g. software may also reside completely or at least partially within the main memory or within the processor e.g. within a processor s cache memory during execution thereof by the computer system the main memory and the processor also constituting machine readable media. The instructions e.g. software may be transmitted or received over a network via the network interface device .

While machine readable medium is shown in an example embodiment to be a single medium the term machine readable medium should be taken to include a single medium or multiple media e.g. a centralized or distributed database or associated caches and servers able to store instructions e.g. instructions . The term machine readable medium shall also be taken to include any medium that is capable of storing instructions e.g. instructions for execution by the machine and that cause the machine to perform any one or more of the methodologies disclosed herein. The term machine readable medium includes but not be limited to data repositories in the form of solid state memories optical media and magnetic media.

The embodiments described herein beneficially allow application search systems to provide higher quality search results based on entities. Throughout this specification plural instances may implement components operations or structures described as a single instance. Although individual operations of one or more methods are illustrated and described as separate operations one or more of the individual operations may be performed concurrently and nothing requires that the operations be performed in the order illustrated. Structures and functionality presented as separate components in example configurations may be implemented as a combined structure or component. Similarly structures and functionality presented as a single component may be implemented as separate components. These and other variations modifications additions and improvements fall within the scope of the subject matter herein.

Certain embodiments are described herein as including logic or a number of components modules or mechanisms for example as illustrated in . Modules may constitute either software modules e.g. code embodied on a machine readable medium or in a transmission signal or hardware modules. A hardware module is tangible unit capable of performing certain operations and may be configured or arranged in a certain manner. In example embodiments one or more computer systems e.g. a standalone client or server computer system or one or more hardware modules of a computer system e.g. a processor or a group of processors may be configured by software e.g. an application or application portion as a hardware module that operates to perform certain operations as described herein.

In various embodiments a hardware module may be implemented mechanically or electronically. For example a hardware module may comprise dedicated circuitry or logic that is permanently configured e.g. as a special purpose processor such as a field programmable gate array FPGA an application specific integrated circuit ASIC system on a chip SoC chipset to perform certain operations. A hardware module may also comprise programmable logic or circuitry e.g. as encompassed within a general purpose processor or other programmable processor that is temporarily configured by software to perform certain operations. It will be appreciated that the decision to implement a hardware module mechanically in dedicated and permanently configured circuitry or in temporarily configured circuitry e.g. configured by software may be driven by cost and time considerations.

The various operations of example methods described herein may be performed at least partially by one or more processors that are temporarily configured e.g. by software or permanently configured to perform the relevant operations. Whether temporarily or permanently configured such processors may constitute processor implemented modules that operate to perform one or more operations or functions. The modules referred to herein may in some example embodiments comprise processor implemented modules.

The one or more processors may also operate to support performance of the relevant operations in a cloud computing environment or as a software as a service SaaS . For example at least some of the operations may be performed by a group of computers as examples of machines including processors these operations being accessible via a network e.g. the Internet and via one or more appropriate interfaces e.g. application program interfaces APIs . 

The performance of certain of the operations may be distributed among the one or more processors not only residing within a single machine but deployed across a number of machines. In some example embodiments the one or more processors or processor implemented modules may be located in a single geographic location e.g. within a home environment an office environment or a server farm . In other example embodiments the one or more processors or processor implemented modules may be distributed across a number of geographic locations.

Some portions of this specification are presented in terms of algorithms or symbolic representations of operations on data stored as bits or binary digital signals within a machine memory e.g. a computer memory . These algorithms or symbolic representations are examples of techniques used by those of ordinary skill in the data processing arts to convey the substance of their work to others skilled in the art. As used herein an algorithm is a self consistent sequence of operations or similar processing leading to a desired result. In this context algorithms and operations involve physical manipulation of physical quantities. Typically but not necessarily such quantities may take the form of electrical magnetic or optical signals capable of being stored accessed transferred combined compared or otherwise manipulated by a machine. It is convenient at times principally for reasons of common usage to refer to such signals using words such as data content bits values elements symbols characters terms numbers numerals or the like. These words however are merely convenient labels and are to be associated with appropriate physical quantities.

Unless specifically stated otherwise discussions herein using words such as processing computing calculating determining presenting displaying or the like may refer to actions or processes of a machine e.g. a computer that manipulates or transforms data represented as physical e.g. electronic magnetic or optical quantities within one or more memories e.g. volatile memory non volatile memory or a combination thereof registers or other machine components that receive store transmit or display information.

As used herein any reference to one embodiment or an embodiment means that a particular element feature structure or characteristic described in connection with the embodiment is included in at least one embodiment. The appearances of the phrase in one embodiment in various places in the specification are not necessarily all referring to the same embodiment.

Some embodiments may be described using the expression coupled and connected along with their derivatives. For example some embodiments may be described using the term coupled to indicate that two or more elements are in direct physical or electrical contact. The term coupled however may also mean that two or more elements are not in direct contact with each other but yet still co operate or interact with each other. The embodiments are not limited in this context.

As used herein the terms comprises comprising includes including has having or any other variation thereof are intended to cover a non exclusive inclusion. For example a process method article or apparatus that comprises a list of elements is not necessarily limited to only those elements but may include other elements not expressly listed or inherent to such process method article or apparatus. Further unless expressly stated to the contrary or refers to an inclusive or and not to an exclusive or. For example a condition A or B is satisfied by any one of the following A is true or present and B is false or not present A is false or not present and B is true or present and both A and B are true or present .

In addition use of the a or an are employed to describe elements and components of the embodiments herein. This is done merely for convenience and to give a general sense of the invention. This description should be read to include one or at least one and the singular also includes the plural unless it is obvious that it is meant otherwise.

Upon reading this disclosure those of skill in the art will appreciate still additional alternative structural and functional designs for a system and a process for performing application search through the disclosed principles herein. Thus while particular embodiments and applications have been illustrated and described it is to be understood that the disclosed embodiments are not limited to the precise construction and components disclosed herein. Various modifications changes and variations which will be apparent to those skilled in the art may be made in the arrangement operation and details of the method and apparatus disclosed herein without departing from the spirit and scope defined in the appended claims.

