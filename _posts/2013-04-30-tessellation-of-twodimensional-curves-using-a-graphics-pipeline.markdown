---

title: Tessellation of two-dimensional curves using a graphics pipeline
abstract: Methods, systems, and computer-storage media for efficiently tessellating two dimensional (2-D) curves using a graphics pipeline running on a graphics processing unit (GPU) are provided. A central processing unit (CPU) converts a geometry having one or more 2-D curves into an intermediate tessellation having at least one Bezier fan with a fan origin and four control points. The intermediate tessellation is sent on to the graphics pipeline. A hull shader in the graphics pipeline is configured to approximate the Bezier fan curve by subdividing the curve into a defined number of triangles based on a maximum value of a width or a height of a bounding box containing the four control points of the Bezier fan. A domain shader in the graphics pipeline is configured to determine a vertex position for each of the defined triangles along the curve of the Bezier fan.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09401034&OS=09401034&RS=09401034
owner: MICROSOFT TECHNOLOGY LICENSING, LLC
number: 09401034
owner_city: Redmond
owner_country: US
publication_date: 20130430
---
One of the primary tasks of a two dimensional 2 D graphics library is to take scene data tessellate it into high level primitives such as arcs Bezier curves and line segments and rasterize the data for output on a computer display or for storage in a bitmap file format. For speed the graphics library can offload some stages of the rendering onto a graphics processing unit GPU . Geometries such as arcs and Bezier curves have typically posed particular challenges to offloading as the GPU normally cannot consume such geometries or can only consume these types of geometries at a high per pixel cost. Thus prior to offloading the central processing unit CPU must first translate the arcs and Bezier curves into low level primitives such as triangles that the GPU can process. This consumes valuable CPU processing power and often causes a bottleneck in the rendering process.

This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used as an aid in determining the scope of the claimed subject matter.

Embodiments of the present invention relate to systems methods and computer storage media for among other things efficiently tessellating 2 D curves using a graphics pipeline running on a GPU. A CPU converts scene data and or objects having one or more 2 D curves into an intermediate tessellation having at least one Bezier fan. The intermediate tessellation is sent on to the graphics pipeline. A hull shader in the graphics pipeline is configured to approximate the Bezier fan curve by subdividing the curve into a defined number of triangles based on a maximum value of a width or a height of a bounding box containing control points of the Bezier fan. A domain shader in the graphics pipeline is configured to determine a vertex position for each of the defined triangles along the curve of the Bezier fan.

Embodiments of the present invention can be used in combination with target independent rasterization TIR . TIR enables the number of pixel samples taken during the rasterization stage in the graphics pipeline known as the sampling rate to be specified independently from the memory allocated for the rendered image.

The subject matter of the present invention is described with specificity herein to meet statutory requirements. However the description itself is not intended to limit the scope of this patent. Rather the inventors have contemplated that the claimed subject matter might also be embodied in other ways to include different steps or combinations of steps similar to the ones described in this document in conjunction with other present or future technologies. Moreover although the terms step and or block may be used herein to connote different elements of methods employed the terms should not be interpreted as implying any particular order among or between various steps herein disclosed unless and except when the order of individual steps is explicitly described.

Various aspects of the technology described herein are generally directed to systems methods and computer storage media for among other things efficiently tessellating 2 D curves using a graphics pipeline running on a GPU. A CPU converts scene data objects having one or more 2 D curves into an intermediate tessellation having at least one Bezier fan with a fan origin and four control points. The intermediate tessellation is sent on to the graphics pipeline. A hull shader in the graphics pipeline is configured to approximate the Bezier fan curve by subdividing the curve into a defined number of triangles based on a maximum value of a width or a height of a bounding box containing the four control points of the Bezier fan. A domain shader in the graphics pipeline is configured to determine a vertex position for each of the defined triangles along the curve of the Bezier fan.

Embodiments of the present invention can be used in combination with target independent rasterization TIR . TIR enables the number of pixel samples taken during the rasterization stage in the graphics pipeline known as the sampling rate to be specified independently from the memory allocated for the rendered image.

Accordingly in one embodiment the present invention is directed to one or more computer storage media having computer executable instructions embodied thereon that when executed perform a method of rendering antialiased 2 D curves. The method comprises converting scene data into an intermediate tessellation comprising a set of geometric shapes tessellated from objects in the scene data. The set of geometric shapes comprises at least one Bezier fan having four control points and a fan origin. A first instruction is generated to configure a hull shader in a graphics pipeline to among other things approximate a curve of the at least one Bezier fan by subdividing the curve into a defined number of triangles based on a maximum value of a width or a height of a minimum bounding box containing the four control points of the at least one Bezier fan. A second instruction is generated to configure a domain shader in the graphics pipeline to determine a vertex position for each of the defined number of triangles along the curve of the at least one Bezier fan. The intermediate tessellation is communicated to the graphics pipeline.

In another embodiment the present invention is directed to a method of rasterizing an intermediate tessellation of an object in a graphics pipeline running on a GPU where the intermediate tessellation comprises at least one Bezier fan having four control points and a fan origin. The method comprises receiving the intermediate tessellation from a CPU of a computing device and receiving a first instruction to configure a hull shader in the graphics pipeline to among other things approximate a curve of the at least one Bezier fan by subdividing the curve into a defined number of triangles. The hull shader through the computing device is configured based on the first instruction. A second instruction is received for configuring a domain shader in the graphics pipeline to determine a vertex position for each of the defined number of triangles along the curve of the at least one Bezier fan. The domain shader through the computing device is configured based on the second instruction.

In yet another embodiment the present invention is directed to a computer storage medium storing an application program interface API for controlling a GPU. The API comprises a subdivision factor property that defines parameters used by a hull shader component to among other things approximate a curve of at least one Bezier fan by subdividing the curve into a defined number of triangles based on a maximum value of a width or a height of a minimum bounding box containing four control points that define the Bezier fan. The API also comprises a position factor property that defines parameters used by a domain shader component to determine a vertex position for each of the defined number of triangles along the curve of the at least one Bezier fan.

Having briefly described an overview of embodiments of the invention an exemplary operating environment suitable for use in implementing embodiments of the invention is described. Referring to the drawings in general and initially to in particular an exemplary operating environment for implementing embodiments of the invention is shown and designated generally as a computing device . The computing device is but one example of a suitable computing environment and is not intended to suggest any limitation as to the scope of use or functionality of the invention. Neither should the computing device be interpreted as having any dependency or requirement relating to any one or combination of components illustrated.

The invention may be described in the general context of computer code or machine useable instructions including computer executable instructions such as program components being executed by a computer or other machine such as a personal data assistant or other handheld device. Generally program components including routines programs objects components data structures and the like refer to code that performs particular tasks or implements particular abstract data types. Embodiments of the invention may be practiced in a variety of system configurations including handheld devices consumer electronics general purpose computers specialty computing devices etc. Embodiments of the invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network.

With continued reference to computing device includes a bus that directly or indirectly couples the following devices memory one or more processors one or more presentation components input output I O ports I O components an illustrative power supply and a GPU . The bus represents what may be one or more busses such as an address bus data bus or combination thereof . Although the various blocks of are shown with lines for the sake of clarity in reality delineating various components is not so clear and metaphorically the lines would more accurately be grey and fuzzy. For example one may consider a presentation component such as a display device to be an I O component . Also CPUs and GPUs have memory. The diagram of is merely illustrative of an exemplary computing device that can be used in connection with one or more embodiments of the invention. Distinction is not made between such categories as workstation server laptop handheld device etc. as all are contemplated within the scope of and reference to computer or computing device. 

The computing device typically includes a variety of computer readable media. Computer readable media may be any available media that is accessible by the computing device and includes both volatile and nonvolatile media removable and non removable media. Computer readable media comprises computer storage media and communication media computer storage media excludes signals per se. Computer storage media includes volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Computer storage media includes but is not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical disk storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can be accessed by computing device . Communication media on the other hand embodies computer readable instructions data structures program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term modulated data signal means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example and not limitation communication media includes wired media such as a wired network or direct wired connection and wireless media such as acoustic RF infrared and other wireless media. Combinations of any of the above should also be included within the scope of computer readable media.

The memory includes computer storage media in the form of volatile and or nonvolatile memory. The memory may be removable non removable or a combination thereof. Exemplary memory includes solid state memory hard drives optical disc drives etc. The computing device includes one or more processors that read data from various entities such as the bus the memory or the I O components . The presentation component s presents data indications to a user or other device. Exemplary presentation components include a display device speaker printing component vibrating component etc. The I O ports allow the computing device to be logically coupled to other devices including the I O components some of which may be built in. Illustrative I O components include a microphone joystick game pad satellite dish camera microphone scanner printer wireless device etc. Interaction with the illustrative I O components may be via touch voice gesture and the like.

Components of the computing device may be used in image processing. For example the computing device may be used to implement a graphics pipeline similar to graphics pipeline of which processes and applies various effects and adjustments to a raw image. The graphics pipeline includes a series of operations that are performed on a digital image. These pipelines are generally designed to allow efficient processing of a digital image while taking advantage of available hardware.

To implement a graphics pipeline one or more procedural shaders on the GPU are utilized. Procedural shaders are specialized processing subunits of the GPU for performing specialized operations on graphics data. An example of a procedural shader is a hull shader which generally operates on 2 D curves such as for example Bezier fans. For instance the hull shader can apply computations related to subdividing the 2 D curve into a defined number of triangles based on dimensions associated with a minimum bounding box that encompasses control points that define the 2 D curve. Another example of a procedural shader is a domain shader . For instance the output of the hull shader is passed to the domain shader which in turn applies computations to define a vertex position for each of the defined number of triangles along the 2 D curve. Other procedural shaders such as a vertex shader and a pixel shader are also utilized these shaders will be explained in greater depth below with respect to . After a procedural shader concludes its operations the information may be placed in a GPU buffer . The information may be presented on an attached display device or may be sent back to the host for further operations.

The GPU buffer provides a storage location on the GPU where processed scene data may be stored. As various processing operations are performed with respect to the scene data the data may be accessed from the GPU buffer altered and then re stored on the buffer . The GPU buffer allows the data being processed to remain on the GPU while it is transformed by a graphics pipeline. As it is time consuming to transfer data from the GPU to the memory it may be preferable for the data to remain on the GPU buffer until processing operations are completed.

With respect to the hull shader and the domain shader specialized functionality can be achieved by downloading instructions to the hull shader and the domain shader . Furthermore the functionality of many different operations may be provided by instruction sets tailored to other components such as a pixel shader and a rasterizer. For example negating remapping biasing and other functionality are useful for many graphics applications. The ability to program the hull shader and the domain shader on the GPU to process 2 D curves is advantageous for graphics operations because of the processing speed achieved by utilizing the parallel architecture of the GPU . These specialized sets of instructions may add value by easing development and improving performance. By executing these instructions a variety of functions can be performed by the hull shader and the domain shader assuming the instruction count limit and other hardware limitations of the shaders and are not exceeded. The hull shader the domain shader and other components may receive instructions through one or more application program interfaces APIs .

With reference to a block diagram is illustrated that shows an exemplary computing system architecture suitable for use with embodiments of the present invention. The computing system architecture shown in is merely an example of one suitable computing system and does not limit the scope of use or functionality of the present invention. Neither should the computing system architecture be interpreted as having any dependency or requirement related to any single module component or combination of modules components.

The computing system architecture includes a computing device and a display . The computing device comprises an image module a GPU driver an API module and an operating system . The computing device may be any type of computing device such as for example the computing device described above with reference to . By way of example only and not limitation the computing device may be a personal computer desktop computer laptop computer handheld device mobile handset consumer electronic device or the like.

The image module transmits data for an object or scene to be rendered. The image module may be a computer program for which objects or scenes are to be rendered. The objects or scenes to be rendered may include but are not limited to video game images video clips movie images and static screen images. The objects may be three dimensional or two dimensional. The API module is an interface which may be provided by the operating system to support requests made by computer programs such as the image module . Direct3D and OpenGL are examples of APIs that support requests of the image module . The device is in communication with the display device .

The image module may provide configuration instructions for one or more components in a graphics pipeline. The instructions may also be provided by the operating system . The instructions may be passed to the API module which exposes functions of the GPU drivers to the image module . The API module may configure functions in the GPU drivers based on the instructions received. As explained in more detail subsequently the API module has a subdivision factor property that defines parameters used by a hull shader such as the hull shader of to among other things approximate a 2 D curve by subdividing the curve into a defined number of triangles based on a maximum value of a width or height of a minimum bounding box containing control points that define the 2 D curve. The API module may also have a position factor property that defines parameters used by a domain shader such as the domain shader of to position the 2 D curve by determining a vertex position for each of the defined number of triangles along the 2 D curve. Additionally the API module may have a render target storage property that defines an amount of memory allocated on the GPU to a rendered image and a sampling rate property that defines a sampling rate used by a rasterizer component. The image module may provide instructions for these properties on a per frame basis or change these functions multiple times while rendering a single scene or object.

With reference to an exemplary graphics pipeline is shown. The graphics pipeline includes the stages for transforming scene data into rasterized bitmap representations of the data also known as a coverage mask or a rendered image that may be displayed on a display device. The graphics pipeline includes an input assembler a vertex shader a hull shader a tessellator a domain shader a geometry shader a rasterizer a pixel shader and output merger . The rendered image produced by the graphics pipeline may be written to a GPU buffer allocated for the rendered image e.g. as shown by the arrows connecting the graphics pipeline and the GPU buffer . The graphics pipeline depicted in is exemplary and additional components may be added or components removed.

The input assembler reads vertices out of memory e.g. the GPU buffer as well as control points and fan origins associated with Bezier fans forms geometries from these data points e.g. sets of triangles and Bezier fans and creates pipeline work items. Each set of primitives e.g. triangles versus Bezier fans is handled as a separate pass on the graphics pipeline . For efficiency however like primitives from multiple geometries will be processed together in a single pass on the graphics pipeline .

Triangle primitives are rasterized using the vertex shader and the pixel shader . The vertex shader is a graphics processing function used to add special effects to objects in a 3 D environment by performing mathematical operations on the objects vertex data. The geometry shader generates new graphics primitives such as points lines and triangles from those primitives that were sent to the beginning of the graphics pipeline . The rasterizer converts scene data into a raster image e.g. pixels for output to a display or file. The rasterizer may sample the scene data at several sub pixels per pixel. The pixel shader serves to manipulate a pixel color usually to apply an effect on an image for example realism bump mapping shadows anti aliasing and explosion effects. It is a graphics function that calculates effects on a per pixel basis. Output merger performs blend depth and stencil operations. The rendered image produced by the output merger is written to the GPU buffer .

Bezier fan primitives are rasterized using the hull shader the tessellator and the domain shader in addition to the other shaders and or components outlined above. As will be described in more detail below the hull shader specifies among other things that a Bezier fan will be treated as a deformed triangle partitions the interior of the deformed triangle into one or more triangles and a curve segment and approximates the curve segment by specifying how the curve segment will be subdivided. For instance the hull shader specifies the number of triangles to be used to approximate the curve segment based on dimensions of a bounding box encompassing the Bezier fan s control points. The tessellator carries out the tessellation of the Bezier fan based on the parameters specified by the hull shader .

The output of the tessellator is passed on to the domain shader . The domain shader also receives as input directly from the hull shader at least the four control points and the fan origin associated with the Bezier fan. The domain shader operates on these values using for example a Bernstein polynomial to output a vertex position of each of the triangles along the curve segment of the Bezier fan. Thus at a high level the hull shader specifies parameters used to describe the overall shape of the geometry having the 2 D curve and the domain shader positions the geometry.

Turning now to an illustration of a Bezier fan is shown and is referenced generally by the numeral . The Bezier fan is defined by a single vertex known as the fan origin O and a cubic Bezier known as the fan contour . As shown in the fan contour covers all points t v B t v O 1 v 0 t v 1 where B t is a parameterization of the Bezier fan over the 0 1 interval e.g. between points and and O is the fan origin . As seen in the variable t describes how far along the Bezier curve a first point is located point and the variable v describes the distance a second point point is along a line connecting the fan origin O with the first point .

The Bezier fan shown in is produced subsequent to a CPU taking an object and tessellating the object into an intermediate tessellation having high level primitives such as the Bezier fan and triangles. For instance with respect to an object such as object shown in the CPU selects the center of a bounding box of the object as the figure origin . Each segment of the object is then walked. When a line segment is encountered a triangle with vertices defined by the line end points and the figure origin is outputted. This is shown by triangles and of . When a Bezier segment is encountered a Bezier fan is outputted using the Bezier curve itself as the fan contour and the figure origin as the fan origin. depicts two Bezier fans and . Bezier fans produced this way may be defined or encoded as a set of four control points and the fan origin. For instance the Bezier fan may be encoded using the figure origin as the fan origin and control points and .

Bezier fans resulting from the above process may be self intersecting and primitives may overlap. This may be handled by the CPU further sub dividing the Bezier fans to ensure that the fans do not self intersect and primitives do not overlap. Alternatively if any portion of the resulting coverage mask overlaps the coverage mask may first be rendered into an intermediate bitmap with an XOR logical blend. Although the intermediate tessellation shown in includes a cubic Bezier fan embodiments of the invention can be extended to support additional segment types such as arcs and quadratic Beziers at the cost of additional passes through the graphics pipeline. In an alternative embodiment objects having N segment types could be subdivided into N sets of primitives corresponding to triangles and N 1 sets of fan types with the fan contours defined by a segment of the corresponding type.

Turning now to depicts a Bezier fan after being operated on by a hull shader such as the hull shader of . As explained above with respect to the hull shader receives as input a fan origin and four control points and that define the Bezier fan . The hull shader utilizes a set of parameters to operate on the Bezier fan . The set of parameters include 

The tri domain parameter specifies that the Bezier fan will be treated as a deformed triangle. In an alternative embodiment the Bezier fan may be treated as a deformed rectangle. The integer partitioning parameter indicates that the interior of the deformed triangle will be partitioned using integer partitioning. For instance using an interior point the Bezier fan has been partitioned into a curve segment and two triangles and that each share an edge with the perimeter of the curve segment e.g. lines and . The curve segment extends from point to point . In an alternative embodiment fractional partitioning may be used to partition the interior of the deformed triangle. The output topology parameter specifies that the curve segment will be approximated using a set of triangles each of whose vertices will be specified in clockwise order.

The inside tessellation factor affects how many interior triangles are produced by the tessellation. An interior triangle is defined as a triangle that does not share an edge with the perimeter of the curve segment of the Bezier fan e.g. the lines and . The inside tessellation factor is set to 1 which indicates that no interior triangles are produced by the tessellation. The contour tessellation factor is an integer that is chosen dynamically at runtime by utilizing a look up table that is generated offline. The contour tessellation factor specifies how finely to subdivide the curve segment using triangles that radiate out from the interior point as shown in . In other words the contour tessellation factor specifies the number of triangles to be used in the subdivision. In general when a curve segment is tessellated too coarsely the rendered image will have visible faceting. On the other hand when a curve segment is tessellated too finely the GPU becomes over burdened and processing times become prolonged. The present invention utilizes the contour tessellation factor to strike a balance between tessellating too coarsely and tessellating too finely.

As mentioned the contour tessellation factor is an integer that is chosen dynamically at runtime by utilizing a look up table. The look up table is generated offline prior to compilation by choosing a pre defined set of contour tessellation factors e.g. 2 4 8 16 32 and 64 and computing an associated bounding box dimension for each of the contour tessellation factors. Specifically for each tessellation factor n the maximum value henceforth called D of dist B t L t is computed where max and B t is the canonical parameterization of a Bezier based on Bernstein basis functions with t ranging from 0 to 1 for a cubic Bezier 3 1 3 1 1 where C . . . Care the four Bezier control points whose x and y coordinates are each allowed to range in the interval 0 1 . L t is the normalized arc length parameterization of the polyline segment connecting the points

At runtime a minimum bounding box that encompasses the four control points of the Bezier fan is computed. An exemplary bounding box is shown in it contains four control points of a Bezier fan as shown at points C C C and C. The bounding box has a height and a width . The maximum dimension of the bounding box is determined e.g. either the height or the width . The maximum dimension is matched to the appropriate range in the look up table and the minimum contour tessellation factor n is chosen such that

The domain shader receives as input from the hull shader the Bezier fan control points C C C C the fan origin O and a SV DomainLocation t u v . The domain location is specified in Barycentric coordinates meaning that 0 t u v 1 and t u v 1 which allows u to be ignored. The domain shader emits as output a vertex position P for each of the triangles along the curve segment e.g. the curve segment of . Each vertex position P is calculated using the following formula 1 where B t is the Bernstein polynomial 3 1 3 1 1 

The output of the domain shader is depicted in . illustrates the same Bezier fan as shown in now labeled as Bezier fan . Each of the triangles meets the curve segment at a vertex position P e.g. vertex positions P . . . P . Two exemplary vertex positions are shown at numerals and .

Turning now to a flow diagram is depicted of an exemplary method of rendering antialiased 2 D curves and is referenced generally by the numeral . Antialiased graphics are rendered images with lines and or curves that appear straight or smooth rather than stair stepped. The antialiased rendered images are produced by an anti aliasing process that utilizes components of a graphics pipeline such as the graphics pipeline of . Rendering is a process of generating a rasterized bitmap representation of scene data. A rendered image does not actually have to be displayed for the completion of the rendering process. The method may be performed by an image component. Examples of image components include word processing applications spreadsheet applications presentation applications personal contact applications games and other applications that produce two dimensional images.

At a step scene data is converted into an intermediate tessellation by generating a set of geometric shapes tessellated from objects in the scene data. The intermediate tessellation includes at least one Bezier fan defined by a fan origin and four control points. Other exemplary geometric shapes may include triangles and arc segments. In one embodiment the converting step is done by software running on a CPU.

At a step a first instruction to configure a hull shader in the graphics pipeline is generated. The hull shader is configured to approximate a curve or curve segment of the Bezier fan by subdividing the curve into a defined number of triangles based on a maximum value of a width or a height of a minimum bounding box that contains the four control points that define the Bezier fan. As explained above the number of triangles used to approximate the curve is determined based on a pre computed look up table comprising one or more ranges of maximum height or width values and corresponding subdivision factors or contour tessellation factors. The first instruction may be communicated to an API that in turn configures the hull shader on the GPU.

At a step a second instruction to configure a domain shader in the graphics pipeline is generated. The domain shader is configured to determine a vertex position for each of the defined number of triangles along the curve at the Bezier fan using for example a Bernstein polynomial. The second instruction may also be communicated to an API that in turn configures the domain shader on the GPU. At a step the intermediate tessellation is communicated from the CPU to the graphics pipeline running on the GPU.

The method may further include generating a third instruction to define a render target storage value in the graphics pipeline. The render target storage value defines the amount of memory allocated to the rendered image. The rendered image may be the end result of running the intermediate tessellation through the graphics pipeline. The third instruction may be communicated to an API that in turn configures a process on the GPU.

A fourth instruction may also be generated to define a sampling rate for a rasterizer in the graphics pipeline. The sampling rate is defined independently from the render target storage. Because these items are defined separately their values do not need to be tied together. In one embodiment the memory or render target storage value is set to 1 the rendered bitmap representation. For example if the rendered image was 480 pixels 480 pixels the allocated memory could be enough to store 230 400 pixels. Since the sampling rate is defined independently the sampling rate could be four sub pixels per pixel even with the memory allocation for 230 400 pixels on a 480 480 rendered bitmap representation. The fourth instruction may be communicated to an API that in turn configures a process on the GPU.

Additional instructions may also be generated. For instance instructions may be generated to configure a pixel shader in the graphics pipeline to process the intermediate tessellation. The instruction may vary depending on whether the geometric shapes within the intermediate tessellation overlap or are non overlapping. In a scenario where the geometric shapes are non overlapping the pixel shader is configured to count the number of bits set in the intermediate tessellation normalize the results to a real number and add the real number to current contents of a render target. On the other hand when there is overlap between the geometric shapes the pixel shader is configured to combine the triangle or triangles emitted by the domain shader with current contents of a render target using a logical process to determine which color is added or subtracted from the render target. In one embodiment the logical process is a bitmap exclusive or XOR operation. In another embodiment the logical process is a bitmap OR operation.

Turning now to a flow diagram is depicted of a method of instructing a GPU to rasterize an intermediate tessellation of an object. The intermediate tessellation comprises at least a Bezier fan having four control points and a fan origin. The method may be performed by an API.

At a step the GPU receives the intermediate tessellation from a CPU of a computing device. The intermediate tessellation comprises a high level representation of the object having one or more line segments and at least one Bezier fan defined by a fan origin and four control points. At a step the GPU receives a first instruction to configure a hull shader in a graphics pipeline running on the GPU to among other things approximate a curve of the Bezier fan by subdividing the curve into a defined number of triangles.

The first instruction may also comprise a tri domain instruction specifying the hull shader to treat the Bezier fan as a deformed triangle having two sides and a curved side. The first instruction may also comprise a partition instruction for partitioning the interior of the Bezier fan and an output topology instruction specifying that the curve of the Bezier fan will be subdivided using a set of triangles each of whose vertices will be specified in clockwise order. The first instruction additionally comprises an inside tessellation factor instruction of 1 that guarantees that there are no interior triangles e.g. triangles that do not share an edge with the perimeter of the curve segment of the Bezier fan .

At a step the hull shader is configured by the computing device based on the first instruction. At a step the GPU receives a second instruction for configuring a domain shader in the graphics pipeline to determine a vertex position for each of the defined number of triangles along the curve of the Bezier fan. At a step the domain shader is configured based on the second instruction.

The method further comprises the hull shader executing the first instruction against the Bezier fan of the intermediate tessellation. The hull shader computes a minimum bounding box containing the Bezier fan s four control points and determines a maximum value of either the width or the height of the bounding box. A look up table comprising ranges of maximum height or width values and corresponding contour tessellation factors is accessed and the maximum value of the bounding box is matched to one of the ranges in the look up table. A subdivision factor or contour tessellation factor corresponding to the matched range is determined from the look up table and this factor is used to subdivide the Bezier fan curve into a number of triangles equal to the contour tessellation factor. The method additionally comprises the domain shader executing the second instruction against the Bezier fan in order to determine the vertex position for each of the defined number of triangles along the Bezier fan curve.

Additional instructions may be received by the GPU. For instance an instruction to define a render target storage value in the graphics pipeline running on the GPU is received. The instruction may be received from a program. An amount of memory in the GPU corresponding to the render target storage value is allocated. The memory may be allocated by a driver for the GPU. Instructions may also be received to define a sampling rate for a rasterizer in the graphics pipeline on the GPU. The sampling rate is defined independently from the render target storage value. The rasterizer is configured to sample scene data at the sampling rate. The rasterizer may be configured through drivers in the GPU. The sampling rate and storage value may be independent of each other. In one aspect the sampling rate may be greater than the render target storage value where the render target storage value is equivalent to one pixel per pixel in a rendered image and the sampling rate is set to four sub pixels per pixel.

Embodiments of the invention have been described to be illustrative rather than restrictive. It will be understood that certain features and subcombinations are of utility and may be employed without reference to other features and subcombinations. This is contemplated by and is within the scope of the claims.

