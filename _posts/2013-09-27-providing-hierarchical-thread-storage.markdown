---

title: Providing hierarchical thread storage
abstract: Described are techniques for creating a thread. A first plurality of calls are issued to create the thread. The first plurality of calls are executed in the context of an executing first thread and form a call chain traversing a plurality of code layers in a first order. A data area including thread-specific context information is created and initialized at each of the plurality of code layers when code of each code layer is invoked in accordance with the interface of each code layer to create the thread. Each of the plurality of code layers is included in a registered set. Executing the thread includes issuing a second plurality of calls traversing said plurality of code layers in an order that is a reverse of the first order. The second plurality of calls result in transferring control to a first body of code for the thread.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09459920&OS=09459920&RS=09459920
owner: EMC Corporation
number: 09459920
owner_city: Hopkinton
owner_country: US
publication_date: 20130927
---
This application generally relates to code execution and more particularly to techniques used for communicating between different code modules.

Computer systems may include different resources used by one or more host processors. Resources and host processors in a computer system may be interconnected by one or more communication connections. These resources may include for example data storage devices such as those included in the data storage systems manufactured by EMC Corporation. These data storage systems may be coupled to one or more servers or host processors and provide storage services to each host processor. Multiple data storage systems from one or more different vendors may be connected and may provide common data storage for one or more host processors in a computer system.

A host processor may perform a variety of data processing tasks and operations using the data storage system. For example a host processor may perform basic system I O operations in connection with data requests such as data read and write operations.

Host processor systems may store and retrieve data using a storage system containing a plurality of host interface units disk drives and disk interface units. The host systems access the storage system through a plurality of channels provided therewith. Host systems provide data and access control information through the channels to the storage system and the storage system provides data to the host systems also through the channels. The host systems do not address the disk drives of the storage system directly but rather access what appears to the host systems as a plurality of logical disk units. The logical disk units may or may not correspond to the actual disk drives. Allowing multiple host systems to access the single storage system allows the host systems to share data in the system. In order to facilitate sharing of the data on the system additional software on the data storage systems may also be used.

Code modules that execute on a data storage system as well as other systems may use a variety of different techniques for inter module communications. An environment in which the code executes may provide a facility for such inter module communication.

In accordance with one aspect of the invention is a method of creating a thread comprising issuing a first plurality of calls to create the thread said first plurality of calls forming a call chain traversing a plurality of code layers in a first order said first plurality of calls being executed in a context of an executing first thread wherein said first plurality of calls includes a first call issued by the executing first thread to a first of the plurality of code layers in accordance with a first interface for the first call each of said plurality of code layers providing a set of interfaces for making calls to code of said each code layer each of said plurality of code layers providing an interface for invoking code of said each code layer to create the thread wherein for the thread being created as a result of said first plurality of calls a data area including thread specific context information is created and initialized at each of said plurality of code layers when code of said each code layer is invoked in accordance with said interface of said each code layer to create the thread wherein each of said plurality of code layers is included in a registered set of code layers responsive to a last one of the first plurality of calls in the call chain being issued to a last one of the plurality of code layers from another one of the plurality of code layers creating the thread and executing the thread wherein said executing the thread includes issuing a second plurality of calls forming a callback call chain traversing said plurality of code layers in an order that is a reverse of said first order wherein said second plurality of calls are executed in a context of the thread and results in transferring control to a first body of code for the thread whereby said first body of code is included in a user code module. The first body of code may begin execution responsive to said transferring control to the first body of code. Issuing the second plurality of calls may result in creating and initializing a data area including thread specific context information for the thread for each code layer that is included in the registered set and wherein said each code layer is also not included in the plurality of code layers traversed when issuing said first plurality of calls to create the thread. Each of the code layers in the registered set may register a birth callback routine and a death callback routine. The birth callback routine of said each code layer may be invoked to perform processing including creating and initializing a data area including thread specific context information for said each code layer. If said each code layer is not included in said plurality of code layers traversed when issuing the first plurality of calls the birth callback routine of said each code layer may be subsequently invoked in connection with performing said issuing a second plurality of calls forming a callback call chain traversing said plurality of code layers in an order that is a reverse of said first order. Subsequent to said transferring control to said first body of code for the thread a new code layer may register and may be included in said registered set. The method may also include executing code of the thread which results in transferring control to first code of said new code layer said first code of said new code layer using thread specific context information for said new code layer for said thread determining that a data area including thread specific context information for the new code layer for the thread does not exist and responsive to said determining creating and initializing a data area including thread specific context information for the new code layer for the thread. The first code of said new code layer may perform processing using at least some of the thread specific context information for said new code layer for said thread. Creating and initializing a data area including thread specific context information for the new code layer for the thread may further include invoking a birth callback routine of said new code layer. A first runtime execution stack for the executing first thread may include said first plurality of calls and wherein a second runtime stack for the thread created may include said second plurality of calls wherein the method further comprises the thread completing execution. Responsive to said thread completing execution first processing may be performed where the first processing may include unwinding said second runtime execution stack including returning through said second plurality of calls of the second runtime execution stack wherein said returning through said second plurality of calls includes invoking a death callback routine for each of said code layers of said registered set if a birth callback routine for said each code layer was previously executed. Subsequent to the thread being created processing may be performed to unwind said first runtime execution stack including returning through said first plurality of calls of the first runtime execution stack whereby the executing first thread continues execution of code following the first call. A death callback routine for a first code layer of said registered set may perform second processing including deallocating storage for a first data area including thread specific context information for said first code layer wherein said first data area was previously created and initialized by code of a birth callback routine of said first code layer. Responsive to invoking code of said each code layer to create the thread as part of said issuing said first plurality of calls an entry in a disable bit mask array may be set to denote that said each code layer is included in the call chain comprising the first plurality of calls. Issuing said first plurality of calls may include executing first code of a first of said plurality of code layers that performs processing comprising determining using said disable bit mask array for each other code layer that is supported which may possibly issue a create thread call to said first code layer using said interface of said first code layer to create a thread whether said each other code layer issued said create thread call in said first plurality of calls and setting a data item to have a value in accordance with said determining said data item being included in first thread specific context information for said thread for said first code layer. Issuing the second plurality of calls may include executing second code of said first code layer that determines using said first thread specific information for said thread for said first code layer whether to invoke a birth callback of each other code layer which may possibly issue said create thread call to said first code layer to create a thread. One of the plurality of code layers in the registered set may perform processing to unregister. A first death callback may be specified for said one code layer when previously registering said one code layer. The first death callback may beinvoked for each existing first data area including thread specific context information for said one code layer.

In accordance with another aspect of the invention is a non transitory computer readable medium comprising code stored thereon for creating a thread for execution the non transitory computer readable medium comprising code for issuing a first plurality of calls to create the thread said first plurality of calls forming a call chain traversing a plurality of code layers in a first order said first plurality of calls being executed in a context of an executing first thread wherein said first plurality of calls includes a first call issued by the executing first thread to a first of the plurality of code layers in accordance with a first interface for the first call each of said plurality of code layers providing a set of interfaces for making calls to code of said each code layer each of said plurality of code layers providing an interface for invoking code of said each code layer to create the thread wherein for the thread being created as a result of said first plurality of calls a data area including thread specific context information is created and initialized at each of said plurality of code layers when code of said each code layer is invoked in accordance with said interface of said each code layer to create the thread wherein each of said plurality of code layers is included in a registered set of code layers responsive to a last one of the first plurality of calls in the call chain being issued to a last one of the plurality of code layers from another one of the plurality of code layers creating the thread and executing the thread wherein said executing the thread includes issuing a second plurality of calls forming a callback call chain traversing said plurality of code layers in an order that is a reverse of said first order wherein said second plurality of calls are executed in a context of the thread and results in transferring control to a first body of code for the thread whereby said first body of code is included in a user code module. The first body of code may begin execution responsive to said transferring control to the first body of code and wherein each of said code layers in said registered set may register a birth callback routine and a death callback routine. Issuing said second plurality of calls may result in creating and initializing a data area including thread specific context information for the thread for each code layer that is included in the registered set and wherein said each code layer is also not included in the plurality of code layers traversed when issuing said first plurality of calls to create the thread.

With the growing popularity of all types of data storage devices there is also a growing demand for software and features for data storage devices. However developing software components for the devices is a difficult task because storage devices operate under constraints which at least in some cases are distinct or prioritized differently from those imposed on other types of computing systems.

For example data storage devices require solutions to different sets of problems. A wide variety of data storage hardware solutions are available in the market. The solutions require significant efforts from software developers to provide high performance and reliability and other desired storage features and to integrate them with software solutions that would present to the end customers easy and friendly user interfaces. In addition providers of hardware solutions are challenged to provide reasonable hardware to software interface mechanisms.

In many cases these constraints have resulted in providing largely static and non expandable programming environments for data storage devices. The programming environments for these devices also tend to lack a common or standard interface to handle the integration of software components in a data storage environment. Thus the creation of component oriented software is rendered difficult and becomes a custom solution. Accordingly conventional programming and testing environments for such devices present a substantial obstacle to software developers for such devices. Adding functionality to the operating system of a storage device can be difficult. Adding the same functionality to a storage device having a different operating system may require in general not only a different set of function calls and programming methods but a different programming environment altogether.

Examples of conventional methods providing platform independence include the CORBA architecture and Sun Microsystems Java. A CORBA architecture employs a middle layer called Object Request Broker ORB to facilitate integration of software objects. The middle layer requires memory and a CPU s processing power.

A conventional Java architecture employs a virtual machine which provides platform independence at run time. A virtual machine facilitates different object components to find each other and the object components interact with each other via the virtual machine. Because object components interact and execute via the virtual machine versus execution of native code of the underlying processor the processing speed is noticeably slowed down in a Java architecture. In addition the virtual machine requires a large amount of memory and only executes code in user space. Furthermore a software developer is required to use the Java language and thus needs to expend a large amount of time and effort to become versatile in using a Java system. In addition a large amount of legacy code written in non Java language becomes unavailable in a Java architecture.

It is desirable to have flexible and platform independent programming environments for storage devices especially given the growing demand for storage devices having a variety of different data storage system environments.

As described at least in part below a storage software platform architecture can be provided that converges and leverages existing platform capabilities and technologies with other assets to provide a sustainable advantage.

In at least some implementations the architecture allows developers to focus on the customer experience and quality improved product scalability reliability and availability innovation in response to customer need development of best of breed products and solutions product line breadth and enterprise and data center technologies. In at least some implementations the architecture also facilitates development and or improvement in key areas such as convergence and leverage ease of use channel readiness consistency and flexibility application awareness storage solutions and services success at the lower end of the market and efficiency productivity and focus of development resources.

In at least one aspect the architecture is or includes a scalable common architecture that can be extended across many technical and industry dimensions and that takes into account that performance considerations vary that availability and quality concerns may be high but have different complexities that security is constant but with perimeter versus internal security priorities varying and that many different topologies exist. In at least one implementation the architecture is or includes a unified architecture for integrated management of network attached storage NAS and object and storage block services.

The architecture may include features such as openness application awareness ease of use and management partner enablement scaling globalization enhanced platform architecture and enhanced availability and reliability. Openness may rely on and or leverage proprietary and third party technologies for accessibility and user interface. Application awareness may include automated discovery application provisioning and self management. Ease of use and management may include a unified user experience total lifecycle coverage self management and active communities. Partner enablement may include features that facilitate sales channels and OEM arrangements. Scaling may include a range from small and medium size businesses to enterprise and may include scaling up and scaling out. Globalization may include fully internationalized systems with localized user interface screens and behavior. Enhanced platform architecture may include modular building blocks and well defined interfaces. Enhanced availability and reliability may include fault domains and autonomous management.

At least one implementation of the architecture takes into account that from a high level perspective many different storage platforms have many of the same features such as moving data from one I O chip to memory to another I O chip high availability clustering peer to peer replication and drive management and such platforms also support similar interface protocols transformations and methods. However if such platforms have significantly varying implementations and external interfaces and little commonality development involves significant duplication of functionality and work and it can be difficult to move technology or techniques from platform to platform share or reuse technology or techniques combine technology or techniques from different platforms together or with new applications or otherwise avoid doing the same work multiple times. For example if a new feature or new standard is needed the new feature or standard must be implemented separately for each platform.

A convergence oriented common software environment CSE based on the architecture takes into account different base architectural assumptions different terminology for similar concepts different behaviors or expressions for similar features different high availability different clustering scaling and non destructive upgrade models different wire protocols e.g. replication mainframe and different management interfaces and look and feel interfaces. As a result the environment takes into account different software environments different base operating systems dictating hardware and different hardware dictating base operating systems.

Thus the common software environment enables mechanical commonality as a prelude to enabling architectural commonality with the results that the value of developed technology increases commonality increases it takes less work to maintain the same base of functions or add features flexibility increases the ability to effect rapid change is improved technology and techniques are freed from existing mechanical then architectural constraints the ability to combine existing technology and techniques with new technology and techniques in new ways increases lost opportunity costs are regained resources are freed up to refactor and rationalize rather than rewrite or discard current technology or techniques the underlying basics of technology is preserved enabling virtualization code is strengthened by preserving field experience development testing and support are made more efficient and reliability is improved.

Referring to shown is an example of an embodiment of a system that may be used in connection with performing the techniques described herein. The system includes one or more data storage systems connected to server or host systems through communication medium . The system also includes a management system connected to one or more data storage systems through communication medium . In this embodiment of the system the management system and the N servers or hosts may access the data storage systems for example in performing input output I O operations data requests and other operations. The communication medium may be any one or more of a variety of networks or other type of communication connections as known to those skilled in the art. Each of the communication mediums and may be a network connection bus and or other type of data link such as a hardwire or other connections known in the art. For example the communication medium may be the Internet an intranet network or other wireless or other hardwired connection s by which the host systems may access and communicate with the data storage systems and may also communicate with other components not shown that may be included in the system . In one embodiment the communication medium may be a LAN connection and the communication medium may be an iSCSI or fibre channel connection.

Each of the host systems and the data storage systems included in the system may be connected to the communication medium by any one of a variety of connections as may be provided and supported in accordance with the type of communication medium . Similarly the management system may be connected to the communication medium by any one of variety of connections in accordance with the type of communication medium . The processors included in the host computer systems and management system may be any one of a variety of proprietary or commercially available single or multi processor system such as an Intel based processor or other type of commercially available processor able to support traffic in accordance with each particular embodiment and application.

It should be noted that the particular examples of the hardware and software that may be included in the data storage systems are described herein in more detail and may vary with each particular embodiment. Each of the host computers the management system and data storage systems may all be located at the same physical site or alternatively may also be located in different physical locations. In connection with communication mediums and a variety of different communication protocols may be used such as SCSI Fibre Channel iSCSI and the like. Some or all of the connections by which the hosts management system and data storage system may be connected to their respective communication medium may pass through other communication devices such as a switching equipment a phone line a repeater a multiplexer or even a satellite. In one embodiment the hosts may communicate with the data storage systems over an iSCSI or a fibre channel connection and the management system may communicate with the data storage systems over a separate network connection using TCP IP. It should be noted that although illustrates communications between the hosts and data storage systems being over a first connection and communications between the management system and the data storage systems being over a second different connection an embodiment may also use the same connection. The particular type and number of connections may vary in accordance with particulars of each embodiment.

Each of the host computer systems may perform different types of data operations in accordance with different types of tasks. In the embodiment of any one of the host computers may issue a data request to the data storage systems to perform a data operation. For example an application executing on one of the host computers may perform a read or write operation resulting in one or more data requests to the data storage systems .

The management system may be used in connection with management of the data storage systems . The management system may include hardware and or software components. The management system may include one or more computer processors connected to one or more I O devices such as for example a display or other output device and an input device such as for example a keyboard mouse a touchpad and the like. A data storage system manager may for example view information about a current storage volume configuration on a display device of the management system .

In one embodiment the one or more data storage systems of may be an appliance with hardware and software for hosting the data storage of the one or more applications executing on the hosts . The appliance may include one or more storage processors and one or more devices upon which data is stored. The appliance may include software used in connection with storing the data of the hosts on the appliance and also software used in connection with techniques described in following paragraphs which are part of a common software environment CSE .

In another embodiment the data storage systems may include one or more data storage systems such as one or more of the data storage systems such as a data storage array offered by EMC Corporation of Hopkinton Mass. Each of the data storage systems may include one or more data storage devices such as disks. One or more data storage systems may be manufactured by one or more different vendors. Each of the data storage systems included in may be inter connected not shown . Additionally the data storage systems may also be connected to the host systems through any one or more communication connections that may vary with each particular embodiment and device in accordance with the different protocols used in a particular embodiment. The type of communication connection used may vary with certain system parameters and requirements such as those related to bandwidth and throughput required in accordance with a rate of I O requests as may be issued by the host computer systems for example to the data storage systems . It should be noted that each of the data storage systems may operate stand alone or may also be included as part of a storage area network SAN that includes for example other components such as other data storage systems. Each of the data storage systems may include a plurality of disk devices or volumes. The particular data storage systems and examples as described herein for purposes of illustration should not be construed as a limitation. Other types of commercially available data storage systems as well as processors and hardware controlling access to these particular devices may also be included in an embodiment.

In such an embodiment in which element of is implemented using one or more data storage systems each of the data storage systems may include code thereon for performing the techniques as described herein for the common software environment.

Servers or host systems such as provide data and access control information through channels to the storage systems and the storage systems may also provide data to the host systems also through the channels. The host systems may not address the disk drives of the storage systems directly but rather access to data may be provided to one or more host systems from what the host systems view as a plurality of logical devices or logical volumes LVs . The LVs may or may not correspond to the actual disk drives. For example one or more LVs may reside on a single physical disk drive. Data in a single storage system may be accessed by multiple hosts allowing the hosts to share the data residing therein. An LV or LUN logical unit number may be used to refer to the foregoing logically defined devices or volumes.

In following paragraphs reference may be made to a particular embodiment such as for example an embodiment in which element of is an appliance as described above. However it will be appreciated by those skilled in the art that this is for purposes of illustration and should not be construed as a limitation of the techniques herein.

The common software environment may include components described herein executing on each data storage system. Each of the data storage systems may have any one of a variety of different hardware and software platforms comprising a supported environment. For example a first data storage system may include the common software environment with a first operating system and underlying hardware. A second data storage system may include the common software environment with a different operating system and different underlying hardware.

The common software environment CSE includes a framework which may be implemented using APIs application programming interfaces and other code modules described herein. The APIs may implement the underlying functionality which varies with the different possible data storage system hardware and software platforms. As such code may be written using the APIs so that the code is insulated from the underlying platform dependencies. The code may be executed on any data storage system utilizing the APIs regardless of the particular hardware and or software platform of the data storage system. Additionally the API code of the CSE may be written so that the code is allowed to execute in user space or kernel space as will be described in more detail herein. As such the API may utilize the underlying primitives of the particular operating system or may also emulate functionality on an operating system lacking a particular feature. A code module using the API can also execute in user mode or kernel mode on a supported operating system. For example a code module may make a first API call to CSE on a data storage system having a first operating system. For the first operating system the API of the CSE may implement the first API call utilizing the underlying primitives of the first operating system. The code module may also be executed on another data storage system having a second different operating system. For the second operating system the first API call to CSE may be implemented using the primitives of the second operating system. The second operating system may not have a rich or full set of primitives so the API code of the CSE may emulate the necessary functionality of the primitives missing from the second operating system. The API code of the CSE uses the underlying operating system primitives where available and may otherwise synthesize or emulate the functionality necessary as may vary with the capabilities of each operating system.

As described in more detail below a code module may also be coded for use with other APIs besides the API of the CSE.

Referring to shown is an example illustrating general data flow between a code module and code of an API of the CSE in accordance with techniques herein. The example also illustrates the API code utilizing underlying native operating system functionality. The API code effectively provides a wrapper or layer of code around the underlying operating system calls that may be made to implement functionality of the particular API feature and operation. The API thus insulates the code module from the different operating system specific calls that may be made to implement the API functionality providing portability of the code module across different operating systems that may be used in different execution environments. It should be noted that as described herein the underlying operating system functionality may vary with environment. Where a particular functionality needed to perform an operation in connection with the API is not directly available in a native operating system the functionality may be emulated or synthesized using other functionality which is available in the native operating system.

The example includes code module which makes a call API call parameters to code in the API of the CSE. When the code module is executed and the foregoing API call is made control is transferred to an entry point in the API code as indicated by . The API code body is executed and may invoke one or more operating system routines OS routines to implement the particular operation of the API call. Subsequently control is returned to the code module as indicated by when the API code body has completed. It should be noted that in the example the code module calls a routine in the API. The code module may be code developed to run in user mode kernel mode and or in any one of a variety of different environments each having a different operating system. The API routine may return to the calling routine once the called API routine has completed.

The example illustrates a template in which functionality provided in the native environment such as by an operating system may be used by the API of the CSE so that user or developer code invokes the CSE API rather than calling the underlying operating system routines directly. Such code which invokes the API rather than directly invoking the underlying operating system routines provides portability of the developed code module across user and kernel mode as well as the different supported environments.

As described above the CSE may include the API code and other code modules to implement the framework providing portability among different hardware and software platforms e.g. different operating systems data storage systems and underlying hardware and the like . The common software environment may include other code provided as a layer between the API and operating system specific code.

The same API of the CSE may be used by a code module when the code module is executed in user space kernel space and or on different data storage systems having different environments such as different operating system and or processor architecture. The code module may make CSE API calls so that the API implements the same set of API calls to facilitate portability of the code module for execution in user space kernel space different operating systems or on any one of a variety of different software environments that may be supported in accordance with the functionality included in the API. Thus a module coded using the CSE API may be executed in user mode kernel mode or on any supported operating system and calls may be made between two modules coded in accordance with different software environments. Furthermore the same module may be executed on different data storage systems having different data storage system environments provided the particular data storage system environment is supported by the CSE API code. Thus processing dependencies that may vary with operating system and or underlying processor architecture may be handled by the API code of the CSE so that a module utilizing the CSE API may be executed in a variety of different data storage system environments as well as user or kernel mode.

The foregoing describes a user code module such as module which may be coded for use in accordance with the CSE API such as to create a thread. However it may also be possible that other existing code modules are coded for use in accordance with a different API for creating threads. For example a user code module may be coded to use another different API such as for use with a particular operating system such as a Unix based operating system or a proprietary operating system such as the DART Data Access in Real Time real time operating system by EMC Corporation. The DART operating system runs on EMC data storage systems such as the EMC Celerra family of data storage system products by EMC Corporation. Code of the other different API may in turn invoke the CSE API to create a thread.

A code module creating a thread may result in multiple create thread API calls through a hierarchy of different layers of APIs. Thus there may be multiple thread regimes or API layers each corresponding to a different thread model. Each such thread regime or layer may provide an API invoked for implementing and using threads based on a different thread model. For example a first thread regime may provide a first API for use when creating and using threads with a first operating system such as a Unix operating system and its particular first thread model or implementation. A second thread regime may provide a second API for use when creating and using threads with a second operating system such as the DART operating system and its particular second thread model or implementation. A first user code module may be coded in accordance a particular first thread model or implementation of the first operating system using APIs of the first thread regime so that threads of the first code module may use thread specific runtime context information of the first thread model. Similarly a second user code module may be coded in accordance a particular second thread model or implementation of the second operating system using APIs of the second thread regime so that threads of the second code module may use thread specific runtime context information of the second thread model.

In an environment described herein a first code entity of the first user code module may call a second code entity of the second user code module whereby both the first and second code entities may execute in the context of the same first thread. It should be noted that use of the term code entity herein may generally refer to any suitable unit of executable code in an embodiment such as a function routine handler and the like. Described herein are techniques that may be used to facilitate making such calls between two different code entities executing in the context of the same thread whereby the two code entities are each coded for execution in different hardware and or software environments such as different operating systems. As noted above a first code module may include a first module with a first code entity coded for execution on a Unix operating system and a second code module including the second code entity may be coded for execution on a different operating system such as the DART operating system. As such code entities of the two modules each coded for use in a different hardware and or software environment may use different threading regimes or APIs each of which use different thread specific information or context for a particular thread model of the regime. Thread specific context information may be for example runtime state information e.g. different runtime error code and error state information recorded upon the occurrence of an error for a particular thread regime thread attributes and thread local storage particular to a regime or thread model and the like. For example a first code entity of a first code module coded for execution on a first operating system may have a first attribute and or runtime state information which are unknown or not included in thread specific context information for a second thread model used by the second module and second code entity thereof which is coded for execution in a second operating system. However when executing in the context of a thread making calls from a first code entity of a first module coded for use in the first operating system to a second code entity of the second module coded for use in the second operating system it may be necessary to provide the invoked second code entity of the second module with sufficient thread context information of the first thread where such context information is particular for use with the second operating system to properly execute the code of the second entity of the second module when invoked by the first entity of the first module. For example the first module may be coded to use first thread specific context information applicable in the first operating system which needs to be provided in connection with the call made to code of the second module coded for the second operating system which may use different thread specific context information than code of the first module coded for use with the first operating system .

As such when executing in the context of a single thread techniques herein may be used to facilitate making calls between different code entities of different modules such as of the foregoing two modules coded for use in different environments which use different thread regimes based on different thread models by establishing appropriate thread context information needed for making calls across all registered supported environments. Furthermore an embodiment in accordance with techniques herein may include a CSE layer which facilitates execution of both the first and second code modules on the same system and in the same environment by emulating or simulating any needed functionality. The CSE layer and first and second code modules may execute in the context of a single thread of a process on any supported underlying native hardware and or software.

Techniques herein may be used to ensure that for a call made between a first code entity of a first code module to a second code entity of a second code module where each of the two entities execute in the context of the same thread and the two modules may use any supported threading regime and model the called or invoked second code entity of the second module has available the appropriate thread specific context information for the particular thread regime and thread model used by the operating system of invoked second entity of the second module. Techniques herein may be used to facilitate calls between two bodies of executing code each from a different module coded for use with a different regime and thread model where each body of executing code may execute in the context of the same thread.

The thread regimes or layers may be stacked at runtime e.g. form a runtime call stack . For example a first module may use a first API to create a thread which results in a first call to a first thread regime. The first thread regime may include code which further uses a second API to create the requested thread which results in a second call to a second thread regime. In connection with examples provided herein a C like or pseudo code level syntax may be used to express parameters calls and the like.

Referring to shown is an example illustrating components that may be included in an embodiment in accordance with techniques herein. The example includes user code modules thread regimes TRs and CSE layer . The user code module may be coded for use in a Unix based operating system using a Unix based thread regime and model. For example TR may represent the Unix thread regime that includes a first API and thread model used by the code module to create threads. Code of TR may implement and create threads by making calls to the CSE layer which further includes multiple thread regimes CSE API and CSE OSS . Thread regime CSE API may include the API exposed or presented by CSE for use by other code which makes calls into the CSE layer . Thread regime CSE OSS may represent a CSE internal regime which acts as a further insulating layer or regime between and . CSE OSS may include a lower level CSE internally used API which provides an API implementation specific to a particular operating system and makes calls to the different supported native operating systems e.g. any of the operating systems as represented in layer . TR may represent the DART operating system based thread regime that includes a second API and second thread model used by the code module to create threads. Code of TR may implement and create threads by making calls to the CSE layer in a manner similar to code of TR noted above. The user code module may be coded for use in a system running the DART operating system using a DART operating system based thread regime and model and therefore use the API provided by TR for creating threads.

Consistent with description herein CSE may be a layer which insulates code above the CSE layer from dependencies of the underlying operating system or hardware platform that may be in use on a particular system. Element includes operating system through operating system n and hardware platform through hardware platform n and represents the various possible combinations of underlying hardware and or operating system software that may exist in a supported system. Thus the CSE layer may include code to appropriately interface with all supported combinations of hardware and software of to thereby insulate any code above CSE from dependencies in the underlying operating systems and hardware platforms of . It should be noted that is not meant to imply that a single system includes all combinations of operating systems and hardware platforms. Rather element represents the fact that a single system may include any particular one of the N operating systems and or particular one of the M hardware platforms and the CSE may insulate code layers above from any coding dependencies of the particular operating system and or hardware platform.

Element may represent a single executing process having its own process address space execution fault domain and the like. Element illustrates that each of the different elements included therein may be included in the same process and mapped for execution in the same single process address space. It should be noted that there may be a single physical copy of the different regimes or layers and which may be mapped for use into the single process address space for process . For example and may be API routines having code included in one or more libraries which are mapped for use into the address space of each individual executing process.

It should be noted that element representing a single process and its associated address space and may be omitted in some subsequent figures for sake of simplicity

In accordance with techniques herein user code module may include code to create a first thread and may also include code of a first code entity executing in the context of the first thread. The first code entity may make a call to a second code entity of user code module whereby both the first and second code entities execute in the context of the same first thread. To facilitate such calls and ensure that the appropriate thread context information for the first thread may be provided to the second code entity coded for use with a second thread model and regime different from a first thread model and regime used the first code entity techniques described in following paragraphs may be utilized. There may be a different instance of CSE OSS for each of the different N supported operating systems of . Each of the different N supporting operating systems may provide a native operating system OS layer or API for implementing native threads. This is represented in where element represents a particular native OS layer supported by the CSE layer e.g. a particular of the N operating systems represented by that may run on a particular system . There may be an instance of for each particular N native operating system. The example of may represent different software layers in an embodiment in accordance with techniques herein.

Each of the foregoing regimes and may have its own set of APIs and associated code bodies such as for thread creation and for other thread based operations.

Thus when user code module executes and performs a call to create a thread using an API of a call is made to code of TR resulting in a runtime transfer of control to code of . Responsive to the call to code of TR makes a call to create a thread using an API of resulting in a runtime transfer of control to code of . Responsive to the call to code of code of makes a call to create a thread using an API of resulting in a runtime transfer of control to code of . Responsive to the call to the code of uses a native OS API to create a native OS thread. In this manner the initial call from to create a thread results in a runtime execution stack including multiple thread regimes and layers.

The foregoing of are exemplary layers and regimes that may be used in an embodiment. An embodiment may more generally include any number of regimes and layers.

Techniques described in following paragraphs provide the appropriate thread context information at each layer and regime to facilitate making calls between threads of different code modules each possibly coded based on a different thread regime and thread model.

With reference to elements and may be included in infrastructure code of a system and facility in accordance with techniques herein for use by one or more user code modules . Each of the layers or regimes and may represent a body of code providing an API for use by a layer above said each layer in the runtime stack.

Each of the layers or regimes and may be characterized as providing an API for creating and using threads as well as possibly other processing. In connection with a runtime stack or call chain for creating a thread a first API at an upper level in the stack for creating threads is mapped to a second API at a lower level in the stack for creating threads. Thus to create a thread generally involves invoking multiple APIs for creating threads at different levels in the runtime stack based on such mapping between APIs of different levels or regimes.

What will be described in following paragraphs are some examples of increasing and varying complexity illustrating the different layers and regimes that may be included in a particular runtime stack for creating threads depending on which thread regime API and thread model is used by the user code module.

A first example will consider a user code module which interfaces directly with the CSE API . A second example will consider a user code module such as module which interfaces directly with a different TR such as TR that runs on top of CSE API . A third example will consider a more complex example in which not all the thread regimes are loaded and registered when a first module creates threads. For example as part of initialization or startup only the native OS and the lower regimes CSE OSS may be loaded for use. The first user code module may interface directly with the CSE OSS layer to create worker threads as part of this initialization process. Later on additional regimes and may be loaded and registered for use. Techniques herein may be used to further provide appropriate context information for use in regimes and since it may be possible that threads of the CSE OSS layer or regime may make calls to and or receive calls from other threads or bodies of code which use any one or more of the regimes and . In other words the third example illustrates processing that may be performed with a thread which is created prior to other upper level thread regimes such as being registered and loaded.

Referring to shown is an illustration of the first example in accordance with techniques herein. As mentioned above the first example described in following paragraphs is made with reference to the illustration of where a user code module uses the thread API or regime and associated thread model of the CSE API to directly call into the code of the regime to create a thread. In accordance with techniques herein the runtime stack of regimes or layers may include and with a different create thread API being invoked at each layer or regime in the foregoing stack at runtime responsive to an initial call made from to to create the thread. This runtime call stack is further illustrated with reference to .

The example of illustrates the runtime execution flow of the first example. The four boxes on the left hand side illustrate runtime execution flow between different regimes or API layers going down the runtime stack to create a new second native thread between different create thread APIs of the different layers or regimes. The sequence of calls illustrated by the four boxes on the left hand side may form a first runtime call stack that may also be referred to as the create thread call chain. Code of a first executing thread may include call to create a second new thread. In connection with creating this second new thread and responsive to executing call the sequence of API calls of the first runtime call stack including the create thread call chain through layers and may be made resulting in creation of the second native OS thread by executing . It should be noted that execution of the create thread call chain to create the second new thread are executed in the context of the first thread. Once the second new native OS thread has been created at the processing of the first thread may return up the runtime stack through the layers where the first thread resumes execution following the point of invocation which created the second new thread.

Subsequently the newly created second thread spawned by the native OS create thread call at continues processing as denoted by with its own runtime stack. In the context of the newly created second thread processing and runtime flow continues with an additional chain of calls traversing back through the layers of the create thread call chain in a reverse layer ordering as illustrated by the different regimes or API layers on the right hand side of the example . The sequence of calls illustrated by the four boxes on the right hand side may be included in a second runtime call stack for the second thread that may be also be referred to herein as the callback call chain which includes a sequence of callbacks between layers or regimes from the native OS to a code body of the newly created second thread in the user code module

Thus element represents a create thread call chain that may be included in the first runtime call stack for the first thread to create a second new thread. Element represents a callback call chain that may be included in a second runtime call stack for the newly created second thread.

In connection with the runtime execution flow down the runtime stack of regimes or API layers reference is made to the 4 boxes on the left side of the example comprising the create thread call chain whereby such processing executes in the context of the first thread. The create thread call chain illustrated by the 4 boxes on the left side illustrates the series of calls between thread create APIs of different layers or regimes. In a first step a call is made from user module at statement to CSE API using the appropriate API call CSE API thread create of the regime . Element represents the body of code for the entry point CSE API thread create to which control is transferred as a result of executing . In a second step a call is made from the body of code at line to the CSE OSS using the appropriate API call CSE OSS thread create of the regime . Element represents the body of code for the entry point CSE OSS thread create to which control is transferred as a result of executing

In a third step a call is made from the body of code at line to the native OS using the appropriate API call os native thread create of the regime . Element represents the body of code for the entry point os native thread create to which control is transferred as a result of executing . The code of results in creation of a new second native thread at line . Following execution of line two things occur. First the first thread processing returns up the create thread call chain to the point following whereby the first thread may then continue execution. Secondly the second new native thread is created as a result of the line whereby the second thread then proceeds with its own runtime execution flow with calls denoted by from the native OS to each regime or API layer previously traversed in connection with the create thread API call chain.

In connection with the runtime execution of the second new thread including a next set of calls through the regimes or API layers reference is made to the 4 boxes on the right side of the example comprising the callback call chain . After the new second native OS thread is created in the newly created second thread commences execution with the os native thread wrapper routine or callback . Code of then performs a callback into the regime or layer . The callback from to is represented by statement which is a call to CSE OSS thread wrapper resulting in transfer of control to the body of code having entry point CSE OSS thread wrapper. The body of code may then perform a callback into the regime or layer . The callback from to is represented by statement which is a call to CSE API thread wrapper resulting in transfer of control to the body of code having entry point CSE API thread wrapper.

The body of code may then perform a callback into the user code module to the entry point for the thread body of code FOO. In this example FOO may represent the code body of the newly create second thread which is now being executed as a result of the transfer of control to . The callback from to is represented by statement which is a call to thread body FOO resulting in transfer of control to the body of code having entry point thread body FOO.

Each regime or level has thread specific context information for each thread created such as for the second thread described above. When a create thread API call of the create thread call chain is performed from a first layer or regime to a second layer or regime where the first layer is above the second layer in the runtime stack as illustrated by the execution flow on the left side of the example the first layer or regime provides the address or entry point of the callback routine body of code located in the first layer or regime. The address or entry point of the callback routine may be communicated from the first layer to the second layer as a parameter of the create thread API call made from the first layer to the second layer. Subsequently the callback routine of the first layer may be invoked from the second layer at a later point in time in the callback call chain.

As described herein the callback is included in a series of subsequent callbacks forming the callback call chain illustrated by the execution flow through the layers as denoted by the 4 boxes on the right side of As illustrated in by the boxes on the right hand side of the example the order in which the layers or regimes are traversed in connection with the callbacks from the native OS to thread body FOO of is the reverse ordering of layer traversal associated with the create thread API call chain e.g. reverse ordering of the runtime traversal of layers illustrated by the boxes on the left side of the example .

Processing that may be performed by each of the thread wrapper code bodies and as well as other bodies of code and also the API details for the various calls are described in more detail elsewhere herein.

The chain of callbacks as illustrated by execution flow on the right side of the example results in transferring control through the various layers until the thread body is reached in the user code module . The mechanism providing the linkage for performing the callbacks is described in more detail in following paragraphs.

The foregoing generally describes the runtime execution flow of the calls performed for creating a thread for the different layers or regimes. What will now be described is the information that may be accumulated at each layer how information from one layer is passed to another layer in the runtime stack in connection with the create thread call chain e.g. boxes on the left side of of the first thread issuing an initial call to create the new second thread and how the various layers of the create thread call chain runtime stack are then traversed in reverse order in connection with a subsequent series of callbacks e.g. boxes on right hand side of comprising the runtime call chain of the second newly created thread.

Each of the thread create APIs of the example may generally have a name represented as XXX thread create provided by a regime or layer where XXX may denote the particular regime or layer including the body of code for XXX thread create. As a result of making the call XXX thread create control is transferred from a first layer or regime e.g. immediately above XXX in the runtime stack to the regime or layer XXX. The following may represent the parameters of one of the XXX thread create APIs e.g. such as of regimes or layers and XXX thread create p1 p2 p3 . . . whereby

p1 is a parameter that is a handle or pointer to thread specific context information used by layer XXX in the runtime stack e.g. layer XXX is going to assign a value to p1 

p2 is a parameter identifying a callback or entry point of code in the first layer or regime above XXX whereby the callback is to be called back as part of the callback call chain of the runtime flow of execution traversing the layers of the thread create call chain in reverse order e.g. as illustrated by the right hand side of the example which traverses the layers of the create thread call chain in reverse order and

p3 is a parameter that identifies thread specific context information used by the first layer or regime above XXX in the runtime stack whereby this particular call instance XXX thread create is made from the first layer or regime to the layer or regime XXX. Parameter p3 identifies the thread specific context information used by the first layer or regime for the newly created thread such as the second thread described above in connection with .

It should be noted that an embodiment may also include other parameters as represented above by the trailing ellipses . . . following parameter p3. Described in more detail elsewhere herein when the callback is made using parameter p2 the callback may include passing parameter p3 for use by the code of the callback.

Reference is now made to . The example of shows the create thread call chain e.g. on the right hand side of execution flow from the example down the runtime stack with additional details provided regarding the create thread API parameters for each level and the thread specific data area of each level. Elements and provide further details regarding the parameters for each create thread call to a regime or layer. Elements and identify the different thread specific context information data areas of the different regimes or levels. Element identifies context information that may be used by the thread FOO being created. It should be noted that there may be an instance of and for each thread created by a call instance from the user code module

To further illustrate element represents a call to CSE API thread create made from module to regime or layer CSE API to regime. In this case the parameters of the call CSE API thread create may be as follows 

p1 is CSE API thread handle a pointer or handle to thread specific context information used by layer CSE API 

p2 is thread body FOO and identifies the entry point or body of code for the callback which is the thread body of code e.g. the callback made at from CSE API thread wrapper of CSE API to thread FOO of user module as illustrated in and

p3 is FOO context an address or otherwise identifies the thread specific context information used by the created thread FOO in the user code module

Element represents a call to CSE OSS thread create made from regime or layer CSE API to regime or layer CSE OSS . In this case the parameters of the call CSE OSS thread create may be as follows 

p3 is CSE API thread handle an address or otherwise identifies the thread specific context information described below used by layer or regime CSE API for the newly created thread to be created by execution of and of native OS .

Element represents a call to os native thread create made from regime or layer CSE OSS to the native OS . In this case the parameters of the call may be as follows 

p1 is CSE OSS thread handle os native thread handle a pointer or handle to thread specific context information used by layer native OS 

p2 is CSE OSS thread wrapper and identifies the entry point or body of code for the callback CSE OSS thread wrapper e.g. the callback made from the native OS to CSE OSS as illustrated by the transfer of control at from native OS to the CSE OSS thread wrapper in and

p3 is CSE OSS thread handle an address or otherwise identifies the thread specific context information described below used by layer or regime CSE OSS for the newly created thread to be created by execution of and of native OS .

Generally the body of code for an XXX thread create API of a regime or layer may perform processing including 

1. Allocating storage for the thread specific context information area used by layer XXX for the new thread to be created by execution of and of native OS .

parameter p2 e.g. the callback entry point or the body of code invoked for the callback to layer XXX in the series of calls illustrated by boxes on the right hand side of parameter p3 and

optionally any other thread specific context information used by layer XXX. It should be noted that the thread specific context information area also includes a pointer to the thread specific context information of the layer below XXX in the create thread API call chain of the runtime stack which is filled in as a result of completing the call in 3. below.

To further illustrate the body of code CSE OSS thread create may allocate storage for the thread specific context information data area CSE OSS thread handle e.g. used by layer CSE OSS populate the storage area just allocated with the thread specific context information including 

It should be noted that each of the XXX thread create bodies of code may also perform other processing as described in more detail elsewhere herein.

In a similar manner as noted above for thread specific context information area the storage area CSE API thread handle used by the CSE API layer may include 

It should be noted that each of the thread specific context information areas and at each layer or regime may also include other fields of context information that may be used specifically by that particular layer or regime as well as a code module coded for use with that particular layer or regime.

Continuing with the first example and with reference to assume there is a call in the user code module from the thread body FOO in line to obtain a piece of its own thread specific context information such as its thread name FOO and the user code module does not have the requested data in FOO s own local thread specific context information . Such requested thread specific context information regarding the thread name may be data included in thread specific context information for FOO at a different regime or layer e.g. such as may be included in any of and or of . In this example the thread NAME may be included in the thread specific context information for layer or regime CSE API and thus in the data area identified by CSE API thread handle field

The native OS may include APIs to store and retrieve information for each thread such as regarding the execution context of each thread. An embodiment may use a structure execution context for each thread created by the OS. The native OS may include APIs to set and get a pointer to the execution context structure for a particular thread. For example the native OS may include an API get os native tls ptr to get or retrieve a pointer to the execution context structure for a particular thread and an API set os native tls ptr to set a pointer to an execution context structure for a particular thread. The thread may be for example the currently executing thread such as FOO.

Element represents information that may be included in an execution context structure for thread FOO. The execution context for a thread FOO may be characterized as a low level OS structure that includes information about the thread enabling processing to retrieve and locate the different data areas including thread specific context information for the different layers or regimes such as the non OS layers or regimes e.g. data areas containing the thread specific context information as illustrated in . The execution context structure may be used by processing such as described in following paragraphs and elsewhere herein to link to the thread specific context information used by the different layers or regimes.

Generally the execution context structure created and maintained for each thread may include a field such as a pointer for each supported layer or regime whereby the field identifies the thread specific context information for that layer or regime. The execution context structure may also include other information for the particular thread such as other information that is commonly used by all thread regimes or layers. In the execution context fields may identify the data areas including the thread specific context information used by different supported regimes or layers. For example element identifies the data area CSE OSS thread handle of including thread specific context information for the CSE OSS layer regime. Element identifies data area CSE API thread handle including thread specific context information for the CSE API layer regime . Elements and may be null or otherwise not identify data areas for regimes TR and TR in this particular example since such regimes are not included in the runtime stack for the current thread FOO as illustrated in .

Element identifies the data area for thread specific context information used by the CSE API layer or regime as described above with the additional field which includes a string that is the thread s name FOO .

Processing that may be performed in an embodiment in accordance with techniques herein to set or initialize the information stored in the execution context structure for a created thread is described in more detail elsewhere herein in connection with detail provided regarding the thread wrappers included in the callbacks invoked. Additionally the thread specific information such as the thread name FOO of field may have been previously stored such as by the thread wrapper CSE API thread wrapper of prior to calling the thread body FOO in

In the example a call is made at to the API CSE API GET MY THREAD NAME in the CSE API regime or layer to return a string that is the currently executing thread s name. Execution of causes a transfer of control to the body of code for CSE API GET MY THREAD NAME. In line a call is made using a native OS API get os native tls ptr described above which returns a pointer to the execution context structure for the currently executing thread FOO. In this example the call in returns a pointer to the execution context structure . Line retrieves the thread name from field using the information of pointer to CSE API thread handle which identifies the data area including the desired thread specific context information for the CSE API regime . The context of is retrieved and also returned to the point of call in thread FOO.

As a variation to the foregoing it may be that the CSE API layer or regime did not include the thread name in its thread specific context information of . Rather the thread name may be stored in other thread specific context information at a different layer or regime. For example assume the thread name is a field in the thread specific information of the CSE OSS layer in this case the code of may further invoke an API of the CSE OSS layer to retrieve and return the thread name from its thread specific information . The thread name may then be returned as a value to the original calling thread FOO of module

Referring to shown is an illustration of the second example in accordance with techniques herein. As mentioned above the second example considers the user code module which interfaces directly with a different thread regime or layer TR that runs on top of CSE API . The second example described in following paragraphs is made with reference to the illustration of where a user code module uses the thread API or regime and associated thread model of the TR to directly call into the code of the regime to create a thread. In accordance with techniques herein the runtime stack of regimes or layers may include and with a different create thread API being invoked at each layer or regime in the foregoing stack at runtime responsive to an initial call made from to to create the thread. This runtime call stack is further illustrated with reference to below. In the second example as in there is also an additional thread regime TR which is not included in the runtime call stack when creating a thread for user code module . As described above each layer or regime in the runtime call stack performs processing to store thread specific context information in a data area for that particular level. However since TR is not included in the call stack its thread specific information is not filled in as part of the runtime call stack processing of the create thread call chain. Thus assuming the second newly created thread is thread FOO and if a call is ever made from a thread FOO of to an API in TR directly or indirectly the thread specific context information for FOO in TR is not completed or filled in. What will now be described is how an embodiment may complete or fill in the thread specific context information for thread such as FOO in a regime or layer such as TR which is not included in the runtime call stack.

Before proceeding further with details of the second example a general description is provided regarding aspects of the facility described herein. Each thread regime or layer other than the native OS layer providing an API for use with threads such as to create threads may initially register with the infrastructure prior to any user code module invoking APIs of the layer or regime for creating threads.

For example with reference to the thread regimes or layers that register with the infrastructure or facility described herein are TR TR CSE API and CSE OSS . Registration may occur for example as part of initialization and loading of a particular thread regime or layer providing a set of APIs for use with techniques herein. Similarly when a thread regime or layer providing a set of thread APIs for use with techniques herein is unloaded for use with techniques herein the thread regime or layer unregisters with the infrastructure or facility.

Code for the register and unregister APIs may be generally included in a library of routines provided for use with the infrastructure and techniques described herein.

To further illustrate consider the TR thread regime or layer. As part of initializing and loading TR the following function or routine may be executed where the function or routine includes performing registration with the infrastructure or facility described herein 

The birth callback for a regime such as TR birth callback may be invoked as part of processing performed when creating a thread when TR is not otherwise invoked as part of the create thread call chain of the runtime stack e.g. as illustrated in . In this manner the birth callback for a regime or layer may include performing processing to create and initialize a data area including thread specific context information for the regime or layer such as TR when such processing has not already been performed as part of the runtime stack when creating a thread. TR may include the bodies of code for the above mentioned birth and death callbacks specified in the registration API when registering TR.

Each regime or layer may register using the foregoing API thread regime callbacks register in a manner similar to that as described for TR.

With reference to the particular second example as in the birth callback for TR may be invoked as part of processing when creating a thread FOO included in module where the create thread call chain of the runtime stack processing does not otherwise result in calling the TR create thread API to create and initialize a data area including thread specific context information for the regime or layer TR.

In addition to each regime registering with the facility or infrastructure described herein each regime may also unregister for example when code of the regime is being unloaded or processing is otherwise performed to decouple the regime so that it is not used in connection with techniques herein.

The following may be an example of a routine executed in connection with deinitialization processing for a regime such as TR where such processing includes invoking an unregister API that may be used when unregistering a thread regime or layer 

In the foregoing deinitialization routine the following is the examplary unregister API that may be used in connection with techniques herein to unregister with the infrastructure thread regime callbacks unregister TR REGIME ID where

TR REGIME ID is the unique thread regime or layer identifier as specified in the registration API when previously registering TR. TR world deinit arg1i . . . argNi may be invoked when unloading regime TR.

Each regime or layer may unregister using the foregoing API thread regime callbacks unregister in a manner similar to that as described for TR.

Referring to shown is an example illustrating data structures that may be used in an embodiment in accordance with techniques herein for a single process. The example includes a thread world global information info structure which includes regime information and a list of execution context structures . The information of may be characterized as global in that a single set of the information in may be maintained for the infrastructure with respect to all threads and all regimes in a single process.

The regime information may include information such as the function pointer or code entry point for all registered birth and death callbacks and an outstanding thread count for each supported regime or layer as identified by a column header . It should be noted that may be an array of integer values where the array includes an entry for each supported regime or layer. The value of an entry in the array for corresponding to a particular regime or layer may denote the number of existing threads which have a data area including thread specific context information created and initialized through the birth callback for that regime. The array may be used for example in connection with cleanup processing performed when the particular regime is unregistered.

The execution context list may identify a list of execution contexts including thread specific context information that has been created as a result of a birth callback for any regime for all threads created.

Element provides additional information that may be included in an execution context structure as briefly mentioned elsewhere herein. An execution context may be created for each thread created. In one embodiment the execution context which is associated with a particular thread created using techniques herein may be created and initialized by the thread wrapper or callback of the CSE OS layer or regime e.g. by code of the callback CSE OSS thread wrapper which is invoked as part of the callback call chain . Each execution context structure may include information identifying the different data areas of thread specific context information for each of the thread regimes or layers. It should be noted that element is similar to that as described in element of . In this manner the information in may be updated by the appropriate thread wrapper callback routines invoked as part of the callback call chain when executing in the context of the newly created thread.

The execution context structure may also include an in use mask a disable mask and a regime context vector or array where each of the foregoing and includes an entry for each supported regime or layer.

The disable mask may include an entry for each supported regime or layer and may be used in connection with determining which if any birth callbacks to invoke to ensure that a data area including thread specific context information for each supported regime or layer is created and initialized for each thread that is created.

The regime context array is an array of pointers and includes an entry for each supported regime or layer. An entry of the regime context array corresponding to a regime or layer identifies the data area of thread specific context information for the regime or layer if such data area is created and initialized by invocation of the birth callback for the regime e.g. thereby indicating that the thread create API of the regime or layer is not included in the thread create call chain of the runtime stack for the thread having the execution context . Otherwise the entry of the regime context array corresponding to the regime or layer may be null or some other value denoting that the data area of thread specific context information for the regime or layer is otherwise created and initialized as a result of calling the regime or layer s create thread API as part of the create thread call chain of the runtime stack for the thread having the execution context .

The in use mask may include a 1 for each entry corresponding to a regime or layer in which the regime or layer s data area of the thread specific context information is created and initialized by the regime s registered birth callback. Thus an entry of the in use mask corresponding to a regime or layer and having a value of 1 denotes that an entry of the regime context array for the regime or layer is non null and identifies the regime or layer s data area of the thread specific context information is created and initialized by the regime s registered birth callback.

The foregoing data structures and use in connection with techniques herein are described in more detail elsewhere. For example as described elsewhere herein the callback routines such as the thread wrappers invoked as part of the callback call chain may perform processing using Boolean variables described below to determine whether to invoke any of the registered birth callbacks. As also described below and elsewhere herein each of the Boolean variables may have a value determined using the disable mask Allocating storage for a data area including thread specific context information for a layer or regime may be performed responsive to invoking the registered birth callback for the layer or regime. Thus such processing may also appropriately update the entries of the regime context array and in use mask for that regime or layer. Similarly dellocating storage for a data area including thread specific context information for a layer or regime may be performed responsive to invoking the registered death callback for the layer or regime. Thus such processing may also appropriately update the entries of the regime context array and in use mask for that regime or layer.

With reference back to and the second example each of the regimes or layers TR TR CSE API and CSE OSS may invoke the register API thread regime callbacks register to register the birth and death callback routines for each regime. As a result of this regime registration the rows of information of the regime information may be populated. At this point prior to any threads being created the outstanding thread count may include a zero in each entry since no threads have been created. Subsequently a call may be made from user code module to create a thread such as a thread FOO as described in connection with the first example with the difference that the user code module directly invokes an API of the TR regime or layer in the second example with a runtime stack through layers and thereby omitting TR as mentioned above .

Referring to shown is an example illustrating the runtime execution flow of the second example when creating a thread which generally follows a similar pattern of execution flow as described above in connection with . Element includes the five boxes on the left hand side illustrating runtime execution flow of the create thread call chain between different regimes or API layers of the runtime stack to create a new second native thread such as thread FOO. As described above the create thread call chain executes in the context of a first thread including code which issues a call to create the new second native thread FOO. Once is executed in the context of the first thread two things occur. First runtime processing for the first thread returns up the create thread call chain comprising the runtime stack of the first thread s execution by returning along the path through layers to whereby the first thread resumes execution following . Secondly for the newly created second thread processing for the newly created second thread continues with processing and runtime flow for the second thread comprising the callback call chain as illustrated by traversal of the different regimes or API layers on the right hand side of the example .

In connection with the runtime execution flow for the create thread call chain executing in the context of the first thread to create the second new thread reference is made to the 5 boxes on the left side of the example . User code module includes the body of code for the first thread. The body of code of the first thread includes a call to create the new second thread. In a first step a call is made from the body of code of the user module at statement to TR using the appropriate API call TR thread create of the regime . Element represents the body of code for the entry point TR thread create to which control is transferred as a result of executing .

In a second step a call is made from the body of code at line to CSE API using the appropriate API call CSE API thread create of the regime . Element represents the body of code for the entry point CSE API thread create to which control is transferred as a result of executing

In a third step a call is made from the body of code at line to the CSE OSS using the appropriate API call CSE OSS thread create of the regime . Element represents the body of code for the entry point CSE OSS thread create to which control is transferred as a result of executing

In a fourth step a call is made from the body of code at line to the native OS using the appropriate API call os native thread create of the regime . Element represents the body of code for the entry point os native thread create to which control is transferred as a result of executing . The code of results in creation of a native thread as illustrated by . Once the native thread has been created as result of two things occur. First control returns up the create thread call chain back to the statement following whereby the first thread continues execution. Additionally execution of the newly created second thread continues as illustrated by with a second runtime stack of the second thread comprising the callback call chain which traverses layers e.g. regimes or API layers of in reverse order.

In connection with the callback call chain portion of the runtime stack reference is made to the 5 boxes on the right side of the example . After the native OS thread is created in control is transferred to the os native thread wrapper which executes in the context of the second newly created thread. The code of then performs a callback into the regime or layer . The callback from to is represented by statement which is a call to CSE OSS thread wrapper resulting in transfer of control to the body of code having entry point CSE OSS thread wrapper. The body of code may then perform a callback into the regime or layer . The callback from layer or regimes to is represented by statement which is a call to CSE API thread wrapper resulting in transfer of control to the body of code having entry point CSE API thread wrapper.

The body of code may then perform a callback into the regime or layer . The callback from layer or regimes to is represented by statement which is a call to TR thread wrapper resulting in transfer of control to the body of code having entry point TR thread wrapper.

The body of code may then perform a callback into the user code module to the entry point for the thread body of code FOO. In this example FOO may represent the code of the newly created thread s body e.g. thread created by which is now being executed as a result of the transfer of control to . The callback from to is represented by statement which is a call to thread body FOO resulting in transfer of control to the body of code having entry point thread body FOO.

As with the first example described above e.g. each regime or level has thread specific context information for each thread created. When a create thread API call of the create thread call chain is made from a first level or regime to a second level or regime e.g. as illustrated by the execution flow of on the left side of the example the first level or regime provides the address or entry point of the body of code for the callback routine of the first level or regime that is invoked as part of the callback call chain . The address or entry point of the callback routine may be communicated from the first layer to the second layer as a parameter of the create thread API call made from the first layer to the second layer. Subsequently the callback routine of the first layer may be invoked from the second layer at a later point in time in the callback call chain.

As described herein the callback is included in a series of subsequent callbacks forming the callback call chain illustrated by the execution flow through the layers as denoted by the 5 boxes on the right side of whereby the routines invoked as part of the callback chain execute in the context of the new thread created by . As illustrated by the boxes of on the right hand side of the example the order in which the layers or regimes are traversed in connection with the callbacks from the native OS to thread FOO of is the reverse ordering of layer traversal associated with the create thread API call chain e.g. reverse ordering of the runtime traversal of layers illustrated by the boxes of on the left side of the example of the first thread which issued the call to create the second thread.

Processing that may be performed by each of the thread wrapper code bodies and as well as other bodies of code and also the API details for the various calls are described in more detail elsewhere herein.

The chain of callbacks of as illustrated by execution flow on the right side of the example results in transferring control through different layers or regimes until the thread body is reached in the user code module

What will now be described is processing that may be performed in an embodiment in accordance with techniques herein to identify the particular one or more thread regimes or layers that have not been traversed e.g. are not included in the create thread call chain of runtime call stack of the first thread when creating a second new thread.

When creating the second new thread and traversing down through each regime or layer of of the runtime stack e.g. left side boxes of the example processing is performed by code executing in the context of the first thread at each non OS layer thread create API to set the disable mask bit for that particular regime or layer. In this manner the disable mask may be used to identify any non OS layers or regimes which are not included in the create thread call chain of the runtime stack when creating a thread whereby after completing the create thread call chain the disable mask includes a 0 for each layer or regime not included in the create thread call chain of the runtime stack and otherwise includes a 1 e.g. set for each layer or regime included in the create thread call chain of the runtime stack.

When invoking the thread create API of a first layer or regime the code of the thread create API has knowledge regarding what layers or regimes if any may make appear above the first layer or regime in the create thread call chain portion of the runtime stack e.g. what other layers may call into the first layer using the first layer s thread create API in the runtime stack . In this manner the code of the thread API of the first layer may examine the entries of the disable mask corresponding to those layer s that may appear above the first layer in the create thread call chain of the runtime stack when creating a thread. For each such layer that may appear above the first layer in the create thread call chain of the runtime stack the create thread API of the first layer may record information in its thread specific context information identifying which layer is included in the create thread call chain portion of the runtime stack immediately above the first layer.

For example with reference to TR and TR may possibly be in the create thread call chain of runtime stack above the CSE API layer when creating a thread. With the second example the create thread call chain of the runtime stack includes TR above layer . With reference now to the TR thread create code may set the disable mask bit of corresponding to TR prior to and then call CSE API thread create at line causing a transfer of control to the body of code for CSE API thread create. Within the code prior to calling CSE OSS thread create at line the following may be performed to set two Booleans or flag values call TR regime callback and call TR regime callback included in the thread specific context information for layer

The value of the Boolean variable call TR regime callback corresponding to TR may have a value of 0 or false if the TR layer thread specific context information does not need to be created and initialized and otherwise may have a value of 1 or true denoting that the TR layer thread specific context information needs to be created and initialized.

With reference back to the values for the Boolean variables call TR regime callback and call TR regime callback may be included in the thread specific context information for the CSE API regime

In a similar manner in the CSE OSS layer within the code prior to calling native os thread create at line the following may be performed to set a Boolean or flag value call CSE API regime callback included in the thread specific context information for layer

It should be noted that the foregoing knowledge encoded in a first regime or layer regarding what other regimes or layers may possibly be above the first regime or layer in the create thread call chain of the runtime stack when creating a thread may be obtained in other suitable ways than as just described above. For example an embodiment may provide a service or routine which is invoked with a parameter identifying a particular regime or layer. The service or routine may return as an output the list of other regimes or layers if any that may appear in the create thread call chain above the particular regime or layer in the runtime stack when creating a thread. The first layer or regime may then use this returned information to examine the appropriate corresponding bits of the disable mask to store additional information in the thread specific context information for the first layer or regime as described.

In this manner the values of the foregoing Boolean variables in the thread specific context information may be used to identify any birth callback s to be invoked for a regime or layer having one of the foregoing Boolean variables with a value of 1 or TRUE.

With reference to a thread wrapper or callback at a first layer or regime e.g. and may use any of the foregoing Boolean variables stored in the thread specific context information of the first layer or regime to determine whether to invoke any birth callback for another layer or regime which may appear above the first regime in the create thread call chain of the runtime call stack when creating a thread. For example the code of CSE OSS thread wrapper may examine the value of the Boolean call CSE API regime callback included in the thread specific context information for regime CSE OSS to determine whether to call the birth callback in for the CSE API regime whereby the birth callback for the CSE API regime may be invoked if the value of call CSE API regime callback is true 1 .

Similarly code of CSE API thread wrapper may examine the value of the Boolean call TR regime callback as included in the thread specific context information for regime CSE API to determine whether to call the birth callback in for the TR regime whereby the birth callback for the TR regime may be invoked if the value of call TR regime callback is true 1 .

Code of CSE API thread wrapper may also examine the value of the Boolean call TR regime callback as included in the thread specific context information for regime CSE API to determine whether to call the birth callback in for the TR regime whereby the birth callback for the TR regime may be invoked if the value of callTR regime callback is true 1 .

It should be noted that use of the disable mask and performing processing as just described allows for determination of which regimes or layers if any were not included in the create thread call chain of the runtime stack when creating a thread and thereby allows for determining which birth callbacks for regimes or layers should be invoked to create and initialize data areas with thread specific context information for the newly created thread e.g. created by . The foregoing may be performed without requiring modification of any of the APIs of the different thread regimes or layers which may not be feasible in an embodiment. In other words another possible way in which information may be communicated for use with techniques herein is through introduction of additional API parameters for regimes which passes required information up and or down the create thread call chain of the runtime call stack when creating a thread. However the APIs of the different regimes or layers typically cannot be modified so other techniques such as those described herein may be used to determine and communicate necessary information between different code bodies.

Processing proceeds through the chain of callbacks of the runtime stack e.g. as illustrated by including calls traversing in sequence the layers and on the right hand side of whereby code of the callbacks or thread wrappers in the call chain are executed in the context of the newly created thread. A first callback of a first layer determines for the set of layers which may possibly be included in the create thread call chain of runtime stack above the first layer which of layers of the set if any were not included e.g. invoked in the create thread call chain of runtime stack immediately above the first layer. The first layer then proceeds with invoking the birth callback for each such layer of the set that was not included in the create thread call chain immediately above the first layer.

For the second example described above in connection with based on the foregoing the birth callback for regime or layer TR is invoked by code of the CSE API thread wrapper of .

It should be noted that the regime context vector or array of is an array of pointers that may be used in an embodiment in connection with referencing thread specific context information through multiple levels of pointers such as when invoking a birth callback.

For example with reference to shown is an example including the regime context array of pointers. The example illustrates that the regime context entry for a particular regime such as TR may be a first pointer to TR thread handle e.g. similar to the data area identified by or as illustrated in where TR thread handle is a second pointer to the TR thread specific context information created and initialized as a results of invoking the registered TR birth callback. Other entries of the regime context array may similarly point to or identify other data areas of the thread specific context information of other regimes or layers where each such data area is created and initialized by a birth callback. However in this particular second example only TR s thread specific context information is stored in a data area that is created and initialized as a result of invoking a birth callback the TR birth callback so that all other entries of corresponding to other regimes or layers are null. In the second example each of the remaining supported regimes or layers other than TR have their respective data areas including thread specific context information particular to each regime or layer created and initialized as part of the create thread call chain of the runtime stack.

Additionally with reference to the second example the in use mask may include a 1 in the corresponding entry for TR and a 0 in all remaining entries corresponding to other regimes or layers. The in use mask may include a 1 for each entry corresponding to a regime or layer in which the regime or layer s data area of the thread specific context information is created and initialized by the regime s registered birth callback. Thus an entry of the in use mask corresponding to a regime or layer such as TR having a value of 1 denotes that an entry of the regime context array for the regime or layer is non null and identifies the regime or layer s data area of the thread specific context information is created and initialized by the regime s registered birth callback.

The particular use of the regime context array is illustrated in more detail in connection with a pseudo code like description provided for various routines that may be used in an embodiment in accordance with techniques herein.

As described herein a thread create API may be included in each of the different regimes or layers whereby for a first executing thread a create thread call chain of a runtime stack may include invoking one or more such thread create APIs which result in creating a new second OS native thread. Once the second thread is created by code of the native OS layer processing of the first thread may return back up through the layers of the create thread call chain to resume execution of the first thread following the initial create thread API invocation e.g. such as of . In this manner the create thread call chain of the first thread may unwind. Additionally execution of the newly created second thread proceeds with invoking one or more thread wrappers as callbacks in the different regimes or layers of the callback call chain to finally result in execution of code of the thread body for the newly created thread. Once the newly created thread completes its processing the thread may return e.g. exit terminate and the like thereby subsequently causing an unwinding of its runtime stack such as illustrated by the call chain of . For example with reference to responsive to code of the thread body for FOO of user module exiting or returning processing may be performed to return in the reverse direction e.g. unwind along the newly created thread s runtime stack. The return path may be as follows e g where and are the thread wrappers or callbacks respectively at layers and .

In connection with unwinding the runtime stack for the newly created thread FOO having the body of code any of the thread wrappers which issued birth callbacks may also now issue corresponding death callbacks during this unwinding. Recall that a registered birth callback for a first regime or layer is invoked by one of the thread wrappers e.g. to create and initialize a data area including thread specific context information for the first regime or layer which was not included in the create thread call chain of create thread APIs e.g. of e.g. from user code module to native OS . In a complementary fashion responsive to a thread returning or exiting a death callback is invoked for each regime or layer where a prior birth callback was invoked for that same regime or layer. A death callback registered for a first regime or layer may for example perform processing to deallocate storage previously allocated for the thread specific context information in a prior birth callback registered for the first regime.

As described above with a birth callback invocation a first layer or regime may invoke a registered death callback for a second layer or regime which may possibly be included in the create thread call chain of the runtime stack of create thread API calls above e.g. prior to the first layer and whereby the second layer or regime was actually not included in the create thread call chain of the runtime stack of create thread API calls.

For the second example described above in connection with based on the foregoing the death callback registered for regime or layer TR is invoked by code of the CSE API thread wrapper of while returning through the runtime execution stack layers of layers in order when unwinding the runtime stack upon thread exit or return e.g. completion of thread body FOO completing execution . For example the death callback for TR may be invoked during the unwinding of from layer to to unwind the callback call chain following the statement in the code of CSE API thread wrapper .

Reference is now made to . The example of shows the create thread call chain e.g. the left hand side of execution flow for the second example with additional details provided regarding the create thread API parameters for each level and the thread specific data area of each level. Additionally provides further details regarding the create thread APIs invoked at each layer in the runtime stack in a manner similar to that as described herein with for the first example. The difference between is that includes such details and modification for the additional create thread API for layer or regime TR included in the create thread call chain of the runtime stack of the first thread for the second example e.g. but not the first example e.g. .

Elements and provide further details regarding the parameters for each create thread call to a regime or layer. Elements and identify the different thread specific context information data areas of the different regimes or levels and element identifies context information that may be used by the thread FOO being created. It should be noted that there may be an instance of and for each thread created by a call instance from the user code module

To further illustrate element represents a call to TR thread create made from module to regime or layer TR . In this case the parameters of the call TR thread create may be as follows 

p2 is thread body FOO and identifies the entry point or body of code for the callback which is the thread body of code e.g. the callback made from TR to user module as illustrated by the transfer of control at from TR thread wrapper to the thread body of FOO in and

p3 is FOO context an address or otherwise identifies the thread specific context information used by the created thread FOO in the user code module

Element represents a call to CSE API thread create made from regime or layer TR to regime or layer CSE API . In this case the parameters of the call CSE API thread create may be as follows 

p1 is TR thread handle CSE API thread handle a pointer or handle to thread specific context information used by layer CSE API 

p2 is TR thread wrapper and identifies the entry point or body of code for the callback TR thread wrapper e.g. the callback made from CSE API to TR as illustrated by the transfer of control at from CSE API thread wrapper to TR thread wrapper in and

p3 is TR thread handle an address or otherwise identifies the thread specific context information described below used by layer or regime TR

The create thread API calls in the layers or regimes as denoted by and and the associated parameters of each are described above in connection with .

The data area is as described in connection with with the additional Boolean variable call CSE API regime callback as described elsewhere herein used in connection with determining which registered birth callback s if any are invoked.

Additionally as a result of invoking the registered birth callback for the TR regime whereby the invocation is done from CSE API thread wrapper as described above a data area for TR for thread FOO is also created and initialized as generally described in connection with . In more detail the thread specific context information for the TR regime may include information and fields similar to that as described above for data area . For example the TR thread specific data area may include a thread body field and a thread body context field both of which may be null in this particular case and a field CSE API thread handle with a pointer or other identifier identifying the data area .

It should be noted that each of the thread specific context information areas and at each layer or regime may also include other fields of context information that may be used specifically by that particular layer or regime as well as a code module coded for use with that particular layer or regime.

Referring to shown is an illustration of the third example in accordance with techniques herein. As mentioned above the third example described in following paragraphs is made initially with reference to the illustration of where at a first point in time only the regimes or layers CSE OSS and the native OS are loaded and thus only regime CSE OSS is registered. Code of the CSE OSS may create a thread the timer thread which may be invoked to wait an amount of time and then subsequently invoke a specified callback routine after that amount of time has elapsed. When the timer thread is created consistent with other descriptions herein such as illustrated in connection with previous examples only thread specific context information for regimes and for timer thread are created.

In this third example it should be noted that the regimes or layers CSE API TR and TR are supported but have not yet registered. Thus is an illustration of the code loaded and executing at a first point in time prior to the remaining regimes or layers CSE API TR and TR being registered.

At a second point in time subsequent to the first point in time the remaining regimes or layers CSE API TR and TR may register.

With reference now to shown is an illustration of the registered regimes or layers and executing user code module at the second point in time. The layers or regimes have a stacking order which consistent with description elsewhere herein represent the runtime stack and ordering of the different layers which are traversed with the create thread API call chain. Subsequent to the second point in time after remaining regimes and are registered and module begin execution code of user code module creates thread FOO. The user code module is coded for use with the TR API and regime for creating threads. Thus processing may be performed to create thread FOO as described in connection with the second example herein e.g. code of a first thread of module may issue a create thread API call to the TR regime or layer to result in creating a create thread API call chain resulting in creating a new native OS thread for thread FOO. The create thread call chain may return back to to continue execution of the first thread. Additionally a callback call chain included in the runtime stack for thread FOO results in execution of the body of code for thread FOO. . The user code module may also include other code such as code for a timer event callback or interrupt handler as described in more detail below.

With reference now to shown are further details regarding the third example. In the executing thread FOO may include a call to an API in the TR layer . The call may be a call to a timer routine TR timer which takes a first parameter time identifying the amount of time to wait and a second parameter tcallback indicating the routine to call or invoke once the amount of time specified by the first parameter has elapsed. As a result of call control is transferred to the body of code TR timer which may include call to the CSE API timer API of the CSE API regime . As a result of call control is transferred to the body of code for the CSE API timer which may include call to the CSE OSS timer API of the CSE OSS regime which may wake up the timer thread having the body of code which may then begin execution. Thus as a result of call control is transferred to the body of code for the thread timer previously created and as described in connection with at the first point in time when only the regime was registered .

It should be noted that waking up the timer thread as a result of executing as illustrated by causes a switch in thread execution context to the timer thread. Up to and including code executed at point execution is performed in the context of the thread FOO.

Element may represent the body of code for CSE OSS timer to which control is transferred as a result of execution of . Code for the CSE OSS timer is illustrated as including statement which waits an amount of time denoting by the first parameter time where wait in may be a call to a native OS routine. Statement results in transfer of control to the timer related callback such as provided in the second parameter tcallback established as an interrupt handler or other suitable means. Execution of results in a transfer of control to the UC cback in the other code of the user code module . The other code may include the body of code for the timer callback handler or routine UC cback. The routine UC cback may include a statement that is a call to the TR thread get errno value API of the TR regime or layer . Performing call results in a transfer of control to the code of to obtain the error number associated with the last routine or function having code executed prior to transferring control to UC cback. Thus the error number obtained specifies an error number encoding a status regarding execution of CSE OSS timer thread .

It should be noted that the call at results in a transfer of control to the routine or body of code for the UC cback whereby code of and subsequently execute in the context of the current thread which is the timer thread of the CSE OSS layer or regime . Thus processing just described subsequent to waking up the timer thread and causing execution of code is in the context of the timer thread.

It should also be noted that any one or more of the layers or regimes may include other APIs and associated functionality besides that associated with creating a thread. For example as indicated by the TR regime or layer may include a routine or function TR thread get errno value which may return a value denoting the current error condition associated with the currently executing thread FOO . Also as in connection with the third example each regime or layer may include an API for a timer which results in the runtime call chain just described.

As an alternative to specifying the second parameter tcallback in each of the invocations to and the callback routine to be called or invoked upon the amount of time denoted by the time parameter elapsing may be established or defined in other ways. For example the routine called may be an interrupt handler established as the routine to be invoked upon the occurrence of one or more events such as a timer related event that occurs due to processing performed by CSE OSS timer also referred to herein as the timer thread or the CSE OSS timer thread . In the example of the call at indicates that the parameter time is 5 e.g. 5 seconds or other time unit and that the timer callback tcallback routine is UC cback.

Referring to shown is an example illustrating the thread specific context information that may be used for the TR regime in connection with the third example in an embodiment in accordance with techniques herein. The example includes fields thread body thread body context and CSE API thread handle as described elsewhere herein such as in connection with the second example and . Additionally the thread specific context information for the TR regime may also include field errno value which may be an integer field including a value for the error number encoding a status regarding execution of the last TR function or routine executed. As known in the art errno is a well known Unix thread specific value that may be set to any one of multiple predefined error number values each denoting a different error status regarding execution of the last function or routine for an executing thread.

What will now be described are techniques that may be performed to create and initialize the thread specific context information for thread CSE OSS timer when executing the routine TR thread get errno value of the TR regime whereby TR is a regime which was not loaded and registered at the time thread CSE OSS timer was created and thus where thread specific context information for the regime TR for the thread CSE OSS timer was not created.

Referring to shown is an example of logical processing that may be performed by routines in an embodiment in accordance with techniques herein. Element provides further details regarding logical processing that may be performed by the routine TR thread get errno included in the TR regime or layer in an embodiment in accordance with techniques herein. The example includes a statement to retrieve the execution context for the currently executing thread. Execution context find may be an API of the CSE OSS layer which further invokes the get os native tls ptr API of the native OS layer. The API get os native tls ptr is described elsewhere herein. Statement may be a call to thread regime context get and init on first use which retrieves from an execution context structure provided as the first parameter execution context the pointer or handler to the thread specific context information for the regime identified by the second parameter TR REGIME ID. Statement returns the value of the particular data item errno value from the thread specific context information for the regime TR for the currently executing thread FOO. It should be noted that the processing performed by thread regime context get and init on first use referenced at line and other routines are described in more detail elsewhere herein.

In this example though there is no existing data area including the thread specific context information for layer or regime TR for thread CSE OSS timer since the layer or regime TR was not registered at the time thread CSE OSS timer was created. Thus with reference back to although there is an execution context structure for the currently executing thread CSE OSS timer the value for TR thread handle may be null or otherwise indicate that there is no thread specific context information for the TR regime for thread CSE OSS timer.

What will now be described are techniques that may be used to create and initialize the thread specific context information for the TR regime for thread CSE OSS timer . With reference to statement such processing is performed as a result of the call to thread regime context get and init on first use whereby element provides further detail regarding logical processing performed by thread regime context get and init on first use. As indicated in the routine thread regime context get and init on first use returns a pointer that is an entry of the regime context array for the specific execution context whereby the pointer identifies the data area including the thread specific context information for the desired regime TR. Additionally if the data area does not exist processing is performed to create and initialize it to include the appropriate thread specific context information.

Statement is an IF statement that determines whether the thread specific context information for the TR regime as denoted by the second parameter regime id of the specified execution context structure as denoted by the first parameter execution context has been created. The IF statement evaluates to true if such thread specific context information does not exist and results in execution of statement which performs a call to the routine thread regime birth callback issue to invoke the registered birth callback for the desired TR regime and create and initialize the thread specific context information for TR for the execution context.

Referring to shown is an example providing more detail regarding processing performed by thread regime birth callback issue in an embodiment in accordance with techniques herein. At step a determination is made by the IF statement whether there is a registered birth callback for the desired regime TR. If step evaluates to yes statement is performed to invoke the registered birth callback for the desired regime such as TR in this example. Line obtains the execution context structure for the currently executing thread CSE OSS timer . Element adds the current context to the execution context list of the global information e.g. as in . As mentioned elsewhere herein the execution context list may identify a list of execution contexts including thread specific context information for a regime where the thread specific context information is created as a result of a registered birth callback for the regime. The execution context list may be a single list of such execution contexts for thread specific information created as a result of a registered birth callback with respect to all regimes for a single process. Line results in setting the in use mask bit for the desired regime such as TR in this example to denote the thread specific context information for the TR regime has been created as a result of the registered birth callback for the TR regime. Line results in incrementing the outstanding thread count of for the regime TR to indicate that a thread CSE OSS timer has thread specific context information for regime TR that needs to be cleaned up if and when the TR regime is unloaded and unregistered. Line is executed if statement evaluates to false denoting that the birth callback for the specified regime such as TR is not registered so the context pointer is initialized to null or another predetermined value such as INITIALIZE ON FIRST USE.

Referring to shown is an example of processing that may be performed for the registered birth callback for the TR regime or layer in connection with an embodiment in accordance with techniques herein. The example includes element describing in more detail logical processing that may be performed for the birth callback of the TR regime or layer. At memory may be allocated for the pointer or identifier TR thread handle of data area including thread specific context information for the TR regime. At the data area is initialized to include the thread specific context information for the TR regime for the specific thread such as the CSE OSS timer thread. At the regime context ptr e.g. array of the regime context array is updated to identify the data area just created and initialized.

Thus as a result of calling thread regime birth callback issue with respect to the thread CSE OSS timer for the TR regime which ultimately results in invoking the birth callback for the TR regime such as described in the data area for the thread specific context information for the TR regime for the thread CSE OSS timer is created and initialized. With reference back to a data area including the information may be created and initialized for thread CSE OSS timer. In this particular example and may be initialized to null or some other suitable value.

Each regime may include code for a create thread API particular to that regime. Thread exits by returning from the thread body. It should be noted that each regime may also have other APIs for performing thread operations and use in connection with other thread based processing and the life cycle of a thread. For example although not described herein each regime may also include an exit thread API so that a thread may also terminate as a result of using the exit thread API rather than returning from the thread body as noted above.

Each regime also registers with the infrastructure using the register API thread regime callbacks register described herein in order to be used with techniques herein. Each regime may also unregister using the unregister API thread regime callbacks unregister described herein when the regime is ready to unload or no longer be used with the infrastructure performing techniques herein. Each regime may include code for the regime specific birth callback and death callback identified in the register API. Each regime may also include code for the thread wrapper or callback routine included in the callback call chain described herein The register and unregister APIs may be APIs included in infrastructure or facility code.

In connection with the unregister API thread regime callbacks unregister processing may be performed to cleanup and remove any thread specific context information data areas for the regime being unregistered. The unregister API may invoke the death callback for the regime for each such data area including thread specific information for the regime being unregistered.

Referring to shown is an example of processing that may be performed by the thread regime callbacks unregister API in an embodiment in accordance with techniques herein. At line an IF statement determines whether there are any existing data areas for threads for the particular regime regime id. In this example such a determination may be made with respect to the outstanding thread count data item for regime id. e.g. data item of thread world global info structure a described in connection with and elsewhere herein . If evaluates to true processing of the THEN portion e.g. lines may be performed. Line is a for loop which traverses the list of execution contexts for the current process. For each execution context in the list lines ensure that the entry in the in use mask of for the particular regime id is clear thereby indicating that the execution context for the regime is no longer in use. At line a determination is made as to whether all entries of the in use mask of the current execution context structure are zero. If so then the execution context may be removed from the execution context list at line . At line the death callback for the regime is called to deallocate storage and perform any other suitable cleanup processing for the thread specific context information data area of the current execution context. Steps of the for loop beginning spanning lines through e.g. including are performed with respect to each entry of the execution context list.

Once the for loop processing beginning at step has been performed with respect to each execution context in the execution context list control then proceeds to line where the entry of the birth callback array of for the particular regime regime id being unregistered is set to NULL. Similarly line sets the entry of the death callback array of for the particular regime regime id being unregistered to NULL. If the conditional IF statement at line evaluates to false processing proceeds directly to line .

In an embodiment in accordance with techniques an assumption may be that the regime CSE OSS registers prior to any other regime. As part of initialization processing performed for the CSE OSS regime such initialization processing may include registering the CSE OSS regime and also may include creating and initializing various structures described herein such as the thread world global information used in connection with techniques herein.

Referring to shown are flowcharts of processing steps that may be performed in an embodiment in accordance with techniques herein. The steps of the flowcharts and generally summarize processing described above. The processing described is performed with respect to a single process that may include a first executing thread which issues a create thread API call to create a new second thread.

At step one or more thread regimes or API layers register. Registration for each regime or layer includes specifying a birth and death callback for each of the regimes. At step a user code module executes and includes a first executing thread that issues an API call to one of the registered thread regimes to create a second new thread. At step the initial API call made by the first thread executing code of the user code module results in execution of different create thread APIs of different regimes or layers forming the create thread API call chain for creating the second new thread. At step a data area including thread specific context information for the second new thread is created and initialized for each regime or layer in the call chain of create thread APIs of the different regimes or layers included in the runtime execution stack. At step a new native OS thread e.g. for the second thread is created. The call to create the new OS native thread in may be executed in the context of the first thread and responsive to such a call results in creating the second new thread. At step execution of the first thread proceeds with returning back up the create thread API call chain of the runtime execution stack for the first thread whereby the first thread continues execution at the code following the initial API call to create the new thread e.g. continue execution of code of the first thread following invocation of create thread API in step . Additionally execution of the second newly created thread also proceeds. It should be noted that steps subsequent to are executed in the context of the newly created second thread. Processing associated with steps and may be performed by the first thread e.g. in the context of the first thread . In connection with step with the first thread returning or unwinding its execution stack with respect to the create thread API call processing for the first thread proceeds with traversal of its runtime stack to unwind through the various layers or regimes of the create thread call chain e.g. from the native OS where the native OS create thread call is made in step to return to the user code module following the point in step where the initial API call was made to create the new second thread.

At step execution of the second thread e.g. newly created in step proceeds with a sequence of callbacks included in the callback call chain of thread wrappers. A callback or thread wrapper is invoked in each layer or regime included in the create thread API call chain. The callback call chain traverses the regimes or layers of the create thread API call chain in reverse order. At step execution of the callback routines or thread wrappers of the callback call chain results in creating and initializing a data area for each registered regime or layer not included in the create thread API call chain of the runtime stack by calling the registered birth callback for each such regime or layer. At step the last callback or thread wrapper invoked in the callback call chain subsequently results in transfer of control to the body of code for the created thread which commences execution. At step one or more additional regimes or API layers may register. Registration for each regime or layer includes specifying birth and death callbacks for the particular regime. At step while the second thread e.g. created in step is executing the thread itself may perform an API call to a first regime or layer which uses at least some of the thread specific context information particular to the first regime or layer about the currently executing thread. Alternatively the thread may transfer control to another routine or more generally another body of code also executed in the context of the current second thread where the other body of code may perform the API call rather than the thread itself to the first regime or layer which uses at least some of the thread specific context information particular to the first regime or layer about the currently executing thread the second thread. At step a determination is made as to whether the data area including the thread specific context information for the first regime or layer for the currently executing thread e.g. second thread created in step exists. If step evaluates to yes control proceeds to step . At step The needed items from the thread specific context information for the first regime or layer for the currently executing thread used by the invoked API code of the first regime or layer may be obtained from the existing data area including the thread specific context information. From step control proceeds to step . If step evaluates to no control proceeds to step . If the data area does not exist in step the data area is now created on demand whereby the birth callback for the first regime or layer is invoked to create and initialize the data area with the appropriate thread specific information for the currently executing thread. Control proceeds to step . In step execution of the current second thread continues. At step the second thread completes and returns thereby causing traversal of its runtime stack to return from the user code including the second thread s body of code to the point in the native OS create thread code at which the second thread was created in step . Step processing may include unwinding the runtime execution stack of the second thread which includes the callback call chain whereby responsive to the second thread returning or exiting a death callback is invoked for each regime or layer where a prior birth callback was invoked for that same regime or layer. A death callback registered for a first regime or layer may for example perform processing to deallocate storage previously allocated for the thread specific context information in a prior birth callback registered for the first regime for the second new thread.

In following paragraphs provided are more detailed descriptions regarding the various structures and fields as well as processing performed by the various bodies of code that may be used in an embodiment in accordance with techniques herein such as in connection with the examples described above.

Following is more detail regarding the various structures that may be included in an embodiment in accordance with techniques herein. Such structures may include fields as mentioned above and also possibly other fields.

In some embodiments it should be noted that the type field of the execution context structure may identify any of a defined set of possible types such as thread DPC deferred procedure call or interrupt. In one embodiment a thread may be used as code entity to implement or simulate other code entities such as DPCs or interrupt service routine such as described for example in U.S. Pat. No. 8 387 075 issued Feb. 26 2013 MCCANN et al COMMON SCHEDULING AND SYNCHRONIZATION PRIMITIVES which is incorporated by reference herein.

Following are descriptions providing more detail regarding processing that may be performed for thread create APIs provided by the different regimes.

Following are descriptions providing more detail regarding processing that may be performed for thread wrapper APIs provided by the different regimes used for callbacks such as for example in connection with Figures 6 and 10.

Following are more detailed descriptions of initialize and deinitialization routines that may be invoked in connection with initializing and deinitializing each regime. As part of initialization of a regime the register API described herein may be invoked and as part of deinitialization the unregister API described herein may be invoked.

Following are more detailed descriptions regarding processing that may be performed for the birth and death callbacks registered for each regime.

Following are more processing details provided regarding miscellaneous routines referenced or invoked from other routines.

Following is more detail regarding processing performed by the register and unregister APIs in an embodiment in accordance with techniques herein

Although the techniques herein are illustrated in an exemplary embodiment of a data storage system the techniques herein may be used in connection with code executing on any suitable processor on any system. For example an embodiment may implement the techniques herein using code which is executed by a processor of the data storage system. As will be appreciated by those skilled in the art the code may be stored on the data storage system on any one of a computer readable medium having any one of a variety of different forms including volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Computer storage media includes but is not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM DVD or other optical storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can accessed by a data storage system processor.

While the invention has been disclosed in connection with preferred embodiments shown and described in detail their modifications and improvements thereon will become readily apparent to those skilled in the art. Accordingly the spirit and scope of the present invention should be limited only by the following claims.

