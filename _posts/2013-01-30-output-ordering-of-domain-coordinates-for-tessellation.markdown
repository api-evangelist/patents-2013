---

title: Output ordering of domain coordinates for tessellation
abstract: Systems and methods for a tessellation are described. For tessellation, a tessellation unit may divide a domain into a plurality of portions, where at least one portion is a contiguous portion. The tessellation unit may output domain coordinates of primitives along diagonal strips within the contiguous portion to increase the likelihood that patch coordinates that correspond to the domain coordinates are stored in a reuse buffer.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09123168&OS=09123168&RS=09123168
owner: QUALCOMM Incorporated
number: 09123168
owner_city: San Diego
owner_country: US
publication_date: 20130130
---
This disclosure relates to techniques for graphics processing and more specifically to tessellation in graphics processing.

A graphics processing unit GPU may implement a graphics processing pipeline that includes a tessellation stage. The tessellation stage converts a surface into a plurality of primitives on the GPU resulting in a more detailed surface. For example the GPU can receive information for a coarse surface and generate a high resolution surface rather than receiving information for the high resolution surface. Receiving information for the high resolution surface rather than the coarse surface may be bandwidth inefficient because the amount of information needed to define the high resolution surface may be much greater than the amount of information needed to define the coarse surface.

In general the techniques described in this disclosure are directed to a sequence in which a tessellation unit outputs domain coordinates of primitives generated during tessellation within a domain. For example the tessellation unit may divide a domain into a plurality of portions and at least one of the portions may be a contiguous portion. The tessellation unit may output the domain coordinates of primitives arranged in diagonal strips where the diagonal strips reside within the contiguous portion.

In one example the disclosure describes a method for tessellation. The method includes dividing with a tessellation unit a domain into a plurality of portions. In this example at least one of the portions is a contiguous portion. The method also includes outputting with the tessellation unit domain coordinates of primitives within a first diagonal strip that is within the contiguous portion and outputting with the tessellation unit domain coordinates of primitives within a second diagonal strip that is within the contiguous portion. In this example the second diagonal strip is one of parallel with the first diagonal strip or tangent with the first diagonal strip. The method also includes outputting with the tessellation unit domain coordinates of primitives within a third diagonal strip that is within the contiguous portion. In this example the third diagonal strip is parallel with at least the first diagonal strip. Also in this example a number of primitives within the third diagonal strip is different than a number of primitives within the first diagonal strip and the second diagonal strip.

In one example the disclosure describes a device that includes a graphics processing unit GPU comprising a tessellation unit. The tessellation unit is configured to divide a domain into a plurality of portions. In this example at least one of the portions is a contiguous portion. The tessellation unit is also configured to output domain coordinates of primitives within a first diagonal strip that is within the contiguous portion and output domain coordinates of primitives within a second diagonal strip that is within the contiguous portion. In this example the second diagonal strip is one of parallel with the first diagonal strip or tangent with the first diagonal strip. The tessellation unit is also configured to output domain coordinates of primitives within a third diagonal strip that is within the contiguous portion. In this example the third diagonal strip is parallel with at least the first diagonal strip. Also in this example a number of primitives within the third diagonal strip is different than a number of primitives within the first diagonal strip and the second diagonal strip. The device also includes a reuse buffer configured to store patch coordinates that correspond to one or more of the outputted domain coordinates of primitives within the first second and third diagonal strips.

In one example the disclosure describes a device comprising a graphics processing unit GPU . The GPU includes means for dividing a domain into a plurality of portions. In this example at least one of the portions is a contiguous portion. The GPU also includes means for outputting domain coordinates of primitives within a first diagonal strip that is within the contiguous portion and means for outputting domain coordinates of primitives within a second diagonal strip that is within the contiguous portion. In this example the second diagonal strip is one of parallel with the first diagonal strip or tangent with the first diagonal strip. The GPU also includes means for outputting domain coordinates of primitives within a third diagonal strip that is within the contiguous portion. In this example the third diagonal strip is parallel with at least the first diagonal strip. Also in this example a number of primitives within the third diagonal strip is different than a number of primitives within the first diagonal strip and the second diagonal strip.

In one example the disclosure describes a computer readable storage medium comprising instruction stored thereon that when executed cause one or more processors to divide a domain into a plurality of portions. In this example at least one of the portions is a contiguous portion. The instructions also cause the one or more processors to output domain coordinates of primitives within a first diagonal strip that is within the contiguous portion and output domain coordinates of primitives within a second diagonal strip that is within the contiguous portion. In this example the second diagonal strip is one of parallel with the first diagonal strip or tangent with the first diagonal strip. The instructions also cause the one or more processors to output domain coordinates of primitives within a third diagonal strip that is within the contiguous portion. In this example the third diagonal strip is parallel with at least the first diagonal strip. Also in this example a number of primitives within the third diagonal strip is different than a number of primitives within the first diagonal strip and the second diagonal strip.

The details of one or more examples are set forth in the accompanying drawings and the description below. Other features objects and advantages will be apparent from the description and drawings and from the claims.

Modern mobile devices such as laptop computer tablet computers smartphones and digital media players include a CPU Central Processing Unit a graphics processing unit GPU and system memory. When rendering graphics as part of executing an application the CPU transmits instructions and graphics data to the GPU. In some examples the graphics data may be in the form of vertices which may comprise one or more data structures that describes a point in 2D or 3D space.

The application executing on the CPU may communicate with the GPU in accordance with an application programming interface API . For instance the application may communicate with the GPU in accordance with the DirectX API developed by Microsoft or the OpenGL API developed by the Khronos Group as two examples. For purposes of illustration and understanding the techniques described in this disclosure are generally described in the context of the DirectX and OpenGL APIs. However aspects of this disclosure should not be considered limited to the DirectX and OpenGL APIs and the techniques described in this disclosure may be extended to other APIs as well.

DirectX and OpenGL each define graphics processing pipelines that are to be implemented by a GPU. These graphics processing pipelines may include a combination of programmable stages as well as fixed function stages. Some recent versions of the APIs such as the Direct3D 11 API and the OpenGL 4.x API include a tessellation process that is to be performed by the GPU.

The tessellation process refers to dividing a portion referred to as patch of a surface of an object into a plurality of smaller portions and interconnecting the smaller portions together. This results in a more highly detailed surface as compared to the surface prior to tessellation. Tessellation allows the application executing on the CPU to define the surface with low resolution which may require few points and allows the GPU to generate a higher resolution surface.

To implement tessellation the GPU may include a tessellation unit which may be a fixed function unit although aspects of this disclosure do not require the tessellation unit to be a fixed function unit. Examples of the tessellation unit include the tessellation stage in the DirectX pipeline and the primitive generator in the OpenGL 4.x pipeline . The tessellation unit may be configured to construct primitives within a domain. This domain should not be confused with the patch. The patch is a portion of the surface of an object that is to be rendered. The domain may be considered as a template within which the tessellation unit constructs primitives and is separate from the patch. The tessellation unit may define the vertices of the primitives in domain coordinates. Domain coordinates are based on a coordinate system that is local to the tessellation unit and used by the tessellation unit to define points within the domain.

A domain shader in the DirectX pipeline or a tessellation evaluation shader in the OpenGL 4.x pipeline may receive the domain coordinates from the tessellation unit and transforms the domain coordinates to patch coordinates. Patch coordinates are based on a coordinate system used by the GPU for defining points within the patch. The domain shader or tessellation evaluation shader may be considered as mapping the domain coordinates of vertices of the primitives within the domain to points within the patch e.g. vertices of primitives within the patch and interconnecting these mapped points within the patch to add resolution to the patch e.g. add primitives within the patch to add resolution to the patch .

In some examples the tessellation unit may output the domain coordinates for each vertex of a primitive to a reuse buffer sometimes referred to as a post transformation vertex cache PTVC . A controller may determine whether the reuse buffer stores patch coordinates for the domain coordinates outputted by the tessellation unit. If the controller determines that the reuse buffer does not store the patch coordinates for the domain coordinates outputted by the tessellation unit then the controller may cause an instance of the domain shader or tessellation evaluation shader to execute to transform the domain coordinates of the vertex of the primitive within the domain into the patch coordinates for a vertex of a primitive that is to be added into the patch. The controller may then store the patch coordinates in the reuse buffer. If however the controller determines that the reuse buffer already stores the patch coordinates for the domain coordinates outputted by the tessellation unit the controller may not cause an instance of the domain shader or tessellation evaluation shader to execute.

In general execution of the domain shader or tessellation evaluation shader may require substantial processing time which may slow the tessellation process. The techniques described in this disclosure relate to a sequence in which the tessellation unit may output the vertices of the primitives within the domain to increase the likelihood that the reuse buffer already stores the patch coordinates for the domain coordinates of the vertices of the primitives outputted by the tessellation unit. This may potentially result in fewer instances of the execution of the domain shader or the tessellation evaluation shader which in turn may result in a faster completion of the tessellation process as compared to other techniques.

In the techniques described in this disclosure the tessellation unit may output the vertices of the primitives in the domain in a particular sequence. As described in more detail the tessellation unit may output the vertices of primitives within a portion of the domain. For example the tessellation unit may divide the domain into a plurality of portions. At least one of the portions may encompass a contiguous area within the domain and may be referred to as a contiguous portion. As described in more detail a contiguous portion of the domain may mean that there is no gap within the portion that excludes primitives within the domain.

As described in more detail the tessellation unit may output vertices of primitives where the primitives are arranged in one or more diagonal strips within the contiguous portion. For instance the tessellation unit may output vertices of primitives that reside within a first diagonal strip where the first diagonal strip resides within the contiguous portion.

After outputting the vertices of primitives that reside within the first diagonal strip the tessellation unit may output the vertices of primitives that reside within a second diagonal strip where the second diagonal strip resides within the contiguous portion. In some examples the second diagonal strip may be parallel with the first diagonal strip. In other examples the second diagonal strip may be tangent with the first diagonal strip.

After outputting vertices of primitives that reside within the second diagonal strip the tessellation unit may then output vertices of primitives that reside within a third diagonal strip and so forth. The third diagonal strip may be parallel with the first diagonal strip. The tessellation unit may output primitives within the diagonal strips until the tessellation unit completes outputting the primitives within one of the portions of the domain. The tessellation unit may output primitives within another portion in the domain in a substantially similar manner.

CPU may execute various types of applications. Examples of the applications include web browsers e mail applications spreadsheets video games or other applications that generate viewable objects for display. Instructions for execution of the one or more applications may be stored within system memory . CPU may transmit graphics data of the generated viewable objects to GPU for further processing.

For example GPU may be specialized hardware that allows for massively parallel processing which functions well for processing graphics data. In this way CPU offloads graphics processing that is better handled by GPU . CPU may communicate with GPU in accordance with a particular application processing interface API . Examples of such APIs include the DirectX API by Microsoft and the OpenGL by the Khronos group however aspects of this disclosure are not limited to the DirectX and the OpenGL APIs and may be extended to other types of APIs that have been developed are currently being developed or are to be developed in the future.

In addition to defining the manner in which GPU is to receive graphics data from CPU the APIs may define a particular graphics processing pipeline that GPU is to implement. GPU in illustrates the graphics processing pipeline defined by the DirectX 11.x API such as the Direct3D 11 API. As described in more detail illustrates the graphics processing pipeline of the OpenGL 4.x API.

Examples of CPU and GPU include but are not limited to a digital signal processor DSP general purpose microprocessor application specific integrated circuit ASIC field programmable logic array FPGA or other equivalent integrated or discrete logic circuitry. In some examples GPU may be specialized hardware that includes integrated and or discrete logic circuitry that provides GPU with massive parallel processing capabilities suitable for graphics processing. In some instances GPU may also include general purpose processing and may be referred to as a general purpose GPU GPGPU . The techniques described in this disclosure may also be applicable to examples where GPU is a GPGPU.

System memory may comprise one or more computer readable storage media. Examples of system memory include but are not limited to a random access memory RAM a read only memory ROM an electrically erasable programmable read only memory EEPROM flash memory or any other medium that can be used to carry or store desired program code in the form of instructions and or data structures and that can be accessed by a computer or a processor.

In some aspects system memory may include instructions that cause CPU and or GPU to perform the functions ascribed to CPU and GPU in this disclosure. Accordingly system memory may be a computer readable storage medium having instructions stored thereon that when executed cause one or more processors e.g. CPU and GPU to perform various functions.

System memory may in some examples be considered as a non transitory storage medium. The term non transitory may indicate that the storage medium is not embodied in a carrier wave or a propagated signal. However the term non transitory should not be interpreted to mean that system memory is non movable or necessarily static in its content. As one example system memory may be removed from device and moved to another device. As another example a system memory substantially similar to system memory may be inserted into device . In certain examples a non transitory storage medium may store data that can over time change e.g. in RAM .

The execution of the applications on CPU causes CPU to generate a plurality of primitives that connect together to form the viewable content. Examples of the primitives include points lines triangles squares or any other type of polygon. CPU may define these primitives by their respective vertices. For example CPU may define coordinates and color values for the vertices. The coordinate values may be three dimensional 3D coordinates or 2D coordinates.

In some cases CPU may also generate a special type of primitive referred to as a patch. Similar to the other primitive types a patch may be defined by a plurality of vertices referred to as control points of a patch. Unlike other primitive types the patch may not be any particular shape. For example CPU may interconnect the control points of the patch in any manner so that the interconnected control points form any desired shape. For other primitive types such as triangles CPU may define the specific manner in which the vertices are interconnected e.g. such that interconnection of the vertices results in a triangle .

Also unlike other primitive types the number of control points in a patch may be variable. For example the application executing on CPU may define a maximum number of control points that are allowed for a patch or the maximum number of control points may be user defined. In some examples the number of control points in a patch may be one to thirty two control points however the techniques described in this disclosure are not so limited.

CPU may utilize the control patch for purposes of tessellation. As described above a tessellation process refers to CPU defining a portion of a surface of a viewable object in low resolution and tessellating the portion to generate a higher resolution version of the surface. For example CPU may define control points of the patch such that when the control points are interconnected the patch forms a portion of a surface of a viewable object. If a surface were to be formed only from the control points of the patch the surface may not appear with high resolution and may appear jagged. With tessellation additional primitives are added to the patch such that when the primitives are interconnected the interconnection of these primitives adds detail to the patch which increases the resolution of the patch and results in higher quality viewable content.

GPU may be configured to implement tessellation. In this way CPU may not need to define the vertices for all the additional primitives needed to generate the higher resolution patch which saves on computations performed by CPU . Also CPU may need to transmit fewer vertices e.g. the vertices of the control points and not the vertices of the primitives to be added and GPU may correspondingly need to receive fewer vertices which promotes bandwidth efficiency due to fewer accesses to system memory .

To perform graphics operations GPU may implement a graphics processing pipeline. The graphics processing pipeline includes performing functions as defined by software or firmware executing on GPU and performing functions by fixed function units that are hardwired to perform specific functions. The software or firmware executing on the GPU may be referred to as shaders and the shaders may execute on one or more shader cores of GPU . Shaders provide users with functional flexibility because a user can design the shaders to perform desired tasks in any conceivable manner. The fixed function units however are hardwired for the manner in which the fixed function units perform tasks. Accordingly the fixed function units may not provide much functional flexibility such as programmable functional flexibility provided by software or firmware.

As indicated above the graphics processing pipeline illustrated in is a graphic processing pipeline substantially as defined by Direct3D 11. In this example GPU may include one or more of input assembler stage vertex shader stage hull shader stage tessellation stage domain shader stage geometry shader stage rasterizer stage pixel shader stage and output merge stage . GPU may include more stages than those illustrated and in some examples GPU may not necessarily include all of the illustrated stages. Also the specific ordering of the stages is provided for purposes of illustration and should not be considered limiting.

In techniques described in this disclosure CPU may output the control points of a patch to system memory . GPU may then retrieve the control points from system memory . In this manner CPU may transmit the control points to GPU . As used in this disclosure CPU transmitting to GPU or GPU receiving from CPU may generally include CPU writing to system memory from which GPU reads. Alternatively it may be possible for CPU to directly transmit to GPU and for GPU to directly receive from CPU .

Input assembler stage may read the control points from system memory as defined by CPU and assemble the control points to form the patch. For instance input assembler stage may read the coordinates color values and other such information of the control points. The coordinates color values and other such information may be commonly referred to as attributes of the control points. Based on the attributes of the control points input assembler stage may determine the general layout of the patch. In this manner input assembler stage may assemble the control points to form the patch. Input assembler stage may be a fixed function logic unit or a programmable unit.

Vertex shader stage may process the vertices e.g. the control points of the patch from input assembler stage . For example vertex shader stage may perform per vertex operations such as transformations skinning morphing and per vertex lighting. Vertex shader stage may be a shader.

Hull shader stage receives the control points of the patch as processed by vertex shader stage process the control points and outputs control points for a processed patch. In other words hull shader stage receives an input patch as processed by vertex shader stage processes the input patch and outputs an output patch. Hull shader stage may perform various functions for processing the input patch. For example hull shader stage may modify the coordinates of the control points to change the locations of the control points or may even add or delete control points.

In addition hull shader stage may determine values that indicate how many primitives are to be added to the patch generated by hull shader stage i.e. the output patch . Hull shader stage may utilize various criteria to determine how many primitives are to be added to the patch. Described below are two example criteria that hull shader stage may utilize to determine how many primitives are to be added to the patch. However aspects of this disclosure are not so limited and hull shader stage may utilize any criteria to determine how many primitives should be added to the patch.

As one example hull shader stage may utilize information indicative of the depth of the patch to determine how many primitives should be added. For instance a patch that is further away from the perspective of the viewer may not need high resolution because objects further in distance appear blurry in real life. However a patch that is closer from the perspective of the viewer may need higher resolution because objects closer in distance appear sharper in real life. In this example hull shader stage may determine that fewer primitives should be added to the patch that is further away and more primitives should be added to the patch that is closer relative to one another.

As another example hull shader stage may determine how many primitives should be added based on the size of the patch. For a smaller sized patch hull shader stage may determine that fewer primitives should be added because the patch encompasses a smaller area. For a larger sized patch hull shader stage may determine that more primitives should be added because the patch encompasses a larger area.

Based on a determination of how many primitives should be added hull shader stage may output a domain type and values that indicate how many primitives are to be added to the patch to tessellation stage . The values that indicate how many primitives are to be added to the patch in the Direct3D 11 API are referred to as tessfactors.

The domain may be a considered as a template shape that tessellation stage uses for tessellation purposes. Examples of the domain type include a line a triangle a quad e.g. a four sided polygon or any other type of polygon. The domain may be a two dimensional 2D shape even if the patches define a three dimensional 3D surface or a 2D surface. When the domain is a line the domain may be a one dimensional 1D shape i.e. a line even if the patches define a 3D surface a 2D surface or a 1D surface. For purposes of illustration the techniques described in this disclosure are described with respect to the domain being a 2D surface. For instance the techniques are described with domain shapes that are the triangle or quad.

In some examples hull shader stage may not explicitly indicate the domain type. Rather tessellation stage may determine the domain type based on the number of transmitted tessfactors. For example the presence of four tessfactors may indicate that the domain type is a triangle domain type and the presence of six tessfactors may indicate that the domain type is a quad domain type.

In some examples a quad domain may be defined by two dimensional 2D Cartesian coordinates u v . In some examples a triangle domain may be defined by Barycentric coordinates. Barycentric coordinates utilize three coordinates to identify any point within the triangle. For example the vertices of the triangle domain may be defined as u v w as described below in more detail. The location of any point within the triangle is defined by vertex weighting that indicates its proximity to a vertex. For instance the closer a point is to a vertex the higher its vertex weighting and the further away the point is from the vertex the lower its vertex weighting.

As an example assume the vertices of the triangle are defined with Barycentric coordinates u v w as follows 1 0 0 0 1 0 and 0 0 1 . In this example the center point is located at 1 3 1 3 1 3 because the center point is equally distant from each of the vertices. Also with the given definition of the vertex coordinates in this example the sum of the u v and w coordinates for any point within the triangle domain should equal one.

The Cartesian and Barycentric coordinates are described for purposes of illustration only and should not be considered limiting. In other examples it may be possible to define the quad domain with Barycentric coordinates or Cartesian coordinates and the triangle domain with Cartesian coordinates or Barycentric coordinates. In general a domain of any type may be defined using any coordinate system.

Tessellation stage may tessellate the domain into a plurality of primitives e.g. construct a plurality of primitives within the domain . It should be understood that in this example tessellation stage is not tessellating the patch outputted by hull shader stage into primitives but rather tessellating the domain into the primitives. In some examples tessellation stage may not even have access to the patch outputted by hull shader stage . Tessellation stage may be a fixed function unit although aspects of this disclosure need not be so limited.

Tessellation stage may utilize the tessfactors outputted by hull shader stage to tessellate the domain into a plurality of primitives. For example in addition to defining the domain type e.g. triangle or quad the tessfactors may define how many rings are to be included within the domain.

A ring may be a series of concentric shapes within the domain where the concentric shapes are the same shape as the domain shape. For example if the domain shape is a quad the perimeter of the quad may be considered as the outer ring. Hull shader stage may define the number of inner rings which may be series of smaller sized quads that reside within the quad domain. Similarly if the domain shape is a triangle the perimeter of the triangle may be considered as the outer ring and the inner rings may be series of smaller sized triangles that reside within the triangle domain.

In addition to defining the number of rings within a domain the tessfactors define the points that reside along the rings. The points that reside along the rings should not be confused with control points. The control points define the patch. The points that reside along the rings are points generated by tessellation stage based on the tessfactors. These points are generated within the domain and not within the patch.

Also it is these points that tessellation stage connects together to construct the plurality of primitives within the domain. For example assume that the primitives that tessellation stage will construct are triangles. In this example tessellation stage may connect one point that resides along the outer ring with two points that reside along the inner ring to form a triangle primitive. Alternatively tessellation stage may connect two points that reside along the outer ring with one point that resides along the inner ring to form a triangle primitive. In this way by defining the domain type the number of rings within the domain and the number of points along the outer and inner rings hull shader stage may define the number of primitives that tessellation stage should construct within the domain.

In some examples the number of points that can reside along an edge of ring may be one point to sixty five points. For example if the domain type is a triangle than there may be up to 65 points per edge of the triangle domain. Similarly if the domain type is a quad than there may be up to 65 points per edge of the quad. However the techniques described in this disclosure are not limited to an edge having a maximum of sixty five points.

Furthermore the number of points that reside along a ring may be different for outer and inner rings. For example the number of points that reside along an edge of the outer ring may be more than or less than the number points that reside along an edge of the inner ring. It may also be possible that number of points that reside along the edge of the outer ring and the inner ring are the same number of points.

Moreover the number points along an edge of the same ring may be different. For example for a triangle domain the number of points that reside along one of the edges may be different than the number of points that reside along one other edge or both edges. Similarly for a quad domain the number of points that reside along one of the edges may be different than the number of points that reside along one two or all three other remaining edges. It may also be possible for each of the edges of the rings to have the same number of points.

As described above in some examples tessellation stage may not divide the patch into a plurality of primitives. Accordingly in some examples tessellation stage may not receive any information such as the number of control points the locations of the control points or the size of the patch. Without any information as to the size of the patch and the locations of the control points tessellation stage may not be able to define the size of the domain that is used or the specific coordinates for the vertices of the domain.

To address this tessellation stage may rely upon a normalized coordinate system for defining the vertices of the domain as well as for determining the locations of the interconnected points within the domain. As one example of the normalized coordinates tessellation stage may define the vertices of a quad domain in u v coordinates as 0 0 1 0 0 1 and 1 1 which is a unit square. Tessellation stage may define the vertices of a triangle domain in u v w coordinates as 0 0 1 0 1 0 and 1 0 0 which is an equilateral triangle. Tessellation stage may determine the coordinates for the interconnected vertices of the plurality of primitives in this normalized coordinate system. In other words tessellation stage may define the coordinates of the vertices of the primitives within the domain using a local normalized coordinate system. In this disclosure the coordinates of the vertices as defined by tessellation stage may be referred to as domain coordinates because these coordinate are with respect to a normalized coordinate system for the domain.

In the illustrated graphics pipeline domain shader may receive the domain coordinates for the vertices of the plurality of primitives in the normalized coordinate system e.g. the u v coordinates or the u v w coordinates as applicable . The function of domain shader stage may be to map the domain coordinates of the vertices as received from tessellation stage on to the patch. For example while tessellation stage may not receive information of the patch as defined by hull shader stage domain shader stage may receive such information from hull shader stage .

Domain shader stage may transform the domain coordinates for a vertex of a primitive into patch coordinates of a vertex of a primitive that is to be added to the patch. The patch coordinates may be coordinates that are defined relative to the coordinate system used by GPU and define points in the patch. For example the domain coordinates of the vertex of a primitive in the domain may be based on a normalized coordinate system used to define points in a 2D domain. However the patch may be defined in three dimensions and domain shader stage may transform the domain coordinates of the vertex to identify a point on the patch.

For example domain shader stage may receive the coordinates of the control points of the patch from hull shader . With the coordinates of the control points of the patch from hull shader stage domain shader stage may determine the location of the vertex as outputted by tessellation stage on the patch. This identified point on the patch may be a vertex for a primitive that is added to the patch.

Tessellation stage may output the domain coordinates for a vertex to a reuse buffer not shown in and shown in greater detail in . The reuse buffer may be referred to as a post transformation vertex cache PTVC . A controller not shown in and shown in greater detail in may determine whether the reuse buffer stores patch coordinates that correspond to the domain coordinates of the vertex outputted by tessellation unit . As used in this disclosure patch coordinates that correspond to the domain coordinates of the vertex outputted by tessellation unit refer to patch coordinates that are generated by transforming the domain coordinates.

If the controller determines that the reuse buffer does not store the patch coordinates that correspond to the domain coordinates the controller may execute an instantiation of domain shader stage . Domain shader stage may receive the domain coordinates of the vertex outputted by tessellation stage transform the domain coordinates to patch coordinates and store the patch coordinates in the reuse buffer. If the controller determines that the reuse buffer stores the patch coordinates that correspond to the domain coordinates the controller may not execute an instantiation of domain shader stage . In either case the controller may then output the patch coordinates further along the graphics pipeline.

Because tessellation stage outputs vertices of the plurality of primitives generated by tessellation stage and domain shader stage adds these primitives to the patch the combination of hull shader stage tessellation stage and domain shader stage together add additional primitives to the patch. This results in a mesh of primitives that are added to the patch creating a higher resolution more detailed patch as compared to the patch defined by CPU . In this manner hull shader stage tessellation stage and domain shader stage implement a tessellation process.

Geometry shader stage receives the vertices of the primitives added to the patch by domain shader stage and may further generate additional vertices for the primitives to add even more resolution. Rasterizer stage receives the primitives from geometry shader stage and converts the primitives into pixels for the display. For example the primitives may be defined as vectors that indicate the interconnection of the primitives and may be defined in a coordinate space that is independent of the display on which the image is to be displayed. Rasterizer stage converts these vectors into the display coordinates and performs any additional functions such as removing points within primitives that are occluded.

Pixel shader stage receives the pixels as outputted by rasterizer stage and performs post processing to assign color values to each of the pixels that are to be displayed. For example pixel shader stage may receive constant values stored in system memory texture data stored in system memory and any other data to generate per pixel outputs such as color values. Pixel shader stage may also output opacity values that indicate the opaqueness of the pixels.

Output merge stage may perform any final pixel processing. For example output merge stage may utilize depth information to further determine whether any of the pixels should be removed from being displayed. Output merge stage may also perform blending operations to generate final pixel values which may include luma and chroma values or red green blue RGB values.

Output merge stage may output the final pixel values to a frame buffer generally located within system memory but which may be located within GPU . A display processor not shown may retrieve the pixel values from the frame buffer and cause pixels of a display not shown of device e.g. via red green and blue pixel components to illuminate at specified intensity levels according to the pixel values to cause the display to display the image.

As described above the controller may execute an instantiation of domain shader stage whenever the reuse buffer does not store the patch coordinates for the corresponding domain coordinates of a vertex of a primitive within the domain. In general execution of domain shader stage may be processing intensive and time consuming and it may be desirable to limit the number of times domain shader stage needs to execute. For example a first primitive and a second primitive in the domain may share two vertices. In this example after tessellation stage outputs the domain coordinates of the vertices of the first primitive the controller may execute three instantiations of domain shader stage i.e. one per vertex and store the resulting patch coordinates in the reuse buffer. Then after tessellation stage outputs the domain coordinates for the vertices of the second primitive the controller may execute one instantiation of domain shader stage . In this case the reuse buffer may already store the patch coordinates for the two vertices that are shared between the first and second primitive. Accordingly the controller may need to execute only one instantiation of domain shader stage for the unshared vertex of the second primitive.

However due to the limited storage capabilities of the reuse buffer it may be possible that the patch coordinates for a vertex that is shared between two primitives is no longer stored in the reuse buffer when tessellation stage outputs the domain coordinates for the shared vertex for the second time. For instance in the previous example due to the limited storage capabilities of the reuse buffer it may be possible that the patch coordinates that correspond to the domain coordinates of one or both of the vertices that are shared between the first and second primitive are no longer stored in the reuse buffer when tessellation unit outputs the domain coordinates of the vertices of the second primitive.

This may result in execution of instantiations of domain shader stage for transforming domain coordinates that were previously transformed to patch coordinates. For instance in the above example where the patch coordinates that correspond to the domain coordinates of the shared vertices are stored in the reuse buffer the controller may execute only one instantiation of domain shader stage to transform the domain coordinates of the unshared vertex of the second primitive to patch coordinates. However in the above example where the patch coordinates that correspond to the domain coordinates of the shared vertices are not stored in the reuse buffer the controller may execute three instantiation of domain shader stage to transform the domain coordinates of the three vertices of the second primitive to patch coordinates.

Previously stored patch coordinates may not be available in the reuse buffer because the reuse buffer may implement a first in first out replacement scheme. For example when the reuse buffer is full e.g. each slot within the reuse buffer stores a patch coordinate the reuse buffer may remove i.e. wash out the earliest stored patch coordinates to free up storage space for the next patch coordinates that are to be stored. If the removed patch coordinates correspond to domain coordinates for a vertex of a primitive that is shared with another primitive then the controller may cause the execution of another instantiation of the domain shader stage to retransform the domain coordinates of the vertex into the patch coordinates when tessellation stage outputs the vertices of the other primitive.

The techniques described in this disclosure are directed to the sequence in which tessellation stage outputs vertices of the primitives. In some examples tessellation stage may output the vertices of primitives in such a sequence to increase the likelihood that shared vertices remain stored in the reuse buffer. For example after outputting vertices of a first primitive tessellation stage may output vertices in such a sequence that vertices of the first primitive that are shared with subsequent primitives are within the reuse buffer when tessellation stage outputs the vertices of these subsequent primitives.

Furthermore the output sequence of the primitives may be such that when the reuse buffer is full there are not many remaining primitives with a vertex whose domain coordinates correspond to the earliest stored patch coordinates. For instance in the first in first out replacement scheme when the reuse buffer is full the reuse buffer may remove the earliest stored patch coordinates. These patch coordinates may correspond to domain coordinates of a vertex within the primitive where the vertex is not shared with many other primitives. In this way even if the reuse buffer removes these patch coordinates there may be limited impact on the number of instantiations of domain shader stage as described below in more detail.

As described above hull shader stage may define the number of rings within the domain and the number of points that reside along each edge of the rings. Tessellation stage in turn may place points along the rings in the manner defined by hull shader stage . These points form the vertices of the primitives created by tessellation stage in the domain. Tessellation stage may interconnect these vertices together to form the primitives and output the domain coordinates for the vertices of these primitives.

In accordance with the techniques described in this disclosure prior to outputting the domain coordinates for the vertices of the primitives tessellation stage may divide the domain into a plurality of portions. At least one of the portions may encompass a contiguous area within the domain and may be referred to as a contiguous portion. In general it may be possible for each of the portions to be contiguous portions however aspects of this disclosure are not so limited.

The contiguous portion may be defined by a plurality of edges. The plurality of edges forms a perimeter within the domain that tessellation stage tessellates and the portion may be the contiguous area of the domain within the perimeter. In the techniques described in this disclosure the contiguous portion may include any primitive within the domain that falls within the perimeter of the contiguous portion.

For instance the term contiguous means that there is no gap within the portion that excludes primitives within the domain. For example if a primitive within the domain is within the perimeter of the portion then that primitive is part of the portion. To further assist with understanding the concept of a contiguous portion the contiguous portions should not be confused with the rings used to construct the primitives within the domain.

Some other techniques output the primitives within each of the rings used to construct the primitives. In these examples a tessellation stage other than tessellation stage first outputs primitives along an outer ring. This outer ring forms a gap in the domain. For example the center point within the domain falls within the area of the domain encompassed by the ring but the tessellation stage of these other techniques excludes the center point when outputting the domain coordinates of vertices within the ring. In other words these rings should not be considered as contiguous portions because the area within a ring is excluded from being part of the ring.

In accordance with the techniques described in this disclosure tessellation stage may output vertices of primitives where the primitives are arranged in one or more diagonal strips within the contiguous portion. A diagonal strip of primitives includes four sides where two of the four sides are parallel. The two parallel sides may each include at least one vertex of each of the primitives within the diagonal strip. Also the number of vertices on each of the two parallel sides may be different.

For example assume that a diagonal strip includes three primitives. In this example a first side of the parallel sides of the diagonal strip may include three points and a second side of the parallel sides of the diagonal strip may include two points. By interconnecting the three points on the first side with the two points on the second side the tessellation unit may construct the three primitives within the diagonal strip. In this example the three points on the first side may form three vertices and the two points on the second side may form two vertices. Because the primitives within the diagonal strip share vertices tessellation stage may construct the three primitives using only the three vertices that reside along the first side of the parallel sides of the diagonal strip and the two vertices that reside along the second side of the parallel sides of the diagonal strip.

In some examples tessellation stage may output vertices of primitives that reside within a first diagonal strip where the first diagonal strip resides within the contiguous portion. After outputting the vertices of primitives that reside within the first diagonal strip tessellation stage may output the vertices of primitives that reside within a second diagonal strip where the second diagonal strip resides within the contiguous portion.

In some examples the second diagonal strip may be parallel with the first diagonal strip. In these examples the number of primitives within the second diagonal strip may be different than the number of primitives within the first diagonal strip. In other examples the second diagonal strip may be tangent with the first diagonal strip. In these examples the number of primitives within the second diagonal strip may be the same as the number of primitives within the first diagonal strip.

After outputting vertices of primitives that reside within the second diagonal strip tessellation stage may then output vertices of primitives that reside within a third diagonal strip. The third diagonal strip may be parallel with the first diagonal strip. Also the number of primitives that reside within the third diagonal strip may be different than the number of primitives that reside within the first and second diagonal strips.

Tessellation stage may output primitives within the diagonal strips until tessellation stage completes outputting the primitives within one of the portions of the domain. Tessellation stage may output primitives within another portion in the domain in a substantially similar manner.

By outputting vertices in the manner described above GPU may execute fewer instantiations of domain shader stage . For example due to the limited size of the reuse buffer the reuse buffer may not be able to store all of the vertices outputted by tessellation stage . For instance as described above the reuse buffer may implement a first in first out replacement scheme when the reuse buffer is full and domain shader stage is attempting to store newly transformed patch coordinates. The techniques described in this disclosure may increase the likelihood that after domain shader stage transforms vertices of a first primitive from domain coordinates to patch coordinates the patch coordinates for vertices that are shared with a second primitive are not washed out of the reuse buffer before tessellation stage outputs the domain coordinates of vertices of the primitives within the second diagonal strip and similarly for the third diagonal strip.

As described above tessellation stage may divide the domain into a plurality of portions. The manner in which tessellation stage divides the domain into the plurality of portions may be based on the tessfactors outputted by hull shader stage and the number of storage slots in the reuse buffer i.e. the storage capability of the reuse buffer . For example for a quad domain hull shader stage may output the number of segments into which each side of the ring is to be divided. The number of segments along each side of the ring is one example of the tessfactor outputted by hull shader stage .

The number of segments into which each side of the quad domain is to be divided may indicate the number of points on each side of the quad domain. For instance if one side is to be divided into five segments then tessellation stage may determine that there are six points on the side one point on each end of the side and four points in the middle to divide the side into five segments .

For the quad domain hull shader stage may output a tessfactor for the vertical sides that define the number of segments into which the vertical sides are to be divided. This tessfactor may be referred to as f. Hull shader stage may also output a tessfactor for the horizontal sides that define the number of segments into which the horizontal sides are to be divided. This tessfactor may be referred to as f.

Tessellation stage may determine which one of these two tessfactors is smaller or possibly equal in value e.g. whether f f or whether f f . Assume that the smaller of two is referred to as f. Also assume that the number of storage slots in the reuse buffer is C. In this example tessellation stage may determine whether f 1 is less than or equal to C 2. If f 1 is less than or equal to C 2 then tessellation stage may divide the quad domain into two portions e.g. divide the quad domain into duplets where one or both of the two portions are contiguous portions.

In this example tessellation stage may output domain coordinates of vertices of the primitives within a first diagonal strip within a first contiguous portion of the two portions followed by a second diagonal strip within the first contiguous portion. In this example the second diagonal strip may be tangent with the first diagonal strip and the number of primitives in the first diagonal strip and the second diagonal strip may be the same. Then tessellation stage may output domain coordinates of vertices of primitives within a third diagonal strip of the first contiguous portion. The third diagonal strip may be parallel with the first diagonal strip and the number of primitives within the third diagonal strip may be different than the number of primitives within the first and second diagonal strips.

Tessellation stage may repeat outputting domain coordinates of primitives in a similar manner until tessellation stage finishes outputting primitives within the first contiguous portion. Tessellation stage may then proceed with the second contiguous portion and output domain coordinates of vertices within the second contiguous portion in a substantially similar fashion. Outputting domain coordinates of the primitives in the example where f 1 is less than or equal to C 2 may be referred to as a first mode of operation of tessellation stage .

If tessellation stage determines that f 1 is not less than or equal to C 2 tessellation stage may determine whether f 2 1 is less than or equal to C 1. If f 2 1 is less than or equal to C 1 tessellation stage may divide the quad domain into four portions e.g. quadruplets where one or more of the four portions are contiguous portions.

In this example tessellation stage may output domain coordinates of vertices of the primitives within a first diagonal strip within a first contiguous portion of the four portions followed by a second diagonal strip within the first contiguous portion. In this example the second diagonal strip may be parallel with the first diagonal strip and the number of primitives in the first diagonal strip and the second diagonal strip may be different. Then tessellation stage may output domain coordinates of vertices of primitives within a third diagonal strip of the first contiguous portion. The third diagonal strip may be parallel with the first and second diagonal strips and the number of primitives within the third diagonal strip may be different than the number of primitives within the first and second diagonal strips.

Tessellation stage may repeat outputting domain coordinates of primitives in a similar manner until tessellation stage finishes outputting primitives within the first contiguous portion. Tessellation stage may then proceed with the second contiguous portion and output domain coordinates of vertices within the second contiguous portion in a substantially similar fashion followed by the third and fourth portions. Outputting domain coordinates of the primitives in the example where f 2 1 is less than or equal to C 1 may be referred to as a second mode of operation of tessellation stage .

If tessellation stage determines that f 2 1 is not less than or equal to C 1 tessellation stage may divide the quad domain into more than four portions. In this example tessellation stage may operate in a third mode of operation. For instance tessellation stage may divide the quad domain into five portions. On four of the five portions tessellation stage may implement the first mode of operation. On the fifth portion tessellation stage may implement the second mode of operation.

It should be understood that although the previous examples described tessellation stage as determining whether f 1 is less than or equal to C 2 or whether f 2 1 is less than or equal to C 1 aspects of this disclosure are not so limited. In general any component may determine whether f 1 is less than or equal to C 2 or whether f 2 1 is less than or equal to C 1.

For example GPU may load hull shader stage with the number of slots in the reuse buffer i.e. the value of C and hull shader stage may perform the above determinations and indicate to tessellation stage the manner in which the domain is to be divided. As another example a controller of GPU may perform the above determinations and indicate to tessellation stage the manner in which the domain is to be divided.

The above examples described the first second or third modes of operation for a quad domain. Tessellation stage may also implement the first second or third modes of operation for instances when the domain is a triangular domain. For a triangle domain rather than defining a fand ftessfactor hull shader stage may define one tessfactor referred to as f.

In this example if f 1 is less than or equal to C 2 then tessellation stage may implement the first mode of operation by dividing the triangle domain into two portions. In this example one of the two portions may be sized differently than the other portion. Tessellation stage may then output the domain coordinates of the primitives in the first second and third triangles as described above for the largest sized domain. For the smaller sized domain tessellation stage may implement the second mode of operation.

In this example for the triangle domain if f 1 is not less than or equal to C 2 and f 2 1 is less than or equal to C 1 tessellation stage implements the second mode of operation. For instance tessellation stage may divide the triangle domain into three portions e.g. triplets and implement the second mode of operation on each of the three portions. In this example if f 2 1 is not less than or equal to C 1 tessellation stage implements the third mode of operation. For example tessellation stage may divide the triangle domain into more than three portions. Tessellation stage may implement the second mode of operation on some of the portions and implement the third mode of operation on some of the other portions.

In the example where the domain is a triangle domain tessellation stage may determine whether f 1 is less than or equal to C 2 or whether f 2 1 is less than or equal to C 1. However as above the techniques described in this disclosure are not so limited. In general any other component may perform these determinations and indicate to tessellation stage the manner in which the triangle domain is to be divided.

The above example techniques may be applicable to the entirety of the domain when there is uniform tessellation. In uniform tessellation the tessfactors for the outer rings are the same as the tessfactors for the inner rings. However in other examples hull shader stage may define different numbers of tessfactors for the outer most ring and the inner rings. For example the outer most ring may be equivalent to the perimeter of the domain and hull shader stage may define a different number of segments on the outer most ring as compared to the number of segments in the inner rings.

In this example tessellation stage may implement the first second or third mode of operation on the domain encompassed by the inner rings. For example the first inner ring e.g. ring after the outer most ring may be considered as a subset domain and tessellation stage may implement the first second or third mode of operation on the subset domain. For the primitives in the outer most ring i.e. part of the domain that is not part of the subset domain tessellation stage may output those primitives in any order.

The OpenGL 4.x graphics processing pipeline may function in a substantially similar fashion as the Direct3D 11 graphics processing pipeline. Accordingly for purposes of brevity reference is made to to describe components that are similar to both the Direct3D 11 graphics processing pipeline and the OpenGL 4.x graphics processing pipeline.

As illustrated in the example of GPU includes input assembler vertex shader tessellation control shader primitive generator tessellation evaluation shader geometry shader clipping unit rasterizer fragment shader and post processor . Similar to in the example illustrated in GPU may include more or fewer components than those illustrated in . Also the specific ordering of the unit is provided for purposes of illustration and should not be considered limiting.

In some ways the tessellation process with the OpenGL 4.x graphics processing pipeline may be substantially similar to the tessellation process with the Direct3D 11 graphics processing pipeline. For example OpenGL 4.x tessellation process may rely upon patches and control points in the manner similar to that described above with respect to . For instance input assembler and vertex shader of may function substantially similar as input assembler stage and vertex shader stage of respectively.

As more examples for tessellation tessellation control shader of may function substantially similarly to hull shader stage of . However tessellation control shader outputs tessellation levels which may be analogous to the tessfactors of Direct3D 11. For example the tessellation levels of OpenGL 4.x may define the domain type the number of rings within the domain and the number of points per ring edge.

Primitive generator may function in a substantially similar manner as tessellation stage . For example primitive generator may utilize the tessellation levels and the domain type to divide the domain into a plurality of primitives. Also in accordance with techniques described in this disclosure primitive generator may output the domain coordinates of the primitives in the manner described above. For example primitive generator may output the domain coordinates of the vertices of primitives where the primitives reside in diagonal strips.

Similar to tessellation stage of primitive generator may divide the domain into a plurality of portions where at least one portion is a contiguous portion. Primitive generator may then output the domain coordinates of the vertices primitives within the contiguous portion. For example primitive generator may output domain coordinates of vertices of primitives that reside within a first diagonal strip followed by a second diagonal strip and a third diagonal strip. Furthermore primitive generator may implement the different example modes of operation described above with respect to tessellation stage .

Tessellation evaluation shader of may function substantially similarly to domain shader stage of . For example tessellation evaluation shader may receive the vertices of the generated primitives from primitive generator and add the primitive to the patch outputted by tessellation control shader . In this manner the graphics processing pipeline of the OpenGL 4.x API may perform tessellation on a patch to increase the resolution of the patch.

Geometry shader may function substantially similarly to geometry shader stage . The combination of clipping unit and rasterizer in may function substantially similarly to rasterizer stage in . Fragment shader and post processor in may function substantially similarly to pixel shader stage and output merge stage in respectively. Post processor may output the final pixel values to a frame buffer and the display processor may retrieve the pixel values from the frame buffer and cause a display to illuminate according to the pixel values to display the image.

As described above tessellation control shader primitive generator and tessellation evaluation shader of function substantially similarly to hull shader stage tessellation stage and domain shader stage of respectively for implementing the tessellation process. Accordingly both the Direct3D 11 and the OpenGL 4.x APIs rely upon two programmable shader units and one fixed function unit to implement the tessellation process.

For purposes of generality the techniques described in this disclosure may be described with a first tessellation shader unit a tessellation unit and a second tessellation shader unit. Examples of the first tessellation shader unit include hull shader stage and tessellation control shader . Examples of the tessellation unit include tessellation stage and primitive generator . Examples of the second tessellation shader unit include domain shader stage and tessellation evaluation shader .

Also Direct3D 11 uses the term tessfactors and OpenGL 4.x uses the term tessellation levels which may be considered analogous terms. For purposes of generality this disclosure uses the term tessellation factor examples of which include tessfactors and tessellation levels. In this way the first shader unit may be considered as outputting tessellation factors to the tessellation unit and the tessellation unit may output vertices to the second shader unit in response to the tessellation factors.

It should be noted that while the Direct3D 11 and OpenGL 4.x utilize two shader units and one fixed function unit the techniques described in this disclosure are not so limited. For example it may be possible in other systems for the first and second shader units to be fixed function units and the tessellation unit to be a shader unit. As another example all may be fixed function units or all may be shader units or any combination thereof.

Therefore in some examples it may be considered that a first unit performs functions similar to the first shader unit but may be a shader unit or a fixed function unit a second unit performs functions similar to the tessellation unit but may be a shader unit or a fixed function unit and a third unit performs functions similar to the second shader unit but may be a shader unit or a fixed function unit. Moreover although the first shader unit the tessellation unit and the second shader unit are illustrated as separate units in aspects of this disclosure are not so limited. These units and possibly any unit of the graphics processing pipelines illustrated in may be combined together into a common unit. Accordingly while the functionality of these units is described separately for ease of description these units may be implemented in shared hardware or as distinct components.

As illustrated domain is tessellated into a plurality of primitives e.g. triangles . In some other examples a tessellation unit not like the tessellation unit of this disclosure outputs domain coordinates of the vertices of the primitives in a ring by ring fashion where the ring in this example is a triangle. For instance illustrates ring and ring . Ring is the outer most ring and includes primitives that border the boundary of domain . Ring is the first inner ring because no primitive in ring resides on the boundary of domain .

In some other techniques the tessellation unit of these other techniques outputs the domain coordinates of all of the primitives that reside within ring . Then the tessellation unit of these other techniques outputs the domain coordinates of all the primitives that reside within ring . As shown in some of the primitives are numbered to assist with understanding. For example the tessellation unit of these other techniques outputs the domain coordinates of primitive followed by primitive primitive and so forth until primitive because these primitives all reside within ring . Then the tessellation unit of these other techniques outputs the domain coordinates of primitives in ring starting from primitive .

In the example illustrated in because primitive is the first primitive of domain after the tessellation unit of these other techniques outputs the domain coordinates of primitive a domain shader executes three times to transform each of the three domain coordinates of primitive into patch coordinates and stores the corresponding patch coordinates in the reuse buffer. Then after the tessellation unit of these other techniques outputs the domain coordinates of primitive the domain shader may execute only one time because primitive shares two vertices with primitive and the patch coordinates for these two vertices may be stored in the reuse buffer. The domain shader may transform the unshared vertex of primitive to transform the domain coordinates of the unshared vertex of primitive into patch coordinates and stored the corresponding patch coordinates in the reuse buffer.

The tessellation unit of these other techniques may output the domain coordinates of the primitives along ring until the tessellation unit of these other techniques outputs the domain coordinates of primitive . As illustrated in primitive shares two vertices with primitive . However due to the limited size of the reuse buffer the reuse buffer may have removed the patch coordinates that correspond to the domain coordinates of primitive . In this case the domain shader may execute three times and re transform the domain coordinates into patch coordinates of the vertices shared by primitive and primitive . In other words although the domain shader had already transformed domain coordinates of primitive into patch coordinates in these other techniques the domain shader may have to once again transform domain coordinates of primitive i.e. the ones shared with primitive into patch coordinates.

The tessellation unit in these other techniques may then output the domain coordinates of the vertices of primitive in ring . As illustrated primitive shares two vertices with primitive and primitive shares one vertex with primitive . In this the domain shader may execute twice. For instance because primitive shares one vertex with primitive the patch coordinates for that vertex may be stored in the reuse buffer. However for the vertex of primitive that is shared with primitive and not shared with primitive due to the limited size of the reuse buffer the reuse buffer may remove the patch coordinates that correspond to the domain coordinates of this vertex. In this case the domain shader may need to execute to transform the domain coordinates of this vertex into patch coordinates even though the domain shader had previously transformed the domain coordinates of this vertex into patch coordinates.

As illustrated domain is tessellated into a plurality of primitives e.g. triangles . In some other examples a tessellation unit not like the tessellation unit of this disclosure outputs domain coordinates of the vertices of the primitives in domain in a ring by ring fashion where the ring in this example is a rectangle.

For ease of description only some of the primitives that reside in the outer ring of domain are illustrated. For example the outer ring of domain includes primitive to primitive . In this example the tessellation unit of these other techniques outputs the domain coordinates for the vertices of primitive followed by primitive and so forth until primitive .

However in these other techniques by the time the tessellation unit of these other techniques outputs the domain coordinates of primitive 216 the reuse buffer may have removed the patch coordinates that correspond to the domain coordinates of primitive . Accordingly even though primitive shares two vertices with primitive the domain shader may need to execute three times to transform the domain coordinates of primitive into corresponding patch coordinates.

The example illustrated in is one example manner in which some other techniques attempted to reduce the number of executions of the domain shader. For example in the tessellation unit of these other techniques outputs primitives from one ring. In the tessellation unit of these other techniques outputs domain coordinates of primitives in two rings simultaneously.

Such an output scheme may reduce the number of times the domain shader needs to execute. For example when the tessellation unit of these other techniques outputs the domain coordinates of primitive the patch coordinates for the domain coordinates that primitive shares with primitives and may still be available in the reuse buffer. However even the scheme illustrated in may execute more instances of the domain shader than desirable. For example when the tessellation unit of these other techniques outputs the domain coordinates of primitive the patch coordinates for the domain coordinates of the vertices of primitive that are shared with primitive may no longer be stored in the reuse buffer.

In this way in the examples illustrated in the tessellation unit of these other techniques generates one strip of primitives for each ring and it may be possible for units further in the graphics pipeline e.g. after the domain shader to reuse the vertices in the reuse buffer between primitives in the same ring. However it may not be possible for the units further in the graphics pipeline to reuse vertices for primitives across the rings due to the limited size of the reuse buffer. This results in extra executions of the domain shader.

For example assume that the reuse buffer includes thirty two cache slots. In the examples illustrated in there may be two cache misses for the same vertex. A cache miss may refer to an instance where the corresponding patch coordinates for a domain coordinate are not stored in the reuse buffer. For example in the examples illustrated in after the domain shader transforms the domain coordinates into patch coordinates for a vertex it may be possible that the domain shader will need to execute at least once more to transform the domain coordinates of this same vertex into patch coordinates due to the limited size of the reuse buffer.

The example illustrated in may reduce the number of executions of the domain shader relative to the techniques illustrated in . However in some examples there may be up to sixty four vertices along an edge of a ring. In this case even the example illustrated in may result in multiple executions of the domain shader to transform the domain coordinates of the same vertex into patch coordinates.

Accordingly the techniques illustrated with may place limitations on the efficiency of the reuse buffer. For example the patch coordinates that correspond to the domain coordinates for vertices in one ring are lost when outputting domain coordinates for the second ring. Also as can been seen in the vertices of primitives to that reside along the outer boundary of domain are not shared with any of the primitives in ring e.g. primitive onwards in ring . Accordingly there may be very little to no negative impact on the efficiency of the reuse buffer if patch coordinates that correspond to the domain coordinates of the vertices that reside along the outer boundary of domain are lost. For example there may be little to no negative impact on the efficiency of reuse buffer if vertices along one side of the ring are lost if the vertices along the other side of the ring are preserved in the reuse buffer.

However in the examples of such preservation of vertices along one side of the ring may not occur. For example the order in which the domain coordinates of vertices are output in examples of may be considered as axis aligned. After the tessellation unit of these other techniques output the domain coordinates of primitives to most of the primitives to do not share any vertices with primitives to with primitive and being the exception . However the primitives onwards in ring share vertices with the primitives to which are lost in the reuse buffer due to the limited size. Accordingly it may be more desirable to ensure that the patch coordinates for primitives to are available when outputting the primitives and onward than the patch coordinates for primitives to .

As described above the techniques described in this disclosure provide for an output scheme of the domain coordinates to maximize the efficiency of the reuse buffer. For example as described above the tessellation unit in accordance with the techniques described in this disclosure e.g. tessellation stage and primitive generator may divide the domain into a plurality of portions where at least one of the portions is a contiguous portion. The rings illustrated in should not be considered as contiguous portions.

For example as used in this disclosure a contiguous portion includes any primitive that falls within the area of the contiguous portion e.g. within the ends of the edges of the contiguous portion such that there is no gap in the domain. The rings illustrated in exclude primitives that fall within the area encompassed by the rings such that there is a gap in the domain. For example in although ring encompasses all of domain ring excludes primitives that fall within ring . In this way ring hollows out domain creating a gap in domain . Such similar exclusion of primitives can also be seen in .

The tessellation unit e.g. tessellation stage or primitive generator may output domain coordinates along diagonal strips within the contiguous portion. In other words the tessellation unit outputs domain coordinates in a diagonal walking direction. Walking as used in this disclosure refers to the steps in which the tessellation unit outputs the domain coordinates of the primitives. One potential advantage of outputting in the diagonal walking direction is that the diagonal strip length grows gradually starting from a strip length of one primitive. This may result in vertices being added from the outer side of the diagonal strip while the reuse buffer replaces vertices from the inner side of the diagonal strip in a first in first out scheme.

Domain shader is illustrated in dashed lines to indicate that domain shader executes on GPU such as on one or more shader cores of GPU where a shader core is a dedicated hardware of GPU for the execution of shaders such as domain shader . In other words in this example domain shader is not a hardware block but rather a software unit executing on a hardware block. One example of domain shader is domain shader stage . Another example of domain shader is tessellation evaluation shader .

Controller may be a control unit of GPU that controls the overall functionality of GPU . For example controller may determine whether and when to execute shader programs. Controller may also determine the mode of operation of tessellation unit . Alternatively tessellation unit may determine the mode of operation. Controller may be hardware software executing on hardware or firmware executing on hardware. Furthermore in some examples instead of or in addition to controller determining when to execute domain shader reuse buffer may include a cache controller that is configured to determine when to execute domain shader . However for purposes of illustration the techniques are described in context of controller determining the mode of operation and determining when domain shader is to be executed.

Because either controller or tessellation unit may determine the mode of operation of tessellation unit the techniques described in this disclosure may be considered as a processing unit being configured to determine the mode of operation of tessellation unit . In some examples the processing unit may be controller . In some examples the processing unit may be tessellation unit . In some examples the processing unit may be the combination of controller and tessellation unit . For ease of illustration as described above the techniques for determining the mode of operation are described with examples where the processing unit is controller . However the processing unit may alternatively or in conjunction with controller be tessellation unit .

As illustrated tessellation unit includes setup unit point generators and connectivity generator . Setup unit point generators and connectivity generator may be fixed function hardware units of tessellation unit . Setup unit point generators and connectivity generator are illustrated as separate components for ease of description. Setup unit point generators and connectivity generator may be formed as a single unit as separate units or a combination thereof.

Setup unit may receive the tessellation factors as input from a first shader unit such as hull shader stage of or tessellation control shader of and may determine the domain type from the tessellation factors. For example if there are four tessellation factors setup unit may determine that the domain type is a triangle and if there are six tessellation factors setup unit may determine that the domain type is a quad. Setup unit may perform other setup functions such as correcting rounding problems ceiling and floor functions determining half tessellation factors and reducing and combining tessellation factors. In general setup unit may process the tessellation factors to ensure that the other components of tessellation unit can perform respective functions.

Point generators may determine how many points reside along each edge of each ring of the domain from the tessellation factors and the locations of the points e.g. the u v coordinates or the u v w coordinates of the points . Connectivity generator may connect i.e. stitch the points to form a plurality of primitives in the domain.

In some examples connectivity generator may be configured to implement the techniques described in this disclosure. For example rather than outputting domain coordinates of primitives as illustrated in connectivity generator may be configured to divide the domain into a plurality of portions and output domain coordinates of primitives in diagonal strips within the portions. In some examples point generators and connectivity generator may function together for outputting the domain coordinates.

For example point generators may determine the coordinates of the vertices of primitives that reside within a first diagonal strip where the first diagonal strip resides within the contiguous portion. Point generator may then output the determined coordinates to connective generator e.g. via a shallow buffer separate from reuse buffer and not illustrated in . Connectivity generator may assemble the primitives and output domain coordinates of vertices of the primitives that reside within a first diagonal strip where the first diagonal strip resides within the contiguous portion. Point generators may also determine the coordinates of vertices of primitives that reside within a second diagonal strip where the second diagonal strip resides within the contiguous portion and output the determined coordinates to connectivity generator e.g. via the shallow buffer . After outputting the domain coordinates of vertices that reside within the first diagonal strip connectivity generator may output domain coordinates of vertices that reside within a second diagonal strip where the second diagonal strip resides within the contiguous portion.

In one mode of operation the second diagonal strip may be parallel with the first diagonal strip and connectivity generator may output domain coordinates of vertices that reside within the second parallel diagonal strip. In this example the second parallel diagonal strip may include a different number of primitives than the first diagonal strip.

In another mode of operation the second diagonal strip may be tangent with the first diagonal strip. Tangent as used in this disclosure means that only one primitive in the second diagonal strip shares two vertices with only one primitive in the first diagonal strip. In this way the second diagonal strip may be considered as being connected to the first diagonal strip at only one primitive and hence tangent with the first diagonal strip. In this example the second tangent diagonal strip may include a same number of primitives as the first diagonal strip.

Also point generators may determine the coordinates of the vertices of primitives that reside within a third diagonal strip and output the determined coordinates to connectivity generator e.g. via the shallow buffer . After outputting vertices of primitives that reside within the second diagonal strip connectivity generator may then output vertices of primitives that reside within the third diagonal strip that is within the contiguous portion. In either mode of operation the third diagonal strip may be parallel with the first diagonal strip. For instance in the mode of operation where the first and second diagonal strips are parallel with one another the third diagonal strip may be parallel with both the first and second diagonal strip. In the mode of operation where the second diagonal strip is tangent with the first diagonal strip the third diagonal strip may be parallel with the first diagonal strip but may not be parallel with the second diagonal strip.

Point generators may determine coordinates of primitives and connectivity generator may output primitives within the diagonal strips until connectivity generator completes outputting the primitives within one of the contiguous portions of the domain. Point generators may determine coordinates of primitives and connectivity generator may then output primitives within another contiguous portion in the domain in a substantially similar manner.

Connectivity generator may output the domain coordinates of one primitive to controller . Controller may then determine whether reuse buffer stores patch coordinates that correspond to the outputted domain coordinates. For instance the domain coordinates may be indices into reuse buffer . As described above the domain coordinates may be Cartesian coordinates e.g. u v coordinates or Barycentric coordinates e.g. u v w coordinates . The u coordinate the v coordinate and the w coordinate may each be 17 bits. Accordingly the u v coordinates may include thirty four bits while the u v w coordinates may include fifty one bits.

Controller may output these thirty four or fifty one bits to an XOR gate within reuse buffer . The XOR gate may compare the received bits with bits indicative of the indices of reuse buffer . If the output of the XOR gate indicates that the received bits match an index in reuse buffer reuse buffer may output a cache hit to controller . A cache hit means that reuse buffer stores patch coordinates for the domain coordinates that formed the thirty four or fifty one bits. If the output of the XOR gate indicates that the received bits do not match an index in reuse buffer reuse buffer may output a cache miss to controller . A cache miss means that reuse buffer does not store patch coordinates for the domain coordinates that formed the thirty four or fifty one bits.

If a cache hit occurs controller may not cause an instantiation of domain shader to execute because reuse buffer already stores the patch coordinates for the domain coordinates that formed the thirty four or fifty one bits. In this case controller may cause subsequent units of the graphics pipeline to read the patch coordinates that correspond to the outputted domain coordinates for further processing. For example controller may cause geometry shader stage or geometry shader to read the patch coordinates that correspond to the outputted domain coordinates from reuse buffer for further processing.

If a cache miss occurs controller may cause an instantiation of domain shader to execute because reuse buffer does not store the patch coordinates for the domain coordinates that formed the thirty four or fifty one bits. In this case controller may provide the domain coordinates to domain shader and domain shader may transform the domain coordinates into corresponding patch coordinates. Domain shader may output the patch coordinates to reuse buffer . Reuse buffer in turn may store the patch coordinates at indices equal to the thirty four or fifty one bits that formed the domain coordinates. After reuse buffer stores the patch coordinates controller may cause subsequent units of the graphics pipeline to read the patch coordinates from reuse buffer for further processing.

Controller may repeat these steps for each of the domain coordinates outputted by connectivity generator . For example for every cache miss controller may cause an instantiation of domain shader to execute and for every cache miss controller may not cause an instantiation of domain shader to execute.

As described above the techniques described in this disclosure may minimize the number of instantiations of domain shader . To this end the techniques described in this disclosure may minimize the number of cache misses that occur. For example outputting domain coordinates of primitives in diagonal strips within contiguous portions increase the likelihood that patch coordinates that correspond to the domain coordinates of shared vertices remain in reuse buffer and that reuse buffer removes e.g. washes out patch coordinates that correspond to the domain coordinates of unshared vertices.

In the techniques described in this disclosure each of the diagonal strips may include a first side e.g. an inner side and a second side e.g. an outer side . In the example mode of operation in which the first second and third diagonal strips are all parallel with one another the outer side of the first diagonal strip may be the same as the inner side of the second diagonal strip and the outer side of the second diagonal strip may be same as the inner side of the third diagonal strip. In this example the number of primitives in each of the diagonal strips may be different.

As one example the number of primitives in the second diagonal strip may be greater than the number of primitives in the first diagonal strip and the number of primitives in the third diagonal strip may be greater than the number of primitives in the first and second diagonal strip. This results in the number of vertices on the outer side of the first diagonal strip being greater than the number of vertices on the inner side of the first diagonal strip and the number of vertices on the outer side of the second diagonal strip being greater than the number of vertices on the inner side of the second diagonal strip where the inner side of the second diagonal strip is the same as the outer side of the first diagonal strip.

By ensuring that the patch coordinates that correspond to the domain coordinates of the vertices on the outer side of the diagonal strips remain within reuse buffer the techniques described in this disclosure may progressively grow the number of patch coordinates that are stored in reuse buffer . Then when reuse buffer becomes full reuse buffer may remove patch coordinates that correspond to domain coordinates of vertices that reside along the inner side of the diagonal strips. As there are fewer primitives in the inner side of the diagonal strip these primitives may not share as many vertices if any with other primitives in the domain. Accordingly if the patch coordinates that correspond to the domain coordinates of these inner side vertices are removed from reuse buffer the impact on the number of times domain shader needs to execute may be minor. In this way this mode of operation allows for a reduction in the number of times domain shader needs to execute as compared to the examples described above with respect to .

The example mode of operation where the second diagonal strip is tangent with the first diagonal strip may also minimize the execution of domain shader by increasing the likelihood that patch coordinates that correspond to domain coordinates of shared vertices remain in reuse buffer . For example if the storage capabilities of reuse buffer e.g. the number of slots in reuse buffer is sufficiently large and or the number of vertices in the domain is sufficiently small after connectivity generator outputs the domain coordinates for the primitives in the second diagonal strip reuse buffer may still store the patch coordinates that correspond to the domain coordinates of primitives in the first diagonal strip.

Then when connectivity generator outputs the domain coordinates of primitives in the third diagonal strip controller may determine that domain shader does not need to execute for many of the domain coordinates. For example in this mode of operation the inner side of the third diagonal strip may be the same as the outer side of the first diagonal strip. The patch coordinates that correspond to the domain coordinates for the vertices that reside along the outer side of the diagonal strip may still be stored in reuse buffer and controller may determine that domain shader does not need to execute for at least these vertices.

In this way even in the mode of operation where the second diagonal strip is tangent with the first diagonal strip the techniques described in this disclosure may progressively grow the patch coordinates that are stored in reuse buffer such that patch coordinates that correspond to domain coordinates that reside on the outer side of the diagonal strips remain in reuse buffer and patch coordinates that correspond to domain coordinates that reside on the inner side of the diagonal strips are removed from reuse buffer . For instance in the mode of operation where the second diagonal strip is tangent with the first diagonal strip the number of primitives in the third diagonal strip may be greater than the number of primitives in the first diagonal strip.

Accordingly the number of vertices that resides on the inner side of the first diagonal strip are less than the number of vertices that reside on the outer side of the first diagonal strip. In this manner even if reuse buffer removes the patch coordinates that correspond to the domain coordinates of vertices that reside along the inner side of the first diagonal strip there may be minor if any negative impact on the number of times domain shader needs to execute. In this way this mode of operation also allows for a reduction in the number of times domain shader needs to execute as compared to the examples described above with respect to .

As described above point generators and connectivity generator together may divide the domain into a plurality of portions where at least one of the portions is a contiguous portion. Point generators and connectivity generator together may divide the domain into the plurality of portions based on the tessellation factors and the storage capability of reuse buffer . Point generators and connectivity generator may then implement one of the example modes of operations described above based on the manner in which point generators and connectivity generator divides the domain.

For a quad domain tessellation unit may receive an ftessellation factor and an ftessellation factor. The ftessellation factor may indicate the number of vertices that reside on a ring in the x direction and the ftessellation factor may indicate the number of vertices that reside on a ring in the y direction. For example point generators of tessellation unit may utilize the ftessellation factor and the ftessellation factor to determine the number of points that reside on each of the rings. It should be noted that although rings are needed to determine the location of the points e.g. the vertices connectivity generator outputs primitives in diagonal strips and not based on the rings. In other words once point generators utilize the rings to determine the location of the vertices connectivity generator outputs domain coordinates of the vertices of the primitives in the diagonal strips and not in the ring by ring fashion described above with respect to .

In some examples setup unit may preprocess the fand ftessellation factors. For example setup unit may round fand fto integer values if tessellation unit is to apply integer partitioning. Setup unit may round fand fto an odd integer if tessellation unit is to apply odd fractional partitioning. Setup unit may round fand fto an even integer if tessellation unit is to apply even fractional partitioning. Setup unit may round fand fto 2 i.e. a dyadic integer if tessellation unit is to apply power of 2 pow partitioning. In any event this disclosure refers to the fand ftessellation factors as being factors subsequent to the preprocessing by setup unit .

Connectivity generator may divide the quad domain based on the lesser of fand f. For example a processing unit e.g. controller and or tessellation unit may determine the lesser of fand f. For instance let fequal the lesser of fand f where fequals the greater of fand f. If fis equal to f then let fequal either for f. In other words fis less than or equal to f i.e. f f .

The above example assumed the domain to be a quad domain. For a triangle domain tessellation unit may not receive an fand an ftessellation factor. Rather tessellation unit may receive one tessellation factor which this disclosure refers to as ffor simplicity.

As described in more detail the value of tessellation factor fmay determine the manner in which point generators and connectivity generator divide the domain. Also the number of slots in reuse buffer may determine the manner in which point generators and connectivity generator divide the domain. Let C equal the number of slots in reuse buffer i.e. the storage capabilities of reuse buffer .

In some examples controller may determine whether f 1 is less than or equal to C 2. It should be understood that it may be possible for tessellation unit to determine whether f 1 is less than or equal to C 2. For example tessellation unit may be preloaded with the value of C. In other words the processing unit e.g. controller and or tessellation unit may determine whether f 1 is less than or equal to C 2. However for ease of description controller is described as determining whether f 1 is less than or equal to C 2.

If controller determines that f 1 is less than or equal to C 2 then controller may instruct connectivity generator to operate in a first mode of operation. This first mode of operation may be referred to as a joint diagonal walk. In the first mode of operation point generators and connectivity generator may divide the domain into two portions where one or more both portions are contiguous portions. For example point generators and connectivity generator may divide the quad domain into two halves and may implement the first mode of operation on each of the two halves. As another example point generators and connectivity generator may divide the triangle domain into a one third portion and a two thirds portion. In this example point generators and connectivity generator may implement a first mode of operation on the two thirds portion and may implement a second mode of operation described in more detail below on the one third portion.

For purposes of illustration illustrates the manner in which connectivity generator may output domain coordinates for primitives within portion B. It should be understood that connectivity generator outputs the domain coordinates based on the determined domain coordinates by point generators . Portion B is a contiguous portion because all primitives of domain that fall within portion B are included as part of portion B. For instance portion B does not create a gap in domain .

In the example illustrated in connectivity generator may start outputting domain coordinates of primitives that are located at the center of portion B along the x axis boundary of domain and extend outwards. This is further illustrated with respect to first diagonal strip second diagonal strip and third diagonal strip . For instance first diagonal strip includes primitives A to N second diagonal strip includes primitives A to N and third diagonal strip includes primitives A to M.

In the first mode of operation e.g. where f 1 is less than or equal to C 2 second diagonal strip may include a same number of primitives as first diagonal strip . For example in first diagonal strip includes N number of primitives and second diagonal strip also includes N number of primitives. In the first mode operation third diagonal strip includes a different number of primitives than first diagonal strip and second diagonal strip . For instance third diagonal strip includes M number of primitives.

Also in the first mode of operation second diagonal strip is tangent with first diagonal strip . For example second diagonal strip includes only one primitive that shares two vertices with only one primitive of first diagonal strip . As illustrated in primitive A of second diagonal strip shares two vertices with primitive N of first diagonal strip and none of the remaining primitives of second diagonal strip shares two vertices with any remaining primitives of first diagonal strip .

Furthermore in the first mode of operation third diagonal strip is parallel with first diagonal strip but not parallel with second diagonal strip . Each of first diagonal strip second diagonal strip and third diagonal strip may include an inner side and an outer side. The inner side refers to the side of first diagonal strip second diagonal strip and third diagonal strip that is closer to the center of portion B and the outer side refers to the side of first diagonal strip second diagonal strip and third diagonal strip that is away from the center of portion B.

Two diagonal strips being parallel with one another means that the two diagonal strips start from the same axis and extend outwards in the same direction. For example first diagonal strip and third diagonal strip both start along the x axis of domain and extend outwards in the same direction. Second diagonal strip starts along the x axis of domain but does not extend outwards in the same direction as first diagonal strip and third diagonal strip .

In some examples two diagonal strips being parallel with one another means that an outer side of one of the two diagonal strips is the same as an inner side of the other of the two diagonal strips. For example the outer side of first diagonal strip is the same as the inner side of third diagonal strip . Accordingly third diagonal strip is parallel with first diagonal strip . However neither of the inner side nor the outer side of second diagonal strip is the same as the inner side or outer side of first diagonal strip and third diagonal strip . Accordingly third diagonal strip is not parallel with second diagonal strip .

Furthermore even if two diagonal strips do not share an inner side and outer side it may be possible for the two diagonal strips to be considered parallel with one another. For instance as described above if two diagonal strips start from a same axis of the domain and extend outwards in the same direction the two diagonal strips may be considered as being parallel with one another.

In connectivity generator may output the domain coordinates for primitives A to N i.e. domain coordinates for primitives in first diagonal strip . For any of these domain coordinates of primitives A to N for which reuse buffer does not store corresponding patch coordinates controller may cause an instantiation of domain shader to execute and domain shader may store the transformed coordinates i.e. the patch coordinates that correspond to the domain coordinates in reuse buffer . Connectivity generator may then output domain coordinates for primitives A to N i.e. domain coordinates for primitives in second diagonal strip . Again for any of these domain coordinates of primitives A to N for which reuse buffer does not store corresponding patch coordinates controller may cause an instantiation of domain shader to execute and domain shader may store the transformed coordinates in reuse buffer . Next connectivity generator may output domain coordinates for primitives A to M i.e. domain coordinates for primitives in third diagonal strip . As above for any of these domain coordinates of primitives A to M for which reuse buffer does not store corresponding patch coordinates controller may cause an instantiation of domain shader to execute and domain shader may store the transformed coordinates in reuse buffer .

Connectivity generator may keep outputting domain coordinates in this manner until connectivity generator completes outputting domain coordinates of all of the primitives in portion B. Connectivity generator may then repeat these steps with respect to portion A. As illustrated in portion B and portion A share many vertices. In some cases it may be possible that the patch coordinates that correspond to the domain coordinates for some of these vertices that shared by portion A and portion B are no longer available in reuse buffer . For some of vertices controller may cause domain shader to execute. However although domain shader may need execute for retransforming the domain coordinates of these shared vertices to patch coordinates the techniques described in this disclosure may still reduce the overall number of times domain shader needs to execute as compared to the examples illustrated in .

In some instances as illustrated in after outputting primitives of a diagonal strip there may be no diagonal strip that is congruent i.e. tangent to that diagonal strip. In this case connectivity generator may output primitives of the diagonal strip that is the mirror opposite. For example after connectivity generator outputs the domain coordinates of primitives within diagonal strip there may be no tangent diagonal strip to diagonal strip . In this case connectivity generator may output the domain coordinates of primitives in diagonal strip which is the mirror opposite of diagonal strip .

Diagonal strips that are mirror opposites of one another refer to diagonal strips that would intersect a line of symmetry within the domain at the same point if extended. For instance in the line of symmetry may be considered as a vertical line that extends upwards from a center bottom end of domain or downwards from a center top end of domain . In this example if diagonal strip and diagonal strip extended further diagonal strip and diagonal strip would intersect along the line of symmetry of domain .

In this manner as illustrated in connectivity generator starts from the center of the bottom end of portion B and outputs domain coordinates of primitives extending in the outwards direction towards both the right end and left end of portion B and towards the top end of portion B. Alternatively connectivity generator may start from the center of top end of portion B outwards towards both the right end and left end of portion B and towards the bottom end of portion B. In this case the likelihood that patch coordinates that correspond to the domain coordinates of vertices that are shared by portion B and A will be removed from reuse buffer . Accordingly it may be more advantageous for connectivity generator to start from the center of bottom end of portion B rather than the top end of portion B. In either situation e.g. starting from top end or bottom end of portion the output scheme may be referred to as a joint walk in the x direction because first diagonal strip starts from the x axis and second diagonal strip ends at the x axis.

However the techniques described in this disclosure are not so limited. In some other examples point generators and connectivity generator may divide domain into two vertical portions rather than the horizontal portions illustrated in . In this case connectivity generator may start from a center of the left end or a center of the right end and output domain coordinates of primitives extending in the outwards direction towards both the top end and the bottom end of a vertical portion of the two vertical portions. Such an output scheme may be referred to as a joint walk in the y direction because the first diagonal strip in this example may start from the y axis of the domain and the second diagonal strip in this example may end at the y axis of the domain. For instance the joint walk in the y direction may be considered as the same as the joint walk in the x direction if domain were rotated 90 degrees.

When the processing unit e.g. controller or tessellation unit determines that connectivity generator is to implement the first mode of operation controller may further determine whether connectivity generator is to implement the joint walk in the x direction or the joint walk in the y direction. For example controller may determine whether connectivity generator is to implement the joint walk in the x direction or the joint walk in the y direction based on the tessellation factors.

For instance in the first mode of operation f 1 is less than or equal to C 2 and fequaled to the lesser of fand f. If controller determines that fequals f i.e. fis less than or equal to f then controller may determine that connectivity generator is to implement the joint walk in the x direction to output the domain coordinates of primitives in the contiguous portion. If controller determines that fequals f i.e. fis less than or equal to f then controller may determine that connectivity generator is to implement the joint walk in the y direction to output the domain coordinates of primitives in the contiguous portion. Connectivity generator may then output domain coordinates of primitives in the contiguous portion in either the joint walk in the x direction or joint walk in the y direction based on the determination of controller .

For triangle domain tessellation unit may receive one tessellation factor that indicates the number of points that reside along each side of a ring rather than two tessellation factors i.e. fand f for a quad domain such as quad domain of . For consistency the tessellation factor that indicates the number of points that reside along each side of a ring for triangle domain is referred to as f. However fmay simply be referred to as f as there is no fand ftessellation factors.

Furthermore in the first mode of operation where connectivity generator point generators and divide domain into two portions one of the two portions may include one third of domain and the other of the two portions may include two thirds of domain . For example portion B is a contiguous portion that includes two thirds of domain and portion A is a contiguous portion that includes one third of domain .

It may be possible for point generators and connectivity generator to divide domain into equal halves. However in the case where f 1 is less than or equal to C 2 there may be sufficient storage slots in reuse buffer for connectivity generator to output domain coordinates for primitives within two thirds of domain i.e. within portion B . Because two thirds of domain is larger than one half of domain it may be more advantageous for connectivity generator to divide domain into a one third portion A and a two thirds portion B.

For purposes of illustration illustrates the manner in which connectivity generator may output domain coordinates for primitives within portion B. As described above connectivity generator may output domain coordinates that point generators determined. Outputting domain coordinates of primitives in portion B may be considered as a joint walk because portion B is a combination of two triplets e.g. two thirds of domain equals a combination of two one thirds of domain .

In the example illustrated in connectivity generator may start outputting domain coordinates of primitives that are located at the center of portion B and extend outwards. For example illustrates first diagonal strip second diagonal strip and third diagonal strip . In this example connectivity generator may output the domain coordinates of primitives that reside within first diagonal strip followed by the domain coordinates of primitives that reside with second diagonal strip and then followed by the domain coordinates of primitives that reside with third diagonal strip . After the outputting of the domain coordinates for each of the diagonal strips for any of the domain coordinates for which reuse buffer does not store corresponding patch coordinates controller may cause an instantiation of domain shader to execute and domain shader may store the transformed coordinates i.e. the patch coordinates that correspond to the domain coordinates in reuse buffer .

In the example illustrated in because connectivity generator is implementing the first mode of operation second diagonal strip is tangent to first diagonal strip and second diagonal strip may include the same number of primitives as first diagonal strip . Also in the first mode of operation third diagonal strip may be parallel with first diagonal strip and not diagonal with second diagonal strip . As illustrated third diagonal strip may include a different number of primitives than the first diagonal strip and the second diagonal strip .

Connectivity generator may keep outputting domain coordinates in this manner until connectivity generator completes outputting domain coordinates of all of the primitives in portion B. It should be understood that although illustrates portion B as including the bottom two thirds of domain aspects of this disclosure are not so limited. In other examples portion B may include the right or left two thirds of domain . For portion A connectivity generator may output primitives in accordance with a second mode of operation described below.

In the examples illustrated in point generators and connectivity generator may implement the joint walk where joint walk includes two sections of a quadruplet for a quad domain and two sections of a triplet for a triangle domain. In the joint walk the two sections are adjacent to one another and share vertices on a hypothetical middle line extending throughout the domain i.e. in the vertical direction in . also illustrate an example of uniform tessellation in which there are the same number of vertices along each of the rings and the number of vertices along each of the rings is even. This may allow point generators of tessellation unit to exploit the symmetry pattern in the tessellation and save computations by computing the coordinates for half the vertices along a ring and mirroring the coordinates of the other half of the vertices along the ring using an internal buffer other than or including reuse buffer .

Similar to after outputting primitives of a diagonal strip there may be no diagonal strip that is congruent to that diagonal strip. In this case connectivity generator may output primitives of the diagonal strip that is the mirror opposite. For example after connectivity generator outputs the domain coordinates of primitives within diagonal strip there may be no diagonal strip that is tangent to diagonal strip . In this case connectivity generator may output the domain coordinates of primitives in diagonal strip which is the mirror opposite of diagonal strip . For example if diagonal strip and diagonal strip were to extend diagonal strip and diagonal strip would meet at the same point along a line of symmetry.

In the example illustrated in fequals 6 and fequals 18. However for ease of illustration only half of contiguous portion is illustrated. For instance illustrates six segments along the y axis where a segment is a line between two vertices and nine segments along the x axis. The full contiguous portion includes six segments along the y axis and eighteen segments along the x axis. For ease of illustration only the part of the contiguous portion that includes six segments along the y axis and nine segments along the x axis is illustrated i.e. half of the contiguous portion . For instance fequals 6 because there are six segments along the y axis where a segment includes two end points and the two end points are vertices of primitives. In fequals 18 because there are actually eighteen segments along the x axis but only nine of the eighteen segments are illustrated in .

Also in the example illustrated in assume that the number of slots in reuse buffer is 9 i.e. C equals 9 . In this case because fis less than f the processing unit e.g. controller and or tessellation unit may determine that fequals f i.e. fequals 6 . In this example f 1 equals 7 and C 2 also equals 7. Therefore in this example controller may determine that f 1 is less than or equal to C 2 and may cause point generators and connectivity generator to implement the first mode of operation i.e. the joint walk .

Furthermore in this example because fis less than f controller may cause point generators and connectivity generator to implement the joint walk in the y direction. For example as illustrated in connectivity generator may start from the left end of contiguous portion and extend outwards to the right end of contiguous portion . In the example illustrated in a first diagonal strip may include primitives and a second diagonal strip may include primitives and and a third diagonal strip may include primitives and . The first diagonal strip starts from the y axis and the second diagonal strip ends at the y axis hence joint walk in the y direction.

In this case the second diagonal strip is tangent with the first diagonal strip and the third diagonal strip is parallel with the first diagonal and not parallel with the third diagonal. Also the number of primitives in the first and second diagonal strips is the same i.e. primitives in each and the number of primitives in the third diagonal strip is different i.e. primitives instead of primitives .

Table 1 below illustrates the behavior of reuse cache for the first primitives of contiguous portion . In Table 1 the first column indicates the primitive the second column indicates the domain coordinates and the third column indicates the patch coordinates stored in reuse buffer . For ease of illustration the patch coordinates are given the same value as their corresponding domain coordinates. Also in the third column of Table 1 patch coordinates that are bolded and underlined indicate the instance when domain shader executed to transform the domain coordinates to patch coordinates.

In Table 1 for primitive controller may cause three instantiations of domain shader to execute to transform the domain coordinates of primitive to patch coordinates. Primitive shares two vertices with primitive i.e. the vertex with domain coordinate and . In this case for primitive controller may cause one instantiation of domain shader to execute one for domain coordinate . Because the patch coordinates that correspond to domain coordinates and are already stored in reuse buffer controller may not cause an instantiation of domain shader for domain coordinates and .

As illustrated in Table 1 after primitive reuse buffer is full. In this case after connectivity generator outputs the domain coordinates of primitive controller may determine that two instantiations of domain shader need to execute one for domain coordinate of primitive and one for domain coordinate of primitive . Accordingly reuse buffer may remove the earliest stored patch coordinates which are patch coordinates and to free storage space for patch coordinates and .

Table 1 may indicate the manner in which to efficiently utilize reuse buffer to minimize the execution of domain shader for the first mode of operation. For example all shared vertices are fully utilized e.g. no extra cache misses . For instance the patch coordinates that correspond to the domain coordinates of a vertex remain stored in reuse buffer until connectivity generator outputs the domain coordinates for most of the primitives that share that vertex. This may minimize the number of times domain shader needs to execute.

The above examples described the techniques for the first mode of operation where f 1 is less than or equal to C 2. However the condition that f 1 is less than or equal to C 2 may be not true in every case. For example for larger values of fand or smaller values of C compared to above examples the condition that f 1 is less than or equal to C 2 may not hold true.

In some examples if the processing unit e.g. controller and or tessellation unit determines that f 1 is not less than or equal to C 2 controller in this example may determine whether f 2 1 is less than or equal to C 1. If controller determines that f 2 1 is less than or equal to C 1 controller may cause connectivity generator to implement a second mode of operation.

In the second mode of operation point generators and connectivity generator may divide a quad domain into four portions e.g. quadruplets where at least one of the portions is a contiguous portion. In the second mode of operation point generators and connectivity generator may divide a triangle domain into three portions e.g. triplets where at least one of the portions is a contiguous portion.

For the second mode of operation similar to the first mode of operation connectivity generator may output domain coordinates of primitives that reside within a first diagonal strip followed by domain coordinates of primitives that reside within the second diagonal strip and then followed by domain coordinates of primitives that reside within a third diagonal strip. However in the second mode of operation the second diagonal strip is parallel with the first diagonal strip and the third diagonal strip.

For instance an inner side of the second diagonal strip may be the same as an outer side of the first diagonal strip. Also an outer side of the second diagonal strip may be the same as an inner side of the third diagonal strip. In this example because the second diagonal strip is parallel with both the first and the third diagonal strips the first diagonal strip is parallel with the third diagonal strip even if neither the outer nor inner side of the first diagonal strip is the same as the inner or outer side of the third diagonal strip.

For purposes of illustration illustrates the manner in which connectivity generator may output domain coordinates for primitives within portion C. Portion C may be considered as a contiguous portion because portion C does not create a gap in domain .

In the example illustrated in connectivity generator may start outputting domain coordinates of primitives that are located at a corner of portion C and extend outwards towards the opposing corner of portion C. For example in connectivity generator may start from the bottom right corner of portion C and extent outwards towards the top left corner of portion C. This is further illustrated with respect to first diagonal strip second diagonal strip and third diagonal strip . As illustrated second diagonal strip is closer to the top right corner than first diagonal strip and third diagonal strip is closer to the top right corner than both second diagonal strip and first diagonal strip .

First diagonal strip includes primitives A to N second diagonal strip includes primitives A to M and third diagonal strip includes primitives A to X. In the second mode of operation second diagonal strip may include a different number of primitives than first diagonal strip . For example second diagonal strip may include M number of primitives and first diagonal strip may include N number of primitives where M and N are different numbers. Also third diagonal strip may include a different number of primitives than first diagonal strip and second diagonal strip . For example third diagonal strip includes X number of primitives where X is different than M and N.

In the second mode of operation first diagonal strip may be parallel with second diagonal strip . For example an inner side of second diagonal strip is the same as an outer side of first diagonal strip . Also in the second mode of operation third diagonal strip may be parallel with second diagonal strip . For example an inner side of third diagonal strip is the same as an outer side of second diagonal strip . In this case because second diagonal strip is parallel with both first diagonal strip and third diagonal strip first diagonal strip and third diagonal strip may be considered parallel with one another.

In connectivity generator may output the domain coordinates for primitives A to N i.e. domain coordinates for primitives in first diagonal strip . For any of these domain coordinates of primitives A to N for which reuse buffer does not store corresponding patch coordinates controller may cause an instantiation of domain shader to execute and domain shader may store the transformed coordinates i.e. the patch coordinates that correspond to the domain coordinates in reuse buffer . Connectivity generator may then output domain coordinates for primitives A to M i.e. domain coordinates for primitives in second diagonal strip . Again for any of these domain coordinates of primitives A to M for which reuse buffer does not store corresponding patch coordinates controller may cause an instantiation of domain shader to execute and domain shader may store the transformed coordinates in reuse buffer . Next connectivity generator may output domain coordinates for primitives A to i.e. domain coordinates for primitives in third diagonal strip . As above for any of these domain coordinates of primitives A to X for which reuse buffer does not store corresponding patch coordinates controller may cause an instantiation of domain shader to execute and domain shader may store the transformed coordinates in reuse buffer .

In the second mode of operation connectivity generator may output domain coordinates of primitives in a zig zag manner. For instance connectivity generator may start outputting domain coordinates of first diagonal strip starting from the x axis of domain . Then in some examples connectivity generator may output domain coordinates of second diagonal strip starting from the x axis of domain . For third diagonal strip connectivity generator may once again start from the x axis of domain . Such outputting may form a zig zag pattern.

Connectivity generator may keep outputting domain coordinates in this manner until connectivity generator completes outputting domain coordinates of all of the primitives in portion C. Connectivity generator may then repeat these steps with respect to portions A B and D. As illustrated in portion C and portions A B and D share many vertices. In some cases it may be possible that the patch coordinates that correspond to the domain coordinates for some of these vertices that shared by portion C with each one of portions A B and D are no longer available in reuse buffer . For some of vertices controller may cause domain shader to execute. However although domain shader may need execute for retransforming the domain coordinates of these shared vertices to patch coordinates the techniques described in this disclosure may still reduce the overall number of times domain shader needs to execute as compared to the examples illustrated in .

In the example of connectivity generator started from the bottom right corner of portion C and extended outwards towards the top left corner of portion C. Such an output scheme may be referred to as a single walk in the x direction because connectivity generator starts from the x axis of domain . Another example of the single walk in the x direction may be where connectivity generator starts from the bottom left corner of portion C and extends outwards towards the top right corner of portion C.

However aspects of this disclosure are not limited to a single walk in the x direction. In some other examples point generators and connectivity generator may implement a single walk in the y direction where point generators and connectivity generator start from the top left corner of portion C and extend outwards to the bottom right corner of portion C or starts from the top right corner of portion C and extends outwards to the bottom left corner of portion C. These output schemes may be referred to as a single walk in the y direction because point generators and connectivity generator start from the y axis of domain .

The processing unit i.e. controller in this example may determine whether connectivity generator is to implement the single walk in the x direction or the single walk in the y direction. For example in the second mode of operation f 2 1 is less than or equal to C 1. If controller determines that fequals f i.e. fis less than or equal to f controller may cause connectivity generator to output domain coordinates in accordance with the single walk in the x direction. If controller determines that fequals f i.e. fis less than or equal to f controller may cause connectivity generator to output domain coordinates in accordance with the single walk in the y direction.

For purposes of illustration illustrates the manner in which connectivity generator outputs the domain coordinates for primitives in portion C. Connectivity generator may similarly output the domain coordinates of primitives within portions A and B. Furthermore with respect to connectivity generator may similarly output the domain coordinates of primitives within portion OOA.

In this example connectivity generator may output the domain coordinates for primitives in first diagonal strip and controller may execute instantiations of domain shader for each domain coordinate whose corresponding patch coordinate is not stored in reuse buffer . Connectivity generator may then output the domain coordinates for primitives in second diagonal strip and controller may execute instantiations of domain shader for each domain coordinate whose corresponding patch coordinate is not stored in reuse buffer . Next connectivity generator may output the domain coordinates for primitives in third diagonal strip and controller may execute instantiations of domain shader for each domain coordinate whose corresponding patch coordinate is not stored in reuse buffer .

Connectivity generator may keep outputting domain coordinates in this manner until connectivity generator reaches the last primitive in portion C. Then connectivity generator may output domain coordinates of primitives in portions A and B in a substantially similar fashion.

In the example illustrated in fequals 10 and fequals 8. illustrates a quarter of the contiguous portion. For example illustrates five segments along the x axis and four segments along the y axis where the full contiguous portion includes ten segments along the x axis and eight segments along y axis. Also in the example illustrated in assume that the number of slots of reuse buffer is 6 i.e. C equals 6 . In this case because fis less than f the processing unit e.g. controller and or tessellation unit may determine that fequals f i.e. fequals 8 . In this example f 2 1 equals 5 and C 1 also equals 5. Therefore in this example controller may determine that f 2 1 is less than or equal to C 1 and may cause point generators and connectivity generator to implement the second mode of operation i.e. single walk .

For example connectivity generator may output domain coordinates of primitives within a first diagonal strip which may include primitives and . Connectivity generator may then output domain coordinates of primitives within a second diagonal strip which may include primitives and . Then connectivity generator may output domain coordinates of primitives within a third diagonal strip which may include primitives and . In this example each of the first second and third diagonal strips may include different number of primitives i.e. and primitives respectively .

Furthermore in this example because fis less than f point generators and connectivity generator may implement the single walk in the y direction. For example primitive of the first diagonal strip is located along the y axis of contiguous portion primitive i.e. the first primitive of the second diagonal strip is located along the y axis of contiguous portion and primitive i.e. the first primitive of the third diagonal strip is located along the y axis of contiguous portion .

Table 2 below illustrates the behavior of reuse cache for the 40 primitives of contiguous portion . In Table 2 the first column indicates the primitive the second column indicates the domain coordinates and the third column indicates the patch coordinates stored in reuse buffer . For ease of illustration the patch coordinates are given the same value as their corresponding domain coordinates. Also in the third column of Table 2 patch coordinates that are bolded and underlined indicate the instance when domain shader executed to transform the domain coordinates to patch coordinates.

In Table 2 for primitive controller may cause three instantiations of domain shader to execute to transform the domain coordinates of primitive to patch coordinates. Primitive shares one vertex with primitive i.e. the vertex with domain coordinate . In this case for primitive controller may cause two instantiations of domain shader to execute one for domain coordinate and one for domain coordinate . Because the patch coordinates that correspond to domain coordinate is already stored in reuse buffer controller may not cause an instantiation of domain shader for domain coordinate .

As illustrated in Table 2 after primitive reuse buffer is full. In this case after connectivity generator outputs the domain coordinates of primitive controller may determine that two instantiations of domain shader need to execute one for domain coordinate of primitive and one for domain coordinate of primitive . Accordingly reuse buffer may remove the earliest stored patch coordinates which are patch coordinates and 9 to free storage space for patch coordinates and 7.

Table 2 as an example indicates a way in which to efficiently utilize reuse buffer to minimize the execution of domain shader for the second mode of operation. For example all shared vertices are fully utilized e.g. no extra cache misses . For instance similar to the example in Table 1 the patch coordinates that correspond to the domain coordinates of a vertex remain stored in reuse buffer until connectivity generator outputs the domain coordinates for most of the primitives that share that vertex. This may minimize the number of times domain shader needs to execute.

The above examples illustrated the first mode of operation and the second mode of operation. However in some examples point generators and connectivity generator may need to implement a third mode of operation. For example f 2 1 C 1 can be rewritten as f 2 2 C 1 . If the size of fis too large or the size of C is too small then there may be instances where f 2 is not less than or equal to 2 C 1 . In these cases f 1 may also not be less than or equal to C 2. In such cases it may not be possible for point generators and connectivity generator to divide a quad domain into quadruplets or divide a triangle domain into triplets and implement the single walk in each of these quadruplets or triplets such that each of the shared vertices is reused.

In such a case i.e. when f 2 is greater than 2 C 1 connectivity point generators and generator may implement the third mode of operation. The third mode of operation may be a combination of the first mode of operation and the second mode of operation. For example when the processing unit e.g. controller and or tessellation unit determines that f 2 is greater than 2 C 1 controller as the example of the processing unit may cause point generators and connectivity generator to divide a quad domain into more than quadruplets and may cause point generators and connectivity generator to divide a triangle domain into more than triplets. Connectivity generator may then implement the first mode of operation e.g. single walk on a first set of the plurality of portions and implement the second mode of operation e.g. joint walk on a second set of the plurality of portions.

For example connectivity generator may output domain coordinates of primitives within a first second and third diagonal strips where the diagonal strips are within portion A. In this example the first second and third diagonal strips may be parallel with one another. For the joint walk across the combined portions C and D connectivity generator may output domain coordinates within a fourth fifth and sixth diagonal strips where the diagonal strips are within combined portions C and D. In this example the fifth diagonal strip may be tangent with the fourth diagonal strip and the sixth diagonal strip may be parallel with the fourth diagonal strip.

In some examples tessellation unit may have tessellated the example domains illustrated in and using uniform tessellation with even tessellation factors. Uniform tessellation means that there are an equal number of points i.e. vertices along the rings. Also in the example illustrated in the tessellation factors were fequals 18 and fequals 6 both of which are even tessellation factors and in the example illustrated in the tessellation factors were fequals 10 and fequals 8 both of which are even tessellation factors . Even tessellation factors results in mirroring across the half way point of an edge of the domain.

However not all domains may be tessellated using uniform tessellation or with even tessellation factors. The following describes a few examples in which the domains are not tessellated using uniform tessellation and examples in which the tessellation factors are even and odd and are both odd.

For uniform tessellation with odd tessellation factors the manner in which connectivity generator divides the domain may be slightly different than the examples with even tessellation factors. However the order in which connectivity generator outputs the domain coordinates of the primitives may be the same.

In the example illustrated in the processing unit e.g. controller and or tessellation unit may have determined that f 2 1 is less than or equal to C 2 and may cause point generators and connectivity generator to implement the second mode of operation i.e. the single walk . For example connectivity generator may output domain coordinates for primitives within first diagonal strip followed by second diagonal strip and then third diagonal strip . As illustrated first diagonal strip is parallel with second diagonal strip which is parallel with third diagonal strip . Accordingly first diagonal strip second diagonal strip and third diagonal strip are each parallel with one another. Also the number of primitives in first diagonal strip second diagonal strip and third diagonal strip is different.

In the example illustrated in the processing unit e.g. controller and or tessellation unit may have determined that f 1 is less than or equal to C 2 and may cause point generators and connectivity generator to implement the first mode of operation i.e. the joint walk . For example connectivity generator may output domain coordinates for primitives within first diagonal strip followed by second diagonal strip and then third diagonal strip . As illustrated second diagonal strip is tangent with first diagonal strip . Third diagonal strip is parallel with first diagonal strip and not parallel with second diagonal strip . Also the number of primitives in first diagonal strip and second diagonal strip is the same and different than the number of primitives in third diagonal strip .

In the example illustrated in the processing unit e.g. controller and or tessellation unit may have determined that f 2 1 is less than or equal to C 2 and may cause point generators and connectivity generator to implement the second mode of operation i.e. the single walk . For example connectivity generator may output domain coordinates for primitives within first diagonal strip followed by second diagonal strip and then third diagonal strip . In the example illustrated in the processing unit e.g. controller and or tessellation unit may have determined that f 1 is less than or equal to C 2 and may cause point generators and connectivity generator to implement the first mode of operation i.e. the joint walk . For example connectivity generator may output domain coordinates for primitives within first diagonal strip followed by second diagonal strip and then third diagonal strip .

In the examples illustrated in after connectivity generator outputs the domain coordinates for the contiguous portions there may be some remaining primitives whose domain coordinates have not yet been outputted. For instance in the two triangles that form the center of domain A may not be encompassed by the contiguous portions. In these examples connectivity generator may output the domain coordinates of the remaining primitives e.g. the triangles that form the center of domain A .

In the example illustrated in controller as one example of the processing unit may have determined that f 2 1 is less than or equal to C 2 and may cause point generators and connectivity generator to implement the second mode of operation i.e. the single walk . For example connectivity generator may output domain coordinates for primitives within first diagonal strip followed by second diagonal strip and then third diagonal strip . In the example illustrated in controller may have determined that f 1 is less than or equal to C 2 and may cause connectivity generator to implement the first mode of operation i.e. the joint walk . For example connectivity generator may output domain coordinates for primitives within first diagonal strip followed by second diagonal strip and then third diagonal strip .

Similar to after connectivity generator outputs the domain coordinates for the contiguous portions there may be a remaining primitive in whose domain coordinates have not yet been outputted. For instance in the triangle that forms the center of domain A and B respectively may not be encompassed by the contiguous portions. In these examples connectivity generator may output the domain coordinates of the remaining primitive e.g. the triangle that forms the center of domain A and B .

The above examples describes the manner in which connectivity generator outputs domain coordinates of primitives within a contiguous portion of a domain where tessellation unit tessellates the domain with uniform tessellation and even tessellation factors even and odd tessellation factors and odd tessellation factors. The following describes the manner in which connectivity generator outputs domain coordinates of primitives for a non uniform tessellated domain. In a non uniform tessellation domain tessellation unit may tessellate parts of the domain utilizing non uniform tessellation and may tessellate other parts of the domain utilizing uniform tessellation.

For instance for a quad domain there may be a total of six tessellation factors. Four of the six tessellation factors may define the number of segments along each of the four sides of the quad domain respectively. These four tessellation factors may not be the same resulting in non uniform tessellation. The remaining two tessellation factors may define the number of segments along the x axis and y axis of the rings within the quad domain resulting in uniform tessellation within the quad domain.

For a triangle domain there may be a total of four tessellation factors. Three of the four tessellation factors may define the number of segments along each of the three sides of the triangle domain respectively. These three tessellation factors may not be the same resulting in non uniform tessellation. The remaining tessellation factor may define the number of segments for the triangle rings within the triangle domain resulting in uniform tessellation within the triangle domain.

For example non uniform tessellation refers to instances when the number of vertices on one or more sides of an outer ring is different. In examples of non uniform tessellation if the tessellation factors for the uniform portions are fand f setup unit of tessellation unit may determine the values of Fand F where fequals F 2.0 and fequals F 2.0.

In examples where tessellation unit tessellates a domain utilizing both non uniform tessellation and uniform tessellation controller may cause point generators and connectivity generator to implement the first second or third mode of operation on the uniform tessellated part of the domain. In the techniques described in this disclosure the manner in which point generators and connectivity generator output the domain coordinates of primitives within the non uniform part of the domain may be generally immaterial.

In accordance with techniques described in this disclosure controller one example of the processing unit may cause point generators and connectivity generator to implement the first second or third mode of operation on portions A B and C based on the values of fand C. Point generators and connectivity generator may implement any existing technique or technique yet to be developed to output the domain coordinates of the primitives within portion . As illustrated portion may be the outer ring of domain .

In accordance with techniques described in this disclosure the processing unit e.g. controller may cause point generators and connectivity generator to implement the first second or third mode of operation on portions A D based on the values of fand C. Point generators and connectivity generator may implement any existing technique or technique yet to be developed to output the domain coordinates of the primitives within portion .

Tessellation unit may receive and process tessellation factors for a domain . For example setup unit may receive the fand ftessellation factors for a quad domain or the f tessellation factor for the triangle domain where these tessellation factors indicate the number of segments along each ring of the domain. For example point generators may partition each ring within the domain based on these tessellation factors and the end points of each segment may be a vertex for one or more primitives. In addition setup unit may round fand fto an integer round fand fto an odd integer round fand fto an even integer or round fand fto 2 i.e. a dyadic integer based on the manner in which the domain is to be tessellated.

Furthermore if the received tessellation factors indicate that the domain is to be tessellated using uniform tessellation and non uniform tessellation tessellation unit may implement the example techniques illustrated in on the uniform tessellated part of the domain. For the non uniform tessellated part of the domain such as the outer ring of the domain tessellation unit may output the domain coordinates of the non uniformed tessellated part of the domain utilizing any technique. For instance for the non uniformed tessellated part tessellation unit may output the domain coordinates in the manner illustrated in i.e. in a ring fashion which is non contiguous .

The processing unit may determine whether f 1 is less than or equal to C 2 . If the processing unit determines that f 1 is less than or equal to C 2 YES of the processing unit may cause tessellation unit via point generators and connectivity generator to implement the first mode of operation.

For example the processing unit may determine whether the domain is a quad domain . If the domain is a quad domain YES of the processing unit may determine whether fis less than or equal f . If fis less than or equal to f YES of the processing unit may cause tessellation unit via point generators and connectivity generator to implement the joint walk in the x direction . For example point generators and connectivity generator may divide the quad domain into two portions where one of the portions is a contiguous portion and may output domain coordinates of primitives within the contiguous portion in accordance with the joint walk in the x direction technique.

If fis not less than or equal to f NO of the processing unit may cause tessellation unit via point generators and connectivity generator to implement the joint walk in the y direction . For example connectivity generator may divide the quad domain into two portions where one of the portions is a contiguous portion and may output domain coordinates of primitives within the contiguous portion in accordance with the joint walk in the y direction technique.

If the domain is not a quad domain NO of the processing unit may cause tessellation unit via point generators and connectivity generator to implement the joint walk on a triangle domain . For example connectivity generator may divide the triangle domain into a one third portion and a two thirds portion where at least the two thirds portion is a contiguous portion. Connectivity generator may output domain coordinates of primitives within the contiguous two thirds portion in accordance with the joint walk technique.

If the processing unit determined that f 1 is not less than or equal to C 2 NO of the processing unit may determine whether f 2 1 is less than or equal to C 1 . If the processing unit determines that f 2 1 is less than or equal to C 2 YES of the processing unit may cause tessellation unit via point generators and connectivity generator to implement the second mode of operation.

The processing unit may determine whether the domain is a quad domain . If the domain is a quad domain YES of the processing unit may determine whether fis less than or equal f . If fis less than or equal to f YES of the processing unit may cause tessellation unit via point generators and connectivity generator to implement the single walk in the x direction . For example connectivity generator may divide the quad domain into four portions where one of the four portions is a contiguous portion and may output domain coordinates of primitives within the contiguous portion in accordance with the single walk in the x direction technique.

If fis not less than or equal to f NO of the processing unit may cause tessellation unit via point generators and connectivity generator to implement the single walk in the y direction . For example connectivity generator may divide the quad domain into four portions where one of the portions is a contiguous portion and may output domain coordinates of primitives within the contiguous portion in accordance with the single walk in the y direction technique.

If the domain is not a quad domain NO of the processing unit may cause tessellation unit via point generators and connectivity generator to implement the single walk on a triangle domain . For example connectivity generator may divide the triangle domain into three portions where at least one portion is a contiguous portion. Connectivity generator may output domain coordinates of primitives within the contiguous portion in accordance with the single walk technique.

If the processing unit determined that f 2 1 is not less than C 1 NO of the processing unit may cause point generator and connectivity generator to implement the third mode of operation. For example the processing unit may cause connectivity generator to implement both the single walk technique and the joint walk technique . For instance in the third mode of operation connectivity generator may divide a quad domain into more than four portions and may divide a triangle domain into more than three portions. In this example for the quad domain connectivity generator may implement the single walk technique on four of the portions and may implement the joint walk technique on the other portions. For the triangle domain connectivity generator may implement the single walk technique on three of the portions and may implement the joint walk technique on the other portions.

In the example of connectivity generator may implement the single walk in the x direction the single walk in the y direction the joint walk in the x direction and the joint walk in the y direction. In some examples walking in the x direction or the y direction may be based on the lesser of the two tessellation factors. For example the processing unit may determine that a first tessellation factor is less than or equal to a second tessellation factor. When outputting the domain coordinates of primitives within the first second and third diagonal strips connectivity generator may start from an axis of the domain that corresponds to the first tessellation factor and extends outwards.

For instance if fis less than f then connectivity generator starts from the x axis of the domain and extends outwards when outputting the domain coordinates of primitives within the first second and third diagonal strips. If fis less than f then connectivity generator starts from the y axis of the domain and extends outwards when outputting the domain coordinates of primitives within the first second and third diagonal strips.

In general in accordance with the example illustrated the processing unit may select a mode of operation from a plurality of different modes of operation based at least on a number of storage slots in reuse buffer where each of the different modes of operation indicate a different manner in which connectivity generator outputs domain coordinates of primitives within a contiguous portion of a domain. Examples of the plurality of different modes of operation include the first second and third modes of operation. The processing unit may select the mode of operation based at least on the storage capabilities of a reuse buffer. The processing unit may then cause connectivity generator to output the domain coordinates of the primitives within the contiguous portion of the domain based on the selected mode of operation.

For example if at least one tessellation factor plus one is less than or equal to a number of storage slots in reuse buffer minus two the processing unit may cause connectivity generator to output domain coordinates in accordance with the first mode of operation. If the at least one tessellation factor plus one is not less than or equal to the number of storage slots in reuse buffer minus two and the at least one tessellation factor divided by two plus one is less than or equal to the number of storage slots in reuse buffer minus one the processing unit may cause connectivity generator to output domain coordinates in accordance with the second mode of operation. If the at least one tessellation factor divided by two plus one is not less than or equal to the number of storage slots in reuse buffer minus one the processing unit may cause connectivity generator to output domain coordinates in accordance with the third mode of operation. The third mode of operation may be considered to be different than just the first mode of operation and just the second mode of operation because the third mode of operation is a combination of the first mode of operation and the second mode of operation.

Point generators and connectivity generator may divide a domain into a plurality of portions . At least one of the portions is a contiguous portion. If operating in the first mode of operation point generators and connectivity generator may divide a quad domain into two equal portions and may divide a triangle domain into two portions where one portion is one third of the domain and the other portion is two thirds of the domain. If operating in the second mode of operation point generators and connectivity generator may divide a quad domain into four portions and may divide a triangle domain into three portions. If operating in the third mode of operation point generators and connectivity generator may divide the quad domain into more than four portions and may divide the triangle domain into more than three portions.

Connectivity generator may output domain coordinates of primitives in a first diagonal strip within the contiguous portion . Connectivity generator may then output domain coordinates of primitives in a second diagonal strip within the contiguous portion . Connectivity generator may then output domain coordinates of primitives in a third diagonal strip within the contiguous portion .

The second diagonal strip may be one of parallel with the first diagonal strip or tangent with the first diagonal strip. The third diagonal strip may be parallel with the first diagonal strip. The third diagonal strip may be parallel with the second diagonal strip in examples where the second diagonal strip is parallel with the first diagonal strip. The third diagonal strip may not be parallel with the second diagonal strip in examples where the second diagonal strip is tangent with the first diagonal strip.

The number of primitives in the first diagonal strip may the same as the number of primitives in the second diagonal strip in examples where the second diagonal strip is tangent with the first diagonal strip. The number of primitives in the first diagonal strip may be different then the number of primitives in the second diagonal strip in examples where the second diagonal strip is parallel with the first diagonal strip. In either case the number of primitives in the third diagonal strip may be different than the number of primitives in the first and second diagonal strips.

In the following examples the number of storage slots in reuse buffer is 32 slots. The tessellation factors range from 1.0 to 64.0. In general the techniques described above with respect to result in almost a 100 miss rate for uniform tessellation. The techniques described above with respect to result in about a 45 miss rate. The techniques described above with respect to result in a 5 miss rate. Minimizing the miss rate may be beneficial as it results in fewer instantiations of domain shader . Execution of domain shader may be time and processing extensive and therefore minimized execution of domain shader may be beneficial.

Line of line of line of and line of illustrate the miss rate when connectivity generator outputs domain coordinates of primitives in accordance with the techniques described in this disclosure. As illustrated by these lines the miss rate is very low and close to 0 . Line of line of line of and line of illustrate the miss rate when a connectivity generator unlike connectivity generator outputs domain coordinates of primitives in accordance with the techniques described above with respect to . As illustrated by these lines the miss rate is much greater than the miss rate when connectivity generator implements one or more example techniques described in this disclosure. Line of line of line of and line of illustrate the miss rate when a connectivity generator unlike connectivity generator outputs domain coordinates of primitives in accordance with the techniques described above with respect to . As illustrated by these lines the miss rate is much greater than the miss rate when connectivity generator implements one or more example techniques described in this disclosure and also greater than when a connectivity generator unlike connectivity generator implements the techniques illustrated in .

GPU system memory and processor of may be similar to GPU system memory and processor of . Examples of user interface include but are not limited to a trackball a mouse a keyboard and other types of input devices. User interface may also be a touch screen and may be incorporated as a part of display . Transceiver module may include circuitry to allow wireless or wired communication between device and another device or a network. Transceiver module may include modulators demodulators amplifiers and other such circuitry for wired or wireless communication. Display may comprise a liquid crystal display LCD a cathode ray tube CRT display a plasma display a touch sensitive display a presence sensitive display or another type of display device.

In one or more examples the functions described may be implemented in hardware software firmware or any combination thereof. If implemented in software the functions may be stored as one or more instructions or code on a computer readable medium. Computer readable media may include computer data storage media. Data storage media may be any available media that can be accessed by one or more computers or one or more processors to retrieve instructions code and or data structures for implementation of the techniques described in this disclosure. By way of example and not limitation such computer readable media can comprise random access memory RAM read only memory ROM EEPROM CD ROM or other optical disk storage magnetic disk storage or other magnetic storage devices or any other medium that can be used to store desired program code in the form of instructions or data structures and that can be accessed by a computer. Disk and disc as used herein includes compact disc CD laser disc optical disc digital versatile disc DVD floppy disk and Blu ray disc where disks usually reproduce data magnetically while discs reproduce data optically with lasers. Combinations of the above should also be included within the scope of computer readable media.

The code may be executed by one or more processors such as one or more digital signal processors DSPs general purpose microprocessors application specific integrated circuits ASICs field programmable logic arrays FPGAs or other equivalent integrated or discrete logic circuitry. Accordingly the term processor as used herein may refer to any of the foregoing structure or any other structure suitable for implementation of the techniques described herein. Also the techniques could be fully implemented in one or more circuits or logic elements.

The techniques of this disclosure may be implemented in a wide variety of devices or apparatuses including a wireless handset an integrated circuit IC or a set of ICs i.e. a chip set . Various components modules or units are described in this disclosure to emphasize functional aspects of devices configured to perform the disclosed techniques but do not necessarily require realization by different hardware units. Rather as described above various units may be combined in a hardware unit or provided by a collection of interoperative hardware units including one or more processors as described above in conjunction with suitable software and or firmware.

Various examples have been described. These and other examples are within the scope of the following claims.

