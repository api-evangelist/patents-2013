---

title: Object storage and synchronization hooks for occasionally-connected devices
abstract: A system may include an application programming interface (API) layer, a cache layer, and an object storage/access layer. The API layer may expose an interface to store a business object and an interface to retrieve the business object, and may transmit a request to store the business object and a request to retrieve the business object, and the cache layer may cache the business object and transmit the request to store the business object and the request to retrieve the business object. The object storage/access layer may receive the request to store the business object and, in response to the request to store the business object, to invoke a serialization method exposed by the business object to store the data associated with the object in a data structure. The object storage/access layer may also receive the request to retrieve the business object and, in response to the request to retrieve the business object, to invoke a deserialization method of the business object to deserialize the data associated with the business object in the data structure.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09152398&OS=09152398&RS=09152398
owner: SAP SE
number: 09152398
owner_city: Walldorf
owner_country: DE
publication_date: 20130925
---
This is a continuation of co pending prior U.S. patent application Ser. No. 12 480 170 filed Jun. 8 2009 which is a divisional of prior U.S. patent application Ser. No. 11 215 870 filed Aug. 31 2005 now issued as U.S. Pat. No. 7 565 365.

Some embodiments relate to enterprise systems utilizing occasionally connected devices. In particular some embodiments are associated with storage of business objects within mobile devices and or synchronization of the stored business objects with a back end data store.

Mobile devices are increasingly used for executing business processes. Such business processes utilize and manipulate business data stored on the mobile devices. In one example a delivery person may deliver a product to customers along an established route. The delivery person may use a mobile device to determine a product quantity and delivery schedule for each customer on the route to enter new orders and or changes to existing orders and to indicate successful delivery of an order. The mobile device must therefore receive business data from a back end system that is specific to the route with which the mobile device is associated e.g. product quantities delivery schedules as well as transmit business data e.g. new and or changed order information to the back end system for validation and storage therein.

To store an object a business process first invokes an appropriate interface of the JDO API. The object is cached and its data is serialized to an intermediate form using a database driver specific Structured Query Language SQL serializer. The serialized data is passed to a database driver for transmission to database element . Database element parses the received data and provides the parsed data to an access methods module. The module deserializes the data in its intermediate form and then serializes the data for storage in a database.

Conversely retrieval of the data includes invoking an interface of the JDO API to request the corresponding object passing the request through the cache SQL serializer the database driver the parser the access methods module and to the database. The data is retrieved from the database deserialized and serialized into the intermediate form using the access methods module. The serialized data is passed to a result builder for building an appropriate response to the request through the database driver a result parser the cache and back to the business process via the JDO API. Such storage and retrieval of business data is unsuitably inefficient for many usage scenarios including when resources are limited and or when high performance is required.

Conventional systems also do not adequately address local storage and synchronization of business data between a mobile device and a back end system. Synchronization issues arise because the nature of a mobile device to become occasionally disconnected from its associated back end system. The frequency and unpredictability of such disconnections create difficulties in keeping mobile devices up to date with respect to their associated data and in maintaining an accurate record of the internal state of the mobile devices.

Improvements to the efficiency of mobile object data storage and or synchronization are therefore desired.

Back end system of includes database management system DBMS and database . DBMS may comprise executable program code to retrieve data from database . Database may comprise one or more disparate systems for storing data therefore DBMS may comprise one or more systems for retrieving stored data. According to some embodiments database is implemented as any suitable collection of data that may be accessed by a computer program to select particular data from the collection. Back end system may comprise other unshown elements to provide an enterprise system such as SAP R 3 Enterprise Resource Planning system.

Back end system may also comprise any other suitable program code scripts or other functional data that is executable to interface with communication network and mobile devices through as described herein. Back end system may comprise any combination of hardware software and or firmware elements that may provide the functions that are attributed to a back end system herein. Two or more of these elements may be located remotely from one another and may communicate with one another via communication network and or a dedicated connection.

As used herein systems in communication with one another are directly or indirectly capable of communicating over any number of different systems for transferring data including but not limited to a local area network a wide area network a telephone network a cellular network a fiber optic network a satellite network an infrared network a radio frequency network and any other type of network that may be used to transmit information between devices. Moreover communication between systems may proceed over any one or more currently or hereafter known transmission protocols such as Asynchronous Transfer Mode ATM Internet Protocol IP Hypertext Transfer Protocol HTTP and Wireless Application Protocol WAP . Communication network may therefore comprise any communication media and protocols that are or become known.

Mobile devices through may interact with business objects maintained by back end system . Mobile devices through may generate access and or modify identical overlapping or completely different sets of business objects depending on their respective data subscriptions. Continuing with the example from the Background a business object BO may comprise an order placed by a customer and may therefore be associated with the one of mobile devices through that is assigned to a delivery route to which that customer belongs. Back end system may provide conflict resolution and synchronization services natively and or via middleware not shown .

Mobile devices through may comprise any of a laptop a personal digital assistant a tablet computer a handheld computer a cellular telephone a dedicated mobile device and any other suitable mobile device or devices that are or become known. As mentioned above mobile devices through may occasionally connect to back end system directly or via communication network .

Elements of architecture may operate to receive a request to store a business object cache the business object invoke a serialization method of the business object to serialize data associated with the business object and store the serialized data in a data structure in association with the business object. Elements of architecture may also operate to receive information regarding the storage of the business object and determine changes to the data stored in association with the business object. Conversely embodiments may receive a request to retrieve a business object retrieve serialized data associated with the business object from a data structure invoke a deserialization method of the business object to deserialize the data and return the business object with the deserialized data.

Architecture includes business processes interacting with system in order to store data in and retrieve data from database . Business processes may generate access and or modify business objects according to some embodiments. A business object as discussed herein may refer to a particular instance of a business object that is associated with particular data.

Business processes may transmit requests to store business objects in and or retrieve business objects from database . Business processes may comprise standalone business applications and application stack . Application stack may include business applications written in Java Server Pages JSP format a Web browser to provide user interface rendering for such applications and a Web server to provide an execution environment e.g. a Java Virtual Machine for the JSP business applications. Any suitable business process that is or becomes known may be used in conjunction with some embodiments.

System includes API layer cache layer direct object storage access layer and synchronization service layer . API layer may expose an interface to store a business object and an interface to retrieve the business object and may transmit a request to store the business object and a request to retrieve the business object. Interfaces exposed by API layer may comply with the JDO API specification but embodiments are not limited thereto. In a case that API layer exposes such complying interfaces actions associated with the interfaces exposed by API layer may differ markedly from those required by the JDO API specification.

Cache layer provides access to underlying persistence implementation layer . Cache layer may also or alternatively store a number of recently used objects to provide quick access thereto. In some embodiments cache layer may cache a to be stored business object and transmit a request to store the business object. Cache may also or alternatively transmit a request to retrieve the business object. Details of cache according to some embodiments are provided below.

Direct object storage access layer may receive request to store the business object from cache layer and in response may invoke a serialization method exposed by the business object to store data associated with the business object in database . Direct object storage access layer may also receive a request to retrieve the business object from cache layer and in response to the request to retrieve the business object invoke a deserialization method of the business object to deserialize the data associated with the business object in the database .

Synchronization service layer may receive information from cache regarding the storage of a business object in database . Synchronization service layer may use this information to determine changes to the data associated with the business object. The determined changes may be used to synchronize the data stored in database with the data stored in association with the business object in database of back end system . Synchronization service may be designed with respect to a generic synchronization abstraction and may therefore be capable of providing synchronization services to systems other than system .

Initially a request to store a business object is received at . In one example business process invokes an interface exposed by API layer . The invocation passes a business object to API layer and comprises a request to store the business object in database . As described above the business object is a particular instance of a business object and includes data associated with the particular instance. The received request may also indicate that the business object implements one or more methods that may be used at as described below.

The business object is cached at . Cache layer may cache the object until storage of the business object is complete. Cache layer also provides access to direct object storage access layer . According to some embodiments described below cache layer provides information to sync service that may be used to determine changes to database since a last synchronization with back end system . The business object itself may include one or methods that may be invoked to provide the information. Inclusion of these methods in the business object according to some embodiments will be described below.

Next at a serialization method of the business object is invoked. The serialization method serializes data associated with the business object. Accordingly the business object includes one or more methods for serializing its own data. In some embodiments such methods are added to the business object during compilation thereof using a class rebuilder as will be described below with respect to. . Direct object storage access layer may invoke the serialization method at according to some embodiments.

The serialized data is stored in a data structure at . In the present example direct object storage access layer stores the serialized data in database in association with the business object. Such storage may comprise storing an identifier of the business object instance in association with the serialized data in database . Direct object storage access layer may store the data in any form and using any database management protocol that might govern database .

According to some embodiments database provides information to synchronization service after . Synchronization service may use the information to determine changes to the data stored in database . Again such changes may be used to synchronize the data stored in association with the stored business object in database with the data stored in association with the stored business object in database of back end system .

At a request to retrieve a business object is received. For example business process may invoke an interface exposed by API layer at . The invocation identifies a business object and comprises a request to retrieve the business object from database . More particularly the invocation comprises a request to retrieve serialized data associated with an instance of the business object and stored in database . The request may also indicate using the invoked interface another interface or any other means that the business object includes one or more methods that may be used as will be described below with respect to .

The serialized data is retrieved from the data structure at . In the present example direct object storage access layer retrieves the serialized data from database using an identifier of the business object that was passed in the request. Direct object storage access layer may retrieve the data using any database management protocol that is compatible with database

A deserialization method of the business object is then invoked at . Direct object storage access layer may invoke the serialization method at according to some embodiments. The deserialization method deserializes the retrieved data into an appropriate object format. Accordingly the business object includes one or more methods for deserializing its own data. These methods may be added to the business object during compilation as will be described below.

The business object including the deserialized data is returned to the requesting entity at . The return may comprise a callback to business process managed by API layer .

Cache layer as described above with respect to cache layer may cache a to be stored business object transmit a request to store the business object transmit a request to retrieve the business object and or store a number of recently used objects to provide quick access thereto. In some embodiments cache layer also indicates whether a business object includes methods for serializing and deserializing itself. Cache layer may also indicate whether the business object includes methods for providing its own synchronization information to synchronization service .

Default persistence manager may comprise a hash table for tracking all or a subset of business objects of business processes and or stored in database . Each object in the database cache is associated with a reference via persistent reference implementation and with a cache handle object via element . The cache handle object holds soft references to persistent reference implementation and to persistent object . These soft references can be dropped by a garbage collector to conserve memory.

The cache handle object is registered with a reference queue associated with persistence manager . Persistence manager drops cache handles from its hash when associated objects have been dropped. If an application holds a strong reference to an object then the garbage collector cannot remove the object and reference. If an application holds a strong reference to a persistent reference implementation i.e. OID of an object then the object may be garbage collected because it can be reloaded from persistence. The foregoing may also hold for persistent objects reachable from other persistent objects since Java references are re written with PersistentReference internally. Thus even if an application strongly references persistent object A while A strongly references persistent object B B can be removed from cache since the strong reference from A to B is re written as a strong reference to PersistentReference of B and thus B itself is held only via soft reference.

All not yet flushed modified objects are additionally strongly referenced from persistence manager in order to hold the objects in memory. In order to allow the user to store PersistentReference instances across persistence managers persistence manager will clone the reference for internal purposes in getObjectById if needed e.g. if the reference points to another persistence manager . If the reference is not associated with a cache handle object then it will become a new synchronized cache handle object. Persistence manager may also clear all cache handle objects and references on commit rollback so the reference may be reused after commit rollback to dereference objects.

Returning to architecture several other elements are present that were not previously described with respect to architecture . These elements include transaction manager and undo manager . Transaction manager and undo manager are in communication with cache layer to facilitate persistence management.

More specifically transaction manager may manage the object storage and retrieval transactions described above. Such management may include changes made to a business object by a first transaction are visible to a second transaction only after the changes have been committed. To avoid conflict transaction manager may also prevent a transaction from changing a business object once the business object is changed by a concurrent transaction. Transaction manager may also restore a prior version of a business object based on an undo file.

Transaction manager may provide undo files to undo manager when new data is committed to database . Undo manager therefore manages the undo files which may include purging the undo files according to an established protocol.

Converter Free Block Manager may provide layer with logical to physical page ID mapping fixed and floating logical page allocation savepoint support and management of physical page state and state transitions. In addition page data cache may cache the physical pages read and write the physical pages and provide temporary pages for scratch space . The page data is stored in data file .

Log writer may comprise a write ahead log writer which layer uses to store a log of each changing operation in log file prior to executing the operation. In some embodiments log writer and log file provide support for savepoints by storing dirty pages and special log records for a savepoint and by indexing the savepoint in a restart record. Accordingly on a restore the indexed savepoint may be read and restored based on its associated log records. Database of architecture may comprise log file and data file according to some embodiments.

Source code including source code classes is generated at . The source code classes may comprise source code of Java classes and a portion of a business process to be executed by a mobile device. One or more of the source code classes may comprise a business object as described above. In this regard one or more of the source code classes may define data to be associated with an instantiation thereof.

The source code may comprise any code that may be compiled for execution in any execution environment. The source code may be generated by any platform in which source code may be developed. The code may comprise ASCII characters formatted according to the Java programming language but embodiments are not limited thereto.

Next at a first plurality of the source code classes is marked as persistable. In some embodiments such a marking indicates that the first plurality of classes are to include one or more methods to serialize and deserialize itself. Persistence related methods will be described in more detail below.

A second plurality of source code classes is marked as sync capable at . This marking may indicate that each of the second plurality of classes is to include one or more methods to provide its own synchronization information to a synchronization service. The second plurality of source code classes may or may not be mutually exclusive with the first plurality of source code classes. That is a single source code class may be marked as persistable at and sync capable at . According to some embodiments the sync capable marking effectively marks a class as sync capable and persistable. The sync capable marking therefore indicates that the class is to include one or more methods to serialize and deserialize itself as well as one or more methods to provide its own synchronization information to a synchronization service.

Source code class of is marked according to some embodiments of . As shown class implements the empty interface SyncCapable . Any suitable type of marker may be employed for each of the second plurality of the source code classes at .

The generated source code classes including the first plurality of classes the second plurality of classes and perhaps other classes is compiled at . Compiling proceeds with respect to the environment in which the compiled code is to be executed. In other words the compiler used at is intended to produce code that may be executed in the intended execution environment.

After compilation at a byte code is determined for each compiled class at . The byte code for a class indicates whether the class was marked at and or . A class rebuilder may be executed at to determine the respective byte codes. Such a class enhancer may also execute through as described below according to some embodiments.

Next at it is determined whether one of the compiled classes was marked as persistable. This determination may be based on a byte code associated with the compiled class. If the byte code indicates that the class was marked as persistable persistence related methods are added to the class at . The persistence related methods may be accessed only by direct object storage access layer in some embodiments. According to some embodiments the persistence related methods include 

Flow proceeds to after or if the determination at is negative. It is determined at whether the subject compiled class was marked as sync capable at . Again this determination may be based on a byte code associated with the compiled class. Synchronization related methods are added to the class at if it is determined that the class was marked as sync capable. The synchronization related methods may comprise one or more methods that provide information associated with changes to an instantiation of the class.

Flow proceeds to after or a negative determination at . If other compiled classes have not yet been evaluated at and flow returns to and proceeds as described above for a second compiled class. Flow therefore cycles from through until each compiled class includes one of both of or neither of the persistence related methods and the synchronization related methods. Process thereafter terminates.

The class enhancement of process may occur at any suitable time. For example process may be executed at compilation time deployment time and or at class loading time runtime . Embodiments of course are not limited thereto.

The embodiments described herein are solely for the purpose of illustration. Those skilled in the art will recognize other embodiments may be practiced with modifications and alterations limited only by the claims.

