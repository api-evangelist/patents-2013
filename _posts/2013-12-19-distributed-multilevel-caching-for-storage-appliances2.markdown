---

title: Distributed multi-level caching for storage appliances
abstract: A distributed multi-layer cache in a distributed storage system is described, where the storage controller functions of the distributed storage system are separated from that of distributed storage system storage media. In an exemplary embodiment, a storage controller server determines if an object is in a cache that stores a plurality of objects. In addition, the distributed storage system includes the cache and a distributed object layer for persistently storing the plurality of objects. The cache further includes a de-duplicated cache layer. The storage controller server accesses the object from the cache if the object is in the cache and accesses the object from the distributed object layer if the object is not in the cache.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09582421&OS=09582421&RS=09582421
owner: Springpath, Inc.
number: 09582421
owner_city: Sunnyvale
owner_country: US
publication_date: 20131219
---
Applicant claims the benefit of priority of prior provisional application Ser. No. 61 739 685 filed Dec. 19 2012 the entirety of which is incorporated by reference.

This invention relates generally to a storage system and more particularly to a distributed multi layer caching in a distributed storage system.

Enterprise storage systems currently available are proprietary storage appliances that integrate the storage controller functions and the storage media into the same physical unit. This centralized model makes it harder to independently scale the storage systems capacity performance and cost. Users can get tied to one expensive appliance without the flexibility of adapting it to different application requirements that may change over time. For small and medium scale enterprise this may require huge upfront capital cost. For larger enterprise datacenters new storage appliances are added as the storage capacity and performance requirements increase. These operate in silos and impose significant management overheads.

Traditionally storage systems implemented a single level in memory like DRAM cache indexed by the logical offset of the stored content. The advent of flash based devices like SSD which provides fast random performance at a lower price than DRAM made them a good candidate for multi tier caching. However most solutions tend to extend the in memory caching methods to the flash based caches which doesn t bode very well with the later. This is because most flash based devices have poor random write performance and tend to wear out after a certain number of writes. Finally even though there exists some solutions to distributed caching they suffer from caching duplicative contents or require complex cache coherency solutions to ensure consistency across difference cache instances. All of the above reduce the effectiveness cost and performance of the distributed multi tier cache.

A distributed multi layer cache in a distributed storage system is described where the storage controller functions of the distributed storage system are separated from that of distributed storage system storage media. In an exemplary embodiment a storage controller server determines if an object is in a cache that stores a plurality of objects. In addition the distributed storage system includes the cache and a distributed object layer for persistently storing the plurality of objects. The cache further includes a de duplicated cache layer. The storage controller server accesses the object from the cache if the object is in the cache and accesses the object from the distributed object layer if the object is not in the cache.

A distributed multi layer cache in a distributed storage system is described where the storage controller functions of the distributed storage system are separated from that of distributed storage system storage media. In the following description numerous specific details are set forth to provide thorough explanation of embodiments of the present invention. It will be apparent however to one skilled in the art that embodiments of the present invention may be practiced without these specific details. In other instances well known components structures and techniques have not been shown in detail in order not to obscure the understanding of this description.

Reference in the specification to one embodiment or an embodiment means that a particular feature structure or characteristic described in connection with the embodiment can be included in at least one embodiment of the invention. The appearances of the phrase in one embodiment in various places in the specification do not necessarily all refer to the same embodiment.

In the following description and claims the terms coupled and connected along with their derivatives may be used. It should be understood that these terms are not intended as synonyms for each other. Coupled is used to indicate that two or more elements which may or may not be in direct physical or electrical contact with each other co operate or interact with each other. Connected is used to indicate the establishment of communication between two or more elements that are coupled with each other.

The processes depicted in the figures that follow are performed by processing logic that comprises hardware e.g. circuitry dedicated logic etc. software such as is run on a general purpose computer system or a dedicated machine or a combination of both. Although the processes are described below in terms of some sequential operations it should be appreciated that some of the operations described may be performed in different order. Moreover some operations may be performed in parallel rather than sequentially.

The terms server client and device are intended to refer generally to data processing systems rather than specifically to a particular form factor for the server client and or device.

A distributed multi layer cache in a distributed storage system is described where the storage controller functions of the distributed storage system are separated from that of distributed storage system storage media. In one embodiment the StorFS system includes a Deduplicated Object Cache Layer DOCL where the DOCL is a multi level de duplicated cache that provides a simple and fast access to recently added and or accessed objects. In one embodiment the DOCL uses a combination of dynamic random access memory DRAM and fast storage devices solid state drives SSD Peripheral Component Interconnect Express PCIe Flash etc. to cache both data and metadata objects. The cache is designed to have minimal overhead and harness the full capabilities of the hierarchical cache consisting of memory and SSD devices. The DOCL uses a set of techniques to index the objects for fast lookup track their hotness read write objects from to SSDs efficiently and without deteriorating their life significantly.

In one embodiment the DOCL includes one or more caching layers to cache both data and metadata. In this embodiment the DOCL is a multi layer cache that includes DRAM and fast storage devices SSD PCIe Flash a small overhead for cache metadata where metadata is in the cache with high probability if the associated data is in the cache and does not require garbage cleaning overhead for the fast storage devices. In addition the DOCL includes these functionalities providing a hierarchical de duped cache where each level of the caches has different characteristics in terms of performance power and endurance providing a simple key value interface for the consumer of the cache efficient cache lookup promotion and demotion of hot and cold objects from different level of caches DRAM cache replacement logic mutable logical L0 cache fast storage device specific L2 cache replacement logic with no garbage cleaning required reference counting to prevent eviction of cached objects and support for variable sized objects.

At a high level and in one embodiment the DOCL provides an object based abstraction with a key value interface. The DOCL provides the caching functionality for the Distributed Object Storage layer of the StorFS system. In this embodiment higher level applications and or the file systems may use DOCL to accelerate their read write performance. On a cache miss the request for an object will be redirected to the underlying Distributed Object Layer.

In the StorFS system the stored files are stripped across multiple caching vNodes. In this embodiment file I O requests are directed to the appropriate DOCL cache in the distributed system of cluster nodes thereby presenting a view of a globally unified cache. In one embodiment a single file can leverage DOCL caches from multiple StorFS nodes.

The cache can operate as a single level DRAM only cache or as a two level DRAM fast storage device cache. In one embodiment the in memory cache is a layer 1 L1 cache and the fast storage device cache is a layer 2 L2 cache. In addition to L1 and L2 caches in one embodiment DOCL can also include a mutable layer 0 L0 cache that is indexed by logical metadata.

In one embodiment the design of the StorFS system distributes both the data and the metadata and this system does not require storing a complete global map for locating individual data blocks in our system. The responsibility of managing metadata is offloaded to each individual storage nodes A C. In one embodiment a cluster manager CRM resides on each SC Server maintains some global metadata which is small compared to the local metadata. In one embodiment each logical file or entity is partitioned into equal sized stripe units . The location of a stripe unit is determined based on a mathematical placement function Equation 1 Virtual Node Hash Entity Stripe Unit Total Virtual Nodes Stripe Unit offset Stripe Unit Size Stripe Unit Per Stripe 1 

The Entityis an identification of a storage entity that is to be operated upon the Total Virtual Nodes is the total number of virtual nodes in the StorFS system the offset is an offset into the storage entity and the Stripe Unit Size is the size of each stripe unit in the StorFS system . The value Stripe Unit Per Stripe is described further below. In one embodiment the storage entity is data that is stored in the StorFS system . For example and in one embodiment the storage entity could be a file an object key value pair etc. In this example the Entitycan be an iNode value a file descriptor an object identifier key value identifier etc. In one embodiment an input to a storage operation is the Entityand the offset e.g. a write read query create delete etc. operations . In this embodiment the Entityis a globally unique identification.

In one embodiment the StorFS system receives the Entityand offset as input for each requested storage operation from an application A C. In this embodiment the StorFS system uses the offset to compute a stripe unit number Stripe Unit based on the stipe unit size Stripe Unit Size and the number of virtual nodes that the entity can be spread across Stripe Unit Per Stripe. Using the stripe unit number and the entity identifier Entity the StorFS system computes the virtual node identifier. As described below the StorFS system uses a hash function to compute the virtual node identifier. With the virtual node identifier the StorFS can identify which physical node the storage entity is associated with and can route the request to the corresponding SC server A C.

In one embodiment each vNode is a collection of either one or more data or metadata objects. In one embodiment the StorFS system does not store data and metadata in the same virtual node. This is because data and metadata may have different access patterns and quality of service QoS requirements. In one embodiment a vNode does not span across two devices e.g. a HDD . A single storage disk of a storage node A C may contain multiple vNodes. In one embodiment the placement function uses that a deterministic hashing function and that has good uniformity over the total number of virtual nodes. A hashing function as known in the art can be used e.g. Jenkins hash murmur hash etc. . In one embodiment the Stripe Unit Per Stripe attribute determines the number of total virtual nodes that an entity can be spread across. This enables distributing and parallelizing the workload across multiple storage nodes e.g. multiple SC servers A C . In one embodiment the StorFS system uses a two level indexing scheme that maps the logical address e.g. offset within a file or an object to a virtual block address VBA and from the VBAs to physical block address PBA . In one embodiment the VBAs are prefixed by the ID of the vNode in which they are stored. This vNode identifier ID is used by the SC client and other StorFS system components to route the I O to the correct cluster node. The physical location on the disk is determined based on the second index which is local to a physical node. In one embodiment a VBA is unique across the StorFS cluster where no two objects in the cluster will have the same VBA.

In one embodiment the cluster manager CRM maintains a database of virtual node vNode to physical node pNode mapping. In this embodiment each SC client and server caches the above mapping and computes the location of a particular data block using the above function in Equation 1 . In this embodiment the cluster manager need not be consulted for every I O. Instead the cluster manager is notified if there is any change in vNode to pNode mapping which may happen due to node disk failure load balancing etc. This allows the StorFS system to scale up and parallelize distribute the workload to many different storage nodes. In addition this provides a more deterministic routing behavior and quality of service. By distributing I Os across different storage nodes the workloads can take advantage of the caches in each of those nodes thereby providing higher combined performance. Even if the application migrates e.g. a virtual machine migrates in a virtualized environment the routing logic can fetch the data from the appropriate storage nodes. Since the placement is done at the stripe unit granularity access to data within a particular stripe unit goes to the same physical node. Access to two different stripe units may land in different physical nodes. The striping can be configured at different level e.g. file volume etc. Depending on the application settings the size of a stripe unit can range from a few megabytes to a few hundred megabytes. In one embodiment this can provide a good balance between fragmentation for sequential file access and load distribution.

In one embodiment the lookup of objects for the L1 cache is performed using an in memory hash table. In this embodiment instead of using the logical identifier or the address of the object for the hash table index the StorFS system uses a fingerprint of the object s content. As a result the L1 cache is a de duplicated object cache. In one embodiment a de duplicated object cache that stores a single instance of the object in the cache. In another embodiment this fingerprint based index also eliminates cache coherency issues and the need to perform cache invalidation. In one embodiment a hash function is used to compute the fingerprint such as a SHA 1 or other type of strong collision resistant hash function as known in the art.

In one embodiment because the DOCL is a multi layer cache the StorFS will keep track of which objects should be retained in each of the DOCL layers and which objects should be evicted form these layers. In addition an object may be promoted from one layer to another. In one embodiment the DOCL takes into account both recency and or frequency of an object to determine the objects that need to be evicted from the cache or cache layer. In one embodiment recency means how long ago or how soon was an object accessed and frequency means that the object was accessed more than once in a specified time period threshold before moving from recency to the frequency based list. Objects with an earlier time being added or accessed are less likely to be evicted from the cache than an object added to the cache a longer time ago or not having been accessed as recently. As the objects are read they are initially promoted to the recency list e.g. a Most Recently Used MRU list . If this object is accessed within a certain time period again the object is promoted to the frequency list e.g. a Most Frequently Used MFU list. . below illustrates the state machine for different L1 cache modes. In one embodiment this state machine only represents the most common transition paths. In certain scenarios cache not full metadata to data ratio is reached there may be a slight divergence.

In one embodiment an object is initially read from the SSD or the HDD and added to the L1 cache . In one embodiment the L1 cache includes a MRU list and MFU list . In this embodiment the MRU list is the most recently used list and the MFU list is the most frequently used list as described in above. In one embodiment upon access the object is added to the MRU list . If the object is not accessed again while in the MRU list the object will go stale and be evicted from the MRU list . If the object is accessed the object is moved to the MFU list . In one embodiment if the object is not accessed while in the MFU list the object can grow stale and be evicted from the MFU list . If the object is accessed the object is refreshed in the MFU list and less likely to be evicted from the L1 cache . In one embodiment the end of MRU and the MFU lists are scanned for objects that are most likely to be evicted out from the L1 cache and copied to the L2 cache if they are not present there already.

As mention above because the objects in the L1 and L2 caches are indexed by fingerprint and are de duplicated there is not a need for cache invalidation. As an object gets modified the entry corresponding to that object in the cache need to be neither invalidated nor modified. In one embodiment because the DOCL L1 and L2 caches are indexed by fingerprint there is no need to invalidate the cache. In this embodiment a modified object will have a new fingerprint because the content of the object has changed. Older version of the object will eventually become cold and be evicted out from cache.

In one embodiment cached objects in L1 are reference counted to make sure that referenced objects are not evicted out. In this embodiment reference counting means adding a reference for each instance the object is referred to in the cache. For example and in one embodiment if two users simultaneously access a cached object there will two references counted for this object. In one embodiment when a cached object is referenced the object s reference count is increased and it is temporarily removed from the MRU MFU lists. In this embodiment the object entry in the cache index is left as it is. This allows subsequent lookups to succeed. When the object s user returns the reference the reference count is decremented. Once the reference count drops to zero the object is inserted back in the appropriate list.

In one embodiment the DOCL is in essence a distributed cache without distributed coordination. In this embodiment there is a separate DOCL for each of the physical nodes in the StorFS system. In one embodiment there is a separate DOCL for each of the storage controller servers A C as described in above. Because each DOCL instance serves the I O requests that are local to its nodes there is no need for a distributed coordination of the different DOCL caches. In this embodiment the I O requests are directed to the appropriate storage nodes using a deterministic routing logic that distributes the I O load uniformly across the cluster as described above. As a result there are no cache coherency issues.

As described above the DOCL can include a L2 cache. In one embodiment the L2 cache does not use a full in memory hash table for indexing the objects in the L2 cache. This is because the size of the metadata to index the cache can be prohibitively large for indexing a large number of small sized objects. Instead in one embodiment the StorFS system uses an on disk index to perform L2 index lookup. For example and in one embodiment the size of the L1 cache can be of the order of a few gigabytes GBs . The L1 cache may be smaller or greater than a few GBs. This L1 size can be insufficient to store the entire working set of the StorFS workload. If the DOCL included just a L1 cache a cache miss may result in an access to the persistent store which is almost 1000 times slower for a persistent store access to HDD. Increasing the size of L1 cache boost performance but it also increases the cost. For cost and performance considerations the DOCL can include a L2 cache. In one embodiment the L2 cache is an SSD based cache. In this embodiment SSD have greater performance than HDDs that may be used for persistent store and are less expensive than a DRAM based cache such as the L1 cache.

In one embodiment any type of SSD can be used for the L2 cache single level cell SLC multi level cell MLC or another type of SSD . In one embodiment a MLC SSD is suitable for L2 cache for multiple reasons the MLC SSD provides fast random sequential reads fast sequential writes low power consumption large size lower cost than DRAM etc. However in this embodiment MLC SSDs also have a few nuances which make an MLC SSD based L2 cache harder to use like a regular DRAM based cache. This is because an MLC SSD can have slower random write performance and limited write erase cycles e.g. 5K for MLC SSD . In one embodiment random writes are slow because SSD blocks need to be erased before data can be written on to them. In this embodiment the DOCL L2 cache algorithm is designed to harness the random read performance of SSD while trying to minimize the number of write erase cycles.

In one embodiment the L2 cache includes a segment least recently used LRU list that keeps track of the hotness of the segments and a segment identifier based L2 hash table . In one embodiment a hotness of a segment measures how recently a segment was added or accessed by the StorFS system. In this embodiment a segment that has not been recently added or accessed can be a candidate for eviction from the L2 cache. In one embodiment a segment that has not been recently added or accessed can be considered cold or stale and that is one that can be evicted from the L2 cache. The LRU list further includes an LRU list for data segments and metadata segments . In one embodiment the data segments are segments to store data in the cache and metadata segments are segments to store data about these stored objects. In one embodiment the segment identifier based L2 hash table that is used to index the segments. In one embodiment eviction from and updates to the L2 cache is at the segment granularity. In another embodiment the L2 cache is a de duplicated cache.

As discussed above it can be expensive to index a large SSD cache at the object granularity. For example and in one embodiment the total memory required to store cache metadata at 4K object granularity for a 256 GB L2 cache is 8 GBs. To address this issue the StorFS system manages the L2 cache at the segment level instead of at the object level. In this embodiment the granularity of allocation and eviction for L2 cache is a full segment. For a 1 MB segment the total L2 cache metadata in the memory is now reduced to 25 MB. In one embodiment the segment is the logical unit of storage allocation by the underlying StorFS s Log based Block Management Layer. In one embodiment segments are typically 1 MB in size and are multiple of erase cycle blocks . This means that once a segment is allocated probably after performing an erase there are no more erases required until the segment is fully written with the objects contents. In alternate embodiments the segments can be larger or smaller in size.

In one embodiment the StorFS system uses the L2 cache in tandem with the L1 cache for a multi layer DOCL. In one embodiment the L2 cache works as follows On L1 cache miss the object is looked in the L2 cache. If there is a hit the object is read and promoted to the MFU list in the L1 cache. If there is a miss the object is read from StorFS persistent store and promoted to the MRU list in the L1 cache. In one embodiment there is no eviction path from L1 to L2. Instead an L1 scanner asynchronously scans the MFU and MRU lists and copy the objects from the end of those lists to the L2 cache. If the object exists in the L2 cache the object is not added to the L2 cache.

In one embodiment writes to the L2 cache are batched and performed asynchronously using a KV Put interface. On successful object write the KV Put returns the segment ID and a key locator cookie. In one embodiment the segment LRU list keeps track of the hotness of the segments. The segment ID returned by the KV Put is inserted in the head of the LRU list if it is not already there . If the object that was copied from L1 to L2 still exists in the L1 cache the corresponding segment ID and key cookie locator is inserted into its header. In one embodiment the combination of the segment ID and key locator cookie provides a faster way to read the objects from L2 cache compared to the key e.g. the fingerprint as there is no on SSD L2 index lookup involved.

In one embodiment and in a steady state the L2 cache will be full. In this state a new segment write will have to first evict e.g. clean an existing segment so there is room for the new segment. In one embodiment the segment to evict is the one in the tail of the corresponding LRU list depending whether the segment is a data segment or a metadata segment. As described above and in one embodiment the L1 scanner writes those objects to the L2 cache that are not presently in L2 cache. For objects that were candidate for L2 writes but already exist in L2 cache the corresponding segment ID is brought to the head of the LRU list. This prevents duplicate writes to the SSD as well make sure that those segments do not get evicted from L2. As the unit of L2 eviction is segment and not individual objects there is no need to perform L2 SSD cleaning and copying of live objects. The index entries associated with the objects in the segments being evicted still need to be removed but that process incurs much less overhead.

In one embodiment the fingerprint of an object may not be known a priori. If the fingerprint is not known the system may have to perform multiple metadata object accesses to determine the fingerprint of that data object. In this embodiment any metadata access to access a data object is essentially an overhead. Minimizing the metadata access overhead can significantly increases the system performance. For that reason in one embodiment the StorFS system employs another caching layer in its cache hierarchy. is a block diagram of one embodiment of a DOCL layer 0 L0 cache . In this embodiment the DOCL L0 cache is a mutable logical index cache that maintains a mapping of logical metadata to its fingerprint. The L0 cache maintains two types of logical metadata an inode cache that maintains a mapping of an inode number to the corresponding inode fingerprint and a data index cache that maintains a mapping of the logical file offset to its corresponding data object s fingerprint. In this embodiment for every data object access or inode access the StorFS system first looks up in its L0 cache using a logical file offset based L0 hash table . If there is a matching entry the StorFS system uses the fingerprint from the entry to access the corresponding data or inode object. If the entry is not there the StorFS system traverses the entire chain of metadata starting from the superblock of the inode to access the desired object. In one embodiment eviction from and updates to the L0 cache is at the object granularity.

As the files contents are modified their corresponding logical entries in the DOCL L0 cache also needs to updated to reflect the current logical metadata to fingerprint mapping.

As described above and in one embodiment the DOCL is a multi layer cache that is used by the StorFS system to provide quick access to objects in the cache. In one embodiment the StorFS system first attempts to access an object in the cache. If the object is not in the cache the StorFS system accesses the object from the Distributed Object Layer. is a flow diagram of one embodiment of a process to access an object using the DOCL. In one embodiment DOCL performs process to access an object. In process begins by receiving an operation to access the object at block . In one embodiment the access operation is a read operation. In another embodiment the access operation can be a write operation where in the object is first persisted in the persistent storage and then inserted in to the L1 cache.

At block process looks up the DOCL L0 cache using the logical address that is inputted with the access operation. Process determines if there is a L0 Cache hit at block . In one embodiment a cache hit in the L0 cache means that object referenced by the access operation is stored in the L1 cache. If there is a cache hit process moves the logical address entry of the object to the head of the L0 list. In one embodiment by moving the logical address entry of the object to the head of the L0 list the object will not grow stale as quickly and will not be evicted as quickly. Execution proceeds to block below.

If there is not a L0 cache hit at block process traverses of the metadata graph starting from the superblock of the cache vNode to which the file stripe belongs and fetches the VBA of the object. At block process looks up the DOCL L1 cache using the fingerprint in the VBA of the object. In one embodiment the fingerprint of the object is a hash of the object contents. Process determines if there is a L1 cache hit for this object. If there is an L1 cache hit process moves the object to the head of the MFU list which indicates that this object has been recently accessed. In addition process moves the contents in the MFU list if necessary to create space for this object. Execution proceeds to block below.

If there is not an L1 cache hit process looks up the DOCL L2 cache using the fingerprint in the VBA of the object at block . At block process determines if there is an L2 cache hit. If there is an L2 cache hit process reads object from the L2 cache and moves the object s segment to the head of the L2 segment list. Execution proceeds to block above. If there is not an L2 cache hit process reads the object from the distributed object layer using the VBA as the key at block . In one embodiment the distributed object layer is the distributed object layer as described in above. At block process determines if the read was successful. If the read was not successful process returns an error to the client at block . If the read was successful process promotes the object to the head of the MRU list in the L1 cache at block . In addition process evicts the content in the MRU list if necessary to create space for this object. At block process returns the object to the client.

As shown in the computer system which is a form of a data processing system includes a bus which is coupled to a microprocessor s and a ROM Read Only Memory and volatile RAM and a non volatile memory . The microprocessor may retrieve the instructions from the memories and execute the instructions to perform operations described above. The bus interconnects these various components together and also interconnects these components and to a display controller and display device and to peripheral devices such as input output I O devices which may be mice keyboards modems network interfaces printers and other devices which are well known in the art. Typically the input output devices are coupled to the system through input output controllers . The volatile RAM Random Access Memory is typically implemented as dynamic RAM DRAM which requires power continually in order to refresh or maintain the data in the memory.

The mass storage is typically a magnetic hard drive or a magnetic optical drive or an optical drive or a DVD RAM or a flash memory or other types of memory systems which maintain data e.g. large amounts of data even after power is removed from the system. Typically the mass storage will also be a random access memory although this is not required. While shows that the mass storage is a local device coupled directly to the rest of the components in the data processing system it will be appreciated that the present invention may utilize a non volatile memory which is remote from the system such as a network storage device which is coupled to the data processing system through a network interface such as a modem an Ethernet interface or a wireless network. The bus may include one or more buses connected to each other through various bridges controllers and or adapters as is well known in the art.

Portions of what was described above may be implemented with logic circuitry such as a dedicated logic circuit or with a microcontroller or other form of processing core that executes program code instructions. Thus processes taught by the discussion above may be performed with program code such as machine executable instructions that cause a machine that executes these instructions to perform certain functions. In this context a machine may be a machine that converts intermediate form or abstract instructions into processor specific instructions e.g. an abstract execution environment such as a process virtual machine e.g. a Java Virtual Machine an interpreter a Common Language Runtime a high level language virtual machine etc. and or electronic circuitry disposed on a semiconductor chip e.g. logic circuitry implemented with transistors designed to execute instructions such as a general purpose processor and or a special purpose processor. Processes taught by the discussion above may also be performed by in the alternative to a machine or in combination with a machine electronic circuitry designed to perform the processes or a portion thereof without the execution of program code.

The present invention also relates to an apparatus for performing the operations described herein. This apparatus may be specially constructed for the required purpose or it may comprise a general purpose computer selectively activated or reconfigured by a computer program stored in the computer. Such a computer program may be stored in a computer readable storage medium such as but is not limited to any type of disk including floppy disks optical disks CD ROMs and magnetic optical disks read only memories ROMs RAMs EPROMs EEPROMs magnetic or optical cards or any type of media suitable for storing electronic instructions and each coupled to a computer system bus.

A machine readable medium includes any mechanism for storing or transmitting information in a form readable by a machine e.g. a computer . For example a machine readable medium includes read only memory ROM random access memory RAM magnetic disk storage media optical storage media flash memory devices etc.

An article of manufacture may be used to store program code. An article of manufacture that stores program code may be embodied as but is not limited to one or more memories e.g. one or more flash memories random access memories static dynamic or other optical disks CD ROMs DVD ROMs EPROMs EEPROMs magnetic or optical cards or other type of machine readable media suitable for storing electronic instructions. Program code may also be downloaded from a remote computer e.g. a server to a requesting computer e.g. a client by way of data signals embodied in a propagation medium e.g. via a communication link e.g. a network connection .

The preceding detailed descriptions are presented in terms of algorithms and symbolic representations of operations on data bits within a computer memory. These algorithmic descriptions and representations are the tools used by those skilled in the data processing arts to most effectively convey the substance of their work to others skilled in the art. An algorithm is here and generally conceived to be a self consistent sequence of operations leading to a desired result. The operations are those requiring physical manipulations of physical quantities. Usually though not necessarily these quantities take the form of electrical or magnetic signals capable of being stored transferred combined compared and otherwise manipulated. It has proven convenient at times principally for reasons of common usage to refer to these signals as bits values elements symbols characters terms numbers or the like.

It should be kept in mind however that all of these and similar terms are to be associated with the appropriate physical quantities and are merely convenient labels applied to these quantities. Unless specifically stated otherwise as apparent from the above discussion it is appreciated that throughout the description discussions utilizing terms such as receiving determining accessing computing evicting performing generating communicating reading writing transferring updating scanning compacting or the like refer to the action and processes of a computer system or similar electronic computing device that manipulates and transforms data represented as physical electronic quantities within the computer system s registers and memories into other data similarly represented as physical quantities within the computer system memories or registers or other such information storage transmission or display devices.

The processes and displays presented herein are not inherently related to any particular computer or other apparatus. Various general purpose systems may be used with programs in accordance with the teachings herein or it may prove convenient to construct a more specialized apparatus to perform the operations described. The required structure for a variety of these systems will be evident from the description below. In addition the present invention is not described with reference to any particular programming language. It will be appreciated that a variety of programming languages may be used to implement the teachings of the invention as described herein.

The foregoing discussion merely describes some exemplary embodiments of the present invention. One skilled in the art will readily recognize from such discussion the accompanying drawings and the claims that various modifications can be made without departing from the spirit and scope of the invention.

