---

title: Dynamic application programming interface
abstract: Systems, methods, and machine-readable media are described for retrieving data associated with files using input data files. Embodiments include generating input data files, which can be transformed to create data objects from input data of the input data files. The input data and the corresponding data objects can include information regarding files, such as the universal resource indicator (URI) of a file. The data objects can then be stored.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09065796&OS=09065796&RS=09065796
owner: Brightcove, Inc.
number: 09065796
owner_city: Boston
owner_country: US
publication_date: 20130619
---
This application claims priority to and is a continuation of U.S. patent application Ser. No. 12 888 089 filed Sep. 22 2010 entitled DYNAMIC APPLICATION PROGRAMMING INTERFACE which is incorporated by reference herein for all purposes.

This disclosure relates in general to cloud based computer processing and but not by way of limitation the communication and storage of data within cloud based computing systems and across inter cloud application boundaries.

Increased networking bandwidth and processing power of networked computers in recent years has increased the popularity for cloud based computing. Cloud based computing or Internet network based computing in which resources software and information are shared among computing systems and other networked devices has enabled the creation and enhancement of large scale services. Such services can include content delivery networks CDNs file management services and more.

Cloud based services can often require the integration of multiple applications which can be executed by multiple computing systems. These applications can have application programming interfaces APIs that can provide data objects to other applications both within a cloud and external to the cloud. However these objects typically conform to a static format. Thus a data object received by a first application requires from a second computing system will rarely be of a format readily usable by the first application. Instead the first application will have be altered to accept data objects of the type provided by the second application. Thus the integration of applications and the computing systems on which they are executed can be time consuming especially where many applications and or computing systems are involved.

Systems methods and machine readable media are described for retrieving data associated with files using input feeds. Embodiments include generating input feed schemas which can be used to create data objects from input data of the input feeds. The input data and the corresponding data objects can include information regarding files such as the universal resource indicator URI of a file. The data objects can then be stored.

According to one embodiment a system that uses input feeds to receive and process data associated with files is provided. The system can comprise a first server at a first location configured to generate a input feed schema. The input feed schema can have information for creating one or more data objects using input data. The input data can comprise a first plurality of properties and each of the one or more data objects can comprise a data structure having a universal resource indicator URI of a file and a second plurality of properties. Each property of the second plurality of properties can correspond to a property of the first plurality of properties and the properties of the first and second pluralities of properties can include a name and a value associated with a file. The first server can store the input feed schema. The system further can comprise a second server at a second location receive the input feed schema. The second server also can receive the input data from an input feed the input feed comprising an electronic file having the input data and use the input feed schema and the input data to generate at least one data object. Finally the second server can store the at least one data object.

The embodiment can be modified various ways. For instance the input feed schema can include a URI of the input feed and or one or more properties of the second plurality of properties can have a different name than the corresponding properties of the first plurality of properties. Moreover the second plurality of properties can comprise a subset of the first plurality of properties. Additionally or alternatively the second server can be configured to receive a file associated with the at least one data object transmit the file to a third server and the third server can be configured to store the file. Moreover if the file comprises a media asset the third server is further configured to transcode the media asset.

Additional modifications are contemplated. The first server for example can be further configured to provide a user interface and the user interface can be configured to receive information for generating the input feed schema. Additionally or alternatively the first server the second server or both can be further configured to do one or more of examine the input feed determine using the input feed that the input data has changed and update the data object to reflect a change in the input data.

According to another embodiment a method is provided for retrieving data associated with media assets using input feeds and generating data objects with the data. The method can comprise generating an input feed schema having information for creating one or more data objects using input data where the input data comprises a first plurality of properties. Each of the one or more data objects can comprise a data structure having a URI of a media asset and a second plurality of properties. Each property of the second plurality of properties can correspond to a property of the first plurality of properties. Moreover the properties of both the first and second pluralities of properties can include a name and a value associated with a media asset. The method further can comprise storing the input feed schema and receiving input data from an input feed where the input feed comprises an electronic file having the input data. The method also can include using the input feed schema and the input data to generate at least one data object and storing the at least one data object.

This embodiment can be adjusted in a variety of ways. Among those explicitly disclosed is including an input feed comprising one or more of extensible markup language XML really simple syndication RSS media RSS MRSS and Atom Syndication Format. Additionally or alternatively a property of the second plurality of properties can have a different name than the property of the first plurality of properties to which it corresponds. The method can further comprise receiving the media asset and or transcoding the media asset where the at least one data object includes a URI of the transcoded media asset. The method can also provide a user interface configured to receive information for generating the input feed schema. Such information can include information for corresponding a property of the second plurality of properties to a property of the first plurality of properties. Additionally or alternatively the method can include examining the input feed determining from the input feed the input data has changed and updating the at least one data object to reflect a change in the input data. In addition the method can include receiving and storing the a media asset associated with the at least one data object.

According to yet another embodiment one or more machine readable media are provided having a set of instructions stored thereon for retrieving and processing data associated with media assets using input feeds. The instructions when executed by one or more machines can cause the one or more machines to generate a input feed schema having information for creating one or more data objects using input data. The input data can comprise a first plurality of properties and each of the one or more data objects can comprise a data structure having a URI of a media asset and a second plurality of properties. Each property of the second plurality of properties can correspond to a property of the first plurality of properties. Moreover the properties of the first and second pluralities of properties can include a name and a value associated with a media asset. The instructions can further cause the one or more machines to store the input feed schema and receive the input data from an input feed where the input feed comprises an electronic file having the input data. The input feed schema and the input data can be used to generate at least one data object and the at least one data object can be stored.

This embodiment can be altered in numerous ways. For example the instructions further can cause one or more machines to receive and or transcode the media asset. Moreover a user interface configured to receive information for generating the input feed schema can be provided. Additionally or alternatively the instructions further can cause one or more machines to examine the input feed determine using the input feed that the input data has changed and update the data object to reflect a change in the input data.

In the appended figures similar components and or features may have the same reference label. Further various components of the same type may be distinguished by following the reference label by a dash and a second label that distinguishes among the similar components. If only the first reference label is used in the specification the description is applicable to any one of the similar components having the same first reference label irrespective of the second reference label.

The ensuing description provides preferred exemplary embodiment s only and is not intended to limit the scope applicability or configuration of the disclosure. Rather the ensuing description of the preferred exemplary embodiment s will provide those skilled in the art with an enabling description for implementing a preferred exemplary embodiment. It is understood that various changes may be made in the function and arrangement of elements without departing from the spirit and scope as set forth in the appended claims.

Systems methods and machine readable media can be utilized to facilitate the integration of systems executing applications providing cloud based and or web services. More specifically data objects and schemas may be used by systems such as file management systems to facilitate the management and distribution of files between various systems. Data objects can comprise information such as metadata regarding any file type. And the file itself can be stored internal or external to a system storing the corresponding data objects. Thus such a file management system can be utilized by a variety of cloud based services.

While the above embodiments may be implemented in a variety of different systems some particular embodiments may be implemented as part of a media service system. is a block diagram illustrating a media servicing system according to some embodiments of the present invention. The system may deliver media content to the end user device through a network such as the Internet . The end user device can be one of any number of devices configured to receive media over the Internet such as a mobile phone tablet computer personal computer portable media device etc. A media asset provided by a content provider can be processed and indexed by cloud hosted integrated multi node pipelining system CHIMPS and further stored on content delivery network CDN . Additionally or alternatively the CHIMPS may also be adapted to store the media asset. Although a media asset can comprise any type of media file e.g. video audio Flash etc. it will be understood as explained above that embodiments can be applied to files of any type including file types having no media content.

The media servicing system further enables a content provider or other entity to gather information regarding user behavior during media playback. For example a content provider can be provided with data indicating that end users tend to stop watching a video at a certain point in playback or that users tended to follow links associated with certain advertisements displayed during playback. With this data a content provider can adjust factors such as media content advertisement placement and content etc. to increase revenue associated with the media content and provide a user of the end user device with a more desirable playback experience.

End user device can request a media asset to stream with a client application executed by the end user device . The client application can be for example a media player browser or other application adapted to request and or play media assets. In response to a request for a media asset the CHIMPS can utilize any number of application centers and or kernel application center s to provide the client application with a data object concerning the requested media asset. The data object can include information about the media asset including where the media asset can be located such as within the CDN or within the CHIMPS itself. Location information may be provided by Universal Resource Indicator URI such as a Universal Resource Locator URL or other indicator. During playback of the media asset the CHIMPS can collect data regarding the playback through beaconing provided by a client application executed by the end user device and or indexing service from within the CHIMPS and or CDN. The CHIMPS can subsequently provide the data and or any analytics information derived from the data to the content provider .

Components within the kernel application center can communicate through network such as a local area network LAN and can include one or more origin servers and a storage array with which data objects and or media assets may be stored and distributed. The storage array may also be utilized by services running on processing server s and or transcoding server s that may require temporary or long term storage. Kernel server can utilize processing server s transcoding server s to provide various functional capabilities to the CHIMPS .

For example as described in more detail below the CHIMPS can provide transcoding service for media assets provided by a content provider for syndication. Such a service can allow a content provider to upload a media asset to an application center after which the application center would notify the kernel server that the media asset has been uploaded. The kernel server can then notify services running on the processing server s of the upload. These services can utilize transcoding server s to transcode the media asset which can then be moved to a CDN and or stored locally by storage array and origin server s . Services running on the processing server s can also update the associated data object stored by the storage array and origin server s .

Media can be ingested into the CHIMPS when a content provider uploads a media asset to ingestion server s in an application center by utilizing a client . The client can be a stand alone application or browser based for example and can communicate with ingest server s through an application programming interface API configured for the ingestion of media assets.

Ingest server s can communicate with devices in the kernel application center executing programs such as kernel server and file replication service . The kernel server can be configured organize the workflow among services such as transcoding file system manager and other services e.g. analytics dynamic API etc. Upon a particular event for example the kernel server can be configured to notify the relevant services of the event causing the services to process tasks associated with the event.

The file replication service under direction of the kernel server can coordinate the movement of the media assets between services. For example retrieving the uploaded media asset from the ingest server s and storing it on the file archive or retrieving transcoded media assets from transcoding server s and storing them in the media asset origin.

The data object updater keeps the data object origin up to date in response to any changes in the system. When for example a file is uploaded transcoded and stored in media asset origin the location and other metadata concerning the transcoded media assets need to be created or updated in the data object origin to ensure an end user device that accesses the object in the data object origin has the correct information regarding the related media asset. Because the data object updater receives updates from the kernel server which is notified when a transcoded media asset is stored in the media asset origin the system ensures the data objects in the data object origin are constantly up to date.

The upload of a media asset to the ingest server s as described above can provide an example of how the kernel server may coordinate workflow. For instance in response to the upload the ingest server s can notify the kernel server that a media asset has been uploaded. The kernel server informs the file replication service of the uploaded media asset and the file replication service moves the uploaded media asset into the file archive and notifies the kernel server of the move. In response the kernel server notifies the file replication service the file system manager and the transcoding master of the move. The file replication service then will know it can delete the uploaded media asset from the ingest server s the file system manager will update the file system accordingly and the transcoding master will notify transcoding service s of different transcoding tasks to be performed. The transcoding service s can then retrieve the uploaded media asset from the file archive to create transcoded media assets. The transcoding service s notify the kernel server once transcoding is complete and the kernel server relays this information to the file replication service . The file replication service then takes the transcoded media assets from the transcoding services and moves them to the media asset origin . Once the file replication service notifies the kernel server of the move the kernel server in turn notifies the file replication service and the data object updater . The data object updater which updates the data object origin accordingly and the file replication service deletes the transcoded media assets from the transcoding services .

The modular nature of the system enables all tasks associated with an event to be completed quickly. As illustrated in the example above workflow relating to a particular event such as a media asset upload can be spread among the various services simultaneously. Moreover because the system s modularity enables it to be scaled to accommodate differing hardware capacities and because the system can be configured to dynamically allocate hardware to different services according to the needs of the system the speed of completing tasks relating to a particular event can further be increased. For example a server of the CHIMPS can be configured to dynamically switch its purpose based on external conditions such as load and overall system performance providing functions such as transcode upload metrics collection application web service and more on an as needed basis.

Embodiments of such systems may include other systems that manage various requests from end users. One such system may be a cloud data persistence system. Such a system is described in detail in Australian patent application no. 2010202782 entitled Cloud Data Persistence Engine which is incorporated herein by reference in its entirety. Referring to a simplified block diagram of an embodiment of a cloud data persistence system is illustrated. Such a system may allow for information such as data objects to be efficiently distributed to multiple of clients. Similar to the systems discussed above although the ensuing description will concentrate on data objects linked to media assets the systems and methods described herein also can utilize data objects corresponding to files of any type. Thus the systems and methods described herein can be applied to cloud based applications beyond media such as social networking or gaming.

Some embodiments of cloud data persistence systems are used to distribute data objects that are linked to media assets and or other file types . A data object may contain information pertinent to the media asset it is linked to. For example a data object may include details about a media asset and permissions for the media asset. More specifically a data object may include fields containing a title keywords linked to the data object the data object s and or associated media asset s date of creation the duration of the associated media asset the file formats the associated media asset is available in and what clients are permitted to access and or edit the data object and or the media asset. The data object may also contain a link to its associated media asset. Such a link may be in the form of a universal resource indicator such as a universal resource locator. Other information may also be stored as a data object that is linked to a media asset. A media asset may represent many different forms of media such as an audio file in a variety of different formats a video file or a flash file to name only a few examples.

Important to note data objects may be stored separate from media assets. For example a data object containing information linked to a particular media asset may not be stored in the same location as the media asset. For example a media asset may reside on multiple servers that are part of a content delivery network while the data object that contains information about the media asset is stored in some other location possibly on some other network. Also while the above discusses linked media assets it should be understood that data objects may also be linked to other assets files or data that do not constitute media. In such embodiments the data objects may contain different fields of data.

Such a cloud data persistence system may be used to distribute data objects to one or several clients but also may be used to distribute data objects to thousands of clients geographically disbursed worldwide. In the embodiment of cloud data persistence system three levels of servers are present a data object origin server data persistence cache servers and application centers . These application centers are in contact with one or more clients . It should be understood that each application center may include one or more servers. For example an application center may be represented by application center of . Alternatively an application center may comprise a single server. While three levels of servers are present in the illustrated embodiment it should be understood that greater or fewer levels of servers may be present in other embodiments. Also various servers may be integrated into the same server. For example one server may serve as both an application center and a data persistence cache server . It should also be understood that the terms of application center data persistence cache server and data object origin server are used to simplify the nomenclature used to describe the various levels of the cloud data persistence system and these terms should not be interpreted as limiting the functionality of their respective identified servers.

Referring to cloud data persistence system clients make requests for data objects from application centers via one or more networks. In the illustrated embodiment only two clients and are present to maintain simplicity many more clients possibly representing many end users may be possible. These clients may communicate with the same application center or may communicate with different application centers and . Further because a client at one time interacts with a particular application center at a different time the same client may interact with a different application center. For example if a particular application center is experiencing a heavy client load possibly caused by a large number of clients attempting to access it a client may be routed to another application center.

The client may make a request for a particular data object to the application center. This request may be made via a network such as the Internet. Other networks may also be possible such as a private intranet. The request for the data object may involve the client sending a universal resource indicator URI to an application center. A URI may take a variety of different formats. In particular the URI may be in the form of a universal resource locator URL . However it should be understood that other forms of URIs may also be possible.

If client transmits a URI to application center application center may have the data object linked to the URI stored locally. If this is the case application center may respond by sending the data object identified by the URI back to client . However application center may have only a subset of the data objects linked to valid URIs stored locally. This may be due to space constraints at application center . For example if clients infrequently request particular data objects it may be inefficient to distribute those data objects to each of application centers .

If the data object requested by client is not present at application center application center may contact another server to retrieve it. Application center may be located in close proximity to data persistence cache server or may be geographically separated from data persistence cache server . Application center may communicate with data persistence cache server directly such as a direct cable connection or may communicate using a network. This network may be a private network such as a local area network or dedicated connection between the servers or may use a public network such as the Internet. Such a request from application center to data persistence cache server may include the URI received by application center from client . In some embodiments data persistence cache servers supply multiple application centers with requested data objects. In cloud data persistence system data persistence cache server serves two application centers and while data persistence cache server serves two different application centers and . It should be understood that a data persistence cache may serve a varying number of application centers. For example a data persistence cache may serve 20 application centers.

It should also be recognized that the connections between application centers and data persistence cache servers are dynamic. If a particular data persistence cache is offline busy or otherwise unavailable an application center may be able to route requests to a different data persistence cache server. For example referring to cloud data persistence system if data persistence cache became unavailable application center may be able to route a request for the data object to data persistence cache server .

While if application centers and data persistence caches communicate via a network e.g. the Internet the servers may be located anywhere a network connection is available worldwide. In some embodiments a data persistence cache is located near a group of application centers. For example if a region such as New England contains two application centers for each state a single data persistence cache may be located in or near New England to serve these twelve scattered application centers. Having the data persistence cache located near a group of application centers may decrease communication latency when an application center and the data persistence cache communicate.

Upon receiving a request for a data object from application center data persistence cache server may determine if it has the data object stored. If it does data persistence cache server may send the data object to application center which may in turn send the data object to client . Upon the application center receiving the data object it may store the data object to be able to satisfy requests from the same or a different client for the same data object at a future time. Application center may make a determination as to whether the data object should be stored or not. For example the determination may be based on the frequency it is receiving requests for the data object from clients . If the data object is frequently being requested by clients application center may store the data object. This may only occur if the data object is being requested more frequently than some other data objects. For example only the 10 000 most frequently requested data objects may be stored by the application center. In some embodiments application center may store the most recently requested data objects. Therefore this data object would be stored at application center and possibly some other data object would no longer be stored at application center . In some embodiments different application centers use different mechanisms to determine what data objects to store. Also in some embodiments some data objects are always stored at application centers . This may occur if a particular data object has been labeled a high priority or some equivalent thereof .

However if data persistence cache server determines that it does not have the data object requested by client stored data persistence cache server may contact another server. Data persistence cache server may contact another server called a data object origin server . Data object origin server may supply data persistence cache servers with various data objects. In cloud data persistence system data object origin server is shown as communicating with two data persistence cache servers . However it should be understood that data object origin server may communicate with one three or some other number of data persistence cache servers. For example data object origin server may communicate with more such as 20 data persistence cache servers.

Data object origin server may be physically located with one or more data persistence cache servers. Data object origin server may communicate directly such as via a direct connection with data persistence cache servers. For example in cloud data persistence system data object origin server communicates directly with the data persistence cache server . Data object origin server may also communicate via any of the previously mentioned networks with a data persistence cache server. Again referring to cloud data persistence system data object origin server communicates with data persistence cache server via a network possibly the Internet.

While application centers and data persistence cache servers may store only a subset of the various data objects that clients may request data object origin server may store all data objects that exist on system . In other words if a data object requested by a client is not present on data object origin server the data object may not exist on system .

Just as a data persistence cache server may be physically located near a group of application centers data object origin server may be located near the group of data persistence cache servers . Returning to the previous regional example if a data persistence cache server is located in New England another may be located near New York City another near Washington D.C. and perhaps yet another near Chicago. If one data object origin server is servicing these data persistence cache servers it may be located in a central location to serve them all. In some embodiments the data object origin server may be co located with one or more data persistence cache servers. Alternatively a data object origin server may be located at a separate physical location from any other database servers.

A request from the data persistence cache server to data object origin server may comprise a URI. This may be the same URI that was sent from client to application center then from application center to data persistence cache server . In some embodiments the URI transmitted from data persistence cache may be in a different format than the other URIs. Upon receiving the URI data object origin server may locate the data object the URI is linked to. The data object origin may then transmit the data object to data persistence cache server . The data persistence cache server may make determination as to whether to store the data objects as previously described in relation to application center . For example the determination of whether to store the data object may be based on the frequency with which application centers request the data object from data persistence cache server . In some embodiments data persistence cache server stores the most recently requested data objects. Data persistence cache server may then transmit the data object to application center . Application center may then transmit the data object to client .

If the data object was first found at application center the latency between client s request and client receiving the data object may be the shortest. If instead the data object is first found at data persistence cache server the latency may be longer. Finally if the data object is only found at data object origin the latency may be the longest. Regardless of where the data object is found client may be unaware of whether application center a data persistence cache server or the data object origin server had the data object stored.

While only one data object origin server is present in cloud data persistence system more than one data object origin server is possible. For example a data object origin server may serve a particular region such as a country. Other data object origin servers may be present in other countries. These data object origin servers may each maintain identical or substantially similar data sets. Therefore a data object found on one data object origin server would also be found on other data object origin servers. While not illustrated in it should be understood that data object origin server may be in communication with a kernel server and or a data object updater server such as illustrated in B and . Such an arrangement may allow multiple different data object origin servers to have the same data objects stored.

While the above deals with the communication flow in cloud data persistence system when a client requests a data object a client or of course an end user acting through the client may also modify a data object. Depending on the data object a request for a particular data object may be much more frequent than a request to modify a data object. By way of example only consider a video clip posted on an online video sharing website. If the video is popular data object information such as the video owner s name and the video s title may be sent to millions of different clients. However the end user who created the video may only infrequently modify via a client data linked to the video.

In cloud data persistence system the request to modify a data object as opposed to a request to retrieve a data object may be treated differently. If client makes a request to application center to modify a data object application center assuming the end user and or client has the proper permissions to modify the data object may route the request to Kernel application center . Kernel application center may then update data object origin server and any other data object origin servers requiring updating. Application center may not modify or delete the previous version of the data object if it is stored at application center . The data object may then be updated at data object origin server . While the data object may now be updated at data object origin server other application centers and data persistence cache servers such as application center and data persistence cache may still have out of date versions of the data object. Therefore upon receiving the modifications to the data object kernel application center may notify data persistence cache servers to no longer use their current version of the data object. This may involve data persistence cache servers deleting their out of date version of the data object. In turn data persistence cache servers may notify application centers to similarly no longer use their out of date versions of the data object. This may again involve the out of date data object being deleted from application centers . Application centers and data persistence cache servers may not receive a new version of the data object along with the notification. Rather application centers and data persistence cache servers may only receive the new version of the data object if a client requests the data object and it is routed through the data persistence cache server and the application center.

If kernel application center knows what particular data objects are stored at data persistence cache servers a notification may only be sent to the data persistence cache server known to store the data object. Similarly if data persistence cache servers know what data objects are stored at application centers only those application centers that have out of date versions of the data object may be sent the notification. In some embodiments whenever a modification of a data object is received at kernel application center all data persistence cache servers are notified which in turn notify all application centers . In such embodiments therefore kernel application center does not need to be aware of what particular data objects are stored at data persistence cache servers and data persistence cache servers do not need to be aware of what data objects are stored at application centers . In some embodiments Kernel application center notifies both data persistence cache servers and application centers .

Referring to a simplified block diagram of an embodiment of a cloud data persistence system is illustrated. Such a system may be substantially similar to system . However system illustrates how various components of system may be geographically separated. It should be understood that each component of system may be located at a different physical location. In some embodiments client is at location while client is at location . Locations and may be close together possibly only several miles if both client and client are using the same application center. Clients and may be a great distance apart if they are using different application centers.

Application centers and are shown as different locations of and respectively. Application centers that use the same data persistence cache server may be closer together than application centers that do not use the same data persistence cache servers. Further as those with skill in the art will recognize while an application server may not be physically closer to a data persistence cache server due to the state of the network communication between two physically further apart servers may be quicker. In such a case the further servers may be in communication as opposed to the closer servers.

Data persistence cache server is at another location . Location may be near or in between location and . Data persistence cache server is at the same location as application center . In some embodiments data persistence cache server is at some other location from application center . Finally data object origin server may be present at location . This location may be at the kernel application center or may be separate.

The use of data objects in the CHIMPS by means such as the cloud data persistence system described above facilitates the management of media assets and or other file types to which the data objects correspond. Additionally systems utilizing data objects hereafter referred to as internal data objects or IDOs may be configured to generate various permutations of the data objects as requested by an application. These permutated objects or application data objects hereafter ADOs can be provided with an API to different applications upon request. Traditional systems may provide a static data set or a static object derived from the data set by an API. However the CHIMPS and similar systems can use the IDOs persisted through the cloud data persistence system as data sources to create ADOs of any desired form discussed in more detail below. Because the CHIMPS can create ADOs upon request there is no need to create and store different permutations of IDOs beforehand. That said some embodiments contemplate creating and storing ADOs thereby foregoing the need to create a particular ADO if it is requested more than once. By providing ADOs in this fashion the entity receiving the ADO thereby saves time and processing power it would otherwise take to convert a static data set or data received in another format to a more usable form.

Storing information regarding media assets and or other file types as IDOs can facilitate the creation and delivery of application data objects or data objects derived from the IDOs and provided to through an API to external entities. The IDOs of the CHIMPS can adhere to a base schema requiring that all IDOs include certain properties. These required properties can be for example the properties required by the CHIMPS to properly process and manage data objects which may vary depending on the desired functionality of the CHIMPS . Data objects can include properties such as methods and data fields. Data fields can include for example and not by way of limitation a unique identifier status title author profile information regarding advertisement breaks available application schemas discussed in more detail below file size date created date last modified and more.

IDOs as stored by the CHIMPS can include many properties in addition to those required by a base schema. Various internal schemas can be created to facilitate the creation and management of IDOs. These internal schemas can derive from the base schema therefore inheriting the minimal properties required by the base schema. Furthermore properties of the internal schemas may be specified by entities providing the data from which the IDOs are created such as content providers .

Using embodiment as an example a content provider can specify a data format of an external data set by which it can provide the CHIMPS data regarding one or more media assets. If the format specified can include three types of data elements for example a Title Artist and URI the CHIMPS can then create an internal schema to use for receiving the external data set and creating a corresponding IDO . The internal schema can be reused numerous times to create multiple IDOs from external data sets including the three types of data elements specified by the content provider .

The names of properties of IDOs may differ from the corresponding data elements of the external data sets . Schemas therefore can map data elements of external data sets to one or more properties of an IDO . Continuing with the example above the external data set can include a Title Artist and URI but the base schema can require that an internal object have a Name Author and Unique Identifier. In this case the content provider can indicate to the CHIMPS that the Title Artist and URI for external data set and other data sets for use with internal schema maps to a Name Author and Unique Identifier respectively. The internal schema can include such mapping data.

The ability to map data elements of external data sets to properties of corresponding IDOs provides for other types of functionality. Internal schemas can provide for mapping data elements to multiple properties . For example a data set may include a URI data element which can be mapped to properties for a URL and Unique Identifier. Moreover data elements may be reformatted altered and or combined to create properties .

Multiple internal schemas may be created enabling the CHIMPS to store IDOs having different formats. Different external entities such as different content providers may customarily store data regarding media assets and or other file types in different formats. Because the CHIMPS can create internal schemas for each entity the external entity does not need to reformat its external data such as external data set before integrating with the CHIMPS . Additionally multiple internal schemas may be used by a single external entity corresponding to multiple file types. For example a first internal schema may be used to create a first IDO from a first external data set comprising information regarding a media asset of a content provider . A second internal schema may be used to create a second IDO from a second external data set comprising information regarding a video game of the same content provider .

Internal schemas can be stored as objects themselves. The internal schema objects can be managed and persisted throughout the cloud data persistence system of the CHIMPS in a manner similar to the IDOs as described above. Moreover IDOs can include information regarding which application schemas described in further detail below may be used with the IDO to create a ADO.

According to some embodiments internal schemas and IDOs can be created without requiring changes in programming code. For example in a Microsoft .NET programming environment if a base schema is created at compile time of the programming code a corresponding object definition or assembly is created and cached in the global assembly cache GAC . Subsequent assemblies corresponding to internal schemas which derive from the base schema may be created and cached in the GAC at runtime once an internal schema is created. Additionally or alternatively IDOs may be created at runtime by directly reading binaries of the files defining the internal schemas . Thus a system running an application for creating IDOs such as a processing server of an application center can be configured to receive any internal schema and create a corresponding IDO without the need to recompile programming code.

As mentioned above additional schemas derived from the base schema may be generated to create ADOs by using data from IDOs . These ADOs may therefore comprise any permutation of the IDO from which they were created. The schemas used to create the ADOs hereafter application schemas may be created at runtime and stored as objects in a similar manner as the internal schemas described above. Furthermore an IDO may be updated to include the internal schema s that may be used with the IDO to create ADOs. As mentioned above because ADOs can be created at runtime and comprise data from IDOs that are stored in the CHIMPS there is no need to store and or persist the ADOs throughout the CHIMPS . That said some embodiments contemplate doing so which can decrease processing demands in the CHIMPS.

ADOs may be utilized internally by the CHIMPS and or passed to an external entity through an API. Thus the ADOs can be utilized in a variety of scenarios. For example where the internal objects include information regarding media assets application schemas may be created for different client applications corresponding to different user devices. A client application of a mobile device such as a mobile phone may require a different ADO than a client application of a personal computer. Moreover a content provider or other entity may specify application schemas for uploaded media assets thereby controlling how data regarding the uploaded media assets is distributed.

Application schemas can determine which of the IDO s properties are included in an ADO . Thus the properties of the ADO can comprise a subset of the properties of the IDO . As discussed above properties can comprise elements attributes and methods of the IDO including data corresponding to the media asset and or other file to which the IDO corresponds. Embodiment illustrates how a first application schema can be used to translate IDO into a first ADO having properties and corresponding to a subset of the properties of the IDO . Similarly a second application schema is used to translate IDO into a second ADO . The second ADO includes properties and corresponding to a second subset of the properties of the IDO .

Some embodiments contemplate the creation of an ADO using properties that may not be found in a corresponding IDO . For instance where a property is required in an ADO but not mapped or not available in a corresponding IDO the property can be created and given a default value thus creating an ADO having one or more properties that may never have existed in the corresponding IDO . Default values can be completely arbitrary and may vary depending on the name of the mapped property. For example if an ADO requires properties named CreatedBy and UpdatedBy which do not correspond to any properties of a corresponding IDO the required properties can be generated and given default values such as systemadmin. Of course default values for such properties can be different depending on desired functionality.

Similar to the internal schemas discussed above application schemas may alter names and or values of data. Embodiment illustrates how the names of some or all properties of ADOs may differ from the names of corresponding properties of the IDO from which they were derived as noted in by the and demarcations. For example Property a of the first ADO has a different name than the Property a of the IDO . Moreover because each application schema may be different the second application schema can specify yet another name for a property . For example Property a of the second ADO has a different name than the Property a of the IDO and Property a of the first ADO . Thus similar to the internal schemas application schemas can effectively map property values of application objects to any property of an IDO .

For example an IDO corresponding to a media asset may be uploaded and stored by the CHIMPS the IDO having a property comprising a data field with a name Author and a value John Doe indicating a name of the author of the media asset. However a certain client application of a cell phone may require a data field Artist rather than Author. An entity such as the content provider and or client application provider can specify a schema for the client application of the cell phone selecting the desired properties such as the data field Artist for ADOs for use with the client application and mapping these properties to existing properties of the IDO .

As with internal schemas application schemas can provide for the reformatting altering and or combining of properties of the IDO to create corresponding properties in ADOs . For example Property d of IDO may comprise a data filed with the a date May 21 2005. If however an ADO needs corresponding data in a mm dd yyyy format such a requirement may be indicated in an application schema and implemented by the CHIMPS such that the corresponding Property d of ADO has a value of 05 21 2005. Embodiments contemplate other types manipulation of properties which can be indicated by application schemas .

An external entity can specify internal application and or other schemas described herein in a variety of ways. The CHIMPS can for example provide a content provider with an application such as a schema managing client by which the content provider can specify schema properties. The application can comprise a stand alone program a browser based application or more and can be used to send schema information to the CHIMPS . The schema information is then utilized by one or more systems in the CHIMPS such as processing servers ingest servers and or storage arrays to create and or store the schemas.

It will be understood that embodiment and other embodiments discussed herein can utilize various types of systems and objects. The API for example may be an API based on representational state transfer REST simple object access protocol SOAP or other architectures and or protocols. The API can further implement a variety of outputs formats and languages with which to return the requested ADO including action message format AMF SOAP Adobe Flash extensible markup language XML including any XML based formats JAVASCRIPT Object Notification JSON HyperText Markup Language HTML a custom binary format and more.

Various systems can request and receive objects in the manner illustrated by embodiment . The retrieval of ADOs comprising information related to files can extend beyond media as mentioned above to other cloud and or web based services. Such services can include social networking gaming or other services. For example an external gaming service provider can request an ADO comprising information regarding a video game e.g. number of levels genre file size etc. utilizing a client or other application configured to communicate with the API . It will be understood that a wide variety of services provided by the CHIMPS can utilize the retrieval of ADOs . By means of example and not of limitation such services can include the redistribution of binary files media or otherwise with no transcoding the repackaging of binary files for platform or operating system specific file formatting e.g. repackaging a .zip file in a WINDOWS based system to a .tar and or .gz format for output to a UNIX based systems or more.

At block a data set is received. As discussed herein the data set can comprise information regarding a file e.g. metadata such as a media asset. The data can be provided in various ways. For example the data may be downloaded from a server of a content provider . Additionally or alternatively a content provider or other external entity may upload the data to system s configured to create corresponding IDOs .

At block relevant data elements are identified. This identification can be performed by using internal schema s created at block . As discussed above internal schemas can be used to create IDOs having certain properties as required by a base schema. To do so internal schema s can include information to map data elements of a data set to properties of an IDO . Additionally or alternatively internal schema s may be linked to a separate file comprising mapping information. At block an IDO is created.

It will be understood that the identifying relevant data elements may done without internal schemas . For example a data set may adhere to a standard format required for all IDOs . Put another way there may be only one internal schema for all IDOs . Alternative embodiments further provide for generating data rather than receiving it from a content provider or other external entity. For example the CHIMPS may receive and transcode a media asset generating information regarding the media asset thereafter creating an IDO comprising information regarding the media asset using the generated information. Of course IDOs may be modified and updated by the CHIMPS as the IDOs and or files to which they correspond are processed and modified by the CHIMPS and or other systems.

At block application schema information is received. As discussed above a content provider application provider or other entity can specify the format and or content of data objects for use by and application requiring an ADO . At block one or more application schemas are created using the received application schema information.

At block a request for an ADO is received and at block the corresponding IDO and application schema required to created the requested ADO are requested. The request may be received by a system at a location different than where the IDO and or the application schema resides. For example the IDO and or application schema may reside on a data object origin server of a kernel application center whereas the request may be received by a caching server of an application center geographically distant from the kernel application center . In cases such as this the IDO and or application schema may be persisted as described above enabling the system receiving the request to create the requested ADO locally.

At block the requested ADO is created and at block it is provided to the requesting entity and or application. As discussed above the receipt of a request for an ADO as well as the providing of the requested ADO may be performed by an API . The API can be executed by one or more systems of the CHIMPS such as caching server s of an application center .

The ability of the CHIMPS to accept data in a variety of formats to create IDOs as well as provide ADOs comprising any number of permutations on the IDOs enables quick integration with the CHIMPS on both ends for both incoming and outgoing data. In fact this ability enables the CHIMPS to enable quick integration between external entities having different formats for data regarding files. For example a content provider having data in a first format regarding media assets may desire to work with a particular CDN or other content distributor requiring data in a second format to distribute the media assets. Integration of the systems could traditionally take several months. However each system may take only minutes to integrate with the CHIMPS which can integrate the two systems by receiving data from the content provider and produce it in any format the CDN or other content distributor may require.

The ability to input and output data and data objects of virtually any format allows the CHIMPS to provide unique services based on this functionality. For example the CHIMPS can be configured to receive data corresponding to files along with the files themselves individually or in bulk by utilizing input feeds. illustrates an embodiment of a method for receiving data using input feeds and creating data objects with the received data.

The term input feed as used herein can comprise any file having data regarding one or more media assets and or other files . Examples of input feeds can include web feeds such as extensible markup language XML really simple syndication RSS media RSS MRSS and Atom Syndication Format. An entity providing the input feed can modify the input feed to reflect changes in the data and or file s to which the data corresponds exposing the input feed to the CHIMPS for download. The CHIMPS in turn can be configured to monitor the input feed for such changes as described herein.

At block the method can begin by receiving input feed schema information which can include a URI of the input feed. As with internal schemas and application schemas detailed above a content provider or other external entity can provide the CHIMPS with information regarding the format and or data elements of an input feed. It will be understood that the input feed schema may be automatically detected if the input feed comprises a format recognized by the system receiving the input feed. Moreover at block the content provider can further map data elements of the input feed to IDO properties. Similar to the schemas described above the information for these mappings can be stored in the input feed schemas or files linked to the input feed schemas and the mappings may indicate modifications to data elements names and or values required to make such a mapping.

At block the input feed schema is created and at block the input feed ingest is enabled. The input feed schemas as with other schemas described herein can be stored and persisted in the CHIMPS as a data object. With the URI of the input feed and the input feed schema enabling a systems such as the CHIMPS to create IDOs from the input feed one or more systems performing the method of can be enabled to ingest the input feed. This can be as simple as including the URI of the input feed on a list of input feed URIs to monitor.

At block the input feed is read. Because a corresponding input feed schema has been created the data elements of the input feed can be easily determined. At block the data is extracted from the input feed and at blocks and the IDO s are created and stored. As discussed above the CHIMPS can have the capacity to store the IDO s and or the input feed schema at any of a variety of locations within the CHIMPS according to desired functionality. For example the IDO can be stored at a data object origin server of the CHIMPS and or persisted to one or more application centers .

Alternative embodiments contemplate numerous variations on the method illustrated in . For example receiving feed schema information at block may be combined with receiving mapping information at block . In addition to extracting data from an input feed the CHIMPS may be further configured to download and or process the file s to which the extracted data corresponds. For example an input feed may provide information regarding desired formats bitrates or other properties for a media asset. Alternatively the properties may be selected by a user interface of an application of the CHIMPS . These properties can include any measurable property of the media asset including but not limited to video bitrate audio bitrate an aspect ratio e.g. 4 3 and or 16 9 height and width a user defined and or forced aspect ratio a pixel height and or width etc. a user selected aspect ratio e.g. force If the CHIMPS determines that one or more of the desired formats or bitrates for the media asset does not exist the CHIMPS can download and transcode the media asset to the desired format or bitrate. Moreover the CHIMPS can store the transcoded version s of the media asset either internally to the CHIMPS or externally e.g. with an external CDN and modify the corresponding IDO to include the URI s of the transcoded version s of the media asset.

Because input feeds may be updated the CHIMPS can further be configured to automatically examine input feeds for updates. Although this examination may be performed upon triggering events it simply may be done one a periodic basis e.g. once every minute . Changes to the input feed can be determined various ways such as determining a last modified date and or time of a previously downloaded input feed and comparing it to a last modified date and or time of a currently available input feed. Actual content of the input feed may also be examined and or compared to contents of a previously downloaded input feed. If the input feed is determined to have changed the CHIMPS may modify corresponding IDOs and or create new IDOs to reflect the changes.

The ability of the CHIMPS to dynamically created IDOs and ADOs further enables the CHIMPS to provide output feeds. The output feeds can provide information regarding one or more files in any format requested by an outside entity. Similar to input feeds the output feeds not only enable external entities to quickly integrate with the CHIMPS it also enables external entities to quickly integrate with other entities integrated with the CHIMPS .

At block the output feed schema is generated based on the information provided above. At block the output feed schema is stored. As with other schemas described herein the output feed schema can comprise an object and the schema object may be stored and persisted throughout the CHIMPS in a manner similar to that of IDOs .

At block the relevant IDO s is retrieved and at block the output feed is generated. Similar to the input feeds described above the output feed can comprise information regarding one or more files. Additionally the output feed can comprise any of a variety of formats and languages such as XML RSS MRSS and Atom Syndication Format.

At block the output feed is stored and at block a URI of the output feed is provided. The output feed can be stored anywhere in the CHIMPS that can be exposed to an outside entity for monitoring. It will be understood that providing the URI of the output feed does not necessarily need to come after the output feed is stored. The CHIMPS can for example indicate the URI of the output feed to an outside entity beforehand if the CHIMPS can determine the location at which the output feed will eventually be stored.

In addition to creating the output feed as illustrated by the method shown in the CHIMPS may update the output feed to reflect changes to the IDO s to which the output feed corresponds. Additionally or alternatively an outside entity may alter the output feed schema to indicate one or more IDOs to add and or remove from the output feed.

Other elements of show further functionality. Update button can be used to save element and attribute mappings of a node. Feed URL field is used to display a URL of the output feed and button can be selected to save and preview the feed output in another window. Save button can be selected to save node mappings as well as selected output feed schema format and selected IDOs not shown .

It should be noted that the methods systems and devices discussed above are intended merely to be examples. It must be stressed that various embodiments may omit substitute or add various procedures or components as appropriate. For instance it should be appreciated that in alternative embodiments the methods may be performed in an order different from that described and that various steps may be added omitted or combined. Also features described with respect to certain embodiments may be combined in various other embodiments. Different aspects and elements of the embodiments may be combined in a similar manner. Also it should be emphasized that technology evolves and thus many of the elements are examples and should not be interpreted to limit the scope of the invention.

Specific details are given in the description to provide a thorough understanding of the embodiments. However it will be understood by one of ordinary skill in the art that the embodiments may be practiced without these specific details. For example well known circuits processes algorithms structures and techniques have been shown without unnecessary detail in order to avoid obscuring the embodiments. This description provides example embodiments only and is not intended to limit the scope applicability or configuration of the invention. Rather the preceding description of the embodiments will provide those skilled in the art with an enabling description for implementing embodiments of the invention. Various changes may be made in the function and arrangement of elements without departing from the spirit and scope of the invention.

Also it is noted that the embodiments may be described as a process which is depicted as a flow diagram or block diagram. Although each may describe the operations as a sequential process many of the operations can be performed in parallel or concurrently. In addition the order of the operations may be rearranged. A process may have additional steps not included in the figure. Furthermore embodiments of the methods may be implemented by hardware software firmware middleware microcode hardware description languages or any combination thereof. When implemented in software firmware middleware or microcode the program code or code segments to perform the necessary tasks may be stored in a computer readable medium such as a storage medium. Processors may perform the necessary tasks.

Having described several embodiments it will be recognized by those of skill in the art that various modifications alternative constructions and equivalents may be used without departing from the spirit of the invention. For example the above elements may merely be a component of a larger system wherein other rules may take precedence over or otherwise modify the application of the invention. Also a number of steps may be undertaken before during or after the above elements are considered. Accordingly the above description should not be taken as limiting the scope of the invention.

