---

title: Contract-based process integration
abstract: The present disclosure describes methods, systems, and computer program products for providing contract-based process integration. One computer-implemented method includes selecting a process integration (PI) scenario definition and a desired party with which to establish communication using an interface, determining at least one semantic contract associated with the selected PI scenario definition, querying the desired party to determine familiarity with the selected PI scenario definition and the semantic contract, analyzing known contract definitions with contract usages for each determined semantic contract to generate first party analysis results, computing an intersection between the first party analysis results and corresponding received analysis results received from the desired party, determining an agreed upon set of processing types with the second party by performing an intersection with contract usage processing types exchanged with the desired party, and generating a technical specification for a message signature based upon the agreed upon set of processing types.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09299049&OS=09299049&RS=09299049
owner: SAP SE
number: 09299049
owner_city: Walldorf
owner_country: DE
publication_date: 20130315
---
In current process integration PI architecture different consumer and provider systems implementing business applications processes tools and frameworks use both inbound and outbound interfaces for example web services function calls file uploads and the like to provide integration between the different systems. The use of different interfaces often results in a lack of knowledge exposure for integration scenarios across different systems insufficient business process documentation lack of a common application programming model configuration and monitoring framework lack of harmonized versioning and interface extensibility different models procedures and tools across business applications imprecise definitions of interfaces and scenarios a lack of a defined link between inbound and outbound interfaces and the like. As a result total cost of development and total cost of ownership increases for both consumers and providers. This increases financial risk loss of business inefficiencies the need to expend organizational resources that could be put to other productive uses and the possibility of errors affecting the organization s financial stability and desirability.

The present disclosure relates to computer implemented methods computer readable media and computer systems for providing contract based process integration. One computer implemented method includes selecting a process integration PI scenario definition and a desired party with which to establish communication using an interface determining at least one semantic contract associated with the selected PI scenario definition querying the desired party to determine familiarity with the selected PI scenario definition and the semantic contract analyzing known contract definitions with contract usages for each determined semantic contract to generate first party analysis results computing an intersection between the first party analysis results and corresponding received analysis results received from the desired party determining an agreed upon set of processing types with the second party by performing an intersection with contract usage processing types exchanged with the desired party and generating a technical specification for a message signature based upon the agreed upon set of processing types.

Other implementations of this aspect include corresponding computer systems apparatuses and computer programs recorded on one or more computer storage devices each configured to perform the actions of the methods. A system of one or more computers can be configured to perform particular operations or actions by virtue of having software firmware hardware or a combination of software firmware or hardware installed on the system that in operation causes the system to perform the actions. One or more computer programs can be configured to perform particular operations or actions by virtue of including instructions that when executed by data processing apparatus cause the apparatus to perform the actions.

The foregoing and other implementations can each optionally include one or more of the following features alone or in combination 

A first aspect combinable with the general implementation wherein the PI scenario definition can be automatically selected based on contextual data.

A second aspect combinable with any of the previous aspects wherein determination of the at least one semantic contract is performed by a communication contract aware communication framework.

A third aspect combinable with any of the previous aspects further comprising receiving confirmation of awareness of the selected PI scenario definition and the at least one semantic contract from the desired party.

A fourth aspect combinable with any of the previous aspects further comprising receiving an analysis of known contract definitions with contract usages for each determined semantic contract from the desired party.

A fifth aspect combinable with any of the previous aspects further comprising implementing the interface compliant with the generated technical specification.

A sixth aspect combinable with any of the previous aspects further comprising exchanging a message with the desired party using the implemented interface.

The subject matter described in this specification can be implemented in particular implementations so as to realize one or more of the following advantages. First isolated often redundant interface solutions from individual problem domains are consolidated into a homogenous overall interface. This homogeneity reduces the number of different entities that are needed to model implement and configure process integration PI reducing total cost of development. Second a contract definition entity merges multiple entities eliminates the need for message types and integrates message communication profile groups profiles. Third PI architecture is aligned closer to standard industry practices for service oriented architecture SOA web services WS based integration. Fourth configuration of modeling entities is improved eliminating the need for a separate set of entities in need of maintenance. Fifth interface versioning and extensibility is more easily supported. Sixth precision and self documentation is possible as well defined contracts also cover behavioral aspects and use case dependent variability. The definitions provide information needed to create a conforming implementation and generate documentation that only covers the fields needed in a specific use case. Seventh in the new implementation interoperability decisions are transparent and encourage parties in cross product scenarios to agree on a standardized specification early in the development process and force the parties to justify any subsequent changes to an agreed upon specification. Finally more precise models allow setting up automated tests or verification of interface implementations prior to and during development. Other advantages will be apparent to those skilled in the art.

The details of one or more implementations of the subject matter of this specification are set forth in the accompanying drawings and the description below. Other features aspects and advantages of the subject matter will become apparent from the description the drawings and the claims.

This disclosure generally describes computer implemented methods computer program products and systems for providing contract based process integration.

The following description is presented to enable any person skilled in the art to make and use the invention and is provided in the context of a particular application and its requirements. By abandoning the concept of inbound and outbound interfaces for process integration PI and focusing on one interface definition on which involved parties abstractly represented as actors agree a holistic solution to PI modeling development and configuration process can be provided. Various modifications to the disclosed implementations will be readily apparent to those skilled in the art and the general principles defined herein may be applied to other embodiments and applications without departing from scope of the disclosure. Thus the present disclosure is not intended to be limited to the described and or illustrated implementations but is to be accorded the widest scope consistent with the principles and features disclosed herein.

For every interaction between actors for example a query and associated response one definition of the interaction is established as binding on each actor and forms the basis for a single model of an interface for the interaction. There are no separate outbound and inbound interface models that can evolve independently. The single definition introduces detailed constraints described below requiring explicit definition of valid uses of the interaction. Along with defined associated interfaces and operations with their signatures developers and customers can derive documentation in high precision from the definition. Every element of the definition is linked to enabled capabilities making it possible to extract a very compact description covering exact capabilities required for a specific use case PI scenario. Versioning of the definition is also possible to allow for extensions agreed upon by the actors. This modular structure is the foundation of a flexible versioning and extension concept.

Interaction patterns are groups of closely related queries requests with their associated responses ideal for describing business semantics sequence and consistency constraints usage patterns and error handling. The interaction patterns are represented by a contract specifying one or multiple related interfaces with their operations and signatures e.g. message data types that are provided consumed in an interaction between the actors along with additional constraints.

In general a contract describes an interaction between two actors by means of a set of operations clustered into interfaces with a single shared interface definition between the actors. For each interface actor roles are specified for example which actor is a supplier and which is a customer. Data is transmitted according to the shared interface definition for example in a message regardless of how the data is manipulated locally by each actor. For example a computer system of a customer actor has an implementation of an operation that takes data within internal data structures and translates the data into a format mandated by the contract i.e. writes a message. The resulting message is then transmitted through an external interface by the customer s computer system to another actor s computer system e.g. a supplier received by an identical interface associated with the other actor s computer system translated from the received message i.e. read and the read data written into internal data structures associated with the other actor s computer system. Note operation implementations of each actor i.e. customer and supplier are separate and in a sense mirror images of each other one implementation wrapping data into a mandated message format and transmitting the message the other implementation receiving the message and unpacking the encapsulated data. Operation implementations cannot be simply exchanged by the actors if they wish to switch roles internal implementations are customized to each actor with only the external interface between the operation implementations standardized. In some implementations an interaction can be split into two or more interactions with a central integration hub performing a mapping of transmitted data at a technical level according to an agreed upon contract.

A contract is an atomic indivisible entity in the sense that the interactions it describes cannot be used independently of each other in a meaningful way for example a query response pattern where neither the query nor the response can stand on its own. The principle holds for a request confirmation pattern as well even though it might be feasible to use the request without the confirmation the reverse is not true for the confirmation. Contracts are not suited to act as a generic container for all integration capabilities of a component as these can typically be used independently of each other. Typically most contracts will contain one or two interfaces but it is possible to create larger logically indivisible interface bundles. A contract also allows specifying additional constraints to document in which order combination operations can be called and which options or use cases exist for using a specific operation.

The concept of a contract appears in three areas as a semantic entity semantic contract a definition entity contract definition and an implementation entity contract usage . The division of labor between the three types of contracts is as follows 1 a semantic contract defines what is done and what the business purpose of the interaction is 2 a contract definition defines how the interaction should take place in great technical detail and 3 a contract usage defines who that is which concrete software component provides an implementation of the contract definition and is thus able to actually interact based on it along with any imposed limitations associated with a particular implementation.

A particular semantic contract defines interfaces operations shared processing types described below and constraints described below but not signatures. Semantic contracts are used for specifying the intended business semantics of an interaction e.g. when composing a PI scenario . Semantic contracts describe the interaction between at least two actors by means of a set of semantic interfaces each offering a set of semantic operations. For each interface it is specified which actor provides it and which one consumes it. Semantic contracts will also specify the applicable processing types with the corresponding constraints. In other words a semantic contract is a specification of the interaction between two abstract parties at the business logic level by means of a conceptually inseparable set of abstract interfaces and operations and constraints governing their use. It is a conceptual entity that abstracts from implementation aspects such as product version or technology. As such it can serve as a bracket abstraction handle or placeholder entity that subsumes all implementations with identical business semantics and allows addressing them in a transparent unified product version and technology agnostic way. The focus is on exposing an integration need or capability of the system in a specific business context while providing maximum flexibility with respect to the way it is implemented. For purposes of this application a business layer is implementation independent an engineering layer is implementation dependent and the implementation layer is a technical realization. Semantic contracts can serve multiple purposes in the software independent business layer they allow specifying integration requirements in a systematic manner as opposed to a purely textual description. In the implementation layer semantic contracts provide a bracket entity that allows grouping multiple alternative technical realizations or successive versions of the same interface. This is useful at configuration deployment time and possibly runtime because it is a cornerstone of an efficient system for meeting conceptual integration requirements by automatically matching and activating compatible implementations and thus avoiding a combinatorial explosion.

A contract definition of the particular semantic contract lists relevant processing types and then specifies which operations call sequences and subsets of the operation signatures are required or forbidden for each processing type. A contract definition is a specification of the interaction between two abstract parties by means of a conceptually inseparable set of interfaces operations and operation signatures and constraints governing their use. The contract definition is a central entity of the proposal fully implementing the contract concept in the implementation layer. A contract definition is a concrete entity in the sense that it provides a complete specification in full technical detail. However it is still abstract in the sense that the contract itself is not a piece of software it is a definition i.e. a specification not an implementation and as such is neither executable nor specific to a single product version.

A contract usage not illustrated for the examples in this disclosure is a model entity documenting that a specific set of implementation artifacts represents a full or partial implementation of a contract along with the specific restrictions that may apply to the implementation. A contract usage documents how a product implements a contract definition. When product such as a business application implements one side of the contract definition the implementation is documented by means of a light weight model entity called a contract usage. The contract usage points to both the contract definition and corresponding implementation artifacts. If the product only implements a subset of the capabilities defined by the contract definition the implementation is publicized by explicitly including only the supported processing types in the contract usage. A contract usage object is not an actual technical implementation nor does it contain any coding. The contract usage is merely a light weight association or correspondence object pointing to the contract definition on one side and relevant technical entities on the other side.

It is desirable that semantic contracts should be maintained in one central location e.g. integrated into and published in a central catalog and shared across an entire organization as the need for new semantic contracts is motivated locally.

Contract usages are hybrid entities containing a private and a public part created locally as they document that a specific local implementation implementing a specific contract definition. Information about interfaces and operations that are implemented and the constraints concerning supported processing types are public information that is made available to other systems to make the capabilities of an implementation known and enable automated configuration and adaptation. The contract usage also contains links to internal implementation entities that document how it is realized that are private and do not need to be published to other systems.

Contract actors for example actors and illustrated in abstractly represent two sides of an interaction and are typically realized by any suitable software entity.

Each actor definition is meant to be local to a contract in which it is defined and has no semantics beyond the boundaries of the contract. Actor labels for example Customer Supplier establish a context of an interaction by providing an idea of who is interacting and which side of the interaction is doing what for example that the Purchase Order Confirmations interface is provided by the Customer actor . In most implementations due to the reusable nature of a contract actors should not reference concrete components or try to characterize possible implementers beyond stated integration requirements that is any component that implements an interface is acceptable and can act the part of the corresponding actor.

At a high level an interface is a single shared specification associated with a contract that defines a set of operations that the provider of the interface exposes and that any conformant actor caller can invoke and receive data from. An interface is directional in the sense that actors for example a customer and a provider are clearly distinguished for each specific use of an interface and that each component provides and requires a well defined set of interfaces.

At the implementation level a physical implementation of the interface exists for each opposite side of an interaction. The service provider realizing the interface will provide an implementation that can actually be called inbound whereas the service consumer will still need an implementation encapsulating the code necessary for composing a conformant request to the corresponding implementation on the other side outbound . It is therefore not primarily the implementation that changes but the description and technical identifiers. For example for web services there will only be one agreed WSDL definition with a single technical name referenced by both parties removing the potential for name matching and WSDL equivalence problems.

In typical implementations contract interface operations are inseparable and semantically linked e.g. in a query response request confirmation or notification pattern. Interface definitions exist primarily for user convenience to group identify linked operations. Generally interfaces should be used to cluster closely related operations for example all dealing with the same business document object or all operations required in a specific phase of an interaction. As a result the specific purpose of the contract can act as an upper bound on the size of associated interfaces.

While there is only one interface type and no distinction between inbound and outbound interfaces a contract does differentiate between actors e.g. provider and consumer of an interface which must be unambiguous. An asynchronous exchange for example one consisting of a query and a response requires at least two interfaces one for the query and one for the response or at least one interface per direction.

The relationship between an interface and contract is a composition. Therefore an interface is not reused across contracts. Nonetheless building blocks of contracts can be reused in particular at the implementation level. This is particularly true if contract models are created on top of existing interface implementations.

At a technical level an interface is implemented by various combinations of coding web service endpoints WSDLs components process agents mapping engines and the like.

Operations associated with an interface are atomic and callable in isolation. However different software methodologies technologies have different conceptions about what constitutes an operation and operations can be implemented in a myriad of ways. While design types of operations should generally be driven by business semantics contract definitions can merge or split operations defined in a semantic contract for example by requiring the consumer to call a series of technical operations to achieve one business purpose by reusing the same technical implementation e.g. one form for Create and Change and or by treating an operation as a special case of another implementing Cancel as a change to quantity 0 .

Typically there is a single semantic contract for an interaction such as invoicing a customer. Such an interface will then be implemented by different products e.g. business applications often multiple times per product using different technologies.

At an operation level typically each contract definition operation realizes one or more semantic operations. In some implementations each operation will implement exactly one semantic operation. However in other implementations and depending on the chosen granularity of the semantic operations operations can group multiple semantic operations. For example form based interfaces can reuse the same operation for creating and updating an object. As another example multiple different types of notifications can be semantically distinguished but a single notify operation can implement the different types. In some implementations multiple semantic operations can become intrinsic processing types of a concrete operation. In some instances a synchronous operation can state that it implements both a request and a response semantic operation.

In some implementations a semantic operation that is semantically indivisible can be e.g. for technical reasons spilt up into multiple operations. In this case the fact that the operation is a fragmentary implementation of the concept and which other technical operations need to be called is recorded.

Constraints described below can affect the relationship between operations and their semantic counterparts. For example depending on a chosen processing type a semantic operation Cancel can in the same contract either be executed by using a dedicated Cancel operation or by using a Change operation with processing type described below Cancel set to ACTIVE which can result in setting a requested quantity value to zero indicating a Boolean FALSE cancel value . This use of constraints and processing types can be useful when integrating implementing contracts with different products where one may use the Cancel operation and one uses the Change operation but similar functionality is needed.

Each operation in a contract definition defines a signature using a data type definition containing a structure definition enhanced with additional restricting constraints. The signature defines what structures and fields need to be provided in a message transmitted between operation interfaces.

A constraint is any arbitrary Boolean expression i.e. any expression that can be evaluated to a TRUE FALSE valued response. Constraints control the validity existence of static and dynamic properties of a contract i.e. which structural elements operations or signature elements are available or required or which actions and state transitions are allowed under specific circumstances. The most common uses of constraints are to make operations or entire interfaces conditionally required doing the same for elements of operation signatures and constraining the protocol.

Constraint expressions can range from simple to complex logical mathematical or textual formulae. Processing types figure prominently in constraints but are themselves dependent on and derived from configuration data master data or the content of concrete message instances.

A contract constraint element is used for storing both signature and cross element constraints. Additionally this element can also be used to store weak constraints that express recommended defaults and non structural constraints e.g. which side is expected to perform ID mapping should it be necessary . The constraint element can also store textual constraints for documenting restrictions that cannot be formalized using expressions or that have not been formalized.

Constraints operate on a type or instance level both of which are interdependent. Enablement conditions for operations operate on the type level if the operation is required it needs to be developed deployed and configured but there is no requirement for the user to actually call it. A contract protocol described below on the other hand constrains the instance level for example if the contract protocol requires a call sequence of X Y Z the user must call Y before calling Z.

A processing type is an operative or controlling property of a process chain or use case instance. It is operative i.e. causing an effect in the sense that it affects the behavior of the software controlling process step transitions service invocations UI adaptations or object behavior. Processing types document in a unified manner switches that have a significant effect on overall product and are based on two central ideas 1 distilling an outcome that is relevant for subsequent processing into a simple binary decision. For example is an approval step required Approval required Approval not necessary Specifying that a particular decision exists where it is taken what the possible outcomes are and which further behaviors are affected by this decision is very useful information even if the specific mechanisms and implementations are not known. The decisions can be used to increase the transparency and expressiveness of many models in particular process flow and process integration models and 2 the ability to derive any relevant decision that is not based on direct user input either from instance data master data or configuration data.

Processing types affect process integration as they represent decisions that can significantly affect the process behavior which interactions are necessary and what is communicated. Process types can also be deduced from object properties. For example a specification could indicate how process types are configured or how they can be recognized in an incoming message. Processing types allow formalizing different supported use cases by using the processing types as arguments in various types of constraint expressions.

A processing type domain is the declaration of a derived named property of an instance entity complete with a list of allowable values that has an effect on the behavior of the entity. Processing type domains represent significant properties or decisions that control or affect the behavior of the software. Processing types are organized into processing type domains. In some implementations each processing type domain is dedicated to a specific topic and contains a list of mutually exclusive processing type alternatives. For example a Sales Order Item can have a processing type domain called Item Product Type with processing types such as Material or Service. The determination rule for this decision is trivial as the mutually exclusive determination of the applicable processing type can be taken directly from a product definition e.g. whether the item is an ABC Widget material or Production Equipment Service Plan Service and can be used to drive process functionality e.g. only for a Material processing type would a logistics component be notified of the customer requirement .

Not all processing type domains are equally important or have the same impact on a contract. Their role in the contract can thus be classified in various ways. Firstly which aspects of a contract are affected can be specified including the following scope which interfaces operations are included sequence what is the usage protocol for calling them signature which structures and fields need to be provided or semantics what do specific fields mean e.g. which side needs to convert an ID . Secondly a processing type domain can be extrinsic or intrinsic to a communication. If it is intrinsic the active value can be determined based on the content of an actual message e.g. because a certain field is missing . If it is extrinsic a message cannot be understood properly without additionally knowing the active value e.g. who needs to map an ID .

Processing type domains can also be classified as static fixed at configuration time or dynamic fixed at run time . For each processing type of a static processing type domain the infrastructure will generate physical interfaces i.e. WSDLs and endpoints in the case of web services. When setting up a connection interacting parties will agree on the processing types that should be used for a static domain. Dynamic domains can be restricted in the configuration process as well but the exact processing type only becomes fixed at runtime.

A contract can at an application level constrain an allowed sequence or choreography of operation invocations by means of state machine chart models called contract protocols. Contract protocols specify all possible allowed sequences of operation invocations by defining states and transitions between them that represent the corresponding operation invocation. Transitions in a contract protocol can be conditional. For example they can depend on processing types or because operations can themselves be optional at runtime. Constraints can also refer to the contract protocols of other related contracts in order to allow expressing constraints for an overall choreography for example a situation where a law states that an invoice should not be sent before an outbound delivery. Because contracts are by definition independent of each other such cross contract constraints are conditional and typically only come into effect when the contracts are actually used in conjunction with each other and a matchup can be made between the contracts e.g. invoice delivery notifications references similar order identifications .

Contract protocols can provide multiple benefits. Apart from a documentary value they enable automated testing of implementations by iterating through different allowed sequences and verifying that reactions conform to associated specification. Contract protocols can also serve as the basis for model derivations if the contract protocol is defined before an implementing object is designed. In some implementations contract protocols can be automatically generated from sequence diagrams process flows and other suitable data structures such as UML sequence diagrams.

For a protocol transition a condition is enabled if an associated transition expression evaluates to true and disabled if it evaluates to false. The same is true for conditionally enabled interfaces and operations it is possible to assign an expression that defines that the interface operation is only included if a certain combination of processing type s is active. In some implementations it is necessary to include the effects of a condition into the expression itself and store it independently from the entity that is being constrained.

In some implementations the radio type selection boxes underneath each processing type are selectable and affect a preview of processing types the effective signature etc. Here each selected value affects the preview of effective signature values. For example for the Confirmation Code signature element if running without confirmation the Confirmation Code has a cardinality of 0 meaning it is not part of the signature and will not be included in an agreed upon signature between parties. Likewise if running with confirmation Confirmation Code has a cardinality of 1 meaning it is part of the signature mandatory and will be included in an agreed upon signature between parties. Note that in this case the Signature has a cardinality of c meaning that Confirmation Code may or may not be included in the signature due to the mutually exclusive nature of the Purchase Order Confirmations domain type and associated processing types . A cardinality of c is weak. Note that the mutually exclusive nature of the processing types creates two specific use cases and associated signatures. One signature with the element mandatory to include it and one without the element at all must not include it . The signature is a conceptual signature definition that allows the generation of many technical signature definitions. Because the with confirmation processing type is selected the non default the effective signature i.e. a technical signature mandates that this code be included in a message between the parties. Note that the real effective signature at configuration time is computed invisibly based on static processing types and a more restrictive effective signature at run time is then computed invisibly based upon dynamic processing types.

 n means can have multiple values associated with the signature element. For example Party has many sub values. Another example is the processing type Available . Since it is selected the communication signature elements are made available for entry. The c indicated for each means that the values can be entered or not optional . In this example assuming that Available was added as an extension if another party was running a contract version without the extension the party with the extension supporting the Available processing type could set the Contact Information domain type processing type to Unavailable as opposed to Available and be compatible with the other party without the extension and the communication signature element fields would not even be in the signature.

Note for the Standard Product Custom Product processing types if Custom Product is selected illustrates at that the RequirementsSpecification ID and RequirementsSpecification Version ID are mandatory as the cardinality of the higher level hierarchical signature element Product Requirement Specification Key becomes 1 thus effecting lower level signature elements . In a case of a Standard Product the cardinality of Product Requirement Specification Key is restricted to cardinality 0 i.e. the entire node is forbidden and not there. Thus its element Requirement Specification ID and RequirementSpecification Version ID disappears as well along with their ineffectual 1 cardinality.

In some implementations constraints cannot be expressed adequately in grid cells because they depend on multiple elements and or processing types. In some implementations these constraints can be defined using any suitably sophisticated editor or method to specify a more complex constraint. For example Constraint applies to the State Code signature element . This constraint reads in this example as a State Code data value is required in a message data structure if the Address.CountryCode data field corresponding to signature element Country Code is equal to a value of US. 

Those of skill in the art will appreciate that the provided example contract signature and constraints is one of a multitude of possible examples and formats. The illustrated data would be provided in any suitable manner consistent with this disclosure. For example the illustrated values would be represented in a database flat file or other suitable structure without departing from the scope of this disclosure. The provided example is not meant to be limiting in any way and is meant to only illustrate one of many possible methods of representing contract and or constraint signature constraint elements.

A PI scenario definition is a bundle of the interactions between two or more abstract parties that are required to realize a specific interface with each interaction represented by a semantic contract. In a PI scenario definition involved parties interact using a set of semantic contracts until a suitable contract definition is chosen for each semantic contract based on defined contract usages implemented by the parties taking processing types processing type domains into account. A PI scenario definition is a much simpler entity than a contract and is typically computed for display and default purposes only. It mainly consists of a list of roles a list of contracts and assignments which role takes on the part of which actor of these contracts in order to clarify who is supposed to provide and consume which interfaces. PI scenarios are intended as a unified way of setting up process integration. At a high level in some implementations a system administrator key user ideally selects one PI scenario definition entry from a list of available PI scenarios or the PI scenario definition is selected based on contextual information being on a purchase order development screen provides a context to select a purchase order PI scenario definition assigns concrete systems to the respective roles e.g. address data for the systems etc. and then obtains a configuration of all of the involved connections. At a lower level establishing a PI scenario has a multi step lifecycle for example a contract development use case e.g. develop the interface a contract configuration use case e.g. deploy and configure the interface and as a contract runtime use case e.g. use the interface to exchange messages .

The entire structure of the model is designed in a way that supposes that there are multiple contract definitions implementing the same semantic contract and multiple contract usages implementing the same contract definition. In this sense there can be multiple versions of contract definitions implementing the same semantics. There are no explicit versions of contracts. In some implementations there are three types of development for a contract 1 New development creates a new contract from scratch and is subject to no restrictions 2 Evolutionary development revision is performed by the contract owner and extends or modifies an existing contract in a subsequent release and 3 Extension development layers additional functionality on top of an existing implementation as an add on and can be performed by anyone. In a working model without explicit versions evolutionary and extension development adhere to the principle that every new or modified element needs to be qualified with a processing type. In this way every new version still contains the previous version which can be extracted or enabled by simply excluding the new processing type. Therefore later revisions are expected to be downward compatible simply by setting the right combination of processing types. For this to work well in practice the relevant coding should also explicitly refer to processing types. In this way the same approach would be applied at the implementation level i.e. the coding would be unchanged if called with the new processing types disabled.

The mechanisms for evolutionary and extension development are basically identical. The only difference is that evolutionary development performed by the contract owner happens in a linear fashion i.e. each revision builds on and replaces the previous one whereas multiple independent and combinable extensions of the same base contract can be developed and deployed at the same time i.e. the development is branching out . Therefore evolutionary development happens in the shared contract object itself and becomes integral part of it i.e. is made available to all systems using the contract whereas extensions need to be stored as addition only deltas in extension objects that users can choose to deploy in their system or not. As the extension objects need the exact same structure as regular contracts similar metaobject types should be reused. Extensions are marked by means of a reference to a base metaobject instance being extended.

If one party exclusively controls a particular contract definition it could be developed locally and then made available to other interested parties. If a contract definition is defined jointly by multiple parties it could be developed on a central shared system and then made available in the local systems be developed on a local system and then be made available to other local systems or be developed in a round robin fashion where each party takes turns to enhance the contract definition with each asynchronous release each version building on the last previously released one.

The party chosen to define a particular contract is entirely up to the involved parties for whatever reason deemed appropriate. For example a consumer with certified security practices can be chosen to define a contract for security reasons or the larger more powerful party could assert authority to do so. Ideally contracts should be mutually agreed upon but a dictated contract is acceptable as long as all parties agree to abide by it. For example a new party to a contract may be required to accept the contact as is or a government agency may dictate acceptance of a contract.

At a second party implements v. . of the contract respectively. Here both the first and the second party are using the same contract version. From method proceeds to .

At the second party defines extension A and implements v. 1.0 with extension A. From method proceeds to

At the third party defines extension B and implements v. 2.0 of the contact with extension B. From method proceeds to

At a fourth party implements v. 1.0 of the contract with extensions A and B. and a third party defines and implements extensions to v. 1.0 of the contact respectively. From method proceeds to .

After the parties are able to communicate using contracts extensions at the levels defined in Table 5.1.

At the second party defines and implements v. 4.0 of the contract with extension A. Note that as illustrated different parties can develop the main version line of a contract e.g. first party and second party and different parties can develop extensions to the main line of the contract e.g. the second party and the third party . Additionally parties can share extensions and or implemented extensions defined by other parties e.g. fourth party . From method proceeds to .

At a fourth party implements v. 4.0 of the contact defined by the second party and implements extensions A and B. Note that the fourth party never defines a contract extension but merely implements available contracts and extensions defined by other parties.

After the parties are able to communicate using contracts extensions at the levels defined in Table 5.2.

All the parties can freely contribute extensions and create implementations that are heterogeneous but all of them can interact at some minimum level of intersection between the versions and extensions. For example if the first and second parties communicate after they have full functionality available to them as they are on the same version where the first party after v. 3.0 with no extensions and the fourth party after v. 4.0 with extension A and B may have some issues due to the disparate versions and or extensions .

Those of skill in the art will appreciate that the provided example parties and contract extension version is one of a multitude of possible example development use cases. For example there could be many other parties or groups of parties involved than those illustrated with a myriad of possible defined contract extensions etc. The provided example is not meant to be limiting in any way and is meant to only illustrate one of many possible development relationships between parties within the scope of this disclosure.

At a first party user accessing a development system selects a PI scenario definition. For example the user can manually select a purchase order PI scenario from a catalog or the development system can contextually select a purchase order PI scenario for the user because they are on a purchase order screen or in a purchase order development area within the development system. The user also selects inputs system address information record for another desired second party that is wished to be communicated with using contract based technology. For example the address information could be an internet protocol IP address URL URI or any other suitable system address information record. From method proceeds to .

At a communication framework not illustrated in determines semantic contracts associated with the selected PI scenario definition. Referring to an example would be that the communication framework would select the Ordering Delivery Notifications and Invoicing semantic contracts if the user selected the Sell from Stock semantic contract. The communication framework can be any software module process or the like that can process contract based technology as described within this disclosure and consistent with aspects of this disclosure. From method proceeds to .

At the other party s system is queried e.g. over a commonly understood communication interface to determine if the other system is familiar with the selected appropriate PI scenario definition and associated semantic contracts. The other party s system responds that it is aware of the target PI scenario definition and semantic contracts. From method proceeds to .

At each party analyzes known contract definitions for which they have contact usages i.e. the contracts are implemented for each semantic contract. Note that if a party does not have a contact implemented this can mean that the use of contracts may not be feasible at that time between the two parties. Of course the non implementing party could implement the contact as well. Each party identifies to the other their contract usage. For example a first party may implement the contract definition using technology A and a second party may implement a contract definition on technology B. From method proceeds to .

At an intersection between the two party s contract usages is computed. In some implementations this intersection computation can be performed by one or both parties. The highest compatibility intersection is normally selected for use between the two parties. Parties can indicate an order of preference for the contract definitions they have implemented typically ranking the most capable implementation they have as the highest ranking. For the chosen contract definition the parties will then select the latest most capable variant supported by both parties. From method proceeds to .

At each party exchanges contract usage processing types with the other party. From method proceeds to .

At an intersection of the exchanged processing types is performed to arrive at an agreed upon set of processing types. For example one party may support processing without confirmation while the other will support both with without confirmation. In this case the intersection would be for both to support without confirmation. The intersection is without confirmation and both will run in this mode. This intersection can result in the disabling of interface operations as well as modification of protocols to not require confirmation. Note in some implementations if both supported with without confirmation the default would be to select with confirmation as it is the most advanced functional option. From method proceeds to .

At a technical specification is generated for a signature based upon the intersection of the exchanged processing types. In some implementations a tool can be provided to work with say a data structure illustrated in . In some implementations the signatures are exchanged using Web Service Definition Language WSDL specifications or other suitable specifications. From method proceeds to .

At each party implements interfaces that are compliant to the agreed upon technical specification are established by each party. Each implemented interface is an endpoint that conforms to the generated technical specification and can receive transmit messages between the parties. Note that messages transmitted between the parties may have ambiguities in terms of optional signature elements that will be resolved at runtime see . For example constraints related to processing types are not written into the technical signature. Affected signature elements are marked as option in the technical signature. In reality there are two mutually exclusive subsets of signature elements one for each processing type. At runtime depending on the active processing type one subset has a cardinality of 0 typically meaning not active while the other as a cardinality of 1 typically indicating active and vice versa if the other processing type is active. From method proceeds to .

At now that the parties have set up endpoints signatures have been exchanged processing types have been locked in so message fields are known expected the parties are capable of exchanging messages using implemented endpoint interfaces. The configuration use case is complete. From method stops.

At first party application logic decides that a message needs to be sent and calls an implemented interface. For example a purchase order needs to be transmitted to a second party. From method proceeds to .

At a mapping element associated with the implemented interface executes an appropriate semantic contract operation for example an Order operation with appropriate information. The mapping element executes the operation by supplying for example operation Order party address record and a handle pointer call back address back into the application logic for appropriate purchase order data internal purchase order document . From method proceeds to .

At mapping element analyzes a persisted configuration according to the specified party. The configuration can include contract definition processing types constraints etc. From method proceeds to .

At the mapping element formats the message according to the analyzed persisted configuration and data retrieved from the handle back into the application logic. In some implementations the mapping element can perform request a validation of the formatted message prior to transmission. From method proceeds to .

At the mapping element transmits the formatted message to a second party endpoint. From method proceeds to .

At a second party endpoint associated with the second party endpoint received and analyzes the transmitted message. From method proceeds to .

At the second party mapping element validates that the signature is correct i.e. required signature elements data is present . From method proceeds to .

At a determination is made whether the signature validation has passed. If not passed method proceeds to where an error is generated and transmitted to the first party. If passed method proceeds to .

At the second party mapping element validates that the runtime constraints associated with the message are valid i.e. according to the effective signature . For example the item type in the message can be analyzed. If a Custom Product processing type is applicable the additional constraints can be analyzed for the inclusion of mandatory signature elements. At the technical level these constraints appear optional so they cannot be checked at that stage. From method proceeds to .

At a determination is made whether the signature validation has passed. If not passed method proceeds to where an error is generated and transmitted to the first party. If passed method proceeds to .

At the second party mapping element calls into application logic to write unpacked message data determined active processing types e.g. standard vs. custom product constraints and other suitable data. To send a message from the second party to the first party can be executed starting from the second party application logic. From method stops.

In general the server is a server that stores one or more business applications where at least a portion of the business applications are executed using requests and responses sent by clients within and communicably coupled to the illustrated example distributed computing system . In some implementations the server may store a plurality of various business applications . In other implementations the server may be a dedicated server meant to store and execute only a single business application . In some implementations the server may comprise a web server where the business applications represent one or more web based applications accessed and executed by the client using the network or directly at the server to perform the programmed tasks or operations of the business application . In some implementations the server allows a user to access process definition not illustrated and or process instance data not illustrated about business processes associated with and executing in conjunction with a particular business application . In some implementations server server and or other component of the example distributed computing system provides various tools not illustrated for the first and or second party to generate store edit transmit and or delete contracts and associated data consistent with this disclosure. In some implementations server can be used to generate store edit transmit and or delete contracts and associated data consistent with this disclosure for server and vice versa .

The server is responsible for receiving requests using the network from one or more client applications described below associated with the client of the example distributed computing system and responding to the received requests by processing said requests in one or more business applications . In addition to requests from the client requests may also be sent to the server from internal users external or third parties other automated applications as well as any other appropriate entities individuals systems or computers.

In some implementations the business application can provide GUI interfaces or interface with one or more other components of the example distributed computing system to provide GUI interfaces that assist with the provision of contract based PI . For example a purchase order issued by business application of server can be entered and submitted to server across network using a GUI interface. When processed by server an GUI interface associated with a corresponding business application could be used to process a sales order and result in a returned HTML or other formatted document renderable by a client application for example a web browser.

In some implementations requests responses can be sent directly to server from a user accessing server directly. In some implementations the server may comprise a web server where one or more of the components of server represent web based applications accessed and executed by the client using the network or directly at the server to perform the programmed tasks or operations of the various components of server .

In some implementations any and or all components of the server both hardware and or software may interface with each other and or the interface using an application programming interface API and or a service layer . The API may include specifications for routines data structures and object classes. The API may be either computer language independent or dependent and refer to a complete interface a single function or even a set of APIs. The service layer provides software services to the example distributed computing system . The functionality of the server may be accessible for all service consumers using this service layer. Software services such as those provided by the service layer provide reusable defined business functionalities through a defined interface. For example the interface may be software written in JAVA C or other suitable language providing data in extensible markup language XML format or other suitable format.

While illustrated as an integrated component of the server in the example distributed computing system alternative implementations may illustrate the API and or the service layer as stand alone components in relation to other components of the example distributed computing system . Moreover any or all parts of the API and or the service layer may be implemented as child or sub modules of another software module enterprise application or hardware module without departing from the scope of this disclosure.

The server includes a network interface . Although illustrated as a single network interface in two or more network interfaces may be used according to particular needs desires or particular implementations of the example distributed computing system . The network interface is used by the server for communicating with other systems in a distributed environment including within the example distributed computing system connected to the network for example the client and server as well as other systems communicably coupled to the network . Generally the network interface comprises logic encoded in software and or hardware in a suitable combination and operable to communicate with the network . More specifically the network interface may comprise software supporting one or more communication protocols associated with communications such that the network or interface s hardware is operable to communicate physical signals within and outside of the illustrated example distributed computing system .

The server includes a processor . Although illustrated as a single processor in two or more processors may be used according to particular needs desires or particular implementations of the example distributed computing system . Generally the processor executes instructions and manipulates data to perform the operations of the server . Specifically the processor executes the functionality required to provide contract based PI.

The server also includes a memory that holds data for the server client and or other components of the example distributed computing system . Although illustrated as a single memory in two or more memories may be used according to particular needs desires or particular implementations of the example distributed computing system . While memory is illustrated as an integral component of the server in alternative implementations memory can be external to the server and or the example distributed computing system . In some implementations the memory includes one or more instances of a contract as described above. Also illustrated is a similar contract associated with server as both the first party and the second party have either an identical copy of the same contract or at least different revisions of the same contact with the revisions handled by processing types.

The contract can be generated stored and or converted from into any suitable format or form for example binary text numerical a database file a flat file or the like. In some instances the contract can be referenced by and for inclusion into other suitable data. In some implementations the contract can be directly accessed by any suitable component of the example distributed computing system for example the business application and or client . While the contract is illustrated as an integral component of the memory in alternative implementations contract can be external to the memory and or be separated into both an external contract and an internal contract as long as it is accessible using network . In some implementations the contract can interface with and or act as a reference to an internal and or external storage location and or provide functionality to retrieve contract stored in the internal and or external storage location.

Those of skill in the art will appreciate that the provided examples with respect to a contract and associated data are representative only and the contract and associated data could be represented by myriad types of data in multiple ways. Other possible values associated with the contract and associated data and consistent with the disclosure will be apparent to those of skill in the art and or through analysis of the attached figures and the disclosure. The figures are not intended to be limiting in any way and only serve to illustrate possible a contract and associated data in one implementation. Other contracts and associated data consistent with this disclosure and the described principles are envisioned.

The business application is any type of application that allows the client to request view add edit delete and or consume content on the client obtained from the server and or an additional content provider not illustrated in response to a received request from the client . A content provider may be for example applications and data on a server and or external services business applications business application servers databases RSS feeds document servers web servers streaming servers caching servers or other suitable content sources.

In some implementations the business application can also use business application data not illustrated including business objects and data business processes content provider locations addresses storage specifications content lists access requirements or other suitable data. For example for a database content provider the business application data may include the server Internet Protocol IP address URL access permission requirements data download speed specifications etc. associated with the database content provider.

Once a particular business application is launched a client may interactively process a task event or other information associated with the server . The business application can be any application program module process or other software that may execute change delete generate or otherwise manage information associated with a particular client . For example the business application may be a portal application a business application and or other suitable application consistent with this disclosure. The business application can also interface with any other suitable component of the example distributed computing system illustrated or not to wholly or partially complete a particular task. For example the described components could process a contract in a sequential parallel and or other suitable manner.

Additionally a particular business application may operate in response to and in connection with at least one request received from other business applications including business applications or other components e.g. software and or hardware modules associated with another server . In some implementations the business application can be and or include a web browser. In some implementations each business application can represent a network based application accessed and executed using the network e.g. through the Internet or using at least one cloud based service associated with the business application . For example a portion of a particular business application may be a web service associated with the business application that is remotely called while another portion of the business application may be an interface object or agent bundled for processing at a remote client . Moreover any or all of a particular business application may be a child or sub module of another software module or enterprise application not illustrated without departing from the scope of this disclosure. Still further portions of the particular business application may be executed or accessed by a user working directly at the server as well as remotely at a corresponding client server . In some implementations the server or any suitable component of server or of the example distributed computing system can execute the business application .

The client may be any computing device operable to connect to or communicate with at least the server and or the server using the network . In general the client comprises an electronic computing device operable to receive transmit process and store any appropriate data associated with the example distributed computing system . The client includes a processor a client application a memory and or an interface .

The client application is any type of application that allows the client to navigate to from request view edit delete and or manipulate content on the client . In some implementations the client application can be and or include a web browser. In some implementations the client application can use parameters metadata and other information received at launch to access a particular set of data from the server and or the server . Once a particular client application is launched a user may interactively process a task event or other information associated with the server and or server . Further although illustrated as a single client application the client application may be implemented as multiple client applications in the client . In some implementations the client application may act as a GUI interface for the business application and or other components of server and or other components of the example distributed computing system .

The network interface is used by the client for communicating with other computing systems in a distributed computing system environment including within the example distributed computing system using network . For example the client uses the interface to communicate with the server and or the server as well as other systems not illustrated that can be communicably coupled to the network . The network interface may be consistent with the above described interface of the enterprise server or other interfaces within the example distributed computing system . The processor may be consistent with the above described processor of the server or other processors within the example distributed computing system . Specifically the processor executes instructions and manipulates data to perform the operations of the client including the functionality required to send requests to the server and or server and to receive and process responses from the server and or the external data . The memory typically stores objects and or data associated with the purposes of the client but may also be consistent with the above described memory of the server or other memories within the example distributed computing system for example external data but storing for example one or more instances of a contract and associated data similar to that stored in memory of server .

Further the illustrated client includes a GUI . The GUI interfaces with at least a portion of the example distributed computing system for any suitable purpose including generating a visual representation of a web browser. The GUI may be used to view and navigate various web pages located both internally and externally to the server view data associated with the server and or external data or any other suitable purpose. In particular the GUI may be used in conjunction with content from server and or external data to provide contract based process integration.

There may be any number of clients associated with or external to the example distributed computing system . For example while the illustrated example distributed computing system includes one client communicably coupled to the server and server using network alternative implementations of the example distributed computing system may include any number of clients suitable to the purposes of the example distributed computing system . Additionally there may also be one or more additional clients external to the illustrated portion of the example distributed computing system that are capable of interacting with the example distributed computing system using the network . Further the term client and user may be used interchangeably as appropriate without departing from the scope of this disclosure. Moreover while the client is described in terms of being used by a single user this disclosure contemplates that many users may use one computer or that one user may use multiple computers.

The illustrated client is intended to encompass any computing device such as a desktop computer laptop notebook computer wireless data port smart phone personal data assistant PDA tablet computing device one or more processors within these devices or any other suitable processing device. For example the client may comprise a computer that includes an input device such as a keypad touch screen or other device that can accept user information and an output device that conveys information associated with the operation of the server or the client itself including digital data visual and or audio information or a GUI as shown with respect to the client .

The previous figures and disclosure illustrate and describe various aspects of computer implemented methods computer readable media and computer systems for providing contract based process integration. While the disclosure discusses the processes in relation to an ordering contract as will be apparent to one of skill in the art the described computer implemented methods computer readable media and computer systems can also be applied to any type of contract of less or greater complexity topic etc. The description is not meant to limit the applicability of the disclosure in any way.

Implementations of the subject matter and the functional operations described in this specification can be implemented in digital electronic circuitry in tangibly embodied computer software or firmware in computer hardware including the structures disclosed in this specification and their structural equivalents or in combinations of one or more of them. Implementations of the subject matter described in this specification can be implemented as one or more computer programs i.e. one or more modules of computer program instructions encoded on a tangible non transitory computer storage medium for execution by or to control the operation of data processing apparatus. Alternatively or in addition the program instructions can be encoded on an artificially generated propagated signal e.g. a machine generated electrical optical or electromagnetic signal that is generated to encode information for transmission to suitable receiver apparatus for execution by a data processing apparatus. The computer storage medium can be a machine readable storage device a machine readable storage substrate a random or serial access memory device or a combination of one or more of them.

The term data processing apparatus refers to data processing hardware and encompasses all kinds of apparatus devices and machines for processing data including by way of example a programmable processor a computer or multiple processors or computers. The apparatus can also be or further include special purpose logic circuitry e.g. a central processing unit CPU a FPGA field programmable gate array or an ASIC application specific integrated circuit . In some implementations the data processing apparatus and or special purpose logic circuitry may be hardware based and or software based. The apparatus can optionally include code that creates an execution environment for computer programs e.g. code that constitutes processor firmware a protocol stack a database management system an operating system or a combination of one or more of them. The present disclosure contemplates the use of data processing apparatuses with or without conventional operating systems for example LINUX UNIX WINDFLOWS MAC OS ANDROID IOS or any other suitable conventional operating system.

A computer program which may also be referred to or described as a program software a software application a module a software module a script or code can be written in any form of programming language including compiled or interpreted languages or declarative or procedural languages and it can be deployed in any form including as a stand alone program or as a module component subroutine or other unit suitable for use in a computing environment. A computer program may but need not correspond to a file in a file system. A program can be stored in a portion of a file that holds other programs or data e.g. one or more scripts stored in a markup language document in a single file dedicated to the program in question or in multiple coordinated files e.g. files that store one or more modules sub programs or portions of code. A computer program can be deployed to be executed on one computer or on multiple computers that are located at one site or distributed across multiple sites and interconnected by a communication network. While portions of the programs illustrated in the various figures are shown as individual modules that implement the various features and functionality through various objects methods or other processes the programs may instead include a number of sub modules third party services components libraries and such as appropriate. Conversely the features and functionality of various components can be combined into single components as appropriate.

The processes and logic flows described in this specification can be performed by one or more programmable computers executing one or more computer programs to perform functions by operating on input data and generating output. The processes and logic flows can also be performed by and apparatus can also be implemented as special purpose logic circuitry e.g. a CPU a FPGA or an ASIC.

Computers suitable for the execution of a computer program can be based on general or special purpose microprocessors both or any other kind of CPU. Generally a CPU will receive instructions and data from a read only memory ROM or a random access memory RAM or both. The essential elements of a computer are a CPU for performing or executing instructions and one or more memory devices for storing instructions and data. Generally a computer will also include or be operatively coupled to receive data from or transfer data to or both one or more mass storage devices for storing data e.g. magnetic magneto optical disks or optical disks. However a computer need not have such devices. Moreover a computer can be embedded in another device e.g. a mobile telephone a personal digital assistant PDA a mobile audio or video player a game console a global positioning system GPS receiver or a portable storage device e.g. a universal serial bus USB flash drive to name just a few.

Computer readable media transitory or non transitory as appropriate suitable for storing computer program instructions and data include all forms of non volatile memory media and memory devices including by way of example semiconductor memory devices e.g. erasable programmable read only memory EPROM electrically erasable programmable read only memory EEPROM and flash memory devices magnetic disks e.g. internal hard disks or removable disks magneto optical disks and CD ROM DVD R DVD RAM and DVD ROM disks. The memory may store various objects or data including caches classes frameworks applications backup data jobs web pages web page templates database tables repositories storing business and or dynamic information and any other appropriate information including any parameters variables algorithms instructions rules constraints or references thereto. Additionally the memory may include any other appropriate data such as logs policies security or access data reporting files as well as others. The processor and the memory can be supplemented by or incorporated in special purpose logic circuitry.

To provide for interaction with a user implementations of the subject matter described in this specification can be implemented on a computer having a display device e.g. a CRT cathode ray tube LCD liquid crystal display or plasma monitor for displaying information to the user and a keyboard and a pointing device e.g. a mouse trackball or trackpad by which the user can provide input to the computer. Input may also be provided to the computer using a touchscreen such as a tablet computer surface with pressure sensitivity a multi touch screen using capacitive or electric sensing or other type of touchscreen. Other kinds of devices can be used to provide for interaction with a user as well for example feedback provided to the user can be any form of sensory feedback e.g. visual feedback auditory feedback or tactile feedback and input from the user can be received in any form including acoustic speech or tactile input. In addition a computer can interact with a user by sending documents to and receiving documents from a device that is used by the user for example by sending web pages to a web browser on a user s client device in response to requests received from the web browser.

The term graphical user interface or GUI may be used in the singular or the plural to describe one or more graphical user interfaces and each of the displays of a particular graphical user interface. Therefore a GUI may represent any graphical user interface including but not limited to a web browser a touch screen or a command line interface CLI that processes information and efficiently presents the information results to the user. In general a GUI may include a plurality of user interface UI elements some or all associated with a web browser such as interactive fields pull down lists and buttons operable by the business suite user. These and other UI elements may be related to or represent the functions of the web browser.

Implementations of the subject matter described in this specification can be implemented in a computing system that includes a back end component e.g. as a data server or that includes a middleware component e.g. an application server or that includes a front end component e.g. a client computer having a graphical user interface or a Web browser through which a user can interact with an implementation of the subject matter described in this specification or any combination of one or more such back end middleware or front end components. The components of the system can be interconnected by any form or medium of wireline and or wireless digital data communication e.g. a communication network. Examples of communication networks include a local area network LAN a radio access network RAN a metropolitan area network MAN a wide area network WAN Worldwide Interoperability for Microwave Access WIMAX a wireless local area network WLAN using for example 802.11 a b g n and or 802.20 all or a portion of the Internet and or any other communication system or systems at one or more locations. The network may communicate with for example Internet Protocol IP packets Frame Relay frames Asynchronous Transfer Mode ATM cells voice video data and or other suitable information between network addresses.

The computing system can include clients and servers. A client and server are generally remote from each other and typically interact through a communication network. The relationship of client and server arises by virtue of computer programs running on the respective computers and having a client server relationship to each other.

In some implementations any or all of the components of the computing system both hardware and or software may interface with each other and or the interface using an application programming interface API and or a service layer. The API may include specifications for routines data structures and object classes. The API may be either computer language independent or dependent and refer to a complete interface a single function or even a set of APIs. The service layer provides software services to the computing system. The functionality of the various components of the computing system may be accessible for all service consumers via this service layer. Software services provide reusable defined business functionalities through a defined interface. For example the interface may be software written in JAVA C or other suitable language providing data in extensible markup language XML format or other suitable format. The API and or service layer may be an integral and or a stand alone component in relation to other components of the computing system. Moreover any or all parts of the service layer may be implemented as child or sub modules of another software module enterprise application or hardware module without departing from the scope of this disclosure.

While this specification contains many specific implementation details these should not be construed as limitations on the scope of any invention or on the scope of what may be claimed but rather as descriptions of features that may be specific to particular implementations of particular inventions. Certain features that are described in this specification in the context of separate implementations can also be implemented in combination in a single implementation. Conversely various features that are described in the context of a single implementation can also be implemented in multiple implementations separately or in any suitable sub combination. Moreover although features may be described above as acting in certain combinations and even initially claimed as such one or more features from a claimed combination can in some cases be excised from the combination and the claimed combination may be directed to a sub combination or variation of a sub combination.

Similarly while operations are depicted in the drawings in a particular order this should not be understood as requiring that such operations be performed in the particular order shown or in sequential order or that all illustrated operations be performed to achieve desirable results. In certain circumstances multitasking and parallel processing may be advantageous. Moreover the separation and or integration of various system modules and components in the implementations described above should not be understood as requiring such separation and or integration in all implementations and it should be understood that the described program components and systems can generally be integrated together in a single software product or packaged into multiple software products.

Particular implementations of the subject matter have been described. Other implementations alterations and permutations of the described implementations are within the scope of the following claims as will be apparent to those skilled in the art. For example the actions recited in the claims can be performed in a different order and still achieve desirable results.

Accordingly the above description of example implementations does not define or constrain this disclosure. Other changes substitutions and alterations are also possible without departing from the spirit and scope of this disclosure.

