---

title: Page server for navigation data
abstract: A page server and method of using the page server is described. The page server stores versioned pages. The pages, which are equally sized data chunks, can be stored with identifiers and version data in a relational database, in separate files, or in a single file where pages are concatenated. The page server may be accessed via SQL, a web interface, a proprietary key/value/version interface on top of TCP/IP, or other method. The page server facilitates incremental updates.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09160817&OS=09160817&RS=09160817
owner: HERE Global B.V.
number: 09160817
owner_city: Veldhoven
owner_country: NL
publication_date: 20130912
---
This application is a continuation under 37 C.F.R. 1.53 b and 35 U.S.C. 120 of U.S. patent application Ser. No. 13 195 974 filed Aug. 2 2011 which claims the benefit of U.S. Provisional Patent Application No. 61 371 191 filed Aug. 6 2010 and entitled PAGE SERVER FOR NAVIGATION DATA. The full disclosure of U.S. patent application Ser. No. 13 195 974 and U.S. Provisional Patent Application Ser. No. 61 371 191 are incorporated herein by reference.

The present invention relates generally to digital map data and more particularly relates to using a page server to update and version database pages containing digital map data.

A navigation application reads data from a geographic database. The data may be next valid character tree NVC data spatial index data full text search data data for map rendering or routing 3D data traffic message channel TMC data point of interest POI data or general metadata. The data may be stored in different data structures that are designed for their use within the navigation application. For example the navigation database standard NDS specifies storing POI data in a relational way and storing data for routing and map display in binary large objects BLOBs .

The geographic database may be located on a client device such as a navigation system. However the client database may have data that is out of date. To obtain current data the client device may request data from an up to date server database. To synchronize the data between an up to date server database and an out of date client database synchronization techniques are needed for all of the different data structures. Moreover the data structures may have special version items that require special treatment.

Despite the different data structures the navigation application typically reads data from the database file in equally sized pages. The pages are created by a database system without regard to which applications will be using the pages. Moreover the database system decides which pages to read in what order to provide the relevant content to the navigation application.

A method and system for serving navigational data as versioned pages without knowing their detailed content is disclosed. The approach has the advantage that it is generally usable and that all kinds of navigational data structures can be modeled on top of it. Not only can this approach be used for incremental map update but also for hybrid navigational applications. Furthermore the presented approach is not limited to synchronizing versioning and updating navigational databases but may also be used for other embedded databases.

These as well as other aspects and advantages will become apparent to those of ordinary skill in the art by reading the following detailed description with reference where appropriate to the accompanying drawings. Further it is understood that this summary is merely an example and is not intended to limit the scope of the invention as claimed.

A page server facilitates the updating and versioning of database pages instead of versioning and updating navigational features. The database pages are stored on the page server and client applications can access these pages and store them locally.

The page server includes a server database and a server interface . The client includes a client database a page access module and a client application module . Data in the server database is typically more current than the data in the client database .

The page server stores pages of data in the server database . The pages are equally sized data chunks. Additionally or alternatively the page server stores a binary difference between a current page and the previous version of the current page in the server database . The page server may also store compressed pages and or differences in the server database . In some applications it may be beneficial to use a rather large page size e.g. 32 Kbytes to reduce the number of page requests.

The server database may be a relational database which allows for easy query and page updates. The data in the server database may be split into different tables allowing the page server to retrieve pages based on SQL. As another example the pages may be stored in the server database as flat files. As yet another example the pages may be concatenated and stored within a single file. Additionally the pages may be stored in the server database in a proprietary manner. Obviously the pages can be stored in many suitable ways.

The server interface may be implemented in many ways such as a commercially available database system or a proprietary database system implementation. For example the server interface may be based on SQL. In this example SQL commands may be issued via database specific jdbc or native modules e.g. for Oracle OCI. As another example the SQL commands may be issued via streamed SQL http en.wikipedia.org wiki StreamSQL . The server interface may also be implemented as a RESTinterface http en.wikipedia.org wiki Representational State Transfer . As yet another example the server interface may be implemented as a specific protocol on top of TCP IP. Other implementation methods are also possible.

The client may be a navigation system located in a vehicle a personal navigation device or a mobile telephone. In this example the client application module includes hardware and or software for providing navigation functions such as route calculation route guidance and map display. Alternatively the client may be another server or a computer that uses and or processes navigation data. For example the client application module may include hardware and or software for compiling navigation data in one or more formats. The client may also be another system that uses an embedded database such as a music player.

The page access module determines whether to read data from the client database or from the page server . The page access module also allows the client to write pages from the page server into the client database . In one example the page access module is a virtual file system layer. In the case of the Navigation Database Standard NDS the page access module is implemented as an SQLite virtual file system http www.sqlite.org c3ref vfs.html .

The communication between the page server and the client is described in a simplified manner as follows. The server interface receives page requests from the page access module . The server interface responds to the page requests by retrieving pages from the server database . The server interface transmits pages to the page access module . In response the page access module stores the pages in the client database and or provides the pages in the client application module .

The server database depicted in includes data that may be used by a navigation system. However the page server may be used to synchronize and update data for all kinds of embedded databases. For example the server database may include data regarding music books movies contact lists and so on. Thus the server database is not limited to storing navigation related data.

The server database may include Next Valid Character Tree NVC data . The NVC data may be composed of small BLOBs binary large objects which contain the next possible characters in a destination input and references to the next NVC BLOB.

The server database may also include spatial index data . The spatial index data may include various types of indexes that relate the different types of data to each other. For example the spatial index structure may be an R tree data structure which allows for indexing multi dimensional information for example the coordinates of geographical data.

The server database may also include full text search data . Full text search denotes a technique for searching computer stored documents. The user supplies search strings and a search engine uses these search strings to match them with the words in documents. For example the full text search data may consist of an n to m relation between the search strings and the documents. For a given query the full text search library typically returns all document IDs that contain the terms supplied in the query.

The server database may also include map data . The map data includes information regarding point line and area features. Point features are used for rendering single points on a map. Line features are used for rendering lines on a map. Area features are used for rendering area shapes on a map.

The server database may also include routing data . The routing data includes a digital representation of the road network including road geometry information such as curvature road width and slope. The routing data may be organized into building blocks to facilitate routing map matching route guidance and advanced driver assistance ADAS applications. For example the routing data of a certain region may be stored in a BLOB while geometry and guidance information may be stored in other BLOBs.

The server database may also include 3D data . The 3D data may include three dimensional models of real world objects a digital representation of ground surface topography or terrain and or satellite and aerial images of the surface.

The server database may also include Traffic Message Channel TMC data . The TMC data is transmitted via the Radio Data System RDS a digital sub channel of standard Frequency Modulation FM radio broadcast. The TMC data includes predefined location codes and event codes. The event information describes the reason for example accident and or effect for example traffic jam of a traffic message. The event code is transmitted in a TMC message and refers to the coded location.

The server database may also include points of interest POI data . The POI data may include point of interest records comprising a type e.g. restaurant hotel city hall police station historical marker ATM golf course and so on location of the point of interest a phone number hours of operation and so on. The POI data may be stored in various relations. One relation may contain category and position of the POI. Another relation may contain more detailed information such as URLs or names of the POIs.

The server database may also include metadata . The metadata includes information on variable database content and database properties. The metadata may be associated with a specific product database a building block or the complete database.

Per the navigation database standard NDS the data in the server database are stored in an embedded relational database such as SQLite http www.sqlite.org . The different data structures e.g. for NVC data spatial index data . . . metadata are stored in relations within SQLite and versioned using a version column. Some of the versioned items may be large e.g. more than 1 MByte for a routing BLOB while others may be small e.g. less than 100 Byte for an NVC BLOB . Furthermore there may be non versioned items such as metadata or some POI attributes which might not be in sync with the versioned data. Due to the complexity of the various data structures it is difficult to create a version concept on top of the SQL columns. To overcome the difficulties of versioning by data type the page server versions by page.

The file is associated with a file identifier a file incremental transaction identifier and optionally a file base version identifier . The file ID describes the content stored in the file . For example FileID 1 may represent routing data from Germany FileID 2 may represent routing data from France File ID may represent name data from Germany and FileID may represent metadata of the Europe Database.

The file incremental transaction ID is set to one or other starting point when the file is created. If the file is incrementally changed i.e. a page is updated or added the FileIncrementalTransactionID is increased. An incremental compiler may be used to change the file incremental transaction ID .

The file base version ID describes when the file was originally created. For example a map developer may release new products periodically e.g. every quarter based on new raw data releases. The FileBaseVersionID is increased every time the file is built from scratch. While the file base version ID may be beneficial for navigation systems this identifier may not be necessary in other systems that use an embedded database.

The page is associated with a page identifier and a page version identifier . The page ID identifies the page within the file . The file is logically divided into equally sized pages . Each page can be accessed directly. For example a file of size 1 GByte having a page size of 1 Kbyte consists of one million pages.

The page version ID is increased every time the page is updated within a transaction. Assume within FileIncrementalTransactionID 2 page n is changed and within FileIncrementalTransactionID 3 page m is changed then page n has the PageVersionID 2 and page m has the PageVersionID 3 whereas all other pages have the PageVersionID 1. Note that the FileIncrementalTransactionID is 3 which equals the maximum PageVersionID in the file.

The server interface uses some or all of the parameters for storing and retrieving versioned pages . For example the server interface may retrieve from the server database all pages of a certain FileID and FileBaseVersionID where the PageID is greater than a certain FileIncrementalTransactionID of the client database . As another example the server interface may update a page in the server database identified by its FileID FileBaseVersionID and PageID . In this example the PageVersionID and the FileIncrementalTransactionID are increased on the page server . Other functions are also possible.

The file has six pages . The second page includes data for the POI associated with ID . The fourth and fifth pages include part of the routing BLOB associated with ID 1. The file starts with version ID 1 original .

In this example the file is modified as follows. When the POI associated with the ID is updated the second page needs to be updated. The second page is completely rewritten and assigned the version ID 2 first revision to the file . In comparison the first page which contains POIs with smaller IDs is not rewritten and still has the version ID 1. Note that a page can contain the content of several POIs.

In the next transaction the routing BLOB with the ID 1 is updated. In order to perform this update the fourth and fifth pages need to be rewritten. Their new page version number is equal to maximum page version number in the file 1 in our example 3. The fifth page may also contain some data of the non updated routing BLOB associated with ID 2. The data of the routing BLOB associated with ID 2 is spread over two pages i.e. the fifth and sixth pages where the fifth page has version ID 3 and the sixth page has version ID 1.

Note that if the POI associated with ID and the routing BLOB associated with ID 1 are updated in a single transaction the second fourth and fifth pages would have version ID 2 while the first third and sixth pages would have version ID 1. Thus the page version number reflects the transaction ID. Stated another way the page version number is identical to the last transaction ID in which the page was changed.

While depicts versions in the tables this versioning is not necessary when using page versioning. Updating and synchronizing a navigational database based on versioned pages rather than on the versioned navigational objects is simpler more efficient more reliable more usable and can be implemented more conveniently. Moreover the page version handling is done in a transparent way to the application.

At block the client receives a request for data. For example a navigation system may request map data for route calculation route guidance and or map display. While a navigation application is running several SQL commands are carried out such as SELECT FROM routingTileTable WHERE id 23423. Using an underlying SQLite library www.sqlite.org arch.html the page access module transforms the SQL commands into a set of page requests.

The client may have access to more than one navigation database file stored in the client database . For example the client may have access to a first file containing data of France and a second file containing data of Germany as shown in Table 1.

To open a file in the client database the client passes at least the URL for the local file e.g. . data Germany.nds to the page access module . The FileID the FileIncrementalTransactionID and the FileBaseVersionID may be contained directly in the file e.g. in the first 100 Bytes of an SQLite file in a look aside file e.g. . data Germany FileInfo.nds or passed along with the URL within the open procedure.

The virtual file system implementation of the page access module now has all information needed to either request pages from the page server or from the local database . Note that the page size and the number of pages are typically stored in the client database e.g. in the first 100 bytes of an SQLite file . If the page size and the number of pages are not stored in the local database file this information may be stored in a FileInfo file or retrieved from the page server .

At block the page access module sends client version information to the page server . The client version information includes the FileID FileIncrementalTransactionID and FileBaseVersionID . The client version information also includes a query regarding whether pages with higher PageVersionIDs or newer file versions are available. In some scenarios the client version information is only sent if an application requests data that is not available on the client database .

At block the server interface receives the information from the page access module and checks whether updated pages and or files are available based on the values of FileIncrementalTransactionID and FileBaseVersionID for the FileID . At block the server interface determines whether new data exists.

At block if the file associated with the FileID has not been updated on the server database the server interface returns an empty result set to the page access module . At block the page access module receives the empty result set. At block the page access module retrieves a page from the local database .

Returning to block if new data is available at block the server interface retrieves a list of PageIDs of pages that have been updated along with the newest FileIncrementalTransactionID from the server database . At block the server interface sends the list of PageIDs of pages that have been updated along with the newest FileIncrementalTransactionID to the page access module . By receiving a list of outdated pages the client may work in a lazy mode requesting the content of the updated pages only when the content is needed by an application. In another example the server interface may immediately retrieve and send the updated pages to the page access module as described at blocks .

At block the page access module receives the list of PageIDs of pages that have been updated along with the newest FileIncrementalTransactionID . The page access module marks the pages associated with the listed IDs as outdated. The information regarding the outdated pages may be stored in the client database in a look aside file or any other suitable data structure such as an SQLite file. If there is a newer FileBaseVersionID the client application module may determine whether it wants to continue using the file associated with the older FileBaseVersionID and download only updated pages associated with the older FileBaseVersionID or whether it wants to download the complete file i.e. all of the pages associated with the newer FileBaseVersionID.

At block the page access module sends a request for downloading the new pages and or files from the server database . If the client application module decides to download the complete file all pages associated with the newer FileBaseVersionID are requested. If the client application module decides to download just the updated pages the updated pages are requested.

At block the server interface receives the request for pages and or files. The server interface retrieves the requested pages and or files from the server database . At block the server interface sends the pages and or files to the page access module .

At block the page access module receives the pages and or files from the server interface . If the page access module receives all of the pages associated with the newer FileBaseVersionID the page access module deletes the older file from the client database and stores the newer file.

If the page access module receives another request for data the page access module determines whether one of the downloaded pages in the look aside file is available. If it is the page is passed to the higher levels of the SQLite engine and is incorporated into the client database . If the file is closed and not all downloaded pages have been incorporated then at the next opening of the file before the page server is contacted for newer information the pages are incorporated into the file and the local FileIncrementalTransactionID is increased. This approach is similar to the write ahead locking approach implemented in SQLite. Thereafter the FileID FileBaseVersionID and the new FileIncrementalTransactionID are sent to the page server again and the method continues at block .

Note that the download of the newer pages could also start as a background routine without waiting for an application request for an outdated page. The pages should only be passed to the upper levels of SQLite if all pages are successfully stored in the client database . Only then can it be guaranteed that the client application module has a consistent version of the data even when no online connection is available.

The size of the SQL result set typically corresponds to the number of read pages. For example if a navigation application reads a routing BLOB only a few index pages and the pages where the routing BLOB is stored are read. As another example if the navigation application does non index supported queries or uses an aggregation function e.g. count then all pages of the database may be read although the result set may consist of only one record. As navigation systems typically do not require these aggregate functions and non index based reads the amount of read data correlates to the number of read pages. Similarly if the page access module updates the client database via an SQL update or SQL insert command only some index pages and some pages containing the inserted and updated data have to be written.

The method is especially beneficial for incremental update when 1 the number of read pages correlates to the amount of data requested by the application and 2 the number of changed pages correlates to the amount of data changed by the application or compiler. As these two conditions especially hold for data managed in a relational database the approach is especially beneficial for updating an NDS database which is based on SQLite.

While the method described how to perform an incremental update on the client database the server database may also be updated in an incremental manner. In this example the client application module is a database compiler located on a server. The server interface receives the FileID and the probably new FileBaseVersionID from the database compiler. The server interface then reads writes pages according to these two parameters from to the page server . The page access module does not necessarily need a local version of the file but can work directly on the pages stored in the server database .

If the server interface writes page 0 and this page does not exist for this FileID and FileBaseVersionID e.g. in the case of a completely new compilation then the FileIncrementalTransactionID is set to 1. In the case of incremental updating the server interface reads the pages from the server database and if it has to write a new page to the server database the server interface writes the new page with the new increased FileIncrementalTransactionID. Note that an incremental compilation is done within one transaction. All pages changed within this transaction receive the same FileIncrementalTransactionID. Thus a client can always download a consistent set of pages.

The method also works for hybrid navigation systems. A hybrid navigation system includes an on board portion and an off board portion. The on board portion is fully functional i.e. the on board portion includes the hardware and software that is located in a standalone on board navigation system. In contrast to the standalone on board navigation system the hybrid navigation system contains a subset of the pages belonging to the database file and a wireless communications link to access additional off board data. The hybrid navigation system is beneficial when the system has limited memory space.

If a page is not locally available the hybrid navigation system requests the page from the page server . Assume that the FileIncrementalTransactionID is n and the page server has two different pages with the page versions of n 3 and n 2. The page server delivers the page with the version n 2 to the hybrid navigation system which is in sync with the other pages in the hybrid navigation system s local database.

If the hybrid navigation system does not have a database file locally and access to the page server is not available due to communication problems the page access module passes a file error to the application requesting the file. The application can handle these errors without crashing. The application may request the file later when a network connection becomes available.

At start up the hybrid navigation system may send its FileID FileBaseVersionID and FileIncrementalTransactionID to the page server asking whether a newer FileBaseVersionID or a newer FileIncrementalTransactionID exists. If a new FileBaseVersionID exists all previously downloaded pages are downloaded again and stored in the local file system. If a new FileIncrementalTransactionID exists only those pages with higher PageID than the local FileIncrementalTransactionID are downloaded.

An interesting feature of a hybrid navigation system is the selective pre loading of the pages via SQL. If a navigation application executes a command such as SELECT FROM POIs NATURAL JOIN POIAttribute WHERE CATID 27 or SELECT FROM RoutingTileTable WHERE ID BETWEEN 12345 and 56768 the hybrid navigation system receives the pages containing the relevant data. Thus it is possible to trigger selective pre loading of pages via SQL tailor made for certain users and or use cases.

The method may be especially useful for systems having very limited hardware. For example shows a platform that includes two central processing units CPUs . For example the platform may be a telematics platform a map positioning engine or other hardware limited device located within a vehicle that uses map data. For purposes of the following description both of the CPUs are too weak to run the light weight SQLite engine.

The first CPU CPU1 has a communications module that facilitates wireless access to systems external from the platform . depicts that the communication module allows the platform to communicate with the page server . The dashed line in separates systems located within the vehicle below the line and systems outside the vehicle above the line .

The second CPU CPU2 runs a process for serving pages via a page server . The page server is a simplified version of the page server . For example the server database in the page server may be a powerful Oracle server containing the versioned pages while the local database in the page server may consist of concatenated pages in one long file. The CPU2 has access to a secure digital SD card and other components within the vehicle.

The CPU1 synchronizes read and write operations to the navigational database stored in the SD card . The CPU1 communicates with the page server outside the vehicle and the page server within the vehicle. The data within the page server typically has more current data than the data within the page server .

To perform a map update the CPU1 requests the FileID FileBaseVersionID and FileIncrementalTransactionID of the database stored on the SD card managed by the CPU2 . The CPU1 queries the page server for up to date pages. If there is new data the page server sends the pages to the communication module which then provides the pages to the CPU2 . The CPU2 stores the pages on the SD card . After all pages of this transaction are stored on the SD card the CPU2 can offer this updated map data to other components within the vehicle.

It is intended that the foregoing detailed description be regarded as illustrative rather than limiting and that the following claims including all equivalents define the scope of the invention. For example while the description provided examples using SQL and SQLite it is understood that other languages and database management systems may be used. The claims should not be read as limited to the described order or elements unless stated to that effect. Therefore all embodiments that come within the scope and spirit of the following claims and equivalents thereto are claimed as the invention.

