---

title: Automatic framework for parallel testing on multiple testing environments
abstract: A web application is tested on multiple testing environments provided by testing appliances. The testing environments are described by a platform, managing an appliance, a browser used for loading the web application, and a browser version. An automatic testing framework is used for handling the parallelized test execution on all of the testing environments. Within the testing framework the testing environments are defined and prepared for the test execution. A consolidated configuration file is generated for the web application's configuration and the tests classes. The testing framework provides a local server to host the web application which is later loaded in the testing environments. The testing framework processes the test and uses a communication with the appliances to send commands and to execute the test on all of the testing environments. A unified test report is generated that accumulates the results from all of the testing environments.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09021438&OS=09021438&RS=09021438
owner: SAP Portals Israel Ltd
number: 09021438
owner_city: Ra'anana
owner_country: IL
publication_date: 20130620
---
A software development life cycle process imposes a structure for the development of software products. There are different models for such processes describing possible approaches for tackling tasks and activities. The activities may include development planning implementation testing preparing the product documentation etc. The life cycle process may be designed with consideration to the type of software product that is developed and specific customers usage. A structured approach for developing applications e.g. a web application may increase the quality of the product the customers satisfaction and the sales revenues. One aspect of delivering web application is the process of comprehensive testing. When discussing web application different software devices with their platforms and installed web browsers are taken into consideration. Desktop computers laptops and mobile devices are generally managed by an operating system. For example a mobile device may have an operating system such as iOS Apple Inc. or Windows Phone Microsoft Inc. or Android Google Inc. . There are a number of browsers that target users of a web application may use when loading the application on a preferred device. The testing process may ensure a consistent user experience with different browsers installed on different platforms.

Embodiments of techniques for an automatic framework for parallel testing on multiple testing environments are described herein. In the following description numerous specific details are set forth to provide a thorough understanding of the embodiments. One skilled in the relevant art will recognize however that the embodiments can be practiced without one or more of the specific details or with other methods components materials etc. In other instances well known structures materials or operations are not shown or described in detail.

Reference throughout this specification to one embodiment this embodiment and similar phrases means that a particular feature structure or characteristic described in connection with the embodiment is included in at least one of the one or more embodiments. Thus the appearances of these phrases in various places throughout this specification are not necessarily all referring to the same embodiment. Furthermore the particular features structures or characteristics may be combined in any suitable manner in one or more embodiments.

In the web applications world the number of platforms browser vendors and versions are increasing at a tremendous pace. More and more devices spread quickly in the market and each device supply a different web browser with a different version. Some of the devices support more than one browser type. In one aspect web developers become challenged to test their web applications which may support vast number of browsers types and versions installed on different platforms and devices in order to supply the customers with high quality products. The web applications may be tested on different platforms both on mobile and desktop devices with browsers having different types and versions e.g. Google Chrome Mozilla Firefox Microsoft Internet Explorer Safari Apple Inc. Opera Opera Software Inc. etc. When testing the application all required devices platforms browsers with different versions etc. may be taken into consideration. Furthermore a developer usually has to pre install and configure each browser and device for test execution. This is hard work which takes lots of time and power. In one embodiment the tests on different device platform browser configurations i.e. testing environments may be executed one after another which may take a lot of time. In another embodiment the tests may be executed automatically in parallel on all the defined required testing environments.

In one embodiment the testing framework may execute a test on all testing environments the testing environment1 testing environment2 testing environment k etc. The execution of the test may happen in parallel against all testing environments i.e. against the combination of a device a platform a browser and a browser version. As a result a unified test report may be generated to accumulate the test results from all of the testing environments .

In one embodiment the testing framework may be an automation framework for web applications which executes automatic tests against unlimited number of browsers in parallel and delivers a unified test report with test status for each browser such as the unified test report . The user may write once an automatic test with a preferred programming language and executes it in parallel against all appliances with the testing environments the user needs and may get one unified report in a short time. The testing environments may be described and differentiated by the type of the devices the platforms the browsers and the browser versions. For example the user may define tests within a tests module in the testing framework . The developer defines in a configuration file which platform browser type and browser version he wants his test to be executed against. Table 1 presents a combination of a platform a browser type and version that may define a testing environment. For example one of the testing environments defined in Table 1 is a computing device having Microsoft Windows as an operating system Internet Explorer 9 as the specific browser used for loading the web application. In one embodiment one or more testing environments may be provided from one appliance. For example appliance is a desktop computing machine having an operating system Microsoft Windows 7 with 3 browsers with different browser version installed Internet Explorer 9 Firefox 17 Google Chrome 26. Therefore on the appliance there are 3 testing environments the first environment is the one defined by the operating system MS Windows 7 Internet Explorer is the browser type and the version of the browser is 9. The second and the third testing environments are accordingly Microsoft Windows 7 Internet Explorer as the browser type with version of the browser 7 and Microsoft Windows 7 Google Chrome as the browser type with version of the browser 26.

Appliance which is a desktop machine provides two testing environments Mac OS Safari browser version 6 and Mac OS Google Chrome 23 version 9. Appliance which is an Apple iPad 2 provides two testing environments iOS 6 Safari browser version 6 and iOS6 Google Chrome version 22. Appliance is an iPhone 5 Apple Inc. providing one testing environment iOS 5.1 browser type Safari browser version 6. The possible appliances that may provide testing environments are not limited to the described exemplary appliances and . One device may provide more than one platform and therefor the number of testing environments provided by that device may exceed proportionally. In one embodiment the testing environments may be provided from real devices or browsers like the example with iPhone 5 with the Safari browser. In another embodiment the devices and browsers may be simulated. For example an Android operating system may be simulated with different screen resolutions and browser versions.

In one embodiment the user may write a test and store it in the tests module. The testing environments and the included browsers may load the web application. The test may be executed against the testing environments provided by the appliances in parallel. In such manner during the test execution each browser that is part of the testing environments is being tested in a different thread with no influence of other browsers threads. As a result from the parallel automatic testing the unified report is generated with test tracking for each browser with the status of the test. If there was an error on some test execution it will be described in detail in the test report.

The file structure of a development project consists of many files including configuration files which define the code sources to be loaded. In addition there are configuration files that also define which test classes to be executed. For example the configuration files may be in an Extensible Markup Language XML format JavaScript Object Notation JSON format etc. The testing framework provides a mechanism to unify the configuration files from the web application and the configuration files that define the test classes to be executed. The unification mechanism may also resolve duplications and dependencies that exist in the configuration files. In one embodiment a consolidated configuration details are generated. Table 2 presents an exemplary consolidated configuration file. The unification mechanism uses an algorithm to explore the development project file structure and to find relevant configuration files and compile them to a new unified configuration file. In one embodiment the user which may be a developer has an option to define which configuration files he wants the mechanism to unify and which not.

In some embodiment browsers are lacking Cascading Style Sheets CSS and Javascript resources and there is a need to pre download them to the testing environment in order to execute tests. In one embodiment the testing framework may automatically identify the target browsers defined in the configuration file and decide if and what resources to download for the test. Due to this process the developer is free of hard work of providing and installing needed resources by the testing environments and more specifically the browsers installed. The web pages of the web application may be hosted on an application server. In one embodiment the web pages may be hosted on a local server . The local server may be a local Hypertext Transfer Protocol HTTP server that may serve the web application on HTTP protocol. The testing framework may automatically launch the local server and publish the web application . If a local server is used then there is no leaning on external HTTP servers because they may be down and out of date with the latest developer code lines. In one embodiment a test from the tests may be executed against both desktop and mobile browsers. The execution of the tests may be an automated process and there may be no difference in the execution flow on different browsers. The testing environments used for the test execution may be provided from the appliances .

In one embodiment the testing framework may have a configuration file where a developer may define testing environments that are targeted for the test execution. The definition of a testing environment may be defined in an XML file and includes details such as but not limited to a device type an operating system a browser type and a browser version. In one embodiment the testing appliances may provide the testing environments. For example appliance1 may correspond to an appliance from the appliances with testing environments in . In one embodiment the configuration file may further include the definition of the test classes from the test targeted for execution on the different testing environments. Table 3 presents an embodiment of an XML file of an exemplary configuration file that includes a list of testing environments and testing classes. In such manner when using the testing framework it may be configured which test classes to be executed on each browser from the testing environments on the testing appliances .

In one embodiment the testing environments defined in Table 3 may be such as the testing environments on appliance1 from testing environment1 to testing environment k . The testing classes defined in the configuration file presented in Table 3 may be defined in the tests module from the testing framework . In one embodiment the testing framework may include consolidated configuration details such as the consolidated configuration details on and the exemplary consolidated details in form of an XML file in Table 2.

The testing framework may further include an identifying module that determines the necessary resources for the testing environments such as testing environment1 through testing environment k on appliance1 . The identifying module may identify the target testing environment and decide if and what resources to download for the test. The identifying modules may take care for pre installing and configuring the required resources on the testing environments. The identification process may be automated so that the process is free from users interactions to determine required resources and manual installation on the appliances . The testing framework communicates with the testing appliances where the testing environments are persisted. The communication between the testing framework and the testing environments may be accomplished through pre installed slave applications one per appliance that may facilitate the communication between the testing framework and each of the testing environments provided by an appliance. In order to control and communicate with the browsers on each appliance from the testing framework a slave application has to be one time installed. The slave application may be compatible with all the devices and platforms that may be defined as testing environments. For example the installation of the slave application may be accomplished manually by a user. The slave application may be written in different programming languages. In one embodiment the chosen programming language for the implementation of the slave application may be related to the appliance that the slave application is installed on.

In one embodiment appliance1 may have a slave application1 that establishes a communication channel with the testing framework and receives commands for the execution of a test from the tests module. In one embodiment the testing framework may send commands to the slave application1 to open a browser from the testing environment1 and to launch the web application which is hosted on the local server . Further the testing framework may send commands related to a specific test that is executed. In yet another embodiment the testing framework may establish communication with slave applications installed on all of the testing appliances to send commands for simultaneous execution of a test. Within a command to the slave application1 the testing framework may suggest execution of the test on all of the testing environments provided by the appliance1 . As a result of the test execution a unified test report may be generated incorporating the results of the tests on all of the testing environments from the testing appliances . Additionally the testing framework may clean the testing environments in a cleaning phase after the test execution in order to delete footprints or leftovers. In such manner the testing appliances may remain clean and ready for new test execution processes.

Some embodiments may include the above described methods being written as one or more software components. These components and the functionality associated with each may be used by client server distributed or peer computer systems. These components may be written in a computer language corresponding to one or more programming languages such as functional declarative procedural object oriented lower level languages and the like. They may be linked to other components via various application programming interfaces and then compiled into one complete application for a server or a client. Alternatively the components maybe implemented in server and client applications. Further these components may be linked together via various distributed programming protocols. Some example embodiments may include remote procedure calls being used to implement one or more of these components across a distributed programming environment. For example a logic level may reside on a first computer system that is remotely located from a second computer system containing an interface level e.g. a graphical user interface . These first and second computer systems can be configured in a server client peer to peer or some other configuration. The clients can vary in complexity from mobile and handheld devices to thin clients and on to thick clients or even other servers.

The above illustrated software components are tangibly stored on a computer readable storage medium as instructions. The term computer readable storage medium should be taken to include a single medium or multiple media that stores one or more sets of instructions. The term computer readable storage medium should be taken to include any physical article that is capable of undergoing a set of physical changes to physically store encode or otherwise carry a set of instructions for execution by a computer system which causes the computer system to perform any of the methods or process steps described represented or illustrated herein. A computer readable storage medium may be a non transitory computer readable storage medium. Examples of a non transitory computer readable storage media include but are not limited to magnetic media such as hard disks floppy disks and magnetic tape optical media such as CD ROMs DVDs and holographic devices magneto optical media and hardware devices that are specially configured to store and execute such as application specific integrated circuits ASICs programmable logic devices PLDs and ROM and RAM devices. Examples of computer readable instructions include machine code such as produced by a compiler and files containing higher level code that are executed by a computer using an interpreter. For example an embodiment may be implemented using Java C or other object oriented programming language and development tools. Another embodiment may be implemented in hard wired circuitry in place of or in combination with machine readable software instructions.

A data source is an information resource. Data sources include sources of data that enable data storage and retrieval. Data sources may include databases such as relational transactional hierarchical multi dimensional e.g. OLAP object oriented databases and the like. Further data sources include tabular data e.g. spreadsheets delimited text files data tagged with a markup language e.g. XML data transactional data unstructured data e.g. text files screen scrapings hierarchical data e.g. data in a file system XML data files a plurality of reports and any other data source accessible through an established protocol such as Open DataBase Connectivity ODBC produced by an underlying software system e.g. ERP system and the like. Data sources may also include a data source where the data is not tangibly stored or otherwise ephemeral such as data streams broadcast data and the like. These data sources can include associated data foundations semantic layers management systems security systems and so on.

In the above description numerous specific details are set forth to provide a thorough understanding of embodiments. One skilled in the relevant art will recognize however that the embodiments can be practiced without one or more of the specific details or with other methods components techniques etc. In other instances well known operations or structures are not shown or described in details.

Although the processes illustrated and described herein include series of steps it will be appreciated that the different embodiments are not limited by the illustrated ordering of steps as some steps may occur in different orders some concurrently with other steps apart from that shown and described herein. In addition not all illustrated steps may be required to implement a methodology in accordance with the one or more embodiments. Moreover it will be appreciated that the processes may be implemented in association with the apparatus and systems illustrated and described herein as well as in association with other systems not illustrated.

The above descriptions and illustrations of embodiments including what is described in the Abstract is not intended to be exhaustive or to limit the one or more embodiments to the precise forms disclosed. While specific embodiments of and examples for the invention are described herein for illustrative purposes various equivalent modifications are possible within the scope of the invention as those skilled in the relevant art will recognize. These modifications can be made in light of the above detailed description. Rather the scope is to be determined by the following claims which are to be interpreted in accordance with established doctrines of claim construction.

