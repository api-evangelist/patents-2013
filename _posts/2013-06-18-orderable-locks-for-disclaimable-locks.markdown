---

title: Orderable locks for disclaimable locks
abstract: Systems and methods of protecting a shared resource in a multi-threaded execution environment in which threads are permitted to transfer control between different software components, for any of which a disclaimable lock having a plurality of orderable locks can be identified. Back out activity can be tracked among a plurality of threads with respect to the disclaimable lock and the shared resource, and reclamation activity among the plurality of threads may be ordered with respect to the disclaimable lock and the shared resource.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09471399&OS=09471399&RS=09471399
owner: International Business Machines Corporation
number: 09471399
owner_city: Armonk
owner_country: US
publication_date: 20130618
---
The present application is a continuation of U.S. patent application Ser. No. 13 422 080 filed on Mar. 16 2012 which is a continuation of U.S. patent application Ser. No. 12 877 141 filed on Sep. 8 2010.

Embodiments of the present invention generally relate to the use of locks in multi threaded execution environments. More particularly embodiments relate to the use of component specific locks that can be disclaimed or backed out of by their owning threads and subsequently reclaimed in the order in which they were disclaimed.

Modern software is typically built from components wherein it can be advantageous to eliminate the need for individual components to be aware of each other s inner workings The components may reside however within a process in which threads holding locks e.g. thread safety synchronization objects can transition program control from one component to another component. Accordingly the thread safety aspects of the various software components can become complex.

In particular components that maintain thread safe data protected by locks may be at risk in scenarios where those components are free to invoke each other s routines. For example deadlocks can arise when threads holding locks on behalf of one component call into other components acquire further locks and then invoke the first component again. This situation can lead to lock acquisitions that are out of the normal order otherwise imposed by each component for any given set of locks. In this scenario any two threads may be likely to deadlock sooner or later.

To avoid the deadlock problem some developers might design their components so as to release any locks acquired on behalf of one component prior to invoking the routines of another component. Conventional locks however are not intended to be or easily used in such a way. Indeed locks typically lend themselves to being held throughout a given procedure performed on a given data set. A data set that is protected by a lock may not be amenable to routines that process information across that data set while calling out to other components during that processing. To implement deadlock safety in such a scenario the lock could be released and reacquired while the data set is traversed. This approach in turn can lead to race conditions typically in unexpected situations where one thread begins accessing the data set while another thread is performing such a release reacquire cycle.

Embodiments may provide for a computer implemented method in which a disclaimable lock having a plurality of orderable locks is identified. The method can include tracking back out activity among a plurality of threads with respect to the disclaimable lock and a shared resource. In addition the method may provide for ordering reclamation activity among the plurality of threads with respect to the disclaimable lock and the shared resource.

Embodiments can also include a computer program product having a computer readable storage medium and computer usable code stored on the computer readable storage medium where if executed by a processor the computer usable code causes a computer to identify a disclaimable lock having a plurality of orderable locks. The computer usable code may also cause a computer to track back out activity among a plurality of threads with respect to the disclaimable lock and a shared resource and order reclamation activity among the plurality of threads with respect to the disclaimable lock and the shared resource.

Other embodiments can provide for a computer implemented method in which back out activity is tracked among a plurality of threads with respect to a disclaimable lock having a plurality of orderable locks wherein tracking the back out activity includes for each disclaiming thread receiving a request to back out of the disclaimable lock from the disclaiming thread. An orderable lock can be created in response to each request to back out of the disclaimable lock wherein the orderable lock may be added to a list of orderable locks associated with the disclaimable lock and designated as a current lock. A recursion count of the current lock may be stored and a back out event can also be issued for each disclaiming thread. The method may also provide for receiving a request from a current thread to reclaim the disclaimable lock. A determination can be made as to whether the current lock of the disclaimable lock is associated with the current thread if the disclaimable lock is not held by another thread. If the current lock of the disclaimable lock is not associated with the current thread the current thread may be forced to wait for a reclamation event. If on the other hand the current lock of the disclaimable lock is associated with the current thread a first orderable lock can be removed from the list of orderable locks associated with the disclaimable lock. In addition a second orderable lock may be designated as the current lock a recursion count of the current thread can be reinstated and ownership of the current lock and thus of the disclaimable lock can be granted to the current thread. The method may also provide for issuing a reclamation event.

Embodiments can also include a computer program product having a computer readable storage medium and computer usable code stored on the computer readable storage medium where if executed by a processor the computer usable code causes a computer to track back out activity among a plurality of threads with respect to a disclaimable lock having a plurality of orderable locks wherein the computer usable code to track the back out activity is to for each disclaiming thread receive a request to back out of the disclaimable lock from the disclaiming thread. The computer usable code to track the back out activity may also create an orderable lock in response to the request the back out of the disclaimable lock add the orderable lock to a list of orderable locks associated with the disclaimable lock designate the orderable lock as a current lock store a recursion count of the disclaiming thread and issue a back out event. In addition if executed the computer usable code can cause a computer to receive a request from a current thread to reclaim the disclaimable lock and determine whether the current lock of the disclaimable lock is associated with the current thread if the disclaimable lock is not held by another thread. If the current lock of the disclaimable lock is not associated with the current thread the current thread may be forced to wait for a reclamation event. If on the other hand the current lock of the disclaimable lock is associated with the current thread a first orderable lock may be removed from the list of orderable locks associated with the disclaimable lock and a second orderable lock can be designated as the current lock. The computer usable code can also reinstate the recursion count of the current thread grant ownership of the current lock and thus of the disclaimable lock to the current thread and issue a reclamation event.

As will be appreciated by one skilled in the art aspects of the present invention may be embodied as a system method or computer program product. Accordingly aspects of the present invention may take the form of an entirely hardware embodiment an entirely software embodiment including firmware resident software micro code etc. or an embodiment combining software and hardware aspects that may all generally be referred to herein as a circuit module or system. Furthermore aspects of the present invention may take the form of a computer program product embodied in one or more computer readable medium s having computer readable program code embodied thereon.

Any combination of one or more computer readable medium s may be utilized. The computer readable medium may be a computer readable signal medium or a computer readable storage medium. A computer readable storage medium may be for example but not limited to an electronic magnetic optical electromagnetic infrared or semiconductor system apparatus or device or any suitable combination of the foregoing. More specific examples a non exhaustive list of the computer readable storage medium would include the following an electrical connection having one or more wires a portable computer diskette a hard disk a random access memory RAM a read only memory ROM an erasable programmable read only memory EPROM or Flash memory an optical fiber a portable compact disc read only memory CD ROM an optical storage device a magnetic storage device or any suitable combination of the foregoing. In the context of this document a computer readable storage medium may be any tangible medium that can contain or store a program for use by or in connection with an instruction execution system apparatus or device.

A computer readable signal medium may include a propagated data signal with computer readable program code embodied therein for example in baseband or as part of a carrier wave. Such a propagated signal may take any of a variety of forms including but not limited to electro magnetic optical or any suitable combination thereof. A computer readable signal medium may be any computer readable medium that is not a computer readable storage medium and that can communicate propagate or transport a program for use by or in connection with an instruction execution system apparatus or device.

Program code embodied on a computer readable medium may be transmitted using any appropriate medium including but not limited to wireless wireline optical fiber cable RF etc. or any suitable combination of the foregoing.

Computer program code for carrying out operations for aspects of the present invention may be written in any combination of one or more programming languages including an object oriented programming language such as Java Smalltalk C or the like and conventional procedural programming languages such as the C programming language or similar programming languages. The program code may execute entirely on the user s computer partly on the user s computer as a stand alone software package partly on the user s computer and partly on a remote computer or entirely on the remote computer or server. In the latter scenario the remote computer may be connected to the user s computer through any type of network including a local area network LAN or a wide area network WAN or the connection may be made to an external computer for example through the Internet using an Internet Service Provider .

Aspects of the present invention are described below with reference to flowchart illustrations and or block diagrams of methods apparatus systems and computer program products according to embodiments of the invention. It will be understood that each block of the flowchart illustrations and or block diagrams and combinations of blocks in the flowchart illustrations and or block diagrams can be implemented by computer program instructions. These computer program instructions may be provided to a processor of a general purpose computer special purpose computer or other programmable data processing apparatus to produce a machine such that the instructions which execute via the processor of the computer or other programmable data processing apparatus create means for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

These computer program instructions may also be stored in a computer readable medium that can direct a computer other programmable data processing apparatus or other devices to function in a particular manner such that the instructions stored in the computer readable medium produce an article of manufacture including instructions which implement the function act specified in the flowchart and or block diagram block or blocks.

The computer program instructions may also be loaded onto a computer other programmable data processing apparatus or other devices to cause a series of operational steps to be performed on the computer other programmable apparatus or other devices to produce a computer implemented process such that the instructions which execute on the computer or other programmable apparatus provide processes for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

Referring now to a scheme of protecting a shared resource in an execution environment in which a plurality of threads can transition program control from one software component to another. In the illustrated example the scheme uses a component specific disclaimable lock having a plurality of orderable locks to track back out activity and order reclamation activity among the threads with respect to the disclaimable lock and the shared resource . Accordingly if multiple threads back out of the disclaimable lock the lock can ensure that the order in which it is reclaimed is the same order in which it was originally held by the threads before they backed out of it. Moreover the illustrated approach can minimize race conditions that may otherwise be induced by software component interactions.

Processing block provides for identifying a disclaimable lock having a plurality of orderable locks. As will be discussed in greater detail in addition to the plurality of orderable locks the disclaimable lock may include a mutex e.g. mutual exclusion lock to be used in ordinary enter leave operations affecting the disclaimable lock and a first event e.g. unload event to be set issued e.g. set a bit value designated for thread synchronization when a component is about to unload enabling instant release of all component specific locks and prevention of the component leaving a process in a state in which the process could hang due to a dangling lock . The disclaimable lock can also include a second event e.g. back out event to be set when a thread backs out of the disclaimable lock a third event reclamation event to be set when a thread reclaims the disclaimable lock and other events as appropriate. Back out activity among a plurality of threads can be tracked in block with respect to the disclaimable lock and a shared resource. In addition illustrated block provides for ordering reclamation activity among the plurality of threads with respect to the disclaimable lock and the shared resource.

As already noted the method may also involve the detection of an unloading of a software component associated with the disclaimable lock and initiating a release of the disclaimable lock and the plurality of orderable locks by the plurality of threads in response to the unloading. The initiating can be accomplished simply by setting a single event that is part of or associated with a disclaimable lock that is specific to that component. By instantly releasing all component specific locks situations in which a component leaves a process in a state in which the process could hang due to a dangling lock can be avoided.

Turning now to one approach to tracking back out activity among a plurality of threads with respect to a disclaimable lock and a shared resource is shown in method . Accordingly portions or all of method may be readily substituted for block already discussed. In the illustrated example a request to back out of a disclaimable lock is received from a disclaiming thread at block . In response to the request an orderable lock can be created at block added to a list of orderable locks associated with the disclaimable lock at block and designated as the current lock at block . Illustrated block provides for storing the recursion count of the disclaiming thread wherein the recursion count can indicate the number of times that the thread has recursively acquired the disclaimable lock i.e. instigated a lock acquisition procedure without instigating a subsequent lock release procedure . The recursion count may therefore be used to ensure that the thread releases the disclaimable lock the same number of times it has acquired the lock. A back out event is issued at block wherein the back out event can cause instruct the disclaiming thread to release the disclaimable lock and one or more threads that are waiting for the disclaimable lock e.g. waiting threads to loop back and attempt to acquire the current lock i.e. the first orderable lock .

If it is determined that the current lock is associated with the current thread block provides for removing a first orderable lock from the list of orderable locks associated with the disclaimable lock block provides for designating a second orderable lock e.g. the former current lock as the current lock and block provides for reinstating the recursion count of the current thread. Acquisition of the current lock can be granted to the current thread at block wherein illustrated block provides for issuing a reclamation event. In one example the reclamation event causes instructs one or more waiting threads to release the first orderable lock loop back and attempt to acquire the current lock i.e. the second orderable lock . Thus other threads executing the software component s code that is associated with a shared resource protected by the disclaimable lock may behave as though the current thread had never backed out of the disclaimable lock. Ordering of lock reclamation can be accomplished via a synchronization object such as an event that is internal to the tracking code of the disclaimable lock s back out reclamation functions. In addition another mutex can guard the lock tracking involved in the above described techniques.

Consider for example a scenario in which graphic widgets are tracked in one list and color schemes for widgets are tracked in another list wherein the widgets may share color schemes and the lists constitute shared resources. Widgets might be used by a particular software component Component 1 as well as by other software components. Moreover another software component Component 2 may be invoked to create and destroy widgets could hold its own locks unknown to Component 1 s developers and may perform other operations unknown to the developers of Component 1.

In this scenario Component 1 might have subroutines e.g. Subroutines A and B that track widgets color schemes and other objects for debugging analysis or other tracking purposes. Subroutine A could run after a widget is destroyed and in addition to removing any destroyed widgets from a widget tracking list also remove any unused color schemes from a color scheme tracking list. Subroutine B may run in other widget or color scheme update contexts and may simply update the widget tracking list to reflect new members or updated colors for the widgets.

Critical sections might conventionally be employed in Subroutine A to keep its tracking structures consistent wherein no locks are held in the outer routines of Component 1 since the use of multiple component specific locks by multiple components could lead to deadlocks during transactions involving either multiple widgets or widget creation or destruction. Thus the threads may perform the following functions shown in Table I on separate processor cores approximately at the times described 

In the above situation thread T1 s failure to update the color scheme tracking associated with a destroyed widget is unresolved under the conventional critical section based approach leading to a memory leak. An approach as described herein on the other hand could employ component specific disclaimable locks rather than relying on critical sections leading to more reliable operation. An example of an associated enhancement is shown below in Table II.

Thus with a modest performance impact to the overall set of operations e.g. 0.1 ms timing difference the illustrated approach enables the replacement of critical sections with component specific disclaimable locks that minimize the risk of deadlocks and of race conditions that can in turn lead to difficult to diagnose problems such as memory leaks.

The cores may be configured to execute various software components such as OS and or application components with multiple threads according to the particular circumstances. Moreover the threads may share the internal cache s not shown of the processor the system memory the memory space of the HDD and other resources such as an SSD solid state disk not shown network resource etc. wherein locks can be used to protect the shared resources. Accordingly the system may be configured to identify a disclaimable lock having a plurality of orderable locks track back out activity among a plurality of threads with respect to the disclaimable lock and a shared resource and order reclamation activity among the plurality of threads with respect to the disclaimable lock and the shared resource as already discussed.

The flowchart and block diagrams in the Figures illustrate the architecture functionality and operation of possible implementations of systems methods and computer program products according to various embodiments of the present invention. In this regard each block in the flowchart or block diagrams may represent a module segment or portion of code which comprises one or more executable instructions for implementing the specified logical function s . It should also be noted that in some alternative implementations the functions noted in the block may occur out of the order noted in the figures. For example two blocks shown in succession may in fact be executed substantially concurrently or the blocks may sometimes be executed in the reverse order depending upon the functionality involved. It will also be noted that each block of the block diagrams and or flowchart illustration and combinations of blocks in the block diagrams and or flowchart illustration can be implemented by special purpose hardware based systems that perform the specified functions or acts or combinations of special purpose hardware and computer instructions. In addition the terms first second etc. may be used herein only to facilitate discussion and carry no particular temporal or chronological significance unless otherwise indicated.

Those skilled in the art will appreciate from the foregoing description that the broad techniques of the embodiments of the present invention can be implemented in a variety of forms. Therefore while the embodiments of this invention have been described in connection with particular examples thereof the true scope of the embodiments of the invention should not be so limited since other modifications will become apparent to the skilled practitioner upon a study of the drawings specification and following claims.

