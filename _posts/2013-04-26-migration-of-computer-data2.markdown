---

title: Migration of computer data
abstract: Migration of computer information. In one example embodiment, a method for migration of computer data includes modifying a volume boot record of a destination volume to a first state in which at least a portion of the destination volume becomes inaccessible to a standard file system, writing one or more snapshots of a source volume to the inaccessible portion of the destination volume while the volume boot record is in the first state, and restoring the volume boot record to a second state in which the inaccessible portion of the destination volume becomes accessible to the standard file system.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09606875&OS=09606875&RS=09606875
owner: STORAGECRAFT TECHNOLOGY CORPORATION
number: 09606875
owner_city: Draper
owner_country: US
publication_date: 20130426
---
This application is a continuation of U.S. patent application Ser. No. 13 481 671 filed May 25 2012 titled BACKUP AND RESTORATION OF COMPUTER INFORMATION which is a divisional of U.S. patent application Ser. No. 12 716 043 filed Mar. 2 2010 titled SYSTEMS METHODS AND COMPUTER READABLE MEDIA FOR BACKUP AND RESTORATION OF COMPUTER INFORMATION now U.S. Pat. No. 8 190 574. Each of the foregoing applications is incorporated herein by reference in its entirety.

Computers and computer networks face a myriad of threats to the information they contain and to their smooth and continuous operation. Backup systems and methods have been proposed for maintaining snapshots of information on a computer or a computer system at any given time. With a backup if the computer system experiences some type of corruption of its stored information the state of the computer can be restored to the point in time when the backup was made.

Computer systems typically maintain sets of files that are stored on various forms of computer media. The locations of the blocks of data on the media that contain the files data are stored in special data structures called file system metadata or simply metadata and these metadata combined with the files own data are collectively called a file system. The blocks of data for an entire file system are often contained within a logical construct called a volume which is a collection of media blocks that may span across one or more media devices. Formatting a volume is a process of writing file system metadata structures to blocks on the underlying volume. File systems generally contain a recognizable portion called a signature within their metadata that makes them recognizable as a file system to an operating system. When the operating system recognizes a file system on a volume the operating system may mount the volume to expose the volume s file contents for use by the system s users and applications. If the operating system cannot recognize the file system on a volume then it will typically indicate that the volume is unformatted unrecognized or a combination thereof. When a volume is unrecognized by the operating system its contents generally cannot be altered by the user unless they format the volume rendering it recognizable or by typical applications.

To protect computer data various techniques have been developed to back up that data. One common backup technique involves the creation of backup copies of files on a per file basis. This technique is often simply called file backup. Many backup procedures use the file system as a starting point and perform the backup by writing the files to a backup storage system. Using this approach individual files are backed up if they have been modified since the previous backup. This file system backup procedure may be useful for finding and restoring a few lost or corrupted files but it may include significant overhead in the form of bandwidth and logical overhead to store information about where each file exists within the file system. In addition complete reconstruction of a storage volume may be difficult using incremental file backups because files that have been deleted may be put back on the volume based on the contents of the incremental backups.

Another technique ignores the individual files and instead backs up the blocks of data of the media on which the file system resides. This technique is often called disk image backup or image backup or block backup because the backup file itself generally contains or represents an image or copy of the entire contents of the volume computer users often loosely call their volumes disks despite the fact that an actual physical media disk may contain more than one volume which is often the case when a hard disk drive contains multiple partitions each partition hosting a volume which may be backed up. In fact with the disk image backup technique the backup itself is generally called a backup image or simply image . Because it backs up the blocks on the media underlying the file system the disk image backup technique backs up both the files data and the file system metadata. File backup does not generally back up the file system metadata. Because the disk image backup technique backs up media blocks rather than files this technique does not necessarily need to be aware of the file system structures or the files contained in the file system. However in practice many disk image backup systems may utilize minimal knowledge of the file system in order to only back up blocks of data that are actually in use on the media ignoring unused blocks.

A disk image backup can be relatively fast because the file structure does not need to be examined. Conversely because there is no coordination with the file system no file changes can be made during the backup copy. In addition retrieving files from the backup copy may be difficult or impossible without restoring the entire volume. Finally while the data transfer may be fast with block copies every block with valid data must be copied resulting in a relatively long process for large volumes e.g. perhaps even days .

If a computer or server crashes or fails or the software becomes corrupted it may become necessary to restore the state of the server to some previously backed up state. Additionally if a user desires to migrate or upgrade from one server to another server the new server must be brought up to the same state with the same information as the server to be replaced. Conventionally the restore process consists of three steps 1 the machine is usually physically shut down 2 a backup of the latest data is created and 3 the data is copied from the backup storage to the storage of the new server e.g. a disk drive used by the server . During this operation a dedicated boot procedure can be used for example boot from a floppy disk and 4 the new server is started.

Between the shutdown and start time neither server performs any useful functions. Also the process of restoring all the files of the server is time consuming. In corporate networks a typical server can have many terabytes of data. With current data transfer rates over networks and from disks restoring this much data may take hours or even days.

Also even an hour of downtime may be considered an extremely long time particularly for many mission critical applications. For example if the server in question is a web server that handles customer requests or sales a period of 16 20 minutes of downtime can result in substantial lost sales.

Systems and methods are needed for an effective backup strategy that is flexible in maintaining multiple accurate backup states and reducing a downtime when both a backup computer and a restore computer are not operational.

In general embodiments of the present invention relate to migration of computer data. At least some example embodiments provide a migration strategy that can perform a migration process while a snapshot process is underway and reduce a downtime when both a source volume and a destination volume are not operational.

In one example embodiment a method for migration of computer data includes modifying a volume boot record of a destination volume to a first state in which at least a portion of the destination volume becomes inaccessible to a standard file system writing one or more snapshots of a source volume to the inaccessible portion of the destination volume while the volume boot record is in the first state and restoring the volume boot record to a second state in which the inaccessible portion of the destination volume becomes accessible to the standard file system.

In the following description elements circuits and functions may be shown in block diagram form in order not to obscure the present invention in unnecessary detail. Conversely specific implementations shown and described are exemplary only and should not be construed as the only way to implement the present invention unless specified otherwise herein. Additionally block definitions and partitioning of logic between various blocks is exemplary of a specific implementation. It will be readily apparent to one of ordinary skill in the art that the present invention may be practiced by numerous other partitioning solutions. For the most part details concerning timing considerations and the like have been omitted where such details are not necessary to obtain a complete understanding of the present invention and are within the abilities of persons of ordinary skill in the relevant art.

Furthermore in this description of embodiments of the invention reference is made to the accompanying drawings which form a part hereof and in which is shown by way of illustration specific embodiments in which the invention may be practiced. The embodiments are intended to describe aspects of the invention in sufficient detail to enable those skilled in the art to practice the invention. Other embodiments may be utilized and changes may be made without departing from the scope of the present invention. The following detailed description is not to be taken in a limiting sense and the scope of the present invention is defined only by the appended claims.

Those of skill in the art would understand that information and signals may be represented using any of a variety of different technologies and techniques. For example data instructions commands information signals bits symbols and chips that may be referenced throughout the above description may be represented by voltages currents electromagnetic waves magnetic fields or particles optical fields or particles or any combination thereof. Some drawings may illustrate signals as a single signal for clarity of presentation and description. It will be understood by a person of ordinary skill in the art that the signal may represent a bus of signals wherein the bus may have a variety of bit widths and the present invention may be implemented on any number of data signals including a single data signal.

Those of skill would further appreciate that the various illustrative logical blocks modules circuits and algorithm acts described in connection with embodiments disclosed herein may be implemented as electronic hardware computer software or combinations of both. To clearly illustrate this interchangeability of hardware and software various illustrative components blocks modules circuits and steps are described generally in terms of their functionality. Whether such functionality is implemented as hardware or software depends upon the particular application and design constraints imposed on the overall system. Skilled artisans may implement the described functionality in varying ways for each particular application but such implementation decisions should not be interpreted as causing a departure from the scope of the embodiments of the invention described herein.

The various illustrative logical blocks modules and circuits described in connection with the embodiments disclosed herein may be implemented or performed with a general purpose processor a special purpose processor a Digital Signal Processor DSP an Application Specific Integrated Circuit ASIC a Field Programmable Gate Array FPGA or other programmable logic device discrete gate or transistor logic discrete hardware components or any combination thereof designed to perform the functions described herein. A general purpose processor may be a microprocessor but in the alternative the processor may be any conventional processor controller microcontroller or state machine. A processor may also be implemented as a combination of computing devices e.g. a combination of a DSP and a microprocessor a plurality of microprocessors one or more microprocessors in conjunction with a DSP core or any other such configuration.

Also it is noted that the embodiments may be described in terms of a process that is depicted as a flowchart a flow diagram a structure diagram or a block diagram. Although a flowchart may describe operational acts as a sequential process many of these acts can be performed in another sequence in parallel or substantially concurrently. In addition the order of the acts may be re arranged. A process may correspond to a method a function a procedure a subroutine a subprogram etc. Furthermore the methods disclosed herein may be implemented in hardware software or both. If implemented in software the functions may be stored or transmitted as one or more instructions or code on a computer readable medium. Computer readable media includes both computer storage media and communication media including any medium that facilitates transfer of a computer program from one place to another.

It should be understood that any reference to an element herein using a designation such as first second and so forth does not limit the quantity or order of those elements unless such limitation is explicitly stated. Rather these designations may be used herein as a convenient method of distinguishing between two or more elements or instances of an element. Thus a reference to first and second elements does not mean that only two elements may be employed there or that the first element must precede the second element in some manner. Also unless stated otherwise a set of elements may comprise one or more elements.

Embodiments of the present invention include methods computing systems and computer readable media for providing an effective backup and restore strategy that is flexible in maintaining multiple backup states and can perform a restore process while the backup process is underway and reduce a downtime when both a backup computer and a restore computer are not operational.

The term boot record as used herein means metadata on a storage medium that makes the storage medium recognizable to an operating system as a storage medium that contains a file structure accessible by file system software. If the boot record contains valid information about the file structure then an operating system can recognize and expose the file structure. This exposure of the file structure contained on a volume s storage medium is called mounting and it is this mounting process that enables users and applications to utilize the files stored on the storage medium using file system software. Thus as a non limiting example a Volume Boot Record VBR is a boot record on a volume that makes the volume recognizable by an operating system as containing a file structure.

The term private block access as used herein means accessing block storage medium through a private Input Output IO interface configured for block accesses that is available to embodiments of the present invention but is not generally available to applications or general operating system processes. Similarly a private block access process is a process that uses one or more private block accesses to perform IO operations to the block storage medium.

The term public block access as used herein means accessing block storage medium through an IO interface configured for direct block access to the block storage medium that is exposed to applications and operating system processes.

The term file access as used herein means accessing a block storage medium through a file system that translates a file access request from applications or general operating system processes to one or more public block accesses.

Embodiments of the present invention deal with disk image backup techniques. Therefore unless specified otherwise references to backup imply backup using a disk image backup technique.

One challenge faced by backup systems is the need to be able to capture the state of the data for all of the blocks on a volume at a given moment without locking or interrupting access to the volume by applications and users despite the fact that the volume may be in use and changes may be in the process of being written to the volume. Techniques to expose such a volume state often called a snapshot state or simply a snapshot without affecting the usability of the volume itself may be referred to as volume snapshot or volume shadow copy techniques. Both of these backup techniques often leverage snapshot technology in order to back up data on in use volumes without interrupting users and applications.

Another challenge faced by backup systems is the need to make periodic backups in order to capture any changes since prior backups. The first time a volume is backed up the resulting backup is typically a file called a full backup image which contains all or all in use blocks on the volume at the time the backup was created. When the next backup of the volume occurs only the blocks of data on the volume that have changed since the prior backup need to be saved. Such a backup is typically called an incremental backup and results in a file called an incremental backup image which contains just those blocks that have changed since the prior backup. A first incremental backup combined with the prior full backup contain all of the data for the blocks on the volume at the time that the first incremental backup was created. The first incremental file is therefore only useful if the full image file is also available. In other words the first incremental file is dependent upon the full image file. Subsequent backups may also be incremental backups each containing just the data for the blocks that were changed since the prior backup and each subsequent incremental image file is dependent upon the incremental image file for the prior backup. A full image file and all of the incremental image files which depend upon it can be called a backup image file chain or simply a chain . Each image file in the chain combined with the image files upon which it depends represents the state of the backed up volume s data at a specific point in time and therefore sometimes each image file in the chain is called a point in time or a recovery point. Mechanisms may be used to enable backup systems to actively track the blocks which change between backups such that the creation of incremental backups does not require a time consuming comparison of the current state of the volume with a prior state but rather a list of the changed blocks is available and is used to determine which blocks are to be saved in the incremental image file. This list makes it possible for such periodic incremental backups to be efficient with both time and storage space.

With contemporary image backup systems when restoring a backup image file that image file and all of the image files upon which it depends must be utilized read from in order to restore the target volume to a state where it contains the same set of blocks as were contained by the source volume at the time the backup was created. In scenarios where the backup contains many billions or even trillions of bytes of data restoring all of that data to the target volume can take an inordinate amount of time potentially many days.

If the source volume of a backup image chain contains a recognized file system then typically when a point in time in an image chain is restored to a target volume the operating system will recognize the data on the target volume as being a recognized file system and will mount that file system. The mounting is the exposure of the file system s file contents for use by applications and users. When the operating system mounts a file system the process of mounting alone can result in changes being written to the volume such as writes to various logs and file system journaling structures on the volume. Also once mounted by the operating system the volume s contents can be easily altered by users and applications. When any such writes occur the state of the target volume s data no longer exactly reflects the state of the point in time data that was restored to the target volume. If the image chain which was utilized for the restore contained points in time that are chronologically younger or newer than the point in time which was actually restored then it is not typically possible to subsequently restore a younger point in time in the same chain to the same target restore volume after it has been mounted by the operating system and altered by writes without losing the data for those writes which occurred after the mount. In other words when a point in time has been restored to a target volume and the target volume has been mounted by the operating system typically it is not possible to then restore additional points in time from the same chain to that restore target volume without the risk of losing data.

If a volume fails ideally the data for that volume s backup s most recent point in time is made available with minimal downtime between the volume failure and the exposure of the last point in time s data for use by users and applications. Because new point in time backups are generally being created for the source volume up until the time that the source volume becomes unavailable due to failure etc. to restore the latest point in time backup conventional image backup systems cannot even begin their restore operation until the source volume has actually become unavailable at which point they can choose the most recent point in time as only then is it determined to actually be the most recent point in time. Conventional image backup systems are not able to restore in advance some of the points in time while the source volume may still be available and then later as a separate restore operation perhaps separated in time by a system reboot . Subsequent points in time in the same chain cannot be restored without risking corruption in between such operations due to the exposure by the operating system of the volume s file system content.

This limitation has made it difficult to preemptively prepare a standby restore volume with the contents of the last point in time that was backed up from the source volume prior to the source volume becoming inaccessible due to failure or other events .

When a mission critical computer system has failed the costs of downtime while a restore is being performed with conventional backup systems to a replacement system can be immense. Even one hour of lost sales due to a failed web server can result in substantial losses. With terabytes of data the downtime can extend to days.

The one or more processors may be configured for executing a wide variety of operating systems and applications including the computing instructions for carrying out embodiments of the present invention.

The memory may be used to hold computing instructions data and other information for performing a wide variety of tasks including performing embodiments of the present invention. By way of example and not limitation the memory may include Synchronous Random Access Memory SRAM Dynamic RAM DRAM Read Only Memory ROM Flash memory and the like.

The communication elements may be configured for communicating with other devices or communication networks. By way of example and not limitation the communication elements may include elements for communicating on wired and wireless communication media such as for example serial ports parallel ports Ethernet connections universal serial bus USB connections IEEE 1394 firewire connections BLUETOOTH wireless connections 802.1 a b g n type wireless connections and other suitable communication interfaces and protocols.

The operational storage and backup storage may be used for storing large amounts of non volatile information for use in the computing system . The operational storage and backup storage may be configured as one or more storage devices. By way of example and not limitation these storage devices may include computer readable media CRM . This CRM may include but is not limited to magnetic and optical storage devices such as disk drives magnetic tapes CDs compact disks DVDs digital versatile discs or digital video discs and other equivalent storage devices. Furthermore the storage devices may include Redundant Array of Independent Disks RAIDS storage systems.

While illustrated as two discrete blocks in those of ordinary skill in the art will recognize that the operational storage and backup storage may actually be resident on the same mass storage device such that a portion of the mass storage device contains operational information for storing software and data used by the computing system and a portion of the mass storage device includes backup information. Furthermore the operational storage may span multiple devices and the backup storage may span multiple devices.

Software processes illustrated herein are intended to illustrate representative processes that may be performed by the systems illustrated herein. Unless specified otherwise the order in which the process acts are described is not intended to be construed as a limitation and acts described as occurring sequentially may occur in a different sequence or in one or more parallel process streams. It will be appreciated by those of ordinary skill in the art that many steps and processes may occur in addition to those outlined in the flowcharts. Furthermore the processes may be implemented in any suitable hardware software firmware or combinations thereof.

When executed as firmware or software the instructions for performing the processes may be stored on a computer readable medium. A computer readable medium includes but is not limited to magnetic and optical storage devices such as disk drives magnetic tapes CDs compact disks DVDs digital versatile discs or digital video discs and semiconductor devices such as RAM DRAM ROM EPROM and Flash memory.

By way of non limiting example computing instructions for performing the processes may be stored on the operational storage transferred to the memory for execution and executed by the processor . The processor when executing computing instructions configured for performing the processes constitutes structure for performing the processes. In addition some or all portions of the processes may be performed by hardware specifically configured for carrying out the processes.

While some of the discussion herein may be directed toward MICROSOFT operating systems such as WINDOWS NT and WINDOWS XP the present invention is not so limited and is applicable to many operating systems. In addition the discussion may relate to managing file and directory structures on storage volumes. Generally file movements are referred to as read accesses and write accesses. It will be understood by those of ordinary skill in the art that other file accesses are possible within the scope of the invention such as for example changing dates on a file changing privileges on a file and changing other file status indicators. Furthermore the discussion generally refers to files. However unless specified otherwise references to files may include files directories and other similar data structures associated with mass storage devices. A volume may include a variety of mass storage devices such as by way of example and not limitation hard disk drives flash drives floppy disks digital cameras music players and similar devices.

As time progresses after time t changes may occur to specific sectors on the target volume . With incremental sector type backup systems when information within a sector is modified the incremental backup is written to include the same information as a corresponding sector on the target volume . As an example if information within a file at sector is modified the incremental backup process creates a copy of the entire sector as structure on the incremental backup including the change to the information within the file in question. If additional changes are made to information within sector the same changes are made to structure on the incremental backup .

As another example perhaps a new file is created and placed in sector . The incremental backup process will copy the contents of the sector to structure of the incremental backup . Any subsequent changes to information in sector will also be made to structure of the incremental backup .

As another example perhaps information is added to previously empty sector on the target volume . The incremental backup process will add the same information to structure of the incremental backup . Any subsequent changes to information in sector will also be made to structure of the incremental backup .

For ease of discussion the incremental backup is illustrated as structures e.g. of the incremental backup corresponding to the sectors e.g. of the target volume . However while the structures of the incremental backup will have the same data size as the sectors of the target volume the structures do not need to be configured on sector boundaries be contiguous or be in the same relative location as the target volume . Thus a structure such as for example structure may include information at various locations within the incremental backup and may be stored at any location within the incremental backup . In other words illustrates a physical arrangement of the target volume but only a logical arrangement of the incremental backup .

With this sector backup process sectors may contain a variety of information such as for example files portions of files and metadata such as directory structures and file pointers. In addition it does not matter how many times information in a sector changes only the last result at the time that an incremental backup is created and is stored. Thus if incremental backups use a shadowing process the shadow copy keeps a coherent image of the changes that are made to the volume as the changes are made. Then to create an incremental backup a time point is defined. The shadow copy is saved as the incremental backup at that time point and a new shadow copy is created showing no changes but ready to be modified with changes that occur after the time point.

After the base image has been created incremental images may be created. As shown in an incremental image includes changes to a volume that occur after a specific point in time. Thus incremental backup includes all sectors that have changes after time t and up to the time t of incremental backup .

Similarly incremental backup includes all changes made to sectors of the volume after the point in time that incremental backup was created and up to the time t of incremental backup . The process of creating incremental backups may be repeated indefinitely up to incremental backup N.

Consequently one of the problems with creating long backup chains is that the base image must be combined with a large number of intervening incremental backups to get a true picture of the volume. As a non limiting example suppose a base image is created on a first day. Then each subsequent day two incremental backups are made at different times. After a couple of weeks there would be 28 or more incremental backups that would need to be combined with the base image to create a full picture of the target volume after those 14 days.

On the other hand because of the large size of a base image and the relatively long time to create a base image creating base images more often also may be difficult. In addition for security and redundancy reasons many organizations maintain a copy of backups at remote sites. With remote site storage the target volume can still be recovered if the base image or the incremental backup images are removed from the local site. For example backup information at local sites may be removed periodically to allow for more storage space at the local site. In addition a hardware or software failure may corrupt data on the local volume or otherwise prevent access to the local data. In these cases the backup information can be retrieved from the remote site to restore the state of the local volume.

Thus a balance must be struck between the time storage and communication issues associated with a base image relative to the processing time associated with long incremental backup chains.

Embodiments of the present invention can reduce the length of the incremental backup chain by creating synthetic base images. As a non limiting example in synthetic base image may be created by combining all the information from base image incremental backup incremental backup and incremental backup . Thus synthetic base image becomes a complete base image at time t. Now to get a true picture of the volume at time t the restoration process could use synthetic base image as a starting point rather than the base image . As a result a true picture of the target volume at time t may be obtained by combining synthetic base image with the changes made between time t and t that are reflected in incremental backup .

Similar to synthetic base image synthetic base image may be created by combining the base image with all of the incremental backups . As a result synthetic base image represents a base image e.g. a full backup at time t. While not illustrated in those of ordinary skill in the art will recognize that synthetic base image also may be created by combining the information from synthetic base image with incremental backup and incremental backup . In the end synthetic base image should contain the same information through either combination process.

As a non limiting example synthetic incremental backup may be created by reflecting all the changes made between incremental backup and incremental backup . Thus incremental backup incremental backup and incremental backup are combined to create synthetic incremental backup . Similarly synthetic incremental backup may be created by combining the information from incremental backup and incremental backup .

Many combinations are possible for creating synthetic incremental backups. Furthermore synthetic incremental backups may be used to create other synthetic incremental backups. As non limiting examples synthetic incremental backup may be created by combining the information from synthetic incremental backup and synthetic incremental backup .

As additional non limiting examples synthetic incremental backups may be combined with individual incremental backups. In synthetic incremental backup may be created by combining the information from synthetic incremental backup and incremental backup . Thus synthetic incremental backup includes all the information on changes made to the volume between times t and t. Similarly synthetic incremental backup may be created by combining the information from synthetic incremental backup and incremental backup .

With synthetic incremental backups created the backup and restoration process may be configured to delete intermediate incremental backups or may keep the intermediate incremental backups. For example with synthetic incremental backup created incremental backups through could be deleted. However if they are deleted some time granularity may be lost. In other words if information is to be restored information could be obtained at time t or at time t but information at times t and t is no longer available.

On the other hand if the original incremental backups are retained along with the synthetic incremental backups full time granularity can be maintained and the incremental chain used to restore information at a point in time can also be reduced.

As a non limiting example if information is to be restored for time t a number of optional chains are available based on the synthetic incremental backups created in . One chain could be using base image in combination with incremental backups . Another chain could use base image in combination with synthetic incremental backup and synthetic incremental backup . Another chain could use base image and the combination of synthetic incremental backup synthetic incremental backup and incremental backup . Still another chain could use base image in combination with synthetic incremental backup and incremental backup . Those of ordinary skill in the art will recognize that many other combinations of incremental backups and synthetic incremental backups may be used.

The kernel mode includes lower level operating system functions such as a computing file system logical volume control and device drivers for the various hardware devices in a system. The operating system and user applications may make file Input Output I O requests in the form of read accesses and write accesses also referred to as access requests to the computing file system .

The computing file system passes these access requests on to the logical volume control to determine what disk s and what sector s on the disk s should be accessed to perform the access request. Local disk requests are made to a port module that converts the disk request into the necessary hardware controls to retrieve or store the desired data. Of course as stated earlier a disk may include multiple logical volumes on different partitions of the disk.

The disks may be a variety of devices such as magnetic disks optical disks solid state disks Universal Serial Bus USB drives and the like.

Each volume includes a volume boot record and a data segment . The volume boot record of a volume may include a jump instruction to code that may be used in determining information about the volume . The volume boot record of a volume may also include a Basic Input Output System BIOS parameter block to give details about how to perform input output operations for the volume . The volume boot record also gives information about the volume such as size and file system type such as for example Linux FAT16 FAT12 FAT32 NTFS and the like. When an OS recognizes valid information in the volume boot record the OS can mount the volume which makes the data segment available to IO accesses from other OS processes and user applications.

If the volume is an active boot volume A after processing the MBR the OS jumps to the beginning of the volume boot record of the boot volume A. The OS uses the jump instruction at the beginning of the volume boot record of the boot volume A to jump to a process for completing the boot process and loading of the OS. As part of the process the OS uses the MBR to find data volumes A and B determine if they are valid and mount them if they are valid.

Some embodiments of the present invention may invalidate the volume boot record of a volume and create a private structure for the volume boot record . With an invalid volume boot record the OS may still know that the volume is present using the information in the MBR but it cannot get information about the file system on the volume and will therefore not mount the volume . With the volume unmounted no file accesses to the volume can be made by the standard file system of the OS. As a result no writes can be made to the volume under normal file access control and writes to the volume may be limited to embodiments of the present invention.

The volume boot record is shown in an exploded view showing various bytes of the volume boot record to show details of the volume boot record . A boot segment of the volume boot record includes the information necessary for the OS to recognize the volume as including a valid file system. In this boot segment is set to all zeros which invalidates the volume from the perspective of the OS. In other words the OS may view the volume as an unformatted volume. The volume boot record may include other information useful to the OS which may or may not be set to zeros as indicated by the X in some of the bytes.

While zeros in the boot segment cause the volume to be unrecognizable to the standard file system of the OS the volume boot record also includes a special boot identifier SBI . This special boot identifier can be read by a private block access in a special OS or a special file system within the standard OS as is explained more fully below with reference to . This special access path is generally referred to herein as a private block access. However other special systems not necessarily performing a restore operation may be defined to use the special boot identifier as described herein.

The private block access can read the volume boot record and even though it sees zeros in the volume boot record it can look at another area of the volume boot record in an attempt to find the special boot identifier . In the example shown in the special boot identifier is shown in the last few bytes of the volume boot record . Of course the special boot identifier may be different sizes and at different locations with the volume boot record as long as the private block access knows where to find it within the volume boot record . The private block access then knows that the balance of the restore volume is available for a restore process as explained below with reference to .

Also shown in is a restore information block . The combination of the special boot identifier and the restore information block comprise a set of restore metadata that may be used by a restore process. The restore metadata may include a variety of information such as for example information related to a restore process for the volume .

As a non limiting example the restore metadata may include 1 the special boot identifier 2 a volume identifier 3 checkpoint information and 4 a validation block. The special boot identifier has been discussed above.

The volume identifier may be included to indicate for which volume the restore metadata is being used. In volumes where the restore metadata is stored on the volume the volume identifier is implicit. However the restore metadata may be stored in a file on another volume with only a pointer to the restore metadata existing in the special boot identifier. In the case of a file the volume identifier explicitly identifies which volume the restore metadata is for.

The checkpoint information may include various information about where in the restore process the current restore volume is as will become more apparent from the discussion of the restore process with reference to . Non limiting examples of checkpoint information include a most recently applied image file e.g. point in time such as base image or incremental backup image progress within the current image file time stamps including data and time bytes within the current image applied so far and total bytes within the current image.

The validation block may include information to verify that the restore metadata has not been corrupted using for example a checksum or a hash function. A hash function provides a small digital fingerprint from any kind of data input. By chopping and mixing the original data the hash algorithm can create a small hash value that is unique to the data run through the hash algorithm. The resulting fingerprint is often called a hash value. One property of a hash value is that if two hash values generated with the same hash algorithm are different then the two inputs are different in some way. As a result a hash function can be used as a checksum such that the relatively small hash value can be used to verify that a data file of any size has not been altered.

In this boot segment is set to represent the small file structure . Thus when the OS examines the volume it will determine that the volume is small and as a result the sectors of the volume not occupied by the small file structure will be inaccessible by the OS and other applications.

However as with the embodiments of the volume boot record or a file within the small file structure also includes a special boot identifier SBI . This special boot identifier can be read by a private block access in a special OS or a special file system within the standard OS as is explained more fully below with reference to . This special access path is generally referred to herein as a private block access. However other special systems not necessarily performing a restore operation may be defined to use the special boot identifier as described herein.

The private block access can read the volume boot record and even though it sees a small file structure it can look at another area of the volume boot record or a file on the small file structure in an attempt to find the special boot identifier . In the example shown in the special boot identifier is shown in the last few bytes of the volume boot record and as a file at the end of the small file structure. Of course the special boot identifier may be different sizes and at different locations as long as the private block access knows where to find it. The private block access then knows that the balance of the restore volume not taken up by the small file structure is available for a restore process as explained below with reference to .

Also shown in is a restore information block . The combination of the special boot identifier and the restore information block comprise a set of restore metadata that may be used by a restore process. The restore metadata may include a variety of information as explained above with reference to .

Access to block media may be in the form of public accesses which are generally exposed to applications through software processes within the operating system file system or combinations thereof. Accesses to block media may also be through private channels set up by specialized software processes that are not exposed to other applications. These private and public access channels may also be referred to as IO control interfaces IOCTLs .

The private channels may be set up as a software process operating at an application level to perform direct block access in a manner that is private from other applications by a private block access process . The private accesses may also be set up using a software process operating as a block device filter below the file system .

Due to these many channels there may be many ways to access the block media . Each of the channels shown in is discussed below. Operations to block media are generally referred to as accesses and may be understood to include both read and write operations. From a file centric perspective file accesses are generally considered public. The file system may convert a public file access to one or more public block accesses C to access the block media and collect the necessary information to assemble the contents of a file which is then passed back to the application making the access request.

In some embodiments of the invention the block device filter may reside below the file system and filter out or pass through the public block accesses C from the file system . If a public block access C is allowed to pass through it is presented to the block media as a public block access A.

From a block access perspective an application may directly access block media in block form rather than file form through software processes exposed by the operating system as indicated by public block accesses A and B . An application may also set up its own private block access process to perform private block accesses D and E.

In embodiments that include a block device filter the public block accesses B may be blocked or may be passed on as public block accesses A. Similarly private block accesses D may be blocked or may be passed on as private block accesses B. In describing embodiments that use the block device filter public block accesses B are performed rather than public block accesses A because the block device filter can filter all accesses to the block media and public block accesses A would not be available. Similarly private block accesses D are performed rather than private block accesses E because the block device filter can filter all accesses to the block media and private block accesses E would not be available.

In embodiments that do not use a block device filter public block accesses A and private block accesses E are available whereas public block accesses B and private block accesses D are not available. Public file accesses will generate block accesses C directly not shown to the block media .

In embodiments that invalidate a volume boot record as discussed above a block device filter is not needed however some embodiments may use both invalidation of the volume boot record and the block device filter to prevent undesired accesses to the block media . Thus when using an invalidated boot record a restore process may prevent a restore volume or a portion thereof from being recognized by a standard file system by inserting a restore structure in at least a portion of the volume boot record of the restore volume using a block access A or E which may be through a public channel A or a private channel E. The restore structure may be used by the restore process to hold various metadata related to the restore process and at the same time causes the restore volume to be unrecognizable by the file system .

After the restore structure is present in the volume boot record of the restore volume the restore process may use public block accesses A or private block accesses E to write restore data to restore volume. Normal public file accesses are prevented to the restore volume because the volume boot record is unrecognizable so the restore volume cannot be mounted. After all the restore data is written to the restore volume the block accesses A or E are used to the restore volume to finalize it by restoring the volume boot record to a state indicating that the restore volume is valid.

In embodiments that use a block device filter the volume boot record may not need to be invalidated however some embodiments use both invalidation of the volume boot record and the block device filter to prevent undesired accesses to the block media . The block device filter prevents public block accesses B from applications and public block accesses C from reaching the block media as public block accesses A. Only private block accesses D passed through the block device filter as private block accesses B and private block accesses E are allowed to access the block media . Thus the block media is effectively prevented from being modified except through the block device filter or private block control which are used by the restore process.

To perform the restore process the restore volume or a portion thereof is prevented from undesired changes by the block device filter preventing public media accesses e.g. public file accesses public block accesses B and public block accesses C to the restore volume and allow private block accesses D and E to the restore volume. The restore process may use private block accesses D and E to write restore data to the restore volume while the public media accesses B and C are being prevented. After all the restore data is written to the restore volume the block device filter may be removed or reconfigured to allow public media accesses B and C to finalize the restore volume.

Backup images may be communicated between the backup computer and the restore computer via a communication link . This communication may be accomplished in a number of ways. As non limiting examples the backup images may be communicated electronically across a wide area network WAN or a local area network LAN .

As stated earlier base images may be quite large. Therefore as other non limiting communication examples the base image incremental images and combinations thereof may be placed on media such as a magnetic media or an optical media and physically transported by any appropriate transportation element from the local site to the remote site. Furthermore prior to communication either electronically or by transport the base image may be compressed to reduce the size of the image or encrypted for security.

As mentioned earlier performing a restore process when a computer has failed may be an extremely long process when terabytes of data are involved. In addition when migrating data from one computer to another e.g. in an upgrade it may be difficult to have both the old computer and the upgrade computer down for the entire time required to perform a restore process.

In conventional restore systems a final backup would need to be made on the old computer and then access to that old computer prevented so that the new computer can be restored to a same and coherent state with the old computer. Thus conventionally restore processes have been performed overnight or on weekends to minimize the impact of downtime on the users. For example a server with terabytes of data may take 18 to 24 hours or even longer to restore if the restore process can restore 1 GB per minute. In addition restore processes are generally not completely automated and must be monitored by a system administrator. If any problems with the restore occur the entire restore process may need to be started from the beginning creating even more downtime.

Embodiments of the present invention use the invalidated volumes discussed above to perform a headstart restore process wherein a restore may begin on a new machine while the old machine is still operating in its normal mode performing its usual functions and incremental backup functions as explained above.

By marking a volume as invalid to the operating system the OS and user applications cannot modify that volume. However a private block access operating separate from or in combination with the OS can recognize the invalid volume and begin restoring backup files from the old computer on the new computer while the old computer is still running.

The restore process can continue with incremental backups until the new computer is restored to the same state as the old computer was at the last incremental backup. Then a final incremental backup can be performed on the old computer and the old computer is shut down to prevent any further changes. Then only the final incremental backup needs to be restored on the new computer and the invalidated volume can be finalized and exposed to the operating system.

In operation of the backup process a base image of the volume to be backed up is created. Decision block determines if a restore process should be started on this or another computer. If so operation sends any backup files that have not yet been sent to the computer performing the restore process . If it is the same computer the sending may simply be pointers to the backup files. If no incremental images have been created only the base image would be sent. On subsequent cycles through the loop of backup process incremental images may be sent from the backup process to the restore process as they become available.

Decision block tests to see if it is time to create a new incremental backup at a new point in time. If not the backup process loops back to decision block . If it is time for a new incremental backup operation performs the incremental backup.

Operation block creates a synthetic incremental backup if desired and as discussed above with reference to . Operation block creates a synthetic base backup if desired and as discussed above with reference to .

Decision block tests to see if completion of a restore process is desired. In the case of a migration this test may occur at any user defined time based on when it may be convenient to have both the backup computer and restore computer unavailable while a final incremental backup is restored. In the case of a catastrophic failure that failure would prompt the decision to complete the restore process.

If a completion of the restore process is not desired the backup process loops back to decision block . If a completion of the restore process is desired operation sends the final backup to the restore process . Of course in the case of a catastrophic failure the final backup may not be made and the last completed incremental would have to be used as the restore point. After a final incremental is sent the backup process ends.

The restore process may begin concurrently with the backup process any time after the base image has been received by the restore process . To begin operation invalidates the volume to be restored as discussed above with reference to . As stated above since the volume is inaccessible and unrecognized by the standard file system the volume may be a boot volume or a data volume. Operation copies the available backup images that have been sent from the backup process to the invalidated volume. Decision block tests to see if it is time to complete the restore process . As stated above this may be a user selected time or a forced time due to a catastrophic failure. If the restore is not to be completed at this time the restore process loops to operation to restore more backup images if they are available. If the restore is to be completed operation finalizes the volume to make it recognizable by the standard file system.

Optionally operation may mount the restored volume so that the standard file system can access it. Optionally operation may reboot the system if the restored volume is a boot volume. Upon rebooting the MBR may point to a now valid volume boot record on the newly restored boot volume so the system can boot up from the restored boot volume.

Alternatively operations and may be postponed. As a non limiting example the restore system may have multiple volumes that need to be restored. It may be desirable to wait until all the volumes have been restored before exposing the restored volumes to the standard file system mounting the volumes or a combination thereof.

In many modern systems a disk a volume or a combination thereof may be virtually represented by a file that appears to the system through APIs or other means as a conventional physical volume. Embodiments of the present invention may be used on such virtual volumes as explained above. In addition the file that emulates the virtual volume may be write protected or hidden from the standard file system as a way to invalidate the virtual volume from the perspective of the standard file system.

Of course the backup and restore processes may also operate as discussed above with reference by operating within one of the virtual machines to access the virtual disks .

Although this invention has been described with reference to particular embodiments the invention is not limited to these described embodiments. Rather the invention is limited only by the appended claims which include within their scope all equivalent devices or methods that operate according to the principles of the invention as described.

