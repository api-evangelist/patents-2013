---

title: System and methods for tracing individual transactions across a mainframe computing environment
abstract: A performance management system is provided for monitoring performance of an application across a distributed computing environment, including within one or more mainframe computers. In the mainframe environment, a transaction manager is configured to receive a transaction request from an application executing remotely from the mainframe computer. An event agent is invoked via a user exit by the transaction manager and operates to detect events caused by the handling of the transaction by the transaction manager. Upon detecting such events, the event agent generates event messages for select events associated with the transaction, where the event message includes identifying information for the transaction. A translator agent is configured to receive the event messages from the event agent and transmit the event data record to a server located remotely from the mainframe computer, where the event data record includes the identifying information for the transaction.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09311214&OS=09311214&RS=09311214
owner: Dynatrace LLC
number: 09311214
owner_city: Detroit
owner_country: US
publication_date: 20130605
---
This application claims the benefit of U.S. Provisional Application No. 61 731 008 filed on Nov. 29 2012. The entire disclosure of the above application is incorporated herein by reference.

The present disclosure relates to tracing and monitoring of individual transactions performed by software applications across computing boundaries including a mainframe computing environment.

Object oriented and bytecode based software development platforms including the Oracle JAVA platform and the MICROSOFT.NET platform have gained wide acceptance for developing enterprise class software applications. Bytecode based software provides cross platform and cross language compatibility and eases the networked integration of software applications.

Remote method invocation available for the platforms like Oracle Remote Method Invocation RMI and the MICROSOFT.NET Remoting system and messaging services like the Oracle JAVA Messaging Service JMS or the MICROSOFT Messaging Queue ease the creation of distributed and loosely coupled architectures.

Approaches like service oriented architecture SOA use these features to provide flexible application architectures which can be adapted to rapidly changing market demands.

Albeit this flexibility eases building and updating the functionality of applications it constitutes a challenge for conventional performance monitoring and tracing tools which traditionally consider the scope of an isolated application. Most existing tools are not prepared to trace transactions over the borders of threads or different virtual machines. Following the execution path of a transaction over the borders of threads processes or different host systems is essential for tracing complete end to end transactions which may be processed by a chain of different application servers that may communicate in various ways. Therefore it is desirable to develop methods for tracing transactions across computing boundaries including a mainframe computing environment and preferably without modifications to source code on any monitored platforms.

Information that depicts the different processing stages on different application servers and provides specific performance information for the processing stages is a precondition for performance analysis of distributed applications. To provide such information it is required to correlate isolated trace information acquired from the different servers participating in a transaction to depict a consistent end to end transaction. The ability to trace transactions across multiple application execution environments including both distributed and mainframe environments provides end to end visibility for the entire span of the transaction and thereby allows IT departments to locate precise cause of a slowdown in their application.

This section provides background information related to the present disclosure which is not necessarily prior art.

The drawings described herein are for illustrative purposes only of selected embodiments and not all possible implementations and are not intended to limit the scope of the present disclosure. Corresponding reference numerals indicate corresponding parts throughout the several views of the drawings.

In an exemplary embodiment the application may be running within a virtual machine such as a JAVA virtual machine on a web server. An agent is injected into the virtual machine which intercepts the loading of original bytecode performed by the native loader and captures the original bytecode. Each agent is provided with a unique agent identifier which is added to messages sent by the agent and thus allows distinguishing messages received from different agents. The captured bytecode is sent to an instrumentation engine. The captured bytecode may be sent via a computer network to the instrumentation engine. The instrumentation engine extracts meta data from the received original bytecode. The metadata is used to identify and select the parts of the original bytecode which are augmented with sensor code. The bytecode parts include but are not limited to class definitions method definitions and constant pools. The selection of the bytecode parts may be based on explicitly specified method and class names identifying single methods or classes or it may use a rule based system where one rule may match multiple classes or methods. Sensor code is placed in the selected parts of the original bytecode and the instrumented byte code is sent back to the agent which forwards the instrumented bytecode to the bytecode loading process of the virtual machine which loads the instrumented bytecode instead of the original bytecode. Other techniques for instrumenting applications running in a virtual machine are also contemplated by this disclosure.

The instrumentation engine instruments methods which should be monitored with entry sensors to detect invocations of monitored methods and exit sensors which detect when execution of monitored methods is finished. Exit sensors detect both normal method exits and exits caused by an unhandled exception. It should be noted that a distinction between both exit types is necessary for a monitoring system to provide correct monitoring information but this distinction does not foster the understanding of the present disclosure and is thus omitted here.

The instrumentation engine can also place tagging sensors in methods initiating an interaction with other threads or virtual machines like methods sending synchronous or asynchronous messages using messaging oriented middleware methods preparing network messages representing remote message invocations or methods initiating an interaction with another thread within the same virtual machine. Those tagging sensors extract correlation information from the thread local storage which is created by entry sensors and store it in a place where it is accessible for the target threads. Placement of tagging sensors may also include insertion of additional member variables via bytecode manipulation to store the extended correlation information.

Additionally tag extraction sensors are placed in methods that receive interactions from other threads like methods receiving synchronous or asynchronous messages methods receiving messages representing remote method invocations or methods starting a new thread. Those methods are subsumed here as thread activation methods. Tag extraction sensors build the counterpart to tagging sensors. The tag extraction sensors store received correlation information within the thread local storage where it is accessible for other sensors. These different types of sensors are referenced generally as agent in .

During operation agent detects invocation of select methods and generates an event message regarding the invoked methods. The event messages are in turn sent via a computer network to the correlation engine . In some instances the application may spawn a transaction request which is to be serviced by the mainframe computer . For example the application may query a database hosted on the mainframe computer. In these instances the agent also sends an event message across the network to the correlation engine where the event message indicates the initiation of a transaction request and is tagged with information that uniquely identifies the execution path which spawned the event message referred to herein in as non mainframe tag . The mainframe computer may also be instrumented in a manner which generates event messages regarding invocations made on the mainframe as will be further described below.

The correlation engine is configured to receive event messages from different sensors throughout the distributed computing environment including the mainframe computer . Correlation of event messages by the correlation engine is based on information that uniquely identifies execution paths which spawn the event messages. For each agent correlation is based on information that uniquely identifies the agent and or the execution path. Correlation information is transferred from a monitored thread to other threads that are activated by the monitored thread and thus allows for correlation of related threads by the correlation engine . For further details regarding such correlation and an exemplary performance management system reference may be had to U.S. Pat. No. 8 234 631 which is incorporated in its entirety herein by reference.

Different communication techniques may be used to communicate the transaction request from the application to the transaction manager . For example message queuing may be used to transmit the request from the application to the transaction manager operating in the mainframe environment as shown in . More specifically a queue manager is configured to receive the transaction request from the application and operates to place a transaction into a message queue . The transaction manager in turn retrieves the transaction from the message queue for subsequently processing. In an exemplary embodiment message queuing may be implemented using the WebSphere MQ message oriented middleware although other implementations are contemplated by this disclosure.

In another example the transaction request from the application may be received by a transaction gateway such as the CICS Transaction Gateway shown in . The CICS transaction gateway in turn passes the requests to the transaction manager . In particular the CICS transaction gateway may pass the request using either the IP interconnectivity protocol IPIC or the external CICS interface EXCI . Other techniques for communicating the transaction request from the application to the mainframe computer such as transmitting the request using Simple Object Access Protocol SOAP are also contemplated by this disclosure. In this example the event agent is interfaced with the transaction manager and sends event messages directly to the correlation engine . It is understood that the event agent may be interfaced with an event manager and a translator agent as shown in and further described below.

User exits are also used to transfer control to the event agent for other types of application events as well. Various application events can be caused during the handling of a transaction request from the application . Select application events are monitored and detected at by the event agent . A listing of exemplary agent events is provided below in the appendix along with detailed notes for each generated event. Upon occurrence of a select application event control is transferred from the transaction manager via an applicable user exit to the event agent which in turn generates the appropriate agent event s .

Next the event agent determines at identifying information for the application transaction request which caused the event. In the context of message queuing identifying information for the application transaction includes an identifier for the queue manager an identifier for the message queue an identifier for the message itself and an identifier for the correlation identifier of the message.

When the transaction request is received via a gateway the identifying information for the transaction request is further defined as an identifier for the gateway e.g. the CICS transaction gateway . In the context of the CICS transaction gateway the identifying information for the application transaction depends on the mechanism by which the transaction request is passed on to the transaction manager . For the IPIC protocol the ApplidQualifier and the Applid along with the timestamp uniquely identifies the application transaction. For the EXCI protocol the ApplidQualifier and the Applid along with a modified timestamp uniquely identifies the application transaction where the timestamp is appended with a two byte binary sequence number to ensure uniqueness.

To ensure that non mainframe events can be linked with subsequent events generated on the mainframe the CICS transaction gateway can be instrumented with an incoming sensor and an outgoing sensor . The incoming sensor is configured to detect the transaction request received by the CICS Transaction Gateway and generate an event message signifying receipt of the transaction request. Likewise the outgoing sensor generates an event message signifying that the transaction request has been passed on to the transaction manager . The incoming sensor and the outgoing sensor both insert the identifying information for the application transaction into the event message and such information is readily available from the CICS transaction gateway.

It is readily understood that the identifying information for the application transaction may take different forms. In some embodiments the identifying information for the application transaction may be included with each event message whereas in other embodiments the identifying information for the application transaction may be included in event messages for select events such as those which initiate a CICS transaction or an execution path in the mainframe runtime environment.

Lastly the event agent generates an event message for the event where the event message includes the identifying information for the application transaction request. The event messages are then sent at to the correlation engine . The identifying information for the application transaction is used by the correlation engine to correlate the events captured in an execution path in the mainframe environment with other event messages of execution paths associated with the transaction from different execution environments. In some embodiments the event message generated by the event agent may be translated into a form understood by the correlation engine before being sent to the correlation engine . It is readily understood that the application events described in this disclosure are representative and other types of application events may be monitored within the scope of this disclosure.

The monitoring process described in can be extended to track other transactions that are invoked by the initial transaction. With reference to the initial transaction i.e. Task may start or otherwise link to another transaction Task within the same region of the run time environment e.g. same CICS region or to a transaction Task in a different region of the run time environment e.g. different CICS region on same or different logical partition . In a similar manner user exits are used to transfer control to the event agent when a link is made to another transaction e.g. an Insert Link event represents the EXEC CICS LINK invocation . In addition to identifying information for the application transaction request the event agent also determines transaction context information. In CICS association data is the set of information that describes the environment in which user tasks run and the way that user tasks are attached in a region. This association data is made available and can serve as the transaction context information. Thus the event agent can further append the transaction context information to the event messages sent to the correlation engine. In this way all of the sub paths in the mainframe environment can be linked back to the originating sub path to form one continuous path that described the entire user transaction.

A determination is first made at as to whether the user exit is an application program interface call to a resource manager supported by the transaction manager . More specifically a determination is made as to whether the user exit is a return from a resource manager interface RMI call handled by the CICS RMI. In the CICS context this user exit is referred to as XRMIOUT. If the user exit is not a return from an RMI call then the event agent determines at whether any of its sensors are enabled. In the exemplary embodiment the event agent may be configured with different types of sensors. For example the event agent may be configured with a sensor for detecting message queue MQ commands and another sensor for detecting databases calls e.g. DB2 queries . When a sensor is enabled the event agent will detect the applicable application events and take appropriate action. Conversely the event agent will ignore application events of a particular type when the corresponding sensor is disabled. If none of the sensors are enabled processing is complete and control returns at to the transaction manager .

When one or more sensors are enabled a determination is made at as to whether the user exit is for an entry to an RMI call to be handled by the CICS RMI. In the CICS context this user exit is referred to as XRMIIN. Calls to resource manager interfaces are further described below. Because the transaction may initiate other programs and or spawn other execution paths the event agent is also configured to handle user exits indicative of such activity. In the exemplary embodiment a determination is made at as to whether the user exit indicates a request to link to another program. In the CICS context this user exit is referred to as XPCREQ. If so the event agent gathers information about the link request and generates an applicable event message as indicated at . A user exit is also invoked upon completion of the link request referred to as XPCREQ Complete . In a similar manner the event agent gathers information about the link request and generates an application event message as indicated at . It is understood that the event agent may be configured to handle other types of user exits such as task related exits for context management events associated with start transaction requests which allow for the tracing of execution paths associated with the transaction being monitored. If the user exit is unmatched control returns at to the transaction manager .

When the user exit is deemed to be call to or a return from an RMI call the user agent determines at whether it is already tracing the transaction which caused the user exit. Context information is retained for each transaction. The event agent can determine whether it is tracing a transaction by examining this transaction context information.

Before the event agent begins tracing a given transaction it can expect to detect an MQ command pertaining to the transaction as noted at . That is the event agent will begin tracing a given transaction upon detecting a command by the CICS transaction server to get a message i.e. MQGET from the message queue . By the time the event agent gets control from the transaction manager various registers maintained by the transaction manager have changed. For example registers having information for the program currently active in the CICS region would contain values for the event agent . The event agent however is interested in learning about the transaction which initiated the event agent . Accordingly the event agent will need to locate at the applicable registers which contain information about the transaction and or the application which made the transaction request. Control returns to the transaction manager at when tracing has not yet begun and the user exit does not pertain to an MQ command.

In the CICS context the MQGMO data structure contains data associated with the MQGET command. illustrates a set of registers and pointers used to by the event agent to obtain the MQMGO data structure. This data structure is available in the system at the time the user exit invokes the event agent . The structure of this control block is provided by the IBM MQSeries API documentation. Of note an identifier for the message queue QNAME is contained in the MQGMO RESOLVEDQNAME field. The identifier for the queue manager QMGRNAME is obtained from a startup program in the CICS region which locates it and caches it in a location known to the event agent .

Additionally the event agent accesses a data structure containing message description data as shown in . Likewise a set of registers and pointers used by the event agent to obtain the MQMD data structure and the structure of this control block is provided by the IBM MQSeries API documentation. The identifier for the message MSGID is contained in the MQGMD MSGID field and the correlation identifier is contained in the MQGMD CORRELID field. In the exemplary embodiment the identifier for the queue manager the identifier for the message queue the identifier for the message itself and the correlation identifier of the message are referred to collectively as the identifying information or tag for the application transaction. These tags allow for the correlation of associated execution paths. The individual event messages generated by the event agent for a particular transaction are placed into the context of an execution path by the translation agent . In this way these event messages can be correlated with the application which initiated the transaction.

Depending on the type of MQ command the event agent will handle the command differently. First a determination is made at as to whether the MQ command is of the type which places a message onto a queue i.e. MQPUT . Next a determination is made at as to whether the MQ command is of the type which retrieves a message from a queue i.e. MQGET . In either case a determination is then made at as to whether the user exit is for an entry to an RMI call. If so event agent will handle the command as indicated at otherwise it is assumed that the user exit is for a return from an RMI call. In this case the event agent gets the return code at for the RMI call and the builds an appropriate event message at . The event agent then sends the event message to the translator agent . It is readily understood that the event agent may be configured to support other types of MQ commands. Handling of other types of MQ commands does not further the understanding of this disclosure and thus has been omitted.

For transactions the event agent is already tracing the event agent determines at as to which subsystem the application call pertains to. In the exemplary embodiment the event agent supports MQ commands and DB2 queries. For MQ commands the event agent determines the type of MQ command and evaluates the MQ command beginning at in the manner set forth above.

For DB2 queries a determination is made at as to whether the user exit was invoked prior to the DB2 query or after the DB2 query. Prior to the query the event agent creates SQL attachments at and then generates the applicable enter event message at . Conversely after the query the event agent creates connection pool attachments at and captures the SQLCODE for the query at . The event agent will create a JDBC attachment at when the return code indicates success or a warning. Depending on whether the query was successful or not the event agent then creates the applicable event message as indicated at and respectively. In either case control returns at to the transaction manager . It is readily understood that the event agent can be configured to support other types of resource interfaces or mainframe subsystems as indicated at .

It is to be understood that only the relevant steps of the agent are discussed in relation to but that other software implemented instructions may be needed to control and manage the overall operation of the event agent. For example the event agent may be configured to handle other types of application events such as Task Start Task End and Context Management exit events. The event agent may also be configured to handle transaction requests received via other mechanisms such as the CICS transaction gateway. Rather than checking for an MQ command in step the event agent could be configured to determine what type of mechanism was used to receive the transaction request. In CICS the mechanism used to receive the transaction request may be indicated in the origin data. In the case the transaction request was received via the CICS transaction gateway the event agent can be configured to handle commands associated with this mechanism. Moreover the event agent can be configured to determine the identifying information for the transaction request e.g. the ApplidQualifier and the Applid from a set of registers in a manner similar to that described in relation to message queuing. For brevity details for determining such information has been omitted from this disclosure.

Returning to a translator agent may be configured to receive event messages from the event agent . In one embodiment the event messages may be handled by an intermediate event manager prior to reaching the translator agent . The event manager operates generally to control the lifecycle of the translator agent . Additionally the event manager receives the event messages from the event agent and places the event messages in an event queue . Prior to placing the event messages in the event queue the messages may be validated by the event manager . For example each different type of application event being monitored by the event agent may be assigned a unique event identifier by the event agent . The event manager may use the event identifier to validate event messages received from the event agent . Invalid events are not placed into the event queue . The translator agent retrieves the validated event messages from the event queue . The event manager may also operate to add an address space identifier of the CICS region from which the event message originated to the event message. In other embodiments event messages may be communicated directly from the event agent to the translator agent via shared memory and without the use of the event manager . In yet other embodiments the event agent sends event messages directly to the correlation engine and there is no need for the translator agent .

In some embodiments the event manager and the translator agent may operate for example in a data collection subsystem e.g. z OS data collector of the mainframe computer . In other embodiments the translator agent operates on a computing device distinct from the mainframe computer. In these embodiments the event manager may be configured to transmit the event messages across a computer network to the translator agent . Event messages may be transmitted by the event manager for example using TCP IP or a best effort delivery communication protocol. Other types of communication mechanisms are also contemplated by this disclosure.

Next the translator agent determines the event type for the message as indicated at . For each event type the translator agent processes the event message accordingly. That is the translator agent maps data from the event message to the corresponding fields in an event data record. For example the translator agent generates a Start Path event record for a Start Root Path event received from the event agent . An exemplary data structure for the Start Path event record is provided as follows.

For events that initiate a transaction in the mainframe run time environment the event data record for such events includes the identifying information for the application transaction. In the case of the Start Path event record identifying information for the application transaction i.e. queue manager name queue name and message id may be inserted into the tagInfo field of the event data record. For the remaining events the translator agent tags the event data record with the CICS transaction context information. Given the identifying information for the application transaction from a preceding event data record the correlation engine can correlate subsequent event data records to the application transaction using the transaction context information. In either case the event data records also include at least one performance metric pertaining to the application transaction. For example a timestamp at which the program is started signifies a performance metric that will enable the correlation engine to determine performance pertaining to the application transaction being monitored. Lastly the translator agent transmits the event data record to the correlation engine as indicated at . Again it is to be understood that only the relevant steps of the agent are discussed in relation to but that other software implemented instructions may be needed to control and manage the overall operation of the translator agent

Returning to execution of the application may result in a transaction request for the mainframe computer . In the exemplary embodiment the transaction request may be communicated via message queuing to the mainframe computer . One or more of the agents monitoring the application will generate an event message in response to the transaction request. The event message will include information that uniquely identifies the execution paths which spawn the transaction request. In addition the event message will include identifying information for the application transaction request such as an identifier for the queue manager an identifier for the message queue and an identifier for the message. In an exemplary embodiment this event message may mimic the format of the Start Path event record noted above. The event message is sent by the agent across the network to the correlation engine .

The correlation engine will also receive event messages from the mainframe computer . Event messages are generated throughout the handling of the transaction by the mainframe in the manner described above. Select event messages are tagged with identifying information for the application transaction including an identifier for the queue manager an identifier for the message queue and an identifier for the transaction request. In this way the identifying information for the application transaction can be used by the correlation engine to correlate the mainframe events with the application requesting the backend mainframe processing.

When a transaction manager is notified that a message should be retrieved from an application message queue an MQGET API is invoked in that transaction manager as indicated at in . In this example that is CICS Region C259 with an agent id of 97 as noted in the appendix below. Events are generated when the MQGET API completes. At that time the XRMIOUT user exit is invoked allowing the event agent to intercept the completion of the API call. The tag generated as event permits the correlation engine to associate this transaction with the distributed application s MQPUT. Events are generated as the standard sequence for an MQCLOSE or MQOPEN. Event is generated via the invocation of the user exit XRMIIN and events via XRMIOUT. The program FLCTRIG1 invokes a START transaction API for transaction FLC2. This causes a context management event to invoke the task related exit which generates event . This Insert Link event is created to facilitate the linking of the current execution path with the new path that is about to begin for a new transaction. The correlation engine will use the tag information in event to accomplish that correlation. A start transaction event for this new transaction invoked the task related exit which creates events . These events signal the start of the started transaction FLC2 which in turn starts the user program FLCPGM2. The event is used by the correlation engine to link together FLCPGM2 with FLCTRIG1 event . Note that the task id has changed from event to event to indicate a new execution path transaction . Execution times for the various programs can be made visible for example as indicated at .

Events are generated via the user exits XPCREQ when the user program FLCPGM2 issues a CICS DPL LINK EXEC CICS LINK PROGRAM name to start a mirror transaction that will execute FLDPGM3 in another CICS Region C208 . The exit event is generated via a task manager call at the end of the task. This event caused the task related exit to invoke which permits the event agent to generate the corresponding exit event for the end of the transaction. Event is generated in this second CICS Region C208 with a new agent id of 82 and a new task id of 354 as noted in the appendix below. With reference to in this indicates a new execution path for the new transaction within a new CICS region. The tags created in event and permit the correlation engine to correctly link these execution paths even as they cross CICS region boundaries. A task start event invokes the task manager calls at the start of the task which in turn generates these events. Events are similar in nature to events except that they were generated for a DPL API rather than a Start Tran API.

Event represents a CICS LINK API which invokes the user program FLDDB21. This API is intercepted by the user exit XPCREQ. Events are created via the XRMIIN user exit and the DB2 Handler code within the event agent . The corresponding exit events via the XRMIOUT user exit are events . This same pattern is repeated for events . In this way metrics pertaining to a database call are made visible as indicated at .

User exit XPCREQC is driven by the returns from the CICS LINK API requests and permits the event agent to generate the corresponding exit events. Event is the exit event for Event and Event is the exit event for event .

A task end event caused the task related exit to invoke which permits the event agent to generate the corresponding exit event for the end of the transaction indicated by the enter event . Note that event is the exit for a program traced by agent and task when control is returned to the original CICS Region C259.

Events and are standard MQ events similar to the pattern of events . Event is generated via the XRMIIN user exit at the beginning of an MQPUT API. Events are generated via the XRMIOUT user exit at the end of that MQPUT API. The tag generated in Event permits the correlation engine to link the end of the mainframe processing with the corresponding MQGET in the distributed application. Event is the exit event for the original program FLCTRIG1.

The techniques described herein may be implemented by one or more computer programs executed by one or more processors. The computer programs include processor executable instructions that are stored on a non transitory tangible computer readable medium. The computer programs may also include stored data. Non limiting examples of the non transitory tangible computer readable medium are nonvolatile memory magnetic storage and optical storage.

Some portions of the above description present the techniques described herein in terms of algorithms and symbolic representations of operations on information. These algorithmic descriptions and representations are the means used by those skilled in the data processing arts to most effectively convey the substance of their work to others skilled in the art. These operations while described functionally or logically are understood to be implemented by computer programs. Furthermore it has also proven convenient at times to refer to these arrangements of operations as modules or by functional names without loss of generality.

Unless specifically stated otherwise as apparent from the above discussion it is appreciated that throughout the description discussions utilizing terms such as processing or computing or calculating or determining or displaying or the like refer to the action and processes of a computer system or similar electronic computing device that manipulates and transforms data represented as physical electronic quantities within the computer system memories or registers or other such information storage transmission or display devices.

Certain aspects of the described techniques include process steps and instructions described herein in the form of an algorithm. It should be noted that the described process steps and instructions could be embodied in software firmware or hardware and when embodied in software could be downloaded to reside on and be operated from different platforms used by real time network operating systems.

The present disclosure also relates to an apparatus for performing the operations herein. This apparatus may be specially constructed for the required purposes or it may comprise a general purpose computer selectively activated or reconfigured by a computer program stored on a computer readable medium that can be accessed by the computer. Such a computer program may be stored in a tangible computer readable storage medium such as but is not limited to any type of disk including floppy disks optical disks CD ROMs magnetic optical disks read only memories ROMs random access memories RAMs EPROMs EEPROMs magnetic or optical cards application specific integrated circuits ASICs or any type of media suitable for storing electronic instructions and each coupled to a computer system bus. Furthermore the computers referred to in the specification may include a single processor or may be architectures employing multiple processor designs for increased computing capability.

The algorithms and operations presented herein are not inherently related to any particular computer or other apparatus. Various general purpose systems may also be used with programs in accordance with the teachings herein or it may prove convenient to construct more specialized apparatuses to perform the required method steps. The required structure for a variety of these systems will be apparent to those of skill in the art along with equivalent variations. In addition the present disclosure is not described with reference to any particular programming language. It is appreciated that a variety of programming languages may be used to implement the teachings of the present disclosure as described herein.

The present disclosure is well suited to a wide variety of computer network systems over numerous topologies. Within this field the configuration and management of large networks comprise storage devices and computers that are communicatively coupled to dissimilar computers and storage devices over a network such as the Internet.

The foregoing description of the embodiments has been provided for purposes of illustration and description. It is not intended to be exhaustive or to limit the disclosure. Individual elements or features of a particular embodiment are generally not limited to that particular embodiment but where applicable are interchangeable and can be used in a selected embodiment even if not specifically shown or described. The same may also be varied in many ways. Such variations are not to be regarded as a departure from the disclosure and all such modifications are intended to be included within the scope of the disclosure.

