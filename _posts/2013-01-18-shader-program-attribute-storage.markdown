---

title: Shader program attribute storage
abstract: A system, method, and computer program product are provided for determining a size of an attribute storage buffer. Input attributes read by a shader program to generate output attributes are identified. A portion of the output attributes to be consumed by a destination shader program is identified. The size of the attribute storage buffer that is allocated for execution of the shader program is computed based on the input attributes and the portion of the output attributes.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09214008&OS=09214008&RS=09214008
owner: NVIDIA Corporation
number: 09214008
owner_city: Santa Clara
owner_country: US
publication_date: 20130118
---
During execution of a shader program input attributes are read from memory processed and output attributes are stored to the memory. Because a shader program is not necessarily constrained to read all of the input attributes from the memory before any of the output attributes are written to the memory. Therefore separate portions of the memory need to be allocated for storing the input attributes and the output attributes. In some cases processing performance is limited because more memory is needed for allocation to additional shader programs or to increase the parallel execution of a shader program.

Thus there is a need for addressing the issue of attribute storage and or other issues associated with the prior art.

A system method and computer program product are provided for determining a size of an attribute storage buffer. Input attributes read by a shader program to generate output attributes are identified. A portion of the output attributes to be consumed by a destination shader program is identified. The size of the attribute storage buffer that is allocated for execution of the shader program is computed based on the input attributes and the portion of the output attributes.

Conventional graphics processors that include multiple processing units are configured to execute shader programs. As previously explained separate storage is allocated for input attributes and output attributes of a shader program. When the shader program executes on one or more processing units the processing units can read input attributes from one attribute buffer and write output attributes to another attribute buffer in an arbitrary order. Attribute buffers are used to temporarily store attributes generated by a shader program and or consumed by a destination shader program to transfer data between different shader programs and or fixed function hardware engines in a pipeline. In one embodiment for multi threaded execution attribute buffers are allocated for a group of threads that are executed in parallel on a processing unit so that the amount of storage that is allocated is the per thread attribute storage multiplied by the number of threads in the group. When the amount of storage available for attribute buffers is limited the number of threads that can execute the shader program is limited possibly limiting performance

A compiler may be configured to examine the shader program and if all of the attribute read operations occur before any of the attribute write operations the compiler may set a flag indicating that optimization of the attribute storage is possible. In one embodiment the compiler may be configured when possible to reorder the attribute read and write operations within the shader program so that all of the attribute read operations occur before any of the attribute write operations. When a processing unit is configured to execute the shader program and the flag is set indicating that optimization of the attribute storage is possible a single attribute storage buffer may be allocated for storing the input attributes and the output attributes. The size of the attribute buffer that is allocated is the maximum of the amount of storage needed for the input attributes and the output attributes. In contrast when a separate input attribute buffer and output attribute buffer is allocated the amount of storage is the sum of the storage needed for the input attributes and the output attributes. Thus when the amount of storage needed for the input attributes equals the amount of storage needed for the output attributes and the attribute storage optimization flag is set the attribute storage buffer size that is allocated to the processing unit for the shader program may be halved.

More illustrative information will now be set forth regarding various optional architectures and features with which the foregoing framework may or may not be implemented per the desires of the user. It should be strongly noted that the following information is set forth for illustrative purposes and should not be construed as limiting in any manner. Any of the following features may be optionally incorporated with or without the exclusion of other features described.

When the amount of storage needed to store the input attributes is less than the amount of storage needed to store the output attributes the size of the attribute buffer may reduced to the intersection of the portion of the output attributes that are consumed by the destination shader program i.e. the input attributes . The output attributes that are not consumed by the destination shader program may be discarded. In addition to the input attributes the destination shader program may also consume default input attributes that are not included in the output attributes . The default input attributes are additional input attributes that are set to default values and are not stored in the buffer . The additional input attributes are not read from an attribute buffer however like the input attributes the additional input attributes are also consumed by the destination shader program .

As shown in the amount of storage allocated in the memory for execution of the shader program is the sum of the storage needed for the input attributes and the output attributes i.e. the sum of the sizes of the attribute buffer and the attribute buffer . Thus when the attribute storage optimization flag is set the attribute storage buffer size that is allocated for execution of the shader program may be reduced to the maximum size of the attribute buffer and the attribute buffer i.e. the size of the attribute buffer .

The shader program and or that is executed by one or more processing units may be a vertex shader tessellation shader geometry shader pixel shader hull shader domain shader compute shader or other type of shader program. The attributes stored in the memory are vertex geometry pixel or other types of attributes that are consumed and or generated by a shader program. In one embodiment the shader program and or the destination shader program is replaced with a fixed function hardware engine comprising circuitry that is configured to receive input attributes and generate output attributes.

In contrast with the example shown in the attribute storage optimization flag is set for the shader program . Therefore the attribute storage buffer size that is allocated for execution of the shader program may be reduced to the maximum size of the attribute buffer and the attribute buffer i.e. the size of the attribute buffer . However the storage that is needed for the input attributes that are consumed by the shader program is less than the storage that is needed for the output attributes . Therefore the size of the attribute buffer is computed based on the maximum of the amount of storage for the input attributes and the amount of storage for the input attributes . It is not necessary to allocate storage for one or more attributes of the output. attributes that are not consumed by the shader program . It is also not necessary to allocate storage for the additional input attributes that are not generated by the shader program but that are consumed by the shader program . In one embodiment the shader program may be configured to discard writes of output attributes that are not consumed by the shader program and the shader program may be configured to set the additional input attributes to default values.

In one embodiment each shader program and and fixed function hardware engine specifies an IMAP and an OMAP. The IMAP associated with a particular shader program or fixed function hardware engine indicates which input attributes of a set of possible input attributes are consumed by the particular shader program or fixed function hardware engine. The IMAP indicates the input attributes that are consumed i.e. the additional input attributes that are set to default values as well as the input attributes that are read from an attribute buffer. The OMAP associated with a particular shader program or fixed function hardware engine indicates which output attributes of a set of possible output attributes are generated by the particular shader program or fixed function hardware engine. The IMAP and the OMAP may be encoded as a mask including one bit for each of the possible attributes.

A base address is associated with each attribute buffer and and the IMAP specified by the corresponding shader program and in some cases the IMAP can be used in combination with the base address to determine the location within the input attribute buffer where the attribute can be found. However because all of the input attributes that are consumed by a shader program or fixed function hardware engine are not stored in the attribute buffer and i.e. the additional input attributes are not stored the IMAP may not be reliable for determining where a particular input attribute is read from the attribute buffer or . Similarly because all of the output attributes are not necessarily stored in the attribute buffer the OMAP may not be reliable for determining where a particular output attribute should be written within the attribute buffer or .

The OMAP specified by the shader program may be combined with the IMAP specified by the destination shader program and then combined with the base address associated with the attribute buffer to determine the location where each output attribute that will be read by the shader program is written by the shader program . For example when the OMAP and IMAP are represented as masks a combined mask BMAP may be computed as an intersection of the previous OMAP and current IMAP. More specifically BMAP OMAP IMAP where n indicates the order of the shader programs and and the fixed function hardware engine . The BMAPmay be set equal to IMAP. The BMAPis used to determine the location where each input attribute may be read from an attribute buffer and the BMAPis used to determine the location where each output attribute that is generated may be written to an attribute buffer. The size of the attribute buffer may be computed based on the BMAPand BMAPcorresponding to the shader program . The additional input attributes that are not read from an attribute buffer but that are consumed by are identified as OMAP IMAP.

In one embodiment the attribute storage optimization flag is not set for the shader program . The attribute storage optimization flag may be stored in the shader header of the shader program . Therefore the output attributes that are generated by the shader program cannot be stored in the attribute buffer and instead are stored in a separate attribute buffer . The fixed function hardware engine is configured to read all of the input attributes before writing any of the output attributes so the output attributes that are generated by the fixed function hardware engine can be stored in the same attribute buffer that stores the input attributes that are read by the fixed function hardware engine i.e. the attribute buffer . The size of the attribute buffer may be computed based on the maximum of the amount of storage for the input attributes the amount of storage for the output attributes and the output attributes . The amount of storage needed for the output attributes may be reduced based on an IMAP if an destination shader or fixed function hardware engine is added. As shown in when the attribute storage optimization flag is set the attribute storage buffer size that is allocated for execution of a particular shader program or fixed function hardware engine may be computed based on the BMAPand BMAPcorresponding to the shader program or fixed function hardware engine.

The attribute storage optimization improves performance of the shader programs by allowing more threads to execute simultaneously in a processing unit. The processing capacity may be more effectively utilized when the number of threads that can execute simultaneously is not limited by the memory available for allocation to attribute buffers. In some embodiment the memory and or is a shared memory that may be allocated for the storage of input and output attributes as well as other data. The attribute storage optimization may be particularly useful at lower screen resolutions where a system is more likely to be limited by vertex shader performance assuming pixel count decreases to a greater extent compared with geometric complexity. In other words when the number of pixels that are displayed decreases the number of vertices does not necessarily decrease.

After the shader program has been compiled the shader program may be combined with other shader programs and executed by the same processor that was used to compile the shader program or by a different processor. The shader program and other shader programs may be configured to form a processing pipeline with one or more fixed function hardware engines that reside within the processor that executes the shader program. At step a processing unit that is configured to execute the shader program determines if attribute buffer combining is enabled for the shader program. Buffer combining may be enabled or disabled for each fixed function hardware engine based on the configuration of the fixed function hardware engine. Although the following steps are described in terms of shader programs the steps apply equally to fixed function hardware engines.

If the processing unit determines that attribute buffer combining is not enabled then at step separate attribute storage buffers are allocated for the input attributes read by the shader program and the output attributes that are generated by the shader program. Pointers i.e. base addresses to the separate attributes storage buffers are provided to the shader program.

However if at step the processing unit determines that attribute buffer combining is enabled then at step the processing unit determines if the input attributes are generated by a previous shader program. In other words the processing unit determines if a portion of output attributes generated by a previous shader program are the input attributes and if so at step the processing unit obtains the size of the attribute buffer that stores the input attributes. The size of the attribute buffer will be at least the size needed to store the input attributes that are read by the shader program and it may be larger if the input attributes that are read for one or more previous shader programs require more storage space. For example if attribute buffer sharing is enabled for each of the shader programs and the fixed function hardware engine shown in the input attributes that are read by each of the shader programs and and fixed function hardware engine may be stored in the attribute buffer and the attribute buffer is not allocated.

If at step the processing unit determines that the input attributes are not generated by a previous shader program in other words the shader program is the first shader program in the processing pipeline then at step the processing unit identifies the input attributes that are read by the shader program. The processing unit determines the size of the attribute buffer that is needed to store the input attributes. At step the processing unit identifies the portion of output attributes consumed by a destination shader program and determines the size of the attribute buffer that is needed to store the portion of the output attributes. When there is no destination shader program i.e. the shader program is the last shader program in the processing pipeline the portion of the output attributes generated by the shader program are used to determine the size of the attribute buffer that is needed to store the output attributes.

At step the size of the attribute storage buffer that is allocated for execution of the shader program is computed based on the input attributes and the portion of the output attributes or the output attributes when there is no destination shader program . In one embodiment the size of the attribute storage buffer is computed as the maximum of the size of the attribute buffer that stores the input attributes and the size of the attribute buffer that is needed to store the portion of the output attributes or the output attributes when there is no destination shader program .

At step a single attribute storage buffer is allocated for the input attributes read by the shader program and the output attributes that are generated by the shader program. A pointer i.e. base address to the attribute storage buffer is provided to the shader program. The single base address is used to read the input attributes and write the output attributes. When multiple shader programs and or fixed function hardware engines are combined as shown in the single attribute storage buffer may be allocated as the attribute storage buffer for two or more shader programs and or fixed function hardware engines. When attribute buffer combining is enabled for all of the shader programs and or fixed function hardware engines a single attribute storage buffer that is sized to store the maximum of the amount of storage for the different input attributes and the amount of storage for the output attributes generated by the last shader program or fixed function hardware engine may be allocated to all of the shader programs and fixed function hardware engines.

In one embodiment the PHI includes an input output I O unit configured to transmit and receive communications i.e. commands data etc. from a central processing unit CPU not shown over the system bus . The I O unit may implement a Peripheral Component Interconnect Express PCIe interface for communications over a PCIe bus. In alternative embodiments the I O unit may implement other types of well known bus interfaces.

The PPU also includes a host interface unit that decodes the commands and transmits the commands to the grid management unit or other units of the PPU e.g. memory interface as the commands may specify. The host interface unit is configured to route communications between and among the various logical units of the PPU .

In one embodiment a program encoded as a command stream is written to a buffer by the CPU. The buffer is a region in memory e.g. memory or system memory that is accessible i.e. read write by both the CPU and the PPU . The CPU writes the command stream to the buffer and then transmits a pointer to the start of the command stream to the PPU . The host interface unit provides the grid management unit GMU with pointers to one or more streams. The GMU selects one or more streams and is configured to organize the selected streams as a pool of pending grids. The pool of pending grids may include new grids that have not yet been selected for execution and grids that have been partially executed and have been suspended.

A work distribution unit that is coupled between the GMU and the SMs manages a pool of active grids selecting and dispatching active grids for execution by the SMs . Pending grids are transferred to the active grid pool by the GMU when a pending grid is eligible to execute i.e. has no unresolved data dependencies. An active grid is transferred to the pending pool when execution of the active grid is blocked by a dependency. When execution of a grid is completed the grid is removed from the active grid pool by the work distribution unit . In addition to receiving grids from the host interface unit and the work distribution unit the GMU also receives grids that are dynamically generated by the SMs during execution of a grid. These dynamically generated grids join the other pending grids in the pending grid pool.

In one embodiment the CPU executes a driver kernel that implements an application programming interface API that enables one or more applications executing on the CPU to schedule operations for execution on the PPU . An application may include instructions i.e. API calls that cause the driver kernel to generate one or more grids for execution. In one embodiment the PPU implements a SIMD Single Instruction Multiple Data architecture where each thread block i.e. warp in a grid is concurrently executed on a different data set by different threads in the thread block. The driver kernel defines thread blocks that are comprised of k related threads such that threads in the same thread block may exchange data through shared memory. In one embodiment a thread block comprises 32 related threads and a grid is an array of one or more thread blocks that execute the same stream and the different thread blocks may. exchange data through global memory.

In one embodiment the PPU comprises X SMs X . For example the PPU may include 15 distinct SMs . Each SM is multi threaded and configured to execute a plurality of threads e.g. 32 threads from a particular thread block concurrently. Each of the SMs is connected to a level two L2 cache via a crossbar or other type of interconnect network . The L2 cache is connected to one or more memory interfaces . Memory interfaces implement 16 32 64 128 bit data buses or the like for high speed data transfer. In one embodiment the PPU comprises U memory interfaces U where each memory interface U is connected to a corresponding memory device U . For example PPU may be connected to up to 6 memory devices such as graphics double data rate version 5 synchronous dynamic random access memory GDDR5 SDRAM 

In one embodiment the PPU implements a multi level memory hierarchy. The memory is located off chip in SDRAM coupled to the PPU . Data from the memory may be fetched and stored in the L2 cache which is located on chip and is shared between the various SMs . In one embodiment each of the SMs also implements an L1 cache. The L1 cache is private memory that is dedicated to a particular SM . Each of the L1 caches is coupled to the shared L2 cache . Data from the L2 cache may be fetched and stored in each of the L1 caches for processing in the functional units of the SMs .

In one embodiment the PPU comprises a graphics processing unit GPU . The PPU is configured to receive commands that specify shader programs for processing graphics data. Graphics data may be defined as a set of primitives such as points lines triangles quads triangle strips and the like. Typically a primitive includes data that specifies a number of vertices for the primitive e.g. in a model space coordinate system as well as attributes associated with each vertex of the primitive. The PPU can be configured to process the graphics primitives to generate a frame buffer i.e. pixel data for each of the pixels of the display . The driver kernel implements a graphics processing pipeline such as the graphics processing pipeline defined by the OpenGL API.

An application writes model data for a scene i.e. a collection of vertices and attributes to memory. The model data defines each of the objects that may be visible on a display. The application then makes an API call to the driver kernel that requests the model data to be rendered and displayed. The driver kernel reads the model data and writes commands to the buffer to perform one or more operations to process the model data. The commands may encode different shader programs including one or more of a vertex shader hull shader geometry shader pixel shader etc.

For example the GMU may configure one or more SMs to execute a vertex shader program that processes a number of vertices defined by the model data. In one embodiment the GMU may configure different SMs to execute different shader programs concurrently. For example a first subset of SMs may be configured to execute a vertex shader program while a second subset of SMs may be configured to execute a pixel shader program. The first subset of SMs processes vertex data to produce processed vertex data and writes the processed vertex data to the L2 cache and or the memory . After the processed vertex data is rasterized i.e. transformed from three dimensional data into two dimensional data in screen space to produce fragment data the second subset of SMs executes a pixel shader to produce processed fragment data which is then blended with other processed fragment data and written to the frame buffer in memory . The vertex shader program and pixel shader program may execute concurrently processing different data from the same scene in a pipelined fashion until all of the model data for the scene has been rendered to the frame buffer. Then the contents of the frame buffer are transmitted to a display controller for display on a display device.

When attribute buffer combining is not enabled for a shader program the input attributes e.g. vertex data processed vertex data fragment data etc. and the output attributes corresponding to the shader program are stored in separate attribute buffers in the shared memory i.e. L1 cache and or the memory When attribute buffer combining is enabled for one or more shader programs one or more combined attribute buffers are allocated for the one of more shader programs. In one embodiment a particular attribute buffer may be accessed by threads in the same thread group or warp. When space is not available for allocation of an additional attribute buffer the processing performance of the PPU may be limited even though one or more SMs may be idle. Therefore reducing the amount of space needed for storing attribute buffers may improve processing performance of the PPU .

The PPU may be included in a desktop computer a laptop computer a tablet computer a smart phone e.g. a wireless hand held device personal digital assistant PDA a digital camera a hand held electronic device and the like. In one embodiment the PPU is embodied on a single semiconductor substrate. In another embodiment the PPU is included in a system on a chip SoC along with one or more other logic units such as a reduced instruction set computer RISC CPU a memory management unit MMU a digital to analog converter DAC and the like.

In one embodiment the PPU may be included on a graphics card that includes one or more memory devices such as GDDR5 SDRAM. The graphics card may be configured to interface with a PCIe slot on a motherboard of a desktop computer that includes e.g. a northbridge chipset and a southbridge chipset. In yet another embodiment the PPU may be an integrated graphics processing unit iGPU included in the chipset i.e. Northbridge of the motherboard.

As described above the work distribution unit dispatches active grids for execution on one or more SMs of the PPU . The scheduler unit receives the grids from the work distribution unit and manages instruction scheduling for one or more thread blocks of each active grid. The scheduler unit schedules threads for execution in groups of parallel threads where each group is called a warp. In one embodiment each warp includes 32 threads. The scheduler unit may manage a plurality of different thread blocks allocating the thread blocks to warps for execution and then scheduling instructions from the plurality of different warps on the various functional units i.e. cores DPUs SFUs and LSUs during each clock cycle.

In one embodiment each scheduler unit includes one or more instruction dispatch units . Each dispatch unit is configured to transmit instructions to one or more of the functional units. In the embodiment shown in the scheduler unit includes two dispatch units that enable two different instructions from the same warp to be dispatched during each clock cycle. In alternative embodiments each scheduler unit may include a single dispatch unit or additional dispatch units .

Each SM includes a register file that provides a set of registers for the functional units of the SM . In one embodiment the register file is divided between each of the functional units such that each functional unit is allocated a dedicated portion of the register file . In another embodiment the register file is divided between the different warps being executed by the SM . The register file provides temporary storage for operands connected to the data paths of the functional units.

Each SM comprises L processing cores . In one embodiment the SM includes a large number e.g. 192 etc. of distinct processing cores . Each core is a fully pipelined single precision processing unit that includes a floating point arithmetic logic unit and an integer arithmetic logic unit. In one embodiment the floating point arithmetic logic units implement the IEEE 754 2008 standard for floating point arithmetic. Each SM also comprises M DPUs that implement double precision floating point arithmetic N S Ells that perform special functions e.g. copy rectangle pixel blending operations and the like and P LSUs that implement load and store operations between the shared memory L1 cache and the register file . In one embodiment the SM includes 64 DPUs 32 SFUs and 32 LSUs .

Each SM includes an interconnect network that connects each of the functional units to the register file and the shared memory L1 cache . In one embodiment the interconnect network is a crossbar that can be configured to connect any of the functional units to any of the registers in the register file or the memory locations in shared memory L1 cache .

In one embodiment the SM is implemented within a GPU. In such an embodiment the SM comprises texture units . The texture units are configured to load texture maps i.e. a 2D array of texels from the memory and sample the texture maps to produce sampled texture values for use in shader programs. The texture units implement texture operations such as anti aliasing operations using mip maps i.e. texture maps of varying levels of detail . In one embodiment the SM includes 16 texture units .

The PPU described above may be configured to perform highly parallel computations much faster than conventional CPUs. Parallel computing has advantages in graphics processing data compression biometrics stream processing algorithms and the like.

The system also includes input devices a graphics processor and a display i.e. a conventional CRT cathode ray tube LCD liquid crystal display LED light emitting diode plasma display or the like. User input may be received from the input devices e.g. keyboard mouse touchpad microphone and the like. In one embodiment the graphics processor may include a plurality of shader modules a rasterization module etc. Each of the foregoing modules may even be situated on a single semiconductor platform to form a graphics processing unit GPU .

In the present description a single semiconductor platform may refer to a sole unitary semiconductor based integrated circuit or chip. It should be noted that the term single semiconductor platform may also refer to multi chip modules with increased connectivity which simulate on chip operation and make substantial improvements over utilizing a conventional central processing unit CPU and bus implementation. Of course the various modules may also be situated separately or in various combinations of semiconductor platforms per the desires of the user.

The system may also include a secondary storage . The secondary storage includes for example a hard disk drive and or a removable storage drive representing a floppy disk drive a magnetic tape drive a compact disk drive digital versatile disk DVD drive recording device universal serial bus USB flash memory. The removable storage drive reads from and or writes to a removable storage unit in a well known manner.

Computer programs or computer control logic algorithms may be stored in the main memory and or the secondary storage . Such computer programs when executed enable the system to perform various functions. For example a compiler program that is configured to examiner a shader program and enable or disable attribute buffer combining may be stored in the main memory . The compiler program may be executed by the central processor or the graphics processor . The main memory the storage and or any other storage are possible examples of computer readable media.

In one embodiment the architecture and or functionality of the various previous figures may be implemented in the context of the central processor the graphics processor an integrated circuit not shown that is capable of at least a portion of the capabilities of both the central processor and the graphics processor a chipset i.e. a group of integrated circuits designed to work and sold as a unit for performing related functions etc. and or any other integrated circuit for that matter.

Still yet the architecture and or functionality of the various previous figures may be implemented in the context of a general computer system a circuit board system a game console system dedicated for entertainment purposes an application specific system and or any other desired system. For example the system may take the form of a desktop computer laptop computer server workstation game consoles embedded system and or any other type of logic. Still yet the system may take the form of various other devices including but not limited to a personal digital assistant PDA device a mobile phone device a television etc.

Further while not shown the system may be coupled to a network e.g. a telecommunications network local area network LAN wireless network wide area network WAN such as the Internet peer to peer network cable network or the like for communication purposes.

While various embodiments have been described above it should be understood that they have been presented by way of example only and not limitation. Thus the breadth and scope of a preferred embodiment should not be limited by any of the above described exemplary embodiments but should be defined only in accordance with the following claims and their equivalents.

