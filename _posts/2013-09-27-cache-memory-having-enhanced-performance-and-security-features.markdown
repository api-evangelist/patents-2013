---

title: Cache memory having enhanced performance and security features
abstract: Methods for accessing, storing and replacing data in a cache memory are provided, wherein a plurality of index bits and a plurality of tag bits at the cache memory are received. The plurality of index bits are processed to determine whether a matching index exists in the cache memory and the plurality of tag bits are processed to determine whether a matching tag exists in the cache memory, and a data line is retrieved from the cache memory if both a matching tag and a matching index exist in the cache memory. A random line in the cache memory can be replaced with a data line from a main memory, or evicted without replacement, based on the combination of index and tag misses, security contexts and protection bits. User-defined and/or vendor-defined replacement procedures can be utilized to replace data lines in the cache memory.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09110816&OS=09110816&RS=09110816
owner: Teleputers, LLC
number: 09110816
owner_city: Princeton
owner_country: US
publication_date: 20130927
---
This application is a divisional of and claims the benefit of priority to U.S. patent application Ser. No. 12 633 500 filed on Dec. 8 2009 which claims the benefit of U.S. Provisional Application Ser. No. 61 201 185 filed Dec. 8 2008 the entire disclosures of which are expressly incorporated herein by reference.

The present invention was made with support of the U.S. Government under NSF and DARPA Grant Nos. CNS 0430487 and CNS 0752961. Accordingly the U.S. Government has certain rights in the present invention.

The present invention relates to computer memory. More specifically the present invention relates to a cache memory having enhanced performance and security features.

Cache memory is an important component of modern computer processors. Typically cache memory is manufactured from high speed memory and is provided on the same chip as a microprocessor. To alleviate processor delays associated with having to obtain information from main memory which is slower than cache memory modern cache memories store copies of frequently accessed information from main memory so that such information can be quickly retrieved from the cache memory. If a desired piece of information exists in the cache memory a hit is said to have occurred otherwise a miss occurs and the processor obtains the desired information from main memory.

Ideally cache memories should have both short access times and low miss rates to minimize average memory access delay. Unfortunately cache memories which achieve the best access times such as direct mapped DM cache memories suffer from high miss rates. Fully associative FA or set associative SA cache memories achieve the best miss rates but at the cost of increased access times and power consumption.

Power efficiency is also a critical issue in cache memory design. Lower power dissipation provides the benefits of longer battery life for mobile devices and reduced wear of the memory. Higher power consumption causes heating and reliability problems which limit performance. Increasing faults and hot spots are also concerns especially in the deep submicron era of modern microprocessors. Due to the shrinking of technology feature sizes process variations increase the number of faulty devices with excessive delay or leakage power. Also current densities become higher thereby unduly heating the chip and causing hot spots. Both of these outcomes adversely impact chip yields and device lifetimes.

Another new and important aspect for cache memory design is security. Recent software cache based side channel attacks show that cache memories are highly vulnerable to leakage of critical information such as cryptographic keys. They rely only on the timing difference between cache hits and misses and therefore are effective on all caches impacting a wide range of platforms and users. Since security solutions often lead to very restrictive design they typically result in severe performance degradation.

Recent attacks have shown that in spite of software protections such as address space isolation or secure Virtual Machines hardware caches in processors introduce interference between programs and users. For example a given process can evict cache lines of other processes causing them to miss cache accesses. As demonstrated by the recent cache based side channel attacks critical information e.g. cryptographic keys can easily be leaked out due to the aforementioned cache behavior. In contrast to traditional cryptanalysis these cache based attacks allow the recovery of the full secret cryptographic key and require much less time and computation power. Furthermore these attacks can succeed on almost all processors with caches since they rely only on hits and misses that occur in all caches. Such attacks are also very easy to launch a remote computer user can become an attacker without the need for special equipment.

Both software and hardware techniques have been proposed to mitigate the information leakage problem in caches. Software techniques mostly involve rewriting the code to prevent known attacks from succeeding. One software solution is to avoid using memory access operations e.g. replacing Advanced Encryption Standard AES table lookups with arithmetic and logical operations . The performance overhead however can be very high and the method is not applicable to all situations. Another software countermeasure preloads objects into the cache before any use of them so that all subsequent accesses achieve cache hits thus leaking no information. This approach however is not really secure since the preloaded objects could be evicted by other memory references at a later time. Researchers have also proposed using alternative tables table permutation and algorithmic masking to mitigate cache based attacks. Such methods however can lead to significant performance degradation e.g. delays of approximately 2 to 4 times slower in the case of AES. In general software countermeasures incur significant performance degradation and are often not secure enough due to the behavior of the underlying hardware cache. Software methods alone are not sufficient to provide secure yet high performance mitigation of cache based information leakage.

Hardware methods have also been proposed. Cache partitioning Partitioned cache and cache line locking PLcache prevent undesirable cache evictions if the objects are put into a private partition or locked in cache respectively thus helping to achieve constant execution time. Another approach uses a randomization based approach allowing interference but randomizing it so that it carries no information. The drawback of cache partitioning and cache line locking is cache under utilization. Cache lines that are locked or belong to a private partition cannot be used by other processes even when they are unused. The randomization based approach can avoid cache underutilization.

In summary the information leakage problem in caches introduces a new challenge in cache design. In addition to performance power efficiency reliability etc. cache designers have to also take security into account which typically introduces even more restrictions in cache design and compromises other design goals.

The present invention relates to a cache memory having enhanced performance and security features. The cache memory includes a data array storing a plurality of data lines a tag array storing a plurality of tags corresponding to the plurality of data lines and an address decoder which permits dynamic memory to cache mapping to provide enhanced security of the data lines as well as enhanced performance. The address decoder receives a context identifier and a plurality of index bits of an address passed to the cache memory and determines whether a matching value in a line number register exists. The line number registers allow for dynamic memory to cache mapping and their contents can be modified as desired by cache replacement algorithms disclosed herein. If a line number register with a matching value for the index bits and context identifier exists a corresponding tag element from the cache tag memory is accessed and compared to the tag bits also in the address provided to the cache memory. At the same time a corresponding data line from the cache data memory is accessed. If the tag element matches the tag bits in the address provided to the tag memory then the corresponding data line accessed from the data array is transmitted to a processor in communication with the cache that requested a data element contained in the data line for subsequent use by the processor. If both a matching line number register and a matching tag element are not found the present invention also provides a method and a computer readable medium for replacing data in a faster and smaller cache memory with data from a larger and slower memory. A random line in the faster and smaller cache memory can be replaced with a data line from the larger and slower memory. Under other conditions a random line in the cache can be evicted without replacing it with a data line from the larger and slower memory. User defined and or vendor defined replacement procedures can also be utilized to replace data lines in the cache memory. A circuit implementation for an address decoder that is an embodiment of the present invention is also described herein.

The computer system could be any suitable computer system including but not limited to a desktop computer laptop computer handheld computer personal digital assistant portable computer server web server proxy server embedded computing system etc. Such a system could include a non volatile memory e.g. disk EPROM EEPROM flash memory ROM etc. a bus for allowing communication between components of the system a random access main memory e.g. dynamic RAM DRAM a communications subsystem e.g. Ethernet network interface wireless network interface etc. one or more input devices e.g. mouse keyboard etc. and a display . It is noted that the components and arrangement shown in could vary as dictated by the specific computer architecture in which the cache memory is implemented.

As shown in an address decoder is provided which receives as inputs the context identifier context RMT ID as well as the index bits . The context RMT ID and the index bits are used by the decoder to look up the index of a real cache line to which the tag bits may be mapped by referring to a plurality of line number registers LNregs stored in a memory associated with or forming part of the decoder such as an index array or which are hardwired registers as part of the decoder . As discussed below in greater detail below in connection with the LNregs are physical implementations of a plurality of logical re mapping tables RMTs which can be altered as desired to provide security for the cache memory . In this arrangement the cache memory provides dynamic memory to cache remapping meaning that a memory block can be mapped to any desired cache line at run time. This provides for improved security for instance from information leakage attacks and other security threats. By changing the contents of an RMT entry i.e. by changing the contents of LNregs an address can be remapped to an arbitrary cache line thus securing the contents of the cache from information leakage attacks as well as other security threats.

The address decoder generates an output which indicates whether an index hit or index miss has occurred i.e. whether a matching index exists in the LNregs which matches the index bits and the context RMT ID . If an index hit occurs then the contents of the matching LNreg selects a corresponding tag element from the tag array and a corresponding data line .

The cache memory also includes a tag comparator circuit which includes a comparator and AND gate for determining whether the selected tag element in the tag array matches the tag bits . The selected tag element contains a tag value a V flag bit and a P flag bit . The flag bit V indicates if the corresponding tag value is valid i.e. whether the tag element contains a valid tag value. If V 1 and there is a match in the selected tag element with the tag bits then a tag hit is said to have occurred. Thus a tag hit or a tag miss signal can be provided at the output .

Further the data array generates a data output which represents data corresponding to the specified address if there is both an index hit and a tag hit. That is the data output represents data which exists in the cache and can be obtained therefrom thereby obviating the need for a processor core to obtain such data from main memory.

The P flag bit an optional feature indicates the presence of protected cache lines. In such circumstances each page table entry and or segment descriptor if implemented could also have a PP flag bit which indicates the presence of a protected page.

In the first logical mapping step 1 every memory line with the same n k index bits are mapped into the same LDM cache slot. However since only one memory line can reside in this LDM cache slot at any one time the particular line residing here is indicated by the tag shown in in the selected tag element . This is like a direct mapped DM cache in conventional cache architectures. In the second logical mapping step 2 every LDM line can be mapped into any of the data line slots of the physical cache . However it is noted that each distinct LDM line can only be mapped into at most one of the slots of the physical cache . This is like a fully associative FA cache in conventional cache architectures. In addition in accordance with the present invention the cache line slot in the physical cache can be randomly chosen.

In the actual implementation of the present invention the aforementioned two logical mapping steps are performed in reverse. The n k bits of are used together with the context RMT ID to select at most one of the LNregs which contain the same contents matching the contents of these n k bits. Note that exactly one LNreg or none is selected. If one LNreg is selected this is called an Index Hit. If none are selected this is called an Index Miss. If one LNreg is selected on an Index Hit then the corresponding selected tag is compared to the tag bits in the address supplied to the cache . If this compares as equal matching as indicated by the result of comparator and the valid bit V 1 as indicated by the output of the AND gate then this is called a Tag Hit. Otherwise it is called a Tag Miss. The LDM cache does not physically exist but is introduced herein to facilitate analysis and discussion of the cache memory of the present invention. The dynamic remapping feature of the present invention enables the cache to store in physical cache memory e.g. in the tag and data arrays and of the most useful 2lines at run time rather than holding a fixed set of cache lines and missing others.

To determine which lines in the LDM cache are stored in the physical cache memory each line of the physical cache memory is associated with one of the plurality of LNregs . The LNregs store the n k bit line number of the corresponding logical cache line in the LDM cache . Each set of LNregs physically implement a single logical RMT and changing the line numbers stored in a LNreg maps another logical cache line to the physical cache line. Although shows 2cache lines in the physical cache memory as in conventional cache sizes which are always a power of 2 the number of cache lines s of the data array and tag array in the cache see of the present invention can be any number not necessarily a power of 2 so long as s is less than or equal to 2.

A process that needs to be protected against information leakage from other processes should use a different RMT. In such circumstances the operating system or hyperviser or other trusted system software of a computer system in which the cache of the present invention is implemented such as the computer system shown in and described above is in charge of associating a process with an RMT ID when the process is assigned a hardware context for execution. Also it is noted that the LNregs of could be integrated into the address decoder and the decoder activates cache line if the contents in LNreg matches the context RMT ID and the n k index bits of the memory address supplied to the cache. The LNregs are updated when cache line replacements occur and a new line s context RMT ID and index bits are written to the RMT ID field and line num field of a selected LNreg respectively.

The circuitry shown in integrates comparison logic into a traditional address decoder making use of the existing logic and routing of the traditional address decoder and maintaining similar timing characteristics. To implement the dynamic memory to cache mapping of the present invention the logic in a traditional address decoder that generates word line selection signals are made flexible using switches. The switches can be controlled by the values of bits in an LNreg to connect different address bits or their inverted values to the inputs of the logic gates as shown in expanded circuitry thus making the logic flexible. This implements the dynamic memory to cache mapping of the present invention.

In the circuitry shown in the connections between the address lines and the inputs of the decoder are controlled. The predecoders are moved from the location in a conventional Direct Mapped cache s address decoder circuit shown in phantom in as dotted gates to the locations shown in . The predecoders are 3 input NAND gates and control which cache line is activated given an index.

It is assumed that the LNregs are laid out external to the memory cell array . Since each cache line is associated with one LNreg the overhead of LNregs relative to the overall cache storage is n k d M where n k and d are defined as above and M is the total number of memory cells in each cache line including data tag flags and error correction code ECC bits. For example in a 64 kilobyte KB cache with 64 bit address and 64 byte cache line size n 10. The value of M varies since the numbers of tag flags and ECC bits are implementation dependent. As a rough estimation it is assumed that there are approximately 50 bits in total for tag flag and ECC bits and therefore M is approximately equal to 64 8 50 562. If 4 RMTs are allowed and it is desired to achieve good performance d 2 and k 4. The relative overhead of storage will be 16 562 which is approximately 2.9 . It is noted that the tag array and the data array may be separated requiring two sets of address decoders. In such circumstances the storage overhead will be 5.8 .

It is noted that another way to implement the decoder circuit is by using a content addressable memory CAM such that the LNregs are implemented as a CAM array.

Additionally the decoder circuit could also be implemented using alternate decoder designs such as that as shown in . Similar to the implementation shown in the decoder circuit includes address lines and drivers . The memory cell array is also shown. Also provided are 3 8 predecoder circuits connected between the address lines and the drivers wordline circuits which output wordlines to the memory cell array and permutation register PR circuitry which includes switches . In the implementation shown in the static connections in a traditional address decoder between the outputs of the 3 8 predecoder circuits and the final NOR gates in the address decoder are replaced with dynamic connections via switches controlled by the permutation registers. For each switch a 3 input NAND gate is used to generate a control signal. For every 3 address bits 8 switches and 8 3 input NAND gates are needed. The more heavily loaded predecoder lines due to the drain capacitance of the switches may be segmented with duplicated drivers.

The hardware required to support the mapping shown in can be faster than that in . The load on the long wires as well as the input lines of the logic gates that the long wires drive is also lower because of fewer switches and smaller switch sizes. Since the cache of the present invention has longer index bits the output of the 3 input NAND gate corresponding to the extra address bits needs to be ANDed with the output of the NOR gate as shown in the wordline circuit . This is done by replacing the first inverter in the word line buffer string with a 2 input NAND gate. By properly adjusting the transistor sizes of the 2 input NAND gate no extra delay is introduced.

Table 1 below shows HSPICE results for the address decoder of a traditional direct mapped cache versus the cache of the present invention referred to herein as Newcache . In all cases the extra delays are no greater than 5 ps which is less than 3 of the address decoder time shown in Table 1.

Since the overall cache access time is between 600 ps for the 8 KB cache to 800 ps for the 64 KB cache this increase in address decoder time is less than 1 of the overall cache access time.

There are two types of misses index misses and tag misses in the cache memory of the present invention. An index miss occurs if none of the LNregs matches the given RMT ID and index. None of the cache lines is selected if an index miss occurs. A tag miss occurs if the index hits in one LNreg but the tag of the selected cache line does not match the address tag. A tag miss essentially is the same as an ordinary miss in a traditional direct mapped cache whereas the index miss is a unique type of miss in the cache memory of the present invention. Since an index hit means the match of the context RMT ID and index bits tag misses only occur within the same process or among processes using the same RMT. Index misses occur early in the hardware pipeline during address decoding before the tag is read out and compared and this early miss signal could be used by the pipeline control logic to improve performance. For example the context RMT ID is known shortly after the Instruction Fetch stage and an index miss can be detected before even the tag is read out of the tag array .

The tag misses are conflict misses in the LDM cache since the addresses of the incoming line and the line in cache have the same index as well as the same context RMT ID but different tags. Since in a direct mapped cache at most one cache line can be selected at any time no two LNregs can contain the same index and the same context RMT ID . Therefore either the original line in the cache is replaced with the incoming line or the incoming line is not cached.

For index misses the new memory block can replace any cache line. The nomenclature utilized in the flowchart in is described in Table 2 below 

Beginning in step a determination is made as to whether a cache hit has occurred. A cache hit occurs if there is an index hit and a tag hit. If so step occurs wherein a cache access operation occurs as in a traditional direct mapped cache on the cache line C selected by the decoder. Otherwise step occurs wherein a determination is made as to whether an index miss has occurred. An index miss occurs when the selected cache line C does not match the context RMT ID and index bits of the memory block D. If an index miss has not occurred then a tag miss must have occurred at step . A tag miss always indicates a matching context RMT ID and lines C and D must use the same RMT which usually means that they belong to the same process or the same security or trust group. This interference is referred to as internal to a process or processes in the same security group. If a negative determination is made i.e. an index miss has not occurred step occurs.

In step a determination is made as to whether neither the incoming line D nor the selected line C is protected meaning that the interference is harmless. If so step occurs wherein the miss is handled normally as in a traditional cache. Otherwise if either C or D are protected meaning that the interference may leak out critical information step occurs wherein the cache interference is randomized due to the conflict between C and D. To avoid information leaking interference D does not replace C and since in a tag miss D can not replace cache lines other than C D is sent directly to the CPU core without being put in the cache. In an index hit but tag miss D cannot replace cache lines other than C because otherwise there will be two LNregs with the same contents. On the other hand since a miss should normally cause an eviction a random line is evicted which substitutes for the eviction of C as well as randomizes the interference. Otherwise the old cache lines tend to stay in the cache and new cache lines will not get cached.

If in step a determination is made that the miss is an index miss i.e. it is not a tag miss none of the LNregs match the RMT ID and index of D step occurs wherein C and D may or may not belong to the same process or if they belong to the same process they have different indices. Since for an index miss the new memory block D can replace any cache line a cache line is randomly selected with equal probability as in the RAND replacement algorithm and evicted. The interference caused by an index miss therefore is always randomized.

Compared with other commonly used replacement algorithms such as LRU pseudo LRU and FIFO the random replacement algorithm of the present invention requires less hardware cost to implement due to its stateless nature. It does require a Random Number Generator which is typically already available in a secure processor. Although the algorithm requires condition checks these checks are simple and stateless thus they can be easily implemented with simple combinational logic. Also the security of the algorithm relies on the quality of the random source which is preferably a true or pseudo random number generator TRNG or PRNG on chip. Further it is noted that the algorithm could be provided in either hardware e.g. as a hardwired circuit firmware or software e.g. on one or more computer readable mediums such as non volatile memory read only memory ROM flash memory disk etc. . In the performance statistics discussion below accompanying the replacement algorithm is assumed to be implemented in hardware.

Additionally the detailed HSPICE simulations described above in connection with Table 1 and show that the address decoder of the present invention is no more than 3 of the conventional Direct Mapped cache and no more than 1 of the overall cache access time. Although a fast SA cache could have an access time close to that of the present invention the power consumption is significantly higher up to 4 times higher than Newcache as shown in .

Cache misses have been classified as compulsory misses capacity misses or conflict misses. Compulsory misses e.g. on a cold start are common to all caches. Capacity misses e.g. when the program s working size exceeds the size of the cache only depend on cache size. Conflict misses have been shown to depend on the cache organization e.g. set associativity and capacity. To reduce conflict miss rate a traditional way is to increase associativity. However this impacts cache access time and power efficiency. Increasing capacity can reduce capacity misses as well as conflict misses. However this is often not feasible in practice due to the limited silicon real estate budget.

As demonstrated by the present invention conflict misses can be largely independent of cache capacity. Regardless of the real capacity of the physical cache in the Newcache with an n k bit index has less conflict misses than a traditional direct mapped cache with 2cache lines thereby providing enhanced performance over known cache designs. The total number of misses in Newcache has the following bounds Miss Newcache 2 CompulsoryMiss CapactiyMiss 2 ConflictMiss DM 2 Equation 1 Miss Newcache 2 max Miss DM 2 Miss FA 2 Equation 2 where Miss Arch Size denotes the set of misses in a cache of type Arch with a capacity of Size and A is the number of elements in set A. In Equation 1 above the left side of the equation can be decomposed to the same first 2 terms as the right side plus a third term ConflictMiss Newcache 2 . Hence Equation 1 shows that the conflict misses of Newcache is less than or equal to that of a direct mapped cache with 2cache lines. Indeed as verified below this bound is asymptotically tight and is a good approximation of the true miss rate in real configurations. This means that the conflict misses of Newcache are largely independent of its actual cache capacity. The conflict misses are indeed dependent on the size of the larger LDM cache 2 rather than on the actual physical cache size 2. This property of the cache of the present invention gives cache designers the ability to control the conflict miss rate at the desirable level by choosing the proper number of index bits while choosing the capacity independently based on cost or other needs. This avoids the speed and power penalty due to higher associativity and allows finer grained control on allocating capacity to the cache and making the best use of the resource.

Equation 2 shows the lower bound of the miss rate of the Newcache. The Newcache can not have a lower miss rate than a FA cache with the same capacity. Also since the physical cache is a subset of the LDM cache as shown in a hit in the physical cache is always a hit in the LDM cache while the opposite is not necessarily true. Therefore the physical cache always has more misses that the LDM cache does i.e. the Newcache with 2cache lines always has more misses that a traditional DM cache with 2cache lines. The lower bound of the miss rate of the Newcache with 2cache lines is therefore the maximum of the miss rate of a FA cache with 2cache lines and the miss rate of a DM cache with 2cache lines.

For experimental confirmation of miss rates Newcache and traditional direct mapped DM set associative SA and fully associative FA caches were simulated on a cache simulator derived from sim cache and sim cheetah of the simplescalar toolset. All 26 SPEC2000 benchmarks were run for 1 billion instructions with appropriate fast forward counts ranging from 2 million instructions to 3 billion instructions. illustrates the accuracy of the bounds derived in Equations 1 and 2 above. The bounds are normalized to the real miss rate to show the relative accuracy. The simulation is done for Newcache with 64 byte lines for n 6 to 10 i.e. 4K bytes to 64K bytes capacity with cache indices that are k 3 to 4 bits longer. Except for one point the bounds are always within the 10 range of the real miss rate and when n k or k gets larger the accuracy increases. Indeed the derived bounds are asymptotically tight meaning that the equality in Equation 1 holds when k and n k are large.

Table 3 below compares the miss rates of Newcache with the DM cache and the 2 way and 4 way SA caches with LRU replacement. FA caches and 8 way SA caches with RAND replacement are also included to show the effectiveness of the replacement algorithm of the present invention discussed above in connection with . The lowest miss rate in each column is highlighted in bold and normalized to 1 in parenthesis . The miss rates of Newcache is represented in the last 2 rows Newcache almost always achieves the lowest miss rates achieved in each column by traditional caches.

The power efficiency of Newcache was analyzed with regard to two aspects the per access energy of the cache and the overall power consumption. Modern caches are usually organized as a set of subarrays to achieve fast timing and low power dissipation. The main sources of dynamic power include the power for routing address bits in and data bits out via H trees as shown by in and the power on word lines and bit lines since they are heavily loaded. Since Newcache is direct mapped only a minimum number of subarrays need to be activated in each access which minimizes the power consumed on word lines and bit lines giving the low per access energy.

Analysis of the security of the present invention is now discussed. The cache of the present invention adopts the randomization approach on cache misses to mitigate information leakage. This is similar in concept to that used in prior art caches with some differences for enhancing performance. The information leakage channel is modeled as a classic discrete time synchronous channel. The input symbol of the channel is the line number i of the cache line accessed by the victim that would cause an eviction and the output symbol is the line number j of cache line for which the attacker observes an eviction. Note that the same physical cache line may have different line numbers from the victim and attacker s points of view e.g. in the proposed cache they may use different RMTs . To make the capacity of this channel zero the randomization should meet the following requirement for all protected cache lines Equation 3 where P j i Pr output j input i . In other words given an access at line i by the victim that would cause an eviction the attacker can observe an eviction at any line number with equal probability. From the attacker s point of view although the attacker can observe a cache eviction he has no idea which cache line was accessed by the victim. Below it is shown that the cache of the present invention meets this condition. Given a cache miss that causes eviction the following cases need to be considered 

Clearly the randomization feature of the algorithm of the present invention satisfies Equation 3 above and thus achieves zero channel capacity. Some additional benefits of the cache of the present invention are discussed below 

Fault Tolerance Memory to cache remapping is a common technique used in fault tolerant cache design. In traditional caches a memory block mapped to a faulty line set is statically remapped to another good line set. Such schemes increase the number of conflict misses since the remapped cache line set is now shared by more memory addresses. They also increase the number of capacity misses since the faulty lines reduce cache capacity. The proposed cache architecture can provide fault tolerance in a similar manner using remapping but with better performance. Due to the dynamic memory to cache mapping of the present invention a cache of size s with p faulty cache lines is equivalent to a cache of size s p which has the same conflict miss rate as shown by Equation 1. In other words faulty cache lines in the cache of the present invention only increase capacity misses but not conflict misses.

Hot Spot Mitigation Due to spatial and temporal locality the references to a small number of cache lines account for a majority of the total cache references. The more frequently accessed cache lines generate more heat causing hot spots. Such unevenly distributed cache line accesses however are mostly avoided by the cache of the present invention. This is because the replacement algorithm of the present invention maps memory blocks to randomly selected physical cache lines which avoids clustering of frequently accessed cache lines.

Optimization for Power Efficiency With the ability of mapping memory blocks to arbitrary physical cache lines the present invention can also facilitate low power design. For example by adaptively turning off cache lines based on a program s working set the power efficiency of the cache can be further improved with minimal impact on performance. An analysis similar to that in the discussion of fault tolerance can show that turning off cache lines in the proposed cache will cause fewer additional cache misses than in traditional caches.

Benefits for Cache Partitioning and Locking In traditional caches such as set associative caches cache partitioning is not trivial and has many restrictions. A set associative cache can be partitioned in two ways horizontal partitioning and vertical partitioning. Horizontal partitioning divides cache sets into subgroups each of which forms a partition. One issue with this scheme is that the number of cache sets in each partition has to be a power of 2. This severely limits the flexibility of choosing a partition size. In addition the address decoder has to be redesigned so that it can be reconfigured to index different numbers of cache sets. Vertical partitioning partitions cache ways degrees of associativity into subgroups. As most caches have limited associativity the number of partitions can be very limited. In addition the partitions have lower associativity than the original cache thus incurring higher conflict miss rates.

Cache line locking is a more flexible way to partition a cache as in PLcache. It however also suffers from higher conflict miss rates. In a set associative cache the locked line s in a cache set reduce the effective associativity of the set thus incurring more conflict misses. In contrast the cache of the present invention does not have restrictions on the number of physical cache lines in a cache i.e. the number of cache lines s can be an arbitrary positive integer unlike in traditional caches where s should be a power of 2. Therefore cache partitioning and locking mechanisms built upon the cache of the present invention has the highest flexibility in allocating cache lines to a partition. Moreover as shown above partitioning a cache incurs fewer additional cache misses in the present invention than in traditional caches thus providing better performance.

The present invention can also be applied to computer systems having more than one type of memories such as the computer system shown in . As shown therein the computer system includes two types of memories a slow memory and a fast memory . The central processing unit CPU is in communication with both memories and executes a replacement algorithm . The CPU tries to find information in the faster memory . If it cannot it fetches it from the slow memory and uses the replacement algorithm e.g. one or more of the replacement algorithms discussed herein or other type of replacement algorithm to replace some information in the fast memory e.g. if the fast memory is already full. The dynamic remapping described herein is still applicable to prevent information leakage. Additionally the two level logical mapping shown in and discussed above can also be applied to improve the performance of dynamic mapping if desired. It is also noted that each level of the mapping can also be generalized to set associative or other mapping e.g. rather than direct mapping in the first level of mapping to the LDM cache and fully associative mapping in the second level from LDM cache to physical cache as described above .

A generalized version of the replacement algorithm of the present invention indicated generally at is shown in . In step a determination is made as to whether an index hit occurred. If a positive determination is made step occurs wherein a determination is made as to whether a tag hit occurred. If so step occurs wherein a cache access procedure is invoked. Such a procedure could include but is not limited to directly accessing the line in the cache corresponding to the matching tag.

If a negative determination has been made in step step occurs wherein a first user or vendor defined procedure procedure is invoked. If a negative determination has been made in step a second user or vendor defined procedure procedure is invoked in step . The user or vendor defined procedures could be any desired procedure for replacing contents in cache memory such as random replacement as discussed earlier or other suitable procedures. The algorithm can be implemented in hardware or in software for less time critical caches. For example the replacement algorithm could be a sequence of instructions in software or in firmware stored on disk flash memory or ROM.

Having thus described the invention in detail it is to be understood that the foregoing description is not intended to limit the spirit or scope thereof. What is desired to be protected is set forth in the following claims.

