---

title: Server-aided private set intersection (PSI) with data transfer
abstract: Existing private set intersection (PSI) protocol allows two parties to find intersection of their sets, but restricts learning any other information about each other's set except for its size. In general, the server-aided private set intersection with data transfer technique described herein provides a server-aided private set intersection (PSI) protocol that supports data transfers. The technique pertains to a method for providing a server-aided private set intersection protocol which allows two parties to transfer some of the information about their elements via an untrusted third party. The protocol involves (a) parties applying a shared pseudo-random permutation to each of their sets to create labels of the elements of the set, (b) sending the labels to the third party and (c) the third party performing data transfer between the two parties along with computation of intersection of sets received using a multi-share key.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09158925&OS=09158925&RS=09158925
owner: Microsoft Technology Licensing, LLC
number: 09158925
owner_city: Redmond
owner_country: US
publication_date: 20131127
---
Private set intersection PSI allows two parties to find the intersection of their sets without revealing the data elements of their sets to each other. PSI has numerous real world applications including privacy preserving data mining location based services and genomic computations. More specifically a PSI protocol allows two parties Pand Pto find the intersection of two sets Sand Sfrom some universe U without having to disclose the sets to each other. In other words with a PSI protocol Pand Pcan find the intersection I S Sof their sets without learning any information about the other party s set beyond its size.

With a server aided PSI protocol the two parties Pand Pcan in addition outsource some of their computations to an untrusted server instantiated for example in the cloud. Server aided PSI protocols are more efficient for clients than traditional PSI protocols by several orders of magnitude.

This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used to limit the scope of the claimed subject matter.

The server aided private set intersection with data transfer technique described herein provides a server aided private set intersection PSI protocol that supports data transfers. The PSI protocol of the technique can operate in a server aided setting where the parties have access to an untrusted server that makes its computational resources available as a service. In one embodiment the protocol requires only a linear number of block cipher invocations a pseudo random permutation and the execution of a standard plaintext set intersection algorithm.

The technique allows two clients to transfer information about some of their data elements over a network via a server. To this end in one embodiment of the technique a first client generates for each element in the first client s set S a label for the element an identifier for the element and an encrypted form for the data associated with the element that was encrypted using a two share secret key. The first client sends to a server for each element in set S the label for each element the identifier for each element and the first share of the two share secret key. The first client also sends to the second client for each element in the set S the identifier for each element the encrypted data associated with each element and the second share of the two share secret key. Similar to the first client the second client sends labels generated for the elements of the second client s set Sto the server. The server computes the intersection of the labels of the received sets and sends to the second party for each element in the intersection the label the identifier for the element and the first share of the two share secret key. The second client can then decrypt the data associated with each element in the intersection of the sets using the labels the identifiers and the first and second shares of the two share secret key. By virtue of this technique no party to the transaction neither the clients nor the server discover any of the clients data that they do not wish to reveal.

In the following description of the server aided private set intersection with data transfer technique reference is made to the accompanying drawings which form a part thereof and which show by way of illustration examples by which the server aided private set intersection with data transfer technique described herein may be practiced. It is to be understood that other embodiments may be utilized and structural changes may be made without departing from the scope of the claimed subject matter.

The following sections provide an introduction an overview of multi party computation an overview of the notation used in this description a description of server aided private set intersection without data transfer as well as exemplary embodiments of the server aided private set intersection with data transfer technique described herein. An exemplary data flow diagram and exemplary scenarios for practicing the technique are also described.

As a preliminary matter some of the figures that follow describe concepts in the context of one or more structural components variously referred to as functionality modules features elements etc. The various components shown in the figures can be implemented in any manner. In one case the illustrated separation of various components in the figures into distinct units may reflect the use of corresponding distinct components in an actual implementation. Alternatively or in addition any single component illustrated in the figures may be implemented by plural actual components. Alternatively or in addition the depiction of any two or more separate components in the figures may reflect different functions performed by a single actual component.

Other figures describe the concepts in flowchart form. In this form certain operations are described as constituting distinct blocks performed in a certain order. Such implementations are illustrative and non limiting. Certain blocks described herein can be grouped together and performed in a single operation certain blocks can be broken apart into plural component blocks and certain blocks can be performed in an order that differs from that which is illustrated herein including a parallel manner of performing the blocks . The blocks shown in the flowcharts can be implemented in any manner.

In the problem of private set intersection PSI two parties want to learn the intersection of their sets without revealing to each other any information about their sets beyond the intersection. PSI is a fundamental problem in security and privacy that comes up in many different contexts. Consider for example the case of two or more institutions that wish to obtain a list of common customers for data mining purposes or a government agency that wants to learn whether anyone on its no fly list is on a flight s passenger list. PSI has found applications in a wide range of settings such as genomic computation location based services and collaborative botnet detection.

PSI is a special case of the more general problem of secure multi party computation MPC . In this problem each party holds its own private input and the goal is to collectively compute a joint function of the participants inputs without leaking additional information and while guaranteeing correctness of the output. The design and implementation of practical MPC protocols has been an active area of research over past decade with numerous efforts to improve and optimize software implementations and to develop new frameworks. A large body of work therefore has focused on the design and implementation of efficient special purpose PSI protocols.

As the trend towards larger and larger databases continues governments and private organizations often manage massive databases that store billions of records. Therefore for any PSI and MPC in general solution to be of practical interest in such settings it needs to efficiently process sets with tens or hundreds of millions of records.

A promising approach to address multi party computation is server aided or cloud assisted MPC. In this variant of MPC the standard setting is augmented with a small set of servers that have no inputs to the computation and that receive no output but that make their computational resources available to the parties.

This section provides various preliminaries and notation which are useful in understanding the following description of the server aided private set intersection technique described herein.

Throughout this description parties to a described protocol that are not the server or untrusted third party may be referred to as clients. The terms the third party untrusted third party and server may also be used interchangeably.

The protocols described herein are single round protocols and have roughly the following structure. First the clients process their input sets to generate a set of labels T which they will send to the server or third party. The server then performs an intersection on the sets it receives and returns the results. For the protocols secure against a malicious or untrusted server the clients then perform some local checks and extract the intersection from the server s message. For the purpose of this description a simplified notion of non collusion is used wherein two parties Pand Pare considered to not collude if they are not simultaneously corrupted by the adversary e.g. either Pis malicious or Pis but not both .

In some embodiments of the technique the server is treated in a conservative manner as untrustworthy meaning for instance that the server cannot be trusted to maintain the confidentiality of information provided to the server . However in some scenarios it will be assumed that the server does not collude with any participant module to circumvent the security provisions described herein. Further in some scenarios it will be assumed that the parties to the joint computation are semi honest entities at worst. This means that the entities can be expected to follow a prescribed security protocol. But the entities may try to leverage the information that they discover in the course of this protocol to uncover additional information to which they are not entitled .

A private key encryption scheme such as the one described herein is a set of three polynomial time algorithms Gen Enc Dec that work as follows. Gen is a probabilistic algorithm that takes a security parameter k in unary and returns a secret key K. Enc is a probabilistic algorithm that take a key K and an n bit message m and returns ciphertext C. Dec is a deterministic algorithm that takes key K and a ciphertext c and returns m if K was the key under which c was produced.

In all the protocols described below k denotes the computational security parameter i.e. the key length for a Pseudo Random Permutation PRP while s denotes a statistical security parameter. For 1 the set S is defined as

By way of background and before describing the server aided private set intersection with data transfer technique a server aided private set intersection without data transfer protocol for a semi honest server or any collusion of malicious parties is first described. The protocol is shown in Table 1 and described in .

Referring to let Sbe the set of party P. The parties start by jointly generating a secret k bit key K for a Pseudo Random Permutation PRP F as shown in block . Each party randomly permutes the set F S which consists of labels computed by evaluating the PRP over the elements of the party s appropriate set as shown in block and sends the permuted set to the server as shown in block . The server then simply computes and returns the intersection of the labels F S through F S see blocks . Each party can then know which elements they have in common with the other parties.

Intuitively the security of the protocol follows from the fact that the parties never receive any messages from each other and their only possible malicious behavior is to change their own PRP labels which simply translates to changing their input set. The semi honest server only receives labels which due to the pseudo randomness of the PRP reveal no information about the set elements.

The protocol described in Table 1 is secure in the presence 1 a semi honest server and honest parties or 2 a honest server and any collusion of malicious parties.

Each Pinvokes the PRP S times while the server in one embodiment only performs a plaintext set intersection and no cryptographic operations. However the technique can use any of the existing algorithms for set intersection. In one embodiment of the technique a folklore hash table insertion lookup which runs in nearly linear time is used.

The protocol can be executed asynchronously where each party connects at a different time to submit his message to the server and later to obtain the output.

In many practical applications of PSI one of the parties also wishes to transfer some information related to the elements in the intersection. More precisely consider a scenario where Phas in addition to its set S a database db that associates to each element x of Ssome data which is denoted as db x . In such a scenario Pmay wish to transfer the set db x x S S to P where Sis the set of P. While the PSI protocol described above is not sufficient for this scenario it can be used as a building block in a more complex protocol to achieve such a data transfer.

As shown in block a first party generates a set of triples for each element in set Scomprising a label for the element an identifier for the element and an encrypted form for the data associated with the element that was encrypted using a two share secret key. The labels for each element in Sare generated using a shared key and a PRP.

As shown in block the first party sends to the second party for each element in the set S the identifier for each element the encrypted data associated with each element and the second share of the two share secret key. Additionally the first party sends to a third party for each element in set S the label for each element the identifier for the data associated with each element and the first share of the two share secret key as shown in block . The second party also sends labels generated for the elements of set Sto the third party block . The labels for the elements of the set Sare generated using the same shared key and PRP that the first party used.

Once the third party receives the aforementioned data from the first and second parties the third party computes the intersection of the labels of the sets and sends to the second party for each element in the intersection the label the identifier associated with the element and the first share of the two share secret key as shown in block .

The second party can then decrypt the data associated with each element in the intersection of the sets using the labels the identifiers and the first and second share of the two share secret key as shown in block . This can be done by XORing the shares to recover the key and then using the key to decrypt the data.

Table 2 depicts a two party PSI protocol with data transfer that is secure against a semi honest server and semi honest Pand P. This protocol is described in greater detail with respect to .

As shown in block the first party Pgenerates a first secret key K a second secret key K and a third secret key K and sends the second secret key Kto the second party P. Key Kis used to generate encryption keys for data db x associated with each element of set S while key Kis used to generate a label for an element x of a set. Key Kis used to generate an identifier idfor each element x of a set.

 1 Using K a two share secret key Kis generated. This two share secret key Kis made up of a first share zand a second share z. In one embodiment of the technique this is done by generating the first share zby applying a pseudo random permutation to element x concatenated with a first string using key K. Similarly the second share zis generated by applying a pseudo random permutation to element x concatenated with a second string using key K. The key Kis then generated by performing an XOR operation on first share zand a second share z. It is important to note that a first share zand a second share zof a key are generated for each element of S. Furthermore other procedures for generating a two part or even multi part key could also be used.

As shown in block the first party Psends to the third party a set of triples for each element comprising the identifier id the first share of the key zand the label l. The order of the triples can be randomly shuffled prior to sending them. The first party Palso sends to Pa set of triples for each element comprising the identifier id the second share of the key zand the encrypted data C db x as shown in block . This set of triples can also be randomly shuffled prior to sending them to P.

The second party Pgenerates labels for the elements in P s set Sby permuting the elements using key Kand a PRP and sends the labels for each element in set Sto the untrusted third party see block .

The third party compares the set of labels received from Pand the set of labels received from Pto find the intersection I of the permuted labels of Pand P and sends to Pall triples it received from Pthat have a label inside the intersection block . Pcan then decrypt the triples that Preceived from Pcomprising P s encrypted data C db x for the elements that Pand Phold at the intersection of the sets Sand Susing both shares of the two share secret key block .

Each Pinvokes the PRP S times while the server in one embodiment only performs a plaintext set intersection and no cryptographic operations. However the technique can use any of the existing algorithms for set intersection. In one embodiment of the technique a folklore hash table insertion lookup which runs in nearly linear time is used.

The protocol can be executed asynchronously where each party connects at a different time to submit his message to the server and later to obtain the output.

As mentioned previously although the descriptions of the protocols refer to parties that hold data sets e.g. first and second parties for example and a third party that computes the intersection of the data sets those with ordinary skill in the art will understand that the parties mentioned can operate in a server client setting. Parties to a described protocol that are not referenced as the server or untrusted third party may hence be referred to as clients. Furthermore the terms the third party untrusted third party and server may also be used interchangeably. The following description describes the protocol described in in terms of client and server side processing. It should be noted that the server may actually be more than one server or computing entity working in a computing cloud. Likewise although the description refers to first and second clients many more clients may transfer data about their sets using the server.

Referring to as shown in block the first client Pgenerates a first secret key K a second secret key K and a third secret key K and sends the second secret key Kto the second client P.

 1 using K a two share secret key Kis generated. This two share secret key Kcomprises a first share zand a second share z.

As shown in block the first client Psends to the server a set of triples for each element comprising the identifier id the first share of the key zand the label l. The first client Psends to Pa set of triples for each element comprising the identifier id the second share of the key zand the encrypted data C db x as shown in block . The set of triples in both of these instances are randomly shuffled prior to sending.

Referring back to as shown in block the server receives from the first client Pa set of triples for each element comprising the identifier id the first share of the key zand the label l. The server receives from the second party Pthe labels for each element in set S see block .

The server compares the set of labels received from Pand the set of labels received from Pto find the intersection I of the permuted labels of Pand P block and sends to Pall triples it received from Pthat have a label inside the intersection block . As discussed above the intersection of the labels can be found in a variety of ways such as for example by computing a plain text intersection on the labels.

Exemplary processes for practicing the technique having been provided the next section provides a discussion of an exemplary architecture for practicing the technique.

The server module can represent any type of computing functionality. In one case it corresponds to a computer server that includes processing functionality input functionality output functionality storage functionality etc. In one scenario the server module may represent a processing resource in a cloud computing system such as a data center that provides a cloud computing service. The server module can represent a single resource provided at a single location or a distributed resource that is distributed over plural locations. For example the server module can correspond to a single physical machine alternatively the server module can represent a virtual server module that maps to corresponding underlying computing hardware in any manner.

Each client module can likewise represent any type of functionality that includes processing functionality input functionality output functionality storage functionality etc. In illustrative concrete examples any client module can correspond to a stationary personal computing device a laptop or net book computing device a personal digital assistant PDA computing device a stylus type computing device a mobile phone device a game console a set top box and so on.

The server module is connected to the client modules P and P via any type of network . The network may represent any type of point to point or multi point coupling mechanism. In one implementation the network can correspond to a wide area network e.g. the Internet a local area network or combination thereof. The network can include any combination of wireless links wired links routers gateways etc. as governed by any protocol or combination of protocols. The server module can represent a remote or local resource in relation to any of the participant modules.

In one implementation of the technique using the architecture shown in each of the clients apply a shared pseudo random permutation PRP to the elements of their data sets using a shared secret key to create labels of the elements of their set and send these labels to the server . The first client further generates an identifier for each of the elements of the first party s set a multi share secret key for each of the elements of the first party s set which could be for example a two share key and encrypted data associated with each of the elements of the first client s set using the multi share secret key. The first client sends the encrypted data for all the elements in the first client s set to the other parties along with a portion of the multi share secret key and the identifier for each element of the first client s set. The first client sends the server the remaining portions of the multi share key and the identifiers for each element. Each client receives for each of the elements in the intersection the labels for the intersection of the data elements the identifiers and the remaining portions of the multi share key from the server . Each client can then decrypt the encrypted associated data for each of the elements in the intersection of the sets using the labels the identifiers and all portions of the multi share key for each element.

The server aided private set intersection with data transfer technique can applied to many real world applications such as for example regarding patients medical data transfer verification that passengers on a flight are not on a no fly list or the transfer of some but not all user data for on line applications. These applications are described in brief below but there are many many other applications that can gainfully employ the server aided private set intersection with data transfer technique.

There are many scenarios where one hospital may not want to divulge the details about individual patient records to either another hospital or a server. For example in the case where two hospitals have treated some of the same patients it may be desirable for one hospital to transfer patient data about patients they have both treated from one hospital to another while it would not be desirable to transfer data about all patients. In this case the server aided private set intersection with data transfer technique can be used to transfer patient data about patients both hospitals have treated in order for each hospital to have a complete record of these patients medical histories.

There are also many scenarios where an airline might not want to divulge the details about travelers on their flights to a government agency or to another country. For example an airline might not want to divulge their entire passenger list to a government agency or a foreign country in order for the government agency or the foreign country to determine if any of the passengers are on a do not fly list. In this case the server aided private set intersection with data transfer technique can be used to determine which scheduled passengers on a flight are on the do not fly list without revealing data about the other scheduled passengers.

There are also many scenarios where one provider of an on line service or application for example a gaming service or application might want to share information about users that the on line service application has in common with other on line applications or services. In this case it probably would not want to provide information about all of its users. In this case the server aided private set intersection with data transfer technique can be used to provide information about users the two on line services applications have in common without revealing data about other users.

The server aided private set intersection with data transfer technique described herein is operational within numerous types of general purpose or special purpose computing system environments or configurations. illustrates a simplified example of a general purpose computer system on which various embodiments and elements of the server aided private set intersection with data transfer technique as described herein may be implemented. It should be noted that any boxes that are represented by broken or dashed lines in represent alternate embodiments of the simplified computing device and that any or all of these alternate embodiments as described below may be used in combination with other alternate embodiments that are described throughout this document.

For example shows a general system diagram showing a simplified computing device . Such computing devices can be typically be found in devices having at least some minimum computational capability including but not limited to personal computers server computers hand held computing devices laptop or mobile computers communications devices such as cell phones and PDA s multiprocessor systems microprocessor based systems set top boxes programmable consumer electronics network PCs minicomputers mainframe computers audio or video media players etc.

To allow a device to implement the server aided private set intersection with data transfer technique the device should have a sufficient computational capability and system memory to enable basic computational operations. In particular as illustrated by the computational capability is generally illustrated by one or more processing unit s and may also include one or more GPUs either or both in communication with system memory . Note that that the processing unit s of the general computing device may be specialized microprocessors such as a DSP a VLIW or other micro controller or can be conventional CPUs having one or more processing cores including specialized GPU based cores in a multi core CPU. When used in special purpose devices such as the server aided private set intersection with data transfer technique the computing device can be implemented as an ASIC or FPGA for example.

In addition the simplified computing device of may also include other components such as for example a communications interface . The simplified computing device of may also include one or more conventional computer input devices e.g. pointing devices keyboards audio and speech input devices video input devices haptic input devices devices for receiving wired or wireless data transmissions etc. . The simplified computing device of may also include other optional components such as for example one or more conventional computer output devices e.g. display device s audio output devices video output devices devices for transmitting wired or wireless data transmissions etc. . Note that typical communications interfaces input devices output devices and storage devices for general purpose computers are well known to those skilled in the art and will not be described in detail herein.

The simplified computing device of may also include a variety of computer readable media. Computer readable media can be any available media that can be accessed by computer via storage devices and includes both volatile and nonvolatile media that is either removable and or non removable for storage of information such as computer readable or computer executable instructions data structures program modules or other data. Computer readable media may comprise computer storage media and communication media. Computer storage media refers to tangible computer or machine readable media or storage devices such as DVD s CD s floppy disks tape drives hard drives optical drives solid state memory devices RAM ROM EEPROM flash memory or other memory technology magnetic cassettes magnetic tapes magnetic disk storage or other magnetic storage devices or any other device which can be used to store the desired information and which can be accessed by one or more computing devices.

Storage of information such as computer readable or computer executable instructions data structures program modules etc. can also be accomplished by using any of a variety of the aforementioned communication media to encode one or more modulated data signals or carrier waves or other transport mechanisms or communications protocols and includes any wired or wireless information delivery mechanism. Note that the terms modulated data signal or carrier wave generally refer to a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. For example communication media includes wired media such as a wired network or direct wired connection carrying one or more modulated data signals and wireless media such as acoustic RF infrared laser and other wireless media for transmitting and or receiving one or more modulated data signals or carrier waves. Combinations of any of the above should also be included within the scope of communication media.

Further software programs and or computer program products embodying some or all of the various embodiments of the server aided private set intersection with data transfer technique described herein or portions thereof may be stored received transmitted or read from any desired combination of computer or machine readable media or storage devices and communication media in the form of computer executable instructions or other data structures.

Finally the server aided private set intersection with data transfer technique described herein may be further described in the general context of computer executable instructions such as program modules being executed by a computing device. Generally program modules include routines programs objects components data structures etc. that perform particular tasks or implement particular abstract data types. The embodiments described herein may also be practiced in distributed computing environments where tasks are performed by one or more remote processing devices or within a cloud of one or more devices that are linked through one or more communications networks. In a distributed computing environment program modules may be located in both local and remote computer storage media including media storage devices. Still further the aforementioned instructions may be implemented in part or in whole as hardware logic circuits which may or may not include a processor.

It should also be noted that any or all of the aforementioned alternate embodiments described herein may be used in any combination desired to form additional hybrid embodiments. Although the subject matter has been described in language specific to structural features and or methodological acts it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the specific features or acts described above. The specific features and acts described above are disclosed as example forms of implementing the claims.

