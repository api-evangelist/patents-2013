---

title: System and method for managing code isolation
abstract: A computing system is configured to use a trampoline to isolate sensitive code in a virtual environment and in other applications. An import table may describe the entry points of a privileged code module or driver that generates privileged code. A system and method loads a shadow kernel to facilitate isolating the linkage between drivers and the rest of the system. The shadow kernel may be a copy of the operating system kernel that does not have the same integral position in the operation of the computing device. The shadow kernel may be used as a template for creating a jump table to redirect more critical privileged resource access requests from specially loaded kernel mode drivers to the PVM. All requests may pass through the PVM, which redirects non-critical functions to the original kernel. Multiple copies of a given driver or code module may be loaded in a given session.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09582302&OS=09582302&RS=09582302
owner: Citrix Systems, Inc.
number: 09582302
owner_city: Fort Lauderdale
owner_country: US
publication_date: 20130307
---
This application is a continuation application of and claims priority to co pending U.S. patent application Ser. No. 12 381 065 filed on Mar. 5 2009 and having the same title.

The present application is related by subject matter to U.S. Nonprovisional patent application Ser. No. 11 525 727 filed on Sep. 22 2006 entitled Dynamic Table Configuration in a Virtual Machine. 

This invention relates generally to managing computing resources and more specifically to a system and method for managing code isolation of privileged code.

A system for managing resources in a computing device comprises a processor a manager operably connected to the processor a host environment controllable by the manager said host environment comprising privileged code and an isolated environment controllable by the manager the isolated environment being configured to isolate the privileged code of the host environment.

A system for managing resources in a virtual machine comprises a processor a virtual machine manager operably connected to the processor a host environment controllable by the virtual machine manager an application coupled to the host environment and configured to generate a non privileged resource request a privileged driver said privileged driver being configured to issue a privileged resource request to an API a process virtual machine PVM configured to receive the privileged resource request from the privileged driver and to receive the non privileged resource request from the application the PVM being further configured to modify one or more of the privileged resource request and the non privileged resource request to create one or more modified resource requests and an operating system OS kernel configured to provide a response upon receipt from the PVM of one or more modified resource requests from the PVM.

A method for managing resources in a virtual machine comprises issuing a privileged resource request to an API by a privileged driver receiving the privileged resource request by a PVM modifying the privileged resource request by the PVM receiving the modified resource request by an OS kernel acting on the modified resource request according to OS rules by the OS kernel receiving the transmitted action from the OS kernel by a device driver associated with a device performing functions associated with the action according to driver rules by the device driver and receiving and storing or otherwise disposing of the modified resource request by a disk operably connected with the device driver.

A method for managing resources in a virtual machine comprises issuing a privileged resource request to an API by a privileged driver receiving the privileged resource request by a PVM modifying the privileged resource request by the PVM receiving the modified resource request by an OS kernel and providing a response by the OS kernel upon receipt from the PVM of one or more modified resource requests by the OS kernel.

A computer readable storage medium having embodied thereon a program the program being executable by a computer to perform a method for capturing and sending data that comprises issuing a privileged resource request to an API by a privileged driver receiving the privileged resource request by a PVM modifying the privileged resource request by the PVM receiving the modified resource request by an OS kernel and providing a response by the OS kernel upon receipt from the PVM of one or more modified resource requests by the OS kernel.

Virtual machines VMs allow a computer to simultaneously support two or more computing environments. A computer environment comprises the operating system user applications and data. A VM is configured to borrow computing resources such as CPU disk or memory from a host computer such that the VM may co exist alongside the host computer as a guest computer.

Due to a large software footprint current VMs cannot be easily transported from one host computer to another host computer. To be portable the VM may include the capability to adapt to a given host environment and reconfigure its resources based on the presence or absence of hardware and or operating system resources on the host system. Additionally to protect the integrity of the resources and promote their proper functionality the resources on the guest computer may remain isolated from the resources on the host computer and vice versa.

When a VM accesses operating system resources on the host computer the host computer isolates certain operating system resources e.g. the file system registry kernel objects and or services from the guest computer.

The embodiments discussed herein are illustrative of one example of the present invention. As these embodiments of the present invention are described with reference to illustrations various modifications or adaptations of the methods and or specific structures described may become apparent to those skilled in the art. All such modifications adaptations or variations that rely upon the teachings of the present invention and through which these teachings have advanced the art are considered to be within the scope of the present invention. Hence these descriptions and drawings should not be considered in a limiting sense as it is understood that the present invention is in no way limited to only the embodiments illustrated.

Generally the responsibility of an arbitrary VMM is to detect and mitigate or virtualize access to abstract resources. In hypervisor hardware based VMMs resource access is detected by trapping processor instructions that may otherwise cause unexpected errors or system corruption if allowed to execute unmodified. These requests are transformed by the VMM into harmless requests or emulated to ensure inconsistencies do not occur in the system. In process virtual machines PVMs the virtual machine monitor executes in a configuration that is much more tightly coupled with the underlying operating system and typically execute with peer privilege with respect to the operating system itself. In contrast hypervisor hardware based virtual machine monitors typically executes with supervisory privilege providing the hypervisor hardware based VMM with a conceptually easy way to mitigate the aforementioned improper resource access requests.

The fact that PVMs are peers of the operating system makes it extremely challenging for PVMs to virtualize all resource requests in the system since there are many ways in which a resource access might escape detection. By operating in conjunction with the operating system it is usually simple for the PVM to intercept accesses from user mode non privileged applications. However when faced with privileged code e.g. privileged drivers or other kernel mode code the traditionally accepted ways in which PVMs operate become unusable.

Most software programs share a large amount of common code. In a given set of software programs this common code might include code to manipulate files such as creating files closing files writing to or reading from files and the like code to print data to the screen or other input output I O device code to perform mathematical functions such as square root and the like code that provides implementation of common data structures such as trees linked lists and the like code that manages threads and other common code.

Since the code to perform these types of operations is common such common code may be shared between programs and thus reduce memory consumption in the system. To accomplish this technique the operating system in question may provide shared libraries. Shared libraries may include a set of code modules that contain the common code described above.

In some operating systems the list of externally required functions required by a software program is known as the import table. The import table may comprise a list of all code routines functions that are missing from the software program executable code module yet are required by the module. As the software program is executed the operating system examines the import table for an application and resolves missing code functions by dynamically linking against the shared library. The shared library may contain the implementation code for these common functions. The process that the operating system uses to resolve missing code functions against a shared library is called symbol resolution.

At the conclusion of symbol resolution the software program is completely resolved meaning there are implementations present for all code routines required by the program to properly function. At this point the operating system begins execution of the program.

During the program s execution the program may request accesses to physical or logical resources such as the disk drive or screen. In typical computer systems this request is passed to the operating system kernel which then fulfills the request for the program. In modern operating systems all resource access is managed by the kernel in order to prevent two programs from accidentally modifying the same resource concurrently and in order to prevent malicious or buggy programs from accessing sensitive system resources.

The operating system may provide a standard way for programs to pass requests to the kernel. In typical operating systems this capability is implemented as a system call dispatcher a code routine that may be called by the program. The system call dispatcher is configured to receive the request from the program and to deliver it to the kernel via some operating system specific means.

The flow of I O requests is downward on the page as illustrated by an arrow . An application may respond to a need created either by input or by its own requirements. The application may issue a non privileged resource request originating in non privileged code to an API. The application may pass the non privileged resource request to a system call dispatcher . The system call dispatcher may be located on both sides of the boundary between non privileged user mode and privileged mode also known as kernel mode . The system call dispatcher may pass non privileged resource request to the operating system kernel .

Once the request is received by the kernel the kernel may fulfill the request deny it or take any number of other actions. Whatever action the kernel takes is transmitted to the appropriate device driver which then directs an associated device to perform one or more functions associated with the action. The device driver then forwards resulting output to disk for storage or other final disposition. Eventually the program is notified that the request is completed.

Again the flow of I O requests is downward on the page as illustrated by an arrow . The application and the resource request of are also shown in . Application may pass a non privileged resource request originating in non privileged code to a process virtual machine PVM . The PVM may be located on the privileged side of the boundary between non privileged user mode and privileged mode . The PVM inserts itself into the request processing pipeline intercepting the non privileged request prior to its reaching a kernel and modifying it to create a modified non privileged resource request . The PVM may virtualize the non privileged resource request by altering the non privileged resource request to an alternate namespace or otherwise modifying it. The modification may be based on a table of rules. The modification creates modified non privileged resource request .

The PVM may pass the non privileged resource request to operating system kernel . Once modified non privileged resource request is received by kernel kernel may fulfill the modified non privileged request deny it or take any number of other actions. Whatever action kernel takes may be transmitted to the appropriate device driver which then directs an associated device to perform any functions associated with the action. Device driver then forwards resulting output to disk for storage or other final disposition. Eventually the program is notified that the request is completed.

However the same PVM mediated interception technique cannot be applied to privileged code kernel mode . Throughout this application the term privileged driver shall be used to refer interchangeable to a driver located in privileged space and or originating in privileged code and a code module located in privileged space and or comprising privileged code. When a privileged driver is loaded into the system it will generate a privileged resource request to an API that may be dynamically transmitted directly to operating system kernel . This means that privileged resource request will not pass through PVM . Once privileged resource request is received by kernel kernel may fulfill privileged request deny it or take any number of other actions. Whatever action kernel takes may be transmitted to the appropriate device driver which then may direct an associated device to perform any functions associated with the action. Device driver then may forward any resulting output to disk for storage or other final disposition.

As illustrated in the architectural structure of modern operating systems prevents application of the PVM mediated interception technique to privileged code stems from the architectural structure of modern operating systems as illustrated in . is an illustration of a block diagram of a system that resolves a privileged driver s import table against the operating system kernel resulting that any calls made by the privileged driver will bypass the PVM. When a privileged code module or privileged driver is loaded into the system it may dynamically link directly against the operating system kernel.

The flow of I O requests is downward on the page as illustrated by arrow . Application may respond to a need created either by input or by its own requirements. The application may issue a non privileged resource request . The application may pass a non privileged resource request originating in non privileged code to process virtual machine PVM . PVM may be located on the privileged side of the boundary between non privileged user mode and privileged mode . The PVM inserts itself into the request processing pipeline intercepting the non privileged request prior to its reaching kernel and modifying it to create a modified non privileged resource request . The PVM may virtualize non privileged resource request by altering non privileged resource request to an alternate namespace or otherwise modifying it based on a table of rules thereby creating modified non privileged resource request .

PVM may pass modified non privileged resource request to operating system kernel . Once modified non privileged resource request is received by kernel kernel may read export table in response to instructions contained in privileged resource request . Export table may comprise export table instructions A D e.g. open file close file delete file rename file and the like. Using export table kernel may fulfill modified non privileged request deny it or take any number of other actions. Whatever action kernel takes may be transmitted to the appropriate device driver which then directs an associated device to perform any functions associated with the action. Device driver then forwards any resulting output to disk for storage or other final disposition.

However the same PVM mediated interception technique cannot be applied to privileged code kernel mode . Privileged driver may comprise import table . Import table may comprise import table instructions A D e.g. open file close file delete file rename file and the like. Import table instructions A D may be different from export table instructions A D. Privileged driver may generate privileged resource request . Privileged resource request and import table may be dynamically transmitted over linkage directly to operating system kernel . This means that privileged resource request will not pass through PVM .

Once privileged resource request and import table are received by kernel kernel may read export table in response to instructions contained in privileged resource request and the import table that helped generate it. Using export table kernel may fulfill privileged request deny it or take any number of other actions. Whatever action kernel takes may be transmitted to the appropriate device driver which then directs an associated device to perform any functions associated with the action. Device driver then forwards any resulting output to disk for storage or other final disposition. Eventually the program is notified that the request is completed.

In sum requests issued by the privileged driver will result in execution of code in the OS kernel thus bypassing the PVM.

Host environment may comprise for example user applications and data files stored within a host memory. Host environment may further access resources such as library files configuration files registries and or or kernel objects. Examples of an operating system include Windows or Linux . Hardware may include hardware resources e.g. ports processors memory and input output devices including for example a display speakers printers a keyboard and or a mouse. In operation a user may operate host system as if host system is a personal computer without a virtual machine. Host environment may be substantially unaffected by the presence of a virtual machine.

Systems and methods are described herein to efficiently manage and enforce separation and isolation of sections of program code in a software program. This enables safeguarding of the integrity of sensitive code particularly privileged code protecting such resources and promoting their proper functionality. Specifically this invention addresses key deficiencies in the current state of the art by illustrating new techniques for software API redirection. The invention may apply to any operating system provided API call including but not limited to blocking non blocking and call back registration calls. Software systems such as operating systems or virtual machine monitors may make effective use of the techniques described herein to enforce a new level of isolation between the objects that they manage.

Although the systems and methods described herein have universal applicability we shall frame the discussion by focusing on one key area where these systems and methods may be extremely useful virtual machine monitors VMMs . In this area the systems and methods described herein are used by a special form of VMM to provide a higher level of separation between operating environments.

The system and methods described in this invention impart a way for a PVM to mitigate access to privileged code in order to provide a comparable level of isolation to that of a hypervisor hardware based VMM.

One approach to solve this problem may make use of the PVM module s supervisory privilege. Since the PVM has peer privilege with the operating system kernel it is possible for the PVM to modify the kernel s in memory executable code causing all APIs to be redirected to the PVM module. This approach may be disfavored for several reasons The set of APIs required to intercept may be quite large. In line patching of running code may lead to instability. In line patching of running code may not be easily performed atomically which would be required for this approach to work properly.

According to embodiments of the invention all of these shortcomings of this possible approach may be avoided by use of the disclosed system and method for code isolation. Embodiments of the invention provide a generic method to force privileged kernel APIs to flow through the PVM thus ensuring that requests coming from these modules may be inspected and optionally transformed if required.

A shadow kernel is a copy of the OS kernel that nevertheless does not have the same integral position in the operation of the computing device as the actual OS kernel. Accordingly a shadow kernel may offer more robust execution of certain functions than may the OS kernel.

A shadow kernel is loaded into memory in the same fashion as a standard driver is. This is possible in most modern operating systems as the kernel binary file is structurally organized in a similar way to a driver binary file and has no external dependencies. The shadow kernel may serve as an intermediate jump destination that facilitates the privileged resource request s jump from the privileged driver to the PVM.

Shadow kernel may determine whether an instruction that is called by privileged resource request is a critical function. Shadow kernel may be used as a template for creating the jump table required to redirect certain kernel functions to the PVM while other non critical functions may be redirected to the original kernel.

Kernel function is redirected on the first jump of the trampoline to shadow kernel which then redirects a second jump for kernel function to a kernel function destination . The kernel function destination may be PVM not pictured for critical functions. The kernel function destination may be original kernel not pictured for non critical functions.

The flow of I O requests is downward on the page as illustrated by arrow . As above application may respond to a need created either by input or by its own requirements and may issue a non privileged resource request originating in non privileged code. Application may pass non privileged resource request to PVM . PVM may intercept non privileged request prior to its reaching kernel and may modify it to create a modified resource request . According to the present set of embodiments privileged and non privileged resource requests are treated the same. PVM may virtualize non privileged resource request by altering non privileged resource request to an alternate namespace or otherwise modifying it based on a table of rules thereby creating modified resource request .

According to embodiments of the invention the same PVM mediated interception technique may be applied to privileged code kernel mode . Resource access requests from certain specially loaded kernel mode drivers or other privileged code are routed through the PVM for processing. When a privileged driver is loaded into the system it will generate a privileged resource request that will be transmitted directly to PVM . As with non privileged resource request PVM may virtualize non privileged resource request by altering non privileged resource request to an alternate namespace or otherwise modifying it based on a table of rules thereby creating modified resource request .

PVM may pass modified resource request to operating system kernel . Once modified resource request is received by kernel kernel may fulfill the modified resource request deny it or take any number of other actions. Whatever action kernel takes may be transmitted to the appropriate device driver which then directs an associated device to perform any functions associated with the action. Device driver then may forward any resulting output to disk for storage or other final disposition.

The system resolves a privileged driver s import table against the shadow kernel resulting that any calls made by the privileged driver will pass through the PVM.

The application may respond to a need created either by input or by its own requirements. The application may issue a non privileged resource request . Application may pass a non privileged resource request to PVM . PVM is located on the privileged side of the boundary between non privileged user mode and privileged mode also known as kernel mode . Once non privileged resource request is received by PVM PVM may read PVM export table in response to instructions contained in non privileged resource request and any privileged resource requests that may have already been received from the shadow kernel . PVM export table may comprise PVM export table instructions A D e.g. open file close file delete file rename file and the like. Using PVM export table PVM intercepts non privileged request prior to its reaching kernel and modifies it to create a modified resource request . PVM may virtualize non privileged resource request by altering non privileged resource request to an alternate namespace or otherwise modifying it based on a table of rules thereby creating the modified resource request .

According to embodiments of the invention the same VM mediated interception technique may be applied to privileged code kernel mode . Privileged driver may comprise import table . According to embodiments of the invention the import table may describe the entry points of the privileged driver . Privileged driver generates privileged resource request . Previously privileged resource request and import table would typically have been dynamically transmitted directly to operating system kernel via an old linkage which is removed according to embodiments of the invention and replaced with new linkage . The privileged resource request and the import table pass through the new linkage to the shadow kernel .

Once the privileged resource request is received by shadow kernel using shadow kernel rules the shadow kernel may read shadow kernel export table in response to instructions contained in privileged resource request and the import table that helped generate it. Shadow kernel rules may be predetermined by a user. Alternatively or in addition shadow kernel rules may be created on the fly during real time operation of the invention.

Shadow kernel export table may comprise shadow kernel export table instructions A D e.g. open file close file delete file rename file and the like. Import table instructions A D export table instructions A D PVM export table instructions A D and shadow kernel export table instructions A D may all be different from each other. Shadow kernel may pass privileged resource request and shadow kernel export table to PVM .

The PVM can read PVM export table in response to instructions contained in privileged resource request and the shadow kernel export table as well as any prior privileged resource requests that may have already been received from shadow kernel . Using PVM export table PVM modifies privileged resource request to create a modified resource request .

The PVM may pass modified resource request and PVM export table to operating system kernel . Using OS rules OS kernel may generate export table in response to instructions contained in modified resource request and the PVM export table . OS rules may be predetermined by a user. Alternatively or in addition OS rules may be created on the fly during real time operation of the invention.

The kernel may fulfill the modified resource request deny it or take any number of other actions. Whatever action kernel takes may be transmitted to the appropriate device driver . The device driver then directs an associated device to perform any functions associated with the action. Device driver then forwards any resulting output to disk for storage or other final disposition.

In sum requests issued by the privileged driver will result in a new linkage enabling execution of code in the PVM.

In the Microsoft Windows operating system shadow kernel implementation may be accomplished through the following sequence of actions 

At this point the system has a second kernel loaded into memory but it has not yet been initialized. For the purposes of the embodiment illustrated in this is acceptable. However in an alternate embodiment the state of the system kernel may be shared with the shadow kernel by performing the additional steps 

By utilizing a second shadow kernel we can create an in place template based trampoline as illustrated in .

The privileged driver may comprise import table . Import table comprises import table instructions A D e.g. open file close file delete file and rename file.

As discussed above a trampoline may be implemented as a jump table and used to isolate privileged code. Jump tables comprise a sequence of instructions to jump to various other places in a computing system.

The privileged driver may direct the privileged resource request and the import table to jump through the new linkage to the shadow kernel .

Using shadow kernel rules shadow kernel may create a shadow kernel export table in response to instructions contained in privileged resource request and the import table as well as any previously received privileged resource requests .

The shadow kernel export table comprises shadow kernel export table instructions A I e.g. open file close file delete file rename file logoff user logon user query system time set system time reboot computer and the like.

The shadow kernel may determine whether an instruction in shadow kernel export table that is called by privileged resource request is a critical function ie. one that is also comprised in PVM export table . If the answer is yes then the shadow kernel may direct the privileged resource request and the shadow kernel export table to jump to PVM as disclosed in further detail in . If the answer is no then the shadow kernel may direct the privileged resource request to jump to the OS kernel which comprises the export table .

For example with reference to the shadow kernel export table depicted in upon the direction of privileged resource request to shadow kernel export table privileged resource request may call a shadow kernel export table instruction . If the called shadow kernel export table instruction is one of shadow kernel export table instructions A D e.g. open file close file delete file rename file and the like these shadow kernel export table instructions are also comprised in PVM export table as PVM export table instructions A D. Typically these instructions also comprised in PVM will be of a more critical nature. Accordingly in these cases the shadow kernel may redirect privileged resource request and a copy not shown of the shadow kernel export table to jump to PVM .

On the other hand if the shadow kernel export table instruction called by the privileged resource request in the shadow kernel export table is one of shadow kernel export table instructions E I e.g. logoff user logon user query system time set system time and reboot computer these instructions are not comprised in PVM export table . Typically these instructions will be non critical. Accordingly in these cases shadow kernel may redirect the privileged resource request and a copy not shown of the shadow kernel export table to jump directly to the OS kernel .

Once the critical privileged resource request and the copy of shadow kernel export table are received by PVM the PVM may create a PVM export table in response to instructions contained in privileged resource request and the copy of shadow kernel export table . The PVM may intercept the privileged resource request prior to its reaching the kernel and may modify it to create a modified resource request . The PVM may virtualize the privileged resource request by altering privileged resource request to an alternate namespace or otherwise modifying it based on a table of rules thereby creating modified resource request . PVM may redirect modified resource request and PVM export table to jump to operating system kernel .

Export table may comprise export table instructions A I e.g. open file close file delete file rename file logoff user logon user query system time set system time reboot computer and the like. In this example export table instructions A D e.g. open file close file delete file and rename file are critical instructions and export table instructions E I e.g. logoff user logon user query system time set system time and reboot computer are non critical instructions. Import table instructions A D shadow kernel export table instructions A I PVM export table instructions A D and export table instructions A I may all be different from each other.

Once OS kernel receives either 1 a non critical privileged resource request and shadow kernel export table or 2 a modified resource request and PVM export table the OS kernel may as above read export table in response to instructions contained in the resource request and the export table. Using the export table the kernel may fulfill privileged request deny it or take any number of other actions. Once the modified resource request is received by the kernel the kernel may fulfill the modified resource request deny it or take any number of other actions. Whatever action the kernel takes may be transmitted to the appropriate device driver which then may direct an associated device to perform any functions associated with the action. The device driver may then forward any resulting output to the disk for storage or other final disposition.

In sum requests issued by the privileged driver will result in a new linkage enabling execution of code in the PVM. Critical functions may be directed to the shadow kernel and non critical functions may be directed to the OS kernel.

By using the steps described above import table modification may be used to construct a symbol resolution hierarchy such as in . In this hierarchy it is easily demonstrable that there are no functions directly linked to the original system kernel or drivers unless those functions are expressly permitted to be linked. Using this approach it is possible to completely isolate a driver stack or hierarchy from the same or similar stack or hierarchy loaded on the host computer.

When privileged driver is loaded into host environment an isolated copy may be loaded into isolated environment according to embodiments of the invention. The privileged driver may comprise the import table .

The privileged driver may direct the privileged resource request and the import table to jump to the OS kernel . Once the OS kernel has received the privileged resource request and the import table using OS rules the OS kernel may fulfill the privileged resource request deny it or take any number of other actions.

The import table may comprise privileged driver instructions A D e.g. create delete pop and push and the like. The import table also may comprise import table OS instructions A D e.g. open file close file delete file and rename file. The import table thus facilitates translation between privileged driver instructions A D and import table OS instructions A D. For example import table may comprise one or more of a privileged driver instruction A create that translates to an import table OS instruction A open file a privileged driver instruction B delete that translates to an import table OS instruction B close file a privileged driver instruction C push that translates to an import table OS instruction C delete file and a privileged driver instruction D pop that translates to an import table OS instruction D rename file. 

Operating in host environment the privileged driver may create a copy A of itself which it may jump to a secure location in host environment . The privileged driver may then create a copy A of privileged resource request which may be provided to copy A along with import table . Once the privileged resource request copy A and the import table are received by the privileged driver copy A the copy A may read a privileged driver export table in response to instructions contained in privileged resource request copy A and import table . The privileged driver export table may in turn comprise isolated privileged export table instructions A D e.g. create delete push pop and the like. Such a destination would be particularly appropriate for a non critical function.

The isolated privileged driver may comprise isolated privileged import table . The isolated privileged import table may comprise isolated privileged driver instructions A D e.g. open file close file delete file rename file and the like. Isolated privileged import table also may comprise isolated privileged OS instructions A D e.g. create delete push pop and the like. Isolated privileged import table thus facilitates translation between isolated privileged driver instructions A D and isolated privileged OS instructions A D. For example isolated privileged import table may comprise one or more of an isolated privileged driver instruction A create that translates to an isolated privileged OS instruction A open file an isolated privileged driver instruction B delete that translates to an isolated privileged OS instruction B close file an isolated privileged driver instruction C push that translates to an isolated privileged OS instruction C delete file and an isolated privileged driver instruction D pop that translates to an isolated privileged OS instruction D rename file. 

Operating in isolated environment isolated privileged driver may create a copy B of privileged resource request and may further create a copy A of itself. Both copies may be jumped to a protected isolated location to which isolated privileged import table may be provided. Once privileged resource request copy B and privileged import table are received by isolated privileged driver copy A copy A may read an isolated privileged driver export table in response to instructions contained in privileged resource request copy B and privileged import table . Isolated privileged driver export table may in turn comprise isolated privileged export table instructions A D e.g. create delete push pop and the like. Such a destination would be particularly appropriate for a critical function.

The isolated privileged driver may create another privileged resource request copy C to jump along with isolated privileged import table through new linkage to shadow kernel . Once privileged resource request C and isolated privileged import table are received by shadow kernel using shadow kernel rules the shadow kernel may read shadow kernel export table in response to instructions contained in privileged resource request and the import table that helped generate it. Shadow kernel rules may be predetermined by a user. Alternatively or in addition shadow kernel rules may be created on the fly during real time operation of the invention.

The shadow kernel may direct the privileged resource request and the shadow kernel export table to jump to the PVM . Once the privileged resource request and the shadow kernel export table are received by the PVM the PVM may read a PVM export table in response to instructions contained in privileged resource request and shadow kernel export table . The PVM export table may comprise PVM export table instructions A D e.g. open file close file delete file rename file and the like. Import table instructions A D export table instructions A D shadow kernel export table instructions A D and PVM export table instructions A D may all be different from each other.

Using PVM export table PVM modifies privileged resource request to create a modified resource request . PVM may virtualize privileged resource request by altering privileged resource request to an alternate namespace or otherwise modifying it based on a table of rules thereby creating modified resource request .

PVM may pass modified resource request and PVM export table to operating system kernel . Once OS kernel has received modified resource request and PVM export table using OS rules OS kernel may generate export table in response to instructions contained in modified resource request and the PVM export table . OS rules may be predetermined by a user. Alternatively or in addition OS rules may be created on the fly during real time operation of the invention.

As previously described the kernel may fulfill the modified resource request deny it or take any number of other actions.

Embodiments of the invention thus permit the loading of multiple copies of a given driver or code module in a given session. According to embodiments of the invention a shadow kernel may accordingly be loaded in conjunction with a set of virtualized drivers. According to embodiments of the invention multiple sessions of the virtual environment may accordingly be simultaneously loaded each with its own shadow kernel and its own isolated set of drivers. The result is a robust versatile and efficient method for code isolation of privileged code in a virtual environment.

By using the shadow kernel approach described above trampoline code may be constructed. In the preferred embodiment a shadow kernel is used as a template for creating the jump table required to redirect certain kernel functions to the PVM while other non critical functions may be redirected to the original kernel. In the preferred embodiment this template based trampoline may be constructed using the following exemplary method 

During subsequent driver load a set of embodiments of the invention uses the shadow kernel s export table instead of the OS kernel s export table. Since the shadow kernel is a template it exhibits exactly the same memory layout as the OS kernel. Therefore the resolution of its import table is performed in a very straightforward way as illustrated in the following steps 

There is an additional resolution step performed when a driver has other dependencies e.g. other symbols in its import table besides those originating in the OSKernel . In the preferred embodiment drivers that are loaded may participate in the symbol resolution sequence shown in the following steps 

As with a real computer it is typically advisable to shut down and clean up a virtual session to avoid accumulating unwanted code and to avoid potential conflicts that could occur in the future. Shutdown of a virtual machine using code isolation according to embodiments of the invention presents certain challenges. When a real kernel and a shadow kernel are present there may be code that must be obtained from the real kernel rather than its shadow copy. The real kernel will be responsible for shutdown of sessions. Shutdown requires inducing drivers that depend on the real kernel to clean up and shut down.

In some cases resources may have already been already allocated that may be blocking a certain desired shutdown event from happening. It would be useful to terminate such blocking calls to facilitate a fuller shutdown. To prevent a permanent block a trampoline may be added to any blocking calls and another resource may be added to the blocking call that will interrupt it for various specified reasons one being shutdown.

Typically for example an OS such as Windows will not unload a module if a module has code executing into it. Once a thread of execution starts that is awaiting a certain event it cannot be interrupted unless the awaited event happens. For example a thread of execution may be waiting until the system time reaches 10 00 P.M. In such situations embodiments of the invention intercept the request to wait on that event and substitute a two prong request to wait on the original event and a shutdown event whichever occurs first. This allows the release of all the threads that are waiting. In turn unloading of the module in question is then possible.

To accomplish this shutdown process embodiments of the invention identify threads that were created by drivers that were loaded in the virtual environment so that they may be woken up and purged using the trampoline process. If a driver cannot be shut down or unloaded it is hidden under the rug that is it is cooled to remove any links with the rest of the system and any of its registrations are cancelled so it will not be called again.

External to the entire environment according to embodiments of the invention an orchestrator program simulates the order in which the operating system shuts down components calling all drivers that have registered for such a notification according to the shutdown sequence. This enables the notification according to embodiments of the invention of loaded drivers immediately before the system is going to shut down enabling them to flush their buffers or perform other needed pre shutdown functions.

The above description is illustrative and not restrictive. Many variations of the invention will become apparent to those of skill in the art upon review of this disclosure. The scope of the invention should therefore be determined not with reference to the above description but instead should be determined with reference to the appended claims along with their full scope of equivalents.

