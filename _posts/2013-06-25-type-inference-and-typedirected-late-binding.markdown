---

title: Type inference and type-directed late binding
abstract: Systems and methods that enhance and balance a late binding and an early binding in a programming language, via supplying an option component to opt-in (or opt-out) late binding, and wherein a late binding is triggered based on a static type for the variable (e.g., object or a type/string.) Additionally, the variable is enabled to have different static types at different regions (e.g., a program fragment) of the programming language.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08732732&OS=08732732&RS=08732732
owner: Microsoft Corporation
number: 08732732
owner_city: Redmond
owner_country: US
publication_date: 20130625
---
This application is a continuation of and claims priority to and the benefit of U.S. patent application Ser. No. 11 220 167 entitled TYPE INFERENCE AND TYPE DIRECTED LATE BINDING which was filed on Sep. 6 2005 and which is expressly incorporated herein in its entirety by this reference. U.S. patent application Ser. No. 11 220 167 is to issue as U.S. Pat. No. 8 473 971 on Jun. 25 2013. 

As programming approaches and foundations have evolved application programming interfaces APIs and programming schemas have been developed to standardize and unify programming methodologies that were previously multi variant and relatively incompatible. Modern programming therefore often involves employing APIs and schemas in conjunction with reusable libraries. Such Programming languages continue to evolve to facilitate specification by programmers as well as efficient execution.

Compilers and or interpreters bear the burden of translating high level logic into executable machine code. In general compilers and or interpreters are components that receive a program specified in a source programming language e.g. C C Visual Basic Java . . . and covert the logic provided thereby to machine language that is executable by a hardware device. However the conversion need not be done verbatim. In fact conventional compilers and or interpreters analyze the source code and generate very efficient code. For example programmers write code that sets forth a logical flow of operations that is intuitive and easy for humans to understand but is often inefficient for a computer to execute. Compilers and or interpreters can identify inefficiencies and improve program performance at the hardware level by eliminating unnecessary operations and or rearranging the execution of instructions while still achieving the intended results. In this manner programmers can create robust and efficient software.

Programming languages include static languages and dynamic languages. A static language requires most program structure such as the types of variables and function arguments to be determined at compile time. The compiler can detect errors and optimize performance at the cost of run time flexibility. On the other hand dynamic languages allow a user to make more run time changes to program structure such as passing arguments of different types to the same function and in some languages defining new types or classes. A dynamic environment can enable run time definition and linking.

In general type inference is a language mechanism that facilitates writing correctly typed applications for programmers. Consider the following 

as a Visual Basic statement that both declares the variable X and initializes its value to the string Hello . The compiler is aware that the type of the right hand side is String. Accordingly the compiler can infer that the type of the variable ought to be X. Currently the compiler sets the type of X to Object the most general type in the language and employs late binding to resolve later code like X.Length which is only legal for type String.

Late binding refers to an operation wherein the compiler inserts code to look up the method Length at run time. Such ability to late bound over member names is especially important in data intensive programs where the structure of the data is not known statically and for writing generic interpretative code. Nonetheless late binding while very flexible can sometimes introduce run time cost and reduce design time hints in the user interface e.g. when employing an assist provider such as Intellisense . Such can hinder flexibility of the programming languages.

Therefore there is a need to overcome the aforementioned exemplary deficiencies associated with conventional systems and devices.

The following presents a simplified summary in order to provide a basic understanding of some aspects of the claimed subject matter. This summary is not an extensive overview. It is not intended to identify key critical elements or to delineate the scope of the claimed subject matter. Its sole purpose is to present some concepts in a simplified form as a prelude to the more detailed description that is presented later.

The subject innovation provides for systems and methods that balance a late binding and an early binding in a programming language via supplying an option component to opt in or opt out late binding and wherein a late binding is triggered based on a static type for the variable e.g. object or a type string. A type inference component is implemented in the programming language and appropriate late bound helpers can be called e.g. XML late bound helper for values of XML type reflection late bound helper for objects and the like to type direct the late binding. As such late binding can be triggered based on type specified for the variable. The option component can include a smart tag or similar refactoring mechanism to enable a user to chose as string or as object and specify not only whether late binding is desired or not but also type of late binding for example. The late binding can be the default scenario for the programming language and the user can opt out. Alternatively the programming language can include non late binding as the default wherein the user can then opt in. Additionally in context of Visual Basic VB syntax the smart tag can expand when clicked upon to indicate the type explicitly wherein the variable declaration is already available.

According to a further aspect of the subject innovation a variable can have different static types at different regions e.g. a program fragment of a programming language. Moreover an analysis can be performed to identify the type of variable at different segments of a program or identify a set of possible types for the variable. Such can mitigate an early commitment of a type and if a type may be acceptable a check can be provided at later time. A feed back warning as opposed to an error can also be provided to the user regarding changed types for a variable. Such can provide flexibility to a user and a same variable name can be used in several occasions throughout a programming code for example.

In a related methodology a user can initially select whether late binding is desired or not. Subsequently the user can designate desired types of late binding. Moreover different types of late binding can be supplied depending upon the static type of the variable e.g. inferred from a usage thereof . Accordingly a balance between early binding and late binding can be created wherein the checking can be relaxed at run time and information available regarding static types employed at compile time.

To the accomplishment of the foregoing and related ends certain illustrative aspects of the claimed subject matter are described herein in connection with the following description and the annexed drawings. These aspects are indicative of various ways in which the subject matter may be practiced all of which are intended to be within the scope of the claimed subject matter. Other advantages and novel features may become apparent from the following detailed description when considered in conjunction with the drawings.

The various aspects of the subject innovation are now described with reference to the annexed drawings wherein like numerals refer to like or corresponding elements throughout. It should be understood however that the drawings and detailed description relating thereto are not intended to limit the claimed subject matter to the particular form disclosed. Rather the intention is to cover all modifications equivalents and alternatives falling within the spirit and scope of the claimed subject matter.

As used herein the terms component system and the like are intended to refer to a computer related entity either hardware a combination of hardware and software software or software in execution. For example a component may be but is not limited to being a process running on a processor a processor an object an executable a thread of execution a program and or a computer. By way of illustration both an application running on computer and the computer can be a component. One or more components may reside within a process and or thread of execution and a component may be localized on one computer and or distributed between two or more computers. Also the word exemplary is used herein to mean serving as an example instance or illustration. Any aspect or design described herein as exemplary is not necessarily to be construed as preferred or advantageous over other aspects or designs.

Furthermore the disclosed subject matter may be implemented as a system method apparatus or article of manufacture using standard programming and or engineering techniques to produce software firmware hardware or any combination thereof to control a computer or processor based device to implement aspects detailed herein. The term computer program as used herein is intended to encompass a computer program accessible from any computer readable device carrier or media. For example computer readable media can include but are not limited to magnetic storage devices e.g. hard disk floppy disk magnetic strips . . . optical disks e.g. compact disk CD digital versatile disk DVD . . . smart cards and flash memory devices e.g. card stick . Additionally it should be appreciated that a carrier wave can be employed to carry computer readable electronic data such as those used in transmitting and receiving electronic mail or in accessing a network such as the Internet or a local area network LAN . Of course those skilled in the art will recognize many modifications can be made to this configuration without departing from the scope or spirit of the claimed subject matter.

Turning initially to a programming environment is illustrated and a programming language e.g. Visual Basic enhanced via employing an option component . The option component enables a user to opt in to or opt out of late binding and wherein a late binding is triggered based on a static type designated for the variable e.g. a variable can be assigned a specific static type or object . A type inference component is implemented in the programming language wherein such type component can designate types of expressions and variables given a typically inevitable lack of complete type information. As such a balance between a late binding and an early binding in the programming language can be provided wherein appropriate late bound helpers can be called e.g. XML late bound helper for XML reflection late bound helper for objects and the like to type direct the late binding.

As illustrated the type inference component can supply a compiler not shown with missing type information based on contextual information of an input data stream. The option component can further include a smart tag or similar refactoring mechanism as described in detail infra which enables a user to chose between the precise inferred type or object and specify not only whether late binding is desired or not but also type of late binding for example. The late binding can be the default scenario for the programming language and the user can opt out. Alternatively the programming language can include non late binding as the default wherein the user can then opt in. Moreover in context of Visual Basic VB syntax the smart tag can expand when clicked upon to indicate the type explicitly wherein the variable declaration is already available for example.

Referring initially to a programming environment for type inference and type directed late binding as described in detail infra is illustrated. The system includes a source program that is developed designed or edited by an Integrated Development Environment IDE . The IDE can be associated with a more elaborate programming station such as a developer studio application or associated with a more basic tool such as a code text editor for example. In general the option component enables a user to opt in or opt out late binding and wherein a static type for a variable can be assigned a precise inferred type or object. A compiler processes the source program according to well known compilation techniques and in view of the type directed late binding to produce executable code for a computer at .

Typically the ability to late bound over member names is especially important in data intensive programs where the structure of the data is not known statically and to write generic interpretative code. In general binding refers to the way in which a programming code such as Visual Basic code accesses. There exist two types of binding with which Visual Basic employs namely early binding and late binding.

In general when the target of the expression can be deferred until run time such deferring processing is referred to as late binding. Late binding allows Object variables to be used in a typeless way where all resolution of members is based on the actual run time type of the value in the variable. If strict semantics are specified by the compilation environment late binding causes a compile time error. Non public members can be ignored when performing late binding including for the purposes of overload resolution. Moreover unlike the early bound case invoking or accessing a Shared member late bound will cause the invocation target to be evaluated at run time.

Likewise area represents the conventional approach for dynamic languages wherein all values are typed as object. In such dynamic languages the dynamic language does not possess knowledge regarding a static type of a variable.

The subject innovation in one exemplary aspect relates to the middle ground wherein opting in and opting out e.g. of regions and and different forms of late bindings are supplied depending on the static type of the value. Thus a variable can accept different static types at different regions of the program e.g. a variable with a changing static type and a type inferred based on use of the variable. As such different program fragment can contain different static types or sets for the same variable. For example at compile time a variable can accept a static type of integer or button as a set of possibilities. Such is in contrast to conventional static programming languages wherein the variable typically accepts exactly one static type everywhere in the programming language.

wherein the type of expression E is known to the compiler to be T. In accordance with one aspect of the subject innovation VB can display a smart tag underneath the X in the VS IDE for example. The smart tag can function as an interactive graphical element. Accordingly if the user clicks or hovers over the smart tag a drop down menu of options appears. The two options illustrated in this case will be T and Object .

In general if the user selects T then the user is opting in for static type inference meaning that in later code the type of variable X will be T. Specifically an assist provider Intellisense for the dot operator on X written X. will display the known list of fields and methods for type T. Alternatively selecting Object from the smart tag drop down menu means that the user is opting in for standard VB late binding over Object. As such the compiler and IDE will not know the specific list of fields and methods for X so the dot operator will not display an assist provider e.g. Intellisense hints and the compiler must generate code to select fields and methods at runtime via a meta object protocol implemented through reflection .

Typically the assist provider not shown supplies intelligent programmatic assistance e.g. Intellisense for a particular programming language e.g. Visual Basic C C Java J . . . . Such assist provider components therefore can be provided by specific language development entities e.g. software companies universities individuals . . . . The assist provider component can simplify coding for example aiding programmers in statement class and function completion by providing suggestions based on programmatic context. These suggestions can be provided via pop up windows or boxes drop down windows and the like. For example suggestions can be made for completing a partially specified word or statement based on its previous specification in the same of different compilation unit.

It is to be appreciated that late binding is typically not to be construed as the opposite of static typing. The type T statically known may require late binding over its domain. For example when the user types 

The static type of X can be XElement which offers a kind of late binding to the actual terms in the XML. Specifically X.book.title will be a legal code and in general will only be fully resolved at run time. Thus Intellisense may be capable of displaying hints when the user types X. if there is an XSD schema in scope but the binding to book and title is late that is completed only at run time. Such mix of statically known type XElement and dynamically known bindings X.book X.book.title can be referred to as Type Directed Late Binding.

Moreover when the user opts in for either static typing or late binding over Object then the IDE can rewrite the code using the IDE s pretty lister to denote the selected type. For example if the user opts in for T the IDE can replace 

Additionally if Option Strict is ON the user can in general be required to opt in before compilation can proceed. Alternatively If Option Strict is OFF then late binding to Object will be the default selected for every case where the user has not opted in.

Moreover in certain circumstances it is not necessary to declare every variable before employing it. For example if the first appearance of the variable X in a program is the assignment X 5 then the compiler can infer that the type of variable X is Integer. Similarly the IDE can display a smart tag with a drop down menu offering the options Integer and Object . The following code can be considered as an example 

For this example it is assumed that such code is the first appearance of the variable X in the program. The standard flow analysis in the compiler is aware that control can go either way in the branch so it can inform type inference that the type of X can be any of Integer String or Object. As a matter of convenience to the user the smart tag with these three options can appear under the first X in the branch. Moreover Pretty listing can insert explicit calls to built in type conversion functions consistently with the opted in type. The if the user chose String above then the pretty lister will rewrite the combination as 

The default type for undeclared variables can be Object and thus if the first use of the variable X is not in an inferable context then its type shall be inferred to be Object.

Referring now to fragments of a code wherein a variable can have different static types e.g. as set of types at different regions is illustrated. Such can provide flexibility for different regions without an early commitment to a particular type. If the type may be acceptable permission is then granted to employ the type and a later check verifies the accuracy. In contrast conventional static programming languages issue an error in such circumstances. As illustrated at the variable X assumes a static type of a string wherein Intellisense checking can also be supplied. Subsequently and at X can be an integer and local knowledge regarding the type of X is employed. A feed back to the user can be provided in form of a warning regarding such change. Thereafter and at X can assume a button. At and after the End If X can be an integer or button and not a string . The compiler can now track the type as it has knowledge that X is an integer or button and can assume either one. Alternatively X can be designated as on object instead of a more precise tracking. Such enables identifying regions of a program wherein the types of a variable or a precise prescription are known.

At the site of the assignment X 5 the IDE can display another smart tag permitting the user to opt in for a type shift. Under the scheme proposed above this code would be automatically rewritten as 

The compiler can accept as input a file having source code associated with processing of a sequence of elements. The source code may include various expressions and associated functions methods and or other programmatic constructs. The compiler can process source code in conjunction with one or more components for analyzing constructs and generating or injecting code.

A front end component reads and performs lexical analysis upon the source code. In essence the front end component reads and translates a sequence of characters e.g. alphanumeric in the source code into syntactic elements or tokens indicating constants identifiers operator symbols keywords and punctuation among other things.

The converter component parses the tokens into an intermediate representation. For instance the converter component can check syntax and group tokens into expressions or other syntactic structures which in turn coalesce into statement trees. Conceptually these trees form a parse tree . Furthermore and as appropriate the converter module can place entries into a symbol table that lists symbol names and type information used in the source code along with related characteristics.

A state can be employed to track the progress of the compiler in processing the received or retrieved source code and forming the parse tree . For example different state values indicate that the compiler is at the start of a class definition or functions has just declared a class member or has completed an expression. As the compiler progresses it continually updates the state . The compiler may partially or fully expose the state to an outside entity which can then provide input to the compiler .

Based upon constructs or other signals in the source code or if the opportunity is otherwise recognized the converter component or another component can inject code corresponding to facilitate efficient and proper execution. Rules coded into the converter component or other component indicates what must be done to implement the desired functionality and identify locations where the code is to be injected or where other operations are to be carried out. Injected code typically includes added statements metadata or other elements at one or more locations but this term can also include changing deleting or otherwise modifying existing source code. Injected code can be stored as one or more templates or in some other form. In addition it should be appreciated that symbol table manipulations and parse tree transformations can take place.

Based on the symbol table and the parse tree a back end component can translate the intermediate representation into output code. The back end component converts the intermediate representation into instructions executable in or by a target processor into memory allocations for variables and so forth. The output code can be executable by a real processor but output code that is executable by a virtual processor can also be provided.

Furthermore the front end component and the back end component can perform additional functions such as code optimization and can perform the described operations as a single phase or in multiple phases. Various other aspects of the components of compiler are conventional in nature and can be substituted with components performing equivalent functions. Additionally at various stages during processing of the source code an error checker component can check for errors such as errors in lexical structure syntax errors and even semantic errors. Upon detection error checker component can halt compilation and generate a message indicative of the error.

In order to provide a context for the various aspects of the disclosed subject matter as well as the following discussion are intended to provide a brief general description of a suitable environment in which the various aspects of the disclosed subject matter may be implemented. While the subject matter has been described above in the general context of computer executable instructions of a computer program that runs on a computer and or computers those skilled in the art will recognize that the innovation also may be implemented in combination with other program modules. Generally program modules include routines programs components data structures etc. that perform particular tasks and or implement particular abstract data types. Moreover those skilled in the art will appreciate that the innovative methods can be practiced with other computer system configurations including single processor or multiprocessor computer systems mini computing devices mainframe computers as well as personal computers hand held computing devices e.g. personal digital assistant PDA phone watch . . . microprocessor based or programmable consumer or industrial electronics and the like. The illustrated aspects may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. However some if not all aspects of the invention can be practiced on stand alone computers. In a distributed computing environment program modules may be located in both local and remote memory storage devices.

With reference to an exemplary environment for implementing various aspects of the subject innovation is described that includes a computer . The computer includes a processing unit a system memory and a system bus . The system bus couples system components including but not limited to the system memory to the processing unit . The processing unit can be any of various available processors. Dual microprocessors and other multiprocessor architectures also can be employed as the processing unit .

The system bus can be any of several types of bus structure s including the memory bus or memory controller a peripheral bus or external bus and or a local bus using any variety of available bus architectures including but not limited to 11 bit bus Industrial Standard Architecture ISA Micro Channel Architecture MSA Extended ISA EISA Intelligent Drive Electronics IDE VESA Local Bus VLB Peripheral Component Interconnect PCI Universal Serial Bus USB Advanced Graphics Port AGP Personal Computer Memory Card International Association bus PCMCIA and Small Computer Systems Interface SCSI .

The system memory includes volatile memory and nonvolatile memory . The basic input output system BIOS containing the basic routines to transfer information between elements within the computer such as during start up is stored in nonvolatile memory . By way of illustration and not limitation nonvolatile memory can include read only memory ROM programmable ROM PROM electrically programmable ROM EPROM electrically erasable ROM EEPROM or flash memory. Volatile memory includes random access memory RAM which acts as external cache memory. By way of illustration and not limitation RAM is available in many forms such as synchronous RAM SRAM dynamic RAM DRAM synchronous DRAM SDRAM double data rate SDRAM DDR SDRAM enhanced SDRAM ESDRAM Synchlink DRAM SLDRAM and direct Rambus RAM DRRAM .

Computer also includes removable non removable volatile non volatile computer storage media. illustrates for example a disk storage . Disk storage includes but is not limited to devices like a magnetic disk drive floppy disk drive tape drive Jaz drive Zip drive LS 100 drive flash memory card or memory stick. In addition disk storage can include storage media separately or in combination with other storage media including but not limited to an optical disk drive such as a compact disk ROM device CD ROM CD recordable drive CD R Drive CD rewritable drive CD RW Drive or a digital versatile disk ROM drive DVD ROM . To facilitate connection of the disk storage devices to the system bus a removable or non removable interface is typically used such as interface .

It is to be appreciated that describes software that acts as an intermediary between users and the basic computer resources described in suitable operating environment . Such software includes an operating system . Operating system which can be stored on disk storage acts to control and allocate resources of the computer system . System applications take advantage of the management of resources by operating system through program modules and program data stored either in system memory or on disk storage . It is to be appreciated that various components described herein can be implemented with various operating systems or combinations of operating systems.

A user enters commands or information into the computer through input device s . Input devices include but are not limited to a pointing device such as a mouse trackball stylus touch pad keyboard microphone joystick game pad satellite dish scanner TV tuner card digital camera digital video camera web camera and the like. These and other input devices connect to the processing unit through the system bus via interface port s . Interface port s include for example a serial port a parallel port a game port and a universal serial bus USB . Output device s use some of the same type of ports as input device s . Thus for example a USB port may be used to provide input to computer and to output information from computer to an output device . Output adapter is provided to illustrate that there are some output devices like monitors speakers and printers among other output devices that require special adapters. The output adapters include by way of illustration and not limitation video and sound cards that provide a means of connection between the output device and the system bus . It should be noted that other devices and or systems of devices provide both input and output capabilities such as remote computer s .

Computer can operate in a networked environment using logical connections to one or more remote computers such as remote computer s . The remote computer s can be a personal computer a server a router a network PC a workstation a microprocessor based appliance a peer device or other common network node and the like and typically includes many or all of the elements described relative to computer . For purposes of brevity only a memory storage device is illustrated with remote computer s . Remote computer s is logically connected to computer through a network interface and then physically connected via communication connection . Network interface encompasses communication networks such as local area networks LAN and wide area networks WAN . LAN technologies include Fiber Distributed Data Interface FDDI Copper Distributed Data Interface CDDI Ethernet IEEE 802.3 Token Ring IEEE 802.5 and the like. WAN technologies include but are not limited to point to point links circuit switching networks like Integrated Services Digital Networks ISDN and variations thereon packet switching networks and Digital Subscriber Lines DSL .

Communication connection s refers to the hardware software employed to connect the network interface to the bus . While communication connection is shown for illustrative clarity inside computer it can also be external to computer . The hardware software necessary for connection to the network interface includes for exemplary purposes only internal and external technologies such as modems including regular telephone grade modems cable modems and DSL modems ISDN adapters and Ethernet cards.

What has been described above includes various exemplary aspects. It is of course not possible to describe every conceivable combination of components or methodologies for purposes of describing these aspects but one of ordinary skill in the art may recognize that many further combinations and permutations are possible. Accordingly the aspects described herein are intended to embrace all such alterations modifications and variations that fall within the spirit and scope of the appended claims. Furthermore to the extent that the term includes is used in either the detailed description or the claims such term is intended to be inclusive in a manner similar to the term comprising as comprising is interpreted when employed as a transitional word in a claim.

