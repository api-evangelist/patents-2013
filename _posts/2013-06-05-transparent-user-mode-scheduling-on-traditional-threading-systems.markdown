---

title: Transparent user mode scheduling on traditional threading systems
abstract: Embodiments for performing cooperative user mode scheduling between user mode schedulable (UMS) threads and primary threads are disclosed. In accordance with one embodiment, an asynchronous procedure call (APC) is received on a kernel portion of a user mode schedulable (UMS) thread. The status of the UMS thread as it is being processed in a multi-processor environment is determined. Based on the determined status, the APC is processed on the UMS thread.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09229789&OS=09229789&RS=09229789
owner: Microsoft Technology Licensing, LLC
number: 09229789
owner_city: Redmond
owner_country: US
publication_date: 20130605
---
This application is a divisional of U.S. patent application Ser. No. 12 242 648 entitled Transparent User Mode Scheduling on Traditional Threading Systems filed on Sep. 30 2008 now U.S. Pat. No. 8 473 964 issued on Jun. 25 2013. This application is also related to U.S. patent application Ser. No. 12 242 566 filed on Sep. 30 2008 now U.S. Pat. No. 8 321 874 issued on Nov. 27 2012 entitled Intelligent Context Migration for User Mode Scheduling which is incorporated herein by reference.

User mode scheduling enables processes to switch user threads for better concurrency and control. User mode schedulable UMS threads are divided into distinct user and kernel portions. However the division of a UMS threads into a user portion and kernel portion may cause difficulties during thread execution.

This Summary is provided to introduce a selection of concepts in a simplified form that is further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used to limit the scope of the claimed subject matter.

Described herein are embodiments of various technologies for cooperative user mode scheduling for the proper execution of UMS threads. In one embodiment an asynchronous procedure call APC is received on a kernel portion of a user mode schedulable UMS thread. The status of the UMS thread as it is being processed in a multi processor environment is determined. Based on the determined status the APC is processed on the UMS thread. Other embodiments will become more apparent from the following detailed description when taken in conjunction with the accompanying drawings.

This disclosure is directed to embodiments of directed switches for the proper execution of user mode schedulable UMS threads. In a multi processor environment the UMS threads are program threads that may be executed by one or more central processor units CPUs in the context of an operating system process. The UMS threads are similar to processor threads currently in use on computing platforms in that each UMS thread includes a kernel portion and a user portion.

The execution of a typical process thread may involve the recurring processing of the kernel portion of the thread in kernel mode in conjunction with the recurring processing of the user portion in user mode and the automatic switching between the two modes. In contrast due to the unique architecture of the computing platform on which the UMS threads are executed the UMS threads do not generally alternate automatically between user and kernel modes. Instead the user portions of UMS threads are switched with the user portions of special threads which are referred to herein as primary threads. In turn the user portions of the primary threads may then be executed in user mode. However this substitution of a user portion of a primary thread for a user portion of a UMS thread may create a mismatch in identities. This identity mismatch between the user portion of the UMS thread and the primary thread kernel portion may occur once the primary thread executing on behalf of the user portion of the UMS thread returns to kernel mode. Accordingly a process referred to as a directed switch may be performed to remedy such mismatches and provide smooth transition between the user and kernel portions of the UMS thread.

In some instances the implementation of such directed switches may make it necessary to implement certain support mechanisms and processes. The embodiments described herein are directed to these support mechanisms and processes that work cooperatively to support directed switches. Accordingly various examples of these mechanisms and processes that support directed switches are described below with reference to .

Each of the threads in the exemplary multi processor environment comprises a kernel portion that resides in kernel mode and a user portion that resides in user mode . The kernel and user modes are standard ways of dividing the execution of threads in a computer system between operating system activities such as activities performed by an operating system OS kernel and application activities such as those performed by a user s program.

For example the UMS thread may include a kernel portion and a user portion . Likewise the primary thread may include a kernel portion and a user portion . Additionally the process thread may include a kernel portion and a user portion . In various embodiments kernel mode is implemented by the operating environment for a kernel of an operating system i.e. the OS kernel. Kernel mode is generally a privileged mode of operation with direct access to the hardware resources in the machine. Generally speaking the OS kernel is responsible for managing a computing system s resources i.e. hardware and software components . As a basic component of an operating system the OS kernel provides the lowest level abstraction layer for computing resources e.g. memory processors and I O devices that an application needs to control for the performance of various functions.

Moreover the kernel and user portions of each thread in the exemplary multi processor environment may also include additional memory structure. For example the kernel portion may include a kernel mode stack registers and a kernel structure that describes the kernel portion which is the kernel thread descriptor . Furthermore the user portion may include a user thread descriptor which is a block of memory belonging to the user portion . The user portion may further include registers and a user mode stack .

It will be appreciated that the UMS thread is distinguishable from a process thread such as the standard thread . In various embodiments a UMS thread may differ from a standard thread in that the scheduling assignments of CPUs to the UMS kernel portion and the UMS user portion may be independently managed by an operating system while the kernel and user portions of a standard thread generally are assigned in unison. Thus while switching between the kernel portion and the user portion of the standard thread usually occurs implicitly during thread execution on a central processing unit CPU the UMS thread may provide applications with the ability to control the switch between the various user portions of its threads in user mode during execution. This capability allows applications to achieve higher performance and scalability because it is not always necessary to also switch the kernel portions of threads. For example switching from a user portion to a kernel portion of a standard thread generally requires an entry into kernel mode saving the old kernel state accessing some kernel global data structures and locks restoring new states and exiting kernel mode. However because UMS threads provide applications with the ability to perform switches in user mode the switches into kernel modes as well as kernel data and or lock contentions may be avoided.

The UMS threads such as the UMS threads may be created from standard threads such as the standard thread by allowing the user portion and the kernel portion to be assigned to CPUs such as CPU and CPU independently. In embodiments where the multi processor environment is running on IA 64 Itanium CPU architecture for example the creation of a UMS thread may involve the use of a special pointer to the UMS states that are stored in user thread descriptor of the UMS thread. The special pointer may be stored in a register that is accessible by other threads.

Alternatively in embodiments where the multi processor environment is running on an x86 or x64 CPU architecture the creation of a UMS thread may involve the use of a segment selector that points to the user thread descriptor of the UMS thread. Accordingly the special pointer and or the selector of a UMS thread may enable other threads such as the primary threads to access the states of the UMS thread as stored in its corresponding user thread descriptor.

The primary threads such as primary thread and the may act as virtual processors for an application. In some embodiments the number of primary threads present in the multi processor environment may correlate with the number of CPUs present in the environment. For example the primary thread may execute on the CPU while the primary thread may execute on the CPU . However in other embodiments the number of primary threads present may be greater or fewer than the number of CPUs in the multi processor environment .

A primary thread may act as virtual processor for executing the user portions of a UMS thread. For example but not as a limitation an application running the user portion of primary thread on the CPU can switch execution to the user portion of the UMS thread. The application can subsequently switch to executing other user portions of the UMS threads by using its own scheduling policies without any intervention or support from the OS kernel to implement its own scheduling policies.

In various embodiments a primary thread may be constructed from a standard thread such as the standard thread with the addition of an extra state. Thus a primary thread may convert back and forth from a standard thread based on application requirements. For example an application can respond to resource expansion by constructing more primary threads and a decrease in resource pressure scenarios can result in de converting a primary thread back to a standard thread.

As shown in the exemplary UMS thread may include a kernel portion that resides in kernel mode and a user portion that resides in user mode . It will be appreciated that the execution of a UMS thread such as the UMS thread differs from the execution of a standard thread such as the standard thread . Standard thread processing is generally dependent on the automatic that is implicit switch between a kernel portion of a thread and a user portion of a thread. For example during the execution of the standard thread a CPU may process the kernel portion of the standard thread in kernel mode . Subsequently the CPU may change from kernel mode to user mode by automatically switching from the kernel portion of the standard thread to the user portion . The user portion of the standard thread is then further processed in user mode. Additionally when the execution is to be switched to the user portion of another standard thread the current user portion needs to switch to its kernel portion which then switches to the kernel portion of the next standard thread to run. The kernel portion of the next standard thread may also further switch to its user portion in the same manner.

However during the processing of a UMS thread the switch to the kernel portion of the UMS thread is generally not required to switch to the user portion of another thread. The prevention of automatic switching from a user portion to a kernel portion of a UMS thread during processing is a fundamental principle of the UMS computing architecture. This architecture may enable computer applications to have greater control over the concurrency and efficiency of threads in both single processor and multi processor environments.

Instead the UMS threads may use alternative implementations to perform tasks in user mode . A particular alternative implementation is illustrated in with respect to the UMS thread . As shown a CPU may in essence execute the user portion of the UMS thread with the assistance of the primary thread . For example the user portion of the primary thread may switch to the user portion of the UMS thread . The CPU may then execute the user portion of the UMS thread in lieu of the user portion of the primary thread .

In various embodiments the switch of the user portion to the user portion may be accomplished by saving the context state of the user portion and loading the context state of the user portion . In at least one such embodiment the saving and loading of context states of the user portion to the user portion includes switching the user thread descriptor of the UMS thread with a user thread descriptor of the primary thread using one of the pointer or the segment selector . Moreover the transfer may also include the switch of the context states from the registers including the register pointing to the user mode stack of the UMS thread to the corresponding registers and user mode stack of the primary thread . The switching of the user thread descriptors and the various register and stack states is shown in as context loading and context saving . Subsequently the user portion of the primary thread may be executed using the same CPU.

Following the execution of the user portion the user thread descriptors registers and user mode stacks of the user portion and the user portion respectively may be switched to enable execution of the user portion or the user portion of yet another thread. These switches may be repeated one or more times. In other embodiments the switching between the user portions of UMS threads may not need to use the user portion of the primary thread as an intermediary.

At some point in the execution of the user portion of UMS thread in user mode via the use of the user portion the UMS thread may need to enter kernel mode from user mode . In other words the user portion of the UMS thread may need to switch to the kernel portion . In various instances the need to enter kernel mode may arise due to the occurrence of a system call synchronous entry into kernel mode an exception asynchronous entry into kernel mode or an interrupt asynchronous entry into kernel mode . As used herein synchronous refers to a situation where entry into kernel mode is synchronized with the execution design of the user portion and thus only a certain portion of the information in the register state of a UMS thread needs to be saved and later re loaded while asynchronous refers to a situation where the execution of the user portion is interrupted essentially at a random point and thus all the information in the register state needs to be saved and later re loaded. It will be appreciated that while system calls and exceptions are thread specific interrupts are not specific to any thread.

For standard thread such as standard thread the switch from a user portion to a kernel portion may be accomplished implicitly when the standard thread may enters kernel mode from user mode . To provide isolation between application and operating system execution user mode and kernel mode provide special register state to reduce how much saving and loading is required when switching from the user portion of a standard thread to the kernel portion such as providing a separate register pointing to the kernel mode stack . These special facilities in the CPU architecture make some of the state save restore when switching between the user and kernel portions of the same standard thread implicit . For example upon entry of the standard thread into kernel mode register state may be automatically spilled to the implicit stack pointer and the new kernel stack pointer may be automatically loaded. Moreover during the switch of the kernel portion with the kernel portion of another standard thread not shown this special register state may be loaded in addition to a regular stack pointer to point to the kernel stack area of the new standard thread.

However the switch from the user portion of UMS thread to the kernel portion may need special steps that are not necessary for the implicit switch from the user portion to the kernel portion of a standard thread . As shown in the initial step of the switch from the user portion to the kernel portion of the UMS thread is an implicit switch between the user portion and the kernel portion of the primary thread . This is due to the fact that the user portion was previously executing as the user portion in user mode . Nevertheless this implicit switch does not produce the desired result because the user portion of the primary thread has been replaced by the user portion of the UMS thread . In other words as far as the OS kernel last knew the state of what was running in user mode on the processor it was the user portion of the primary thread . This is because a switch from user portion to the user portion in the UMS thread can occur without the awareness of the OS kernel. Thus when the user portion enters kernel mode the implicit switch will take it to the kernel portion of the primary thread . However since the user portion was really replaced by the user portion of the UMS thread the user portion will actually enter kernel mode .

Accordingly when the user portion of UMS thread not the user portion of the primary thread enters kernel mode the OS kernel that is expecting the user portion of primary thread may have the ability to detect the mismatch based on the identities of each user portion. In various embodiments the identity of each user portion of each thread which is part of the context information of each thread may be stored in the kernel thread descriptors. For example the identity of the UMS thread may be stored in its kernel thread descriptor while the identity of the primary thread may be stored in its kernel thread descriptor .

For correct operation of the system the OS kernel needs to handle this case where the implicit switch will run the kernel portion of the wrong thread. This is because the operating system attaches certain import information such as the security context to the kernel thread descriptor. Since this state is only ever consumed in kernel mode the UMS thread needs to run with the correct context once it enters kernel mode . Therefore in the example of the UMS thread the OS kernel may switch from the kernel portion of the primary thread to the kernel portion once the UMS thread enters kernel mode . This cross thread switching process is referred to as a directed switch. Thus directed switches may enable UMS threads to be executed transparently in an operating system that is in the same way as standard threads.

In various embodiments the directed switch may be accomplished by exchanging context information of the kernel portion primary thread with the context information of the kernel portion UMS thread . This process is shown as context migration . As used throughout context information refers to the state of a thread which may include the registers that the thread may be using as well as other operating system and hardware specific data necessary for the execution of the thread. In this way once the context migration is completed the kernel portion may be executed by a CPU in kernel mode .

Subsequently the kernel portion of the UMS thread may cause the context information associated with user portion of the UMS thread to be queued to a UMS completion list . The UMS completion list may be a UMS data structure on which the OS kernel queues context information for user portions of the UMS threads that are ready for execution in user mode . After the queuing of the user portion the kernel portion of the UMS thread may place itself in a parked state i.e. a type of ready waiting state .

Moreover when freed by the UMS thread following the kernel mode context migration the primary thread may switch back to its user portion in user mode . Once back in user mode the user portion primary may switch to the user portion of another UMS thread for execution.

In various embodiments a primary thread may be created from a standard thread which may include NT threads. Moreover the user thread descriptor of each primary thread is dynamically allocated by the OS kernel during the creation of the original standard thread . Thus the user thread descriptor of a primary thread may reside in any part of a User Virtual Address VA space. As shown in the User VA space may include addresses above 4 GB 2 32 such as an upper 4 gigabyte GB portion shown as well as a lower 4 GB portion .

Thus in one example the user thread descriptor of a primary thread may reside in an upper 4 gigabyte GB portion of the User VA space . Further the user thread descriptor may include a self pointer that points to the beginning of the user thread descriptor . For example but not as a limitation if the user thread descriptor begins at hexadecimal memory address B00000100 the self pointer may point to the memory address B00000100 . Moreover the user thread descriptor as located in the User VA space may map to the user thread descriptor pages located in the physical memory . The self pointer may be used by various processes to access or refer to the user thread descriptor via its flat linear address.

In various computing architectures the user thread descriptor may be accessed such as for the purpose of UMS thread switching via different structures. For example but not as a limitation Intel Architecture 32 bit IA 32 and AMD64 Intel EM64T architectures may access the user thread descriptor via a data segment . The Intel Architecture 64 bit IA 64 on the other hand may access the user thread descriptor via a general purpose register not shown .

While the IA 32 and the IA 64 architectures need no special accommodations to access the user thread descriptor that is stored in the User VA the AMD 64 Intel EM64T architectures may pose special constraints. Specifically due to historical limitations the loading of the data segment from user mode is constrained to 32 bits rather than the 64 bits that are loadable from kernel mode . The 32 bits of the data segment correspond to the lower 4 GB portion of the User VA space . As a result when a primary thread includes the user thread descriptor that is located in the upper 4 GB portion the user thread descriptor is inaccessible by the data segment .

Accordingly in such a scenario a paging unit may be used to generate an image of the user thread descriptor in the lower 4 GB portion . In other words a second mapping to the user thread descriptor pages referred to in as secondary user thread descriptor may be created in the lower 4 GB portion . Moreover it will be appreciated that while a self pointer which is a mirror image of the self pointer may reside in the secondary user thread descriptor it nevertheless points to the beginning of the user thread descriptor . For example but not as a limitation even if the secondary user thread descriptor begins at memory address 20 in the example the self pointer still points to the memory address B00000100 . As a result regardless of whether the data segment is loaded from kernel mode or user mode user thread descriptor access operations will always lead to the same actual user thread descriptor pages in the physical memory .

In various embodiments the secondary user thread descriptor may be removed from the User VA space when it has been established that the address of the secondary user thread descriptor is not being used and no further switches of the primary thread that corresponds to the secondary user thread descriptor will occur.

As described above during the switching of the user portion of the primary thread with the user portion of the UMS thread the user thread descriptor and registers of each thread may be switched that is swapped. Nevertheless the switch of certain privilege hardware states that are not stored in the user thread descriptor and the registers of the UMS thread is generally not allowed in user mode . For example the loading of the hardware debug registers of the UMS thread which may include privileged hardware states into the primary thread is not permitted in user mode .

As shown in when debug registers are enabled for the UMS thread the updated register states of the UMS thread are captured and stored in a context holder of the user portion . Thus when the primary thread switches to the UMS thread in user mode the primary thread may detect that the debug values are stored in the context holder of the user portion . In various embodiments the context holders may include the user mode stacks as described in

Subsequently the primary thread may invoke a kernel call to enter kernel mode . Once in kernel mode the primary thread may change its own thread state to reflect the kernel states of the UMS thread . In various embodiments the primary thread may accomplish the thread state change by exchanging its context information with the context information of the UMS thread via a context migration . Following the thread state change the primary thread may load the hardware debug registers into its kernel portion .

An APC can perform various actions including collecting and or changing the context of thread. Moreover since APCs are asynchronous they may occur at any time during the execution of UMS thread via a primary thread. In various embodiments the APCs are generally delivered to the kernel portions of threads in kernel mode . However the APCs may impact the execution of threads in user mode . For example but not as limitation the APCs may be used to obtain the context of the user portions of threads to suspend the execution of the user portions of threads and to terminate the execution of the user portion of threads. It will be appreciated that while the occurrence of the APC is illustrated using the UMS thread and the primary thread the same principles hold for other UMS threads and primary threads.

As shown in an APC may be fired into kernel mode when the kernel portion of the UMS thread is being executed in kernel mode . Accordingly the APC may run on the kernel portion . For example the APC may retrieve the context information from the kernel portion . In another example the APC may modify the context information in the kernel portion .

As shown the kernel portion of the UMS thread is not being executed in kernel mode when the APC is delivered to the UMS thread in kernel mode. Upon receiving the APC the kernel portion may first cause a kernel lock to be placed on the user portion . In various embodiments the kernel lock may be the performed using the lock bit further described below in . The kernel lock may prevent the states of the user portion from being modified by another mechanism such as by a user mode scheduler. In various embodiments the kernel lock may refer to a soft lock that does not prevent the user states of the user portion from being accessed by a non cooperative code.

Second the kernel portion of the UMS thread may peek at the user portion of the thread to determine whether the user portion is currently being executed. In at least one embodiment the UMS thread may look at a specific context field of the user portion to determine whether it is already being executed. If the kernel portion determines that the user portion is idle and not being executed the kernel portion may enable the APC to access the user portion . For example the APC may retrieve the context information from the user portion . In another example the APC may modify the context information in the user portion .

As shown the kernel portion of the UMS thread is not being executed in kernel mode when the APC is delivered to the UMS thread in kernel mode . Upon receiving the APC the kernel portion may first cause a kernel lock to be placed on the user portion . In various embodiments the kernel lock may be the performed using the lock bit further described below in .

Second the kernel portion of the UMS thread may peek at the user portion of the thread to determine whether the user portion is currently being executed. In at least one embodiment the UMS thread may look at a specific context field of the user portion to determine whether it has been locked for execution such as execution by a primary thread. As further described below when the user portion is locked for execution by a primary thread the corresponding lock may include a client identifier CID that identifies the particular primary thread. For example the CID may identify the particular primary thread as the primary thread .

Thus once the kernel portion determines that the user portion is currently locked for execution by the primary thread e.g. switched with the user portion the kernel portion may fire a disassociate APC to the primary thread as identified by the CID .

In various embodiments assuming that the user portion of the primary thread is being executed in user mode the disassociate APC may cause the primary thread to abandon its execution in user mode and return to kernel mode . Moreover once the primary thread is in kernel mode the primary thread may return the context information from its kernel portion to the user portion of the UMS thread . Having returned the context information the primary thread may return to user mode . In other words the primary thread may switch to its user portion which may eventually pick up another UMS thread user portion for execution. Further the kernel portion may enable the APC to access the user portion . For example the APC may retrieve the context information from the user portion . In another example the APC may modify the context information in the user portion .

As shown the kernel portion of the UMS thread is not being executed in kernel mode when the APC is delivered to the UMS thread in kernel mode. Upon receiving the APC the kernel portion may first cause a kernel lock to be placed on the user portion . In various embodiments the kernel lock may be the performed using the lock bit further described below in . Second the kernel portion of the UMS thread may peek at the user portion of the thread to determine whether the user portion is currently being executed. In at least one embodiment the UMS thread may look at a specific context field of the user portion to determine whether it has been locked for execution such as execution by a primary thread. As further described below when the user portion is locked for execution by a primary thread the corresponding lock may include a client identifier CID that identifies the particular primary thread. For example the CID may identify the particular primary thread as the primary thread .

Thus once the kernel portion determines that the user portion is currently locked for execution by the primary thread e.g. switched with the user portion the kernel portion may fire a disassociate APC to the primary thread as identified by the CID .

In various embodiments assuming that the kernel portion of the primary thread is running in kernel mode the kernel portion may be in the process of context migration when the disassociate APC is fired. As described above context migration may include the transfer of context information from the kernel portion to the kernel portion of the UMS thread . In various instances this may create a blocking condition as the kernel portion may be waiting for the disassociate APC to be implemented by the kernel portion . In turn the kernel portion may be unable to disassociate as it is already in the process of transferring state i.e. the most recent accurate UMS thread state is actually in the kernel portion not in the user thread descriptor of user portion .

In order to alleviate this blocking condition the primary thread may send a defer message to the kernel portion of the UMS thread in response to the disassociate APC . The defer message may inform the UMS thread that the primary thread is attempting to switch to the UMS thread . In response to the defer message a routine that is created for and enables the APC to pull the context information into kernel portion may be temporarily rendered inactive. In the place of routine the disassociate APC may create a function in the kernel portion that waits for an indicator from the primary thread . The indicator may be configured to show that the context information has become ready to transfer from the kernel portion to the kernel portion . Thus when the kernel portion signals the UMS thread with the indicator the original APC may pull the context information from the user portion into a staging area that is in the kernel portion . This staging area enables the primary thread to be informed that its part in the directed switch operation is completed even before running the actual APC . Once the original APC completes the pull the routine may pull the context information from the staging area and replace the original context information of the kernel portion such as context information with the context information from kernel portion . It will be appreciated that the staging area is necessary as the APC may result in a suspension of the UMS thread . Thus the primary thread should be released prior to this suspension thereby necessitating the staging area as a safe temporary storage area for the context information in the event of a suspension.

Further since the appropriate context information is in the kernel portion the kernel portion may enable the APC to run on the kernel portion . For example the APC may retrieve the context information from the kernel portion . In another example the APC may modify the context information in the kernel portion .

As shown the kernel portion of the UMS thread is not being executed in kernel mode when the APC is delivered to the UMS thread in kernel mode. Upon receiving the APC the kernel portion may first cause a kernel lock to be placed on the user portion . In various embodiments the kernel lock may be the performed using the lock bit further described below in . Second the kernel portion of the UMS thread may peek at the user portion of the thread to determine whether the user portion is currently being executed. In at least one embodiment the UMS thread may look at a specific context field of the user portion to determine whether it has been locked for execution such as execution by a primary thread. As further described below when the user portion is locked for execution by a primary thread the corresponding lock may include a client identifier CID that identifies the particular primary thread. For example the CID may identify the particular primary thread as the primary thread . Thus once the kernel portion determines that the user portion is currently locked for execution by the primary thread e.g. switched with the user portion the kernel portion may fire a disassociate APC to the primary thread as identified by the CID .

As further shown a switch between the primary thread user portion and the UMS thread user portion may be in the middle of being performed when the disassociate APC is fired. Accordingly the primary thread may be in the process of collecting context information from the user portion . For example this collection is depicted in as context loading . Thus during the occurrence of the disassociated APC it is possibly that a portion of the context information belonging to the UMS thread is still in the memory e.g. registers associated with the user portion while the remainder of this context information has been transferred to the processor executing the user portion such as CPU . This progression of context loading may be detected by the OS kernel as the disassociate APC is delivered to the UMS thread in kernel mode .

In response to the detection that a switching function was in progress when APC or a page fault a type of asynchronous event occurs the OS kernel may complete the context loading on behalf of the user portion . In at least one embodiment the OS kernel may finish the collection of context information regarding the user portion into the memory associated with the primary thread . Once the context loading is complete the kernel portion may enable the APC to access the user portion . For example the APC may retrieve the context information from the user portion . In another example the APC may modify the context information in the user portion .

As shown the kernel portion of the UMS thread is not being executed in kernel mode when the APC is delivered to the UMS thread in kernel mode. Upon receiving the APC the kernel portion may first cause a kernel lock to be placed on the user portion . In various embodiments the kernel lock may be the performed using the lock bit further described below in . Second the kernel portion of the UMS thread may peek at the user portion of the thread to determine whether the user portion is currently being executed. In at least one embodiment the UMS thread may look at a specific context field of the user portion to determine whether it has been locked for execution such as execution by a primary thread. As further described below when the user portion is locked for execution by a primary thread the corresponding lock may include a client identifier CID that identifies the particular primary thread. For example the CID may identify the particular primary thread as the primary thread . Thus once the kernel portion determines that the user portion is currently locked for execution by the primary thread e.g. switched with the user portion the kernel portion may fire a disassociate APC to the primary thread as identified by the CID .

As further shown the disassociate APC may have occurred when the primary thread is yielding to the UMS thread after it is executed in user mode Accordingly the primary thread may be in the process of depositing context information regarding the user portion during the occurrence of the disassociate APC . For example this deposit is depicted in as context saving . Thus during the occurrence of the disassociate APC it is possibly that a portion of the most recently processed context information is already in the memory image associated with the user portion while the remainder of this context information is still present in the processor executing the user portion such as CPU . As used herein the most recently processed context information refers to context information produced by the most recent execution of the primary thread on a CPU. This progression of context saving may be detected by the kernel as the disassociate APC is delivered to the UMS thread in kernel mode .

In response to the detection that a yield was in progress when the disassociate APC or a page fault a type of asynchronous event occurs the OS kernel may complete the current context saving so that the user portion contains the states immediately prior to the occurrence of the context saving . Once the states of the user portion are saved the kernel portion may enable the APC to access the user portion . For example the APC may retrieve the context information from the user portion . In another example the APC may modify the context information in the user portion . However in various embodiments while the context saving may be completed an instruction pointer e.g. CPU register that indicates the progress of the yield process may be reset to a starting point. Accordingly the instruction pointer may enforce the yield process to restart from the beginning Thus when the APC is completed the context saving from the primary thread to the UMS thread may be re run.

As shown each UMS thread such as the UMS thread may include a UMS lock . In turn the UMS lock may include a CID field and a lock bit . The CID field field is part of a system data structure that identifies each process and thread in the process with a unique identifier. The lock bit may have a default value when the UMS thread is not being executed by the OS kernel in kernel mode . For example but not as a limitation the default value of the lock bit may be zero . Moreover the CID field may also have a default value when a primary thread has not switched to the UMS thread . For example but not as a limitation the default value of the CID field may also be zero. 

Thus when the primary thread attempts to switch to the UMS thread it may first check to ensure that the CID field and the lock bit both have their respective default values. In other words the primary thread may verify that the UMS thread is not currently being executed and no other primary thread has previously switched to the UMS thread . If the primary thread is able to verify that both default values are present the primary thread may replace the default value of the CID field with its own identification .

Subsequently the primary thread may perform a switch with the UMS thread . As part of the switch process the primary thread may replace its user thread descriptor with the user thread descriptor of the UMS thread as described above. Once the primary thread has replaced its user thread descriptor the scheduler may once again test the lock bit to ensure that it still holds the default value meaning that it has not been locked by the OS kernel. The reason for the second lock bit test is that the occurrence of an APC following the first lock bit test and during the switch of the primary thread may cause the UMS thread to be executed by the OS kernel. If the second lock bit test indicates that the lock bit still retains its default value the primary thread may further replace its own registers with the registers of the UMS thread . Once the registers are in place the primary may be executed in user mode in place of the UMS thread . Thus any interruption of the primary thread beyond this point follows the scenario in since the primary thread is now fully associated with the UMS thread . On the other hand if the lock bit is set a switch to kernel mode is likely to follow and the primary thread needs to select and switch to another UMS thread.

The selected components stored in memory may in the form of program instructions. The program instructions or modules may include routines programs objects components and data structures that perform particular tasks or implement particular abstract data types. The modules may be implemented as software or computer executable instructions that are executed by one or more processors . As shown in the selected components may include a user mode scheduler a kernel scheduler and a kernel queue . However it will be appreciated that the environment may also include other modules that perform other functions related to thread execution.

The user mode scheduler may be configured to create primary threads and manage UMS threads. The user mode scheduler may be further responsible for exposing UMS thread mechanisms to higher level components in applications and may also control and implement scheduling policies specific to an application and its instances that uses the threads. The user mode scheduler may include a primary thread API module a UMS thread API module a UMS completion list API module and an accessory API module . The primary thread API module may be configured to enable an application to start a new instance of the user mode scheduler . The UMS thread API module may be configured to create a new UMS thread such as the UMS thread from a standard thread such as the standard thread . In one at least one embodiments the thread API module may convert a standard thread into a new UMS thread by adding a special state or convert a standard thread into a primary thread and vice versa.

Moreover the thread API module may enable a primary thread to switch to a UMS thread. Additionally the thread API module may further enable a first UMS thread to yield to a second UMS thread by providing a hint to the primary thread such as the primary thread which indicates the UMS thread to execute as a result of the yield. Finally the thread API module may be implemented to convert a UMS thread or a primary thread back into a standard thread with the removal of the special state.

The UMS completion list API module may be configured to create and manage a UMS completion list such as the UMS completion list . In other embodiments the UMS completion list API module may withdrawn from the UMS completion list all queued UMS thread user portions. In additional embodiments the UMS completion list API module may be implemented to delete a UMS completion list.

The accessory API module may be configured to fetch various UMS thread states. For example the accessory API module may fetch a UMS thread user portion from a UMS completion list so that it may be switched with a user portion of a primary thread for execution on a CPU. In various embodiments the accessory API module may obtain the latest queued UMS thread from the UMS completion list as well as obtain the next queued UMS thread. In other embodiments the accessory API module may be further configured to provide each of the UMS threads with thread information as well as retrieve thread information from each of the UMS threads.

The kernel scheduler may be configured to schedule the various threads for processing on a CPU. In various embodiments the scheduling policy of the kernel scheduler may include preemptive priority based and round robin processing. For example the UMS threads e.g. the UMS thread the primary threads e.g. the primary thread as well as the standard threads e.g. standard process thread may use the services of the kernel scheduler to get appropriately scheduled and pre empted.

Finally the kernel queue is a mechanism that may be configured to monitor system operations and registers events and notify appropriate components of changes. The kernel queue may also used by the kernel to control the concurrency level of threads associated with a particular queue. In various embodiments the kernel queues may wake up the primary thread such as the primary thread when the user portion of the UMS thread enters into a parked state or otherwise blocks in kernel mode e.g. due to a synchronous wait in a system call or a page fault . This may be accomplished by ensuring that the kernel queues used with the UMS mechanism only allow a concurrency level of a single thread.

At decision block the OS kernel may determine whether the APC is delivered to a UMS thread such as the UMS thread . If the OS kernel determines that the APC is not delivered to a UMS thread no at decision block the process may proceed to block . In various embodiments the APC may have been delivered to a standard thread such as standard thread . At block the APC may be processed as part of standard thread processing such as the processing of a NT thread. However if the OS kernel determines that the APC is delivered to a UMS thread yes at decision block the process may proceed to decision block . In various embodiments the APC may be delivered to the kernel portion of a UMS thread .

At decision block the OS kernel may determine whether the kernel portion of the UMS thread is in a parked state. In various embodiments as described above once the execution of a user portion of the UMS thread is completed in kernel mode the kernel portion of the UMS thread may place itself in a parked state i.e. a type of ready waiting state that enables the kernel portion to wait for the occurrence of a directed switch . Thus conversely the fact the kernel portion is not in a parked state indicates that the kernel portion is still being executed.

If the OS kernel determines that the kernel portion is not in a parked state no at decision block the process may proceed to block . At block the APC may be processed as part of standard thread processing such as the processing of a NT thread. However if the OS kernel determines that the kernel portion is in a parked stated yes at decision block the process may proceed to decision block .

At decision block the OS kernel may determine whether the user portion of the UMS thread is running in the primary thread . For example the user portion may be switched with the user portion of the primary thread for execution in user mode . If the OS kernel determines that the user portion is not running in primary thread no at decision block the process may proceed to decision block .

At decision block the OS kernel may determine whether the UMS thread has acquired a context lock. In various embodiments the context lock may be in the form of a placement of a non default value into the lock bit of the UMS lock . If the OS kernel determines that the UMS thread has acquired a context lock yes at decision block which indicates that the UMS thread is actually being executed in kernel mode the process may proceed to block .

At block the APC may be processed as part of standard thread processing such as the processing of a NT thread. However if the OS kernel determines that the UMS thread has not acquired a context lock no at decision block the process may proceed to block .

At block the UMS thread may acquired a context lock to indicate that it is being executed in kernel mode since the UMS thread is not being executed by a primary thread . Subsequently the process may proceed to block . At block the APC may be processed as part of standard thread processing such as the processing of a NT thread.

Returning to decision block if the OS kernel determines that the user portion is running in primary thread yes at decision block the process may proceed to decision block .

At decision block the OS kernel may determine whether the identification of the use portion has been placed into the CID field of the primary thread as part of the current process. If the OS kernel determines that the identification has not been placed into the CID field as part of the current process no at the decision block the process may proceed to decision block . However if the OS kernel determines that the identification has been placed into the CID field of the primary thread as part of the current process yes at decision block the process may proceed to decision block .

Returning to decision block the OS kernel may determine whether the current process is being deleted from the system. If the OS kernel determines that the current process is being deleted yes at decision block the process may proceed to block .

At block the OS kernel may determine that the primary thread has already exited user mode prior to the user thread descriptor loading to the primary thread is completed as part of a UMS switch. Subsequently the process may proceed to block .

At block the APC may be processed as part of standard thread processing such as the processing of a NT thread. Returning to decision block if the OS kernel determines that the current process is not a deletion process no at decision block the process may proceed to decision block .

At decision block a user mode scheduler such as the user mode scheduler may determine whether the primary thread is in user mode . If the user mode scheduler determines that the primary thread is in user mode yes at decision block the process may proceed to decision block in

At decision block the user mode scheduler may determine whether the user portion is running on the primary thread . In other words the user mode scheduler may determine whether the portion of the primary thread may have switched with the user portion for execution in user mode . If the user mode scheduler determines that the user portion is not running on the primary thread no at decision block the process may proceed to block . At block the user mode scheduler may return the primary thread to user mode .

However if the user mode scheduler determines that the user portion is running on the primary thread yes at decision block the process may proceed to block .

At block the register context associated with the user portion may be captured. In various embodiments the captured registered context may include both asynchronous and synchronous contexts. At block the user portion may be queued to a completion list which is described above. At block the user thread descriptor of the primary thread and the control procedure call PC may be reset to system defined user entry points. In various embodiments the primary thread may return the context information from its kernel portion to the user portion of the UMS thread . At block the OS kernel may signal the UMS thread to continue APC processing. At this point the process may also continue to block where the user mode scheduler may return the primary thread to user mode .

Returning to decision block if the user mode scheduler determines that the primary thread is not in user mode no at decision block the process may proceed to decision block .

At decision block the OS kernel may determine whether the primary thread is the middle of a directed switch with the UMS thread . In other words the kernel portion of the primary thread is being switched with the user portion of the UMS thread . If the OS kernel determines that a directed switch is not taking place no at decision block the process may proceed to block where the process will progress as previously described.

However if the OS kernel determines that a directed switch is taking place yes at decision block the process may proceed to block . At block the UMS thread may be synchronized with the primary thread . At decision block the OS kernel may determine whether the joining of the primary thread to the UMS thread is completed. In other words the OS kernel may determine whether the wait for the primary thread to complete the transfer of states from the UMS thread is finished. If the OS kernel determines that the joining of the primary thread is completed yes at decision block the process may further proceed to block . However if the OS kernel determines that the joining of the primary thread is not complete no at decision block the process may loop back to block where additional synchronization may be performed. This looping may be performed until synchronization is complete.

At block the context information from the primary thread may be migrated to a backup store of the UMS thread . In various embodiments as described in the context information from the user portion may be pulled into staging area of the kernel portion . At block the UMS thread may be unparked that is waken up from a waiting state. Once awoken the context information of the UMS thread may be replaced with the context information from the backup store. At block the OS kernel may continue APC servicing. In some embodiments the APC may be executed on the UMS thread with the replaced context information.

At block the user mode scheduler may acquire the client identifier CID such as CID field of a UMS thread . In various embodiments the CID field may be part of a UMS lock that further includes a lock bit .

At decision block it may be determined whether the context lock of the UMS thread is successfully acquired by the user mode scheduler. In other words it is determined whether the user mode scheduler is able to acquire the lock bit of the UMS lock . If it is determined that the user mode scheduler is not able to acquire the context lock no at decision block the process may proceed to block . At block the user mode scheduler may report an unsuccessful UMS execution to a caller. However if it is determined that the user mode scheduler is able to acquire the context lock yes at decision block the process may proceed to decision block .

At decision block the user mode scheduler may determine whether the context is terminated or suspended. If the user mode scheduler determines that the context is terminated or suspended yes at decision block the process may proceed to block . At block the user mode scheduler may report an unsuccessful UMS execution to the caller. However if the user mode scheduler determines that the context is not terminated or suspended no at decision block the process may proceed to block .

At block the primary thread may load to the user thread descriptor from the UMS thread . In various embodiments the primary thread may load the user thread descriptor of the UMS thread using the pointers described in .

At decision block the user mode scheduler may determine whether the UMS thread is kernel locked. In various embodiments the UMS thread is kernel locked if the lock bit indicates that the UMS thread is not of interest to the kernel . For example in at least one embodiment the lock bit may have a default value if the UMS thread is not locked by the OS kernel. If the user mode scheduler determines that the UMS thread is kernel locked yes at decision block the process may proceed to block . At block the primary thread may release the CID field of the UMS thread . In other words the identification of the primary thread may be removed from the CID field of the UMS thread . Subsequently the process may proceed to block . At block the user mode scheduler may report an unsuccessful UMS execution to the OS kernel.

However if the user mode scheduler determines that the UMS thread is not kernel locked no at decision block the process may proceed to block . At block the UMS thread may record the context reference of the primary thread. In other words the identification of the primary thread may be recorded in the CID field field of the UMS thread context . At block the CPU context of the UMS thread that is the user portion may be loaded for execution in user mode .

At block the CPU context of the UMS thread as present in the user portion of the primary thread may be saved back into the user portion of the UMS thread . At block the user thread descriptor of the primary thread may be reloaded. In other words the user thread descriptor of primary thread may be reset to its original state.

At block the primary thread may release the CID field of the UMS thread . In other words the identification of the primary thread may be removed from the CID field of the UMS thread context. At block the user mode scheduler may load a new CPU context into the primary thread .

In a very basic configuration computing device typically includes at least one processing unit and system memory . Depending on the exact configuration and type of computing device system memory may be volatile such as RAM non volatile such as ROM flash memory etc. or some combination of the two. System memory typically includes an operating system one or more program modules and may include program data . The operating system include a component based framework that supports components including properties and events objects inheritance polymorphism reflection and provides an object oriented component based application programming interface API such as but by no means limited to that of the .NET Framework manufactured by Microsoft Corporation Redmond Wash. The device is of a very basic configuration demarcated by a dashed line . Again a terminal may have fewer components but will interact with a computing device that may have such a basic configuration.

Computing device may have additional features or functionality. For example computing device may also include additional data storage devices removable and or non removable such as for example magnetic disks optical disks or tape. Such additional storage is illustrated in by removable storage and non removable storage . Computer storage media may include volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. System memory removable storage and non removable storage are all examples of computer storage media. Computer storage media includes but is not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can be accessed by computing device . Any such computer storage media may be part of device . Computing device may also have input device s such as keyboard mouse pen voice input device touch input device etc. Output device s such as a display speakers printer etc. may also be included. These devices are well known in the art and are not discussed at length here.

Computing device may also contain communication connections that allow the device to communicate with other computing devices such as over a network. These networks may include wired networks as well as wireless networks. Communication connections are one example of communication media. Communication media may typically be embodied by computer readable instructions data structures program modules etc.

It is appreciated that the illustrated computing device is only one example of a suitable device and is not intended to suggest any limitation as to the scope of use or functionality of the various embodiments described. Other well known computing devices systems environments and or configurations that may be suitable for use with the embodiments include but are not limited to personal computers server computers hand held or laptop devices multiprocessor systems microprocessor base systems set top boxes game consoles programmable consumer electronics network PCs minicomputers mainframe computers distributed computing environments that include any of the above systems or devices and or the like.

The use of directed switches for primary threads and the UMS thread may enable pure user mode switching. The use of pure user mode switching may provide an architecture and or platform for applications such as high performance enterprise applications with the ability to better control thread execution and concurrency. Moreover the use of directed switches on a multi processor platform may enable applications to scale efficiently. With the use of directed switches and support mechanisms described herein applications may have the ability to utilize all system services and or application programming interface API on UMS threads transparently that is in the same manner as standard NT threads without compatibility issues.

In closing although the various embodiments have been described in language specific to structural features and or methodological acts it is to be understood that the subject matter defined in the appended representations is not necessarily limited to the specific features or acts described. Rather the specific features and acts are disclosed as exemplary forms of implementing the claimed subject matter.

