---

title: Storing state in a dynamic content routing network
abstract: A client module of an object state storage is configured to identify a live object at a client. The client module is further configured to receive an update message for the live object from storage, the update message is stored by an object ID associated with the live object, and the update message allowing the property to be updated for the live object at the client in real-time. The client module is further configured to transmit the update message for the live object to the client.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09613076&OS=09613076&RS=09613076
owner: Zarba√±a Digital Fund LLC
number: 09613076
owner_city: Wilmington
owner_country: US
publication_date: 20130712
---
This application is related to U.S. patent application Ser. No. 11 515 366 filed Aug. 31 2006 Ser. No. 10 213 269 filed Aug. 5 2002 now U.S. Pat. No. 7 127 720 and Ser. No. 10 017 182 filed Dec. 14 2001 now U.S. Pat. No. 7 043 525 and U.S. Provisional Application Nos. 60 256 613 filed Dec. 18 2000 60 276 847 filed Mar. 16 2001 60 278 303 filed Mar. 21 2001 60 279 608 filed Mar. 28 2001 and 60 280 627 filed Mar. 29 2001 all of which are hereby incorporated herein by reference.

This disclosure pertains in general to transferring information through digital networks and in particular to storing the state of properties being updated by the transferred information.

The Internet is a digital network of computers. An individual computer on the Internet is typically identified by an interne protocol IP address. A computer on the Internet sends a packet of information to another computer by routing the packet to a logical port at the destination computer s IP address. The destination computer interprets the packet according to one of several possible protocols determined by the port to which the packet was sent.

The World Wide Web the Web is a collection of technology and content available on the Internet that allows the content to be routed from server computers to particular destination computers. The Web includes a large number of web pages residing on many different servers. Web pages contain one or more files or references to one or more files specifying instructions for presenting the web page and content such as text images apples video and or audio.

Web pages use a variety of definitional and programming languages to control how information is presented. The most fundamental of these is the Hypertext Markup Language HTML . HTML uses a system of tags to specify how content should be displayed. Recent advances in HTML introduce style sheets which help separate content information from display information. HTML has also been modified and extended to provide new capabilities. For example Extensible Markup Language XML adds semantic content to web pages. In addition Dynamic HTML DHTML adds some dynamic content to web pages.

A web page may also include one or more programs for controlling how the web page is displayed. For example JAVA applets and JAVASCRIPT scripts may be used to control the display of a web page. In addition DHTML uses scripts to control the dynamic content. Thus a web page designer can use applets and scripts to produce animation effects or modify the display based on user interaction. For example the designer can write a script that changes the color of a piece of text when a user clicks on a button.

Devices that display execute web pages are often called client devices or simply clients. Client devices include personal computers web enabled set top boxes and televisions cellular telephones personal digital assistants and other handheld devices and special purpose web browsing appliances. Client devices typically employ a program called a web browser for interpreting the HTML or other display instructions in the web page and displaying the content accordingly. Most web browsers include special functionality such as a Java Virtual Machine for executing JAVA applets and or other applets or scripts embedded in the web pages.

A client device specifies a web page or other document on the web using a Uniform Resource Locator URL . A URL has the form service server path file. Here service refers to the protocol to be used such as the file transfer protocol FTP or the hypertext transport protocol HTTP . Server is the IP address of the server containing the page and path file specifies the particular web page on the server.

The Web suffers from a substantial limitation with respect to dynamically updating content in a web page at a client device. The Web s predominant mode of operation is for a client device to first request a page from a server and then for the server to send the requested page to the client device. Once the server delivers the page to the client it typically terminates its connection to the client and does not retain any information about the client or the page that was sent. For this reason servers are typically stateless. As a result client devices drive and control the flow of information around the Web. While client side control is appropriate in some situations it does not permit efficient updating of data at the client devices. For example if a web page contains information that may change such as the score of a baseball game or a stock quote the server has no way to inform the client devices that are viewing the page of the change. Instead the client devices must ask the server for the updated information. However the client devices do not know when the information on the web page has changed and thus do not know to ask for the update.

There are some simple web programming techniques that attempt to update content on client device side web pages. One approach that web designers use is to rely on the client devices to periodically re request web pages. This updating can be performed as the result of user action such as pressing the refresh button or can be automated to occur on a particular schedule such as by using the HTML Meta Refresh tag to cause the client device to request the page every X seconds . Although this technique provides client devices with more up to date information it is very wasteful of resources. In particular the web server must resend the page even if nothing has changed and even when something has changed it must resend the entire web page rather than just the updated information which may be only a very small part of the page. Further attempting to reduce unnecessary requests by decreasing the request rate results in decreasing the currency of the data. This is an unalterable trade off in a client driven approach.

The performance of automatic refreshing can be improved somewhat by putting information that may change in a separate frame from information that is less likely to change and only refreshing the separate frame. A few web designers even write custom JAVA applets to limit refreshing to individual components on a page such as the score of a soccer game. A willingness to go to such effort illustrates the serious drain of resources caused by frequent refreshing.

Nevertheless even custom JAVA applets are not a meaningful attack on this problem. Custom applets require a large separate development effort for each item on each page that might need to be updated. More importantly most custom applets still update content based upon client driven requests although it is possible to design an applet that accepts pushed messages. This solution is not scalable to provide updated information for large numbers of client devices and for large numbers of web pages.

Therefore there is a need in the art for an efficient way to provide dynamic content to a web page at a client device. Preferably a solution to this need will efficiently specify initial values for content provided to the clients as well as enable efficient updates of the content.

According to one embodiment a non transitory computer readable storage medium having instructions stored thereon for updating a property of a live object at a client the instructions when executed causes a processor to perform operations including identifying the live object at the client. The operations further includes receiving an update message for the live object from an object state storage where the object state storage is located on a dynamic content routing network the update message is stored by an object ID associated with the live object and the update message allowing the property to be updated for the live object at the client in real time. The operations also include processing the update message.

According to another embodiment a hardware based dynamic content routing network includes means for maintaining mappings between clients and live objects using an object ID associated with the live objects. The dynamic content routing network further includes means for receiving an update message for an identified live object and means for routing the update message using the object ID associated with the live object to the clients according to the mappings.

According to another embodiment a client module of an object state storage is configured to identify a live object at a client. The client module is further configured to receive an update message for the live object from storage the update message is stored by an object ID associated with the live object and the update message allowing the property to be updated for the live object at the client in real time. The client module is further configured to transmit the update message for the live object to the client

The features and advantages described in this summary and the following detailed description are not all inclusive and particularly many additional features and advantages will be apparent to one of ordinary skill in the art in view of the drawings specification and claims hereof.

The figures depict an embodiment of the present disclosure for purposes of illustration only. One skilled in the art will readily recognize from the following description that alternative embodiments of the structures and methods illustrated herein may be employed without departing from the principles of the disclosure described herein.

The server client information provider dynamic content provider OSS and routing network are preferably in communication via conventional communications links such as those comprising the Internet. The communications links include known wired communications media such as dedicated or shared data cable television or telephone lines and or known wireless communications media such as communications over the cellular telephone network using protocols such as the global system for mobile communications GSM code division multiple access CDMA time division multiple access TDMA etc.

In one embodiment the entities may each be in communication with one or more Internet Service Providers ISPs not shown that provide each entity with access to other computers on the Internet. The addition the server client information provider dynamic content provider OSS and routing network are preferably each identified by at least one Internet Protocol IP address such as 66.35.209.224. The IP address may also have one or more domain names associated with it such as bangnetworks.com. Alternative embodiments may use alternative addressing schemes and or naming conventions instead of or in addition to those described herein. For example embodiments wherein one or more of the clients are cellular telephones or other portable devices may rely on different addressing schemes.

Preferably the information provider provides web pages or other representations of data to the server . The web pages contain one or more live objects which are designated to be real time dynamically updateable objects. Each live object is identified by an object identifier or object ID. Preferably the web pages do not specify initial properties for the live objects and the information provider does not need to modify the web pages when properties of the objects change. Moreover if the updates to the properties of the live objects are supplied by a dynamic content provider the information provider does not even need to be notified when the properties change. The server provides the web pages to multiple clients .

The clients preferably obtain the initial properties for the live objects identified by the object IDs on the web pages from the OSS . The clients also contact the routing network and register for update messages for the object IDs. The routing network in turn preferably maintains a registry indicating which clients have registered for which object IDs.

The information provider and or dynamic content provider send update messages to the routing network . These messages can be sent any time the information provider or dynamic content provider wants to update a property of a live object. Each update message preferably identifies a live object and contains data for updating a property of the identified live object. The routing network accesses the registry and determines which clients have registered for the identified object. Then the routing network routes the update message to the appropriate clients. Upon receipt of an update message the clients update the specified property of the live object.

In one embodiment the information provider and or dynamic content provider also send certain update messages to the OSS . In another embodiment the routing network routes certain update messages to the OSS . The OSS preferably stores the update messages. The OSS provides these update messages to the clients to set the initial properties of the live objects on web pages received by the clients.

The functionality of the OSS advantageously relieves the information provider and or dynamic content provider from managing the initial properties of the live objects. Without the OSS the information provider would either need to specify initial properties in the web pages it serves or let the client view the web pages without the properties until the client receives the update messages via the routing network . Given the OSS the information provider dynamic content provider knows that the client will have the most current properties for the live objects almost immediately upon loading the page.

The routing network provides an efficient one to many mapping of objects to clients and by inference of information a many to many mapping of information providers dynamic content providers to clients through object based routing. Messages provided by the information provider and or dynamic content provider to the routing network are not routed to the clients based entirely on a specified destination more specifically they are not routed based on the IP address of the client as in conventional IP routing schemes. Instead the messages are routed based on the live objects referenced by the message.

The mapping and object based routing provided by the routing network allow the information provider and dynamic content provider to update properties of live objects at a dynamically changing cross section of clients in real time without requiring the information provider or dynamic content provider to track the clients or web pages being viewed by the clients. The clients in turn do not need to have any a priori knowledge of object IDs they discover which IDs they should register when they receives the web pages from the server .

Object based routing also allows information providers to dynamically update content on web pages without requiring the clients to re request the content and without requiring the information providers or servers to maintain connections with the clients. In this manner significantly more clients can receive updated content from a given information provider than would be possible utilizing conventional client side request driven transmission control protocol Internet Protocol TCP IP connections between the clients and the server .

Turning now to the individual entities illustrated in the server is preferably a conventional computer system configured to act as a web server and serves web pages and other data representations to clients . The web pages provided by the server are associated with one or more information providers .

An information provider is an entity providing one or more web pages information contained in web pages and or other representations of data served by the server . The information provider preferably has a conventional computer system coupled to the Internet. In one embodiment the server is directly controlled by the information provider e.g. the server is physically located at the information provider and or is dedicated to serving only the information provider s web pages . In this embodiment the server and information provider can be treated as the same entity. In an alternative embodiment the server serves web pages from multiple information providers.

As is known in the art the web pages and other content on the server are specified by uniform resource locators URLs having the form service server path web page. Typically web pages are obtained via the hypertext transport protocol HTTP and thus an exemplary URL for retrieving the web page b1.html from the web server having the domain name www.bangnetworks.com is http www.bangnetworks.com news b1.html. 

As used herein a web page is a block of data available from the server . In the simplest case a web page is a file written in the hypertext markup language HTML . The web page may also contain or refer to one or more other blocks of data such as other files text images applets video and or audio. In addition the web page may contain instructions for presenting the web page and its content such as HTML tags and style sheets. The instructions may also be in the Extensible Markup Language XML which is related to HTML and adds semantic content to web pages or the Dynamic HTML DHTML which adds some dynamic content to web pages. Additionally the instructions may take the form of one or more programs such as JAVA applets and JAVASCRIPT and or DHTML scripts.

As used herein the phrase web page also refers to other representations of data served by the server regardless of whether these data representations include characteristics of conventional web pages. These data representations include for example application programs and data intended for the web browser or other application programs residing at the clients or elsewhere such as spreadsheet or textual e.g. word processing data etc.

In a preferred embodiment objects at the client such as web pages and elements of web pages can be designated as live by the information provider . Properties of a live object can be dynamically updated in real time at the client by the information provider or another entity acting on behalf of the information provider. As used herein an object is any datum or data at the client that can be individually identified or accessed. Examples of objects include elements of web pages such as text characters and strings images frames tables audio video applets scripts HTML XML and other code forming the web page variables and other information used by applets scripts and or code URLs embedded in the web page etc. Application and operating system constructs are also objects. For example cells of spreadsheets text in word processor documents and title bars and messages displayed by the operating system or applications are objects. Preferably multiple objects can be grouped together into a single logical object. Thus an object can be defined at any desired or useful level of granularity.

Since content on a web page is conceptualized and organized by object the present disclosure essentially abstracts web pages and web page content and other modules and or functionality at the client away from the HTML code or other conventional representation. This abstraction allows the information provider to update a property of an object without concern for the location display format or other specifics of how the data is being represented at the client .

Live objects have associated properties which include any modifiable data related to the object or referenced with respect to the object. The properties may or may not affect the visual representation of the object in the web page or other data representation. A property may affect an internal aspect of the object and thus a change to the property may not have any direct effect on a web page containing the object. For example the property may affect whether particular aspects of the object are modifiable how the object responds to user input or other stimuli etc. Additionally a property may also have a direct effect on how the object is displayed at the client . For example the property may affect the content color typeface size formatting or other attribute of text images or other data displayed by the object. Other properties may occupy parts of the spectrum between having no effect on the visible representation of the object and having a direct effect on the visible representation of the object. For example a web page showing scores of football games may include a list of games and the current scores of the games as of the time the server serves the web page. The list of games subset of games to be displayed and the scores of the games can be designated as live objects or properties of a single live object and updated as necessary or desired.

A property can also preferably include instantiating an instance of the object or invoking functionality of the object. For example a property of a browser window object may include functionality for instantiating another browser window. This function can be invoked as a logical change to a property of the object. The second browser window can be referenced through the original browser window i.e. object or designated as a new live object.

An information provider or other entity preferably updates a live object at a client via an update message. In general an update message identifies the live object and if necessary the property of the live object and contains data for updating the property. In one embodiment the data may be the actual value for the property or executable code for causing the object s property to be updated. For example the data may be a simple numerical or textual value e.g. 4 to which the property should be set and or the data may be JAVASCRIPT code or a call to a JAVASCRIPT function at the client that effects the desired change to the property of the object.

The update message preferably implicitly or explicitly identifies a handler at the client for use in updating the live object s property. In one embodiment the client utilizes a default handler when the message implicitly specifies the handler e.g. when the message does not identify a specific handler . In one embodiment if the update message specifies the actual value for the property a default handler generates JAVASCRIPT code for changing the property to the specified value. If the data in the update message are JAVASCRIPT code the default handler does not perform any processing of the code. In either case the default handlers preferably use LiveConnect to execute the JAVASCRIPT code in a Java Virtual Machine JVM at the client and thereby update the property of the live object.

For certain objects and or data types the default handlers are not appropriate. In these cases the message preferably explicitly identifies a handler for performing the update. For example the message may explicitly specify a function to call on the data or the message may explicitly identify the environment in which the data should be executed. For example the data in the update message may include code for execution by a software plug in such as MACROMEDIA FLASH and the message may explicitly identify FLASH as the handler.

The information provider preferably designates an object as live by including a unique identifier for the object the object ID in the web page or other data representation provided to the client . In one embodiment the information provider encodes the object ID in an objects corresponding HTML ID attribute using the following HTML expression ID elementIdentifier where elementIdentifier is the object ID and is preferably a string. The string can encode any information desired by the information provider or other entity establishing the object ID and in one embodiment is a simple textual and or numeric identifier. In one embodiment the information provider begins the object ID with a predefined token such as Bang in order to distinguish live objects from other objects that happen to have defined ID attributes. For example an object can have the object ID Bang elementIdentifier. 

In the preferred embodiment each information provider optionally encodes a unique information provider ID in its object IDs in order to prevent naming collisions between the object IDs of different information providers. In one embodiment the information provider ID is a textual and or numeric identifier. The information provider may specify the information provider ID and the object ID as part of a hierarchical namespace. For example in one embodiment objects are named as follows namespace1 namespace2 . . . . namespaceN objectid where namespace1 is the information provider ID and the operates as the name separator and defines additional optional levels of a namespace hierarchy. One embodiment of the system supports typical directory services functionality. For example two dollar sign characters appearing together. refers to the top level of the namespace hierarchy.

Thus the object ID for a live object is preferably formed from a combination of the predefined token the information provider ID namespace and a value assigned by the information provider . For example the object ID for a live object representing the real time price of a stock having the symbol BANG might be Bang informationProviderID equities realtime bang. In this example Bang is the predefined token that signifies a live object informationProviderID is the ID identifying the information provider equities realtime defines levels of a namespace hierarchy and bang identifies the specific object.

In some embodiments and situations the object ID utilizes relative names. For example an information provider referring to its own object IDs is implicitly in its own namespace. Accordingly the information provider does not need to include the information Provider ID in the object IDs it utilizes internally. In one embodiment the information provider ID is not explicitly encoded into the object ID. Instead the information provider ID is encoded elsewhere in the web page in order to provide scope to the page s object IDs.

In one embodiment the object ID identifies a point i.e. a node in a tree in a Document Object Model DOM representation of a web page or other document at the client . The DOM is a platform and language neutral interface that represents a document as a hierarchy of objects. The DOM also provides an interface that allows programs and scripts to dynamically access and update properties of the objects. Object properties can be inherited by descendent objects.

In this embodiment the client preferably executes an update message in the context of the specified point in the DOM representation. The update may specify a change to a property of the object at the identified point. The update also may specify a change to a parent or descendent of the object at the identified point. In each case the update is executed relative to the specified point in the DOM representation. In one embodiment points in the DOM representation specify how to update properties of live objects located at those points. Thus the same update may be interpreted differently depending upon the identified live object s location in the DOM representation.

For example assume there is an object in the DOM representation identified as window.document.frame 3 .ObjectID. Also assume that the object has an innerText property located at window.document.frame 3 .ObjectID.innerText that specifies the text displayed by the object. An update message can change the text displayed by the object by specifying ObjectID and the new value for the innerText property.

An advantage of utilizing object IDs to specify objects is that the information provider or other entity providing the update message can access and change properties of objects without knowing the object s actual location in the DOM representation. Indeed the object may be in different locations in different DOM representations and or in multiple locations in the same DOM representation. In any of these cases the update message will change the specified properties of all of the objects having the given object ID.

Depending upon the particular embodiment of the environment the information provider and or the dynamic content provider provides update messages to the routing network and optionally to the OSS . The dynamic content provider is preferably a conventional computer system operated by an entity that provides real time information such as stock prices and or sports scores. In one embodiment the information provider receives updated properties for the live objects from the dynamic content provider or another source or generates the updated properties internally . Then the information provider sends an update message specifying the object ID and the change to the object property to the routing network and OSS . In this embodiment the dynamic content provider may be absent from the environment .

In another embodiment the dynamic content provider provides the object IDs for live objects to one or more information providers and the information providers distribute the live objects to the clients . Then the dynamic content provider sends messages specifying the changes to the properties of the live objects to the routing network and OSS . For example the dynamic content provider distributes an object ID associated with the score of a particular baseball game to the information providers . Then the dynamic content provider sends a message specifying the object ID and an update to a property of the object that controls the displayed score of the particular baseball game to the routing network and OSS . These two embodiments are not mutually exclusive and therefore some updates may be provided by the information provider while others are provided by the dynamic content provider .

The OSS is preferably a conventional computer system adapted to receive and store update messages from the information provider dynamic content provider and or routing network . The OSS is also adapted communicate with clients to determine which live objects are on web pages downloaded by the clients and to provide the stored update messages for those live objects to the clients. In an alternative embodiment the OSS is adapted to communicate with the clients indirectly through the routing network . In one embodiment the functionality of the OSS is provided by a standalone server. In other embodiments however the functionality of the OSS is integrated into the routing network web server information provider and or dynamic content provider .

The client is a device that retrieves web pages and or other information from the server . In one embodiment the client is a conventional personal computer used by a person to access information on the Internet. In alternative embodiments the client is a different consumer electronic device having Internet connectivity such as an Internet enabled television a cellular telephone a personal digital assistant PDA a web browsing appliance etc. The client preferably but not necessarily has an associated display device.

The client preferably executes a web browser such as MICROSOFT INTERNET EXPLORER for retrieving web pages and displaying them on the display device. In embodiments where the client receives data representations from the server other than conventional web pages the web browser does not necessarily share similarities with conventional web browsers. Preferably the web browser contains a JVM for executing JAVA applets and or scripts. The web browser also preferably contains Dynamic HTML capabilities such as support for JAVASCRIPT or another scripting language such as VBScript and the Document Object Model DOM and enables communications between JAVA and the scripting languages. In one embodiment the web browser supports the LiveConnect standard for enabling communication between JAVA applets and scripts written in the supported scripting languages. The web browser can also be extended through software plug ins such as MACROMEDIA FLASH REAL NETWORKS REALPLAYER and or APPLE QUICKTIME . In alternative embodiments the functionality of the JVM and or other aspects of the web browser are provided by one or more other functional units within the client . The term module is used herein to refer to software computer program code and or any hardware or circuitry utilized to provide the functionality attributed to the module. The web browser and JVM are examples of modules in the client .

In some embodiments the client does not necessarily have a display device web browser and or other components associated with a typical consumer device. The client for example may be a dedicated purpose device having certain aspects of web connectivity such as an embedded HTTP client in a web enabled appliance or in a controller for an automobile audio visual equipment or some other device.

A web page provided from the server to the client preferably includes instructions for enabling the live objects on the web page. The instructions cause the client to automatically and transparently i.e. without user interaction contact the routing network and download an activation module for activating the live objects. In one embodiment the instructions comprise a URL specifying the location of the activation module at the routing network . In an alternative embodiment the client obtains the activation module from the server or another source.

The activation module preferably contains JAVA instructions for execution by the JVM . However alternative embodiments of the module may encode the instructions in the web page and or the activation module using different languages and or techniques. For example the instructions and or activation module can be embedded in the web browser or operating system either as native code or as plug ins. In these alternative embodiments the web browser does not have to download the activation module from an external source.

The activation module preferably provides the object IDs of the live objects on the web page to the OSS . In response the OSS sends the activation module the stored update messages for those live objects. The activation module updates the properties of the live objects at the client as specified by the update messages.

Contemporaneously with the interactions with the OSS the activation module preferably registers the object IDs with the routing network . The routing network records the registrations in the registry . The client s registrations preferably remain in effect as long as the client is displaying the associated web page although other embodiments of the system may use different criteria for determining when to terminate the client s registrations. The activation module updates the live objects as specified by any subsequent update messages received from the routing network .

In an alternative embodiment the OSS directly interfaces with the routing network and does not directly interface with the client . In this embodiment the activation module at the client does not contact the OSS to obtain the initial properties but does register the object IDs with the routing network as described above. The routing network upon receiving new registrations from the client contacts the OSS in order to obtain the current update messages for the registered for objects. Then the routing network provides the update messages to the client in the normal manner. This alternative embodiment is advantageous because the activation module does not need to include separate functionality for interacting with the OSS .

In the embodiment where the client directly interfaces with the OSS the activation module sends the object IDs to the OSS . The OSS in turn authenticates the client activation module and provides it with the stored update messages for the identified objects. The activation module processes the received messages and updates the properties of the live objects on the client s web page . The activation module also registers the object IDs with the routing network . The routing network updates its registry to identify the object IDs for which the client has registered.

At some point the input source sends an update message to the routing network in order to change a property of a live object at the client . In one embodiment the message from the input source to the routing network contains only a single object ID and an update to a property of the identified object. In another embodiment the message contains multiple object IDs and the corresponding property updates. In this latter embodiment the message may have an associated Batch ID that identifies the message as having multiple object IDs and updates. Preferably the information provider can include a batch ID in a web page in the same manner as including an object ID. Likewise the client can preferably register for a batch ID with the routing network in the same manner as an object ID. Similarly the OSS can store batch IDs and batch messages in the same manner as non batch IDs and messages. In fact the batch ID can be the same as the object ID so that the client registers for both batch and non batch messages by registering one ID. Alternatively separate procedures can be established for registering batch messages. The client preferably processes the component messages of a batch as if each message were delivered separately.

The routing network in turn routes the message to each client that has registered for the specified object ID preferably by utilizing standard Internet communications protocols such as IP addresses etc. The activation module at the client processes the message and updates the property of the identified live object. If live objects having the same object ID appear in multiple locations at the client e.g. at multiple locations on a web page being displayed at the client the activation module preferably updates each of the live objects having the specified ID. As a result the routing network allows live objects at the client to be dynamically updated. Preferably this routing and updating happens quickly enough to be considered real time for the purposes of the input source .

The update message from the input source to the routing network is optionally sent to the OSS . In one embodiment the input source selectively sends update messages directly to the OSS . In another embodiment the input source includes a flag or other data field with the update message that indicates whether the routing network should send the message to the OSS . In yet another embodiment the input source or routing network sends every update message to the OSS . Preferably the OSS stores the update messages although it may contain functionality for determining whether a particular message should be stored or discarded. Preferably the OSS overwrites a previously stored update message for the same object if one exists with the new update message. In one embodiment the input source routing network and OSS contain functionality allowing the input source and or routing network to route control messages to the OSS. These control messages may for example tell the OSS to delete all update messages from its storage delete certain update messages etc.

This update process indicated within the dashed box in can repeat an indefinite number of times and is fully asynchronous as to the information provider client and OSS . For example the input source may send regular update messages to the routing network as the score of a sporting event changes or a stock price fluctuates but may stop sending update messages once the sporting event ends or stock market closes. When the client ends the display of a web page containing the live object or otherwise no longer desires to receive update messages the client preferably closes the connection with the routing network . The routing network in turn updates the registry to remove the client s object registrations. In another embodiment the client sends messages to the routing network that selectively register and or de register the client from one or more objects yet leaves the connection open in order to receive update messages pertaining to other objects.

In one embodiment steps occur in a different order or close enough in time that the client receives the update message from the routing network before it receives the update message for the same object from the OSS . In a preferred embodiment the activation module contains functionality enabling it to determine the source of the message and discard the message from the OSS .

In one embodiment the activation module contains functionality enabling it to determine whether to retrieve an update message for an object ID from the OSS or wait for an update message from the routing network . For example the activation module can make this determination based on information contained in the web page downloaded from the server . Thus this embodiment allows the information provider or other entity providing the web page to specify whether the client should retrieve the properties for an object from the OSS or wait for an update message. This control preferably exists at the object level meaning that the client might contact the OSS for update messages for only a subset of the objects on a web page.

The activation module does not necessarily apply the update messages received from the OSS to the live objects on the web page . In one embodiment the activation module and OSS include functionality wherein the activation module can request to receive the update messages in a string or similar format. The activation module can analyze and process the update message string to determine whether to apply the updates rather than simply applying the update messages to the live objects. In another embodiment the activation module alone contains functionality for generating a string from the update messages received from the OSS .

In one embodiment the activation module uses the OSS to recover from an error or other fault at the client . If something happens at the client and it loses all of the properties for the live objects on a web page the activation module can contact the OSS and retrieve the current properties for the live objects. This situation might occur for example if the web browser crashes and is restarted but then loads the previously displayed web page out of a local cache instead of from the server .

There are various ways to internally represent the games and scores in the web pages using live objects. In one embodiment a game object is defined having properties for the two teams involved in the game and the score associated with each team. The game object is placed at a selected position in the web page and the properties of the object cause the information about the game to be displayed on the page. In another embodiment team and score objects are defined with the team object having a property defining the name of a team and the score object having a property defining a score. In this second embodiment the team and score objects are placed at selected locations on the page so that the proper teams and scores are aligned when the page is rendered. In yet another embodiment an object is defined having properties for the name of one team and a score associated with that team. Then pairs of the objects are placed in the page in the proper alignment to indicate the games and scores. In another embodiment an object is defined having properties specifying names of two teams and a separate object is defined having properties specifying two scores. In this last embodiment the two objects are placed in the page so that the names of the teams align with the associated scores. Obviously additional variations of these representations are possible.

Assume for the example of that the names of teams in a game are specified by a names object having properties for the two team names and the scores in the game are specified by a scores object having properties for two scores. In web page a names object having properties set to identify the SF 49ers and the STL Rams is located directly under the Local Sports Scores heading. A scores object having a property set to identify the score of the game as 42 to 7 is directly to the right of the names object . In web page the properties of the second names object identify the same game using slightly different terminology SF and STL. However this names object is aligned with the same scores object as is utilized in web page .

Thus the same scores object is utilized in different positions in each web page . In order to update the score of the San Francisco 49ers vs. St. Louis Rams football game on both web pages the input source simply sends an update message to the routing network specifying the object ID for the scores object and the update to the score property. The routing network routes the update message to the appropriate clients and the clients update the appropriate score regardless of the particular page layout.

The input source i.e. the information provider and or dynamic content provider can use a variety of tools to generate the update messages. is a block diagram illustrating an input source and the tools available to it for generating the update messages. Other tools can be utilized in addition to or instead of the ones described herein.

Preferably the tools allow the input source to access an application programming interface API provided by the routing network for accepting messages. In one embodiment the messages sent by the input source are in the same format as utilized by the activation module at the client . In an alternative embodiment the messages provided to the routing network are in a different format and the routing network translates the messages into the format utilized by the activation module .

In one embodiment the input source utilizes a data pump module to access the API. The data pump module reads an extensible markup language XML file containing one or more object IDs and the new values for the identified objects at regular intervals and automatically generates API calls that send messages representing changes to object properties to the routing network . In another embodiment the data pump module is event driven and reads the XML file in response to a change in the file or some other occurrence.

In another embodiment the input source utilizes a director console module to access the API. Preferably the director console module presents an administrator with a graphical interface displaying the contents of the web page . For example the administrator may use the director console to edit textual data images and or any objects or properties of objects on the web page. After editing the administrator uses a send update button or similar technique to cause the director console module to send messages for the changed objects and properties to the routing network via the API.

In another embodiment the information provider and dynamic content provider work together as the input source by using a content management system module to access the API. Preferably the content management system module resides at the information provider and receives object property updates from the dynamic content provider . The content management system module preferably updates the properties of the live objects in the web page stored at the server and also sends messages for the changed properties to the routing network . In this manner the web page at the server and the web page displayed at the client are updated almost simultaneously. In one embodiment the dynamic content provider sends the update messages to the routing network instead of to the information provider . Embodiments of the system can also utilize any combination of the content management techniques described herein.

For example the tools described above can generate a message having the following code for updating the text displayed by a score object to 2 

Turning now to the actions performed at the client is a flow chart illustrating the steps performed by an embodiment of the activation module . Those of skill in the art will recognize that different embodiments may perform the steps of in different orders. The activation module generally performs four functions interacts with the OSS registers object IDs with the routing network handles messages received by the client from the OSS and network in order to update the properties of live objects and controls communications between the client and the network.

The activation module preferably parses the web page received from the server and identifies the object IDs of the live objects. In an alternative embodiment the activation module identifies only a subset of the object IDs such as the IDs of only live objects that are currently being displayed by the web browser . Alternatively a list of object IDs may be pre encoded in the web page in addition to the objects themselves thereby enabling easy identification by the activation module . In yet another embodiment a user of the client selects the object IDs to register.

The activation module preferably opens a connection between the client and the OSS or routing network depending upon the embodiment . In some cases the client is located behind a firewall that puts a restriction on the types of connection requests the client can make. A firewall might for example block all non HTTP traffic. For this reason the activation module preferably wraps the connection request in an HTTP header in order to get the request through the firewall. The activation module uses the connection to send the OSS a vector e.g. a list or array containing the identified object IDs. In order to accomplish this task through the firewall the activation module preferably puts the vector into a string referred to as object data and then preferably creates an HTTP message to communicate the object data to the routing network . A schematic example is as follows 

where is the object ID list. In response the OSS sends the client the stored update messages for the identified objects and the connection between the client and OSS is then closed. The activation module then updates the properties of the objects on the web page as specified by the update messages.

The activation module preferably opens a connection between the client and the routing network and sends the object ID list using the same technique as with the OSS . When the routing network receives the HTTP request it extracts the object data and updates the registry to indicate that the client has registered for the identified objects.

If the web browser loads a new page or otherwise terminates display of the objects on the initial page the activation module associated with the initial web page preferably terminates the client s connection with the routing network . Those of skill in the art will recognize that this termination can occur asynchronously with the other steps illustrated in . Thus the location of steps and represents only one possible place in the sequence of steps where the termination may occur.

If the connection is not terminated the activation module preferably waits until it receives a message from the routing network specifying an object ID and an update to a property of the identified object. In one embodiment this message is received as HTTP data. Upon receipt of the message the activation module preferably extracts the object ID and update from the HTTP data. Then the activation module updates the property of the identified object or causes the object to be updated as specified by the message.

The sequence of receiving messages extracting data and updating objects is preferably repeated until a new page is loaded or the connection with the routing network is otherwise terminated. Although not shown in in certain circumstances such as when a user action with respect to the web page activates a new live object the activation module may register new object IDs with the routing network without first downloading and parsing a new page. In one embodiment if the newly loaded page contains live objects then the process of downloading the activation module and updating the objects as described by is repeated. In an alternative embodiment the activation module remains active at the client and therefore the client does not re download the activation module from the routing network . Instead the already present activation module performs the live enabling process on the new page.

Internally the routing network is preferably divided into one or more clusters . In the routing network has three clusters A B C although the number of clusters can vary depending upon the processing needs of the network. An input side global load balancer preferably routes messages from the input sources to the clusters . Similarly a client side global load balancer preferably routes connection requests from the clients to the clusters . The load balancers are designed to ensure that load is distributed among the clusters according to a predetermined heuristic. For example the load may be distributed evenly among the clusters or a more powerful cluster may be distributed a majority of the load. In one embodiment one load balancer performs the functions of the input side and client side load balancers and utilizes conventional Domain Name System DNS based load balancing.

Each cluster of which cluster A is representative preferably contains an input side cluster load balancer A and a client side cluster load balancer A. The cluster load balancers A A function similarly to the corresponding global load balancers in that the input side cluster load balancer A balances and routes incoming messages among one or more gateways A and the client side cluster load balancer A balances and routes incoming connection requests among one or more nodes A and application servers A.

In one embodiment the functionality of the two client side cluster load balancers A A is provided by one component. This single component load balancer initially determines whether an incoming request is from an input source seeking to send a message to a gateway A a client seeking a connection to a node A or a client seeking a connection to an application server A. Then the load balancer routes the messages connection requests among the gateways A nodes A and application servers A within the cluster . In one embodiment the single component load balancer provides layer seven load balancing i.e. load balancing at the application layer . Preferably the load balancing for the nodes A and application servers A are performed by the same component since for security reasons most client web browsers only permit an application e.g. the activation module to transparently connect to the location from which the application was downloaded.

Alternative embodiments of the routing network may combine the global and cluster A A load balancers and or incorporate the functionality of the load balancers into different components within or outside of the clusters . In addition alternative embodiments may omit one or more of these load balancers. For example having different clusters serve different customers might obviate the need for the global load balancers .

The gateways A in the cluster receive the messages from the input sources and direct the messages to the appropriate node or nodes A. In one embodiment each gateway A maintains a persistent TCP connection to every node in every cluster and directs every message to every node. Therefore although a gateway A is located inside a cluster A and receives connections via the cluster s input side load balancer A the gateway s scope spans the entire routing network . This broad scope allows messages from any input source to reach any client .

In an alternative embodiment of the routing network each gateway maintains a persistent TCP connection to all nodes in the same cluster and at least one connection to at least one gateway in each of the other clusters. This embodiment reduces the number of simultaneous TCP connections maintained by each gateway . In another alternative embodiment each cluster also includes a gatekeeper not shown in that maintains connections with the gateways of other clusters. A gateway forwards messages to the gatekeeper which then distributes the messages to the gateways of other clusters .

Since a gateway does not control the rate at which it receives messages from input sources it is possible for the gateway to receive messages faster than it can process them i.e. send the messages to the nodes . Therefore each gateway preferably maintains a queue of messages that have been received but not yet processed in order to avoid losing messages. In one embodiment the gateway drops messages if the queue becomes too long. In another embodiment the gateway utilizes priorities assigned to certain messages or input sources to determine which messages to drop.

The nodes preferably transmit messages received from the gateways to the clients that have registered in the object IDs identified by the messages. If no clients have registered the object ID specified by a message the node preferably ignores the message. A node preferably maintains an instance of the registry as a hash table containing the object IDs registered by clients connected to the node. In one embodiment the hash table associates each object ID with a linked list containing one entry for each client that has registered for that object ID. Each entry in the linked list preferably contains a pointer to a socket representing the connection to the corresponding client . As is known in the art the pointer to the socket typically called a file descriptor represents an address to which the node can write in order to send the message to the corresponding client. Preferably the node adds to the hash table and or linked list every time a client registers an interest in an object and deletes the corresponding entry from the hash table and or linked list when the client disconnects from the node or otherwise indicates that it is no longer interested in a particular object.

Alternative embodiments utilize other data structures in addition to or instead of the hash table and linked list and or may utilize different data within the data structures. For example one embodiment of the routing network has a hierarchy of nodes within each cluster . Different nodes in the hierarchy may handle messages received from certain input sources or process messages sent to different clients . In this embodiment the linked lists may point to nodes lower in the hierarchy instead of to sockets leading to the clients . Another embodiment lacks the node hierarchy yet assigns certain nodes to certain input sources or clients .

The application server within each node preferably serves the activation module to the clients in response to client requests. In addition the application server serves any other modules that may be required or desired to support the environment . In an alternative embodiment of the routing network a single application server fulfills all of the client requests. This application server may be within a certain cluster or independent of the clusters. However this single application server embodiment is less desirable because it lacks redundancy.

In one embodiment at least one of the nodes is in communication with the OSS in order to provide the update messages to the OSS. In another embodiment OSS functionality is provided by the node itself.

Preferably the routing network utilizes conventional single processor computer systems executing the Linux operating system OS . Preferably each component of the routing network is implemented by a separate dedicated computer system in order to enable the separate optimization of the components. The input output I O functionality of the OS is preferably enhanced through the use of a non blocking OS package such as NBIO available from the University of California Berkeley Calif. Based on the assumption that connections with the nodes are long lived the OS is preferably configured to not allocate resources toward monitoring idle connections. Instead the well known dev poll patch is preferably applied to the OS in order to provide advanced socket polling capabilities.

Moreover the TCP IP stack in the OS is preferably optimized in order to quickly output messages. In one embodiment the retransmit timer in the stack is reduced from 200 ms to 50 ms. This timer determines how long the stack waits for an acknowledgement ack that a sent packet was received. Due to the way the Linux kernel implements the retransmit timer the kernel will not send pending outbound packets even if the ack has been received until the initial retransmit timer has expired. Reducing the retransmit value minimizes the effect of this delay. If an ack is not received before the retransmit timer expires an embodiment increases the retransmit value for the affected TCP connection and the unacknowledged packet is retransmitted. In addition the TCP IP stack preferably utilizes Nagle s algorithm functionality to concatenate a number of small messages into a larger message thereby reducing the number of packets sent by the routing network .

The input handler preferably provides messages destined to be stored to a storage access module . The storage access module preferably reads writes and modifies update messages in a storage module . Preferably the storage module includes a conventional random access memory RAM for providing fast access to data stored therein. The RAM preferably includes a hash table or other data structure adapted to provide fast access to update messages for specified object IDs. Accordingly the storage access module is preferably adapted to apply a hashing function to object IDs in order to quickly locate entries for the object IDs in the storage module . In one embodiment the storage module includes a conventional magnetic memory for storing update messages in addition to or instead of the RAM and or utilizes a conventional database in addition to or instead of the hash table.

In one embodiment the input handler storage access module and or storage module are adapted to store update message histories. For example the OSS can controllably store the last X update messages for one or more objects. The message histories may be useful for error recovery testing and or accounting purposes. Similarly in one embodiment the input handler storage access module and or storage module are adapted to support time to live TTL functionality. TTL specifies how long a specified update message should be deemed valid and stored by the OSS . Thus an input source can use TTL functionality to ensure that the OSS does not store and provide stale update messages.

A client handler module preferably interacts with the storage access module and the clients . In one embodiment the client handier module receives the object data from a client extracts the object IDs and provides the object IDs to the storage access module . The storage access module in turn provides the update messages for the identified objects to the client handler which then sends the update messages to the client .

In one embodiment the client handler also performs authentication and authorization to ensure that only authorized clients receive update messages from the OSS . In one embodiment the clients present credentials such as login password pairs to the client handler . In another embodiment the authentication performed by the client handler relies at least partly upon the authentications between the clients and the nodes . For example in one embodiment a node gives a token to the authenticated client that the client presents to the client handler .

The above description is included to illustrate the operation of the preferred embodiments and is not meant to limit the scope of the disclosure. The scope of the disclosure is to be limited only by the following claims. From the above discussion many variations will be apparent to one skilled in the relevant art that would yet be encompassed by the spirit and scope of the disclosure.

