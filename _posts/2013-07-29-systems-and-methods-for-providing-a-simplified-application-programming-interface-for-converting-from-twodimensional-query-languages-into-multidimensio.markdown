---

title: Systems and methods for providing a simplified application programming interface for converting from two-dimensional query languages into multi-dimensional query languages to query multi-dimensional data sources and MDX servers
abstract: Apparatus and methods are provided for querying OLAP data sources and other MDX servers utilizing a two-dimensional query language. Aspects of the apparatus and methods receive a query written in a two-dimensional query language, such as LINQ, convert the query into a query compatible with a multi-dimensional query language, such as MDX, and employ the converted query to query the OLAP data source.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09355143&OS=09355143&RS=09355143
owner: 
number: 09355143
owner_city: 
owner_country: 
publication_date: 20130729
---
This application claims the benefit of the filing date of U.S. provisional patent application No. 61 676 998 entitled Simplified LINQ Query API Process of Translation from LINQ and Other Two Dimensional Query Languages into Multidimensional Query eXtensions MDX Query Language Object Multidimensional Mapping which was filed on Jul. 29 2012 by the same inventor of this application. That provisional application is hereby incorporated by reference as if fully set forth herein.

The invention relates generally to computer based query languages and more particularly to the conversion of a two dimensional query language such as Language Integrated Query LINQ into a query language for multi dimensional Online Analytical Processing OLAP such as Multi Dimensional eXpressions MDX .

In computing online analytical processing or OLAP is an method for answering multi dimensional analytical queries swiftly. Typically OLAP is employed for ad hoc queries and business reporting such as sales reports marketing management reports budgeting financial reporting etc. The basic element of an OLAP system is an OLAP or multi dimensional cube data source . It is made up of facts called measures which are categorized by dimensions. Measures are derived from the records in the fact table and dimensions are derived from the dimension tables. Measure Group in SSAS corresponds to a set of measure columns from a fact transactional table in its relational data source. Measure in an SSAS cube corresponds to a not key column in a fact transactional table in its relational data source. Measure column is typically of some numeric type. Dimension in an SSAS cube corresponds to a reference dimensional table in its relational data source. Dimension Attribute in an SSAS cube corresponds to either a column in a reference dimensional table or to a foreign key or date time column in a transactional fact table in its relational data source. Dimension Attributes are quite often of string or date time type.

Measure Property a property of a class or column of a table or a cube measure suitable for aggregation functions.

Dimensional Property a property of a class or a column of a table or a cube dimensional attribute most often used as a grouping or sorting joining identifying key.

OLAP tools enable users to analyze multi dimensional data interactively from multiple perspectives using three basic analytical operations consolidation roll up drill down and slicing and dicing. Consolidation involves the aggregation of data in one or more dimensions. For example all sales offices of a company are combined to forecast future sales. Drill down is more granular and enables examination of the details. For example the sales of a product are collected for a particular area. Slicing and dicing allows taking out slicing a specific set of data from the OLAP cube and examining dicing the slices from different viewpoints.

MDX which was introduced by Microsoft is a powerful query language that can be used to query multidimensional OLAP data sources and other MDX servers such as SSAS Multidimensional SSAS Tabular and Essbase. But MDX is a difficult language to master and thus it is difficult for the average programmer to write error free code. It is also difficult to employ for unit testing and refactoring due to a lack of tooling support. MDX is verbose when it comes to dimensional attribute and measure references specification and it does not support Object Oriented Programming OOP . Additionally MDX queries cannot be reused for data sources that do not support MDX like relational databases or in memory objects. When MDX is used to query data from .NET applications developers have to add plumbing code e.g. low level code that bridges between the application and lower layers to convert query parameters to MDX fragments and to convert query results from ADOMD.NET format into .NET object graphs.

For example creating a reporting web application in .NET using conventional techniques would require the following steps 

1. A developer creates classes and other data structures together with calculation and data verification cleaning logic in .NET domain layer .NET environment 

2. A developer creates dynamic reporting layouts that may handle user actions like mouse clicks for data drill down in ASP.NET Web forms in ASP.NET MVC or in Silverlight .NET environment presentation layer 

3. A developer typically a different developer since very few developers know both MDX and .NET well enough creates parameterized MDX queries that filter join aggregate and sort data according to parameters or builds non parameterized MDX queries dynamically from .NET method parameters and embeds these queries as strings into .NET code data access layer MS SQL Server Analysis Services environment 

4. A developer writes code that submits embedded MDX query strings into ADOMD.NET command passes all parameters into that command and executes it and 

5. A developer writes code that marshals the results of ADOMD.NET command execution step 4 that are in a form of ADOMD.NET flattened record sets into a composition of associated .NET objects designed at step 1.

LINQ which is a Microsoft .NET Framework component that adds data querying capabilities to .NET languages does not suffer from the same issues as MDX but in its present form LINQ cannot be used to query OLAP data sources and other MDX servers such as SSAS and Essbase. LINQ also requires specification of aggregations groupings sorting and joins in each query. Such requirements complicate LINQ queries slow down LINQ learning adoption query development and testing and make LINQ queries more fragile to design changes.

In view of the foregoing it would be advantageous to provide an improved query language. It would further be advantageous to provide such a query language that may be employed to query OLAP data sources and other MDX servers. It would be still further advantageous to provide such as query language that is relatively simple to learn and which is less prone to errors when coding. It would also be advantageous to provide such a query language that allows a single developer to perform steps 1 3 above without the developer having to perform steps 4 and 5.

Many advantages of the invention will be determined and are attained by the invention which in a broadest sense provides a two dimensional query language that can operate to query multi dimensional OLAP data sources and other MDX servers. It provides users the ability to employ simple semantics of two dimensional relational query languages like LINQ or SQL together with the power of implicit data aggregation sorting and joins of multidimensional query languages like MDX. Also users will be able to use a wider range of reporting tools application frameworks and UI .NET components that do not support OLAP cubes and MDX servers directly but can work with LINQ e.g. ActiveReports XtraReports Visual Studio LightSwitch WCF Data Services and OData Web API services ASP.NET LinqDataSource and ObjectDataSource ASPxGridView in LINQ Server Mode .

One or more embodiments of the invention provide an apparatus configured to retrieve data from an OLAP data source. The data source having associated meta data. The apparatus includes a computing device in electrical communication with a network. The apparatus also includes an API configured to operate within the computing device and configured to receive a two dimensional query written in a two dimensional query language. The computing device is configured to convert the two dimensional query into a multi dimensional query that is compatible with a multi dimensional query language. The computing device is also configured to retrieve from the data source data responsive to the multi dimensional query.

One or more embodiments of the invention also provide a method of retrieving data from an OLAP data source where the data source has associated meta data. The method includes providing a computing device that selectively communicates with a network. The method further includes providing an API operating on the computing device. The computing device receives as input via the API a two dimensional query formulated in a two dimensional query language. The computing device converts the two dimensional query into a multi dimensional query and employs the multi dimensional query to retrieve data from the data source and helps to convert the result recordsets into a graph of connected .NET objects entities 

The invention will next be described in connection with certain illustrated embodiments and practices. However it will be clear to those skilled in the art that various modifications additions and subtractions can be made without departing from the spirit or scope of the claims.

Referring to the drawings in detail wherein like reference numerals identify like elements throughout the various figures there is illustrated in a two dimensional query language that is capable of querying multi dimensional OLAP data sources and other MDX servers. While the following description will be limited to LINQ and MDX those skilled in the art will recognize that the invention is not so limited. The following description is equally applicable to any component tool or application that employs a two dimensional relational query language similar to LINQ or Structured Query Language SQL which is converted into multi dimensional query language similar to MDX. One skilled in the art will understand from this disclosure how to apply the disclosed methods to these other component s tool s and or application s without undue experimentation.

Aspects of the invention provide the following general features 1. a LINQ Application Programming Interface API is modified to simplify the creation of LINQ queries simplified LINQ queries interchangeably referred to herein as Simple Dimensional eXtension SDX or LINQ and to make LINQ more compatible with querying OLAP and other data sources 2. a LINQ query is translated converted into a MDX query and 3. methods are provided for designing and implementing Object Multidimensional Mapping OMM components that translate one or more LINQ queries into one or more MDX queries pass the generated MDX query into an ADOMD.NET component for execution in a binary coded operating device takes result data from ADOMD.NET and converts it from ADOMD.NET format into .NET and ADO.NET Entity Framework format and returns results compatible with expectations of LINQ and ADO.NET Entity Framework. As an aside OMM is similar to Object Relational Mapping ORM but maps objects and single dimensional relational languages to multidimensional results and languages.

Using some or all of the above features users who create new applications reports and queries will be able to create queries to multi dimensional OLAP data sources and MDX servers using SDX LINQ and any language supported by .NET and by using data returned by such queries in .NET applications and reports. Applications will be able to execute LINQ queries consume the data returned by such queries and may act upon the results of these queries. Thus in contrast to the example presented in the background section above a reporting web application in .NET could be created using the invention by the following steps 

1. A developer creates classes and other data structures together with calculation and data verification cleaning logic in .NET domain layer .NET environment 

2. A developer creates interactive reporting layouts that may handle user actions like mouse clicks for data drill down in ASP.NET Web forms in ASP.NET MVC or in Silverlight presentation layer .NET environment and 

3. A developer creates LINQ queries that filter join aggregate and sort data. The developer does not need to create and populate parameters or embed LINQ queries as strings into .NET code because LINQ is integrated into .NET data access layer .NET environment . Further the developer does not need to write code for steps 4 5 in the background example since this work is handled by the SSAS Entity Framework Provider component and Microsoft ADO.NET Entity Framework. Thus development and testing work and time are saved. Further step 3 can be performed by the same developer since it is common for .NET developers to also know LINQ which is part of .NET .

The above aspects are preferably implemented as a computer program stored on a computer which causes the computer to function as a data retrieving system for retrieving data stored on cubic or tabular data structures in locally or remotely located MDX servers accessible over the Internet or some other compatible network without utilizing MDX as an API. The program is executed on a Windows operation system OS this limitation is imposed by the fact that Microsoft ADOMD.NET is currently only existing for Windows OS. If this changes in the future then this limitation will change accordingly . The program causes the computer to execute LINQ to achieve one or optionally more of joining grouping aggregating filtering and or sorting data. The program utilizes SDX dialect of LINQ along with metadata of the cubic data structures and MDX servers so that aggregation joining and grouping operators of LINQ are optional rather than required thereby enabling the reduction simplification of standard LINQ queries.

The following illustrates an example of how to simplify the LINQ API and make LINQ more useable for querying OLAP and other data sources.

Simplify Aggregations in a LINQ Query Make implicit aggregations aggregate all Measure Properties listed for projection in a select clause even if no aggregation functions are explicitly specified in a query. A more detailed explanation of the process for determining Measure Properties suitable for aggregation among all projected properties listed in Select will be set forth later in this disclosure. In order to determine a kind of an aggregation function specify it in metadata outside of a query e.g. in a cube metadata file or .Net manifest as attributes . If a kind of an aggregation function is indicated explicitly somewhere in a LINQ query use all regular LINQ conventions for the aggregation of those Measure and or Dimensional Properties with an explicit aggregation function. Aggregate all other Measure Properties implicitly. If a kind of an aggregation function is not specified anywhere neither in metadata nor in a query use Sum as a default.

Simplify Group By section in a LINQ Query Make implicit groupings group results of queries by default even if there is no group . . . by section or GroupBy extension method explicitly specified in a query. When group . . . by is missing in a query use all Dimensional Properties specified in a projection part of a query as grouping keys. A more detailed explanation of the process for determining what projection properties columns are suitable for grouping will be set forth later in 0030 of this disclosure. If an explicit group . . . by clause is present in a LINQ query use all standard LINQ conventions for grouping.

Simplify orderby clause in a LINQ Query Sort query results containing Dimensional Properties implicitly sort query results by default even if there is no explicit orderby keyword and OrderBy extension method in a query. If orderby clause is not present in a LINQ query sort by all Dimensional Properties included into projection select clause of a query by either select keyword or Select extension method. A more detailed explanation of the process for determining what projection properties columns should be used as Dimensional Properties sort keys when both orderby keyword and OrderBy extension method are missing will be set forth later in this disclosure. If there are multiple sort keys in a query sort them in the same sequence in which Dimensional Properties columns are specified in a query. If an explicit orderby clause is present in a LINQ query first sort explicitly indicated properties columns using all standard LINQ conventions for sorting then also sort all other Dimensional Properties implicitly.

Simplify joins in a LINQ Query Make joins implicitly join query results even if there is no explicit join keywords or extension methods in a query. Allow to specify a query like it is a cross join e.g. by using multiple from . . . without corresponding join but instead of returning a Cartesian product in such a case return a normal joined Recordset using default join conditions specified in metadata outside of a query e.g. in a cube definition database keys and constraints class associations .Net manifest or metadata file . Thus instead of having to repeat each join condition specification in each query SDX allows the specification of joins only once in metadata outside of queries. It also enables the writing of very simple queries for several related entities with no navigational properties. Thus users can reduce coupling between entities classes they query by removing some or all of the navigational properties associations from the entities without impacting query complexity. If an explicit join clause is present in a LINQ query use all standard LINQ joining rules for that specific join but all other entities should still be joined with implicit default join conditions specified in metadata. If there is no metadata about joins is present return a cross join Cartesian product .

Using LINQ with languages other than LINQ in the same single query Introduce a new set of methods extension methods or operators that allow insertion of query fragments written in non LINQ query languages e.g. MDX SQL with an intention to return either Recordsets or scalar values.

The following illustrates an example of how to translate covert from LINQ to MDX. Differentiating between Measure Properties and Dimensional Properties Either reserve and use separate data types for Measure Properties e.g. Double and Decimal only or new special custom types class or struct or specify Measure Properties in metadata outside of a query e.g. list of measures in OLAP cube metadata list of Measure Properties in a file or class properties marked with special attributes like MeasurePropertyAttribute metadata in .Net manifest . Consider all non Measure properties to be Dimensional properties.

Alternatively reserve data types for Dimensional Properties e.g. String and Integer or new custom types or specify all Dimensional Properties in metadata outside of a query e.g. list of cube dimensions and dimensional attributes list of primary and foreign keys of a table list of dimensional properties in a file or properties marked with a special attribute like DimensionalPropertyAttribute . Consider all non Dimensional Properties to be Measure Properties.

Converting a LINQ query where projection properties columns can be specified in any order into a MDX query which employs multiple axes and limits a sequence in which measures and dimensions have to be specified Both LINQ to Entities and SQL queries internally return Recordsets where each row contains columns for both Dimensional and Measure Properties in the same sequence specified in a query projection LINQ select clause . Measures can be mixed with dimensions in any order in the same single row. There is no distinction between Dimensional and Measure Properties in standard LINQ and SQL languages. MDX however is a multidimensional query language that does not allow mixing dimensional attributes and measures in the same result row in any arbitrary sequence discussed further below . A typical MDX query employs 2 separate axes ON COLUMNS axis 0 and ON ROWS axis 1 . ON COLUMNS axis is mandatory if someone needs to query non default measures. There is no exact equivalent for ON COLUMNS axis in LINQ or SQL.

The above issue is resolved by aspects of the invention as follows i users are allowed to specify both Dimensional and Measure Properties in LINQ or SQL like queries in any order as they did before ii when converting a query in LINQ or SQL into a query in MDX or similar language Measure Properties are always put into ON COLUMNS axis of the query regardless of an order of respective properties columns in LINQ select clause but associated with an original position of a Measure Property in LINQ select clause iii Dimensional Properties columns are always put into ON ROWS axis when translating into MDX but associated with an original position of a Dimensional Property in LINQ select clause and iv never use any axis other than WHERE ON COLUMNS and or ON ROWS when translating into MDX. v At this point generated MDX can execute but it returns all Dimensional Properties on the left side and all Measure Properties on the right side of the result Recordset. An Object Multidimensional Mapping component should rearrange a sequence of columns in a result Recordset according to the order specified in the original select clause of a query in LINQ or SQL. That original order is tracked during steps iii and iv . If v is omitted LINQ or SQL semantics would change and LINQ provider would throw an exception when converting the result Recordset into .Net objects entities . A further description of this solution extended with design and implementation details specific to ADOMD.NET and ADO.NET Entity Framework is set forth later in this disclosure.

While not preferred the following are possible alternative ways to address the issue of mixing Measure Properties with Dimensional Properties which would still fall within a scope of the invention. Users could specify all Dimensional Properties before any Measure Properties in all of their LINQ queries. Drawbacks to this solution are that it would be difficult to catch errors before run time and it is difficult to always separate Dimensional Properties from Measure Properties. Another possible solution would be to specify measures mixed with dimensional attributes in MDX queries by putting all of them onto a single ON ROWS axis using the MDX CrossJoin function. However such a solution would return a Recordset with a different cardinality from what is expected by LINQ or SQL query semantics. MDX query would return a new row for each new measure specified. LINQ provider would throw an exception when converting the result Recordset into .Net objects. Mapper design pattern or other similar solution could re map un pivot related measures scattered in multiple rows back to a single row with multiple measures but such a solution would have an adverse impact on performance.

Converting a LINQ query that returns both Dimensional and Measure Properties into a MDX query while preserving existing LINQ and SQL implied relational filtering semantics The following explains how to return a Recordset containing only such a combination of Dimensional and Measure Properties that relate to each other in a cube data sources. It also explains how to filter out properly null valued cross join combinations of dimensions and measures without filtering out records with measures that do exist in an underlying fact table but have null values.

Default MDX behavior in SSAS and other MDX OLAP servers is to return a Cartesian product of all permutations between different dimensions and measures including combinations that do not exist in a cube relational data source e.g. do not make logical sense . SSAS will return results with NULL values for those combinations that do not exist. A typical solution used by other MDX generation tools is to apply NON EMPTY keyword. While that solution limits the result Recordset to those combinations of dimensions and measures that are actually present in a cube relational data source it has a tendency to also filter out null measure values that do exist in the data source. This total filtering of all null values is a different behavior from semantics in LINQ SQL and other relational query languages. Such null filtering behavior may distort the results and sometimes it is useful to know what measures have null values.

Aspects of the invention employ the EXISTS MDX function with 3 parameters where the 3rd parameter is a name of a measure group which should be referenced by selected dimensions. Such a solution preserves relational query languages semantics does not distort the results and works faster. If a LINQ query queries multiple measure groups a separate EXISTS function should be used per each measure group and EXISTS functions should be nested into each other. Second argument of each EXISTS function may refer to a set of measures from a measure group mentioned in a third argument.

Matching columns from MDX result recordset with column names following DimensionName . HierarchyName . LevelName pattern to LINQ or SQL result column names following ColumnName pattern Use positional binding generate a dimensional attribute name or a measure name in MDX query in the same relative position where a matching LINQ Dimensional or Measure Property was specified by LINQ select clause. Typically 2 separate axes will be used in a generated MDX query but the result Recordset has a shape of a regular table and a solution for this problem is described above i v . A specific design and implementation details will be described more fully below.

The following is a non limiting example using the above techniques and features to convert translate from LINQ SDX to MDX 

Design and Implementation Considerations for Object Multidimensional Mapping Component and LINQ to MDX Translation with SSAS Entity Framework Provider as an Example Converting a LINQ query where projection properties columns can be specified in any order into MDX query which employs multiple axes and limits a sequence in which measures and dimensions have to be specified.

As stated above both LINQ and SQL queries return Recordsets where each row contains columns for both Dimensional and Measure Properties in a sequence specified by a query projection LINQ select clause . Measures can be mixed with dimensions in any order in the same single row. There is even no distinction between Dimensional and Measure Properties in a standard LINQ and SQL languages. But MDX does not allow such behavior. Someone has to specify all Dimensional Properties in ON ROWS axis and Measure Properties in ON COLUMNS axis in a MDX query in order to get all specified properties in the same single row. However such action results in a Recordset where all Dimensional Properties are returned on the left side of the Recordset and all Measure Properties are on the right side. If someone issued a LINQ query similar to the following 

As stated above a possible solution would be to specify all Dimensional Properties before any Measure Properties in all LINQ queries but that solution would be difficult to follow because it would be difficult to realize errors before run time and it is difficult to remember what properties are Dimensional Properties and what are Measure Properties.

Another solution is to put both Dimensional and Measure Properties into a single ON ROWS axis using CrossJoin MDX function and put any member from All level of any attribute hierarchy into ON COLUMNS axis. Note if ON COLUMNS axis is left empty no measure values will be returned only measure captions . Such MDX query will execute and return multiple rows one per each measure with a single measure value per single row. But LINQ provider e.g. Entity Framework expects multiple related measures in the same row. In order to avoid an error in a LINQ provider when it tries to populate object graph entities from MDX result Recordset a class extending AdomdDataReader e.g. SsasDataReader P of should re map multiple rows with a single measure value into a single row with multiple related measures expected by a LINQ provider e.g. by ADO.NET Entity Framework before returning the result Recordset back to a LINQ provider. A good implementation is to use Mapper design pattern to do that kind of re mapping.

Translating .NET variables and method parameters in LINQ where clause into MDX members and MDX filter function values This can be done in 3 steps 

1. When overriding DbProviderServices.CreateDbCommandDefinition add parameters to a result DbCommand per each parameter expression of DbParameterReferenceExpression type from commandTree.Parameters collection of commandTree input parameter. Names of DbCommand parameters should match with keys in DbCommandTree.Parameters dictionary. Do not assign parameter values for parameters in DbCommand. Do not use for parameters in DbCommand.

2. When generating MDX translate DbParameterReferenceExpression.ParameterName into a parameter value placeholder named as a parameter. e.g. if parameter name is p linq country translate it into 

3. In SsasCommand replace the named parameter value placeholder with the actual parameter value before MDX is executed. Entity Framework will populate parameters in SsasCommand.Parameters with their values before SsasCommand is executed.

Data and control flow for replacing parameter placeholders with respective values is almost the same as for passing MdxColumnOrder mapping from MdxGenerator to SsasCommand steps shown on left part of . The difference is that MdxSelectStatement P and ColumnOrderTracker P are not involved and there is no need in out parameter and additional properties when passing named parameter placeholders from MdxGenerator P to SsasCommand P because parameter placeholders are passed into SsasCommand P as parts of generated MDX string.

Converting a LINQ query that does not have measure properties among projected properties in it its select clause into MDX ADOMD.NET can execute an MDX query that has an empty set in ON COLUMNS axis but it will not return values of Measure Properties in such a case it will return only measure captions. To resolve this issue the program generates a dummy calculated member with any fake value and puts that calculated member into ON COLUMNS axis.

WITH MEMBER Measures . Dummy AS NULL SELECT Customers . Company Name . Company Name ON ROWS Measures . Dummy ON COLUMNS FROM NorthwindEF 

Constants that are generated by Entity Framework in a command tree Entity Framework sometimes generates constants in the command tree which is an input to MDX generation component e.g. MdxGenerator P . Typically the constant looks like a column named Cx e.g. C and that constant s value is 1 . Regardless that MDX generation component does not need or use that constant value LINQ to MDX generation and MDX query execution components cannot entirely ignore that constant. Entity Framework expects the constant value to be returned as a result of LINQ query and if that constant is missing in the result Recordset Entity Framework throws an error. To resolve this issue a Extend AdomdDataReader class e.g. SsasDataReader P to return a constant value 1 in place of original Cx constant. MDX generation component MdxGenerator P should supply a position of that constant into extended AdomdDataReader e.g. SsasDataReader P and the extended AdomdDataReader returns 1 whenever the position of a constant Cx is requested. b MDX generation component generates a calculated member measure with a constant value 1 in a position corresponding to that constant. In such a case AdomdDataReader just returns the value from Cx column as is without any manipulations with the result Recordset.

Supplying a cube name into MDX query generated by MDX generation component of a LINQ provider ADO.NET Entity Framework does not supply a cube name into SQL or MDX generation classes it provides them with a command tree only. Neither the command tree nor an original LINQ query contains anything related to a cube name. But a MDX query must specify a correct cube name in it s FROM clause in order to be executed successfully. A resolution to this issue is to save a cube name into a shared persistent storage like connection string in an application configuration file and read that cube name from that storage later during each MDX generation. Another resolution to this issue which also works with dynamically supplied cube names is to extend AdomdConnection class e.g. SsasConnection P with a new property for a cube name e.g. SsasConnection.CubeName and assign a cube name to that property before running LINQ query. But in this case MDX generation component MdxGenerator P still does not have an access to that cube name. Thus MDX generation component should use a placeholder instead of a real cube name. Also AdomdDataReader class e.g. SsasDataReader P should be extended with a behavior that reads cube name from an instance of an extended connection class e.g. from SsasConnection.CubeName and replaces cube name placeholder with a real cube name.

Associating a Dimensional Property name in LINQ query with a cube dimension name in MDX query in order to generate an MDX query with a fully qualified dimensional attribute following DimensionName . HierarchyName . LevelName MDX Pattern LINQ query references only class names and their property names. There is no reference to a dimension name in LINQ. The following illustrates how to get a dimension name when generating MDX.

A simple solution would be to generate MDX with dimensional attribute references without a corresponding dimension name. But this solution will not work if there are properties with the same name but belonging to different classes and dimensions in the same LINQ query. Also a MDX query that misses dimension names in its dimensional attribute references will execute slower.

A better solution is to use some form of persistent metadata in order to map a name of a class owner of a dimensional property to a dimension name persist and reuse that metadata mapping during MDX generation. The following are some non limiting examples of how to map properties to dimensions and how to store those mappings in metadata 

a. Use .NET attributes taking dimension name as a parameter and persisting that information into .NET manifest.

c. Use some class naming convention for instance a convention when name of a class coincides with a dimension name.

SSAS Entity Framework Provider can use any of these approaches because it reuses naming conventions mapping attributes or XML mappings used by ADO.NET Entity Framework infrastructure. Entity Framework associates table name with a class by means of any of these techniques and SSAS Entity Framework Provider takes a table name from Entity Framework and uses it as a dimension name optionally using AddSpacesToCamelCasingWordsConvention naming convention to convert a table name like SomeName into a dimension name like Some Name .

Thus it is seen that a two dimensional query language that can operate to query multi dimensional OLAP data sources and other MDX servers is provided. Although particular embodiments have been disclosed herein in detail this has been done for purposes of illustration only and is not intended to be limiting with respect to the scope of the claims which follow. In particular it is contemplated by the inventor that various substitutions alterations and modifications may be made without departing from the spirit and scope of the invention as defined by the claims. For example the system is described as being set up as a program running on a computer that communicates over the Internet local area network or inter process channels with a data source. However the system could also function with multiple computers and or servers configured to perform the various operations and or communications could take place via a network other than the Internet. Other aspects advantages and modifications are considered to be within the scope of the following claims. The claims presented are representative of the inventions disclosed herein. Other unclaimed inventions are also contemplated. The inventors reserve the right to pursue such inventions in later claims.

Insofar as embodiments of the invention described above are implemented at least in part using a computer system it will be appreciated that a computer program for implementing at least part of the described methods and or the described systems is envisaged as an aspect of the invention. The computer system may be any suitable apparatus system or device electronic optical or a combination thereof. For example the computer system may be a programmable data processing apparatus a computer a Digital Signal Processor an optical computer or a microprocessor. The computer program may be embodied as source code and undergo compilation for implementation on a computer or may be embodied as object code for example.

It is also conceivable that some or all of the functionality ascribed to the computer program or computer system aforementioned may be implemented in hardware for example by one or more application specific integrated circuits and or optical elements. Suitably the computer program can be stored on a carrier medium in computer usable form which is also envisaged as an aspect of the invention. For example the carrier medium may be solid state memory optical or magneto optical memory such as a readable and or writable disk for example a compact disk CD or a digital versatile disk DVD or magnetic memory such as disk or tape and the computer system can utilize the program to configure it for operation. The computer program may also be supplied from a remote source embodied in a carrier medium such as an electronic signal including a radio frequency carrier wave or an optical carrier wave.

It is accordingly intended that all matter contained in the above description or shown in the accompanying drawings be interpreted as illustrative rather than in a limiting sense. It is also to be understood that the following claims are intended to cover all of the generic and specific features of the invention as described herein and all statements of the scope of the invention which as a matter of language might be said to fall there between.

