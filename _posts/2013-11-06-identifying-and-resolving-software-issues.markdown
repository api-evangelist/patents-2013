---

title: Identifying and resolving software issues
abstract: Technologies are described herein for use in identifying and resolving software issues. One or more corrective actions may be identified and taken that are based upon the similarity between an unresolved issue and one or more resolved issues and/or upon the similarity between code changes made to resolve similar previously resolved issues. A version control graph might also be utilized to determine if a change made to resolve an issue in one branch of a software component is applicable to another branch of the software component. The version control graph might also be utilized to compute the relevance of an entry in an issue tracking system for an issue at a point in time after the entry is created in the issue tracking system.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09430359&OS=09430359&RS=09430359
owner: Amazon Technologies, Inc.
number: 09430359
owner_city: Seattle
owner_country: US
publication_date: 20131106
---
Software developers commonly utilize many different types of tools during the development of a software application. For example software developers might utilize tools for editing source code and for compiling the source code into executable code. In addition to these tools software developers might also utilize other types of utility programs to assist with the development of an application. For example a developer might utilize a version control system VCS to manage changes made to the source code and other components of the application.

In addition to a VCS software developers might also utilize various software development workflow systems to manage the workflow of program development. For example a developer might utilize an issue tracking system to track issues which might also be referred to as defects or bugs within the program being developed. A developer might also utilize other software development workflow systems in conjunction with the development of a program.

Even using the various tools described above the identification and resolution of issues present within software components can be an extremely difficult and often labor intensive process. It is with respect to these and other considerations that the disclosure made herein is presented.

The following detailed description is directed to various technologies for use by a developer in resolving software issues. In particular technologies are provided for investigating an unresolved software issue and for taking one or more corrective actions based upon the results of the investigation. The investigation may include identifying changes made to resolve a previously resolved issue that is similar to the unresolved issue. The investigation might also include identifying similar changes made to resolve similar previously resolved issues. The results of the investigation may be utilized to take one or more corrective actions. For example and without limitation the corrective actions may include providing a notification to a developer identifying the changes made to resolve similar previously resolved issues assigning the unresolved issue to a developer such as the developer that resolved a similar previously resolved issue in an issue tracking system or the developer that created the entry for the previously resolved issue generating a commit to the unresolved issue with the changes made to resolve the previously resolved issue and or performing one or more automated tests to determine if the changes made to resolve the previously resolved issue also resolve the unresolved issue. Other corrective actions might also be performed. Additional details regarding this mechanism are provided below with regard to .

Technologies are also provided for determining if a change made to resolve an issue in one branch of a software component is applicable to another branch of the software component. In order to provide this functionality a version control graph is maintained that identifies relationships between different branches of a software component. For example the version control graph might identify linear sequences of changes of the software component. The version control graph may be utilized to determine when a change made to a first branch of the software component to resolve an issue may be applicable to a point in a second branch of the software component. If the change to the first branch of the software component is determined to be applicable to the second branch the change may be automatically applied to the second branch an entry might be created for the issue on the second branch in an issue tracking system and or other types of actions might be taken. If the change to the first branch of the software component is not applicable to the second branch an entry in an issue tracking system for the issue that is associated with the second branch might be closed if present and or other types of actions might be taken. Additional details regarding this mechanism are provided below with regard to .

Technologies are also provided for calculating the relevance of an entry which might be referred to herein as a defect report for an issue in an issue tracking system at a point in time after the entry is created. In order to provide this functionality an entry is created in an issue tracking system for an issue identified in a software component. Additionally one or more locations e.g. files or ranges of source code lines in the software component are associated with the entry in the issue tracking system. In order to determine the relevance of the entry at a point in time after the entry is created one or more changes made to the locations associated with the entry after the creation of the entry are identified and evaluated. A version control graph maintained by a version control system might be utilized to identify the changes. A staleness score is then computed based upon the type of changes made to the locations in the software component following the creation of the entry for the issue. The staleness score provides a measure of the relevance of the entry in the issue tracking system at a point in time after the entry was created. Various functions may then be performed based upon the staleness score such as but not limited to removing the entry from the issue tracking system if the staleness score meets a threshold value modifying the locations associated with the entry in the issue tracking system initiating an evaluation of the entry providing a user interface for presenting the staleness score and or modifying a priority associated with the entry in the issue tracking system. Additional details regarding this mechanism are provided below with regard to .

It should be appreciated that the subject matter presented herein may be implemented as a computer process an electronic computer controlled apparatus a computing system or an article of manufacture such as a computer readable storage medium. These and various other features will become apparent from a reading of the following disclosure and a review of the associated drawings.

While the subject matter described herein is presented in the general context of program modules that execute on one or more computing devices those skilled in the art will recognize that other implementations may be performed in combination with other types of program modules. Generally program modules include routines programs components data structures and other types of structures that perform particular tasks or implement particular abstract data types. Moreover those skilled in the art will appreciate that the subject matter described herein may be practiced on or in conjunction with other computer system configurations beyond those described below including multiprocessor systems microprocessor based or programmable consumer electronics minicomputers mainframe computers handheld computers personal digital assistants cellular telephone devices electronic book readers special purposed hardware devices network appliances and the like. The embodiments described herein may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment program modules may be located in both local and remote memory storage devices.

In the following detailed description references are made to the accompanying drawings that form a part hereof and that show by way of illustration specific embodiments or examples. The drawings herein are not drawn to scale. Like numerals represent like elements throughout the several figures.

As discussed briefly above a VCS provides functionality for managing changes made to source code files and other types of files associated with a program referred to herein as software components . One specific example of a VCS is the GIT open source distributed version control and source code management system. The VCS may store the software components in a VCS data store which might also be referred to herein as a source code repository. The VCS data store might also be utilized to store data describing changes that have been made to a software component maintained by the VCS . The VCS data store might also be utilized to store other types of data and or metadata regarding the creation and modification of a software component .

As shown in the VCS might also be utilized in conjunction with one or more other software development workflow systems such as an issue tracking system . As discussed briefly above the issue tracking system provides functionality for creating and managing entries for tracking issues that have been identified within a program being developed. For example and without limitation the issue tracking system might maintain an issue tracking data store for storing entries associated with issues that have been resolved in a software component referred to herein as resolved issue data and entries associated with issues that currently exist in a software component referred to herein as unresolved issue data .

The resolved issue data and the unresolved issue data include data describing various characteristics of resolved issues and unresolved issues respectively in software components maintained by the VCS . For example and without limitation the resolved issue data and the unresolved issue data might include data describing failed test cases associated with a resolved or unresolved issue one or more stack traces associated with a resolved or unresolved issue a human generated text description of a resolved issue or an unresolved issue and or data identifying one or more conditions under which a resolved issue or an unresolved issue occurs. The resolved issue data and the unresolved issue data might also include data and or metadata describing other characteristics of resolved issues and unresolved issues respectively in other embodiments.

The resolved issue data and the unresolved issue data also include data identifying the particular software component or components within the VCS in which the corresponding issue resides. Additionally and as shown in the resolved issue data might also identify one or more changes that were made in order to resolve an issue within a particular software component . For example and without limitation if certain lines of program code were modified in order to resolve an issue the resolved issue data for the issue might identify the particular lines of code in the software component that were modified in order to resolve the issue. Other types of changes that resolved an issue in a software component might also be identified in a similar manner. The resolved issue data and unresolved issue data might be stored in entries or defect reports maintained by the issue tracking system .

As described briefly above one embodiment described herein provides technologies for investigation an unresolved issue within a software component and for taking one or more corrective actions based upon the results of the investigation. An issue investigation system provides this functionality in one particular implementation. It should be appreciated however that the functionality described herein as being performed by the issue investigation system might also be performed by the VCS by the issue tracking system or by another component system or combination of systems altogether. In this regard it should also be appreciated that although a VCS and an issue tracking system have been illustrated in the embodiments disclosed herein might also be utilized with other types of software development workflow systems.

In one implementation the issue investigation system is configured to receive an investigation request . The investigation request is a request to perform an investigation for potential solutions to a particular unresolved issue maintained by the issue tracking system . The investigation request might be generated by a software developer and provided to the issue investigation system by way of an appropriate user interface UI through an application programming interface API or in another manner.

In response to receiving an investigation request the issue investigation system is configured to perform an investigation to identify changes made in order to resolve previously resolved issues that may be suitable for use in resolving the unresolved issue . The issue investigation system is also configured to take one or more corrective actions based upon the results of the investigation. For example and without limitation the issue investigation system might identify one or more changes in the VCS that were made in order to resolve issues that were similar to the unresolved issue identified in the investigation request . An investigation recommendation may then be transmitted to a developer e.g. an email message or other type of notification that identifies the changes. The developer can then investigate the changes identified in the recommendation as potential resolutions of the unresolved issue with the software component . The issue investigation system might also take other types of corrective actions which are described in greater detail below.

In order to perform the investigation described briefly above the issue investigation recommendation system obtains data describing the characteristics of the unresolved issue with the software component . For example and without limitation the issue investigation system might obtain unresolved issue data from the issue tracking system associated with the unresolved issue . As discussed briefly above the unresolved issue data might include but is not limited to failed test cases associated with the unresolved issue one or more stack traces associated with the unresolved issue a text description of the unresolved issue and or data identifying one or more conditions under which the unresolved issue occurs. Other types of data describing various characteristics of the unresolved issue might also be obtained from the issue tracking system and or from another system component or location.

The issue investigation system also obtains data describing the characteristics of one or more issues with the software component or with another software component that have been previously resolved. For example and without limitation the issue investigation system might obtain the resolved issue data from the issue tracking system for the software component and or for another software component. As discussed briefly above the resolved issue data might include but is not limited to failed test cases associated with resolved issues one or more stack traces associated with resolved issues test cases added in response to having resolved a resolved issue a text description of resolved issues and or data identifying one or more conditions under which resolved issues occurred. The resolved issue data might also identify for each resolved issue the change or changes which were made in order to resolve the resolved issue. Other types of data describing resolved issues might also be obtained from the issue tracking system and or from another system component or location.

The issue investigation system then utilizes the resolved issue data and the unresolved issue data to identify resolved issues that are similar to the unresolved issue . For example and without limitation the issue investigation system may compare some or all of the characteristics of the unresolved issue described above to the corresponding characteristics associated with previously resolved issues to compute a measure of the similarity between the unresolved issue and the resolved issues. In this way resolved issues can be identified that are similar to the unresolved issue . In some embodiments only resolved issues having at least a threshold level of similarity with the unresolved issue are identified and or considered further in the manner described below.

Once the issue investigation system has identified resolved issues that are similar to the unresolved issue the issue investigation system then identifies the changes that were made in order to resolve each previously resolved issue that is similar to the unresolved issue . In some embodiments the corrective actions taken by the issue investigation system are identified based upon these changes . In other embodiments however another measure of similarity is computed in order to identify the particular changes upon which corrective actions should be identified and taken. In particular in some embodiments the similarity is determined between each of the changes that were made in order to resolve each previously resolved issue that is similar to the unresolved issue . For example and without limitation the similarity between the changes might be determined based upon the files associated with an issue that were changed in order to resolve the issue the lines of program code that were changed in order to resolve an issue the changes made to resolve the issue software classes that were changed to resolve an issue and or the identity of the developer that resolved an issue.

Once the similarity between the changes that were made in order to resolve each previously resolved issue that is similar to the unresolved issue has been determined the issue investigation recommendation system might identify and take one or more corrective actions based upon the identified changes . For example and without limitation the issue investigation system might generate and provide a recommendation that identifies the changes that are similar to one another. The investigation recommendation might be provided as an email message by way of a Web page or in another manner.

In one implementation the issue investigation system might identify changes in the recommendation that have a similarity with one another that is greater than a certain pre defined threshold. The changes might also be ordered based upon their similarity with one another and or based upon the similarity between the unresolved issue and the resolved issues associated with the identified changes . As mentioned above a developer can then examine the changes identified in the recommendation as being possible resolutions to the unresolved issue .

In some embodiments one or more other unresolved issues that are similar to the unresolved issue and that have at least one associated change might also be identified and presented in the recommendation . In some embodiments the recommendation also identifies one or more changes made following a change that resulted in the resolution of an issue. In this way a developer can quickly identify changes made to a particular software component following the resolution of an issue within the software component . The developer may then utilize the identified changes in the investigation of the unresolved issue . Additional details regarding the mechanism described with regard to for investigating an unresolved software issue and for taking corrective action with regard to the unresolved software issue will be provided below with regard to .

The issue investigation system might also take other corrective actions with regard to the unresolved issue based upon the changes identified in the manner described above. For example the issue investigation system might annotate the unresolved issue in the issue tracking system with data identifying the changes that might be relevant to the unresolved issue . A developer can then access this information through the issue tracking system when working on the unresolved issue . The issue investigation system might also create an association in the issue tracking system between the unresolved issue and one or more other resolved or unresolved issues.

The issue investigation system might also transmit an issue assignment request to the issue tracking system in order to assign the unresolved issue to a particular developer. For example the issue investigation system might utilize data stored in the issue tracking data store to identify a developer that resolved a resolved issue that that is similar to the unresolved issue . That developer might then be assigned to the unresolved issue in the issue tracking system .

The issue investigation system might also generate a commit request to the VCS in order to commit the changes to a previously resolved issue to the unresolved issue . In this way changes identified as being relevant to an unresolved issue can be automatically committed in an attempt to resolve the unresolved issue . A developer might also be given an opportunity to approve the commit request before the commit occurs.

In some embodiments the application of a commit to an unresolved issue triggers an automated workflow for evaluating whether the commit resolved the unresolved issue . For example various types of tests may be performed in order to determine whether the changes identified in the manner described above solve the unresolved issue when committed. If the changes resolve the unresolved issue the changes may be kept. If the changes do not resolve the unresolved issue the changes may be rolled back. Various types of build time and runtime tests may be performed to determine whether a commit of the changes resolves the unresolved issue . It should be appreciated that various corrective actions identified above are merely illustrative and that other types of corrective actions might be taken in other implementations.

The implementation of the various components described herein is a matter of choice dependent on the performance and other requirements of the computing system. Accordingly the logical operations described herein are referred to variously as operations structural devices acts or modules. These operations structural devices acts and modules may be implemented in software in firmware in special purpose digital logic and any combination thereof. It should also be appreciated that more or fewer operations may be performed than shown in the FIGS. and described herein. These operations may also be performed in parallel or in a different order than those described herein. Some or all of these operations might also be performed by components other than those specifically identified.

The routine begins at operation where the issue investigation system receives an investigation request . As described above the investigation request identifies a particular unresolved issue for which an investigation should be performed and one or more corrective actions taken. The investigation request might provided to the issue investigation system by way of an appropriate UI through an API or in another manner.

From operation the routine proceeds to operation where the issue investigation system obtains data describing the characteristics of the unresolved issue with the software component . As discussed with regard to for example the issue investigation system might obtain unresolved issue data from the issue tracking system associated with the unresolved issue . The issue investigation system might also obtain other types of data describing various characteristics of the unresolved issue from another system component or location.

From operation the routine proceeds to operation where the issue investigation system obtains data describing the characteristics of one or more issues with the software component or with another software component that have been previously resolved. As discussed above for example the issue investigation system might obtain the resolved issue data from the issue tracking system for the software component and or for one or more other software components. The issue investigation system might also obtain other types of data describing resolved issues from another system component or location.

From operation the routine proceeds to operation where the issue investigation system utilizes the data obtained at operations and to identify resolved issues that are similar to the unresolved issue identified in the recommendation request . As discussed above for example the issue investigation system may compare some or all of the characteristics of the unresolved issue to the corresponding characteristics associated with previously resolved issues to compute a measure of the similarity between the unresolved issue and the resolved issues. In this way resolved issues can be identified that are similar to the unresolved issue . In some embodiments only resolved issues having at least a threshold level of similarity with the unresolved issue are identified and or considered further in the manner described below.

Once the issue investigation system has identified resolved issues that are similar to the unresolved issue the routine proceeds from operation to operation . At operation the issue investigation system identifies changes that were made in order to resolve previously resolved issues that are similar to the unresolved issue . These changes may be identified in an investigation recommendation in some embodiments. The changes might also be utilized when taking the other types of corrective actions described herein.

In some embodiments the routine proceeds from operation to operation where the issue investigation recommendation system computes the similarity between each of the changes identified at operation i.e. the changes that were made in order to resolve each previously resolved issue that is similar to the unresolved issue . As discussed above for example the issue investigation system might compute the similarity between the changes identified at operation based upon the files associated with an issue that were changed in order to resolve the issue the lines of program code that were changed in order to resolve an issue the changes made to resolve the issue software classes that were changed to resolve an issue the identity of the developer associated with an issue and or other metadata associated with an issue.

From operation the routine proceeds to operation where the issue investigation system may take one or more corrective actions based upon the changes identified above at operations and . For instance the issue investigation system might generate an investigation recommendation that identifies the changes that are similar to one another. The investigation recommendation might identify changes that have a similarity with one another that is greater than a certain pre defined threshold. The changes might also be ordered in the investigation recommendation based upon their similarity with one another and or based upon the similarity between the unresolved issue and the resolved issues associated with the identified changes . As discussed above the investigation recommendation might be provided to a developer by way of an email message a Web page a suitable UI an API call response or in another manner. The developer can then examine the changes identified in the investigation recommendation as being possible resolutions to the unresolved issue .

As also discussed above one or more other unresolved issues that are similar to the unresolved issue and that have at least one associated change might also be identified and presented in the recommendation . The recommendation might also identify one or more changes made subsequent to a change that resulted in the resolution of an issue. In this way a developer can quickly identify changes made to a particular software component following the resolution of an issue within the software component . The developer may then utilize the identified changes in the investigation of the unresolved issue .

As discussed above the issue investigation system might take other corrective actions in addition to or other than providing an investigation recommendation . For example and as discussed in detail above the issue investigation system might assign the unresolved issue to a developer that resolved a similar previously resolved issue in the issue tracking system might generate a commit request to commit the changes made to resolve the previously resolved issue to the unresolved issue and or might cause one or more automated tests to be performed in order to determine if the changes made to resolve the previously resolved issue also resolve the unresolved issue . Other corrective actions might also be performed. From operation the routine proceeds to operation where it ends.

Turning now momentarily to an illustrative version control graph will be described. As discussed briefly above the VCS might maintain a version control graph that identifies sequences of changes made to a software component . For instance in the example shown in the version control graph identifies a number of changes A G made to the software component . The version control graph also maintains data identifying the relationships between the changes A D. In the arrows between the changes A G represent these relationships. For example the arrow between the changes A and B indicates that a branch A was taken. The arrow between the changes B and C indicates that additional changes were made to the branch A. Similarly the arrow between the changes A and D indicate that a second branch B was created. An appropriate data structure or data structures might be utilized to store a representation of the changes and the branches .

In the example version control graph shown in the branch A has had one or more changes C made thereto that resolved an issue with the software component . For example and without limitation the changes C might be changes to source code contained in the branch A that resolved the issue . The issue tracking system might maintain an association between the changes C and the issue in the software component that was resolved by the changes C.

An automated mechanism is disclosed herein for determining whether a change or changes made to resolve an issue within one branch of the version control graph might also be relevant to another branch in the version control graph . For instance in the example shown in a determination is being made as to whether the changes C made to the branch A to resolve the issue are also applicable to the branch B. If the changes C are applicable to the branch B then the changes C might be automatically applied to the branch B an entry might be created in the issue tracking system associating the issue with the branch B and or other types of actions might be taken. If the changes C are not applicable to the branch B then an entry in the issue tracking system associating with issue with the branch B might be deleted if one exists and or other types of actions might be taken. Additional details regarding this process will be provided below.

Returning now to additional details will be provided regarding the mechanism disclosed herein for determining if changes made to resolve an issue in one branch of a software component are applicable to another branch of the software component . As shown in a branch tracking defect analysis system is configured in one implementation to provide the functionality disclosed herein for determining if changes made to resolve an issue in one branch of a software component are applicable to another branch of the software component . It should be appreciated however that this functionality might be provided by the VCS by the issue tracking system or by another component or system altogether.

In order to determine if one or more changes made to one branch of a software component are applicable to another branch of the software component the branch tracking defect analysis system might first receive the identity of changes that resolved an issue in one branch of the software component . For instance using the example version control graph shown in a user might identify the changes C to the branch A that resolved the issue . An appropriate UI API or other type of interface might be provided through which a user can specify the identity of the changes that resolved the issue . Alternatively the user might specify an issue that was resolved by the changes . The branch of the software component that contains the identified changes for resolving an issue may be referred to herein as the source branch. 

A user might also specify the identity of a location within another branch of the software component for which a determination is to be made as to whether the changes in the source branch are applicable. The user might be permitted to specify one or multiple branches for which such a determination is to be made. The branch of the software component for which a determination is to be made as to whether a change to another branch is relevant may be referred to herein as the target branch. An appropriate UI API or other type of interface might be provided through which a user can specify the identity of one or more target branches and specific locations in the target branches .

In order to determine whether a change to a source branch is applicable to a point within a target branch of the software component the branch tracking defect analysis system is configured in one embodiment to identify changes in the version control graph that are common to both the source and target branches. The common changes are changes in the version control graph from which both the source branch and the target branch derive. For example in the version control graph shown in the source branch is the branch A the target branch is the branch B and the common changes are the changes A.

Once the branch tracking defect analysis system has identified the common changes the branch tracking defect analysis system traverses the version control graph to collect a linear sequence of changes from the changes in the source branch that resolved the issue to the common changes. This traversal is indicated in by dotted lines. The direction of the arrows on the dotted lines indicates the direction of the traversal of the version control graph . For instance in the example shown in a linear sequence of changes is collected that includes the changes C the changes B and the common changes A.

The branch tracking defect analysis system analyzes the collected linear sequence of changes to determine the impact if any of the changes on the relevance of the change that resolved the issue to the specified point in the target branch. For instance in the example version control graph shown in the path from the changes C to the common changes A is traversed and the changes C B and A are examined to determine their impact if any on the applicability of the change C to the point in the target branch B including the changes G. Along the path from the changes that resolved the issue to the common changes the branch tracking defect analysis system may examine the reverse transformation of the changes to determine the impact if any on the applicability of the change in the source branch to specified point in the target branch. In this way the changes to the source branch may be transformed to their nearest equivalent as they would be applied to the specified location in the target branch.

The branch tracking defect analysis system also traverses the version control graph from the common changes to the specified point in the target branch B to collect a linear sequence of changes along this path. The branch tracking defect analysis system analyzes the collected linear sequence of changes along this path determine the impact if any of the changes on the applicability of the change associated with the source branch to the specified point in the target branch. For instance in the example version control graph shown in the path from the common changes A to the changes G is also traversed and the changes A D F and G are analyzed to determine their impact if any on the applicability of the change C to the point in the target branch B represented by the changes G.

In order to determine the impact of the linear sequences of changes described above on the applicability of the change made to the source branch to the target branch the branch tracking defect analysis system may examine the nature of the changes in the linear sequences of changes. For example if source code that encompasses the change to the source branch is modified at an earlier point in time it may reduce the applicability to the target branch of the change made to the source branch. Similarly changes made to portions of source code other than the portion containing the change made to the source branch might not have any impact on the applicability of a change to the target branch. In this regard it should be appreciated that changes made to a textual model i.e. source code and or a programmatic model might be analyzed along the paths from the changes in the target branch to the common changes and from the common changes to the specified point in the target branch.

In some embodiments a transformed change to a source branch that modifies files or other resources that are not present in the target branch will be considered inapplicable to the target branch. Similarly a transformed change to a source branch that introduces a dependency on a component that is non existing or not being used in the target branch will similarly be considered inapplicable to the target branch. Likewise if the transformed change references incompatible fields or methods in the target branch then the change will be considered inapplicable to the target branch. If merging the transformed change into the target branch would create an inconsistency in the target branch then the change will also be considered inapplicable to the target branch.

In some embodiments the changes made along the path from the changes in the source branch to the common changes and from the common changes to the specified point in the target branch are analyzed. In other embodiments some of the changes along the paths may be skipped. In this regard a user might be permitted to specify various preferences regarding the manner in which the path from the changes in the source branch to the common changes and from the common changes to the specified point in the target branch is traversed.

Based upon the traversal of the version control graph from the changes in the source branch to the common changes and from the common changes to the specified point in the target branch the branch tracking defect analysis system can determine whether the change made to the source branch may be applicable to the target branch. If the change made to the source branch is applicable to the target branch the branch tracking defect analysis system might cause one or more actions to be taken. For example and without limitation the branch tracking defect analysis system might cause the VCS to automatically apply the change previously made to the source branch to the target branch. For instance the change C might be applied to the changes G in the branch B in the example version control graph shown in . Alternatively the branch tracking defect analysis system might submit a modification request to the issue tracking system to create a new entry for the issue in the issue tracking system for the target branch. The new entry corresponds to the issue in the source branch that was resolved by the identified change i.e. the changes C in . The branch tracking defect analysis system might also cause other actions to be taken in response to determining that the change made to the source branch may also be applicable to the target branch.

If the branch tracking defect analysis system determines that the change made to the source branch is not applicable to the target branch the branch tracking defect analysis system might also cause one or more actions to be taken. For example and without limitation the branch tracking defect analysis system might submit a modification request to cause an entry to be closed in the issue tracking system for the issue that is associated with the target branch . The branch tracking defect analysis system might also cause other actions to be taken in response to determining that the change made to the source branch is not applicable to the target branch. Additional details regarding this process will be provided below with regard to .

From operation the routine proceeds to operation where the branch tracking defect analysis system receives the identity of a point e.g. changes in another branch i.e. the target branch in the version control graph for which the applicability of the changes identified at operation is to be determined. As mentioned above the identity of the location in the target branch for which the applicability of the changes made in the source branch is to be determined might be specified through a UI an API or in another manner.

From operation the routine proceeds to operation where the branch tracking defect analysis system identifies common changes for the specified changes in the source branch and the target branch. As mentioned above the common changes are changes in the version control graph from which both the source branch and the target branch derive.

Once the common changes have been identified the routine proceeds from operation to operation where the branch tracking defect analysis system collects a linear sequence of changes along a path in the version control graph from the changes made in the source branch to the common changes. The branch tracking defect analysis system evaluates the collected linear sequence of changes to determine the impact if any of the linear sequence of changes on the relevance of the change made to the source branch to the target branch.

From operation the routine proceeds to operation where the branch tracking defect analysis system collects a linear sequence of changes along a path in the version control graph from the common changes to the specified location in the target branch e.g. the changes G in the example shown in . The branch tracking defect analysis system evaluates the linear sequences of changes along the path between the common changes and the specified location in the target branch to determine the impact of the linear sequence of changes on the applicability to the target branch of the changes made to the source branch.

From operation the routine proceeds to operation where the branch tracking defect analysis system determines based upon the linear sequences of changes collected in the manner described above with regard to operations and whether the changes made to the source branch are applicable to the specified location in the target branch. If the changes made to the source branch are applicable to the target branch the routine proceeds from operation to operation . At operation a new entry may be created in the issue tracking system on the target branch that corresponds to the issue with the source branch that was resolved by the changes to the source branch.

From operation the routine proceeds to operation where the branch tracking defect analysis system might cause one or more other actions to be taken in response to determining that the changes made to the source branch are applicable to the target branch. For example and without limitation the branch tracking defect analysis system might cause the VCS to apply the changes C that resolved the issue with the source branch directly to the appropriate location within the target branch. Other types of actions might also be taken in other implementations.

If at operation the branch tracking defect analysis system determines that the changes made to the source branch are not applicable to the target branch the routine proceeds to operation . At operation the branch tracking defect analysis system might cause the issue tracking system to close an entry from the target branch if one exists for the same issue that is in the source branch. In this way an entry in the issue tracking system can be closed with regard to the target branch if the issue is determined not to be applicable to that branch. The routine then proceeds from operation to operation where the branch tracking defect analysis system might cause other actions to be taken in response to determining that changes made to a source branch are not applicable to another branch in the version control graph . From operations and the routine proceeds to operation where it ends.

It should be appreciated that the mechanism described above with reference to might be utilized in an automated process for testing the applicability of changes made to any branch in a version control graph to each of the other branches in the version control graph . For example a process might be executed that enumerates through each of the issues in the version control graph and performs the process described above with regard to for each of the issues and each of the changes within the branches in the version control graph . In this way various locations within the branches to which each issue may be applicable might be identified. Conversely stated given a location in a branch in the version control graph all of the known issues that might be applicable to that location may be determined. In some embodiments some or all of these processes might be automatically executed in response to the submission of a change that resolves an issue in a branch of the version control graph .

Turning now to details will be provided regarding a mechanism presented herein for calculating the relevance of an entry in the issue tracking system at a point in time after the entry is created. As described above the issue tracking system provides functionality for creating and managing entries corresponding to issues in a software component . For example and as illustrated in the version control graph A shown in an entry A might be created by the issue tracking system and stored in the issue tracking data store for an issue B identified in the software component . As also described above in detail the entries maintained by the issue tracking system may contain various types of information regarding an associated issue.

The mechanism described herein with regard to allows the relevance of an entry in the issue tracking system such as the entry A to be computed at a point in time after the entry has been created. This may be useful for instance where changes made to the software component after an entry has been created for an issue in the software component might reduce the relevance of the issue to the current state of the software component . For example in the version control graph A shown in an entry A has been created in the issue tracking system for an issue B at a certain point in time indicated as T in .

At some point in time shown as T in after the creation of the entry A changes I are made to the software component . The changes I might reduce the relevance of the entry A to the software component . Alternately the changes I might have no impact on the relevance of the entry A and the associated issue B . It may however be difficult for a developer to know whether the entry A is still relevant following the changes I.

At a later point in time indicated as T in additional changes J might also be made to the software component . In this example it may be even more difficult to determine whether the entry A in the issue tracking system and the associated issue B is still relevant following the changes I and J to the software component . Other changes K made at an even later time indicated as T in might make it even more difficult for a developer to understand the relevance of the entry A for the issue B to the current state of the software component .

The mechanism described in detail below with regard to allows the relevance of the issue A to be determined at a point in time after an entry A for the issue B has been created in the issue tracking system . For example using the mechanism described below the relevance of the entry A and the associated issue B may be determined following the changes I J and or K. Various types of actions may then be taken based upon the computed relevance.

The locations refer to locations in the software component that may be relevant to the associated issue . For example and without limitation the locations might refer to one or more files within the software component a line of source code or a range of lines of source code within the software component . A user may be permitted to specify the locations or the locations might be identified automatically based upon characteristics of the associated issue . For example the locations might be identified based upon stack traces associated with the entry A. The locations might also be identified based upon particular lines of source code in the software component that were modified prior to the creation of the entry A. As will be described in greater detail below changes made to the locations associated with an entry A may be analyzed to determine the relevance of an entry to a software component at some point in time after the entry has been created in the issue tracking system .

From operation the routine proceeds to operation where changes made to locations associated with the entry after the point in time at which the entry was created are identified. In one particular embodiment for example the version control graph may be traversed in order to identify the changes made to the specified locations within the software component after creation of the entry . For instance in the example shown in the current relevance of the entry A may be determined by analyzing the changes I J and K if any to the locations associated with the entry A.

From operation the routine proceeds to operation where a staleness score is computed based upon the changes made to the locations in the software component following the creation of the entry A for the issue B. As mentioned briefly above the staleness score provides a measure of the relevance of the entry A in the issue tracking system at a point in time after the entry A was created. In the example shown in for instance the computed staleness score may be computed in a manner to provide a measure of the current relevance of the entry A. The staleness score might similarly be computed for other points in time.

The types and quantity of changes made to the specified locations of the software component impact the staleness score. For example and without limitation significant changes made to the specified locations may decrease the relevance of the entry A and therefore increase the staleness score. Very minor changes to the locations or changes made to other portions of the software component other than the specified locations might have little or no impact on the staleness score. Each of the changes identified in the version control graph from the point in time at which the entry A was created e.g. T in through the point in time at which an indication of relevance is desired e.g. T T or T in may be evaluated and used in the computation of the staleness score. A subset of the changes might also be evaluated to compute the staleness score at another point in time.

From operation the routine proceeds to operation where one or more functions or actions may then be performed based upon the staleness score computed at operation . For example and without limitation if the staleness score indicates that the entry A is not likely to be relevant to the software component at a certain point in time the entry A may be closed in the issue tracking system . In this case a threshold value i.e. a threshold level of relevance may be set for use in determining if an entry A is to be closed in the issue tracking system . For example an entry may be closed in the issue tracking system if the computed staleness score meets e.g. exceeds a certain preset threshold relevance value.

In other embodiments the locations associated with an entry A might be modified based upon the computed staleness score. For example if the computed staleness score indicates that an entry A is no longer relevant but the issue B still exists in the relevant branch then the locations might be modified to reflect another location or locations within the software component . A user might also be permitted an opportunity to specify and or modify the locations .

In other embodiments a priority associated with the entry A in the issue tracking system might be modified based upon the computed staleness score. For example and without limitation the issue tracking system might be utilized to assign each entry associated with the software component a priority score indicating whether the entry is low priority high priority or another priority. Based upon the computed staleness score for an entry the priority associated with the entry might be adjusted. For example if the staleness score indicates that an entry A is no longer relevant the priority of the entry A might be adjusted from high priority to low priority. In some cases setting the priority to the lowest possible value might result in the closure of the entry A. The priority associated with an entry might also be adjusted in other ways based upon the computed staleness score.

In other embodiments a triage action may be requested in response to determining that the computed staleness score meets a specified threshold. For example the entry A for an issue B might be modified in order to signal a developer or other personnel to evaluate the issue B in response to determining that the staleness score for the entry A meets a predefined threshold. Other types of notifications might also be provided in order to signal a developer or other personal to evaluate the relevance of the issue B.

In some embodiments a UI is also provided for presenting the staleness score to a user. Based upon the presented staleness score the user may then be permitted to close and or modify an entry and or the associated locations adjust the priority associated with an entry and or take other types of actions based upon the staleness score. In this regard it should be appreciated that other types of actions might also be taken in place of or in addition to those specifically mentioned herein based upon a computed staleness score. In addition it should be appreciated that various types of events might trigger the process illustrated in . For example and without limitation changes checked in to the VCS might trigger the process described above in order to determine the applicability of any existing entries to the modified program code. Other types of events might also initiate the mechanism shown in . From operation the routine proceeds to operation where it ends.

The computer includes a baseboard or motherboard which is a printed circuit board to which a multitude of components or devices may be connected by way of a system bus or other electrical communication paths. In one illustrative embodiment one or more central processing units CPUs operate in conjunction with a chipset . The CPUs are standard programmable processors that perform arithmetic and logical operations necessary for the operation of the computer .

The CPUs perform the necessary operations by transitioning from one discrete physical state to the next through the manipulation of switching elements that differentiate between and change these states. Switching elements may generally include electronic circuits that maintain one of two binary states such as flip flops and electronic circuits that provide an output state based on the logical combination of the states of one or more other switching elements such as logic gates. These basic switching elements may be combined to create more complex logic circuits including registers adders subtractors arithmetic logic units floating point units and the like.

The chipset provides an interface between the CPUs and the remainder of the components and devices on the baseboard. The chipset may provide an interface to a random access memory RAM used as the main memory in the computer . The chipset may further provide an interface to a computer readable storage medium such as a read only memory ROM or non volatile RAM NVRAM for storing basic routines that help to startup the computer and to transfer information between the various components and devices. The ROM or NVRAM may also store other software components necessary for the operation of the computer in accordance with the embodiments described herein.

According to various embodiments the computer may operate in a networked environment using logical connections to remote computing devices and computer systems through the network such as a local area network LAN a wide area network WAN the Internet or any other networking topology known in the art that connects the computer to remote computers. The chipset includes functionality for providing network connectivity through a network interface controller NIC such as a gigabit Ethernet adapter. The NIC is capable of connecting the computer to other computing devices over the network . It should be appreciated that any number of NICs may be present in the computer connecting the computer to various types of networks and remote computer systems.

The computer may be connected to a mass storage device that provides non volatile storage for the computer . The mass storage device may store system programs application programs other program modules and data which are described in greater detail herein. The mass storage device may be connected to the computer through a storage controller connected to the chipset . The mass storage device may consist of one or more physical storage units. The storage controller may interface with the physical storage units through a serial attached SCSI SAS interface a serial advanced technology attachment SATA interface a fiber channel FC interface or other standard interface for physically connecting and transferring data between computers and physical storage devices.

The computer may store data on the mass storage device by transforming the physical state of the physical storage units to reflect the information being stored. The specific transformation of physical state may depend on various factors in different implementations of this description. Examples of such factors may include but are not limited to the technology used to implement the physical storage units whether the mass storage device is characterized as primary or secondary storage and the like. For example the computer may store information to the mass storage device by issuing instructions through the storage controller to alter the magnetic characteristics of a particular location within a magnetic disk drive unit the reflective or refractive characteristics of a particular location in an optical storage unit or the electrical characteristics of a particular capacitor transistor or other discrete component in a solid state storage unit. Other transformations of physical media are possible without departing from the scope and spirit of the present description with the foregoing examples provided only to facilitate this description. The computer may further read information from the mass storage device by detecting the physical states or characteristics of one or more particular locations within the physical storage units.

In addition to the mass storage device described above the computer may have access to other computer readable storage media to store and retrieve information such as program modules data structures or other data. It should be appreciated by those skilled in the art that computer readable storage media can be any available non transitory media that may be accessed by the computer . By way of example and not limitation computer readable storage media may include volatile and non volatile removable and non removable media implemented in any method or technology. Computer readable storage media includes RAM ROM erasable programmable ROM EPROM electrically erasable programmable ROM EEPROM flash memory or other solid state memory technology compact disc ROM CD ROM digital versatile disk DVD high definition DVD HD DVD BLU RAY or other optical storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium that can be used to store the desired information in a non transitory fashion.

The mass storage device may store an operating system utilized to control the operation of the computer . According to one embodiment the operating system comprises the LINUX operating system. According to another embodiment the operating system comprises the WINDOWS SERVER operating system from MICROSOFT Corporation of Redmond Wash. According to further embodiments the operating system may comprise the UNIX or SOLARIS operating systems. It should be appreciated that other operating systems may also be utilized. The mass storage device may store other system or application programs and data utilized by the computer such as the VCS the issue tracking system the issue investigation recommendation system and or the branch tracking defect analysis system each of which was described above in regard to .

In one embodiment the mass storage device or other computer readable storage media may be encoded with computer executable instructions that when loaded into the computer may transform the computer from a general purpose computing system into a special purpose computer capable of implementing the embodiments described herein. These computer executable instructions transform the computer by specifying how the CPUs transition between states as described above. According to one embodiment the computer may have access to computer readable storage media storing computer executable instructions that when executed by the computer perform the routines and described above with regard to respectively.

The computer might also include an input output controller for receiving and processing input from a number of input devices such as a keyboard the mouse a touchpad a touch screen an electronic stylus or other type of input device. Similarly the input output controller may provide output to a display such as a computer monitor a flat panel display a digital projector a printer a plotter or other type of output device. It will be appreciated that the computer may not include all of the components shown in may include other components that are not explicitly shown in or may utilize an architecture completely different than that shown in .

Based on the foregoing it should be appreciated that various concepts and technologies for identifying and resolving software issues have been presented herein. Although the subject matter presented herein has been described in language specific to computer structural features methodological acts and computer readable media it is to be understood that the invention defined in the appended claims is not necessarily limited to the specific features acts or media described herein. Rather the specific features acts and mediums are disclosed as example forms of implementing the claims.

The subject matter described above is provided by way of illustration only and should not be construed as limiting. Furthermore the claimed subject matter is not limited to implementations that solve any or all disadvantages noted in any part of this disclosure. Various modifications and changes may be made to the subject matter described herein without following the example embodiments and applications illustrated and described and without departing from the true spirit and scope of the present invention which is set forth in the following claims.

