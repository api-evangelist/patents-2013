---

title: Barrier commands in a cache tiling architecture
abstract: One embodiment of the present invention includes a graphics subsystem. The graphics subsystem includes a first processing entity and a second processing entity. Both the first processing entity and the second processing entity are configured to receive first and second batches of primitives, and a barrier command in between the first and second batches of primitives. The barrier command may be either a tiled or a non-tiled barrier command. A tiled barrier command is transmitted through the graphics subsystem for each cache tile. A non-tiled barrier command is transmitted through the graphics subsystem only once. The barrier command causes work that is after the barrier command to stop at a barrier point until a release signal is received. The back-end unit transmits a release signal to both processing entities after the first batch of primitives has been processed by both the first processing entity and the second processing entity.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08749564&OS=08749564&RS=08749564
owner: NVIDIA Corporation
number: 08749564
owner_city: Santa Clara
owner_country: US
publication_date: 20130703
---
This application claims benefit of U.S. provisional patent application Ser. No. 61 719 271 filed Oct. 26 2012 and titled An Approach for Tiled Caching. The subject matter of this related application is hereby incorporated herein by reference.

Embodiments of the present invention relate generally to graphics processing and more specifically to barrier commands in a cache tiling architecture.

Some graphics subsystems implement a tiling architecture that divides a render target into partitions referred to as tiles. Such graphics subsystems rearrange work provided to the graphics subsystem so that work associated with any particular tile remains in an on chip cache for a longer time than with an architecture that does not rearrange work in this manner. This rearrangement helps to improve memory bandwidth as compared with a non tiling architecture. Multiple processing entities may be provided to process the tiles in parallel for improved performance.

Oftentimes work executing in a graphics pipeline includes a first batch of work that is dependent on the results of a second batch of work. In such a case if the graphics pipeline were to begin processing the first batch of work before the second batch of work is fully processed then the results of the first batch of work would not be accurate. Among other things those results would not be properly based on the final results from the second batch of work. In such situations the graphics pipeline needs to be configured to honor these data dependencies.

In one traditional approach to managing data dependencies between multiple batches of work a first batch of work is processed and all other work is stalled. When the first batch of work is completed the other work is resumed. However this approach incurs a large performance penalty because no work other than the work being processed may proceed. Managing data dependencies is made more complicated by a graphics architecture includes multiple processing entities operating in parallel because the data dependencies can exist across the multiple processing entities. For example work to be processed in a first processing entity may be dependent on work being processed by a second processing entity.

As the foregoing illustrates what is needed in the art is a technique for managing data dependencies in a tiling architecture that includes multiple processing entities that process work related to the different tiles in parallel.

One embodiment of the present invention sets forth a graphics subsystem. The graphics subsystem includes a first processing entity and a second processing entity. Both the first processing entity and the second processing entity are configured to receive first and second batches of primitives and a barrier command in between the first and second batches of primitives. The barrier command causes work that is after the barrier command to stop at a barrier point until a release signal is received from a back end unit which is also included in the graphics subsystem. The back end unit transmits a release signal to both processing entities after the first batch of primitives has been processed by both the first processing entity and the second processing entity.

One embodiment of the present invention sets for a computing device. The computing device includes a graphics subsystem. The graphics subsystem includes a first processing entity and a second processing entity. Both the first processing entity and the second processing entity are configured to receive first and second batches of primitives and a barrier command in between the first and second batches of primitives. The barrier command causes work that is after the barrier command to stop at a barrier point until a release signal is received from a back end unit which is also included in the graphics subsystem. The back end unit transmits a release signal to both processing entities after the first batch of primitives has been processed by both the first processing entity and the second processing entity.

One embodiment of the present invention sets for a method for rendering graphics. The method includes processing a first initial batch of primitives in a first processing entity. The method also includes transmitting a first barrier command downstream after processing the first initial batch of primitives. The method further includes processing a first subsequent batch of primitives in response to receiving a release signal in the first processing entity. The method also includes transmitting the release signal to the first processing entity in response to receiving the first barrier command from the first processing entity.

One advantage of the disclosed graphics pipeline is that the graphics pipelines are configured to honor data dependencies between different batches of work. Another advantage is that units within the graphics pipelines that are upstream of the barrier point are allowed to process work in normal course and are not stalled. Thus some amount of work can still be processed within the different graphics pipelines while the downstream data dependencies are sorted out thereby increasing overall processing efficiency relative to prior art approaches.

In the following description numerous specific details are set forth to provide a more thorough understanding of the present invention. However it will be apparent to one of skill in the art that the present invention may be practiced without one or more of these specific details.

In operation I O bridge is configured to receive user input information from input devices such as a keyboard or a mouse and forward the input information to CPU for processing via communication path and memory bridge . Switch is configured to provide connections between I O bridge and other components of the computer system such as a network adapter and various add in cards and .

As also shown I O bridge is coupled to a system disk that may be configured to store content and applications and data for use by CPU and parallel processing subsystem . As a general matter system disk provides non volatile storage for applications and data and may include fixed or removable hard disk drives flash memory devices and CD ROM compact disc read only memory DVD ROM digital versatile disc ROM Blu ray HD DVD high definition DVD or other magnetic optical or solid state storage devices. Finally although not explicitly shown other components such as universal serial bus or other port connections compact disc drives digital versatile disc drives film recording devices and the like may be connected to I O bridge as well.

In various embodiments memory bridge may be a Northbridge chip and I O bridge may be a Southbridge chip. In addition communication paths and as well as other communication paths within computer system may be implemented using any technically suitable protocols including without limitation AGP Accelerated Graphics Port HyperTransport or any other bus or point to point communication protocol known in the art.

In some embodiments parallel processing subsystem comprises a graphics subsystem that delivers pixels to a display device that may be any conventional cathode ray tube liquid crystal display light emitting diode display or the like. In such embodiments the parallel processing subsystem incorporates circuitry optimized for graphics and video processing including for example video output circuitry. As described in greater detail below in such circuitry may be incorporated across one or more parallel processing units PPUs included within parallel processing subsystem . In other embodiments the parallel processing subsystem incorporates circuitry optimized for general purpose and or compute processing. Again such circuitry may be incorporated across one or more PPUs included within parallel processing subsystem that are configured to perform such general purpose and or compute operations. In yet other embodiments the one or more PPUs included within parallel processing subsystem may be configured to perform graphics processing general purpose processing and compute processing operations. System memory includes at least one device driver configured to manage the processing operations of the one or more PPUs within parallel processing subsystem .

In various embodiments parallel processing subsystem may be integrated with one or more other the other elements of to form a single system. For example parallel processing subsystem may be integrated with CPU and other connection circuitry on a single chip to form a system on chip SoC .

It will be appreciated that the system shown herein is illustrative and that variations and modifications are possible. The connection topology including the number and arrangement of bridges the number of CPUs and the number of parallel processing subsystems may be modified as desired. For example in some embodiments system memory could be connected to CPU directly rather than through memory bridge and other devices would communicate with system memory via memory bridge and CPU . In other alternative topologies parallel processing subsystem may be connected to I O bridge or directly to CPU rather than to memory bridge . In still other embodiments I O bridge and memory bridge may be integrated into a single chip instead of existing as one or more discrete devices. Lastly in certain embodiments one or more components shown in may not be present. For example switch could be eliminated and network adapter and add in cards would connect directly to I O bridge .

In some embodiments PPU comprises a graphics processing unit GPU that may be configured to implement a graphics rendering pipeline to perform various operations related to generating pixel data based on graphics data supplied by CPU and or system memory . When processing graphics data PP memory can be used as graphics memory that stores one or more conventional frame buffers and if needed one or more other render targets as well. Among other things PP memory may be used to store and update pixel data and deliver final pixel data or display frames to display device for display. In some embodiments PPU also may be configured for general purpose processing and compute operations.

In operation CPU is the master processor of computer system controlling and coordinating operations of other system components. In particular CPU issues commands that control the operation of PPU . In some embodiments CPU writes a stream of commands for PPU to a data structure not explicitly shown in either or that may be located in system memory PP memory or another storage location accessible to both CPU and PPU . A pointer to the data structure is written to a pushbuffer to initiate processing of the stream of commands in the data structure. The PPU reads command streams from the pushbuffer and then executes commands asynchronously relative to the operation of CPU . In embodiments where multiple pushbuffers are generated execution priorities may be specified for each pushbuffer by an application program via device driver to control scheduling of the different pushbuffers.

As also shown PPU includes an I O input output unit that communicates with the rest of computer system via the communication path and memory bridge . I O unit generates packets or other signals for transmission on communication path and also receives all incoming packets or other signals from communication path directing the incoming packets to appropriate components of PPU . For example commands related to processing tasks may be directed to a host interface while commands related to memory operations e.g. reading from or writing to PP memory may be directed to a crossbar unit . Host interface reads each pushbuffer and transmits the command stream stored in the pushbuffer to a front end .

As mentioned above in conjunction with the connection of PPU to the rest of computer system may be varied. In some embodiments parallel processing subsystem which includes at least one PPU is implemented as an add in card that can be inserted into an expansion slot of computer system . In other embodiments PPU can be integrated on a single chip with a bus bridge such as memory bridge or I O bridge . Again in still other embodiments some or all of the elements of PPU may be included along with CPU in a single integrated circuit or system of chip SoC .

In operation front end transmits processing tasks received from host interface to a work distribution unit not shown within task work unit . The work distribution unit receives pointers to processing tasks that are encoded as task metadata TMD and stored in memory. The pointers to TMDs are included in a command stream that is stored as a pushbuffer and received by the front end unit from the host interface . Processing tasks that may be encoded as TMDs include indices associated with the data to be processed as well as state parameters and commands that define how the data is to be processed. For example the state parameters and commands could define the program to be executed on the data. The task work unit receives tasks from the front end and ensures that GPCs are configured to a valid state before the processing task specified by each one of the TMDs is initiated. A priority may be specified for each TMD that is used to schedule the execution of the processing task. Processing tasks also may be received from the processing cluster array . Optionally the TMD may include a parameter that controls whether the TMD is added to the head or the tail of a list of processing tasks or to a list of pointers to the processing tasks thereby providing another level of control over execution priority.

PPU advantageously implements a highly parallel processing architecture based on a processing cluster array that includes a set of C general processing clusters GPCs where C 1. Each GPC is capable of executing a large number e.g. hundreds or thousands of threads concurrently where each thread is an instance of a program. In various applications different GPCs may be allocated for processing different types of programs or for performing different types of computations. The allocation of GPCs may vary depending on the workload arising for each type of program or computation.

Memory interface includes a set of D of partition units where D 1. Each partition unit is coupled to one or more dynamic random access memories DRAMs residing within PPM memory . In one embodiment the number of partition units equals the number of DRAMs and each partition unit is coupled to a different DRAM . In other embodiments the number of partition units may be different than the number of DRAMs . Persons of ordinary skill in the art will appreciate that a DRAM may be replaced with any other technically suitable storage device. In operation various render targets such as texture maps and frame buffers may be stored across DRAMs allowing partition units to write portions of each render target in parallel to efficiently use the available bandwidth of PP memory .

A given GPCs may process data to be written to any of the DRAMs within PP memory . Crossbar unit is configured to route the output of each GPC to the input of any partition unit or to any other GPC for further processing. GPCs communicate with memory interface via crossbar unit to read from or write to various DRAMs . In one embodiment crossbar unit has a connection to I O unit in addition to a connection to PP memory via memory interface thereby enabling the processing cores within the different GPCs to communicate with system memory or other memory not local to PPU . In the embodiment of crossbar unit is directly connected with I O unit . In various embodiments crossbar unit may use virtual channels to separate traffic streams between the GPCs and partition units .

Again GPCs can be programmed to execute processing tasks relating to a wide variety of applications including without limitation linear and nonlinear data transforms filtering of video and or audio data modeling operations e.g. applying laws of physics to determine position velocity and other attributes of objects image rendering operations e.g. tessellation shader vertex shader geometry shader and or pixel fragment shader programs general compute operations etc. In operation PPU is configured to transfer data from system memory and or PP memory to one or more on chip memory units process the data and write result data back to system memory and or PP memory . The result data may then be accessed by other system components including CPU another PPU within parallel processing subsystem or another parallel processing subsystem within computer system .

As noted above any number of PPUs may be included in a parallel processing subsystem . For example multiple PPUs may be provided on a single add in card or multiple add in cards may be connected to communication path or one or more of PPUs may be integrated into a bridge chip. PPUs in a multi PPU system may be identical to or different from one another. For example different PPUs might have different numbers of processing cores and or different amounts of PP memory . In implementations where multiple PPUs are present those PPUs may be operated in parallel to process data at a higher throughput than is possible with a single PPU . Systems incorporating one or more PPUs may be implemented in a variety of configurations and form factors including without limitation desktops laptops handheld personal computers or other handheld devices servers workstations game consoles embedded systems and the like.

Operation of GPC is controlled via a pipeline manager that distributes processing tasks received from a work distribution unit not shown within task work unit to one or more streaming multiprocessors SMs . Pipeline manager may also be configured to control a work distribution crossbar by specifying destinations for processed data output by SMs .

In one embodiment GPC includes a set of M of SMs where M 1. Also each SM includes a set of functional execution units not shown such as execution units and load store units. Processing operations specific to any of the functional execution units may be pipelined which enables a new instruction to be issued for execution before a previous instruction has completed execution. Any combination of functional execution units within a given SM may be provided. In various embodiments the functional execution units may be configured to support a variety of different operations including integer and floating point arithmetic e.g. addition and multiplication comparison operations Boolean operations AND OR XOR bit shifting and computation of various algebraic functions e.g. planar interpolation and trigonometric exponential and logarithmic functions etc. . Advantageously the same functional execution unit can be configured to perform different operations.

In operation each SM is configured to process one or more thread groups. As used herein a thread group or warp refers to a group of threads concurrently executing the same program on different input data with one thread of the group being assigned to a different execution unit within an SM . A thread group may include fewer threads than the number of execution units within the SM in which case some of the execution may be idle during cycles when that thread group is being processed. A thread group may also include more threads than the number of execution units within the SM in which case processing may occur over consecutive clock cycles. Since each SM can support up to G thread groups concurrently it follows that up to G M thread groups can be executing in GPC at any given time.

Additionally a plurality of related thread groups may be active in different phases of execution at the same time within an SM . This collection of thread groups is referred to herein as a cooperative thread array CTA or thread array. The size of a particular CTA is equal to m k where k is the number of concurrently executing threads in a thread group which is typically an integer multiple of the number of execution units within the SM and m is the number of thread groups simultaneously active within the SM .

Although not shown in each SM contains a level one L1 cache or uses space in a corresponding L1 cache outside of the SM to support among other things load and store operations performed by the execution units. Each SM also has access to level two L2 caches not shown that are shared among all GPCs in PPU . The L2 caches may be used to transfer data between threads. Finally SMs also have access to off chip global memory which may include PP memory and or system memory . It is to be understood that any memory external to PPU may be used as global memory. Additionally as shown in a level one point five L1.5 cache may be included within GPC and configured to receive and hold data requested from memory via memory interface by SM . Such data may include without limitation instructions uniform data and constant data. In embodiments having multiple SMs within GPC the SMs may beneficially share common instructions and data cached in L1.5 cache .

Each GPC may have an associated memory management unit MMU that is configured to map virtual addresses into physical addresses. In various embodiments MMU may reside either within GPC or within the memory interface . The MMU includes a set of page table entries PTEs used to map a virtual address to a physical address of a tile or memory page and optionally a cache line index. The MMU may include address translation lookaside buffers TLB or caches that may reside within SMs within one or more L1 caches or within GPC .

In graphics and compute applications GPC may be configured such that each SM is coupled to a texture unit for performing texture mapping operations such as determining texture sample positions reading texture data and filtering texture data.

In operation each SM transmits a processed task to work distribution crossbar in order to provide the processed task to another GPC for further processing or to store the processed task in an L2 cache not shown parallel processing memory or system memory via crossbar unit . In addition a pre raster operations preROP unit is configured to receive data from SM direct data to one or more raster operations ROP units within partition units perform optimizations for color blending organize pixel color data and perform address translations.

It will be appreciated that the core architecture described herein is illustrative and that variations and modifications are possible. Among other things any number of processing units such as SMs texture units or preROP units may be included within GPC . Further as described above in conjunction with PPU may include any number of GPCs that are configured to be functionally similar to one another so that execution behavior does not depend on which GPC receives a particular processing task. Further each GPC operates independently of the other GPCs in PPU to execute tasks for one or more application programs. In view of the foregoing persons of ordinary skill in the art will appreciate that the architecture described in in no way limits the scope of the present invention.

The PD collects vertex data associated with high order surfaces graphics primitives and the like from the front end and transmits the vertex data to the VAF .

The VAF retrieves vertex attributes associated with each of the incoming vertices from shared memory and stores the vertex data along with the associated vertex attributes into shared memory.

The VTG is a programmable execution unit that is configured to execute vertex shader programs tessellation programs and geometry programs. These programs process the vertex data and vertex attributes received from the VAF and produce graphics primitives for further processing within the graphics processing pipeline . Although not explicitly shown the VTG may include in some embodiments one or more of a vertex processing unit a tessellation initialization processing unit a task generation unit a task distributor a topology generation unit a tessellation processing unit and a geometry processing unit.

The vertex processing unit is a programmable execution unit that is configured to execute vertex shader programs lighting and transforming vertex data as specified by the vertex shader programs. For example the vertex processing unit may be programmed to transform the vertex data from an object based coordinate representation object space to an alternatively based coordinate system such as world space or normalized device coordinates NDC space. The vertex processing unit may read vertex data and vertex attributes that is stored in shared memory by the VAF and may process the vertex data and vertex attributes. The vertex processing unit stores processed vertices in shared memory.

The tessellation initialization processing unit is a programmable execution unit that is configured to execute tessellation initialization shader programs. The tessellation initialization processing unit processes vertices produced by the vertex processing unit and generates graphics primitives known as patches. The tessellation initialization processing unit also generates various patch attributes. The tessellation initialization processing unit then stores the patch data and patch attributes in shared memory. In some embodiments the tessellation initialization shader program may be called a hull shader or a tessellation control shader.

The task generation unit retrieves data and attributes for vertices and patches from shared memory. The task generation unit generates tasks for processing the vertices and patches for processing by later stages in the graphics processing pipeline .

The task distributor redistributes the tasks produced by the task generation unit. The tasks produced by the various instances of the vertex shader program and the tessellation initialization program may vary significantly between one graphics processing pipeline and another. The task distributor redistributes these tasks such that each graphics processing pipeline has approximately the same workload during later pipeline stages.

The topology generation unit retrieves tasks distributed by the task distributor. The topology generation unit indexes the vertices including vertices associated with patches and computes U V coordinates for tessellation vertices and the indices that connect the tessellated vertices to form graphics primitives. The topology generation unit then stores the indexed vertices in shared memory.

The tessellation processing unit is a programmable execution unit that is configured to execute tessellation shader programs. The tessellation processing unit reads input data from and writes output data to shared memory. This output data in shared memory is passed to the next shader stage the geometry processing unit as input data. In some embodiments the tessellation shader program may be called a domain shader or a tessellation evaluation shader.

The geometry processing unit is a programmable execution unit that is configured to execute geometry shader programs thereby transforming graphics primitives. Vertices are grouped to construct graphics primitives for processing where graphics primitives include triangles line segments points and the like. For example the geometry processing unit may be programmed to subdivide the graphics primitives into one or more new graphics primitives and calculate parameters such as plane equation coefficients that are used to rasterize the new graphics primitives.

The geometry processing unit transmits the parameters and vertices specifying new graphics primitives to the VPC . The geometry processing unit may read data that is stored in shared memory for use in processing the geometry data. The VPC performs clipping culling and viewport transform to determine which graphics primitives are potentially viewable in the final rendered image and which graphics primitives are not potentially viewable. The VPC then transmits processed graphics primitives to the tiling unit .

The tiling unit is a graphics primitive sorting engine that resides between a world space pipeline and a screen space pipeline as further described herein. Graphics primitives are processed in the world space pipeline and then transmitted to the tiling unit . The screen space is divided into cache tiles where each cache tile is associated with a portion of the screen space. For each graphics primitive the tiling unit identifies the set of cache tiles that intersect with the graphics primitive a process referred to herein as tiling. After tiling a certain number of graphics primitives the tiling unit processes the graphics primitives on a cache tile basis where graphics primitives associated with a particular cache tile are transmitted to the setup unit . The tiling unit transmits graphics primitives to the setup unit one cache tile at a time. Graphics primitives that intersect with multiple cache tiles are typically processed once in the world space pipeline but are then transmitted multiple times to the screen space pipeline .

Such a technique improves cache memory locality during processing in the screen space pipeline where multiple memory operations associated with a first cache tile access a region of the L2 caches or any other technically feasible cache memory that may stay resident during screen space processing of the first cache tile. Once the graphics primitives associated with the first cache tile are processed by the screen space pipeline the portion of the L2 caches associated with the first cache tile may be flushed and the tiling unit may transmit graphics primitives associated with a second cache tile. Multiple memory operations associated with a second cache tile may then access the region of the L2 caches that may stay resident during screen space processing of the second cache tile. Accordingly the overall memory traffic to the L2 caches and to the render targets may be reduced. In some embodiments the world space computation is performed once for a given graphics primitive irrespective of the number of cache tiles in screen space that intersects with the graphics primitive.

The setup unit receives vertex data from the VPC via the tiling unit and calculates parameters associated with the graphics primitives including without limitation the color values surface normal vectors and transparency values at each vertex of the graphics primitive. The setup unit then transmits processed graphics primitives to rasterizer .

The rasterizer scan converts the new graphics primitives and transmits fragments and coverage data to the pixel shading unit . Additionally the rasterizer may be configured to perform z culling and other z based optimizations.

The pixel shading unit is a programmable execution unit that is configured to execute fragment shader programs transforming fragments received from the rasterizer as specified by the fragment shader programs. Fragment shader programs may shade fragments at pixel level granularity where such shader programs may be called pixel shader programs. Alternatively fragment shader programs may shade fragments at sample level granularity where each pixel includes multiple samples and each sample represents a portion of a pixel. Alternatively fragment shader programs may shade fragments at any other technically feasible granularity depending on the programmed sampling rate.

In various embodiments the fragment processing unit may be programmed to perform operations such as perspective correction texture mapping shading blending and the like to produce shaded fragments that are transmitted to the ROP . The pixel shading unit may read data that is stored in shared memory.

The ROP is a processing unit that performs raster operations such as stencil z test blending and the like and transmits pixel data as processed graphics data for storage in graphics memory via the memory interface where graphics memory is typically structured as one or more render targets. The processed graphics data may be stored in graphics memory parallel processing memory or system memory for display on display device or for further processing by CPU or parallel processing subsystem . In some embodiments the ROP is configured to compress z or color data that is written to memory and decompress z or color data that is read from memory. In various embodiments the ROP may be located in the memory interface in the GPCs in the processing cluster array outside of the GPCs or in a separate unit not shown within the PPUs .

The graphics processing pipeline may be implemented by any one or more processing elements within PPU . For example one of the SMs of could be configured to perform the functions of one or more of the VTG and the pixel shading unit . The functions of the PD the VAF the VPC the tiling unit the setup unit the rasterizer and the ROP may also be performed by processing elements within a particular GPC in conjunction with a corresponding partition unit . Alternatively graphics processing pipeline may be implemented using dedicated fixed function processing elements for one or more of the functions listed above. In various embodiments PPU may be configured to implement one or more graphics processing pipelines .

In some embodiments the graphics processing pipeline may be divided into a world space pipeline and a screen space pipeline . The world space pipeline processes graphics objects in 3D space where the position of each graphics object is known relative to other graphics objects and relative to a 3D coordinate system. The screen space pipeline processes graphics objects that have been projected from the 3D coordinate system onto a 2D planar surface representing the surface of the display device . For example the world space pipeline could include pipeline stages in the graphics processing pipeline from the PD through the VPC . The screen space pipeline could include pipeline stages in the graphics processing pipeline from the setup unit through the ROP . The tiling unit would follow the last stage of the world space pipeline namely the VPC . The tiling unit would precede the first stage of the screen space pipeline namely the setup unit .

In some embodiments the world space pipeline may be further divided into an alpha phase pipeline and a beta phase pipeline. For example the alpha phase pipeline could include pipeline stages in the graphics processing pipeline from the PD through the task generation unit. The beta phase pipeline could include pipeline stages in the graphics processing pipeline from the topology generation unit through the VPC . The graphics processing pipeline performs a first set of operations during processing in the alpha phase pipeline and a second set of operations during processing in the beta phase pipeline. As used herein a set of operations is defined as one or more instructions executed by a single thread by a thread group or by multiple thread groups acting in unison.

In a system with multiple graphics processing pipeline the vertex data and vertex attributes associated with a set of graphics objects may be divided so that each graphics processing pipeline has approximately the same amount of workload through the alpha phase. Alpha phase processing may significantly expand the amount of vertex data and vertex attributes such that the amount of vertex data and vertex attributes produced by the task generation unit is significantly larger than the amount of vertex data and vertex attributes processed by the PD and VAF . Further the task generation unit associated with one graphics processing pipeline may produce a significantly greater quantity of vertex data and vertex attributes than the task generation unit associated with another graphics processing pipeline even in cases where the two graphics processing pipelines process the same quantity of attributes at the beginning of the alpha phase pipeline. In such cases the task distributor redistributes the attributes produced by the alpha phase pipeline such that each graphics processing pipeline has approximately the same workload at the beginning of the beta phase pipeline.

Please note as used herein references to shared memory may include any one or more technically feasible memories including without limitation a local memory shared by one or more SMs or a memory accessible via the memory interface such as a cache memory parallel processing memory or system memory . Please also note as used herein references to cache memory may include any one or more technically feasible memories including without limitation an L1 cache an L1.5 cache and the L2 caches.

The screen space represents one or more memory buffers configured to store rendered image data and other data transmitted by functional units within the graphics processing pipeline . In some embodiments the one or more memory buffers may be configured as one or more render targets. The screen space represents a memory buffer configured to store the image rendered by the graphics processing pipeline. The screen space may be associated with any number of render targets where each render target may be configured independently of other render targets to include any number of fields. Each field within a render target may be configured independently of other fields to include any number of bits. Each render target may include multiple picture elements pixels and each pixel may in turn include multiple samples. In some embodiments the size of each cache tile may be based on the size and configuration of the render targets associated with the screen space. In operation once rendering completes the pixels in the one or more render targets may be transmitted to a display device in order to display the rendered image.

By way of example a set of render targets for the screen space could include eight render targets. The first render target could include four fields representing color including red green and blue component colors and transparency information associated with a corresponding fragment. The second render target could include two fields representing depth and stencil information associated with the corresponding fragment. The third render target could include three fields representing surface normal vector information including an x axis normal vector a y axis normal vector and a z axis normal vector associated with the corresponding fragment. The remaining five render targets could be configured to store additional information associated with the corresponding fragment. Such configurations could include storage for various information including without limitation 3D positional data diffuse lighting information and specular lighting information.

Each cache tile represents a portion of the screen space . For clarity only five cache tiles are shown in . In some embodiments cache tiles may have an arbitrary size in X and Y screen space. For example if a cache tile were to reside in a cache memory that also is used to store other data then the cache tile could be sized to consume only a specific portion of the cache memory. The size of a cache tile may be based on a number of factors including the quantity and configuration of the render targets associated with the screen space the quantity of samples per pixel and whether the data stored in the cache tile is compressed. As a general matter a cache tile is sized to increase the likelihood that the cache tile data remains resident in the cache memory until all graphics primitives associated with the cache tile are fully processed.

The raster tiles represent a portion of the cache tile . As shown the cache tile includes sixteen raster tiles arranged in an array that is four raster tiles wide and four raster tiles high. In systems that include multiple GPCs processing associated with a given cache tile may be divided among the available GPCs . In the example shown if the sixteen raster tiles of cache tile were processed by four different GPCs then each GPC could be assigned to process four of the sixteen raster tiles in the cache tile . Specifically the first GPC could be assigned to process raster tiles and . The second GPC could be assigned to process raster tiles and . The third GPC could be assigned to process raster tiles and . The fourth GPC would then be assigned to process raster tiles and . In other embodiments the processing of the different raster tiles within a given cache tile may be distributed among GPCs or any other processing entities included within computer system in any technically feasible manner.

Each of the pipeline units i.e. the world space pipeline setup rasterizer pixel shader and ROP depicted in functions in a similar manner as described above with respect to . The pre raster operations unit PROP not depicted in is a unit that is configured to perform among other things early z testing optimizations for color blending and address translations.

As shown the graphics subsystem includes at least two instances of the screen space pipeline and the world space pipeline for increased performance. The graphics subsystem also includes a crossbar unit for transmitting work output from the first world space pipeline and the second world space pipeline to the first tiling unit and the second tiling unit . Although depicted in with two instances of the world space pipeline and the screen space pipeline the teachings provided herein apply to graphics pipelines having any number of world space pipelines and screen space pipelines .

The functionality of the world space pipelines and the screen space pipelines are implemented by processing entities such as general processing clusters GPC described above. In one embodiment the first world space pipeline may be implemented in a first GPC and the second world space pipeline may be implemented in a second GPC . As a general matter each screen space pipeline may be implemented in a different GPC and in a similar fashion each world space pipeline may be implemented in a different GPC . Further a given GPC can implement a world space pipeline and also a screen space pipeline . For example the first GPC may implement both the first world space pipeline and the first screen space pipeline .

A front end unit receives commands from a device driver and schedules tasks for processing by the world space pipeline . A back end unit receives data from the screen space pipeline and provides feedback through feedback pathway to PROP . The back end unit includes a barrier command counter for counting the number of barrier commands received by the back end unit as is discussed in more detail below. The functionality of the back end unit may be implemented in the front end unit in which case the graphics subsystem would include only the front end unit . A screen space circular buffer receives barrier commands from the front end unit and stores the barrier commands for use by the tiling units . The screen space buffer is a memory construct that may be stored in a cache such as an L2 cache.

Operation of the graphics subsystem is now described in the context of commands transmitted from a device driver . The commands transmitted from the device driver include a first batch of commands a barrier command and a second batch of commands . The first batch of commands and second batch of commands include commands for rendering primitives. At least some of the commands in the second batch of commands are dependent on screen space outputs such as color values generated by the pixel shader and ROP associated with the first batch of commands . The non tiled barrier command is provided in the commands from the driver between the first batch of commands and the second batch of commands in order to cause the graphics pipeline to honor the data dependencies between the first batch of commands and the second batch of commands .

In operation the device driver sends commands to the front end unit which distributes tasks to the first world space pipeline and the second world space pipeline . The front end unit also causes the barrier command to be transmitted to a screen space circular buffer for subsequent access by the first tiling unit and the second tiling unit as discussed below. In one embodiment the front end unit assigns tasks to the first world space pipeline and the second world space pipeline in round robin order. The first world space pipeline and second world space pipeline each process work associated with the first batch of commands and work associated with the second batch of commands and generate primitives for processing by the first screen space pipeline and the second screen space pipeline .

The first world space pipeline and second world space pipeline each include a bounding box generator unit not shown that determines to which screen space pipeline the first screen space pipeline or the second screen space pipeline each primitive should be transmitted. The first world space pipeline and the second world space pipeline transmit each primitive through the cross bar unit to either or both of the first screen space pipeline or the second screen space pipeline as specified by the bounding box generator. Both the first world space pipeline and the second world space pipeline may send primitives to either of the first screen space pipeline or the second screen space pipeline or both of the first screen space pipeline and the second screen space pipeline depending on which raster tiles the primitives overlap.

Each tiling unit is associated with a respective screen space pipeline . Each tiling unit thus receives primitives from the crossbar destined to the corresponding screen space pipeline and transmits those primitives to the corresponding screen space pipeline . For example the first tiling unit receives primitives destined for the first screen space pipeline and transmits the primitives to the first screen space pipeline .

When the last primitive associated with the first batch of commands is received by a tiling unit the screen space circular buffer transmits the non tiled barrier command to the tiling unit . In response to receiving the non tiled barrier command the tiling unit flushes. When a tiling unit flushes the tiling unit generates cache tile batches that each include primitives that overlap a cache tile and transmits those cache tile batches to the screen space pipeline associated with the particular tiling unit . Each cache tile batch thus includes primitives that overlap a different cache tile. The process of flushing is described in more detail below with respect to . After the tiling unit flushes and transmits all primitives stored in the tiling unit to the corresponding screen space pipeline the tiling unit transmits the non tiled barrier command to the corresponding screen space pipeline .

All primitives transmitted by a tiling unit prior to the tiling unit receiving the barrier command are included in a first batch of primitives while all primitives transmitted by the tiling unit after the tiling unit receiving the barrier command are included in a second batch of primitives . depicts two first batches of primitives and . First batch of primitives corresponds to primitives transmitted by the first tiling unit while first batch of primitives corresponds to primitives transmitted by the second tiling unit . Similarly second batch of primitives corresponds to primitives transmitted by the first tiling unit while second batch of primitives corresponds to primitives transmitted by the second tiling unit . Finally barrier command is the non tiled barrier command transmitted by the first tiling unit while barrier command is the non tiled barrier command transmitted by the second tiling unit .

Each unit in the screen space pipeline processes the first batch of primitives as described above with respect to . Each unit in the screen space pipeline also forwards the barrier command down the screen space pipeline after processing the first batch of primitives .

When the barrier command arrives at PROP PROP sets a barrier flag that indicates that a non tiled barrier command has been received. When set the barrier flag prevents work received after the barrier command from proceeding past PROP until the flag is cleared. Each PROP unit sets a corresponding barrier flag independently. In other words when the first PROP unit receives the first barrier command the first PROP unit sets a corresponding barrier flag but does not set the barrier flag corresponding to the second PROP unit .

After the tiling unit flushes in response to receiving the barrier command and transmits the barrier command to the respective screen space pipeline the tiling unit then receives primitives in the second batch of primitives which are associated with the second batch of commands . The tiling unit generates cache tile batches for each of the primitives in the second batch of primitives and transmits the cache tile batches to the corresponding screen space pipeline as described above. The cache tile batches associated with the second batch of primitives proceed down the screen space pipeline until these cache tile batches arrive at PROP . Because the barrier flag is set PROP does not allow these cache tile batches to proceed past PROP until the barrier flag is cleared.

The work associated with the first batch of primitives proceeds through the rest of the screen space pipeline until the screen space pipeline completes processing the work associated with the first batch of primitives . The screen space pipeline completes processing the work associated with the first batch of primitives when the pixel shader and raster operation unit have completed respective operations for the work associated with the first batch of primitives . As stated above the barrier command follows this work. When a barrier command reaches the back end unit the back end unit increments a barrier command counter to indicate that the back end unit has received a barrier command from one of the screen space pipelines .

If the barrier command counter indicates that a barrier command has been received from each of the screen space pipelines then the back end unit transmits a barrier release signal through feedback pathway which causes both first PROP unit and second PROP unit to reset their corresponding barrier flags. Resetting the barrier flags causes both first PROP and second PROP to begin processing work received after the barrier command including the work associated with the second batch of primitives .

If the barrier command counter indicates that a barrier command has been received from less than all of the screen space pipelines then the back end unit does not transmit a barrier release signal through feedback pathway to the PROP unit and both the first PROP unit and the second PROP unit continue to prohibit work received after the barrier command from being processed or from proceeding past the first PROP unit or the second PROP unit .

Thus work associated with the second batch of primitives and after the barrier command cannot proceed past PROP until all of the work associated with the first batch of primitives has completed processing in both the first ROP and the second ROP . Preventing work associated with the second batch of primitives from proceeding past PROP until all work associated with the first batch of primitives allows any data dependencies between the first batch of primitives and the second batch of primitives to be honored. More specifically all of the processing tasks associated with the first batch of primitives are completed before any of the processing tasks associated with pixel shader or ROP are initiated for the second batch of primitives . Waiting to process the second batch of primitives allows any work associated with the second batch of primitives in either pixel shader or ROP that requires data from the results of processing the first batch of primitives in either pixel shader or ROP to receive such data. One advantage of the non tiled barrier command is that units within the graphics pipelines that are upstream of PROP are allowed to process work associated with the second batch of primitives in normal course and are not stalled.

The units depicted in function in a similar manner as the units described with respect to . Thus front end unit receives the first batch of commands the tiled barrier command and the second batch of commands and in response causes the first world space pipeline and the second world space pipeline to generate primitives associated with both the first batch of commands and the second batch of commands . As in the world space pipelines determine which screen space pipelines should receive the generated primitives and transmit the primitives to the corresponding tiling unit .

However in the device driver transmits a tiled barrier command rather than a non tiled barrier command after a first batch of commands and before a second batch of commands . All units except for the tiling unit treat the tiled barrier command in a similar manner to the manner in which the units treat the non tiled barrier command . More specifically when a PROP unit receives a tiled barrier command the PROP unit sets a barrier flag. The PROP unit prevents work from proceeding until the barrier flag is reset. The back end unit includes a barrier command counter for maintaining a count of the tiled barrier commands received by the back end unit .

The difference between the non tiled barrier command and the tiled barrier command is in what steps the tiling unit takes in response to receiving the tiled barrier command . The tiling unit does not flush in response to receiving the tiled barrier command . Instead when the tiling unit receives the tiled barrier command the tiling unit continues to accept primitives from the world space pipeline until the tiling unit flushes for some other reason for example in response to resource counters in the tiling unit indicating that a resource threshold is exceeded .

When a tiling unit flushes the tiling unit iterates through all of the cache tiles and for each cache tile transmits a cache tile batch that includes all primitives that overlap the cache tile to the corresponding screen space pipeline . The tiling unit continues to transmit cache tile batches in this manner for all cache tiles associated with a render target.

The tiling unit includes the tiled barrier command in each of the cache tile batches that the tiling unit generates. Within each cache tile batch the tiling unit places the tiled barrier command after primitives associated with the first batch of commands but before primitives associated with the second batch of commands .

When each cache tile batch proceeds down the screen space pipeline work associated with the first batch of primitives proceeds down the pipeline without being stopped by the PROP unit . The tiled barrier command in each cache tile batch proceeds down the pipeline after the work associated with the first batch of primitives . When the tiled barrier command reaches PROP PROP sets a barrier flag associated with the cache tile that is associated with the tiled barrier command . When work associated with the second batch of primitives and associated with the cache tile for which a barrier flag is set arrives at PROP PROP causes that work to not proceed past PROP because the barrier flag is set.

For each cache tile the barrier command counter in the back end unit counts the number of tiled barrier commands received by the back end unit corresponding to that cache tile. When the number of barrier commands received by the back end unit for any particular cache tile is equal to the number of screen space pipelines then the back end unit transmits a release signal through feedback pathway to first PROP unit and second PROP unit .

The release signal causes each PROP unit to reset a barrier flag corresponding to the cache tile for which the release signal was sent. Subsequently the PROP unit allows work associated with the second batch and associated with that cache tile to proceed past PROP .

When a tiling unit flushes the tiling unit generates a cache tile batch that includes a tiled barrier command for each cache tile even if the cache tile batch has no primitives. Generating barrier commands in this manner allows the number of tiled barrier commands received by the back end unit to be equal to the number of tiling units even if a particular cache tile batch has no primitives.

Each cache tile batch includes a first batch of primitives that includes primitives associated with the first batch of commands a tiled barrier command and a second batch of primitives that includes primitives associated with the second batch of commands . For each cache tile batch the first batch of primitives and the tiled barrier command proceed past PROP while the second batch of primitives is stopped at PROP until all tiled barrier commands for that particular cache tile have reached the back end unit .

As shown a method begins in step where a crossbar unit transmits work to a first tiling unit and a second tiling unit . The work transmitted to the first tiling unit includes a first batch of work that includes primitives associated with a first batch of commands transmitted from device driver . The work transmitted to the second tiling unit includes a first batch of work that also includes primitives associated with the first batch of commands .

In step the screen space circular buffer transmits a non tiled barrier command to both the first tiling unit and to the second tiling unit . Tiling unit receives a first copy of the barrier command and tiling unit receives a second copy of the barrier command .

In step the first tiling flushes when the first tiling unit receives the first copy of the barrier command . The second tiling unit also flushes when the second tiling unit receives the second copy of the barrier command . As stated above flushing causes the tiling units to reorder the primitives that are in the tiling units into cache tile batches. The tiling units transmit the cache tile batches to the corresponding screen space pipeline .

In step each tiling unit transmits the barrier command to the screen space pipeline . In step the world space pipelines transmit a second batch of work to each tiling unit . In step each screen space pipeline processes the first batch of work until that first batch of work has completed processing. In step when a screen space pipeline finishes processing the first batch of work that screen space pipeline transmits the non tiled barrier command to the back end unit .

When all processing entities have finished processing their corresponding first batches of work then all processing entities forward the barrier command to the back end unit . The back end unit keeps track in barrier command counter of how many barrier commands the back end unit receives. In step when the back end unit receives a number of barrier commands equal to the number of screen space pipelines then the back end unit transmits a barrier release signal through feedback pathway to all of the PROP units . When the PROP units receive the barrier release signal the PROP units allow work associated with the second batch of primitives to proceed past the PROP unit .

As shown a method begins at step where world space pipelines transmit through crossbar a first batch of work and a second batch of work to tiling units . The screen space circular buffer transmits the barrier command to the tiling units so that the barrier command is received after the first batch of work and before the second batch of work.

In step each tiling unit flushes. The tiling units flush when for example a resource counter indicates that a resource threshold has been exceeded. When one tiling unit flushes while storing a tiled barrier command that tiling unit divides the primitives present in the tiling unit into cache tile batches where each cache tile batch includes the tiled barrier command . The cache tile batches may also include primitives associated with either or both of the first batch of work and the second batch of work depending on whether the primitives in the first batch of work and the second batch of work intersect with the cache tile associated with the cache tile batch. The tiling units transmit each of the cache tile batches to the screen space pipeline for processing.

In step the screen space pipeline processes each of the cache tile batches. For each cache tile batch the screen space pipeline processes the work associated with the first batch of primitives. The screen space pipeline also allows work associated with the second batch of primitives to proceed through the screen space pipeline until the work reaches the PROP unit . In step for each cache tile the PROP unit prohibits work associated with the second batch of work from proceeding past the PROP unit.

In step when work associated the any particular cache tile has completed processing in the screen space pipeline the barrier command for that cache tile proceeds to the back end unit . In step when the back end unit receives all barrier commands associated with any particular cache tile the back end unit transmits a barrier release signal through feedback pathway to the PROP unit . When the PROP unit receives a release signal through the feedback pathway the PROP unit allows the work associated with that cache tile and with the second batch of work to proceed past the PROP unit .

In sum a graphics subsystem is disclosed that implements a non tiled barrier command and a tiled barrier command . For the non tiled barrier command the graphics pipeline receives first and second sets of commands from a device driver and receives a non tiled barrier command after the first set of commands but before the second set of commands. The world space pipeline processes the first and second sets of commands to generate primitives which are then transmitted to tiling units. The tiling units generate cache tile batches for processing by screen space pipelines.

After the tiling units receive the last primitives associated with the first set of commands from the world space pipelines the tiling units receive the non tiled barrier command from the screen space circular buffer which causes the tiling units to flush. Work in the screen space pipelines associated with the first set of commands flows through the screen space pipeline and the non tiled barrier command follows. When the non tiled barrier command arrives at PROP PROP sets a barrier flag to prevent work received after the non tiled barrier command from proceeding past PROP . When all of the non tiled barrier commands reach a back end unit the back end unit transmits a release signal through feedback pathway that causes PROP to reset the barrier flag. When the barrier flag is reset work received by PROP after the non tiled barrier command is allowed to proceed.

For the tiled barrier command the tiling units do not flush when the tiling units receive the tiled barrier command . Rather the tiling units accept the tiled barrier command and continue accepting primitives until the tiling units flush for some other reason. When a tiling unit flushes with a tiled barrier command in the tiling unit the tiling unit processes the primitives normally to generate cache tile batches but includes a barrier command in each of the cache tile batches. The tiling unit subsequently transmits all of the cache tile batches to the corresponding screen space pipeline .

Within each cache tile batch primitives and the tiled barrier command are arranged in application programming interface API order meaning that the primitives associated with the first batch of commands are before the tiled barrier command which is before the primitives associated with the second batch of commands. Thus the primitives associated with the first batch of commands are allowed to pass through PROP without hindrance.

When the tiled barrier command arrives at PROP PROP sets a barrier flag corresponding to the cache tile associated with the tiled barrier command . This barrier flag prevents the primitives associated with the second set of commands from proceeding past PROP . However those primitives are still processed normally by all of the units prior to PROP . When all of the tiled barrier commands from each screen space pipeline arrive at the back end unit the back end unit transmits a barrier release signal through feedback pathway to each PROP unit which causes the PROP unit to allow primitives associated with the second batch of commands and with the cache tile that has been released to flow past the PROP unit .

One advantage of the above described techniques is that the graphics pipelines are configured to honor data dependencies between different batches of work. Another advantage is that units within the graphics pipelines that are upstream of the barrier point are allowed to process work in normal course and are not stalled. Thus some amount of work can still be processed within the different graphics pipelines while the downstream data dependencies are sorted out thereby increasing overall processing efficiency relate to prior art approaches.

One embodiment of the invention may be implemented as a program product for use with a computer system. The program s of the program product define functions of the embodiments including the methods described herein and can be contained on a variety of computer readable storage media. Illustrative computer readable storage media include but are not limited to i non writable storage media e.g. read only memory devices within a computer such as compact disc read only memory CD ROM disks readable by a CD ROM drive flash memory read only memory ROM chips or any type of solid state non volatile semiconductor memory on which information is permanently stored and ii writable storage media e.g. floppy disks within a diskette drive or hard disk drive or any type of solid state random access semiconductor memory on which alterable information is stored.

The invention has been described above with reference to specific embodiments. Persons of ordinary skill in the art however will understand that various modifications and changes may be made thereto without departing from the broader spirit and scope of the invention as set forth in the appended claims. The foregoing description and drawings are accordingly to be regarded in an illustrative rather than a restrictive sense.

