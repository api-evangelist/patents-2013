---

title: Method and system for optimized parallel queuing
abstract: A method and system for sharing and synchronizing content between a content repository and file sharing service. An application server includes a connector engine and a connector agent. The connector engine with is configured with a plurality of threads and queues designed to listen for changes at either the file sharing service or the repository, to process those changes in parallel, and to coordinate synchronization of uploads to the file sharing service and downloads to the content repository.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09104742&OS=09104742&RS=09104742
owner: EMC CORPORATION
number: 09104742
owner_city: Hopkinton
owner_country: US
publication_date: 20130313
---
This disclosure relates generally to the field of content sharing and synchronization and more particularly to systems and methods for synchronizing content shared among multiple computing devices using parallel threading and queueing of data.

Content repositories and content management systems such as the Documentum content management platform are multi user environments i.e. many users are accessing the same repository at the same time. File sharing and synchronization services such as the Syncplicity platform are single user systems where a single user may have multiple computing devices all sharing the same content as managed by the file service. This disparity creates complexities when trying to map content from a repository to a file sharing service. For example multiple users can update create rename delete files and folders at the same time.

It would thus be desirable to provide a mechanism for integrating synchronization services with repository services.

This disclosure describes a connector configured to enable sharing and synchronization of content between a data repository such as the Documentum content management platform and a file sharing synchronization service such as the Syncplicity service. Such a connector allows content in the repository to be shared and synchronized with all computing devices that are linked through the file sync service. Further while specific detailed embodiments of a synchronization connector between the Documentum platform and the Syncplicity platform are described herein the synchronization connector may be adapted other platforms.

The components shown in may be implemented with conventional computing devices configured in well known manner e.g. by providing executable instructions to the computing devices for performing their respective functional operations and for communicating and interacting with each other. For example the file sharing service is a single user web based service such as the Syncplicity service that allows folders and files to be identified shared and synchronized among all of the user s computing devices without moving the files. Likewise the repository may be a conventional content management service such as the Documentum content management service. The examples described herein are based on connecting the Documentum repository platform with the Syncplicity service. However it should be recognized that other platforms can be similarly integrated through suitable instruction programming.

The connector is preferably implemented as an instance of an application server running between the file sharing service and the repository . The connector therefore is preferably programmed with executable instructions designed to achieve two main objectives i to publish content from the repository to the file sharing service so that computing devices connected to the file sharing service can share the content and ii to coordinate changes made to content at either the file sharing service or the repository in order to synchronize the contents.

The connector is configured to include a connector engine CE which is a generic platform independent framework that serves as a bridge between the file sharing service and the repository platform . For example CE is programmed with executable instructions to i upload content from the repository to the file sharing service ii store the synchronization status of each uploaded file and folder in a persistent store e.g. Derby or an external database not shown configured by users such as Oracle or SQL Server via setting a proper JDBC driver URL and credential iii monitor content changes on the file sharing service and iv download changes from the file sharing service to the repository.

The connector also includes a connector agent which is a platform specific module used by the CE to communicate with the underlying repository platform regarding traversing folders retrieving or saving content monitoring changes etc. For example connector agent may be programmed with executable instructions to i navigate the folder structure on the repository platform ii upload content from the repository to the CE iii download content from the CE to the repository and iv record the synchronization status of each uploaded file and folder in the repository. The synchronization status may be used by clients to mark or decorate the corresponding object on the user interface.

Another embodiment shown in is similar to that of but in CE interacts with a number of different repositories and each repository has a platform specific connector agent each connector agent configured according to the respective platform. In addition agent is coupled to repository by communications link and agent is coupled to repository by communications link .

The connector is preferably configured through UI which acts as a connector administrator for configuring content sharing between the repository and the file sharing service . The UI is configured to allow users such as a system administrator to i create profiles which define the credential mapping from repository users or groups to a file sharing service login account and filtering rules based on object type format file size and so on for deciding what kinds of content to synchronize in and out ii share a folder with an associated profile and iii change the password for a credential in a file sharing service account repository admin account etc. Since the UI is mainly driven by administrators based on company policy operating in this mode is referred to herein as Auto Sharing or Implicit Sharing.

The connector may also be configured through alternative UI which is adapted for a particular repository platform and is suitable to configure the folders for sharing. For example UI may be a feature of the Documentum platform e.g. D2 ver. 4.1 and or xCP ver. 2.0. Such a client UI is driven by end users based on their own needs and thus operating in this mode is referred to herein as Manual Sharing or Explicit Sharing.

The Documentum platform includes a number of predefined Business Process Manager BPM activity templates that may be used to represent particular tasks that can be added to a business process for example rendering a Word document to PDF format. Custom templates may also be created from scratch or by modifying an existing template. In general a BPM activity template identifies any underlying workflow methods required to complete the task and determines what configuration attributes must be set in order to accomplish the task. The BPM activity template may also set default values for common attributes.

As shown in the connector agent is configured to include a workflow engine and a BPM module . The BPM module is further configured with a process engine and a process integrator .

The Process Builder tool of the Documentum platform is used to create and define workflows and processes for publishing and synchronizing folders and files between the file sharing service and the repository and these workflows and processes are stored in the repository via the workflow engine . More particularly the defined processes create listeners and the process engine executes the processes. Information regarding connection status and cross reference for the file sharing service may be hard coded into the connector engine .

In the Auto Sharing mode the connector administrator UI has a number of defined application programming interfaces APIs using the HTTP protocol for configuring the connector for sharing and synchronization. Alternatively in the Manual Sharing mode the repository platform UI has defined APIs for configuring the connector and for interacting with the repository .

The process engine obtains configuration information from CE as well as status and cross reference information. The connector engine then sets a URL for its operation obtains the user s credentials through a log in process and starts the workflow at the process integrator . The process integrator and the workflow engine forward defined processes to the process engine where the processes are executed causing the process engine to poll for changes in content at the repository then publishing uploading changed content to the file sync service and managing the shared folders. The connector engine coordinates and manages sync points with the file sync service .

In step CE connects to the file sync service. In step CE creates and or deletes sync points for the file sync service . In step CE connects to the process integrator and in step CE forwards its own URL and credential information to the process integrator.

In step the process engine logs in to CE . If the log in is not successful in step then an error is generated back to the UI . If the log in is successful then the file sync service returns an authentication token back to the process engine in step . In step APIs are provided through UI or UI to permit updating the connection and sharing information stored in CE or more accurately in the local store . In step APIs are provided through UI or UI to allow the process engine to update the synchronization status.

During the installation process a DAR file is installed to the repository to create objects and types in the repository. For example an object dm relation type is created with the object types shown in and object subtypes dm relation to dm relation sync status is created with the attributes shown in .

In step CE uses the folder path to retrieve all pairs of profiles and sync points. Steps will be repeated for each pair. In step CE checks to see if the content at the sync point is synchronized by using the sync point object ID and content ID folder path and repository version ID. If the content is synchronized e.g. the content is an exact match in step then in step CE maps the profile username to a token and maps the profile folder path to the sync point vpath . If there is not an exact match in step but the profile matches in step then in step CE maps the profile user name to a token and maps the profile folder path to sync point sync point root folder path . If there is no exact match and no profile match then in step CE maps the profile user name to a token and maps the profile folder path to def sync point sync point root folder path .

If there are more pairs to consider in step then in step the CE retrieves the next pair and the process returns to step to process the next pair. If there are no more pairs to consider in step then in step CE returns a data set to the BPM module having and .

In step the BPM module gets a unique file name for the content of the object and in step uses to publish the content to the file sync service . In step in response to publishing the content the file sync service returns to CE a unique file ID the sync version ID and the date modified. Finally in step the BPM module uses the object ID folder path unique file name unique file ID sync version ID and date modified to update the sync status on CE and repository .

BPM processes are defined through Documentum activity templates to facilitate publishing content to the file sync service . Examples of the process templates are illustrated in .

The process template Connector Watch Documentum Folders illustrated in is the main process for publishing content to the file sync service . The process is initiated by a request from CE and will run until folder monitoring is stopped or the share is removed from the database. This process template gets share profile and user credentials for the file sync service from CE synchronizes contents from the repository to the file sync service creates or updates the dmc relation sync status object for decorators and then goes to sleep. The process resumes after a sleep interval and starts synchronizing the contents again. The sleep interval or frequency is set in the configuration of the folder share.

This process is a long running process so in order to avoid overpopulating the workitem table in the local store a new process is initiated for each publishing cycle. The activity Connector Watch New Folder is used only for external requests. i.e. a call from CE while the activity Connector Watch New Folder Internal is used only for internal requests.

The process template Connector Get CF and Syncplicity Session Info illustrated in gets authentication token share and profile information from CE . The process then obtains a session token using the authentication token application token from the file sync service . This session token is used to authenticate future requests to the file sync service . The process includes the ability to retrieve information for folders and files present in the watch folder from repository . The process also checks to see if the profile has been versioned. If the profile is versioned between two requests then content already synchronized is removed from the file sync service and CE and a synchronization cycle is run again.

The process template Connector Folder Mappings To Delete illustrated in finds the folders that are deleted unlinked from the watch folder by calling the folder orphaned mapping API.

The process template Connector Delete Syncplicity Folder illustrated in deletes the folder and its contents from the file sync service and the connector database as well as deleting the relation object for the folder and its contents.

The process template Connector Get Document Mappings To Delete illustrated in finds the files that are deleted unlinked from the watch folder by calling the file orphaned mapping API.

The process template Connector Delete Syncplicity Document illustrated in deletes the document from the file sync service and connector database as well as deleting the relation object for the document.

The process template Connector Get Folders to Publish illustrated in finds the list of folders that should be published in the current publishing cycle. The list is a collection of three different lists i folders that are linked unlinked to the watch folder these folders are identified by the folder orphaned mapping API ii newly created or renamed folders and iii folders that failed to publish in a previous publishing cycle.

The three lists are combined with duplicate entries removed and then ordered to make sure that the items are created in the file sync service in the same order as they show up in the repository .

The process template Connector Create Folder illustrated in creates a folder in the file sync service an entry in the connector database and a relation object in the repository . The folder information is sent to the create folder API in CE and the result is the mapping information which is used to create the folders. There can be more than one mapping for a folder if the folder is linked to multiple folders under the watch folder.

If there is any error during a publish cycle the status in the connector database and the relation object is set to sync failed and a notification is sent to the object dmc sync admin with the cause of the error.

The process template Connector Get Documents to Publish illustrated in finds the list of documents that should be published in the current publishing cycle. The list is collection of three different lists i documents linked unlinked to the watch folder this information is obtained from file orphaned mapping API ii newly created or renamed files and iii files that failed to publish in a previous publishing cycle. The three lists are combined with duplicate entries removed to generate the final list of objects to publish.

The process template Connector Upload document filtering rules illustrated in checks to see if the file meets the profile rules and if so publishes the file to the file sync service . If the file does not meet the profile rules and it was already published in the previous publishing cycle then the file is deleted from the file sync service .

The process template Connector Upload document illustrated in creates a file in the file sync service an entry in the connector database and a relation object in the repository . The file information is sent to the CE create file API and the result is mapping information which is used to create files. There can be more than one mapping for a file if the file is linked to multiple folders under the watch folder. If there is any error during a publish cycle the status in the connector database and the relation object is set to sync failed and a notification is sent to the object dmc sync admin with the cause of the error.

The process template Connector Sync Sleep illustrated in enables the process to sleep for the specified time interval and is implemented using post timers. In one embodiment the sleep time can be set to 1 5 15 30 or 60 minutes. Any values other than the specified values will default to 1 minute. The object dm WfmsTimer job should be in an active state and the frequency should be set to 1 minute.

The process template Connector Create Relation Object illustrated in creates the object dmc relation sync status and sets the child id to the relation object id.

In one embodiment CE is built on top of the Spring Framework which is an open source framework for a Java based platform. Table I below shows the high level descriptions of Java classes and packages implemented inside CE . All the classes are within the com.emc.syncplicity hierarchy.

The class com.emc.Syncplicity.SyncAgentAppListener implements Spring s ApplicationListener interface and is informed when the web application is started. In the handler the initial connection to the Derby database is established. If the database does not exist it is created and the appropriate database tables are also created.

The SyncAgentAppListener calls into the com.emc.syncplicity.connector.core.ConnectorContext implementation with the application context. When the ConnectorContextImpl class which implements the ConnectorContext interface receives the application context the syncagent.xml file is retrieved from the classpath. The ConnectorContextImpl class then chooses whether to use the configuration based upon the syncagent.xml file or the existing configuration from the database depending on which is valid and has a higher version number. If the syncagent.xml configuration is selected shares syncpoints and profiles will get created updated or deleted depending upon whether there are additions changes or deletions of share and profile elements from the configuration file. Handling of shares and profiles are done through implementations of the com.emc.syncplicity.connector.service.ShareService and com.emc.syncplicity.connector.service.ProfileService interfaces respectively.

The connector engine utilizes the Synplicity REST APIs in order to create and delete syncpoints to add and remove participants to get a list of syncpoint participants and to register a machine to get an authentication token. These API calls go through a set of wrapper classes. The key class that supports all the APIs is com.emc.syncplicity.httpclient.webapi.WebApiManager. A method of that class executeRequest handles Syncplicity session token authentication in a manner transparent to the call.

The Syncplicity REST APIs are utilized by the com.emc.syncplicity.connector.service.ShareService interface implementation namely com.emc.syncplicity.connector.service.impl.ShareServiceImpl class in response to calls from com.emc.syncplicity.connector.controller.ShareController web API requests and the ConnectorContext implementation xml application initialization .

When a share is created the connector engine will make a call into the configured com.emc.syncplicity.connector.core.ISyncpointCreatedListener implementation. The interface consists of a single method as shown below 

For the Documentum connector release the implementation corresponds to the com.emc.syncplicity.connector.documentum.DocumentumSyncpointCreatedListener class. In the onSyncpointCreated method of DocumentumSyncpointCreatedListener the RestTemplate is used to make a call into ConnectorWatchNewFolder API exposed by the Process Integrator.

The process engine utilizes REST services provided by the connector engine in order to find out information about the share that will be monitored to find out the filtering rules applicable to a share to determine whether a document needs to be uploaded to Syncplicity to record synchronization state and to determine files or folders which need to be removed from Syncplicity.

The collaboration use case involves bi directional synchronization. That is the collaboration use case supports the publishing use case plus synchronization changes that occur on other endpoints such as other computers and mobile devices that are linked to the file service . In this embodiment more of the features for synchronizing contents will reside in the connector engine. To that end the BPM module is replaced with an internal module and the connector engine implements various queues and threads for different stages of processing content.

The change events stored in the preparation queue are sent for further processing to a preparation thread . The preparation thread takes items from the preparation queue to optimize and filter them based on the nature of the event. Because the change events are stored as a set of trees based on their dependencies multiple instances of the preparation thread e.g. threads can be run in parallel to simplify the process. The results will be pushed to a process queue where local store is again used as a persistent store.

A process thread is also configured with multiple instances e.g. threads and for parallel processing of the data from process queue . The process thread uploads and downloads content as requested as well as checks the upload synchronization status and stores the status in a finalizing queue . Status recorded in the repository is recorded at the time the content is downloaded. The process thread also resolves any conflicts among different versions of change events typically through defined rules and may reorder the data in the process queue .

A finalizing thread uses the status from the finalizing queue to update the download and upload status on the persistent store .

The subject matter described herein may be computer implemented in a suitable system by providing computer executable instructions stored on a non transitory computer readable medium. A computer readable medium may include any medium that participates in providing instructions to one or more processors for execution. Such a medium may take many forms including but not limited to nonvolatile volatile and transmission media. Nonvolatile media includes for example flash memory or optical or magnetic disks. Volatile media includes static or dynamic memory such as cache memory or RAM. Transmission media includes coaxial cables copper wire fiber optic lines and wires arranged in a bus. Transmission media can also take the form of electromagnetic energy radio frequency signals acoustic or light waves such as those generated during radio wave and infrared data communications.

Computer software products may be written in any of various suitable programming languages such as C C C Pascal Fortran Perl Matlab from MathWorks SAS SPSS JavaScript AJAX Java SQL and XQuery. A computer software product may be an independent application with data input and data display modules. Alternatively computer software products may be classes that are instantiated as distributed objects or component software such as Java Beans or Enterprise Java Beans both by Oracle Corporation . In one embodiment the subject matter described herein is embodied as a computer program product which stores instructions such as computer code that when executed by a computer cause the computer to perform the processes and or techniques described below.

While one or more implementations have been described by way of example and in terms of the specific embodiments it is to be understood that one or more implementations are not limited to the disclosed embodiments. To the contrary it is intended to cover various modifications and similar arrangements as would be apparent to those skilled in the art. Therefore the scope of the appended claims should be accorded the broadest interpretation so as to encompass all such modifications and similar arrangements.

