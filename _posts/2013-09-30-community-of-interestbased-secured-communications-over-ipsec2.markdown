---

title: Community of interest-based secured communications over IPsec
abstract: A method and system for establishing secure communications between endpoints includes transmitting a first message including a token having one or more entries each corresponding to a community of interest associated with a user of the first endpoint and including an encryption key and a validation key associated with the first endpoint. The method includes receiving a second message including a second authorization token including one or more entries, each entry corresponding to a community of interest associated with a second user and including an encryption key and a validation key associated with the second endpoint. The method includes, for each community of interest associated with both users, decrypting an associated entry in the second authorization token to obtain the encryption key and validation key associated with the second endpoint. The method also includes generating a shared secret based on the key pair, transmitting a third message including the created key pair to the second endpoint, and initializing tunnel using the shared secret to derive encryption keys used for IPsec-secured communications between the endpoints.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09596077&OS=09596077&RS=09596077
owner: Unisys Corporation
number: 09596077
owner_city: Blue Bell
owner_country: US
publication_date: 20130930
---
The present application claims priority from U.S. Provisional Patent Application No. 61 814 431 filed Apr. 22 2013 the disclosure of which is hereby incorporated by reference in its entirety.

The present application relates generally to community of interest based secured communications over IPsec.

Modern organizations generate store and communicate large quantities of data. In many instances organizations include individuals having different rights to data or different rights to communicate with other individuals or access particular computing resources. It is frequently important that such organizations be able to quickly and securely access the data stored at the data storage system. In addition it is frequently important that data stored at a data storage system or communicated between computing systems be recoverable if the data is communicated or written incorrectly or are otherwise intercepted or corrupted.

To address the above issues Unisys Corporation of Blue Bell Pennsylvania developed a Stealth solution that uses a kernel level driver to implement end to end cryptographic connections for communication of data across public and private networks. This solution allows users to communicate with other users having common user rights while segregating user groups by way of assignment of different cryptographic keys used for each user group or community of interest . However the Stealth solution has some drawbacks. First the existing Stealth solution is only compatible with IPv4 networks with the increasing proliferation of IPv6 addressing some migration is needed. Secondly the existing Stealth solution resides primarily in drivers at the kernel level and as such is specifically tailored for use on specific operating systems e.g. Windows based systems an incompatible computing system is typically placed behind a Stealth enabled appliance that can be used to route communications on the behalf of that incompatible computing system. Furthermore since the existing Stealth solution utilizes a proprietary cryptographic library it is less trusted by large corporations and governments who prefer standards based security systems.

Internet Protocol Security IPsec is one such standards based protocol suite used for securing Internet Protocol IP communications by authenticating and encrypting each IP packet of a communication session IPsec includes protocols for establishing authentication between agents at the beginning of the session and negotiation of cryptographic keys to be used during the session. IPsec is an end to end security scheme of the Internet Protocol Suite. As compared to other security systems such as SSL SSH or TLS IPsec operates in the Internet Layer rather than operating in the upper layers of the TCP IP model. Hence IPsec protects any application traffic across an Internet Protocol IP network. Applications do not need to be specifically designed to use IPsec whereas TLS SSL is required to be designed into an application to protect the application protocols. In addition IPsec operates in both IPv4 and IPv6 enabled networks.

However IPsec is not without drawbacks. Existing IPsec enabled systems typically negotiate to create IPsec tunnels or secure tunnels on a point to point basis rather than allowing for data access by multiple entities within the same community of interest . Furthermore IPsec is only available on modern computing systems. In Windows environments IPsec is only available as part the native operating system since the release of Windows 7 prior versions lack support for this security protocol suite. Furthermore different implementations of IPsec on different types of computing systems are handled differently leading to inconsistencies in connection parameters. Additionally IPsec is built based on a premise that two computing systems can negotiate security parameters when two such systems intend to form a secure tunnel that tunnel is established through use of an IKE key exchange which requires a response to an initial transmission. However to accomplish perfect forward secrecy such trading of security parameters may not be possible. Accordingly improvements in the various existing secured communications systems are desired.

In accordance with the following disclosure the above and other issues are addressed by the following 

In a first aspect a method of establishing secure communications between endpoints is disclosed. The method includes transmitting from a first endpoint to a second endpoint a first message including a token the token including one or more entries each entry corresponding to a community of interest associated with a user of the first endpoint and including an encryption key and a validation key associated with the first endpoint and encrypted with the corresponding community of interest key. The method also includes receiving from the second endpoint a second message including a second authorization token at the first endpoint the second authorization token including one or more entries each entry corresponding to a community of interest associated with a second user of the second endpoint and including an encryption key and a validation key associated with the second endpoint and encrypted with the corresponding community of interest key. The method further includes for each community of interest associated with both the first user and the second user decrypting an associated entry in the second authorization token to obtain the encryption key and validation key associated with the second endpoint. The method also includes creating a key pair at the first endpoint and generating a shared secret based on the key pair and transmitting a third message including the created key pair to the second endpoint thereby allowing the second endpoint to derive the shared secret. The method includes initializing a tunnel between the first and second endpoints the tunnel using the shared secret to derive encryption keys used for IPsec secured communications between the first and second endpoints.

In a second aspect a method of establishing secure communications between endpoints is disclosed. The method includes receiving from a first endpoint at a second endpoint a first message including a token the token including one or more entries each entry corresponding to a community of interest associated with a user of the first endpoint and including an encryption key and a validation key associated with the first endpoint and encrypted with the corresponding community of interest key. The method also includes for each community of interest associated with both the first user and the second user decrypting an associated entry in the first authorization token to obtain the encryption key and validation key associated with the first endpoint. The method also includes creating a key pair at the second endpoint and transmitting to the first endpoint from the second endpoint a second message including a second authorization token the second authorization token including one or more entries each entry corresponding to a community of interest associated with a second user of the second endpoint and including an encryption key and a validation key associated with the second endpoint and encrypted with the corresponding community of interest key. The method also includes receiving at the second endpoint a third message including a key pair created at the first endpoint encrypted with the encryption key of the second endpoint and deriving at the second endpoint the shared secret from the key pair created at the first endpoint and the key pair created at the second endpoint The method includes initializing a tunnel between the first and second endpoints the tunnel using the shared secret to derive encryption keys used for IPsec secured communications between the first and second endpoints.

In a third aspect a system includes a first endpoint and a second endpoint. The first endpoint includes a computing system configured to transmit a first message to a second endpoint the first message including a token the token including one or more entries each entry corresponding to a community of interest associated with a user of the first endpoint and including an encryption key and a validation key associated with the first endpoint and encrypted with the corresponding community of interest key. The computing system is also configured to receive from the second endpoint a second message including a second authorization token the second authorization token including one or more entries each entry corresponding to a community of interest associated with a second user of the second endpoint and including an encryption key and a validation key associated with the second endpoint and encrypted with the corresponding community of interest key. The computing system is further configured to for each community of interest associated with both the first user and the second user decrypt an associated entry in the second authorization token to obtain the encryption key and validation key associated with the second endpoint. The computing system is also configured to create a key pair and generating a shared secret based on the key pair and transmit a third message including the created key pair to the second endpoint thereby allowing the second endpoint to derive the shared secret. The computing system is configured to initialize a tunnel to the second endpoint the tunnel using the shared secret to derive encryption keys used for IPsec secured communications by the first endpoint. The second endpoint includes a second computing system communicatively connected to the computing system at the first endpoint. The second computing system is configured to receive the first message and for each community of interest associated with both the first user and the second user decrypt an associated entry in the token to obtain the encryption key and validation key associated with the first endpoint. The second computing system is also configured to create a second key pair transmit the second message to the first endpoint the second message including the second authorization token and the second key pair and receive the third message. The second computing system is also configured to derive at the second endpoint the shared secret from the key pair created at the first endpoint and the key pair created at the second endpoint and initialize a tunnel to the first endpoint using the shared secret to derive encryption keys used for IPsec secured communications by the second endpoint.

This summary is provided to introduce a selection of concepts in a simplified form that are farther described below in the Detailed. Description. This summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used to limit the scope of the claimed subject matter.

Various embodiments of the present invention will be described in detail with reference to the drawings wherein like reference numerals represent like parts and assemblies throughout the several views. Reference to various embodiments does not limit the scope of the invention which is limited only by the scope of the claims attached hereto. Additionally any examples set forth in this specification are not intended to be limiting and merely set forth some of the many possible embodiments for the claimed invention.

The logical operations of the various embodiments of the disclosure described herein are implemented as 1 a sequence of computer implemented steps operations or procedures running on a programmable circuit within a computer and or 2 a sequence of computer implemented steps operations or procedures running on a programmable circuit within a directory system database or compiler.

In general the present disclosure relates to improvements to systems and methods for securing endpoints and communication channels such as the Stealth secure communications and storage system of Unisys Corporation of Blue Bell Pennsylvania. As is included in the existing Stealth system data to be transmitted among endpoints e.g. client or server computing systems is encrypted such that 1 no computing system other than the sender and intended recipient can view the contents of the encrypted message s and 2 in some embodiments the messages are configurable such that message packets themselves are split among different packets and optionally transmitted along different transmission paths between computing systems to ensure receipt of the secured communications at a receiving endpoint. That receiving endpoint can then reconstruct the message based on one or more such received split and encrypted messages.

The present disclosure specifically describes aspects of a secure communications and secure computing systems that provides 1 simplified application level security controls 2 support for various addressing schemes such as Internet Protocol Version 4 IPv4 and Internet Protocol Version 6 IPv6 and 3 selectability among a plurality of security constructs including existing proprietary constructs and standardized constructions that allow for such application level security controls. Additionally improvements to the mechanisms used to manage connectivity between computing systems that implement the Stealth system provide for both secure communications between two endpoints even within a common community of interest with other endpoints and ensures that the connectivity is accomplished using perfect forward secrecy ensuring that any unauthorized access of an endpoint within a Stealth enabled network is not responded to even with a response indicating failure. As such from the perspective of a requesting computing system an unauthorized endpoint appears dark or non responsive. Additional features such as a callout driver configured to manage creation and negotiation of an IPsec based tunnel using specific defined processes are provided as well.

It is noted that a complete description of the existing Stealth solution may be found in several pending and commonly assigned U.S. Patent Applications 

U.S. patent application Ser. No. 12 272 012 entitled BLOCK LEVEL DATA STORAGE SECURITY SYSTEM filed 17 Nov. 2008.

U.S. patent application Ser. No. 12 336 558 entitled DATA RECOVERY USING ERROR STRIP IDENTIFIERS filed 17 Dec. 2008.

U.S. Provisional Application Ser. No. 60 648 531 filed Jan. 31 2005 entitled INTEGRATED MULTI LEVEL SECURITY SYSTEM as a continuation in part.

U.S. patent application Ser. No. 11 339 974 filed Jan. 26 2006 entitled INTEGRATED MULTI LEVEL SECURITY SYSTEM which itself is a continuation in part of Ser. No. 60 648 531 above as a continuation in part.

U.S. patent application Ser. No. 11 339 974 filed Jan. 26 2006 entitled SECURING AND PARTITIONING DATA IN MOTION USING A COMMUNITY OF INTEREST which itself is a continuation in part of Ser. No. 11 339 374 as a continuation in part.

U.S. patent application Ser. No. 12 336 559 entitled STORAGE SECURITY USING CRYPTOGRAPHIC SPLITTING filed 17 Dec. 2008.

U.S. patent application Ser. No. 12 336 562 entitled STORAGE SECURITY USING CRYPTOGRAPHIC SPLITTING filed 17 Dec. 2008.

U.S. patent application Ser. No. 12 336 564 entitled STORAGE SECURITY USING CRYPTOGRAPHIC SPLITTING filed 17 Dec. 2008.

U.S. patent application Ser. No. 12 336 568 entitled STORAGE SECURITY USING CRYPTOGRAPHIC SPLITTING filed 17 Dec. 2008.

U.S. patent application Ser. No. 12 342 438 entitled STORAGE AVAILABILITY USING CRYPTOGRAPHIC SPLITTING filed 23 Dec. 2008.

U.S. patent application Ser. No. 12 342 464 entitled. STORAGE AVAILABILITY USING CRYPTOGRAPHIC SPLITTING filed 23 Dec. 2008.

U.S. patent application Ser. No. 12 312 500 entitled BLOCK LEVEL DATA STORAGE USING AN OUTSTANDING WRITE LIST filed 23 Dec. 2008.

U.S. patent application Ser. No. 12 342 636 entitled STORAGE COMMUNITIES OF INTEREST USING CRYPTOGRAPHIC SPLITTING filed 23 Dec. 2008.

U.S. patent application Ser. No. 342 575 entitled STORAGE COMMUNITIES OF INTEREST USING CRYPTOGRAPHIC SPLITTING filed 23 Dec. 2008.

U.S. patent application Ser. No. 12 342 610 entitled STORAGE COMMUNITIES OF INTEREST USING CRYPTOGRAPHIC SPLITTING filed 23 Dec. 2008.

U.S. patent application Ser. No. 12 342 414 entitled VIRTUAL TAPE BACKUP ARRANGEMENT USING CRYPTOGRAPHICALLY SPLIT STORAGE filed 23 Dec. 2008.

U.S. patent application Ser. No. 13 105 173 entitled Methods and Systems for Implementing a Secure Boot Device Using Cryptographically Secure Communications Across Unsecured Networks filed 11 May 2011.

All of these applications are hereby incorporated by reference as if they were set out here in their entirety.

In some embodiments of the present disclosure the methods and systems discussed herein use the Windows Filtering Platform WFP a new architecture provided in Windows Vista operating systems and above. The WFP allows for filtering monitoring and or modification of TCP IP packets as well as filtering of IPSec traffic. The WFP allows for access to TCP IP processing at different layers and can be used to filter on incoming or outgoing traffic. The WFP platform can therefore be used by servers and clients but cannot be used by clients . As noted in farther detail below the present application accommodates secure communications between both types of systems by negotiating the type of cryptographic security library to be used for a connection between particular endpoints clients servers or other addressable computing systems generally .

Referring now to an example intranet portion of the network of is shown illustrating specific details of the secured interconnection of computing systems of . In general the intranet portion includes a network such as Ethernet that is communicatively connected to an outside environment such as the Internet via a firewall . Ethernet supports communicative interconnections among a plurality of different types of computers and equipment. For example in the embodiment shown client systems a server printer which could be connected via a client system such as client system or directly to the Ethernet could be communicatively interconnected via the Ethernet .

To manage secure communications among the various computing systems disclosed a Stealth appliance shown as appliance is included within the intranet . The appliance as further discussed below manages licensing and receives connections via the existing kernel based Stealth implementation. The appliance in some embodiments operates using an existing multi level secure transport protocol MLSTP secure communications construct and receives license tunnel requests from endpoints that request licenses for creating other tunnels to other endpoints. The appliance also manages logging of events occurring within the secure connections with log events received via the license tunnel from various endpoints e.g. client systems . An example of a licensing tunnel creation and a license request is shown in below.

Each of the computing systems within the intranet are enabled with a Stealth client . This can include integration of such a Stealth client onto the computing system itself in particular for Windows based computing systems or computing systems implementing IPsec e.g. Linux Apple Solaris etc. . It could alternatively include positioning a Stealth appliance such as appliance between that computing system and the Ethernet that interconnects computing systems thereby isolating that computing system from unsecured communication.

As noted above the computing systems may be of different types or architectures or may also simply be using different versions of an operating system. Accordingly IPsec may or may not be supported on each such computing system or may be supported in a different way. Accordingly each computing system will be enabled with a different Stealth client based on the type of computing system either installed on that system or in the form of a standalone Stealth appliance. Furthermore to allow different computing systems to securely communicate different components may be required to be installed. For example for Windows XP and Windows Server 2003 endpoints an existing Stealth solution is installed using a multi level secure transport protocol MLSTP driver Windows 7 Server 2008 R2 and Windows 8 systems can include this existing MLSTP driver for backwards compatibility purposes but also include integrated therein the IPsec communications stack discussed herein in particular with respect to . Accordingly in some cases a first and second of the computing systems may connect via an IPsec tunnel while each of the first and second computing systems may not be able to connect to the third computing system via IPsec rather an existing MLSTP driver may be required for example due to third computing system executing an older operating system version or being a different type of computing system or otherwise lacking native IPsec support that is compatible with computing systems 

In connection with the present disclosure and as further illustrated in connection with the driver implementations below an auto negotiation process is performed between two endpoints to determine how best to securely interconnect those endpoints. For example where both endpoints support the IPsec based Stealth implementation discussed herein IPsec tunnels will be a preferred method to establish connections between systems. Therefore for IPv6 endpoints a transmitting endpoint will attempt to connect to that remote endpoint using an IPsec tunnel. For IPv4 endpoints the transmitting endpoint assuming it is IPsec enabled will attempt to connect via a preexisting MLSTP tunnel first but if that attempt fails an IPsec based Stealth connection is initiated. If that tunnel creation attempt also fails either of MLSTP or IPsec could be retried again with each retried in an alternating sequence until connection to the far end endpoint is established.

In some instances an endpoint enabled in VPN mode can use the MSLTP Stealth connection over which the VPN tunnel is established. In alternative embodiments the VPN client can call a new driver or its application level interface to establish a secure IPsec based Stealth tunnel.

In the embodiment shown a server such as server has installed thereon one or more applications assisting with operation of a Stealth enabled network including an authorization service and a provisioning utility . The authorization service can be installed on either a MLSTP compatible or IPsec compatible server system e.g. a Windows based system using either Windows Server 2008 or previous versions and executes in the background on that server. The authorization service also stores certificates and keys useable by an endpoint to communicate with other endpoints an example of a key exchange process with an authorization server for example to substitute a new key is illustrated in described below. The authorization service also handles authorization requests received from endpoints as further noted below. The provisioning utility allows IP address and port ranges to be specified by a user and also handles IPv6 addresses for community of interest filters. The authorization service can also be interfaced in some embodiments to a configuration utility which provides an administrative user interface which allows an administrative user to identify each endpoint and define a set of parameters to be used when communicating among endpoints. For example endpoint parameters can include the number of shares a message should be cryptographically split into M and a number of those shares that should be required to recreate the message N as well as a queue depth allowable at an endpoint.

Referring now to a schematic illustration of an example computing system in which aspects of the present disclosure can be implemented. The computing device can represent for example a native computing system within which one or more of systems . In particular the computing device represents the physical construct of an example computing system at which an endpoint or server could be established. In particular in various embodiments the computing device implements one particular instruction set architecture and can be used to execute non native software and or translate non native code streams in an adaptive manner for execution in accordance with the methods and systems described herein.

In the example of the computing device includes a memory a processing system a secondary storage device a network interface card a video interface a display unit an external component interface and a communication medium . The memory includes one or more computer storage media capable of storing data and or instructions. In different embodiments the memory is implemented in different ways. For example the memory can be implemented using various types of computer storage media.

The processing system includes one or more processing units. A processing unit is a physical device or article of manufacture comprising one or more integrated circuits that selectively execute software instructions. In various embodiments the processing system is implemented in various ways. For example the processing system can be implemented as one or more physical or logical processing cores. In another example the processing system can include one or more separate microprocessors. In yet another example embodiment the processing system can include an application specific integrated circuit ASIC that provides specific functionality. In yet another example the processing system provides specific functionality by using an A SIC and by executing computer executable instructions.

The secondary storage device includes one or more computer storage media. The secondary storage device stores data and software instructions not directly accessible by the processing system . In other words the processing system performs an I O operation to retrieve data and or software instructions from the secondary storage device . In various embodiments the secondary storage device includes various types of computer storage media. For example the secondary storage device can include one or more magnetic disks magnetic tape drives optical discs solid state memory devices and or other types of computer storage media.

The network interface card enables the computing device to send data to and receive data from a communication network. In different embodiments the network interface card is implemented in different ways. For example the network interface card can be implemented as an Ethernet interface a token ring network interface a fiber optic network interface a wireless network interface e.g. WiFi WiMax etc. or another type of network interface.

The video interface enables the computing device to output video information to the display unit . The display unit can be various types of devices for displaying video information such as an LCD display panel a plasma screen display panel a touch sensitive display panel an LED screen a cathode ray tube display or a projector. The video interface can communicate with the display unit in various ways such as via a Universal Serial Bus USB connector a VGA connector a digital visual interface DVI connector an S Video connector High Definition Multimedia Interface HDMI interface or a DisplayPort connector.

The external component interface enables the computing device to communicate with external devices. For example the external component interface can be a USB interface a FireWire interface a serial port interface a parallel port interface a PS 2 interface and or another type of interface that enables the computing device to communicate with external devices. In various embodiments the external component interface enables the computing device to communicate with various external components such as external storage devices input devices speakers modems media player docks other computing devices scanners digital cameras and fingerprint readers.

The communication medium facilitates communication among the hardware components of the computing device . In the example of the communications medium facilitates communication among the memory the processing system the secondary storage device the network interface card the video interface and the external component interface . The communications medium can be implemented in various ways. For example the communications medium can include a PCI bus a PCI Express bus an accelerated graphics port AGP bus a serial Advanced Technology Attachment ATA interconnect a parallel ATA interconnect a Fiber Channel interconnect a USB bus a Small Computing system Interface SCSI interface or another type of communications medium.

The memory stores various types of data and or software instructions. For instance in the example of the memory stores a Basic Input Output System BIOS and an operating system . The BIOS includes a set of computer executable instructions that when executed by the processing system cause the computing device to boot up. The operating system includes a set of computer executable instructions that when executed by the processing system cause the computing device to provide an operating system that coordinates the activities and sharing of resources of the computing device . Furthermore the memory stores application software . The application software includes computer executable instructions that when executed by the processing system cause the computing device to provide one or more applications. The memory also stores program data . The program data is data used by programs that execute on the computing device .

Although particular features are discussed herein as included within an electronic computing device it is recognized that in certain embodiments not all such components or features may be included within a computing device executing according to the methods and systems of the present disclosure. Furthermore different types of hardware and or software systems could be incorporated into such an electronic computing device.

In accordance with the present disclosure the term computer readable media as used herein may include computer storage media and communication media. As used in this document a computer storage medium is a device or article of manufacture that stores data and or computer executable instructions. Computer storage media may include volatile and nonvolatile removable and non removable devices or articles of manufacture implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. By way of example and not limitation computer storage media may include dynamic random access memory DRAM double data rate synchronous dynamic random access memory DDR SDRAM reduced latency DRAM DDR2 SDRAM DDR3 SDRAM solid state memory read only memory ROM electrically erasable programmable ROM optical discs e.g. CD ROMs DVDs etc. magnetic disks e.g. hard disks floppy disks etc. magnetic tapes and other types of devices and or articles of manufacture that store data. Communication media may be embodied by computer readable instructions data structures program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term modulated data signal may describe a signal that has one or more characteristics set or changed in such a manner as to encode information in the signal. By way of example and not limitation communication media may include wired media such as a wired network or direct wired connection and wireless media such as acoustic radio frequency RF infrared and other wireless media.

It is noted that although in the embodiments of shown the computing device represents a physical computing system the various endpoints and servers of the present disclosure need not be directly implemented on a hardware compatible system. Rather such endpoints or servers could be implemented within a virtual computing system or virtual partition of a computing system. In some embodiments the endpoints and or servers of the present disclosure are implemented in a partitioned multiprocessor environment with the various partitions in which endpoints and or servers reside being managed by a system virtualization software package. One such system virtualization package is the Unisys Secure Partitioning SPar partitioning and virtualization system provided by Unisys Corporation of Blue Bell Pennsylvania.

A callout driver interconnected to the user level service by an IOCTL interface is used to identify new endpoints that require the establishment of a Stealth tunnel. The callout driver interfaces to a callout application programming interface API which defines the kernel mode interface to the kernel mode filter engine component .

An MLSTPGW driver passes all IPv6 traffic from a physical network interface card NIC to the upper layer for processing. This can be for example based on a registry setting accessible to the MLSTPGW driver indicating that another Stealth security construct is being used by the endpoint. The MLSTPGW driver is generally a filter driver that intercepts all IP traffic and is used to manage communications over MLSTP tunnels. Regarding the prioritization of IPsec vs. MLSTP as noted above in connection with in the embodiment shown the MLSTPGW driver at least initially allows for traffic to flow through that driver in cases where IPv6 is used and where the system on which the driver is installed is at least a Windows 7 or other IPsec compliant device. Initially all IPv4 and IPv6 traffic passes through the MLSTPGW driver and TCP IP stack to the callout driver to be blocked until an IPsec or MSLTP tunnel is established between the peers. The user level service will request the MLSTPGW driver to attempt to establish an MLSTP tunnel for an IPv4 endpoint. This request is made using an IOCTL and the MLSTPGW driver is modified to implement this IOCTL. If an MLSTP tunnel is established the MLSTPGW driver informs the user level service through another IOCTL. If the MLSTP tunnel fails for an IPv4 endpoint instantiation of an IPsec tunnel is attempted as noted above. It is noted that in some embodiments if an IPsec tunnel cannot be established to a remote IPv6 endpoint tunnel formation fails i.e. no MLSTP tunnel may be available for IPv6 .

The callout driver is used to interface with the WFP which is generally native in the Windows operating system of the system on which it is installed. The callout driver sits above the MLSTPGW driver and is also used to intercept all traffic based on how filters are configured in the WFP. The callout driver is a Kernel level WFP callout driver. WFP callout drivers provide functionality that extend the capabilities of the Windows Filtering Platform. Callouts allow the callout driver to examine network data in order to determine if when an IPsec based tunnel should be established. In some embodiments the callout driver is automatically started during system startup and interfaces with the user level service via a set of IOCTLs.

During service start up or initiation of a Stealth connection the user level service adds a provider and sublayer to the WFP system and adds associated callouts with initial filters to the system for both IPv4 and IPv6 . An initial group of filters are added to allow traffic such as loopback IPv4 subnet broadcast IPv6 neighbor discovery as well as PDUs used to control the IPsec tunnels. An additional filter is added to the system so that all other traffic is called out for further examination by the callout driver . A service such as a protocol service described below in connection with then informs the callout driver to enable IPsec based Stealth using an IOCTL. The callout driver enables secure processing by registering the callouts with the filter engine e.g. via kernel mode filter engine component to intercept inbound or outbound connect attempts. In some embodiments the callout driver intercepts inbound and outbound connections and transport layer traffic sent to or received from remote peers and queues the packets to a worker thread for processing.

The callout driver maintains a structure for each remote endpoint it is communicating with along with a global linked list of such endpoint connections. In some embodiments a global hash table is maintained within the callout driver to help search for a connection. Each endpoint connection entry in the list tracks pending connections or accepted received connection requests and a packet queue that wait for an IPSec tunnel to he established. Once the IPSec tunnel is established by the login service the callout driver completes the pending operation and or reinjects the packets back into the data path. The user level service sets up the IPSec tunnel such that once it is established the driver callouts will no longer be invoked for data on this connection.

In general the callout driver performs a process for each packet that is received at the endpoint. Generally the callout driver will permit the packet if it was already previously inspected or block the packet if the service is not initialized or there are no Global Service Events available e.g. for sending IOCTLs to the user level service to handle the received packet . The callout driver will then search its hash table and create an entry. If a Stealth tunnel IPsec or MLSTP is already open the packet is permitted. Otherwise the packet is initialized to be reinserted at a later time and added to a connection list or packet queue and the callout driver then informs the user level service to initialize a tunnel to the remote endpoint identified by the remote IP address.

In operation to initialize a Stealth tunnel e.g. via IPsec the user level service registers call out filters with the base filter engine including various ALE layer and transport layer filters. The system then allows UDP Stealth based port traffic and notifies a user to provide logon credentials e.g. from a windows login manager . The user level service accesses a WGT file which contains community of interest keys associated with the logged in user to determine if the user has rights to connect to a particular other endpoint e.g. an endpoint that is attempting to connect to the current endpoint or to which traffic is directed . At that point driver filters are activated for example via the base filter engine and kernel mode filter engine .

An IOCTL message is passed to the user mode service that includes the IP address of the local and remote endpoints. The user mode service will then respond and process the WGT file to generate session keys for the tunnel to the remote endpoint. A UDP socket is opened to the remote endpoint and session PDUs are exchanged containing keys to be used for communication. If the exchange of session keys is successful the user level service validates the exchange of keys used to generate a shared secret on corresponding endpoints. The shared secret as discussed further below is used to set the IPsec policy for the tunnel to be established. Because the shared secret is unique to each tunnel created it allows for separate security for each IPsec tunnel being established. Pending successful negotiation of an analogous process at the remote endpoint the callout driver then reinjects blocked data into the data path because of the IPsec policy in place that data is then transmitted over an IPsec tunnel to a remote endpoint.

Generally a Winsock interface is used to establish UDP sockets between endpoints for exchanging protocol messages such as the protocol datagram units PDUs discussed below and a Cryptographic Next Generation CNG interface provides a Windows based user mode encryption API to which the various Stealth based systems of the present disclosure can be interfaced. Accordingly a network application shown as network application can communicate with an endpoint while being secured using IPsec or MLSTP tunnels established by the user level service callout driver and IPsec module or MLSTP driver .

In general and through use of the above described connection sequences it can be ensured that the endpoint implementing IPsec based Stealth security will not respond to a remote endpoint without first determining that it is allowed to do so based on review of communities of interest contained in WGT file and based on filter rules defined using the base filter engine and kernel mode filter engine . Furthermore because session keys are used to generate a shared secret between two endpoints in addition to use of communities of interest even endpoints associated with users in the same community of interest will not be able to recognize communications between endpoints that have established a Stealth based IPsec tunnel as noted herein. Additional details and illustration of these connection sequences are discussed in further detail below in connection with .

Referring now to an example block diagram of a system for secure communications at a gateway implementing the internet protocol security IPsec implementation discussed herein is shown. Such a gateway could be used for example to provide IPv6 based addressing and IPsec based security features for an otherwise unsupported endpoint or to act as a gateway between secured and otherwise unsecured portions of a network.

Generally the system includes analogous elements to those in an endpoint labeled with incremented reference numerals as presented in a gateway rather than an endpoint for establishing direct communications from the gateway. However additional directional lines show passage of data traffic through the gateway between a protected Stealth network and a clear text e.g. Internet side network. In the example shown data transmitted between endpoints having IPv4 addresses pass through a MLSTP driver of the gateway and from a parsed network interface to an unparsed network interface . IPsec secured data is received at the parsed network interface and passed through the MLSTP driver as discussed above with respect to MLSTP driver in this case the IPsec secured data is received at a TCP IP stack and routed through an IPsec encryption decryption component installed at the gateway as opposed to the native functionality typically found in an endpoint as discussed above . The now decrypted data passes through the filter engine and exposed to the callout driver via the API . The callout driver can then route the data if appropriate back through the TCP IP stack and to unparsed network interface for communication as clear text. The filter engine in combination with the callout driver and user level service prevents any data from being passed through the unparsed network interface without first being ensured that it is intended to leave the secured side of the gateway.

In particular the protocol service creates the public private key pair and returns a public key BLOB to a prelogon service . The prelogon service wraps each service key in a service enclave and returns the wrapped keys with the other service enclave information i.e. clear text keys IP addresses etc. to the protocol service . The protocol service then unwraps each service key using a private key and imports each service key into the Windows key store for use in establishing IPsec tunnels. In addition protocol service wraps each service key with a public key and forwards these keys with the other service enclave information to the MLSTPGW driver for use in establishing MLSTP tunnels.

The prelogon service handles management of service enclaves used prior to user logon. In particular the prelogon service retrieves service keys from service enclave registry s and stores the enclave information. It then calls through the LPC Windows RPC interface to acquire a public key from the protocol service . Once the service enclave information has been successfully passed to the protocol service the prelogon service calls back into the protocol service to release the public key.

The logon service handles the management of logon processing user authorization local or via an authorization server and user communication via a USSL Applet interface . The logon service is responsible for handling user logon processing for interfacing with a local authorization service for user authorization. The logon service also is responsible for interfacing with the USSL Applet to provide tunnel status and handling enabling disabling of Stealth connections IPsec and MLSTP and Stealth based VPN connections. The logon service can be configured to run in either client mode or server mode. In client mode it interfaces with a Win Logon service to process user session notifications. In server mode it uses the service credentials for user authorization. The logon service supports the use of local WGTs e.g. WGT of in the case of an endpoint or authorization through an authorization service interface such as authorization service .

For authorization via an authorization service the logon service calls into the protocol service to acquire the public key from an RSA 1024 key pair . This public key is then wrapped with a certificate from the authorization server which was stored at the endpoint during endpoint installation. The public key is then passed to the authorization service in the HTTP request. The authorization service unwraps the public key using its private key and then uses it to wrap the user s COI keys and return them to the logon service . The logon service passes the wrapped COI keys to the protocol service which unwraps each COI key using its private key and stores each in the Windows key store for use in establishing the IPSec tunnels. One example of using an authorization service in the manner generally described above to authorize a particular endpoint to establish a secure IPsec tunnel is illustrated in described in further detail below.

The USSL Applet interface is used on endpoints e.g. client systems to display tunnel status for both IPv4 and IPv6 tunnels. IPSec tunnel initiation is managed by the protocol service on the corresponding endpoint. Once COI negotiation has completed via a session PDU exchange discussed below in connection with the Windows filtering platform is used to remove the user level service e.g. user level service of and callout driver e g. callout driver from the IPSec tunnel path. Because of this the data traffic passed over the IPSec tunnel cannot be tracked by the user level service or callout driver . Instead IPSec statistics are gathered for all IPSec traffic via the Windows Filtering Platform and displayed by the USSL Applet .

Referring to generally it is noted that the timing of when a particular endpoint is Stealth enabled may vary depending upon the mode of that endpoint for example in some cases the endpoint may be set to an always on mode in which at startup the protocol service adds initial global filters to the WFP to be used to callout traffic. In an on demand mode the global filters are not added during service startup but rather the protocol service does not enable global filters until after the logon service enables Stealth or a Stealth based VPN.

Referring now to various connection sequences and connectivity states are shown that enable communications between endpoints e g. client systems or between such systems and a licensing appliance e.g. appliance or an authorization server e.g. server . The connection sequences described herein as discussed below ensure that each communication tunnel between endpoints is private to those endpoints even within a particular community of interest. The connection sequences also ensure that for endpoints that are not part of a particular community of interest those endpoints appear dark meaning that they can be addressed but will provide no response to requests for service including responses denying such requests .

In general there are a plurality of different session protocol data units PDUs used to traverse states and are referred to as Session PDUs. Session Session and Session PDU are exchanged during tunnel initialization while Session PDUs are used as keep alives and Session PDUs are used for termination of tunnels. Each of the PDUs generally includes a SCIP header except for Session which includes generally a number of flags defining connection settings as well as a SessionInfo header which defines a remote username start time session identifier and various other options for creation of the secure tunnel. Discussion of each of the PDUs follows.

Session PDUs are sent from an endpoint to begin initiation of an IPsec enabled Stealth tunnel. These PDUs contain a list of the local session keys individually wrapped with each of the COI keys currently available in the WGTs. The encryption ENC key and public validation VAL key are both encrypted with the COI key before being passed in the authorization token seen as AuthToken in below . In addition the private VAL key is used to sign the AuthToken for validation on the remote endpoint. The remote endpoint must successfully decrypt the session keys before it can use the public VAL key for validation of the Sess PDU.

Session PDUs are sent and received on the Stealth UDP port so that they pass through the callout driver undetected. In example embodiments each token entry in the Session PDU is 128 bytes long so that no padding is required during encryption. In addition the count of communities of interest is included to verify the length of an authorization token on the remote endpoint.

Session PDUs are sent from a receiving endpoint in response to a Session PDU that was successfully verified and decrypted using a COI key from the WGTs e.g. WGT . The Session PDU response contains an authorization token with the local session keys of the responding endpoint wrapped with the COI key that matched the COI key in the Sess PDU received as retrieved from the WGT of the receiving endpoint. In addition in some embodiments the Session PDU contains a signature generated using a SHA 384 HMAC across all of the fields of the Session PDU excluding the signature field and generated using the local VAL private key. This allows for creation of a public private key pair that can be used in a Diffie Hellman key agreement arrangement. The public key can be returned to the requesting endpoint in the Session PDU. Once the originating endpoint U receives the public key of the second endpoint U it uses that key along with its own ECDH P384 private key to generate the shared secret. In some embodiments the Session PDU also contains a SCIP header and SessionInfo header. Session PDUs can also be sent and received on the Stealth UDP port so that they pass through the callout driver undetected.

Session PDUs are sent from an endpoint in response to a Session PDU that was successfully verified and decrypted using the local session keys. The Session PDU response contains a signature as well as a SCIP Protocol Header and a SessionInfo header which contains the responding endpoint s U s corresponding public key which the opposing endpoint U can also use in an analogous manner to generate the shared secret at U for IPSec tunnel establishment. Upon completion of the Session PDU a Diffie Hellman key agreement is performed allowing for generation of a shared encryption key useable for IPsec communications that is not actually exchanged but rather based upon the generated and agreed upon shared secret. As with Session and Session PDUs Session PDUs are sent and received on the Stealth UDP port so that they pass through the callout driver undetected 

Session PDUs or keep alive PDUs seen in as IDLE are periodically transmitted from a Stealth endpoint as a keep alive on an open IPSec tunnel. Each Session PDU contains the SCIP header Age Lifetime and TTL and SessionInfo header. The Session PDU does not contain the user key in the SessionInfo header. This is because the Session PDU is not encrypted instead it is sent over the IPSec tunnel. This allows the remote endpoint to detect that a tunnel has terminated without a Session PDU i.e. due to a network failure because keep alives are no longer being received. Session PDUs are sent and received on the IPSec tunnel using the IPSec UDP port for Stealth traffic so that they pass through the IPsec tunnel.

Session PDUs or termination PDUs seen in as TERM are sent during orderly termination of an IPsec based Stealth tunnel. An example of orderly termination is when the Stealth service is disabled via the USSL Applet or during a user log off. The Session PDU contains a reason code and description to explain the termination reason. The Session PDU is encrypted and signed in the same way as the Session and or Session PDUs. As with the other PDUs TERM PDUs are sent and received on the Stealth UDP port so that they pass through the callow driver undetected.

With that background the various states in state diagram are traversed as follows. Generally upon receiving an IOCTL or data to be transmitted via a Stealth enabled connection the created state is entered indicating that a connection entry has been initialized for a particular tunnel to be created. Upon sending or receiving a Session PDU a pending open state is then entered. The endpoint remains in the pending open state if a timeout occurs. If a Session PDU is received the tunnel is placed on an open state . The tunnel then remains in the open state while Session PDUs are received and Session PDUs are sent.

If while in the pending open state the endpoint sends a Session PDU the endpoint tunnel enters a pending final state in which it remains through timeouts or until either 1 a TERM Session PDU is received in which case the endpoint tunnel switches to a closed state or 2 a Session PDU is received with a different SessionID i.e. a SessionID less than the SessionID regenerated by the local endpoint to prevent collisions as noted in or 3 or Session PDU is received in which the endpoint tunnel changes to the open state . If at any time a TERM Session PDU is received in any state of states the endpoint tunnel enters a closed state .

It is noted that in some embodiments the SessionInfo header may include information regarding IPsec tunnel attributes which may be intercommunicated between two endpoints. This can for example allow the endpoints to negotiate at least a portion of the attributes of a given IPsec tunnel. Example tunnel attributes that may be varied or programmable could include for example the specific type of encryption used e.g. AES 256 a specific authentication mechanism e.g. SHA 256 AES GCM whether to use Elliptic Curve cryptography and the specific IKE version used could all be individually customized for a particular IPsec tunnel. These could be exposed to a user for setting for example by using the protocol service which could allow a user or user level application to set these and additional tunnel attributes. By allowing such tunnel attributes to be changed on a per tunnel basis additional flexibility is provided into the system for including computing systems having various IPsec implementations to be integrated e.g. having different operating system implementations of IPsec as may be present on Windows Solaris Linux Macintosh or other types of machines supporting IPsec . This ability to change settings in particular at the application level i.e. in user mode at protocol service also allows these machines to be integrated without associating an IPsec based Stealth appliance with each such nonstandard computing system to ensure compliance.

Referring now to various message flows are shown illustrating different effects of transmission of PDUs and associated data between endpoints or between an endpoint and an authorization server to enable IPsec based Stealth communication tunnels to he created and used As an initial example is a message flow diagram illustrating a successful session initialization process according to an example embodiment of the present disclosure. In the message flow diagram as shown an initial login enabling action taken at both endpoints U U is followed by a Tunnel INIT IOCTL message at U. U creates encryption key ENC and public validation key VAL and encrypts ENC and VAL with COI keys present at U. These keys are added to an AuthToken which is also signed by VAL. A Session PDU is then transmitted to U and a state is updated to the pending open state .

At U when the Session PDU is received for each COI and token entry the token is decrypted with a COI key and the U encryption key and validation key are both imported. U s encryption key and validation keys are then created as well as an Elliptic Curve Diffie Hellman key. A Session PDU is built and transmitted back to U.

At U upon receiving the Session PDU the received PDU is decrypted with U s encryption key and for every COI in the WGTs if one can be used to decrypt the AuthToken the encryption key and validation key of U are imported. The AuthToken and Session PDU are validated using the U validation key and U s Elliptic Curve Diffie Hellman public key is also imported. A U Elliptic Curve Diffie Hellman key pair is then created and a shared secret is generated based on sharing of the U and U ECDH public keys respectively once COIs are validated and an IPsec tunnel is opened. U then changes the tunnel state to an open state and generates a Session PDU to be transmitted to U.

At U the Session PDU is decrypted with U s encryption key and the Session PDU and validation key are validated. The U Diffie Hellman key is imported and the same shared secret that was generated at U is then generated at U. U then opens an IPsec tunnel and the state of the tunnel at U becomes an open state representing an established IPsec tunnel.

As noted above in connection with endpoints can also communicate with an authorization service such as authorization service on server for receiving authorization from that server and receiving COI keys that are to he distributed among the endpoints. Accordingly is a message flow diagram illustrating a key exchange with an authorization server according to an example embodiment. In this message flow diagram the authorization service represented by AuthServer delivers COI keys to an endpoint U in response to U self identifying to the authorization server. In particular U transmits an HTTP request to AuthServer which includes transmitting a USSL RSA1024 public key as a key blob to the AuthServer which decrypts the request with its private key. Each COI key to be returned to U is then wrapped in the USSL public key and returned to U which unwraps and imports each COI key and also transmits to the MLSTPGW driver the COI keys wrapped with a Secure Parser public key generated by the MLSTPGW driver . Accordingly U will then have received its COI keys for both IPv4 and IPv6 communications using either MLSTP or IPsec security constructs.

Referring now to various filter object classes are disclosed that can be used by the IPsec policy manager that can be instantiated and used to manage filters applied at a secured endpoint for example to manage allowed traffic to from the endpoint in the base filter engine e.g. engine and kernel level engine . As seen in a block diagram of an arrangement of global filter objects is shown alongside the relationships between the objects used to manage global filters. For example CIPSecPolicy contains a plurality of Cfilter instances of both IPv4 and IPv6 varieties . Each CFilter instance can be used to create and manage filters added to the Windows Filtering Engine to enforce the policy for the Stealth tunnel. Each Cfilter instance points to the next CFilter as well as its own CConditions . CConditions corresponds to an array of conditions accessible via a Windows API.

As seen in an arrangement of secure tunnel filter objects is illustrated. The use of conditions on IPSec tunnels is limited and does not allow multiple protocols or multiple ports to be defined on an IPSec tunnel. Because of this restriction the IPSec tunnel contains limited conditions that allow all traffic between the two endpoint of the IPSec tunnel but excludes the session PDUs transmitted using the Stealth port.

In order to deny access to traffic not allowed by a COI filter the COI filter is used to build blocking filters in the WFP between the two IPSec endpoints. These blocking filters are in some embodiments given a higher weight in the WFP than the IPSec filters so that they are applied to traffic between the two endpoints before the IPSec tunnel filters. This prevents traffic excluded by the COI filter from traversing the IPSec tunnel.

In the embodiment shown the arrangement includes a CHashTable which is the hash table for creating finding querying and or deleting a Stealth tunnel and contains an array of 4096 hash table buckets. In the embodiment shown each contains a linked list of CStealth entries . Each CStealth entry contains a pointer to a CIpSecTunnel instance which is created from a CStealth entry and includes a single CIpSecTunnel once it has completed the session exchange. The CIpSecTunnel instance includes the Security Association for the IPSec tunnel a linked list of CFilter instances that describe the IPSec tunnel filters and related COI filters. Each CIPSecTunnel instance contains a list of Cfilter instances and associated CConditions . The CStealth entry also contains a pointer to the CSessionKey and a CTuple pointer . The CTuple pointer is used to construct Session PDUs as described above and contains the last tuple stored in the Session PDU. Once a session exchange has completed successfully the CTuple pointer points to the tuple i.e. the COI matched on the remote endpoint.

The CTupleTable object contains the tuples lists for either the service enclaves or the currently logged on user. The CTupleList contains the number of tuples in the current list as well as pointers to the first and last CTuple instance in the list. The first tuple is used to start the processing for Session PDUs and the CTuple pointer in the CStealth object is used to pick up with the next tuple when the initial COI token contained the maximum number of COIs. The last tuple is used to add additional information from the XML to the tuple currently being processed in the XML file.

Referring to overall it is noted that in addition to the above functionality it is apparent that specific applications may be made available using the IPsec implementation of Stealth as discussed herein. For example the set of PDU definitions can be extended to provide additional functionality. In some embodiments an additional set of PDUs could be exchanged between the AuthSvc and endpoint e.g. endpoint U to allow an authorization service to remotely control the endpoint or at least remotely administer the Stealth based settings at that endpoint. Additionally because of the user level definition of Stealth in the IPsec implementation additional user applications can be developed to control different aspects of the implementation such as for VPN associated with particular COIs or other applications. Further examples can include secured remote access to resources e.g. storage applications virtualized desktops etc. at a computing system or other endpoint having a common community of interest.

Still referring to generally it is noted that the IPsec based system of the present disclosure presents a number of advantages over both native IPsec and existing Stealth solutions. For example due to the partially user mode implementation of the IPsec based Stealth solution migration to different IPsec constructs is much simpler. Furthermore in combination with the feature of configurable IPsec parameters the present application allows Stealth to be installed on many systems that would be otherwise incompatible with the Stealth solution while maintaining negotiation capabilities allowing fallback to a proprietary security protocol as needed. Simplified application level security controls and truly dark endpoints to those entities or persons outside of the community of interest to that person provide still further advantages of the present system.

The above specification examples and data provide a complete description of the manufacture and use of the composition of the invention. Since many embodiments of the invention can be made without departing from the spirit and scope of the invention the invention resides in the claims hereinafter appended.

