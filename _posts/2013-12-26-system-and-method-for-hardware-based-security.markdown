---

title: System and method for hardware based security
abstract: An asset management system is provided, which includes a hardware module operating as an asset control core. The asset control core generally includes a small hardware core embedded in a target system on chip that establishes a hardware-based point of trust on the silicon die. The asset control core can be used as a root of trust on a consumer device by having features that make it difficult to tamper with. The asset control core is able to generate a unique identifier for one device and participate in the tracking and provisioning of the device through a secure communication channel with an appliance. The appliance generally includes a secure module that caches and distributes provisioning data to one of many agents that connect to the asset control core, e.g. on a manufacturing line or in an after-market programming session.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09183158&OS=09183158&RS=09183158
owner: Certicom Corp.
number: 09183158
owner_city: Mississauga, Ontario
owner_country: CA
publication_date: 20131226
---
This application is a continuation of U.S. application Ser. No. 13 131 019 filed on Jan. 13 2012 which is a National Stage application under 35 U.S.C. 371 that claims the benefit of PCT CA2009 001686 filed Nov. 24 2009 which application claims the benefit of U.S. Provisional Application Ser. No. 61 193 391 filed Nov. 24 2008 and U.S. Provisional Application Ser. No. 61 224 801 filed Jul. 10 2009. This application claims priority to U.S. application Ser. No. 13 131 019 International Application Serial No. PCT CA2009 001686 and U.S. Provisional Application Ser. Nos. 61 193 391 and 61 224 801. The entire disclosures of these related applications are incorporated herein by reference.

There are various elements in a manufacturing process that can create what is considered waste . Such elements may include defects inventory excessive redundant etc. over production over processing movement transportation and waiting. Additionally there are costs that can be attributed to external causes such as cloning copying technology transfer and theft both physical and IP theft .

Also at the heart of a wide variety of consumer and commercial products today is a System on Chip SoC where many features are integrated on a single silicon die. Manufacturers may use the same SoC in different platforms with various features enabled disabled in order to differentiate the final products in the market. Unauthorized enablement of features represents significant revenue loss to companies.

Traditional methods of feature programming include outright customization of the SoC silicon through different mask sets the use of silicon fuses that may be selectively blown to control a feature the use of jumper wires on motherboards and the loading of different components and firmware per product.

The provisioning of features occurs in a variety of manufacturing locations whose facilities perform a range of production steps including wafer fabrication for chips assembly packaging test and system integration where components and firmware are integrated into a final product or assembly. These manufacturing locations are typically overseas and out of the control of the semiconductor company outsourcing the contract manufacturing to these facilities. As a result there is little reason for the semiconductor company to trust the distributed manufacturing facility to manage the distribution and collection of proprietary and sensitive data such as feature provisioning commands content protection key data software firmware code images test results and yield reporting data.

Given the value such SoCs have and the trend for semiconductor companies to outsource manufacturing assembly and distribution of their products several new problems begin to emerge due to the lack of trusted manufacturing processes.

A problem with traditional approaches to feature programming is that they need to be done in a trusted environment can be costly to make changes and typically cannot be readily undone.

Also it has been recognized that counterfeit or discarded chips are being treated as new products with no way of differentiating between legitimate and illegitimate parts. In some cases defective chips designated to be destroyed are somehow being recycled back into the production line while good devices are siphoned off and replaced by cheap competitor or non compatible chips. As a result chip vendors are beginning to see their brand being diluted while the cost of warranty increases as these unofficial chips are returned for failing to meet specification.

Another problem arises when considering the proliferation of content protection schemes designed to protect the commercial rights of digital media owners. These content protection schemes require that unique per device key data be programmed into each device somewhere in the manufacturing process. As a licensee of these content protection schemes semiconductor manufacturers become liable for the content protection key data and need to protect that data as it is distributed throughout their untrusted manufacturing operation.

As semiconductor manufacturers begin to leverage the distributed manufacturing model they lose direct control of proprietary device and manufacturing data to the distributed manufacturing operation. In addition to content protection key data other outbound forms of proprietary data like feature provisioning commands software firmware instruction machine code and device personalization data must be distributed and stored throughout the untrusted manufacturing operation. Proprietary manufacturing data also needs to be stored at and collected from the untrusted distributed manufacturing operation by the semiconductor company. The inbound proprietary manufacturing data could exist as test reports programs process data and yield management data.

Opportunities to increase the bottom line in a given manufacturing process may exist by obtaining competitive advantages through the secure management of digital assets. In the following a system is described that provides a solution framework that may be used to reduce the above noted wastes and obtain competitive advantages in various applications. The system to be described comprises several software and hardware components that are deployed and integrated into the manufacturing process across multiple physical locations. In this way a manufacturing platform is created that can provide a comprehensive infrastructure solution.

The manufacturing platform noted above may be referred to herein as an asset management system AMS and will be denoted by numeral as shown in . The AMS is a customizable solution that can be adapted to accommodate various services. For example as discussed below the AMS can be configured to perform one or more of serialization key injection and feature activation by controlling the provision of corresponding assets. An asset may therefore refer to any digital data that is to be added applied to associated with or otherwise bound to a device . A device can be any component or item that is capable of utilizing such assets. For example a device may represent a chip circuit board electronic consumer device computer processor memory etc. The AMS creates a control channel to control the provision or injection of an asset into a device and an audit channel to enforce the collection of logging data to track the distribution and use of the assets. The components of the AMS which will be described below can be distributed globally implemented locally or any configuration comprising both remote and local components. The AMS enables a company to manage and control sensitive manufacturing processes across a global outsourced manufacturing environment.

The AMS comprises one or more controllers which operate as main servers and can be located at the headquarters of an electronic device manufacturer to remotely control their operations at any global location. The controller can communicate remotely over the Internet or other network not shown to control one or more secondary or remote servers herein referred to as appliances . The appliances can be situated at different manufacturing testing or distribution sites. The controller and appliances comprises hardware security modules HSMs to perform sensitive and high trust computations store sensitive information such as private keys perform other cryptographic operations and establish secure connections between components. The HSMs are used to create secure end points between the controller and the appliance and between the appliance and the secure point of trust in the asset control core ACC embedded in a device . The HSM can be a standard off the shelf component that provides the ability to add a functional module FM comprising source code to perform additional secure operations. For example as will be explained further below the AMS enables the metering of credits for assets that are consumed and the HSM when utilizing the FM allows such metering to be performed securely within the secure boundary created by the HSM . The use of the FM provides greater flexibility in which operations can be performed in a trusted and secure manner e.g. in addition to encryption and signing. The FM also provides greater flexibility in which protocols can be utilized e.g. the ECMQV protocol used to communicate with the ACC discussed later .

The controller also provides a graphical user interface GUI to enable administrators operators and other users to interface with the controller the appliances and the wider AMS . The appliance communicates with one or more agents wherein each agent is integrated into a test script or other production routine using an agent application programming interface API and in some embodiments a daemon API that places the agent s role in a separate process outside of the tester and its application see discussed later . The test script or production routine is typically a custom application that is loaded onto a tester on a manufacturing line. It will be appreciated that the term tester may represent any manufacturing or production equipment that is used to inject or otherwise provide an electronic asset to a device . Typically an appliance is located at a production site which may be in the same physical location as the tester or may instead be remote thereto and connected over a LAN WAN or other network not shown . As illustrated in the appliance can be deployed in a redundant architecture i.e. with additional appliance to ensure that if the primary or master appliance malfunctions or goes offline the additional appliance is provisioned to take over and minimize production downtime. In some embodiments the AMS may utilize an ACC embedded on the device for establishing secure communications between the appliance and the device through the agent .

Using the AMS a system of factory provisioning can be created and deployed which can lead to a reduction in revenue loss and can open new revenue sharing opportunities with partners and downstream customers. The AMS can also improve overall security and brand protection throughout the manufacturing process in particular when outsourced contractors are used to produce high margin devices. Such revenue loss reduction in the manufacturing and distribution processes can be accomplished by using the AMS to help prevent unauthorized activation of features in semiconductors and other electronic devices reducing over production reducing inventory and supply chain costs enabling strong built in revenue and brand protection measures and opening new opportunities to profit from after market revenue potential.

A number of assets are generated acquired or otherwise imported by the controller and the assets are bound to the product which creates an association between the asset and product such that application of the service injects or adds the asset to the product and ultimately one or more devices being produced for that product. The product is then bound to an appliance . The product can also be bound to more than one appliance such that the AMS can be configured to distribute assets of the product across the appliances . If the same type of device is being produced at different facilities different products can be created one for each location. For example a device may be produced in several geographical locations each having an appliance at a different production facility. A product may then be created for each facility and bound to the corresponding appliance . It may be noted that an appliance can service more than one agent at more than one tester and thus more than one product can be defined for the same appliance .

The controller then provides the products and corresponding assets to the appliance and these assets are stored and the products thus provisioned at the appliance . The controller meanwhile logs the event of sending the products and the assets and waits for an acknowledgement from the appliance of successful receipt and storage of the assets. The appliance is configured to communicate with at least one agent . The agent is configured to utilize the assets in a production or distribution stage. The agent thus requests assets that it needs to perform this stage. The appliance meters and obtains an appropriate number of assets and logs this event to record the allocation of assets to a particular agent and thus a particular tester . The assets are then provided to the agent . The agent may then begin a loop that includes applying an asset and logging this event for each device that it operates on. It can be seen that when an ACC is used an exchange with the ACC is performed details of which are provided below. At some point e.g. upon hitting a log threshold the agent provides a set of agent logs to the appliance and the appliance stores the logs. In other embodiments the appliance may request logs from the agent . The controller at some later point e.g. during a synchronization operation then requests logs for products associated with the appliance and the appliance logs and agent logs both stored by the appliance are provided to the controller . The controller may then store the logs and make them available for auditing and other post processing or analyses of the data contained therein. By controlling the distribution in one direction and enforcing the logging of events and collection of same in the other direction the AMS is able to provide control over the manufacturing process.

As discussed above the AMS can be configured to provide various services such as serialization key injection and feature activation. These services can be implemented using the control and auditing channels exemplified in general in . In order to configure the components of the AMS for these various services the controller appliance agent and ACC should have certain capabilities. Further detail of these components will now be described making reference to .

The controller is shown in greater detail in . The controller can be implemented as a security hardened rack mounted system which can be accessed through a web interface from a standard web browser . As seen in the controller includes the GUI which can be accessed by a web browser at the controller or remotely . The GUI sits on top of a web server that utilizes a controller daemon to communicate securely denoted by S with the appliance s and typically without security denoted by U with the database . A reporting tool can also securely access a relational database to obtain logging and other data for the purpose of generating reports. Service requests from the reporting tool or any similar application can be made to access data in the database . A database schema is utilized for efficient storage of logs efficient storage of data as required by service modules and for efficient lookups of data as required by the service modules. Custom log data from all services modules can be exported from the database . Before an appliance is deleted the controller should synchronize with the appliance to ensure that all logs have been collected. The controller in this example also supports a command line interface CLI utility that operates with the controller daemon . The CLI utility if utilized should provide similar functionality as the GUI .

The controller synchronizes appliances automatically at specified time intervals to make sure that any service related assets are at their specified maximum amounts i.e. the controller ensures that the appliance has the assets it needs to operate as intended. A read only sync mode can be provided to query current credit levels without topping up any credits. The synchronization operation can also be used to send appliance configuration settings and to retrieve logs from the appliance as illustrated in . This enables the AMS to support high speed manufacturing at each production site without interruption if connections are temporarily lost. The controller can also issue alerts to specified e mail addresses to inform operators of conditions that could stop production ideally before those conditions result. The controller issues an alert under several circumstances such as when the controller is unable to contact an appliance if there are any errors when the controller sends data to an appliance and vice versa when a synchronization operation has failed when the number of assets in an appliance reaches a specified warning level when the free disk space on an appliance reaches a minimum and when an appliance has blocked a connection from an agent because the agent IP address is not in the list managed by the appliance . The management of these alerts can be performed through the GUI described in more detail below.

The controller is also used to monitor all jobs running in the AMS such as synchronization operations and other long running tasks the status of which can be monitored and their progress logged. Job information can be made available in the GUI . The controller also enables operators to add and remove user roles. User roles can be assigned different levels of permission to access each of the components of the AMS . The logs generated by the AMS are stored in the relational database .

The controller in this example runs on server hardware e.g. a Dell 2950 PowerEdge 2U rack mount server using a 2x Intel Xeon quad core 5300 processor 3 GHz. The controller can also use a 110 220 V 750 W redundant power module a DVD ROM dual gigabit NICs and a PCIe riser. The controller requires initial provisioning e.g. by an export PKCS10 request for HSM and SSL certificates signing the certificates by a device certification authority CA and importing the SSL and HSM certificates into the HSM . It can be appreciated that any identity certificates unique to each HSM can also be used. The controller should enable general settings to be configured such as name and SMTP settings for email alerts. Support for multiple user accounts should be provided and a per user permissions matrix can be used to allow access to various parts of the AMS to be granted or denied. In this way different user roles can be defined and different permissions given to each user role on a per module basis. The permissions matrix should be configurable such that a customer can define such permissions and define the number of user roles to differentiate between users. The controller enables and disables service modules to enable different service products to be defined e.g. for serialization key injection feature activation etc. The controller can also configure general settings for an appliance settings such as name manufacturer location IP address port number socket retries socket timeout send receive block sizes and list of agents authorized for that appliance .

The controller synchronizes with each appliance at configurable time intervals e.g. every 30 minutes. However the controller also enables an operator to force a synchronization immediately if this is desired before the next scheduled sync. The controller provides control over the AMS and thus can authorize new appliances before they are added. When shipped from a supplier the appliances should then be in a state requiring such authorization before use. Other provisioning of the appliance by the controller can also be performed once authorization has completed successfully. The controller also implements a credit system in which the controller issues credit to appliances . Whenever an appliance consumes an asset by providing it to an agent as shown in the credit is decremented. The operator can define warning minimum and maximum levels and if the current credit on the appliance is less than or equal to the warning level the controller issues an alert. If the current credit on the appliance is less than the minimum level the controller tops up the credit to the maximum level. If the appliance runs out of credit it can no longer provide assets to the agents . The credits should be allocated per appliance rather than per a service module in general.

As noted above the controller monitors a list of jobs for each appliance . This creates a multithreaded design which allows each appliance to be serviced independently of the others. In addition jobs on each appliance may also be performed concurrently and independently of the others. This allows multiple UI requests to be handled by separate threads as well as multiple appliance connections to be handled by separate threads such that communication with one entity does not disrupt communication with another thus increasing the parallelism of the AMS . The health of each appliance is also monitored including the free and used hard disk space free and used memory health of other hardware components like the HSM date time of last communication with the controller and date time of last communication with each agent . The controller provides a ping utility to check the network liveness of the appliances which uses the secure communications channel between the controller and the appliance . A time synchronization utility is also provided to synchronize time on each appliance with the controller to ensure that the system time and the HSM time on the controller and appliances are specified in UTC and are the same.

The controller should also provide a process to disable appliances from servicing agents . Appropriate warnings and confirmation can be provided as such an action may interfere or even stop a manufacturing line. When disabled appliances should continue servicing the controller . For example the ping utility should still work when the appliance is disabled. This functionality allows an operator to control their manufacturers through the appliances in the event that anomalies are detected and remedial action required. E mail alerts can be generated to flag issues that may potentially stop the manufacturing line and multiple e mail addresses can be specified so that all interested and affected parties can be notified. The controller should also be able to automatically and manually trigger a backup of itself. In the event of hardware failure or other disasters it should be possible to restore the controller from a backup to new hardware or to existing hardware.

Remote upgrades to appliance software including HSM code as well as local upgrades of controller software including HSM code are also enabled by the controller . The controller manages a list of agent IP addresses and subnets that are allowed to connect to each appliance and enables service requests from the GUI and the CLI utility .

The appliances are typically used in redundant pairs as shown in for failure detection and failover. With redundant appliances each appliance can be given a similar quantity of assets with each set having different values. Therefore if one appliance fails the agent can still obtain assets from the other appliance without risk of having overlapping assets in particular where assets must be unique. The appliances should also be security hardened rack mounted systems. Further detail of an exemplary configuration for an appliance is shown in . The appliance comprises an appliance daemon for controlling communications between the controller and the agent to provide a secure communication channel and an appliance relational database for storing logs and other data. As discussed above appliances can be located at a test location third party manufacturer assembly plant or any production or distribution location. One appliance serves one or more agents and appliances can communicate through one or more agents with an ACC if used. Controller to appliance communications should be secure e.g. using an SSL connection protected and mutually authenticated. All issues of assets from an appliance to an agent are recorded in activity logs. When these logs are collected by the controller they are saved in the database and can be viewed in the GUI s reports view as discussed later.

When a new appliance is added to the AMS it is in an off line state. The appliance is then activated in order to be used. Once an appliance is active it still needs to be synchronized before it can begin producing services. illustrates the various states of the appliance .

The appliance can run on hardware that is similar to the controller and all high trust computations will take place inside an HSM . The appliance has at least one HSM but in some embodiments may support more to improve performance of cryptographic operations such as ECMQV use of ECMQV discussed later . Appliances should be provided in pairs for redundancy and high availability. Both appliances in a redundant pair should always be active as the agent may connect to either one. Both appliances are configured on the controller separately. It may be noted that the operator should ensure that both appliances have similar configurations in terms of assets. From the point of view of capacity planning each pair should be considered as one appliance for example you can only count on the throughput of the pair to be no more than the throughput of a single appliance . An export PKCS10 request from the HSM can be made for the SSL HSM and ACC certificates and the certificates should be signed by a device CA. The certificates are then imported into the HSM .

When the appliance is interacting with the tester high performance is paramount to minimize test time. Protocol optimizations should therefore be made where possible. For example ephemeral public keys can be pre generated in the HSMs for use in the appliance ACC protocol. Communications with the controller for conveying custom data and log data should also be efficient so as not to impact the performance of the appliance in its interactions with the agent . The appliance handles service requests from the controller and the agents using the appliance daemon and uses multiple threads to allow controllers and agents to be serviced independently of each other in the same way as the controller can operate in parallel using multiple threads. In this way the controller is given a separate thread and each agent is given a separate thread. Schema for the database should be designed for efficient storage of logs for efficient storage of data as required by various service modules and for efficient lookups of data as required by the service modules.

The agents shown in are software libraries and each agent is integrated into or with a customer s test program or script a custom application that is loaded onto a tester a computer configured to test the devices on the manufacturing line. Where applicable the agent communicates with an ACC or a soft ACC . When configured to utilize the agent API the agent API makes requests for assets to appliances and send logs of used assets back through a secure SSL connection. In addition to the agent API the AMS supports the use of the daemon API which spawns a separate process namely the daemon that retrieves assets from and provides assets to an appliance reducing some of the work being done by the tester application . illustrates a configuration for the agent utilizing the agent API . The agent API allows the test application running on the tester to connect to an appliance to retrieve assets and to return logs to the appliance . It can be seen that the agent API is integrated directly in the test application which gives complete control over how and when assets and logs are transferred between the tester and the appliance . As seen in the agent API obtains an asset data package from the appliance as well as any log request . The agent API also provides an asset request to the appliance and provides requested log reports .

Turning now to the daemon API can be used instead of the agent API to offload responsibilities for managing assets and logs. As shown in the daemon API is integrated into the test application to enable it to communicate with a separate process the daemon that acts as an intermediary between the test application and the appliance for managing the exchange of asset data packages log reports asset requests and log requests . The daemon API provides a simpler interface and can be configured to run the daemon as a background process. As shown in the daemon API provides an interface with the test application to obtain assets as they are needed and obtain log data as it is generated during or at the end of each test. The daemon API runs the separate daemon to host the agent API for the purpose of obtaining assets and providing log reports to the appliance to avoid the test application having to constantly connect to the appliance during the testing process thus saving time. The daemon can request batches of assets at a time using the agent API and deliver assets as they are needed to the tester through the daemon API such that assets are always available to the tester without having to connect to the appliance . In this way the test application only needs to interface and thus communicate with the daemon API for obtaining an asset and for providing its log data which is then packaged into a log report by the agent API on the daemon . The daemon maintains an asset cache to store batches of assets for subsequent distribution to the tester as needed and a log cache to store log data output by the test application as tests are completed to be organized in the log reports . The daemon API can also have a resource management subsystem RMS configured for independently implementing and registering resource management processes with the daemon . In this way users can implement their own resource management process with their own directives to make decisions when to fetch assets send back logs etc. and can associate this process by name with a particular product profile.

The use of the daemon and daemon API as shown in provides several advantages. By having the daemon maintain or cache the connection with the appliance the test application does not need to repeatedly request a new session thus saving time which is critical in a testing environment. Also the daemon can utilize thresholds to control how many assets it stores in the asset cache . For example a low threshold when crossed can cause the daemon to utilize the agent API to separately obtain a new batch of assets from the appliance without disrupting the testing procedure and while continuing to forward the assets that it still has. Also it has been found that when multiple assets are provided by the appliance directly to the test application for example when sending a batch of keys if there are leftover assets on the test application when it terminates these assets can be lost as they may be wiped off the tester s memory. In this case the AMS would be wasting assets and one or more entities would lose revenue or have to absorb the cost. By separating the daemon from the test application as shown in in situations such as this the daemon and the asset cache would survive the test application and thus no assets would be wasted without a chance to recover them. Leftover assets may thus be marked as wasted if the daemon shuts down and a log report can be generated and returned to the appliance to ensure that leftover quantities can if the applicant permits be credited back to the customer. In other embodiments leftover assets can simply be maintained for the next instance of the test application

The daemon API can be used to create a standalone application as shown in or can also be embedded with the test application in other embodiments. The daemon API should be used to offload the management of the assets and the log reports in the test application . The daemon API can be created in client or server mode. In server mode it connects to the appliance and automatically manages the retrieval of assets and the sending of log reports . In client mode it connects to an already running server mode daemon application for AMS assets and logs. There can also be an auto mode where the daemon API uses client or server mode depending on whether or not another instance of the daemon is already running. The daemon API uses text based configuration directives for the management of AMS products or assets and logs. These directives can be read from a file or from memory at compile time. The configuration directives include one or more product profiles. A product profile contains the name of the AMS product the connection credentials for logging into an appliance the resource management process and the process settings. The resource management process is used to manage the assets and logs of the product associated with a profile. The process includes configurable directives for the asset top up levels min asset and max asset and the threshold level at which logs are automatically sent to the appliance max log .

Since the appliances are typically delivered in pairs the agent should be configured with the IP addresses of both appliances and fail over from one appliance to the other in case of appliance failure. The agent should report any errors for example if the agent is unable to connect to one of the appliances . In the case of connection errors the time the agent waits before failover to the other appliance should be configurable.

The ACC is a small and efficient cryptographic security engine that is integrated into a chip s design. The ACC is integrated into the device being manufactured and thus would be established in parallel but separately from the AMS . The AMS can be used with or without the ACC depending on the application. For example serialization and key injection may not require the ACC but the feature activation service module typically does. However the ACC can be used in applications involving serialization and key injection.

The ACC is typically embedded in a SoC die which is then packaged into a chip which is mounted on a printed circuit board PCB and eventually assembled into an electronic device . Every chip that has an ACC can be registered and logged in the controller s database as soon as it has passed wafer testing which in turn can track every chip manufactured that underwent wafer testing. The ACC has a set of output ports and evaluating the aggregate of these outputs indicates which features are to be enabled and which are to be disabled. Once assembled the ACC can still serve as a root of trust on the ultimate device .

The ACC is designed to manage access to non volatile memory NVM and to protect certain regions of the NVM from being accessed by unauthorized agents . The ACC can provide self contained generation of a unique device ID UID used to uniquely identify the ACC . The ACC can also provide self contained generation of keys used to open up a secure communication channel with a trusted server. The ACC should ensure that the enabling and disabling of features are done using trusted equipment by trusted sources and the ACC should be able to initiate or disable device self tests and heath checks to make sure the device has not been tampered with. The ACC can also lock out the device whenever too many invalid commands are issued. The ACC is used to process commands from the appliance and can be programmed to shut itself off if it detects a specified number of illegal commands. The ACC should be designed to work in any electronics manufacturing test environment since the security features of the AMS do not necessarily rely on being able to trust the data link between an appliance and the ACC . Instead security is built into the communications protocols using cryptography. As a result the AMS provides the ability to allow provisioning to occur in a secure auditable manner anywhere from the wafer fabrication to the ODM to the OEM to the user.

In order to secure the ACC to appliance communication channel the ACC uses an asymmetric cryptography scheme for key exchange and symmetric key cryptography to transfer messages between it and the appliance . The asymmetric cryptography scheme uses a public key which is generated from a secret private key. The private key is kept secret and the public key is exposed. It is imperative that the private key be protected in a secure highly tamper resistant setting. An embedded ACC is able to fulfill this requirement by being able to internally and autonomously generate a unique private key with a combination of hardware and firmware to protect the secret key from being exposed. The ACC generates a unique identifier for each device and participates in the tracking and provisioning of the device through the encrypted channel with the appliance . Once both parties agree on a symmetric key the appliance issues confidential messages referred to herein as feature control tickets FCTs to the ACC in a secure manner. The ACC is described in greater detail below making reference to .

To implement the AMS as discussed above various security considerations should be made. As noted above all high trust computations in the controller and appliances should take place inside an HSM in particular on the appliance which is typically running at another entity with various levels of trust between the manufacturer and the entity. When performing serialization the appliance should only be able to generate serial numbers based on the serial number schema received from the controller such schemas are described below . For key injection the appliance should only be able to decrypt the sequenced keys received directly from the controller i.e. not from another appliance . For feature activation the appliance should only be able to decrypt the FCTs received directly from the controller i.e. not received from another appliance . The credit or metering scheme used by the AMS should be secured such that appliances can only use the credit notices received directly from the controller . The appliances should only use assets that are from the controller from which it was provisioned to ensure that assets mistakenly sent to another appliance cannot be used. It should not be possible for the appliance to use credit notices from another appliance and it should not be possible for an attacker to add remove or change the number of credits on the appliance . However it can be appreciated that the AMS can be configured to enable assets on one appliance to be replicated to another appliance for high availability failover purposes if mechanisms are in place to ensure a unique asset is not used more than once. For the administration of the controller the web browser should only be able to access the web server over https and the communications should be secured e.g. mutually authenticated encrypted integrity checked replay protected etc.

The communications between the web server and the controller daemon and the CLI utility and the controller daemon should be secured as shown in e.g. using SSL. Similarly the communications between the controller and appliance and appliance and agent should be secured e.g. using SSL. The communications between the appliance HSM and the ACC should be secured using the ACC protocol and the ACC should authenticate the appliance . The appliance does not need to authenticate the ACC as it is considered a trusted root. The logs from the agent to the appliance to the controller may be encrypted and should be integrity protected to prevent eavesdropping and tampering. Only the controller should be able to decrypt and validate logs. These logs may include custom data such as yield data. The controller and the appliance should be hardened against attack. This hardening will apply to the OS and the applications e.g. the database including those running on the HSM .

All certificates are preferably elliptic curve cryptography ECC certificates issued by a trusted device CA signed on a per customer AMS sub root certificate. ECC certificates would then be used for SSL between each of the web server controller daemon appliance and agent for HSM certificates for every HSM in the AMS and for the ACC certificate used in the ECMQV negotiation with the ACC . Customer names should be embedded in the certificates and should be checked so that communications only occur between end points with the same customer name. Data stored in the database should be protected against unauthorized access and modification.

In the examples discussed herein a product is a model which provides the AMS with a name for the product its identification the service it provides which appliances are producing the product and a list of assets. For example assets can be a collection of serialization schemas and a list of appliances to which the schema collection applies. Similarly the assets can be a collection of key types and a list of appliances to which that key type collection applies. In yet another example the assets can be a collection of FCTs and a list of corresponding appliances . Service modules discussed herein determine what each of the AMS components controller appliances agents and ACC provide in the production process. The AMS in the following examples can define service modules for serialization key injection and feature activation however it will be appreciated that other service modules can be applied to deliver and provide other types of assets. Examples of serialization key injection and feature activation service module configurations are shown in B and C respectively.

Turning first to the serialization service module is a configuration of the AMS that is used to provide a secure means of generating assigning to chips or other electronic objects or devices and tracking unique serial numbers. To provide this service the controller is used to define a product model then to define one or more serialization schemas to be bound to each product model. Each serialization schema contains a range of serial numbers for a particular product e.g. device . The serial number schemas are sent over a secure encrypted connection e.g. over SSL to the appliances at the manufacturer s location typically automatically whenever a synchronization operation takes place. Agents can then request serial number values by product name using the agent API or the daemon API . The serial numbers are generated by the appliance metered and provided to the agents . The serial numbers are then injected sequentially into each die in a chip manufacturing process using the agent . The controller tracks how many serial numbers have been consumed for each serialization product and makes these results available in the GUI .

A serialization schema is an object that defines the rules about how a serial number is generated. For example it determines whether the serial number digits are presented in hexadecimal or decimal form and whether fixed strings are included. While one or more serialization schemas can be bound to a serialization product a particular schema can only be bound to one product. Serialization schemas bound to a product cannot overlap and once bound the schemas should not be unbound. For other changes e.g. to change the static strings that have been inserted a new serialization schema should be created.

If more than one schema is bound to the same product such multiple schemas should be assigned in a priority order. When requesting serial number strings for a product serial numbers are given out from schemas with the highest priority. If a schema is exhausted i.e. count values from the schema have all been assigned the schema with the next highest priority is then used. Serialization products can be bound to more than one appliance with each binding having a minimum and maximum inventory level. The controller can be used to ensure that products bound to multiple appliances have non overlapping ranges of serial numbers. When a product is bound to an appliance the controller keeps an inventory of serial numbers at the specified maximum level. Once the inventory has been sent from the controller to an appliance the serial number values should not be able to be recalled or revoked.

A serial number schema may describe how to convert a base value into a serial number string. In this example the term serial number base value refers to any positive 64 bit integer and should not be confused with the base attribute. A serial number schema has several attributes start count base and total characters. The start and count values define the range of base values that are allowed in the schema. The base attribute determines whether the base value is represented in base 10 or base 16 format when it is converted to a serial number string. The total character attribute defines how many characters to use when representing the base value as a serial number string. Zero or more static strings can be inserted at any position in the serial number string. It may be noted that you should not be able to specify a number less than the minimum number of characters required to represent the largest value in the schema . For example if the schema starts with 0 and the count is 1000 then there should be three or more characters because the schema defines the range 0 999 and three characters are required to represent 999.

c the resultant string is then either truncated from the left or most significant end or it is padded on the left with zeros depending on the total character attribute and

Example A If Schema A start 1 count 100 characters 4 base 16 and the base value 55 the result is the serial number 0037. This is because 55 is within the range the hex format for 55 is 37 and four characters are required thus padding of two zeros. If the base value 3 the result is the serial number 0003.

Example B If Schema B start 1 count 100 characters 3 base 10 staticstring1 pos 3 str X staticstring2 pos 1 str and the base value is 56 the result is the serial number string 0 56X. This is because 56 is in the range 56 is already in base 10 an X is inserted at position 3 i.e. the least significant position and a dash is inserted at position 1 i.e. the most significant position . A zero is used to pad the serial number string because 56 is only two characters. If the base value 1 the result is the serial number string 0 01X with two zeros of padding.

The serialization service module creates logs when serial number schemas are sent from the controller to the appliance recorded as controller activity logs when serial numbers are generated by the appliance and sent to the agent recorded as appliance activity logs and when serial numbers are used by the agent recorded as agent activity logs . All logs are kept on the controller after being collected and can be used to monitor and track serial number use. Each time a serial number is issued to an agent the issuing appliance s credit is decremented by one and the serial number inventory for that product is decremented. Both levels are replenished during a synchronization operation between the controller and the appliance and are used to meter the serial number use of the appliance .

Turning back to a serialization product workflow is shown. In this example a business manager may define the serialization schema by documenting this and communicating the proposed schema to the AMS administrator. The AMS administrator may then use the controller GUI to generate the serialization schema . The business manage can also define the serialization product document this product definition and communicate the definition to the AMS administrator. The AMS administrator may then create a serialization product per the definition using the controller GUI . The AMS administrator then proceeds to bind the serial number schema to the product bind the product to the appliance and uses the controller to synchronize the serial number schema with the appliance . The appliance then uses the agent to inject the serial numbers e.g. per the sequence shown in .

The serialization products when defined are assigned a unique product ID by the AMS and a unique identifying name provided by the operator in order to distinguish from other products. For each serialization product the appliance can deliver the serial numbers to the agent directly or can deliver the serial numbers via FCTs . If the serial number is delivered via an FCT then the operator would in the examples provided below need to specify a 2 byte memory offset in hexadecimal within the ACC where the serial number is to be stored and also an 8 byte record tag value in hexadecimal .

The appliance receives serial number products schemas from the controller responds to requests from agents for serial numbers generates the serial numbers based on the serial number schema meters the serial numbers receives logs back from the agent and sends logs back to the controller . The appliance credit is reduced by one for each serial number delivered to the agent and if the credit reaches zero 0 no more serial numbers should be delivered. When a serial number is to be delivered via an FCT it should not be able to be delivered directly i.e. the appliance should deny any such requests. Also when delivered via an FCT the logging in the appliance should be identical to when the serial number is delivered directly with the exception that the ACC UID should also be logged. A configurable receive block size should be accommodated number of logs returned in a single block from an appliance . When a serial number is delivered via an FCT the ACC flag record tag and memory address data should be protected from tampering on the appliance .

The agent should be capable of requesting serial numbers from the appliance using the agent API or the daemon API by serialization product name and count. The agent should also support the two mechanisms for delivery namely directly or via an FCT . Agents should log the use of each serial number and return logs back to the appliance . The agent should also log discarded serial numbers as wasted. When a serial number is delivered via an FCT the logging in the agent should be identical to when the serial number is delivered directly with the exception that the ACC UID should also be logged.

As discussed above the agent obtains log data from the test application e.g. when using the daemon API . It has been found that the audit channel provided by the AMS enables various correlations to be made during the manufacturing process. For example when adding a serial number to a chip in the tester the tester typically knows the location of the particular chip on the wafer. This location information can be logged along with the serial number that was added and eventually this information is stored by the controller in the relational database . In this way at a later time if the chip fails a test in the manufacturing process the relational database can be used to correlate the serial number of the failed chip with the location at which it was on the die to determine if faults occur in certain parts of the process or locations within the machinery. In another example a timestamp associated with the addition of the serial number can be used to track failures at certain times on certain machines or even to identify certain employees in alleged theft of chips. Therefore the audit channel and relational database can be utilized for various data mining and analyses for improving accountability and for identifying and rectifying root cause of failures in a manufacturing process.

Turning now to the key injection service module is a configuration of the AMS that provides a secure means of injecting keys into products e.g. devices . To provide this service the controller is used to define one or more key types . A key type defines the format of the keys in a file. The controller is then used to define a product model and then to bind one or more key types to each product models as shown by way of example only in . It has been found that by adding keys directly to product definitions without separating key types from products confusion can arise from the different ways that project names and product types are defined by customers in different applications. For example if multiple key types are added to product buckets when that product gets low in credits it can be difficult to determine which of the keys is low and to thus know which key types to top up. By separating the key types from the products as shown in an additional level of abstraction is provided to more closely reflect how the customers typically utilize the assets. In this way the controller can be used to define a product type that can form blobs of one or more key types as well as other assets to avoid inadvertently loading incorrect keys and to better track the actual inventory level of each key type . As such when the keys are imported e.g. on a DVD as shown in the keys are separated into distinct buckets according to key type rather than trying to allocate keys directly to certain products which would then be referred to by different names without necessarily a logical correlation to the number and types of keys used for that product type . Instead the keys are simply separated by key type and then customer defined associations are defined by way of the product type abstraction. Also when defining a product certain permissions can be established such that the product only uses certain key type s e.g. from certain distributers. Since certain key types may be provided according to various contractual obligations better control over the separation and allocation of key types ensures such contractual obligations are adhered to.

Also shown in is a key transform which can be used to modify certain key types in customer specific ways. As illustrated in a key transform can be applied at the time of importing the keys e.g. if the keys of that key type are always to be transformed in that way such that a transformed key type is defined. Alternatively the key transform can be applied prior to or upon delivery wherein the key is transformed on a product specific basis or on an appliance specific basis. In yet another alternative the key transform can be applied at the appliance before the keys are delivered to the agents . When determining where the key transform is applied security considerations should be made based on where the key transform is located e.g. higher security when at the appliance due to the lower trust at that location. It may be noted that by separating key types and product types as shown the transform can be associated with the product rather than the key type to minimize the number of key types required. In other words the key types can be stored separately as imported and the key transform performed per the product type to avoid adding yet another key type and the potential confusion this can cause.

Once a key type has been defined keys of that type can be imported from a key file e.g. via a DVD onto the controller using the GUI . Operations personnel can then use the GUI to specify the number of keys to be sent to an appliance . If a hash has been defined then the AMS verifies the hash value. The keys are sent over a secure encrypted connection e.g. SSL to the appliances at a manufacturer s location in this example automatically whenever a synchronization operation takes place. The keys can then be requested by product name using the agent API or daemon API . When the agent fetches keys it asks for a product and a number of units of that product. The appliance queries all key types bound to this product and returns the specified number of keys for each key type. The keys are then injected into each die on the assembly line by the agent .

Key injection products can be bound to one or more appliances with each binding having a minimum and maximum inventory levels. When a product is bound to an appliance the controller keeps its inventory of keys at the specified maximum level. Once inventory has been sent from the controller to an appliance the keys cannot be recalled or revoked. The controller tracks how many keys have been injected for each key type and makes these results available in the GUI . illustrates an exemplary sequence diagram for performing a key injection service. It can be seen that when compared to serialization key injection also has a step of importing the keys from a file however it can be appreciated that the keys could also be generated by the controller and done at the time of defining the key types. Therefore the sequence shown in is for illustrative purposes only.

When implementing the AMS for key injection the key data should not be stored in plaintext after it is imported onto the controller . Decryption should only happen when the appliance delivers keys to agents unless the ACC is used in which case the data is not decrypted until it is processed by the ACC i.e. by processing the key within an FCT .

A key type has several attributes that define the format of the keys in a file. A typical key type definition is provided in Table 1 below for an HDCP TX key.

The key injection service module is configured to create logs when keys are sent to an appliance controller activity logs when keys are sent to an agent appliance activity logs and when keys are consumed by agents agent activity logs whether they are successful failed or wasted. Such log events are shown in . All the logs are stored on the controller after being returned by the appliance during a synchronization operation and can be used to monitor and track key use. Each time a key is issued to an agent the appliance s credit is decremented by one and the key inventory for that product is decremented. Both levels are replenished during a synchronization operation between the controller and the appliance and are used to meter use on the appliance .

Similar to serialization each key injection production is assigned a unique product ID by the AMS and a unique identifying name provided by the operator. For each key injection product the two mechanisms discussed above namely providing keys directly to the agent and delivery using the FCTs should be allowed. If the key is delivered via an FCT the operator would also specify the 2 byte memory offset within the ACC and the 8 byte record tag value. Each key type is assigned a unique key type ID by the AMS and a unique identifying name provided by the operator. A key is treated in this example as a stream of bytes.

A plaintext batch of sequenced keys can be imported from a file local to the controller e.g. the DVD . Each key is assigned a unique key ID by the AMS . It may be noted that this unique key ID is not the same as the key identifier in the key. The key files can also be imported from a remote computer on which the GUI is running. A special case is to allow HDCP keys that are PGP encrypted to be PGP decrypted and then imported. There is a specific file format that is supported for these HDCP keys. For PGP decryption GNU GPG can be used. The certificate and private key required is assumed in this case to have been imported into GNU GPG already.

During importation of the particular key type if the key identifier is used then the key identifier of the key will be compared to all previously imported key identifiers for that key type . It may be noted that this mechanism does not protect against a key file being used again for another key type and thus should be prevented using operational rules. During import of a particular key type if a hash is used then the hash is calculated and verified for all keys. This hash calculation is not performed using the HSM . Operators should be prevented from importing keys of a particular key type if there is already a job running that is importing keys of the same key type.

One or more keys should be allowed to be bound to a key injection product. Each key type may be assigned to multiple products. For each key type in each product how many of those keys types are required should be specified. A key type should be able to be unbound from a product but only if the product is not bound to any appliance . Each key injection product should be allowed to be bound to one or more appliances . Each appliance may have multiple key products assigned to it and it should be able to unbind a key injection product from an appliance . The controller should not send duplicate keys to appliances . Once a key has been delivered to an appliance it should be deleted from the controller .

Similar to serialization a metering system should be used and once keys are issued to appliances they should not be able to be returned recalled or revoked. When a key is delivered via an FCT the logging in the appliance and agent should be identical to when the key is delivered directly but also includes the ACC UID.

The key injection service module can also support the processing of keys at the controller before they are imported allowing the keys to be arbitrarily transformed referred to herein as key import signed objects. Key import signed objects should be able to be defined wherein each signed object is assigned a unique signed object ID by the AMS and each signed object is assigned a unique identifying name provided by the operator. The signed object is a shared object that resides in the controller and is cryptographically protected with a signature. A function in the shared object is then called once for every key before it is imported to allow the operator to transform the key. It may be noted that the key identifier for example KSV in the case of HDCP should be copied out so that the controller can always access it even after the signed object has potentially obfuscated it. Key import signed objects should be able to be assigned to one or more key types and each key type should be able to have at most one key import signed object assigned. The key import signed objects should be able to be unassigned from key types as well.

The controller when configured for key injection can also support key transform plug ins which allows for the processing of keys at the controller after they are decrypted but before they are sent to the appliance . This may be referred to as a key to appliance transform. The key transform plug in allows for example a hardware specific or end to end protocol specific modification to the key be made on a per customer or per product basis. This allows modifications such as bit allocation for error correction to be made and the transformations can be performed upon importing the keys or prior to delivery to the appliance . Such key to appliance transforms should be able to be defined and each transform should be assigned a unique signed object ID by the AMS and each transform should be assigned a unique identifying name provided by the operator. The transform is a shared object that resides in the controller and should be cryptographically protected with a signature. A function in the shared object is called once for every key before it is sent to the appliance to transform the key. It may be noted that the key identifier should be copied out so that the controller can always access it even after the transform has taken place. Key to appliance transforms should be able to be assigned to one or more key types when bound to a product. Each bound key type should have at most one key to appliance transform assigned. The key to appliance transforms should be able to be unassigned from key types in a product as well.

The key injection service module can also support appliance signed objects which allow for the post processing of keys at the appliance after they are decrypted but before they are sent to the agent . With respect to appliance signed objects key pass through should also be supported. Depending on whether key pass through is enabled or disabled it enforces whether or not appliance signed objects should be present before the appliance will send keys to the agent . This may be referred to herein as key to agent signed objects.

Key to agent signed objects should be able to be defined and each signed object is assigned a unique signed object ID by the AMS and each signed object is assigned a unique identifying name provided by the operator. The signed object is a shared object that resides on the controller and is cryptographically protected by a signature. A function in the shared object can be called for every key before it is sent to the appliance to transform the key. It may be noted that the key identifier should also be copied out so that the controller can access even after the transform takes place. Key to agent signed objects should be able to be assigned to one or more key types. Each key type should have at most one key to agent signed object assigned and key to agent signed objects should be able to be unassigned from key types as well. The key injection service module can also support a read only sync mode where the controller only queries current key levels and retrieves logs from the appliance without delivering new keys.

The appliance should not send duplicate keys to agents and once a key has been delivered it should be deleted from the appliance . When a key is delivered via an FCT it should not be able to be delivered directly and when a key injection product is unbound from an appliance all keys belonging to that product should be deleted from the appliance .

The agent should be able to request key blobs from the appliance by product name and count and each key blob should contain one or more keys depending on how many key types are bound to the product. For example if the product utilizes 3 key types the key blob would include 3 keys. Agents should not send duplicate keys to the tester . Once a key is delivered to the tester it should be deleted from the agent . The agent should also log the use of each key in the key blob separately and should log any keys that it intends to discard.

The AMS when configured to provide a feature activation service module as shown in provides a secure means of activating or deactivating a product s feature set dynamically after fabrication using the ACC . As noted above the ACC can also be used with serialization and key injection service modules but is particularly advantageous for use with the feature activation service module. To provide this service the controller is used to define one or more FCTs then to define a product model. The FCTs are then bound to each product model in which case all FCTs are also bound to the appliance producing that product. The FCTs are then applied to each die on the assembly line using the ACC . Products can be bound to one or more appliances with each binding having a minimum and maximum inventory level. When a product is bound to an appliance the controller keeps its inventory of FCTs at the specified maximum level. Once the inventory level has been sent from the controller to the appliance the FCTs should not be able to be recalled or revoked. The controller tracks how many FCTs have been applied to each product and makes these results available in the GUI .

In the examples described herein the ACC contains a 256 bit 32 byte feature register a tag register and NVRAM. The feature register is meant to be used to control turn on or off or partially on or partially off features on the device . Exactly how the features are turned on off etc. is device dependent. ACC commands provided by way of FCTs are used to read data from or write data to the feature register tag register or NVRAM. FCTs contain feature data and a record tag. The feature data determines which product features to activate or deactivate. The record tag provides a record of which features will be activated by the ACC using the feature data. The feature data is programmed into the ACC feature register and the record tag is programmed into the ACC tag register. The value of the record tag is also customer dependent. The two commands which are described in greater detail below to write to the feature register are SETFEAT and SETFEAT TEMP. When using the latter the feature data is not saved in NVRAM and would be lost on power down.

The ACC also contains in this example a 64 bit 8 byte record tag register . The record tag is meant to be used to record what has been programmed on the ACC . the record tag is set when using any of the commands that write to the ACC except SETFEAT TEMP . How the record tag is interpreted is application dependent. The ACC also contains an implementation dependent amount of NVRAM. The command to write to the NVRAM is WRACCESS. A maximum amount of data that can be written is usually imposed e.g. 500 bytes. What is written to the NVRAM and where it is written is implementation dependent.

The FCTs are sent over a secure encrypted connection e.g. SSL to the appliances at the manufacturer s location automatically whenever a synchronization operation occurs. FCTs can then be requested by the agents by product name using the agent API or daemon API . When an agent requests a feature activation product it would obtain all the FCTs bound to that product individually. When an agent fetches FCTs from an appliance it queries all service modules for an ACC enabled product of that name in which case multiple FCTs may be delivered to an agent and are then send to an ACC individually. The agent API may not interface with the ACC directly in which case an implementation dependent interface is required. When using the feature activation service module the feature data should never be in plaintext after it leaves the controller and before it enters the ACC .

As can been seen in the feature activation service module creates logs when feature data is sent to an appliance controller logs when feature data is sent to an agent appliance logs and when feature data is sent to the ACC agent logs . All the logs are stored on the controller after being returned by an appliance during a synchronization operation and can be used to monitor and track feature use. Each time feature data is used on an appliance the appliance credit is decremented by one and each appliance also maintains a feature data product level which is decremented by one each time feature data is used. The feature data level and credit level are replenished when the controller synchronizes an appliance . Both of these mechanisms are used to meter feature data use on an appliance .

In the defining of products and feature data as well as the delivery of FCTs and log reporting are similar to the mechanisms used in serialization and key injection. However it can be observed that when utilizing an ACC the normal loop for the injection or application of assets is separated into a pair of loops Loop 1 that involves key generation and Loop 2 within Loop 1 which involves feature programming. Loop 1 is initiated by providing the command cmd STARTACC described in detail below. The loops are terminated by providing the command cmd STOPACC . The loops are shown in greater detail in . Once providing cmd STARTACC the ACC generates public keys and after some time the agent requests a response by sending the command cmd REQRESP to obtain the ACC public keys. The agent provides these public keys in turn to the appliance and the appliance uses these keys to generate a shared key e.g. using the ECMQV protocol as exemplified later. The appliance has now opened a secure connection with the ACC and can meter and encrypt the features and log this event. The appliance public keys and the encrypted features are then provided to the agent . The agent then initiates the feature programming loop by sending the command cmd INITIAL FCT FCT which includes the FCT . The features are then programmed in the feature register by the ACC and the agent requests a response again using the cmd REQRESP . In response the ACC provides an encrypted response pertaining to the feature programming steps and the agent logs this event. Since the secure connection is established additional feature programming steps can be applied before the loops terminate as noted above.

It can therefore be seen that when implementing the AMS with an ACC the general provisioning and delivery of assets is similar to those services that do not require an ACC with additional considerations and commands required to establish the secure connection with the ACC also required. It can be appreciated that these operations can also be adapted to be used in the serialization and key injection service modules to utilize FCTs for carrying serial numbers and keys. As such various implementations are available using the common application framework provided by the AMS .

As with the other service modules exemplified herein for feature activation each product should be assigned a unique product ID by the AMS and a unique identifying name provided by the operator. Each feature that is defined can be assigned a unique feature ID by the AMS and a unique identifying name by the operator. Each feature defines a command type and in this example a 32 byte data value. One or more features should be allowed to be bound to a feature activation product and each feature may be bound to multiple products. A feature should be able to be unbound from a product but only if that product is not bound to any appliances . Each feature activation product can be bound to one or more appliances and each appliance may have multiple feature activation products assigned to it.

A metering process can be implemented where the controller will top up the feature activation product levels on the appliance during a synchronization operation. The operator would define warning minimum and maximum levels similar to the other service modules exemplified herein. A feature activation product may be modified deleted on the controller if it is not bound to any appliance and features may be modified deleted on the controller if it is not assigned to any feature activation product. An appliance can be deleted on the controller if there are no products bound to the appliance . The feature command record tag and data should be protected from tampering on the appliance and a read only sync mode should be supported to allow a query to be made and logs to be obtained without providing more FCTs .

The appliance supports delivery of features to the ACC via the agent using the protocol defined in described below. This includes receiving feature activation products from the controller responding to requests from the agent for feature activation products metering the products receiving logs back from the agent and sending logs back to the controller . The appliance decrements appliance credit for each FCT delivered and when a feature activation product is unbound from an appliance all features belonging to that product should be deleted from the appliance .

The agent can request features from the appliance by feature activation product name can interface with the ACC using the above mentioned protocols and can deliver each feature in the product to the ACC separately log the feature use and return logs to the appliance . The feature activation feature use log should include a single character string field for customer log data formatted appropriately.

When implemented as a web based system the GUI can be accessed by launching a standard web browser and pointing the browser to an appropriate URL. As shown in the GUI can include a quick status view which can be configured to appear when the user is logged off or otherwise locked out of the controller . For example the quick status view can be configured to appear after the GUI times out from inactivity on the part of the user logged in or if the user clicks a lock button or selects a similar option from a menu not shown . The quick status view is also made available for viewing even without a user login. In this way status information alerts and other critical messages can be viewed without the observer having to be logged in. For example when an appliance goes offline or malfunctions an operator or even another person in the vicinity can immediately be aware of this situation without having to first log in. The quick status view also functions as a screen saver for the GUI such that if a prescribed period of time passes with no activity in the GUI the quick status view is displayed and the operator would need to log in again to continue. This protects the AMS from inadvertent or malicious tampering while still providing important status information on a read only basis.

The quick status view comprises a top portion and a bottom portion . In the top portion service icons are displayed for the services offered by the AMS . Each icon indicates by colour e.g. red or blue whether there is a problem or alert with any of the appliances associated with the particular service. In the bottom portion product icons are displayed for any products defined in the GUI . Similar to the top portion each icon indicates by colour whether there is a problem or alert with any of the appliances in the system or application supporting the particular product. The use of different colours for normal operations versus problem states enables an operator to quickly identify a problem and drill in to that appliance and application to determine the source of the problem and take any remedial action if necessary. If necessary the bottom portion can provide multiple rows not shown e.g. when there are many products . In some embodiments the operator may be given a option for defining which products should appear in the quick status view .

By clicking any of the icons on the quick status view a user login screen not shown can be launched. Once logged in the operator can be presented with a status view filtered according to the selected icon. Therefore the operator upon determining a problem with a particular service in the quick status view can click on that service icon and upon logging in the next view would be filtered to that service e.g. serialization. Once in the status view the operator can observe which appliance s have alerts and double clicking or other input can take the operator to a detailed view of information about the appliance allowing them to determine the source of the alert. When logging in the login screen can be given a format that is similar to the quick status view and other screens and to differentiate between fields each field can be highlighted with a different colour and provide a status bar to indicate what is being performed. If there is an error logging in a non field specific message can be displayed with a red background at the top of the form.

Once the operator has successfully connected and logged onto a particular controller a main application appears which may be filtered if the user had selected a particular icon . One example providing an appliance view is shown in . To facilitate navigation the GUI provides a consistent form of panes and methods for interacting with the application.

The main navigational and information areas of the main application in this example include an application menu bar a view pane a main information pane a status bar and a version bar . The applications menu bar in comprises five menus namely a Controller menu a Services menu a View menu an Actions menu and a Help menu. The Controller menu enables the operator to modify the controller and log out of the GUI . The Services menu includes an item for each service which in this example include serialization key injection and feature activation. The View menu enables the operator to select from various views e.g. status alerts jobs reports controller appliance products serialization schema key types feature control tickets users etc. The Actions menu changes according to the selected view. The Help menu can provide access to various help resources such as system help administrator s guide developer s guide product overview system overview user s guide etc.

The view pane provides quick access to the different views in the GUI . Such views may include a status view alerts view jobs view reports view controller view appliances view products view serialization schema view key types view FCTs view and user s view. It may be noted that in this example the view pane is an alternative to user the View menu. Where applicable a number beside each view item indicates the number of the associated item e.g. number of alerts for the alerts view number of jobs for the jobs view etc. active in the AMS . Many of the views can also display the Services menu allowing the operator to quickly filter items in the data according to the selected service. For example if the appliances view is active and a serialization item is selected in the Services menu then the appliances view can display all appliances with the serialization service active. When using the Services menu to filter the standard filter bar can be disabled and hidden. Additional service specific information may be displayed for each item in the information pane and extra service specific actions may appear when selecting services in the Services menu.

The main information pane displays information about the objects in the system according to the selected view. For example for the Jobs view each item in the data area is a job in the system. The main information pane comprises several features. A view title bar displays the title of the active view along with the title of the form if a form is currently displayed. For example the view title bar for a Modify Appliance may show APPLIANCES MODIFY APPLIANCE . The view title bar may also contain a link to context sensitive online help for the current screen. A services bar provides a way for the operator to quickly hone in on the services they are interested in. The services bar in the example shown in displays icons in a horizontal grid and may include the following items All Serialization Key Injection and Feature Activation. Selecting all removes any filters and displays the results of the active view with no filtering. Selecting any of the remaining services displays the active view filtered according to the selected service. For example appliances using the selected service jobs related to the selected service etc. In this way the operator can more easily navigate amongst multiple services and appliances served by a single controller . Additional service specific information may be displayed for each item in the data area and extra service specific actions may appear when selecting services in the service bar.

An action bar contains various buttons on its left side with a pull down menu containing any additional actions that are valid for the current view. On the right side of the action bar is a search field. Typing text in the search field filters the contents of the data area depending on the view. For example for the appliance view the user may search by appliance name manufacturer location or product. Actions in the action bar may be valid or invalid depending on the selected item in the data area or whether there is anything selected. If an action is invalid it can be greyed out. In general it is advantageous for the list of actions for each view to be consistent and actions become valid or invalid. A data area presents the information as appropriate for the view filtered as necessary. In this example each view may support up to three zoom levels to enable the user to conveniently drill down into further details when needed to troubleshoot or to identify various settings. Zoom levels may be one item per page one item per three lines and one item per line. The shorthand for these zoom levels are 1 line 3 line and detail. A pull down menu in the action bar allows the operator to select a zoom level. A paging bar allows the operator to page through many items when there are too many items to fit on one page. If the zoom level is detail then there may be one page for each item. The paging bar can be configured to appear automatically whenever necessary. If the information to display fits on a single page the paging bar does not need to appear.

On the left side of the paging bar is a text description of the information presented in the data area with a pull down menu to select the number of items to display per page and how it should be sorted. For example View 10 items by Service where the number of items and the sort field are pull down menus. There is also a button to switch between increasing and decreasing sort order. On the right side of the paging bar are paging widgets which can include text describing which items are displayed for example Reports 11 20 of 46 button to go to the first page button to go to the previous page the text Page XX of YY where XX is a text field allowing the user to go directly to a specific page and YY is the total number of pages button to go to the next page and button to go to the last page.

The status bar is positioned at the bottom of the window and displays basic information about the controller e.g. to indicate that a connection is made and with which operator. Lock and refresh buttons can be included as shown for all views.

To attract the attention of the operator the data area can be modified to include an alert bar as shown in which in the example shown indicates that the selected product shown in the data area has low inventory on a particular appliance named TestApp . The alert bar can be given a distinct and bold colour such as red consistent with other alerts to draw immediate attention to the alert. In this example the alert bar extends across the width of the data area and includes emergency related icons to further identify the alert as such.

The main application can be used to launch a main status view as shown in which displays appliances in three ways grouped by product by manufacturer or by location. If the view is accessed from the quick status screen by clicking one of the product icons if the view is filtered by products or if the By Product action is selected then it will group appliances by product. Otherwise it groups appliances by manufacturer. The screenshot shown in illustrates a view by product. If displaying appliances grouped by product as shown in each product is displayed showing each appliance associated with the product. If displaying appliances grouped by manufacturer then each manufacturer is displayed showing each appliance associated with the manufacturer. If displaying appliances grouped by location then each location is displayed showing each appliance associated with the location.

Appliance icons include service indicators for which services are active on the particular appliance as well as provides an indication of whether the appliance currently has any active alerts by colouring the icon red or whether the appliance is operating correctly by colouring the icon blue . The service indicators can utilize a colour coded scheme for indicating various states. For example an orange icon may indicate that the service on that appliance is low on assets a red icon may indicate a problem with that service a dim or greyed out icon can indicate that the service is not assigned to the appliance and a green icon can be used to indicate that there are no problems. The status view uses a single zoom level in this example. The View action or double clicking a particular appliance takes the operator to the one item per page zoom level of the appliances view with the selected appliance being displayed. The actions associated with the main status view are View By product By manufacturer and By location.

The operator can access the alerts view shown in to examine any alerts present in the AMS . The zoom level shown in is a 1 line zoom level. In the alerts view the operator can view the alerts ping the affected appliance sync the affected appliance and remove the alert. The controller can be configured to issue alerts under several different circumstances such as when the controller is not able to contact an appliance if there are any errors when the controller sends data to an appliance and vice versa when a synchronization operation has failed when the number of assets an appliance has reached the asset warning level when the free disk space on the appliance has reached a warning level when the HSM on the controller or any appliance has deactivated itself or when an appliance has blocked a connection from an agent because the agent IP address is not in the list managed by the appliance . If an alert is issued the appliance affected appears in the alerts view in the data area . The alerts view provides a description of the alert identifies the service for which the alert was issued and provides the time the alert was issued. The appropriate response to an alert depends on the cause of the alert.

The operator can access the jobs view shown in to perform various actions associated with jobs in the AMS such as cancelling a job in progress and removing a completed job. The jobs view in this example supports a 3 line zoom mode as shown in a 1 line zoom mode as shown in and a detail zoom mode as shown in . The complete set of information that the detail zoom mode gives per job is name job ID system appliance or controller job type job status start time end time or estimated end time if available duration and progress. A progress bar is provided in each zoom mode to provide a graphical overview of the status of the job. Within the jobs view the operator can pause the job zoom between zoom modes resume the job cancel the job view a job log remove a job show completed jobs and remove completed jobs.

The operator can access the reports view shown in to generate reports supported by the AMS . illustrates a 1 line zoom mode for the reports view . The reports view provides a service icon and a name for a report. The reports view can also be filtered by selecting a service on the services bar to limit the list of reports to a particular service. The generate report action displays a generate reports form shown in for the operator to enter information required to generate a report. Once the operator has completed the form the report can be viewed as shown in in the view reports screen . The view reports screen also enables the operator to download PDF or CSV formats in this example. Various report types can be generated for example number of assets issued by a controller in total by product or by schema for serialization number of assets issued by day for a particular range number of assets by appliance total by day etc. number of assets received by agents total by day etc. number of missing logs duplicate logs logs by asset ID or number logs for a specified product date range etc.

The controller view shown in provides details of the controller to which the operator is connected in the data area . In this example the controller view provides the following information controller name services the controller is providing IP address of the controller port of the controller SMTP IP address SMTP port SMTP domain From address To address disk health controller HSM status HSM software version controller software version number of alerts in the system the number of jobs active in the system job delete time system check interval controller s disk space and memory available on controller . In the controller view the operator can modify the controller test email and log out. To modify the controller the Modify button in the controller view is selected launching a modify controller form shown in . As can be appreciated from the modify controller form enables the operator to make changes to the settings and details for the controller and apply those settings.

The operator can access the appliances view shown in to perform various actions associated with the appliances such as adding modifying removing and syncing an appliance . The appliances view can support detail 3 line and 1 line zoom modes. shows the appliance view in All Services mode. In All Services mode each appliance displays service specific information about one of the services. If only one service is active on the appliance then that service is displayed. If more than one service is active then the service to display can be selected in a defined order of priority. If a service is selected in the services bar then that service is displayed for all appliances in the appliances view . The 3 line mode is shown in the 1 line mode is shown in and the details mode is shown in . As can be seen in the information available per appliance in this example includes appliance name services provided by the appliance manufacturer location IP address and port status e.g. online offline inactive unprovisioned HSM software version disk space available memory available credit available minimum amount of credit maximum amount of credit warning level for credit appliance software version number of alerts number of jobs number of connection retries connection timeout period auto sync interval ready only sync asset block size last update list of allowable agent IP subnets date time of last communication with controller date time of last communication with each agent and service specific information e.g. serial numbers keys FCTs . Certain ones of these details can appear in certain zoom levels as shown in . In the appliance view the operator can perform a zoom between zoom modes ping the appliance sync the appliance add an appliance modify an appliance remove an appliance activate an appliance and deactivate an appliance .

The ping appliance action launches a ping screen as shown in which enables the operator to ping the selected appliance over the secure channel to make sure it is alive and to determine its network latency. The ping action is used to test whether a particular host appliance is reachable across an IP network and to test an SSL connection self test the network interface card NIC of the computer being used or as a speed test. The ping can estimate the round trip time generally in milliseconds record packet loss and print a statistical summary when complete.

The sync appliance action launches a sync screen shown in and enables the operator to ensure any service related objects are topped up e.g. assets such as serial numbers keys FCTs etc. pushes any appliance configuration changes and retrieves service logs from the appliance . The synchronizing action makes sure that any service related objects or assets such as serial numbers key and FCTs are at their maximum amounts. The synchronizing action also synchronizes an appliance s clock with the controller s clock and retrieves service logs from the appliance . In addition any configuration changes made to an appliance can come into effect after the appliance is synchronized. A read only sync can also be performed which will gather the status and asset information of the appliance to see if it is in sync but does not make any changes. The synchronization can also be used to obtain service logs from an appliance .

The modify appliance action launches a modify appliance screen shown in . The modify appliance screen enables details of the appliance to be edited by the operator. Not shown in are credit minimum credit maximum and credit warning fields to enable the operator to set thresholds for the credits given to the appliance and when to issue a low level warning. The controller and appliance should automatically synchronize on a regular basis and when the appliance is synchronized the controller checks to see how many assets are on the appliance . If the number of assets is equal to or lower than the minimum value then the controller fills the appliance s assets to the maximum level. If the number of assets is equal to or below the warning level then the controller can issue an alert.

When an appliance is first added to a controller it is added with an inactive status see also described above . The activate appliance action brings the selected appliance online automatically initiating provisioning if necessary . The deactivate appliance action takes the selected appliance offline with appropriate warnings if taking the appliance offline will stop an associated production line. illustrates a deactivate appliance screen showing a selected appliance to be deactivated before having the operator confirm this selection. The remove appliance action should only be available if the selected appliance is not online otherwise the action should be disabled. illustrates a remove appliance screen which is similar to the deactivate appliance screen in that the selected appliance is shown prior to confirmation of the selection by the operator. It may be noted that the appliance when deactivated should indicate this by e.g. changing colour to red as exemplified above to provide a further visual cue to the operator regarding the status of the appliance .

A product in the GUI is a named grouping of one or more asset types that provides the AMS with a name for the product an identifier for the product a list of assets e.g. serialization schema key type or FCT depending on the service a list of appliances to which the assets should apply and the service the product provides. In the products view shown in the operator can manage products and perform various actions associated with products in the AMS such as adding modifying or removing a product. The products view is shown in a 3 line zoom mode in a 1 line zoom mode in and a details zoom mode in . As can be seen in the product view can include various information pertaining to the product such as product name service ID assets available displayed as a meter each displayed individually in detail zoom level list of assets schema key types or FCTs list of appliances and for serialization and key injection injection method ACC or normal ACC record field and ACC offset field. In the product view the operator can perform a zoom between zoom modes add a product modify a product and remove a product.

An add a product form is shown in and is exemplified for serialization. For key injection the serialization schema list would be replaced with a key type list and for feature control the serialization schema would be replaced with an FCT list.

A serialization schema in the AMS is an object that defines the rules about how a serial number is generated. For example whether the serial number digits are presented in hexadecimal or decimal and whether fixed strings are included. A serial schema view is shown in . In these views the operator can manage serialization schema and perform various actions associated with schema in the AMS such as adding modifying or removing schema. The 3 line zoom mode is shown in the 1 line zoom mode is shown in and the details zoom mode is shown in . As best seen in the information that defines the serial schema in this example includes the schema name schema ID serial numbers remaining not yet sent to appliances from total pool start value total count of serial numbers to generate whether to use base 10 or base 16 total number of characters in the serial number to pad or truncate list of static strings to include with their positions in the serial number and samples to illustrate the schema. In the serialization schema view the operator can perform a zoom between zoom modes add a schema modify a schema remove a schema and duplicate a schema modify the current selection but save with a new name . To add modify duplicate a serialization schema an add modify duplicate schema form is launched as shown in .

A key type in the AMS is an object that defines the rules about what types of cryptographic keys should be injected for a particular product. A key types view is shown in . In the key types view the operator can manage key types and perform various actions associated with key types in the AMS such as adding modifying or removing a key type. A 3 line zoom mode is shown in a 1 line zoom mode is shown in and a details zoom mode is shown in . As best shown in the information that the key types view may provide can include key type name ID keys available since last import length of key key identifier length and offset key data length and offset file header length hash output length and offset hash algorithm and hash input. A key type diagram is also shown which provides a visual depicted of the structure of the key and is updated as parameters are changed to show the way in which the structure changes. In the key types view the operator can zoom import keys add key types modify key types remove key types and duplicate key types modify current selection but save with a new name . An add modify duplicate key type form is shown in which can be seen is similar to the details zoom mode but enables parameters to be edited.

An FCT in the AMS is an object that defines a particular feature or features that may be specified for a particular product. An FCT includes an array of bits called the feature register . The state of specific bits in the feature register may be mapped to features in the device controlling whether those features are active or disabled. An FCT view is shown in and illustrates a visual depiction of the feature register with the active features being distinguished from unactivated features by filling in a corresponding cell with a different colour. A 3 line zoom mode is shown in a 1 line zoom mode is shown in and a details zoom mode is shown in . In the FCT view the operator can manage FCTs and perform various actions associated with FCTs in the AMS such as adding modifying or removing a ticket. As best shown in the information that can be provided in the FCT view for a particular FCT may include FCT name ID feature inclusion value command implemented tag record tag indicating a feature or set of features programmed on the ACC and total number of injections. In the FCT view the operator can navigate between zoom modes add FCTs modify FCTs remove FCTs and duplicate FCTs .

An administrator can access a users view shown in to perform various actions associated with the users in the system such as adding a user removing a user and changing a user s password. In this example the users view is at the 1 line zoom level. As can be seen in the users view lists information such as username controller permissions appliance permissions user permissions serialization permissions key injection permissions feature control permissions and last login time. The various permissions dictate what operations the user can perform e.g. adding or removing an appliance generating a serialization schema etc. In the users view the administrator can add a user duplicate a user modify a user change a password and remove a user. An add user form is shown in and enables the AMS to impose security permissions on its users according to defined user roles. In this way the administrator can define a user role to enable or deny different levels of access to particular parts of the system. By creating several users with different permissions the responsibilities can be partitioned within the GUI to allow operating the GUI to be much more effective. For example three user roles can be establishes as follows Security Officer SO Administrator AD and Operator OP . For each user role various permissions can be set per the above e.g. for view only view and save view and operate full access etc.

An online help service can also be provided for the GUI which can comprise a menu item or a help icon or both e.g. as shown in which link to an AMS online help guide e.g. in HTML format such that it is supported by a web browser. The menu item can lead the user to the front page table of contents and the help button can lead the user to a help article determined according to the current view in the data area i.e. context sensitive help .

Turning now to further detail of an embodiment of the AMS is now shown configured for providing the feature activation service module. In the example shown in the system is configured to provision communicate with provide data to collect data from and activate features within an ACC embedded in an electronic device . As discussed above the device and in turn the ACC is connected to a tester which is used in a fabrication manufacturing assembly process. The tester employs an agent which is a software module running on the tester . The tester is in turn connected to an appliance which includes an HSM that protects sensitive data and provides a secure zone within the appliance . As shown in the agent facilitates a secure communication channel between the HSM and the ACC for cryptographically securing communications therebetween. Over channel an FCT can be sent from the appliance to the ACC . The appliance may be connected to a backend infrastructure which may provide a certifying authority CA a database and a controller for controlling one or more appliances as will be explained in greater detail below.

In addition to being connected to the tester the ACC may also either at the same time or at some later time or other time during the process be connected to a user interface UI over a wide area network WAN or a device programmer . The device programmer may also connect to the ACC via the WAN as shown. The device programmer and or WAN can connect to the device and ACC using any suitable connection for example serial parallel wired wireless infrared RFID etc. In this example the ACC is connected to the tester over a standard testing protocol connection such as JTAG Joint Test Action Group IEEE 1149 test interface. The tester and appliance are connected over a suitable connection depending on their relative locations. In the examples provided below the appliance is located at the same physical facility as the tester and therefore the connection may be a local area network LAN .

The ACC as will be shown can comprise various types of memory shown generally and collectively as numeral in . The ACC uses a portion of memory to store either persistently or ephemerally various keys and certificates. illustrates various keys and certificates that are used in the following examples. A static private key dsi a static public key Qsi also referred to as the ACC s UID an ephemeral private key dei an ephemeral public key Qei a CA s certificate CERT CA and appliance j s certificate CERT APPj are shown in . In one embodiment the static keys are stored in non volatile memory NVM although they could be mask programmed into a ROM memory. In another embodiment no NVM may be required and the keys can be stored offline on either a hard disc or flash memory or some other non volatile bulk data storage medium outside of the ACC .

As can be seen in the ACC is a small hardware core embedded in a target system on chip SoC that establishes a hardware based point of trust on the silicon die. The ACC can be considered a root of trust on the consumer device as it comprises tamper proof features that provide physical protection to sensitive data and methods to provide remote attestation and verification. As will be explained in greater detail below the ACC is able to generate a unique identifier UID for one integrated circuit IC and participate in the tracking and provisioning of the IC through a secure and authenticated communication channel with the appliance . In the example shown in the IC is mounted on a printed circuit board PCB that would then be assembled into a consumer device . Although embedded as such the ACC can continue to serve as a root of trust on the PCB and or the final device .

The IC may also comprise a separate micro control unit MCU which can be used to establish a connection with a non tester e.g. a device programmer by connecting connection to the IC via a communication interface configured for a suitable protocol as is known in the art. It will be appreciated that as shown in the communication interface may also be integrated into the IC with a direct connection through the PCB to the WAN . The role of the external MCU shown in would be to facilitate the communication of the FCT between the appliance and the ACC over a network e.g. WAN by receiving FCT command messages through the communications interface and reformatting the networked data in this case maybe a stream of bytes into a format that it could pass over its the MCU s memory mapped interface through the ACC parallel interface see also for processing by the ACC . Conversely the ACC would return FCT response messages over its parallel interface to the external MCU for the MCU to translate into a stream of bytes and transmit over the communications interface back to the appliance . The ACC may connect to the agent and thus the appliance via a test interface e.g. JTAG see also FIG. which in turn bridges the connection .

The appliance is a secure module used to cache distribute and collect provisioning data and responses to from one or more agents . For example when an ACC comes on line the appliance can track the parts that it is connected to using the ACC s unique ID UID . The appliance and the ACC may then proceed to exchange key information and open up a tamper resistant communication channel which allows data to be transferred in such a way that the ACC can be certain that it is talking to an authorized appliance and the appliance can be assured that only one unique ACC can decrypt and respond to the message it has sent. Ultimately the ACC can be issued FCTs and provide FCT responses which contain provisioning commands secure data key information serialization information and any other data the appliance wishes to provide to push to upload to inject into or collect from the ACC or the device in general.

The agent may be considered a piece of software that manages the lower level data transmission between the appliance and the ACC . Each agent is coupled to a tester or device programmer and is responsible for passing data transparently between the appliance and the agent . The agent comprises a transport layer API with which the appliance may be used to issue commands and receive responses to from the ACC . It will be appreciated that unless specified otherwise secure operations performed by the appliance are preferably performed within the HSM . The tester or device programmer can be physically connected to the chip through the standard JTAG IEEE 1149 test ports e.g. test interface and connection or another programming interface depending on the application. The agent in either configuration is used to bridge the transport and physical layers. The agent may be considered insecure and in the examples described herein does not perform any cryptographic functions aside from simply providing a message caching mechanism and passing messages between the appliance and the ACC . Of course if desired the agent can also be equipped with cryptographic capabilities of varying degrees depending on the requirements of the application.

The back end infrastructure is a general term referring to the entire backend infrastructure that is used to interface between the manufacturer and its customers end users. Conceptually every device ever processed by the system and all programming records would be kept in a back end database which the manufacturer may use to query the history of each part manufactured. The infrastructure may comprise a CA database engine ERP applications and submodules a feature control server FCS and an e commerce front end server if necessary. The system may also comprise connector logic to connect it to an to an ERP or e commerce front end server. The typical system environment may have the back end server located at a central location talking to an appliance at a customer s manufacturing site via security protocols such as Secure Sockets Layer SSL Transport Layer Security TLS or Level 2 Security MACSec over the interne.

Greater detail concerning the ACC is shown in . The dark outer boundary in denotes a secure boundary such that any operations performed within this boundary are presumed to be trusted.

The ACC is typically a relatively small hardware core with customizable firmware stored in read only memory ROM . In the example shown in the ACC also contains a small microcontroller an elliptic curve cryptography ECC arithmetic unit a hardware based random number generator RNG data read write memory RAM and non volatile memory NVM . The ACC has the ability to participate in the elliptic curve implementation of the Menezes Qu Vanstone ECMQV protocol and the elliptic curve digital signature algorithm ECDSA as well as message encryption and authentication with advanced encryption standard AES based algorithms.

As noted above the ACC is designed to communicate with an appliance connected to a tester or something similar to a device programmer . In order to secure this communication channel the ACC may use an asymmetric cryptography scheme for key exchange and symmetric key cryptography to transfer messages between it and the appliance .

For asymmetric cryptography a public key e.g. Qsi is generated based on a secret private key e.g. dsi . It is important that the private key be protected in a secure highly tamper resistant setting. An embedded ACC is able to fulfill this requirement by being able to internally and autonomously generate a unique private key with a combination of hardware and firmware to protect the secret from being exposed. The private key is statistically unique to a particular device and is permanently associated with that device .

The private key is kept secret whereas the public key is shared. For the ACC the public key or some numerical derivation thereof can be treated as the IC s unique device ID UID as discussed above. Since the private key has a one to one mapping with the public key the UID is also statistically unique to a particular device and is permanently associated with that device when the public key is derived from a static private key .

This technique of IC identification along with the confidentiality and authentication provided by the provisioning protocol described below gives a chip or device vendor the ability to register every authentic part in a database to enact enforcement measures in order to detect and prevent impropriety in the manufacture and distribution of the device such as cloning and reselling over production parts.

The UID can be used as part of the security protocol to establish a secret between the appliance and the ACC through mutual key agreement. During key agreement public keys are traded between two parties each party generates a shared key independently of the other using only the public keys that were exchanged in the open and his her own private key that is kept secret. The result of key agreement is that the two parties arrive at a secret shared between only the two of them while any third parties trying to listen in could not complete the agreement unless they have copies of the private keys.

The appliance and ACC can also participate in an ECMQV key agreement scheme which generates a secret key that is known only to the two parties involved. The shared secret generated e.g. kij is the basis and prerequisite for symmetric key cryptography that is it is used to establish a highly tamper resistant encrypted and authenticated communication channel between the two parties.

Once both parties agree on a symmetric key the appliance can start issuing and receiving signed confidential messages also known as FCTs to from the ACC in a secure and authenticated manner. FCT commands are messages containing either feature provisioning read write access to protected NVM memory regions or any other command or message to be provided to the ACC in a controlled secured and traceable manner. FCT responses are messages containing status audit data or any other command or message to be provided to the appliance in order establish maintain or comply with the secure provisioning protocol.

Privileges can be used to positively enable features at test and manufacture time or enable features upon reconnecting to a server or device programmer in the after market. The lack of privileges can be used negatively to disable non authorized features in a suspect device whether it being a clone a counterfeit or otherwise stolen device.

Completely secured feature provisioning can be achieved through the combination of various cryptographic techniques examples of which are as follows.

Each ACC may have a Root CA public key stored in its ROM or NVM . Each appliance j may then have its own unique certificate CERT APP produced by the Root CA not shown . The certificates may be relatively small and the certificate fields bit mapped for easy parsing. The appliance authenticates itself to the ACC by sending a certificate to the ACC as part of the protocol to be discussed in greater detail below . The ACC uses the CA root certificate to verify the identity of the appliance .

Each appliance can have a customer ID CID assigned to it that is sent along with the certificate. The CID in the certificate should match one of the CIDs stored in the ACC to ensure that a particular appliance belongs to the proper owner producer of a particular device and is authorized to communicate with the embedded ACC . Multiple CIDs on an ACC allows for different vendors on a tiered manufacturing process to provision features that they own. For example an application specific integrated circuit ASIC vendor would configure the SoC for a particular original equipment manufacturer OEM who then configures the device to target a particular equipment seller or service provider and finally the end customer might be allowed to activate yet another subset of configurations based on his her service plan.

The ACC can be made to enforce access control to the third party vendor owned features according to a secure identity data CID of the participating vendors. The original owner of the SoC could potentially load a CID Feature Set configuration table as part of its provisioning.

Each FCT from the appliance to the ACC is encrypted integrity protected authenticated and protected against replay and spoofing in this embodiment. Each FCT may be keyed to the UID of a specific ACC and feature privileges granted only on a per device basis upon the success of unlocking the FCT with a device s private key. A fraudulent device attempting to intercept an FCT locked to another UID would then fail to decrypt the FCT . Each FCT may also be provided a serial number associated with it such that an FCT can only be used once to prevent them from being copied or replayed. Each FCT may be signed by the appliance that issued it so that the FCT cannot be altered in an undetectable manner.

The response from the ACC back to the appliance can be configured to have a serial number and a message authentication code MAC so that even the response cannot be altered or replayed. Since the FCTs are linked to a specific UID the appliance can keep an audit log showing where and what a particular UID was programmed. The audit log can be reported back through the backend to the SoC manufacturer vendor. Should multiple instances of the same UID be detected in a review of these log files it would be an indication that a chip has been cloned or counterfeited.

The use of ECMQV provides an encrypted tunnel that links a specific appliance to a specific ACC . No other party can participate in this protocol or decrypt commands sent during an encrypted programming session. ECMQV in particular may be chosen as the technique to create the channel since it is known to be less vulnerable to the man in the middle attack which is a credible threat in the environment shown.

The ACC and appliance can be configured in various ways to suit a particular environment. The following discusses various features that enable such configurability. The ACC should utilize a very small total silicon area and should support on chip self contained in ACC generation of a UID and on chip generation and storage of ECC public private key pairs. Enablement disablement of scan chain testing of the ACC should be available prior to ACC ECC key pair generation to prevent the private key from being revealed. Authentication integrity protection of commands from the appliance to the ACC should be provided and security critical commands should be unique to a specific ACC . FCTs between an appliance and the ACC should be encrypted for confidentiality and features may be enabled and disabled via FCTs provided to the ACC .

The ACC may function as a protocol enforcer if the received commands are invalid the ACC can reject them and optionally shut down if a threshold of invalid commands were attempted. There should also be the ability to ensure that once the ACC is locked out as in the case when the device is to be retired permanently or if the system detects the device has been tampered with the ACC cannot be re enabled. When not in use the ACC should be capable of powering down to very low current drain and the ACC operation should not rely on external off core firmware or an external CPU to perform its basic functions.

The agent and or any suitable interface e.g. can provide the flexibility to allow customers to add their custom programming interfaces to the ACC which ultimately allows customers to communicate with the ACC using a variety of device programmers e.g. USB port I2C serial interface Ethernet etc. . Similarly ACC programming should be capable of taking place at multiple locations at multiple times provided it can open up a secure communication channel with a trusted appliance . In this way programming can be deferred until the least costly phase of the manufacturing cycle. The appliance and the ACC can be used to securely program and store additional information such as unique device identification numbers e.g. IMEI EIN for mobile phones .

Further detail of the hardware implementation shown in will now be provided. The ACC hardware in this example comprises a microcontroller a memory bus controller to access scratch data ram and NVM and several memory mapped peripherals including an arithmetic unit configured for EC operations an RNG accessible through a peripheral controller and although not shown optionally an AES and SHA core if the area performance trade off is feasible . Additionally the ACC can have an optional generic parallel bus interface and external access NVM interface to add flexibility for SoC designers.

At the center of the ACC is the microcontroller which plays an integral part in all the tasks that the ACC accomplishes including authenticating and executing provisioning commands and enforcing provisioning executing high level security protocols assisting in sequencing the low level hardware cryptographic accelerator functions performing management tasks such as initialization configuration power management and assisting in maintenance built in self test MBIST and a RNG BIST during wafer testing. The microcontroller should be chosen primarily for its size then enhanced to meet speed performance where deemed necessary.

The field arithmetic unit provides hardware acceleration of the low level cryptographic calculations. Specifically the field arithmetic unit should be configured to perform a binary field multiplication efficiently. The field arithmetic unit may be considered an important part of the ACC because it allows the completion of an EC point multiplication relatively quickly. The field arithmetic unit can be used to accelerate both the ECDSA and ECMQV public key protocols used to provide respectively authentication and mutual authentication. The details of these protocols will be explained below.

The hardware and firmware typically trade off in terms of area code memory complexity and performance metrics. Decisions based on what will be implemented in hardware is typically primarily gate count and performance driven. The performance of the ACC has direct cost implications measured in terms of tester time and the equivalent gate count drives the cost of implementation as measured by silicon area.

The RNG with the help of a software conditioner not shown can be used to generate statistically random numbers used as cryptographic keys and UIDs. In elliptic curve public key cryptography schemes a random number is used as the private key and when it is multiplied using elliptic curve scalar point multiplication by the previously agreed upon Generation Point of the curve parameter the product would be the public key. The RNG can be used when the ACC generates its static private key pair which is static throughout the entire life of that ACC . In addition a new ephemeral key is created for every secure session between an ACC and an appliance . Whenever the ACC requires a new static or ephemeral key to be generated the RNG is asked to provide a random bit stream to be used as the seed to generate the private static or ephemeral key. The random bit stream feeds into an AES block cipher to condition the raw entropy produced by the RNG producing a uniformly distributed random number that is used as the static private key. In some embodiments prior to feeding into the AES block cipher the random bit stream can be fed into a software based linear feedback shift register LFSR to condition the RNG data. As part of design for testability DFT testing the ACC should be asked to perform a health check of the RNG .

The ACC in this example can have a 16 bit address ranging from 0000h FFFFh byte addressable memory spaces. The following Table 2 lists how the memory space may be divided into distinct regions in this embodiment.

The microcontroller scratch space XRAM in the above table can be used for temporary data storage by the microcontroller . It may be implemented as fast single cycle access 8 bit byte addressable 32 bit data static RAM. The actual amount of scratch space should be defined based on firmware usage.

The ACC may be configured to have a generic interface to an NVM storage element such as OTP MTP EPROM FLASH etc. NVM is IC technology dependent so an NVM interface for such NVM is likely defined according to the specific application. The NVM interface provides abstraction and should have the capability of writing rewriting and erasing the UID in a secure manner that is easily adapted to a proprietary NVM interface protocol. Certain types of NVM are one time programmable OTP which means that once they are burned they cannot be erased or re written into that memory location. If OTP memories are used then firmware is needed to make sure that it keeps track of which memory locations have already been written to and maintain a mechanism which is used to find the latest data content and where there are available free space.

In this embodiment there are three distinct NVM permission levels each permission level having different restrictions placed on them. First private space permission level wherein NVM is reserved for the ACC s use exclusively. The ACC can read and can write but other agents are prohibited to access this region. Data stored in this region may include the secret static key the UID and the non volatile state of the ACC . Second a protected public space permission level wherein external agents can only write data in this region using the FCTs and the secure messaging protocols with authentication as will be described below. This region is readable from the JTAG port with the RDACCESS type FCTs . This region is also readable from the parallel command interface with a normal memory access as well as with RDACCESS FCTs . Typically this region contains secret data that the customer would want to store in NVM that are only allow accessible by on chip logic assuming the on chip logic does not leak that data to outside the chip. Third a shared memory space permissible level containing other data to be stored in NVM that that the ACC does not need to protect. External agents can read and write in this region either with the cmd SHARENVMWR or the cmd SHARENVMRD or by using direct memory access from the parallel command interface . The cmd commands will be explained in greater detail below. At a minimum the ACC should have enough NVM space with a private permission level to store on chip secrets.

One of the many applications for the ACC is to provide a way to enable and disable features based on customer requirements. Although the exact feature set defining what can be enabled disabled is to be provided by the customer the following describes how a provisioning interface may be used such that adaptations can be made according to specific customer requirements. In short as noted above the ACC comprises a set of output ports denoted by the enablement controller and interface in and evaluates the aggregate of these outputs indicates which features are enabled and which are disabled. In one embodiment there is one enable signal detected over the enablement controller and interface per feature item that would need to be enabled disabled. The raw data that determines the values output to the enablement controller and interface may come from the NVM . It is possible to encode or scramble the enable signals such that there is not a one to one mapping of a particular feature to a single enable signal. In this case you would instead need to evaluate multiple bits of signals to determine whether a particular feature has been enabled. It can be appreciated that it would be up to individual customer application to determine whether this is necessary or feasible. In this way unauthorized feature enabling can be made more difficult at the cost of some additional logic. However whether scrambling is even necessary depends on the actual feature list from the customer and which threat models are being considered.

If the ACC has been compromised as will be explained below it is transitioned into a lock out state wherein the feature enablement is automatically set to some very primitive value where only a bare minimum set of features are enabled for debugging and post mortem analysis. The feature enablement value when in the lock out state may be different than the initial feature enablement of a new device depending on customer requirements.

The amount of time for which the ACC is active is typically relatively short and therefore power consumption while it is inactive should be considered more important than while it is active. The ACC can include power management circuitry provided by the underlying silicon technology to reduce power when it is inactive. For example techniques that can be used to save power when the ACC is inactive include clock gating and power gating may be used.

The ACC shown in also provides a bi directional generic serial command interface to a JTAG test access port TAP controller as defined in the IEEE 1149 JTAG specification. The controller is simply a state machine and implements the feature provisioning commands as JTAG user defined commands. The JTAG specification provides a nicely defined tester interface that can be used by the tester to translate high level commands from the provisioning server into tester commands that are communicated to the design under test DUT through the tester interface.

1 Software MBIST of the RAM and NVM can be initiated by a command issued by the tester . MBIST for RAM and NVRAM involves a fixed pattern across the rows and columns of the memory then reading them back to make sure it contains what is expected. However if OTP NVM is used it is impractical to test every address location so the pattern may be applied to only one address location.

2 Partial scan chain testing inserted for the registers inside the ACC initiated and controlled by the tester . Registers which may be a sub set of control and configuration registers in the ACC deemed to contain sensitive information are excluded from scan chain. The following registers may be excluded from scan chain Life Cycle State and System Ready registers feature enablement registers reset enable register cross clock domain synchronization latches and DFT enable disable register.

3 JTAG Boundary scan is used to test the primary I O of the IC . This is added security to make sure the ACC was not disconnected which might be an indication of an attack. All ACC DFT features are controlled by the ACC s own TAP controller and as such the hardware should be designed so that the DFT features can be enabled and disabled based on the state of the ACC . An uninitialized ACC powers up into a Test State and has DFT features enabled by default. When the ACC receives a cmd EXITTEST software then causes a transition from the Test State to the Initialization State. As a result of this transition the hardware can determine that it is no longer in the Test State and disables DFT features until it is enabled again.

In this embodiment appliance commands are sent serially through the JTAG interface to the ACC s TAP controller as described above. It is possible that is some applications it would be desirable to have an alternate way of issuing commands to the ACC besides a TAP controller and thus a second interface for commands to be sent can be provided namely a generic programming interface. Such a generic programming interface is considered to be simply a 16 or 32 bit processor interface.

The parallelized output from the two command sources should be multiplexed MUXED together and only one command interface should be active at any time. The command interface chosen is the one that issues the first command the TAP controller may be chosen as the default in case there is a tie. The selected interface is the active interface until a cmd REQRESP is completed or an explicit cmd STOPACC is issued or if the device resets. The purpose of the command processing state machine which is implemented in protected firmware running on the MCU is to perform a preliminary decode and filter of the commands issued by the appliance to see how to handle them.

The firmware should have sole control of the state transition based on commands received from the appliance . The first step of transitioning to a new state is to write the new state value to a fixed location in private NVM space. The definitive state value would then be kept in NVM so that if power gets cut before the state was saved the ACC does not revert back to a state that it has already transitioned through upon power up. In other words the lifecycle state transition and the update to the lifecycle state register should be executed as an atomic operation. An overview of the four life cycle states shown in will now be provided.

Test State The ACC is in the test state when it is a brand new un initialized device that has yet to pass testing and sorting. If an ACC is still in this state it implies that the ACC has not completed BIST Scan or other test operations and is thus presumed to not yet be ready for the Initialization State . During the Test State the ACC can execute any number of chip validation tests repeatedly if necessary. Some of these tests can corrupt the internal registers and memory content therefore it is foreseeable for the test program to require multiple reset cycles before being done. The ACC should be designed such that it remains in the Test State through multiple reset cycles until the tester issues one particular command namely the cmd EXITTEST command described below that can be designated as the way to exit the Test State .

The cmd EXITTEST causes the ACC to disable all DFT features and transition to the Initialization State before issuing a soft reset. Disabling DFT features prevents an adversary from using those features to tamper with the SoC without authorization. The DFT features are left disabled until they are explicitly enabled with a FCT issued by an authenticated appliance later on in the Functional State . The least significant bit of the feature register can be reserved to allow DFT in the Functional State . DFT features should not be able to alter the Life Cycle state and having DFT re enabled should not cause the state to change. The soft reset can be helpful to ensure that there are no residual DFT data left in the ACC . The ACC s firmware should be used to update the Life Cycle State value in NVM before issuing the soft reset to ensure that when the ACC restarts its proceeds directly to performing the initialization procedure.

Initialization State In this state the ACC generates its static key pair e.g. dsi Qsi . The x coordinate of the public static key may then be used as the ACC s UID. When this has been done the ACC can update the non volatile life cycle state so that the next boot will proceed to the Functional State . The response to the cmd EXITTEST in this example contains the UID.

Functional State In this state the ACC performs basic health checks updates the feature register and then goes into hibernation waiting for the cmd STARTACC and subsequent commands from the appliance . The ACC can verify that the commands from the appliance are valid and participating in secured communications. If for whatever reason the ACC receives a limited number of what are deemed to be invalid commands in any of the above states the ACC can automatically transition into a Lock Out State . The least significant bit of the feature register allows DFT in the Functional State . DFT features should not be able to alter the Life Cycle state and having DFT re enabled should not cause the state to change. A FCT may be required to set the DFT feature bit bit zero of the feature so that only under secure conditions the DFT can be re enabled. It may be noted that this re enabled occurs typically in a volatile FCT enable operation where DFT capability is lost when the device powers down. The volatile nature of DFT enable allows for multiple enables over the lifecycle of the device even when considering the use of non volatile memory to store enable bits.

Lock Out State This state may be reached if the ACC has encountered one of the following conditions i been issued the cmd LOCKOUT ii detected and exceeded a maximum number of allowed errors iii detected an unrecoverable error. The lock out mechanism is intended to be a deterrent against repeated attempts to attack the ACC and the entire system as a whole. Once the ACC is in the Lock Out state the ACC ceases to process additional commands. Any attempt to communicate using ACC commands thereafter would then result in a LOCKED status as a response. In addition the firmware can either revert to a pre specified feature set or simply maintain the feature set as is prevent further changes to the feature set or protected space of the NVM then shut down and go into hibernation.

Life cycle state transitions are typically progressive and are non volatile that is to say once the ACC has transitioned to a new state it could not go back to a previous state even through power and reset cycles. The exception to this can be the transition to the Lock out State which will be volatile. The Life Cycle State that is stored in NVM should not be modified by going to Lock Out state such that the ACC will be unlocked if it is goes through a power or reset cycle. By preventing command and protocol errors to cause a permanent lock out of the ACC this scheme can prevent the SoC from being permanently disabled inadvertently.

However there are certain errors mostly due to hardware defects that may prevent the ACC from operating normally. If the ACC encounters any of these unrecoverable errors then it is possible for the ACC to be stuck in the Lock Out state permanently. A counter allocated in RAM may be used to keep track of how many error conditions the ACC has observed since reset. Each time the ACC encounters an error condition it would then increment the error count. When the ACC reaches a maximum number of allowed errors the ACC transitions into the volatile Lock out state . The error counter may allow any specified number of allowable errors before locking out the ACC .

The firmware can be organized generally into the following groups a set of cryptographic primitives which includes various underlying arithmetic primitives a set of BIST primitives boot and start up sequencer Life Cycle State functions and a set of functions to interpret and process incoming commands and messages. The cryptographic primitives will be described later following a discussion of the communication protocols and the BIST primitives will be discussed with a discussion of the command handling. The following will thus focus on the boot and start up sequences the Life Cycle State functions and the set of functions to interpret and processing incoming commands and messages.

Boot Start up As shown in at every ACC restart the microcontroller embedded in the ACC automatically starts executing firmware boot code upon power up or coming out of reset. The firmware program should always begin executing the boot sequence in the following order 1 Perform some necessary low level register initializations and configurations 2 Read the feature enablement list stored in NVM and determine which features needs to be enabled or disabled then drive the appropriate feature enable signals 3 Read the NVM to get the last state the ACC was in with before it was powered down reset and 4 Transition into the appropriate Life Cycle State by writing to the Life Cycle State register and jumping to a sub routine that handles everything needed to be done in that particular state.

A diagram illustrating a state transition sequence is provided in . Every state transition may begin with the following sequence First the state transition subroutine has an input parameter indicating the new state it is transitioning to and then does the following 1 Check the new state against the current state to make sure the state transition is valid 2 If the new state is different than the last state stored in NVM update the NVM with the new state value 3 Write the new state value to the Life Cycle State register 4 Decide whether this state transition is the first state transition right after a power up or a hard reset. If it is then go automatically into hibernation mode by default and 5 Otherwise call the corresponding state function to start performing the required operations in that particular state. It may be noted that for step 5 each state has its own subroutine to handle the operations necessary in that state. The subroutines for each of the state subroutines are shown in to

The Test State subroutine is shown in the Initialization State subroutine is shown in the Functional State routine is shown in and the Lock Out State subroutine is shown in . It can be seen that the subroutines generally follow the high level blocks shown in the life cycle diagram of .

It may be noted that as far as firmware is concerned enabling or disabling features involves writing the appropriate values to a set of hardware registers and storing that value in known locations in NVM . It may also be noted that in certain applications the ACC may use OTP memories to store non volatile data. OTP memory does not allow firmware to erase previously written data. Typically OTP memories can be thought of as fuse circuits Every bit has a value of 0 initially and upon writing a 1 to a certain bit location that fuse is permanently burned and could never be restored. For this to occur the firmware should consider whether a piece of data is valid or not where to look for most up to date data where there is free space available and what happens when no more free space and allocating enough extra redundant space to allow for multiple writes. If the NVM is not OTP firmware may treat it as RAM and be free to overwrite existing content. However it should be appreciated that NVM is typically slower than SRAM. Firmware should try to access NVM in bursts to minimize performance impact.

The firmware should store important information to NVM as soon as possible in case the ACC loses power or is suddenly disconnected from the appliance . With certain NVM technologies data written into NVM should be read back to ensure the writes were successful since some NVM write operations may not be 100 reliable. In addition the firmware should maintain a running count of how many failed illegal commands were observed and if the count reaches a threshold firmware should place the ACC into the Locked Out State . Also if a command fails to provide the proper response in a reasonable amount of time it might be an indication that something went wrong inside the ACC or it had been disconnected prematurely. In such cases the appliance could attempt a reset or it would need to log the disconnection in the database and resume the last operation in case this ACC is ever reconnected again.

In order to impede side channel attacks where an adversary extracts secret information by examining information inadvertently leaked out due to implementation details of fundamentally sound algorithms the ACC s firmware may include certain firmware counter measures to mitigate these attacks. The counter measures if any will be specified in the firmware implementation specification. It may be noted that certain counter measures create complexity in the system which in turn increases the execution time and energy consumption.

If the firmware receives a command that is not in a predetermined list such as that in Table 3 even valid commands that are handled by the hardware the firmware can treat such commands as errors and call the error handler function. The commands indicated by DFT in the Table 3 are used to validate the logic on the silicon is manufactured without defect. Some DFT commands have their own protocols and behave differently than the regular command sequence. A description of the actual functionality of these commands will be described later. The DFT commands remain invalid in the Functional State until the DFT features are re enabled through secure feature provisioning via cmd FCT the command associated with providing FCTs .

1 Poll the register NewCmdAvail until it detects the bit value 1 which indicates a new command is available 

6 Prepare the response payload to the hardware where the response payload is in this format where status code contains a 4 byte value SUCCESS FAIL or LOCKED and data contains is as many bytes as required by the command it can be empty for some commands and it should always be empty if the status is not SUCCESS 

7 Set the RspReady bit and clear the CmdInProgress bit at the same time by writing to SWFLAGS register 

8 Wait until SendRspNow is set to 1 indication that the hardware is ready to receive response data from the firmware and write the response data to the registers word by word where word is 32 bit and

9 If instead of the SendRspNow flag you have a NewCmdAvail flag abandon the response and handle the new command instead.

As noted above provides a flow diagram showing the steps that the command interpreter firmware code may take.

An important aspect of the ACC is incorporating protocols to decode verify process and respond to commands that are sent by the appliance . ACC hardware and firmware need to cooperate by communicating with each other through the use of memory mapped registers that are set cleared or polled at the proper instances. Various commands have been introduced above but the following describes further detail of all the commands the ACC accepts in this embodiment to illustrate an exemplary protocol for command handling.

The following Table 4 provides a summary of all the commands that the ACC can process. The function of each of these commands will then be described in more detail.

First some general comments regarding Table 4. The commands indicated as HW only are ones which are handled by the hardware only and the firmware are not aware of them. All the other commands are passed to the firmware to be processed. The commands indicated as DFT in Table 4 are used to validate that the logic on the silicon is manufactured without defects. As the ACC transitions out of Test State DFT commands are disabled and considered invalid. They will remain invalid until the DFT features are re enabled through the secure feature provisioning with a FCT . The REQRESP command is a special command designed to be used to get the response of another command. REQRESP requires hardware and firmware to work together. The commands indicated as SPECIAL are low level hardware commands. They do not follow the command protocol sequence to be described later and they do not return data using the cmd REQRESP . SHARENVMWR and SHARENVMRD are optional and either one or both may be omitted in certain applications. TESTMEM TESTROM TESTNVM and SCAN are optional depending on the application s DFT strategy. The use of STOPACC may also be optional. In some applications this command does not need to be used e.g. if it is intended that the tester device programmer issue a reset when it wants to disconnect from the ACC . Finally some commands are restricted to only certain Life Cycle States . The ACC enforces the validity of the command issued for the current state keeps track of the number of invalid commands encountered and if the count exceeds a threshold the ACC is to be locked out.

cmd REQRESP The purpose of the REQRESP command as mentioned earlier is to provide a request for the response of some other command and as such it should be issued only when it is preceded by another command. There is typically no request payload for this command. The ACC drives all 0 s until the response is ready then it returns the following message Start Of Payload marker STATUS . Responses are comprised of the Start of Payload marker a status and the returned data payload when applicable. The Start Of Payload marker may have the following form 0xFFFF0000 represented by 16 consecutive bits of 1 followed by 16 consecutive bits of 0 s or if the appliance is using the parallel command bus the values 0xFFFF followed by 0x0000 if the bus is 16 bits wide or a DWORD containing the value 0xFFFF0000 if the bus is 32 bit wide. The response comprises one of three status values SUCCESS FAIL LOCKED. The following codes may then be used to designate the response statuses SUCCESS 0xFFFF0001 FAIL 0xFFFF000E and LOCKED 0xFFFF000D.

If the status is SUCCESS there can be a response payload based on the initial command type. The size and content of the response payload will vary from command to command. The appliance should have to keep track of how long the response from the ACC and this should be based on what was the original command that was issued. If the response is anything but SUCCESS no additional information will be returned instead the ACC can repeat a string of 0 s if the appliance has attempted to read after a non success. The appliance may then choose to either retry or abort the operation. In some cases the appliance may choose to disable the ACC permanently by issuing a cmd LOCKOUT . This command is usually issued in the event that the appliance has detected repeated attack attempts defects in the ACC or if it wants to decommission the device. The lack of more insightful status codes than simply status messages may be used to prevent divulging information about the internal operations of the system inadvertently yielding an advantage to an attacker. The REQRESP command in this embodiment is valid in all states.

cmd EXITTEST This command may be used to indicate that all DFT are done and to transition out of the Test State . EXITTEST will disable DFT features transition to the Initialized State cause a soft reset and reboot the ACC . The static keys are generated in the Initialization State making the UID available as a result. The request payload in this example is 4 bytes wherein Payload len 0. An additional response payload is then generated if the command is successful which comprises UID the x coordinate of the static public key of ACC. This command is valid in the Test State . It is recommended that the tester initiates a hard reboot immediately prior to issuing the cmd EXITTEST to remove any residual traces from DFT testing in the ACC . In addition the firmware should assume that the RAM content is corrupted and unreliable so it should execute out of ROM as much as possible.

cmd STARTACC This command may be used to cause a soft reset which effectively wakes up the ACC from power saving mode and reboots. Once the ACC resumes from reset it may begin executing the entire boot sequence. If the ACC is in the Functional State it automatically generates a new ephemeral key pair in order to prepare to establish a new key session with the appliance . There is no request payload for this command. If successful an additional response payload comprises Q the static public key 73 bytes and Q the ephemeral public key 73 bytes . The successful response is sent only in the Functional State after the static keys have already been generated and that it was verified to have been written to NVM correctly . This command is valid in all states. It may be noted that STARTACC may require time for the soft reset boot sequence entropy collection and generation of the ephemeral keys.

cmd STOPACC This command may be used to prepare the ACC to be disconnected. The firmware should then transition into the hibernation mode. The request payload in this example comprises 4 bytes wherein Payload len 0. If the request is successful no additional payload is provided. This command is valid in the Test State the Initialization State and the Functional State . It may be noted that no response is available for this command. Issuing a REQRESP after the ACC has been put in hibernate mode will yield nothing but 0 s when attempting to retrieve a response. The firmware should save all necessary data in the NVM before going to the hibernation mode because in order to resume the hardware generates a reset causing the boot sequence in the firmware and thus all data that is not in NVM after this point will be lost.

cmd LOCKOUT This command may be used to force a transition to the Lock Out State . The request payload in this example comprises 4 bytes wherein Payload len 0. If the request is successful no additional payload is provided. This command is valid in the Test State the Initialization State and the Functional State . Executing this command results in a permanent lock out of the ACC where the ACC then refuses to process any additional commands. In this state the ACC goes to power saving mode and only responds with the LOCKED status when it sees cmd REQRESP .

cmd INITFCT This command is typically the first feature control command in a key session and it is used to instruct the firmware to process a FCT message. The command contains all necessary information to derive a shared secret for the session to secure the tunnel between the appliance and the ACC via the tester and agent . It may be noted that a key session lasts until the ACC is rebooted and the INITFCT command should be issued only once between ACC reboots. If another cmd INITFCT is encountered once a key session has been established it should be treated as an error. To send additional feature provisioning commands after a key session has been established the appliance should use the shorter cmd FCT commands see below for subsequent feature provisioning messages. The request payload for the INITFCT command may be arranged as follows 

Payload len is length of the payload. This field can be used to specify how many 32 bit words are in the rest of the payload. If the payload ends on a fraction of a word the payload len may be rounded up to nearest integer .

CERTis a mini certificate of APP containing CERT VER CID Q SIG where VER is certificate version number 1 byte CID is the customer ID 4 bytes Qis public static key of APP 73 bytes and SIGis the signature for the CERT signed by the root CA where SIG ECDSA SIGN CERT d and dis the root CA s private key.

EMand MACrepresent the encrypted feature provisioning message FCT e.g. 90 600 bytes where EM MAC AES CCM FCT SIG n k FCT being the feature control ticket message 2 512 bytes kbeing the derived encryption key n being a nonce built as msgID 4 zero bytes 8 bytes msgID being a message counter for the current message 4 bytes e.g. always even incrementing by 2 with every FCT command and SIG ECDSA SIGN UID msgID padding FCT d 72 bytes . Here UID is the ACC s UID 36 bytes msgID is the same as above 4 bytes padding comprises zero bytes 8 bytes and dis the APP s private key corresponding to the certificate CERT.

It will be appreciated that the number of bytes indicated above are for illustrative purposes only and may change as required by the particular application.

ERand MACrepresent the encrypted response to the feature command. ER MAC AES CCM FCTRSP n k where FCTRSPni is the response to the FCT command kij is the derived encryption key n is a nonce built as msgID 4 zero bytes 8 bytes and msgID is a message counter for the current message 4 bytes e.g. value of the msgID in the request payload plus 1 always odd .

This command is valid in the Functional State . If the firmware detects this command in the Functional State it can perform the following operations for this command 

1. Reset the message counter msgID to 0 and use it to validate that the ACC s own message count matches what was transmitted while processing the feature provisioning message in step 5.

5. Prepare a response ER MAC to the feature provisioning message. When preparing the response msgID 1 should be used for the nonce n.

If all of the above steps are successful the firmware may then send the status code SUCCESS and ER MAC back. Otherwise the firmware sends the status code FAIL or if the error counter has reached its maximum the firmware transitions into the Lock Out State and sends the status code LOCKED.

cmd FCT This command is used to instruct the firmware to process a feature provisioning message. It is similar to the INITFCT command except that it reuses an existing shared key instead of generating a new shared key. The request payload may be arranged as follows 

Payload len is the length of the payload which specifies how many 32 bit words are in the rest of the payload. If the payload ends on a fraction of a word the payload len is round up to nearest integer .

EMand MACrepresent the encrypted feature provisioning message 90 600 bytes . EM MAC AES CCM FCT SIGnij n k where FCT is the feature control ticket message 2 512 bytes n is the nonce built as msgID 4 zero bytes 8 bytes e.g. always even incrementing by 2 with every FCT command msgID is the message counter for the current message 4 bytes SIG ECDSA SIGN UID msgID padding FCT d 72 bytes UID is the ACC s UID 36 bytes msgID is the same as above 4 bytes padding comprises zero bytes 8 bytes dis the APP s private key corresponding to the certificate CERT and kis the derived encryption key.

ERand MACrepresent the encrypted response to the feature command where ER MAC AES CCM FCTRSP n k FCTRSPis the response to the FCT command kis the derived encryption key n is the nonce built as msgID 4 zero bytes 8 bytes and msgID is the message counter for the current message 4 bytes e.g. value of the msgID in the request payload plus 1 always odd .

The FCT command is valid in the Functional State . The firmware may perform the following operations for this command 

1. The message counter msgID is incremented by 2 regardless of whether the FCT is valid or not and is validated while processing the feature provisioning message in step 2.

3. Prepare a response ER MAC to the feature provisioning message. When generating the response msgID 1 should be used for the nonce.

If all the steps are successful the firmware sends the status code SUCCESS and ER MAC back. Otherwise the firmware sends the status code FAIL or if the error counter has reached its maximum the firmware transitions into the Lock Out State and sends the status code LOCKED. It may be noted that in some embodiments this command requires that a cmd INITFCT command be successfully processed previously so that a key session is available. If that is not true the command would then result in an error.

FCT messages sent to the ACC as part of cmd INITFCT and cmd FCT are typically constructed by the appliance ahead of time and may be non specific to any particular ACC . There are several different types of FCTs and examples of the formatting of the different FCT types may be defined as follows 

Note 1 The shortest of all FCT is the GETFEAT type which is only 2 bytes long. The longest FCTs are of the WRACCESS type which can be up to 512 bytes see notes 2 and 3 for further details .

Note 2 RDACCESS and WRACCESS FCTs in this example can only access data in 4 Byte increments. The address should be aligned on 4 Byte boundaries and the amount of data accessible should be divisible by 4.

Note 3 The minimum amount of data accessible is in this case 4 bytes. The maximum amount of data a WRACCESS can access is maximum EM len len n len TYPE len TAG len ADDR 512 1 1 8 2 500 bytes. The maximum amount of data a RDACCESS type FCT can access is limited by the maximum length of the ER len which is in this embodiment defined to be 512B. The limitations placed on the maximum EM len and ER len is due to the fact that there should be the ability to hold the entire payload within the limited amount of RAM available. If more data needs to be accessed then one would need to break it up into multiple FCTs until they fit within these limits.

Note 4 The WRACCESS and RDACCESS FCTs should only be allowed to access protected areas of the NVM . Attempting to access anything other than protected NVM would then be considered as an error. One exception to this rule can be writing reading the record tag TAG stored in private NVM which is allowed for these commands although the user of WRACCESS should be aware that TAG and DATA are written at the same location in private NVM causing the resulting value in NVM to be an OR operation result of TAG and DATA values.

Note 5 SETFEAT FCTs are used to perform permanent feature provisioning while SETFEAT TEMP FCTs are used to perform temporary feature provisioning. With permanent feature provisioning the FEATSET bits are written into NVM . With temporary feature provisioning the FEATSET value in NVM is OR ed with the FEATSET field of the FCT and as a result will be used as the actual FEATSET for as long as the ACC remains powered on. Once the ACC loses power and or reboots the temporary FEATSET is lost and reverts back to what was stored in NVM .

FCT TAG Record The TAG field of programming FCTs namely SETFEAT and WRACCESS types is used as a history record of what has happened to the ACC in the past.

Each programming FCT may represent a step in the manufacturing process each step has a bit in the TAG record associated with that step. After a FCT is processed the corresponding bit is set to indicate that step has happened. When the appliance constructs the FCT it would then need to know what is the content of the FCT and set the appropriate tag bit. The ACC then keeps a TAG record in a special reserved space in the protected area of NVM . When a FCT is successfully processed the ACC may then bit wise OR the FCT s tag field with the previous TAG record and store the new value back into NVM . By just looking at individual bits of the TAG record the programming steps which were taken can be determined if the bit 1 and which were not if the bit 0 . A brand new un initialized ACC in this case would have a TAG record of all 0 s. The tag record on the ACC is updated as a result of successfully processing a programming FCT or alternatively an arbitrary value can be written directly to the tag record if you know the address of the tag record with a WRACCESS FCT . The TAG record should not be updated if the ACC encounters an error while processing the FCT . The tag record can be read out using cmd SHAREDNVMRD and the read data will be unencrypted.

It may be noted that care should be taken when issuing an WRACCESS FCT that is to write to the tag record the tag record will be written twice once when executing the FCT the second time updating the TAG record. If this were to happen the DATA field should be the same as the TAG field or one of them consists of all 0 s to prevent accidentally corrupting the TAG record.

FCT Responses FCT responses are sent after processing either cmd INITFCT or cmd FCT . The complete response may be arranged as follows 

ER AES CCM STATUS UID n k where STATUS is one of the status codes listed above UIDis the unique ID of the ACC the x coordinates of Q and is data requested by the FCT command where 

n is the nonce built as msgID 4 zero bytes 8 bytes and msgID as above is the message counter for the current message and should always be odd 4 bytes .

It may be noted that STATUS is sent out both in the clear and also part of the encrypted response. Even though the unencrypted status should match the encrypted status unless the status is authenticated by decrypting and verifying the ER there is no guarantee that the unencrypted status is correct because the message could have been altered enroute. Some applications may want to simply look at the unencrypted status to get a quick check on whether the FCT was successful but they should only do it if they are willing to trust the communication channel. The length of the successful response len status ER should be known to the agent when it issued the FCT command so the agent should always assume that the ACC returns that amount of data in the response and reads that amount of data back.

Cmd TESTMEM cmd TESTROM cmd TESTNVM TESTRNG These commands can be used by the chip manufacturers to run functional DFT tests on the silicon die to determine whether the chip is faulty. The request payload identified by Payload len may be 4 bytes and is equal to zero.

if TESTRNG the additional response payload if the command is successful is a 32 bit string of random data as collected by the on board random number generator. These commands are valid in the Test State and the Functional State if that particular DFT feature has been reenabled using a FCT . The enable check is done by firmware.

1. A memory test program marches a specific data pattern across the entire RAM to see if any of the memory bits are faulty.

3. The ROM code health check involves running a CRC 32 on the entire ROM content and comparing that against a hardwired check sum. This is a simple check to make sure the ROM is accessible and fault free it is not meant to secure the ROM code from being tampered with.

4. A RNG test to check the amount of entropy received out of the RNG ring oscillators. This involves collecting a bit stream from the RNG over a fixed period of time then returning the random data to be post processed off chip.

It may be noted that each of these BIST programs has a DFT command associated with it. The command triggers the execution of these test programs and the pass fail test result will be the response status. If any of the BIST program fails the ACC enters the Lock Out State automatically on the first failure. They will not be given the ability to accept multiple additional tries like other invalid command error conditions. It can be appreciated that in other embodiments the application may dictate other DFT strategies in which case only a subset of these commands may be implemented.

cmd SHARENVMWR This is typically an optional command that allows the appliance or other agents to write to the shared region of the NVM . These commands are insecure but they allow open access to the NVM that is within the ACC s control. Typical reasons why these commands should be included a if the design of the SoC only has one NVM that is shared between different multiple functional blocks the ACC would be the gate keeper to that NVM block and help enforce access restrictions b if a system was to use the NVM as a mailbox to and from the ACC and c if the tester needs to inject information to the ACC before a secure session can be established. The request payload may be arranged as follows 

ADDR is the starting address offset from the NVM base address that the command is trying to access which should be aligned on 4 byte boundaries 

WRDATA is the data stream to be written and being SIZE number of bytes long only applicable for cmd SHARENVMWR .

For this command if successful there would be no additional response payload. This command is valid in the Test State and the Functional state . The maximum amount of data that is accessible is limited by the maximum amount of contiguous shared NVM spaces available up to 64 KB. The firmware should check the address and size of the request against a pre programmed NVM permission table and make sure the entire access is permitted. If any part of the access is outside of Shared NVM space then it is considered as an error and the command fails. The exception to this would be when reading the TAG record which is located in a special reserved Protected area of the NVM .

cmd SHARENVMRD This may also be used as an optional command that allows the appliance or other agents to access the shared region of the NVM . These commands are insecure but they allow open access to the NVM that is within the ACC s control. Typical reasons why these commands should be included are a if the design of the SoC only has one NVM that is shared between different multiple functional blocks the ACC would be the gate keeper to that NVM block and help enforce access restrictions b if a system was to use the NVM as a mailbox to and from the ACC and c As pointed out above the cmd SHARENVMRD can be used to read back the FCT TAG record that is located in a specially reserved area of the NVM . The TAG record is readable in the clear with the cmd SHARENVMRD but should not be writable with cmd SHARENVMWR . The request payload may be arranged as follows 

ADDR is the starting address offset from the NVM base address that the command is trying to access and should be aligned on 4 byte boundaries and

If the command is successful the additional response payload comprises RDDATA which is of flexible size. RDDATA is a data stream of SIZE number of bytes long only applicable for cmd SHARENVMRD . It should be presumed that the agent talking to the ACC can calculate the length of RDDATA beforehand. Also the appliance that created the command should let the agent know how much data to retrieve when it sends down the SHAREDNVMRD command. This command is valid in the Test State and the Functional State . The maximum amount of data that is accessible should be limited by the maximum amount of contiguous shared NVM spaces available up to 64 KB. The firmware checks the address and size of the request against a pre programmed NVM permission table and makes sure the entire access is permitted. If any part of the access is outside of Shared NVM space then it is considered as an error and the command fails.

cmd SCAN This command indicates that the tester wants to start scan testing the ACC . The request payload is 4 bytes and the Payload len 0. If the command is successful no additional response payload is provided. This command is valid in the Test State and the Functional State if this particular DFT feature has been reenabled using a FCT . The enable check is done by firmware. The ACC should set the ScanMode bit high.

cmd REQVERID This command may be used to request the ACC s version ID which is used to identify the hardware and software revision of the ACC . This command can be useful in cases where there needs to be a way to distinguish protocols and feature differences between different versions of the ACC . Typically this command is the first command sent to confirm that all parties are in agreement as to the exact protocol to use in further communications. There is no request payload for this command. The response may be arranged as follows 

Both firmware and hardware version IDs are both 8 bits. The actual values of these fields are determined based on which revision of the ACC design is in use. REQVERID should always return with a response immediately. The response will not have a Start of Payload marker nor will it have a status field. HW Version ID should be hard wired and as such always available. FW Version ID is initially all 0 s until the firmware loads the correct value from ROM and writes that value to the FWVERID register at boot time. If the FW Version ID is 0 then it indicates that the ACC has not started to run yet and should try again later. If the response is anything other than known VERIDs it should be considered as a fatal error. This command is valid in all states shown in .

cmd IDCODE This command returns the IDCODE of the ACC s tap controller per IEEE 1149 spec. further detail of this command can be found in this spec . There is no request payload for this command. The response may be arranged as follows 

The IDCODE should be a hard wired constant and thus should always return a response immediately. The response will not have a Start of Payload marker nor will it have a status field. The actual value of the IDCODE is typically application specific. This command is valid in all states.

cmd BYPASS This command puts the ACC tap controller in bypass mode per IEEE 1149 spec. Every bit that gets shifted in is delayed by 1 TCK clock cycle and shifted out. This command is valid in all states.

A high level description of the communication protocols is now provided. As has been discussed the appliance communicates securely with the ACC using messages known as Feature Control Tickets or FCTs . In the system there are two interfaces with which the appliance can communicate with the ACC .

One interface is the JTAG test interface as defined in the IEEE 1149.1 standard for test access port and boundary scan architecture. The interface standard includes the definitions of a set of control and data signals a test access port controller and a mechanism and instruction set to support testing of the circuit. Although the JTAG interface is typically used to test integrated circuits for manufacturing defects the standard includes provisions for individuals to extend the command set to implement user defined functions.

In addition to the JTAG interface this embodiment provides a secondary command interface for connecting a parallel bus to enable the additional flexibility of allowing after market reprogramming or if there is no access to the JTAG interface . The secondary command interface can be configured to look like a simple generic memory mapped bus. The data width on the secondary interface could be configured to be 8 16 or 32 bits depending on the application s requirements.

It may be noted that although the JTAG interface and Parallel Command Interface are physically different one being a serial interface the other being a parallel bus they share a common set of commands and responses. The two interfaces are multiplexed together in hardware via command interface MUX to present a uniform interface to the firmware. As such the differences in the physical implementations can be hidden from firmware.

a The appliance agent should always be the one to initiate communication with the ACC through a tester or a customer dependent device programmer .

b The ACC can be considered a slave in the command protocol such that it can only respond to commands it cannot initiate them. For example in this configuration the ACC does not even send response data without being prompted to do so.

c The microcontroller in the ACC is single threaded with no interrupts. Therefore it can only work on one task at a time and will have to complete that task before it does anything else. If another command arrives before that task is done the new command will need to be ignored.

d A wafer tester typically does not want to waste time waiting for the ACC to finish its time consuming calculations. Instead it will want to move on to do other things and come back when ACC is close to completing a command.

e The JTAG interface specification requires every JTAG implementation have an Instruction Register IR and a Data Register DR . Both registers are readable and writable by the tester . In this example there are two versions of IR DR register pairs. One is located in Tap and JTAG interface the other in the parallel interface . The Cmd Interface Mux arbitrates between the two versions and routes the IR DR data accordingly to the peripheral controller . The tester would write to the IR to tell which command to execute. It can send request data by writing to the DR and it can capture the response data by reading from the DR. Similarly the parallel command interface reuses this paradigm as much as possible so it will also have an IR and a DR but they can be implemented as a memory mapped register on the bus.

Depending on the command programmed reading the DR after writing might not get back the same content that was written. The tester may read and write the IR and DR at any time but this may result in corrupt data or be out of sync if done at inappropriate times. The transaction protocol described below specifies when reads and writes can occur and what the expected results should be.

Turning now to an example single command sequence is shown. The tester initiates one of the commands listed in Table 4 to the ACC by writing the instruction code to the ACC s Instruction Register IR at 1a . As soon as the IR is updated signifying a new command is issued the ACC decodes the command and prepare to absorb the correct amount of data associated with that command at 1b . The tester then sends the data payload associated with the new command by writing data to the ACC s data register DR at 2a . If the request payload is not sent in full the ACC will hang waiting for the remaining data indefinitely. The ACC will be responsible for sampling the data register as fast as the tester sends it and storing the entire payload into scratch data RAM at 2b before executing the command itself. The ACC then issues reads to the DR and inserts wait states to stretch out a read cycle until a ready signal indicates that new data has arrived.

The actual throughput limit is based on JTAG and ACC system clock frequencies and the ability of ACC s microcontroller to move data from the DR to its RAM . When using the custom parallel interface there is the potential for data to be sent faster than the ACC can copy in which case flow control to limit how fast the bus should be written. In any case the ACC should be configured such that incoming data is not dropped.

After the entire payload has been sent and absorbed the ACC starts to process the command. The agent waits until the command has completed before issuing another command at 3 and this could take a relatively long time. Each command can take up to a fixed maximum number of cycles to execute that type of command. If the appliance waits this maximum number of cycles it can ensure that the ACC will finish processing the command. While the ACC is processing at 3 the appliance agent tester may use the waiting period to opportunistically perform other tasks e.g. testing other parts of the SoC if possible. If the tester does not wait and issues a new command before the previous command is finished it is considered a protocol violation and the new command will be ignored. The exception to this is the cmd REQRESP and some special commands handled by the hardware exclusively .

When the appliance is ready to come back and ask for the response it issues the command to Request for Response cmd REQRESP at 4 . When hardware logic detects this it sets the SendRespNow flag. If the tester reads from the DR without first sending the cmd REQRESP it will get 0 s. Once the ACC has finished processing the command and the result is ready firmware can check the SendRespNow flag to see if the cmd REQRESP has been issued. If the cmd REQRESP is issued before the ACC finishes executing the command the ACC sends 0 s until it finishes and have the full result ready at 5a . If the cmd REQRESP was issued and the ACC has finished executing the command and has the response ready the ACC can begin to send the response which comprises a Start of Payload marker followed by a response status and then the response payload if there s any at 5b .

If there are response payload data to be sent the ACC copies data from the response buffer in scratch RAM to the DR as fast as the appliance reads from the DR. This continues until the entire response payload is sent. Again the actual throughput limit is based on clock frequency and the ability of ACC s microcontroller to move data from the RAM to the DR. When using the custom parallel interface there is the potential for data to be read faster than the ACC can copy. In that case restrictions can be placed on how fast the bus should read data.

The tester should read the DR until it sees the Start of Payload marker at 6 then continue to read the entire response. Once the Start of Payload is sent and read by the tester it should not issue another command before the entire response payload is read or else the system may behave unpredictably including hanging indefinitely.

If the agent continues to read after the entire payload has been sent the ACC will resume sending all 0 s. Should additional programming be required the appliance can repeat these steps. If no additional programming is required the appliance can finish by transitioning the ACC to hibernate mode with a cmd STOPACC .

Some additional comments regarding the REQRESP may be noted. First the reason for the explicit request for response is to keep the appliance and the ACC synchronized but it may also allow the tester to perform other tasks in parallel instead of waiting for the ACC to respond. If a command requires some sort of response from the ACC the appliance would issue a cmd REQRESP before it issues the next command or else the response will not be sent and will be discarded. If the appliance issues two cmd REQRESP back to back without a valid command in between then this sequence can be considered a protocol violation. The actual behaviour of the ACC would then make it appear like the second REQRESP is discarded. It is recommended that every command be followed by a cmd REQRESP just to close the transaction loop but the protocol allows omitting the cmd REQRESP if the appliance is not concerned with the status or return data. The ACC should always prepare the full response assuming it will be requested at some point only it without transmitting it without a cmd REQRESP .

Once a cmd REQRESP is issued and the Start of Payload is sent the appliance needs to make sure to read the entire response. It may not issue another command before all the response is read or else the system may hang indefinitely. If for some reason the appliance does not get a Start of Payload after the expected wait time has expired it may be an indication that something is wrong and that the ACC is stuck in some unknown state for unknown reasons. When that happens the safest thing to try when attempting to recover from such error is by issuing a STARTACC command to reset the ACC . Although resetting may not be a guaranteed way to recover from all possible foreseeable or unforeseeable failures.

On the server side the appliance should record the initialization event and relay the information obtained as a result of the initialization sequence back to the database in the backend infrastructure . The information such as the part number lot number wafer ID time agent s ID location operator ID and such are valuable information that would allow the vendor to track the history of each individual SoC die using the ACC s UID as a reference.

A set of preconditions should first be considered. A newly fabricated ACCis powered up and connected to APPagent through a tester or device programmer . ACCwould still be in the Test State . If the ACC is not in the Test State it means that it has previously been initialized. If the ACC is in the Initialization State the procedure shown in would jump to 3 . If the ACC is in the Functional State the procedure shown in would jump to 6 . If the ACC is in the Locked State the ACC would remain in the Locked State go to power saving mode and return LOCKED status when a response is requested.

A set of feature provisioning bits may be used to control whether certain DFT or debug features are enabled or disabled and such bits would be application specific.

As another precondition APPshould obtain the ACC s version ID VERID which is composed of a hardware version number and a firmware version number in order to find out which version of the communication protocol to use. If this has not been done yet a cmd VERID may be sent the ACCto obtain the VERID. This allows the APPto account for slight protocol variations between different generations or stepping of ACC.

APPmay also have assurances that the ACCis healthy and functional by making sure it has passed all DFT tests available.

Finally a precondition may be that ACCdoes not have any residual artifacts which might impact operations from defect testing such as scan and memory BIST. DFT features would need to be carefully designed to make this possible.

The procedure shown in will now be described. First ACCpowers up and detects that it is booting from a hard reset and that it is still in the Test State . As long as the ACC is still in the Test State firmware ensures that all DFT features are enabled. ACCshould be able to perform any DFT tests at pre and to undergo multiple hard reboot cycles without effecting its ability to protect secure data later in its life cycle.

At some point APPissues a cmd EXITTEST at 1 to signal that a basic set of tests has finished successfully and now ACCshould start to disable some DFT features. When ACCsees EXITTEST it a writes 0 s to the FEAT register to disable DFT features b changes the Life Cycle State in NVM to the Initialization State and issues a soft reset at 2 .

Upon rebooting ACCshould find that a it s booting due to a soft reset by looking at a HW flag b it s in the Initialization State by reading the state stored in NVM and c that this is the first time both a and b are both true at 3 . Then the ACC writes an Exit Test marker to NVM to indicate that this ACC has exited the Test State and proceeds to perform its usual Initialization State tasks see 4 below . If the next time ACCreboots and a and b are true but the Exit Test is already set then it means that the initialization failed and the device is now unreliable. In which case ACCwill transition to the Locked State immediately.

While in the Initialization State ACCattempts to generate the static ECC keys d Q at 4 according to an EC key generation function to be discussed later. If key generation fails the ACC would transition to the Locked Out State directly. If key generation is successful the ACC prepares a success response payload having SUCCESS UID . ACCthen updates the Life Cycle state in NVM such that the next reboot will cause the ACC to start up in the Functional State . The ACC would then wait to process additional commands and should not go into hibernation.

If the APPoptionally issues a cmd REQRESP at this point the response would be either LOCKED or SUCCESS UID . APPwill typically collect the UIDs of all the chips it has initialized making sure they are valid public keys and forward them to the backend database at 5a along with other information deemed to be useful to facilitate tracking and cataloguing the dies. At 5b the backend may store the UID store the ID of the appliance that was used and increment a device production count.

A cmd STARTACC is the next command issued in the typical initialization sequence at 6 . Alternatively the ACC may be power cycled multiple times at this point and the behaviour can expect to be the same. ACCmay come out of reset run its boot sequence and come up in the Functional State . In the Functional State ACCshould always automatically start to generate the ephemeral key d Q according to the EC key generation function to be described below. If key generation is successful the response will be SUCCESS Q Q otherwise the response will just be FAILURE or LOCKED .

In the meantime the tester has the option to go on to perform other tasks while waiting for the ephemeral key to be generated. When the tester is ready to retrieve the ephemeral keys it will issue a cmd REQRESP at 7 and wait for a response from ACC.

When ACChas the response ready and has seen the cmd REQRESP it will send a Start of Payload marker followed by the response payload back to the APLat 8 .

APPis then expected to extract the information from the response and process it accordingly at 9 . If the return status is a FAIL or if the appliance cannot process the data that was received APPhas the option to issue a cmd LOCKOUT to lock out ACC. The initialization process may then perform post operations. The appliance agent tester may issue additional commands or disconnect and the ACC may process such other commands in the Functional State .

Some additional features regarding the initialization protocol may be noted. First the entire initialization process can be streamlined down to be completed very quickly because tester time is very costly. As soon as the appliance has ACC s UID the appliance can issue a cmd STOPACC to have the ACC run its power down routine and go into hibernation low power mode. When the ACC sees the cmd STOPACC it should explicitly overwrite all sensitive data from its scratch memory to prevent exposing secret data if at all possible. However it can be appreciated that if the device was hot unplugged the ACC would not be able to neatly wipe out secrets in SRAM and shut down properly.

Once the initialization sequence is completed the ACC can reconnect to the appliance through a different agent at a later time perhaps further down the product manufacturing line such as packaging during board assembly or even after the device is fully assembled and being activated at the end retail location by an end customer. The UID is defined to be the x coordinate of which in this example is a 283 bit number. It is noted that the UID of chips should be registered as soon as convenient in order to detect chips with duplicated UIDs being out in the field.

Turning now to a protocol for establishing a secure communication session using key agreement is illustrated. Up to this point in the present example all the testing and initialization commands between an appliance and an ACC that have been described thus far are sent in the clear . In order to start secure communications the two parties will need to participate in a key agreement protocol and the cmd INITFCT can be used to do that.

The cmd INITFCT is broken up into two parts the first part has all the necessary information needed by the ACC to derive a shared secret for a new key session and the second part contains the first FCT that needs to be processed. For the protocol in several preconditions may exist. First an initialized ACCwould have already generated its static and ephemeral keys d Q d Q . Also APPwould have received and validated Q Qand it would be able to extract UIDfrom Q. If these first two preconditions are not satisfied the initialization sequence shown in may be executed. The appliance has its static key pair d Q and a certificate CERT APP signed by the Root CA. Also APPhas some indication that it needs to communicate with ACC. This could be either a manufacturer wanting to preset some default features before shipping or could be a customer requesting a new feature on his her device to be enabled. Another precondition is that ACChas been pre programmed with the Root CA s public key Q in its ROM . Optionally ACCis pre programmed with a customer ID CID in its ROM . ACChas not received another cmd INITFCT after it was last rebooted. If it did it s considered as a protocol error. Finally a precondition is that ACCis ready to handle a new command. This means that ACCis in the Functional State is not in hibernation mode has completed all previous tasks and is now waiting.

The output will be the status FAIL or the status SUCCESS and ACC s ephemeral public key Q. It may be noted that various side effects can occur. ACC s message counter number msgID may get reset to zero and both parties could have generated the shared session key kindependently from each other.

The procedure shown in proceeds as follows. The appliance generates its ephemeral keys for this session d Q at 1 . The appliance then issues a cmd INITFCT at 2 with the request data being Q CERT EM len EM . The ACC receives the command and validates the certificate and the public key ECDSA VERIFY CERT Q and public key validation Q respectively at 3 . The ACC then extracts Qfrom CERT APP . If the protocol requires matching a customer ID CID a CID field in the CERT would have to match against the CID stored in ACC .

The ACC then computes a shared session key k with ECMQVwKDF d d Q Q at 4a . If 3 and 4a are successful the ACC continues on to process decrypt and authenticate the FCT in the rest of the payload at 4b . Otherwise the ACC may stop here and prepare a FAILURE response. If the response is FAIL the appliance can either restart the sequence or issue a cmd LOCKOUT . The appliance can optionally log the error in the database.

A few additional features may be noted. First if everything was successful the shared session key kcomputed at the end of this sequence forms the basis for an encryption tunnel using symmetric key ciphers between linking an authorized appliance to a specific ACC . Any other ACC or appliance would not be able to participate in any further communications between the two because kis known only to the two authorized parties. This sequence may not be repeated without a reboot by using either a hard reset or a cmd STARTACC . There should be no limit as to how many times the ACC can be rebooted but each time the ACC reboots a new ephemeral key will need to be regenerated which could take a noticeable amount of time in the range of hundreds of milliseconds. If the ACC encounters any error or failures during any step of the key exchange protocol it should call the Error Handler subroutine as described above.

In step 3 the ACC verifies CERT APP using a copy of the Root CA s public key that the ACC has in its ROM . The certificate validation step lets the ACC know that the root CA has authenticated and qualified this particular appliance to issue commands to this ACC . This is to prevent untrusted appliances from issuing sensitive commands to the ACC . If a particular application requires the use CIDs the certificate will contain a CID which has to match with a CID stored in a table in the ACC s ROM . This is to meant prevent an appliance assigned to a particular customer from being used to connect to parts manufactured for another customer. If the CID in the certificate is not found in the CID table it will be treated as an error.

The APPand ACChave their own copies of the following variables and the two copies should match a shared session key k that had been generated as a result of the key agreement protocol and msgID the command serial ID that starts from 0 on cmd INITFCT and increments by 2 for each cmd FCT always even and for responses it equals to msgID from the corresponding command plus 1 always odd .

The input is a FCT and the output is the status FAIL or the status SUCCESS and whatever data that was requested by the FCT . One side effect is that depending on the type of FCT either features on the SoC gets enabled disabled or some data was accessed out of the NVM . Another side effect may be that both APPand ACCincrement their copy of the command serial ID count msgID.

5. If everything verifies correctly ACCperforms the operations requested by the FCT and prepares the FCT response message.

8. APPreceives the response then decrypts and verifies the response. If the appliance requires sending more commands or tries resending the same command it may do so without rerunning the key agreement protocol i.e. another cmd INITIALFCT should not be sent as long as the command serial number gets incremented.

Various error conditions may be noted. First if ACCencounters any error or failures during any step of the key exchange protocol it should call the Error Handler subroutine see . For step 8 if APPreceives a FAIL response APPcan either retry the sequence or issue a cmd LOCKOUT . The appliance can optionally log the error in the database.

Some additional features regarding this protocol may also be noted. First the command serial ID msgID starts with 0 and increments by 2 with every cmd FCT in this session. It gets reset back to 0 at the beginning of a new session as a result of a key agreement protocol. However for the responses to cmd FCT msgID is equal to the msgID in the corresponding command plus 1 . The use of this ID prevents the same command and response to be reused in replay type of attacks. For example imagine an adversary pays to enable some features then capture the FCT messages and immediately asks to disable the features to get a refund only to turn around right away and replay the enabling FCT . Alternatively an adversary initially forces the appliance to issue an invalid command to generate a FAIL response then ask to be issued an enablement FCT . When the ACC is asked whether the command was processed properly the adversary could substitute a success response with the recorded FAIL response thereby successfully pretending to have the enablement not go through.

The UIDties the command and response to one ACC to prevent an adversary from being able to replay this message on another ACC . The key pair dand Q uniquely identifies the specific appliance who participated in the shared key agreement session that created the session key k. When they are used in the signing process it can be used to positively identify the originator of the message. Furthermore through the use of a CERT APP that is certified by the Root CA during the key agreement protocol the ACC has the assurance that this appliance is permitted to be issuing FCTs .

It may be noted that there are two possible application scenarios i FCT messages are created by the backend on a per use per ACC basis if the device has already reached the retail space and ii FCTs could be something the backend batch configures an appliance which then automatically apply to an entire batch of ACC embedded dies that it encounters. Depending on how the FCT is used there may be some server side optimization that can take place when performing step 1 .

A discussion of the underlying cryptographic algorithms used herein will now be provided. As noted above EC arithmetic is advantageously utilized. It is widely held that ECC offers the most security per bit of any public key cryptographic scheme. In addition it can be implemented in hardware quite efficiently leading to a very small core in terms of silicon area. The ECC parameters utilized by the system are in this example set according to the sect283k1 FKoblitz curve recommend by the Standards for Efficient Cryptography Group SEGC . This curve is selected to facilitate an overall strength that is equivalent to 128 bit strength. If this level of security is not needed in a particular application the field parameters may be reduced to use smaller numbers.

The block cipher function chosen to be used in the ACC is in this example an AES symmetric key block cipher. Further detail can be found by referring to FIPS 197 for the AES specification as well as the SP800 38A and SP800 38C for the definition of the CTR and CCM block cipher modes. The parameters for AES where ever it is used in the ACC will in this embodiment be a 128 bit key blocks of 128 bits of data as input and blocks of 128 bit bit stream as the output. If the input data stream does not fit into a 128 bit block 128 bits can be broken off at a time.

In the context of the ACC the block cipher may be used in several different ways a condition the random bits obtained from the RNG ring oscillators to produce the random strings used as private keys b use as a hash function in the Key Derivation Function KDF when generating the shared key in ECMQV c use as a hash function when verifying the authenticity of a FCT signature d decrypting a FCT in counter mode and e encrypt and provide message authentication of the response to a FCT .

AES CCM mode may be used to provide authentication and encryption for the responses to FCT commands. CCM mode as described in SP800 38C is essentially two AES modes that are defined in SP800 38A the Counter CTR and the CBC MAC mode combined together with some additional formatting and transformations as described in appendix A of SP800 38C . The ACC in this embodiment implements CCM which is CCM mode with additional formatting and transformation to be compliant with other real world implementations of CCM mode such as it is described in Zigbee.

b an 8 byte nonce unique to each message that uses the same key. The nonce is initialized with the message counter msgID in the first 4 bytes concatenated with 4 zeros after that.

The output is cipher text C C . . . C followed by the encrypted MAC C. The encrypted MAC or the tag as referred to in SP800 38C would be fixed to be 128 bits long. Although the CCM specification allows for the option to turn off encryption the ACC should be configured to always encrypt. The specification also allows for an optional associated data input which in this embodiment is chosen not to be used. As such the associated data string will always have a length of 0 .

Turning now to the Matyas Meyer Oseas Modification Detection Code MMO MDC function is shown which is based on AES 128 block cipher and is the hash scheme deployed in the ACC in this example. The inputs comprise an input bit stream x and the output is a hash digest. A constant value of the 0 is used as the initial vector hash . For each block i of the input bit stream the bit stream text xgets sent in as the input to the AES along with the previous block s hash value as the cipher key. The output of the AES block is XOR ed with the input x to form the hash result hash. This is repeated until the entire message is processed. After sending the entire message through the final hash value is output as the digest.

As discussed above the ACC in this embodiment will have an on chip ring oscillator source of entropy which relies on the fact that there is phase jitter between the oscillator samples. The ACC firmware collects oscillator output data values from the ring oscillator hardware and uses an AES block cipher for conditioning. The ACC RNG hardware provides at least bit of entropy for each bit read from the RNG hardware . The ACC in this example will follow NIST SP800 90 such that 

2 Obtain 256 bits from ACC HW RNG entropy input to be used in 3 that contain at least 128 bits of entropy.

3 Follow 10.2.1.3.1 NIST SP800 90 for CTR DRBG instantiation The Process Steps for Instantiation When Full Entropy is Available for the Entropy Input and a Derivation Function is Not Used where entropy input is a random bit stream from 2 personalization string is null and Update function specified in 1 . It may be noted that the following values inside Update during this step Block Encrypt Key 0 IV 1 and Block Encrypt Key 0 IV 2 can be pre computed for speed ups.

4 Since the full entropy is not used as input in 3 finish instantiation by generating 1 byte of random data see 5 and discarding it.

5 Define CTR DRBG Generate algorithm as 10.2.1.5.1 NIST SP800 90 The Process Steps for Generating Pseudorandom Bits When a Derivation Function is Not Used for the DRBG Implementation .

The procedure may be summarized as follows. The firmware enables the RNG to start capturing data. The RNG hardware performs self calibration with respect to the ACC s system clock and determines how many system clock cycles are needed between sampling the ring oscillator outputs. The hardware captures one entropy bit per sample period and notifies firmware when it has 8 entropy bits by asserting a Ready flag. The firmware polls the RNG for the RNGReady flag and reads the 8 bits. The firmware repeats this until it has obtained 256 bits from ACC s RNG . Meanwhile firmware continuously verifies that the RNG hardware is healthy by checking the RngError flag. The TR DRBG Generate algorithm as 10.2.1.5.1 NIST SP800 90 is then executed with the parameters listed above.

Elliptic Curve key generation may refer to how a key pair is created from random number stream. A prerequisite is that previously agreed upon EC curve parameters have been selected. The input is a random bit stream and the output is SUCCESS and a key pair d Q or FAIL. 1 construct a 283 bit bit stream by perform the random number generation described above to form the private key d. 2 Repeat step 1 if d 0.3 Perform an EC point multiplication with the generating point of the EC parameter to create the public key Q d G. 4 Repeat from step 1 if Q is not a valid point on the EC. 5 If this key pair is to be used as the static key store d Q in NVM . 6 If an error occurred during any step of the process return FAIL otherwise return successful and the key pair d Q .

ECMQV The goal for key agreement is for two parties to independently derive a shared secret that can then be used as a symmetric key for bulk data encryption. It requires each party to use two pairs of keys one static and one ephemeral where each key pair comprising of a secret private key and a public key. In the present embodiment a variant to the two pass ECMQV protocol is utilized skipping the explicit key confirmation step. It has been recognized that the keys can be implicitly confirmed when messages cannot be decoded properly i.e. we will know if the keys don t match when FCT messages starts failing to be verified unsuccessfully.

The Key Derivation Function KDF is used to derive a key from a shared secret bit string. In the context of this example the shared key may use the MMO hashing technique as the KDF. The input is a 283 bit string as the shared secret value x and the output is a 128 bit string as the shared key k. k MMO MDC x .

The Associated Value Function AVF is used to truncate the x coordinate of an elliptic curve point according to ANSI X9.63 ECMQV AVF. The high half of the x coordinate is truncated and then the lowest bit of the highest half is forced to be 1 to avoid obtaining all 0 s.

The public key validation step is to verify that the public key was generated and received properly. The key validation step checks to see if it meets some basic properties of a valid key. The inputs are EC Domain Parameters and a candidate public key Q. The output is either ACCEPT or REJECT. 1 Verify that Q O. 2 Verify that xand yare elements of the underlying field F. 3 Verify that Q satisfies the EC equation defined by the EC domain parameters. 4 Verify that 4 Q O. 5 Return ACCEPT if satisfies all of the above else REJECT.

The ECMQV shared key generation is a way for two parties to derive a shared secret key. After each party derives the shared secret key there is an optional additional exchange to provide key confirmation. The following describes how party 1 is to compute the shared key with party 2 . The inputs are EC Domain Parameters two validated EC private keys d and d owned by party 1 two validated EC public keys Qand Qowned by party 2 . The outputs are session private key k and a status SUCCESS FAIL. The procedure is as follows. 1 Compute the integer s d avf Q d mod n . 2 Compute the EC point Z h s Q avf Q Q . 3 Check if Z O output FAIL and stop. 4 Let xbe the x coordinate of Z and compute k kdf x . Key generation is sometimes followed by an explicit key confirmation to make sure both parties arrived at the same k but may be omitted due to performance concerns. One can also implicitly rely on the fact that if keys were not the same messages could not be decrypted properly.

The Elliptic Curve Digital Signature Algorithm ECDSA is an efficient method to check data integrity data authentication and provides non repudiation. The ACC may use the ECDSA algorithm where the hash function utilized is MMO MDC described earlier.

As discussed above the root CA certificate can be signed using ECDSA and the Appliance can sign FCTs using ECDSA as such an overview of ECDSA will be provided. The inputs comprise EC Domain Parameters private key d and message M. The output is a digital Signature r s . 1 Select a random number k in 1 n 1 . 2 Generate an ephemeral key pair Q k G. 3 Take the x coordinate of Q x and convert it into an integer x int x . 4 Compute r x mod n. 5 Compute e MMO MDC M . 6 Compute s k e d r mod n. 7 If s 0 then go to step 1. 8 Return r s .

For each message that the ACC receives from the appliance it will need to verify the signature to make sure the message comes from the appliance it thinks is sending the message and that it has not been altered while in transit. This is the purpose of the signature verification step. The inputs comprise EC Domain Parameters public key Q message M and signature r s . The output is either ACCEPT or REJECT. The signature verification using ECDSA may proceed as follows. 1 Verify that r and s are integers in the interval 1 n 1 . Return REJECT if either criteria fails. 2 Compute e MMO MDC M . 3 Compute w s mod n. 4 Compute u1 e w mod n. 5 Compute u2 r w mod n. 6 Compute x y u G u Q . 7 H X O then return REJECT. 8 Take the x coordinate x and convert it into an integer x int x . 9 If r x mod n return ACCEPT else return REJECT.

Turning now to through an example sequence of operations is provided which illustrates the use of the system in provisioning delivering and implementing a FCT in an ACC . The example describes a way of utilizing virtual inventory by permitting controlled and secure feature activation using the ACC .

Referring first to it can be seen that the backend infrastructure which may represent the original manufacturer would first define a product define FCTs and assign such FCTs to the product e.g. refer back to and use of the controller . As discussed above the system may comprise multiple appliances at multiple locations. The backend would then assign a product to an appliance and provide credits for producing an agreed upon or stipulated number of that product as well as the product ID and the FCTs to appliance j. The backend at this time may log the event to record which appliance is associated with which product how many credits were provided and the number and nature of the FCTs for that product. The appliance upon receipt would store the product ID FCTs and retain a record of the number of credits it has received.

The agent then determines the product ID associated with the product being provisioned or communicated with and sends the command cmd EXITTEST to transition the ACC into the Initialization State . The ACC upon transitioning generates its static private key dsi and its static public key Qsi and transitions into the Functional State . A first loop Loop 1 now begins which comprises a series of transactions between the appliance agent and ACC that represent a complete feature provisioning operation defined by either the INITFCT or FCT commands. Loop 1 in this example is an outer loop based on a single INITFCT command to initialize an encrypted tunnel for processing FCTs . Loop 1 would be repeated for each ACC e.g. in a production line or anytime the secure tunnel needs to be established by deriving a shared secret with an ECMQV handshake between the ACC and appliance . The derivation of the shared secret requires the INITFCT command. Loop 1 begins with the agent sending a STARTACC command to the ACC and now that the ACC has transitioned into the Functional State moving now to the ACC can generate an ephemeral private key dei and an ephemeral public key Qei.

The agent sends the command cmd REQRESP to the ACC to obtain the ACC s public keys Qei and Qsi and the ACC responds by providing such keys to the appliance via the agent . The agent logs the event and also provides the product ID associated with the ACC and its public keys to the appliance . The appliance logs this event generates its own ephemeral key pair dej Qej generates the shared key kij and searches FCT 1 by product ID to ensure that the feature associated with FCT 1 is intended to be used in that product. The appliance then generates the CERTj using a combination of VER CID Qsj and the SIGcertj in this case by concatenating such components. The UID msgID some padding the FCT 1 and the static private key dsj of the appliance are then combined e.g. concatenated and signed using the ECDSA SIGN function to generate the signature SIGnij.

Using the FCT 1 the shared key kij the nonce n and SIGnij Enij MACnij is generated using the AES CCM  ENC function as shown in . The FCT is then metered to indicate consumption of one credit and the ephemeral public key Qej the appliance s certificate CERTj the encrypted message MAC pair EMnij MACnij and EM len are then sent to the ACC via the agent moving now to . The agent would log this event and also send the command cmd INITFCT to the ACC to begin the feature activation procedure.

The ACC begins by verifying CERTj using CERT CA to thus verify that it is communicating with the proper appliance . Once CERTj is verified the ACC then generates the shared key kij. FCT1 SIGnij and the nonce n are then recovered using the AES CCM  DEC function using the pair EMnij MACnij and the shared key kij. The signature SIGnij is then verified using Qsj obtained from CERTj and the nonce n is verified. The FCT may then be executed. An encrypted response pair ERnij MACnij is then generated using the AES CCM  ENC function which takes the FCTRSPni the nonce n and the shared key kij as inputs. At some point the agent then sends the command cmd REQRESP to the ACC from which the ACC responds by providing the pair ERnij MACnij . The agent logs the event and forwards ERnij MACnij to the appliance moving now to .

The appliance then decrypts ERnij MACnij using the shared key kij as an input into the AES CCM  DEC function to obtain the FCTRSPni message and the nonce n. The appliance then verifies n and logs the event. Next an optional second loop Loop 2 may then be executed for FCTN 2 to M additional FCTs as required. Since the INITFCT command has already run namely in the outer loop Loop 1 the ephemeral keys and shared secret already exist in the ACC and appliance so further provisioning can be done with the FCT command or multiple FCT commands. Once all FCT commands have been executed Loop 2 finishes and then Loop 1 can repeat for a new ACC . It can be seen that for each additional FCT that FCT e.g. FCTN is searched by product ID and then the appliance can proceed directly to the generation of SIGnij and the process described above repeated wherein various components already exchanged e.g. Qej CERTj need not be sent again. Loop 2 and then Loop 1 ends on . Turning now to the agent then logs the event issues the command cmd STOPACC at which time ACC destroys the ephemeral keys dei Qei. The agent then sends its accumulated logs to the appliance . The backend may then request the logs of the agent and appliance by requesting same from the appliance . The appliance then sends the agent logs and the appliance logs to the backend and the backend can make a final log of this event.

It can therefore be seen that the ACC provides a hardware based point of trust on the silicon die and using the system described above can be used to perform various tasks throughout the manufacturing process as well as the entire product lifecycle from manufacture through retail channels to consumer consumption onto end of life in a secure reliable and auditable fashion. It can also be seen that the ACC can be designed to provide the following capabilities managing accesses to the NVM and protecting certain regions of the NVM from being accessed by unauthorized agents self contained generation of a UID used to uniquely identify the ACC self contained generation of keys used to open up a secure communication channel with a trusted server ensuring that the enabling and disabling of features are done using trusted equipment by trusted sources the ability to initiate or disable device self tests and health checks to make sure device has not been tampered with and locking out the device whenever too many invalid commands are attempted.

Additionally it may be noted that the ACC can be extended to implement the following features having the appliance inject the UID instead of limiting the capabilities to only a self generated UID and securely booting and authenticating firmware upgrades through code signing.

As discussed the ACC is typically embedded and integrated in a SoC die which is then packaged into a chip which is mounted on a printed circuit board PCB and eventually assembled into an electronic device or product . Every chip that has an ACC in it can be registered and logged in the backend database as soon as it has passed wafer testing which in turn can track every chip manufactured that underwent wafer testing. The ACC may be designed to work in any electronics manufacturing test environment since the security features of the system do not rely on the data link between the appliance and ACC to be trusted but rather the security is built in to the communication protocols cryptographically.

Furthermore if an end customer wants to reprogram the feature set of his her particular device there is the flexibility in the system to allow him or her to connect to an appliance using whatever device programmer the equipment vendor deems fit and the appliance can open up a secure channel by itself. As a result the system provides the ability to allow provisioning to occur in a completely secure auditable manner anywhere from the wafer fab to the ODM to the OEM to end user.

For the fabless chip manufacturer this provisioning flexibility means that the fabless chip vendor can produce base chips and then have them provisioned at the distributor ODM OEM as they need specific features enabled for specific product builds. This greatly reduces the number of mask turns per year per product line saving significant cost. It reduces SKUs and simplifies supply chain management. It can eliminate grey market overstock sales by OEMs. Because the chips can be made so that they will not work unless they are programmed by system this can eliminate illegal overproduction by foundries. In addition the solution described herein enables aftermarket revenue from the end user directly to the fabless chip vendor something that is difficult if not impossible using traditional programming solutions. With the system if an end customer wishes to enables a feature contained on a chip e.g. enhanced graphics capability from his video card he can order that feature over the web and the chip vendor can issue the command to enable it remotely.

For a device vendor the benefits can be similar simplified SKUs and more efficient supply chain management. Just in time provisioning is possible to facilitate last minute changes in orders. Inventory of raw components is simplified with the system because the components can be provisioned as needed for the current production. Revenue can also protected because hackers can t find ways to reprogram the devices in an unauthorized way.

The objective of a security system such as the system is to prevent an adversary from tampering with the device . If a threat is to be treated seriously it would have to jeopardize the ACC from performing its primary functions. To this end it makes sense to consider the cost of an attack. There are two parts to the cost equation 1 The initial effort to probe research and reverse engineer our design to have one modified chip and 2 The incremental effort to repeat that attack on each successive chip if a the result of the initial effort was published and made public and b he has access the all the equipment necessary to perform the attack readily available.

An attack is considered to be too difficult and non effective if the incremental cost to enact the attack is more than the retail cost of the chip or if the attack is limited to a specific feature then the retail cost of that feature. Thus we can think of an attack as too difficult if cost to repeat the exploitation value of all features of a device . From this perspective a break that requires modifying each chip individually using techniques involving FIBs or E beams is not a concern because it is not cost effective. It can be appreciated that in many cases the occasional single break is acceptable because it would not affect the manufacturer s revenue stream significantly. The most serious threat would be a system wide break that would enable a hack to be published that would allow many people to repeat the steps with very little effort. However if an adversary is to spend the time and effort and somehow manage to successfully defeat the first devices it would not be much of a concern if he is unable to utilize the knowledge he gained on the first attempt and repeat on successive devices in a cost effectively manner.

a The ACC is a closed system and all sensitive operations and data are private and inaccessible from other logic on the die.

b The rest of the system is secure and is not subject to tampering so one would not be able to use it to facilitate hash collision finding.

c The system in which the ACC is embedded has taken the proper precautions such that it does not bypass the suggested required security measures.

d The ability to read or write static memory elements using e beam or lasers and other similar techniques is possible but it will be difficult and expensive.

e The ability to read or write ephemeral memory elements outside of ACC programming is outside the scope of our security model.

A list of techniques an adversary might physically attempt to break the system have been identified. An adversary might utilize multiple methods in concert with each other to attempt a break such as Inter chip probing Oscilloscopes Logic analyzer Wafer Die Testers Board level JTAG debugger Modifying ACC ROM content tempering replacement at the mask level Device removal and substitution replacing a chip that has the ACC with a device that did not have an ACC swapping one chip with another connecting multiple chips in parallel Off line NVM modification using a forged appliance to communicate with the ACC and injecting glitches on the power and clock signals while ACC is running. Such threats should be considered when implementing the system .

Additionally a separate list of techniques an adversary might use to break the system s protocols has also been identified. An adversary would need to use one or more of the physical threats to attack the protocol side channel observation message forging message replay message interleaving passive attack identity spoofing key snooping and timing attacks. As with physical threats such threats should be considered when implementing the system .

Accordingly the ACC should provide secure tamper free storage of the CA Public Key the ACC should provide secure tamper free storage of ACC s static key pair the ACC should be able to enable the default set of features without a FCT for a particular device there should be a way to establish a confidential and authenticated channel between the ACC and the appliance there should be a way to issue authenticated commands with ability to verify message integrity from appliance to ACC the communication protocol between the ACC and the appliance should be designed such that it can prevent replay of commands and acknowledgements steps taken to break one ACC cannot be replicated cost effectively nor does it lead to a systemic break of mass quantities of parts and devices should have statistically unique private keys and public identifiers. However if a very small number of chips est. 

In general there is provided a method of programming features on a device the method comprising providing a hardware module on the device the hardware module comprising non volatile memory NVM for storing feature activation information at least a portion of the NVM being protected and a cryptographic controller for performing cryptographic operations the hardware module receiving a first command for establishing a secure session with an agent connected to the hardware module the hardware module generating one or more public keys using the cryptographic controller and providing the one or more public keys to the agent to enable the agent to provide the public keys to an appliance to generate a shared secret key the hardware module obtaining an encrypted set of features from the agent the hardware module using the shared secret to decrypt the set of features and the hardware module programming one or more features on the NVM of the device according to the set of features.

There is also provided a method of programming features on a device the method comprising providing a connection to a hardware module on the device through an agent in communication with the hardware module the hardware module comprising non volatile memory for storing feature activation information obtaining from the agent one or more public keys generated by the hardware module using a cryptographic controller using the one or more public keys to generate a shared secret key using the shared secret key to encrypt a set of features providing an encrypted set of features to the hardware module through the agent and metering a credit pool indicative of a quantity of hardware modules to be programmed.

There is also provided a method of programming features on a device the method comprising providing a first connection to a hardware module on the device and a second connection to an appliance the appliance comprising sets of features to be programmed on the device the hardware module comprising non volatile memory for storing feature activation information sending a command to the hardware module to initiate a secure session therewith obtaining from the hardware module one or more public keys generated by the hardware module providing the public keys to the appliance obtaining from the appliance an encrypted set of features providing the encrypted set of features by establishing a feature programming session with the hardware module and obtaining a response from the hardware module pertaining to application of the set of features.

There is also provided a hardware module for controlling assets to be applied to a device the hardware module configured to be incorporated into the device the hardware module comprising a cryptographic controller for performing cryptographic operations a random number generator for generating a unique identifier non volatile memory NVM at least a portion thereof being protected for storing feature activation information and a provisioning interface providing one or more outputs to the device indicating which of a set of features are enabled and which are disabled.

There is also provided a method of programming features on a device the method comprising determining a set of features to be enabled on the device populating a feature register according to which features are to be enabled preparing a feature control ticket using the feature register encrypting the feature control ticket and providing one or more feature control tickets to an appliance for delivery to one or more devices capable of being programmed with the features.

There is also provided a method of exchanging information with a device the method comprising providing a hardware module on the device providing an appliance in communication with the hardware module establishing a secure communication channel between the appliance and the hardware module and utilizing messages sent between the appliance and the hardware module over the secure communication channel to exchange information therebetween.

There is also provided a computer readable medium comprising computer executable instructions for exchanging information with a device the computer executable instructions comprising instructions for providing a hardware module on the device providing an appliance in communication with the hardware module establishing a secure communication channel between the appliance and the hardware module and utilizing messages sent between the appliance and the hardware module over the secure communication channel to exchange information therebetween.

There is also provided a system for exchanging information with a device the system comprising a hardware module to be embedded on the device wherein the hardware module is configured to establish a secure communication channel with an appliance wherein the hardware module is further configured to exchange messages sent between the appliance and the hardware module and wherein the hardware module is further configured to utilize the messages to obtain or provide information.

It will be appreciated that any module or component exemplified herein that executes instructions may include or otherwise have access to computer readable media such as storage media computer storage media or data storage devices removable and or non removable such as for example magnetic disks optical disks or tape. Computer storage media may include volatile and non volatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Examples of computer storage media include RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can be accessed by an application module or both. Any such computer storage media may be part of the modules shown herein or accessible or connectable thereto. Any application or module herein described may be implemented using computer readable executable instructions that may be stored or otherwise held by such computer readable media.

Although the above system has been described with reference to certain specific embodiments various modifications thereof will be apparent to those skilled in the art as outlined in the claims appended hereto.

