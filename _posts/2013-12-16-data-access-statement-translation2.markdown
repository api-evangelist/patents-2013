---

title: Data access statement translation
abstract: Techniques are described for dynamic translation of data access statements. A first set of statements is sent by an executing process to access a first data storage that supports a first query language. The first set of statements is intercepted and translated into a second set of statements configured to access a second data storage that supports a second query language. The second set of statements may be executed on the second data storage, and the result data set may be sent to the executing process that generated the first set of statements. The first and second storages may employ different data storage formats, such as relational and non-relational storage formats. The behavior of the executing process may be monitored to determine the feasibility of modifying the source code of the process to employ a different query language.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09535948&OS=09535948&RS=09535948
owner: Amazon Technologies, Inc.
number: 09535948
owner_city: Reno
owner_country: US
publication_date: 20131216
---
Applications libraries and other types of software modules may include hard coded statements written in a particular query language to access data stored on a particular type of data storage device. In some cases an organization that operates or maintains the software modules may migrate data from one type of data storage device to another type of data storage. In cases where existing software modules include hard coded statements in a particular query language the software modules may not function properly when attempting to access a data storage device that supports a different query language or that implements a different transaction model.

Certain implementations and embodiments will now be described more fully below with reference to the accompanying figures in which various aspects are shown. However various aspects may be implemented in many different forms and should not be construed as limited to the implementations set forth herein. Like numbers refer to like elements throughout.

This disclosure describes implementations of systems devices methods and computer readable media for dynamically intercepting and translating statements configured to access a data storage device or service. An application may include data access statements e.g. statements that are written into the source code to access data stored on a first data storage. The application may be modified such that the application is linked with or otherwise incorporates a database driver that redirects the statements to a statement processing device instead of the first data storage. The statement processing device may perform operations to translate the statements from their original query language e.g. a language supported by the first data storage into a different query language. The translated statements may then be executed on a second data storage that supports the different query language a different transaction model or a different storage format. The result data set generated through execution of the translated statements may be returned to the statement processing device. The statement processing device may then return the result data set to the application that sent the original statements in some cases after processing the result data set. Implementations may return the result data set to the application as if the result data set was generated based on executing the original statements on the first data storage. In some implementations the interception and translation of the statements may be substantially transparent to the application that sent the statements and may not require any modification of the application apart from incorporating a different database driver into the application.

The behavior of the application after receiving the result data set may provide an indication of the feasibility of modifying e.g. refactoring or recoding the application to interact with the second data storage instead of the first data storage. Accordingly implementations may enable an estimate of the cost that may be expended to make such modifications such as the cost in money time computing resources human resources and so forth. For example if it determined that the application exhibits errors failures exceptions or other problems in response to receiving the result data set a determination may be made that the modification of the application may be arduous or time consuming.

The host device s may execute one or more application s that include one or more statements for accessing a data storage. The application s may include any type of application specified using any programming language including but not limited to any version of Java or JavaScript provided by Oracle Corporation of Redwood City Calif. USA C C C developed by Microsoft Corporation of Redmond Wash. USA Perl Python developed by the Python Software Foundation BASIC assembly language and so forth. The application s may be specified using a programming language that is a compiled programming language such that the application s are compiled into machine executable binary code that is executable on the host device s . The application s may also be specified using a scripting language or an interpreted programming language such that the application s execute within a virtual machine runtime or interpreter engine executing on the host device s . The application s may be parallelized across one or more processes or threads executing on one or more host device s . The application s may include one or more statements for accessing a data storage to retrieve data store data update or modify stored data or delete data from the data storage. For example an application that is written to manage employee data records in an employee data storage may include statements to retrieve update and store employee information that describes an employee name department title employee identification number office location email address and so forth. The statements may be written using any query language. A query language may include a data manipulation language DML or any structured language arranged to access retrieve modify add or delete data stored in any type of data storage. The statements described herein may be specified using query languages including but not limited to any version of the Structured Query Language SQL Language Integrated Query LINQ the Hadoop Query Language HQL or MapReduce.

Each statement may indicate one or more operations to be performed on stored data. For example statements may be configured to perform operations including but not limited to operations to retrieve records from a dataset e.g. select operations operations to add new records to a dataset e.g. insert operations operations to modify existing records in a dataset e.g. update operations or operations to remove records from a dataset e.g. delete operations . Statements may also perform operations to process records from multiple datasets in data storage such as an inner join operation a left outer join operation a right outer join operation a full outer join operation a cross join operation and so forth.

In some cases the host device s may execute a first instance of the application s that incorporates a database driver such as any version of a Java Database Connectivity JDBC driver or any version of an Open Database Connectivity ODBC driver. The database driver may be incorporated into the application s as a library Application Programming Interface API or other type of software module and may enable the application s to send a first set of statements to interact with a first data storage . The first set of statements may include statements that are hard coded or otherwise included in the specification e.g. source code of the application s . In some cases the first set of statements may include one or more statements specified using a first query language that is supported by the first data storage . For example in cases where the first data storage is a relational data storage that employs a data storage format such as that supported by the Oracle database management system the first set of statements may be specified using Oracle SQL.

The first data storage may include any number of datastores databases or data storage systems that support any type of data storage format. In some cases the first data storage may employ a relational data storage format including one or more formally described tables each table including one or more columns associated with data attributes. The first data storage s may be managed through any type of relational database management system RDBMS software. The first data storage s may implement a transaction model that determines how multiple operations may be processed by the first data storage s as part of a same transaction. The first data storage s may include any number of relational databases including but not limited to databases managed through any of the following Oracle Database and MySQL from Oracle Corporation of Redwood City Calif. USA DB2 from International Business Machines IBM Corporation of Armonk N.Y. USA Linter from the RELEX Group of Voronezh Russia Microsoft Access and Microsoft SQL Server from Microsoft Corporation of Redmond Wash. USA PostgreSQL from the PostgreSQL Global Development Group or SQLite from D. Richard Hipp.

The first data storage s may also include any number of non relational datastores that employ a non relational data storage format and that may not comply with a relational database model. Such non relational datastores may employ a hierarchical database model or a network database model. The non relational datastores may also include key value datastores hash tables flat files associative arrays other types of data structures or unstructured data storage. In some cases the non relational datastores may store metadata describing data attributes or other aspects of the stored data. The first data storage s may include any number of non relational datastores including but not limited to datastores managed through any of the following FoxPro database management system from Microsoft Corporation of Redmond Wash. USA ParAccel Analytic Database from ParAccel Incorporated of San Diego Calif. USA Berkeley DB from Oracle Corporation of Redwood City Calif. USA MongoDB from MongoDB Inc. of New York N.Y. USA or Cassandra CouchDB and Hadoop from the Apache Software Foundation.

The first set of statements may be executed on the first data storage to generate a first result data set . The first result data set may then be sent to the application s executing on the host device s enabling the application s to further process the data included in the first result data set .

In implementations the host device s may execute a second instance of the application s that incorporates a redirection database driver that differs from the database driver . The application s may share a same or similar design or source code specification with the application s and may operate substantially similarly to the application s . However during execution of the application s the redirection database driver may redirect the first set of statements to one or more statement processing device s instead of to the first data storage . The statement processing device s may comprise any type of computing device including but not limited to any of the types of computing devices described with reference to the host device s . In some cases two or more of the statement processing devices may comprise a cluster cloud farm or other grouping of multiple devices that coordinate operations to provide load balancing failover support parallel processing capabilities shared storage resources or other aspects. The statement processing device s are described further with reference to .

The statement processing device s may execute a statement processing module to receive translate analyze or otherwise process the first set of statements . Operations of the statement processing module are described further with reference to . In some implementations the statement processing module may include a parser module . The parser module may operate to parse the first set of statements based on a grammar for the first query language in which the first set of statements are specified. The parser module may generate a parse data structure such as a parse tree that describes one or more data access operations specified in the first set of statements . The parse data structure may be provided to a statement generation and execution module which generates a second set of statements . The second set of statements may include one or more statements that are specified using a second query language that is different from the first query language of the first set of statements . In this way the statement processing module may translate the first set of statements from a first query language to a second query language.

The statement generation and execution module may execute the second set of statements on a second data storage that supports the second query language. The second data storage may be a relational or a non relational data storage and may store data using any data storage format including a relational or non relational data storage format. The second data storage may include any number of databases datastores or data storage systems that are operated through any of the data storage management systems described above with reference to the first data storage . A second result data set may be generated based on the execution of the second set of statements . The second result data set may be received by the statement processing module and sent to the application s executing on the host device s enabling the application s to further process the data included in the second result data set . In some cases the statement processing module may perform one or more operations to reformat or otherwise process the second result data set prior to sending the second result data set to the application s . For example the second result data set may be reorganized into a format similar to a format in which the first result data set is generated.

In some cases the execution of the application s and the application s may be monitored to determine any differences in behavior between the application s and the application s after respectively receiving the first result data set and the second result data set . Any detected differences in behavior may enable a determination of the feasibility or cost of modifying the application s to interact with the second data storage instead of the first data storage . Such information may be used in planning for a data migration when large quantities of data may be migrated from storage on the first data storage to the second data storage .

In some cases the first data storage may employ a different data storage format compared to the second data storage . For example the first data storage may employ a relational data storage format and the second data storage may employ a non relational data storage format. As another example the first data storage may employ a non relational data storage format and the second data storage may employ a relational data storage format. In such cases implementations may enable the dynamic and automatic translation of statements that are configured to access data stored in a first data storage format to generate statements that are configured to access data stored in a second data storage format. In some cases the first set of statements may be described using a version of SQL to accessing a relational database and the second set of statements may be described using a query language for accessing a non relational datastore such as a key value store.

Implementations also support statement translation in cases where the first data storage and the second data storage both support a similar data storage format e.g. are both relational databases but that support different query languages. For example the first data storage may be a relational database that supports a first version of SQL and the second data storage may be a relational database that supports a second different version of SQL. In such cases statement translation may be performed to translate the first set of statements from the first version to the second version of SQL. Although the example of depicts two data storages the environment may include any number of data storages of any type that support any data storage format or any query language.

In some cases the first data storage may implement a different transaction model compared to the second data storage . For example the first data storage may order two or more insert update or delete statements issued concurrently and the second data storage may interleave these statements. In cases where the first data storage and the second data storage implement different transaction models the application s s may exhibit errors failures exceptions or other aberrant behavior on receiving the second result data set . For example in some cases the second data storage may be a NoSQL datastore or some other data storage that does not support transactional processing or the set of features for Atomicity Consistency Isolation and Durability ACID that may be supported by a relational database. In such cases and where multiple applications may attempt to alter the same data simultaneously or otherwise be configured to expect transactional processing errors in data processing may occur.

Although the first data storage and the second data storage are depicted in as separate devices from the other entities in the environment implementations are not so limited. In some cases one or both of the first data storage and the second data storage may be a data storage service executing on one or more computing devices which may include the statement processing device s the host device s or other devices.

The various devices of the environment may communicate with one another using one or more networks. Such networks may include public networks such as the Internet private networks such as an institutional or personal intranet or some combination of private and public networks. The networks may include any type of wired or wireless network including but not limited to local area networks LANs wide area networks WANs wireless WANs WWANs wireless LANs WLANs mobile communications networks e.g. 3G 4G etc. and so forth. In some implementations communications between the various devices in the environment may be encrypted or otherwise secured. For example such communications may employ one or more public or private cryptographic keys digital certificates or other credentials supported by a security protocol such as any version of the Secure Sockets Layer SSL protocol the Transport Layer Security TLS protocol or the Advanced Encryption Standard AES .

The host device may include one or more input output I O devices . The I O device s may include input devices such as a keyboard a mouse a pen a game controller a touch input device an audio input device e.g. a microphone a gestural input device a haptic input device an image or video capture device e.g. a camera or other devices. In some cases the I O device s may also include output devices such as a display an audio output device e.g. a speaker a printer a haptic output device and so forth. The I O device s may be physically incorporated with the host device or may be externally placed.

The host device may include one or more I O interfaces to enable components or modules of the host device to control interface with or otherwise communicate with the I O device s . The I O interface s may enable information to be transferred in or out of the host device or between components of the host device through serial communication parallel communication or other types of communication. For example the I O interface s may comply with a version of the RS 232 standard for serial ports or with a version of the Institute of Electrical and Electronics Engineers IEEE 1284 standard for parallel ports. As another example the I O interface s may be configured to provide a connection over Universal Serial Bus USB or Ethernet. In some cases the I O interface s may be configured to provide a serial connection that is compliant with a version of the IEEE 1394 standard. The host device may also include one or more busses or other internal communications hardware or software that allow for the transfer of data between the various modules and components of the host device .

The host device may include one or more network interfaces that enable communications between the host device and other network accessible computing devices such as the statement processing device s . The network interface s may include one or more network interface controllers NICs or other types of transceiver devices configured to send and receive communications over a network.

The host device may include one or more memories described herein as memory . The memory comprises one or more computer readable storage media CRSM . The CRSM may include one or more of an electronic storage medium a magnetic storage medium an optical storage medium a quantum storage medium a mechanical computer storage medium and so forth. The memory provides storage of computer readable instructions that may describe data structures program modules processes applications or other data for the operation of the host device . In some implementations the memory may provide storage of computer readable instructions or other information in a non transitory format.

The memory may include an operating system OS module . The OS module may be configured to manage hardware resources such as the I O device s the I O interface s and the network interface s and to provide various services to applications processes or modules executing on the processor s . The OS module may include one or more of the following any version of the Linux operating system any version of iOS from Apple Corp. of Cupertino Calif. USA any version of Windows or Windows Mobile from Microsoft Corp. of Redmond Wash. USA any version of Android from Google Corp. of Mountain View Calif. USA and its derivatives from various sources any version of Palm OS from Palm Computing Inc. of Sunnyvale Calif. USA and its derivatives from various sources any version of BlackBerry OS from Research In Motion Ltd. of Waterloo Ontario Canada any version of VxWorks from Wind River Systems of Alameda Calif. USA or other operating systems.

The memory may include one or more of the modules described above as executing on the host device such as the application s . As described above the memory may include a first instance of the application s that incorporate the database driver e.g. for interacting with the first data storage . The memory may also include a second instance of the application s that incorporates the redirection database driver which redirects statements from the application s to the statement processing device s . In some implementations the memory may include a diagnostic module configured to collect information regarding the behavior of the application s during execution. For example the diagnostic module may detect errors failures exceptions or other problems exhibited by the application s . The diagnostic module may also be configured to compare the first result data set and the second result data set to detect potential problems associated with a data migration from the first data storage to the second data storage or to identify other issues. The memory may also include one or more other modules such as a user authentication module or an access control module to secure access to the host device and so forth.

The memory may include data storage to store data for operations of the host device . The data storage may comprise a database array structured list tree or other data structure and may be a relational or a non relational datastore. The data storage may store data such as that described above as being stored on or employed by the host device including one or more of the first result data set or the second result data set . In some implementations the data storage may store application diagnostic information that describes how one or both of the application s and the application s behavior during execution. For example the application diagnostic information may describe errors failures exceptions or other problems exhibited during execution. The application diagnostic information may also include memory dumps stack traces communications logs or other information to enable one or more users to examine the behaviors of the application s . The application diagnostic information may be generated by the diagnostic module . The data storage may also store other data such as user authentication information or access control data. In some implementations at least a portion of the information stored in the data storage may be stored externally to the host device on other devices that may communicate with the host device via the I O interface s or via the network interface s .

The statement processing device may include one or more memories described herein as memory . The memory comprises one or more CRSM as described above with reference to the memory . The memory may include an OS module that is configured to manage hardware resources such as the I O device s the I O interface s and the network interface s and to provide various services to applications processes or modules executing on the processor s . The OS module may include one or more of the operating systems described above with reference to the OS module . The memory may include one or more of the modules described above as executing on the statement processing device such as the statement processing module the parser module and the statement generation and execution module . Although the examples herein may describe the parser module and the statement generation and execution module as sub modules sub components or sub processes of the statement processing module e.g. as shown in implementations are not so limited. In some cases one or both of the parser module and the statement generation and execution module may execute separately from the statement processing module .

In some implementations the memory may include one or more parser generation modules that generate one or more parser module s . The parser generation module may generate at least one parser module for each query language used to specify the first set of statements . Implementations support the use of any parser generation module to generate the parser module s including but not limited to the CUP parser generator supported by the Technical University of Munich or the Java Compiler Compiler JavaCC from Oracle Corporation of Redwood City Calif. USA. The parser generation module may receive as input a grammar specification for one or more query languages and generate a parser module corresponding to each of the grammars. For example the parser generation module may access a grammar for a version of SQL and output a parser module that parses statements written in that version of SQL. The parser generation module may also access a grammar for a version of HQL and output a parser module that parses statements written in that version of HQL. Accordingly the memory may store any number of parser modules configured to parse any number of query languages.

In some cases the memory may store a statement processing module that includes multiple parser modules to parse statements received in multiple query languages. Alternatively the memory may store a plurality of statement processing modules that each includes a parser module to parse statements received in a particular query language. The memory may also include one or more other modules such as a user authentication module or an access control module to secure access to the statement processing device and so forth.

The memory may include data storage to store data for operations of the statement processing device . The data storage may comprise a database array structured list tree or other data structure and may be a relational or a non relational datastore. The data storage may store data such as that described above including one or more of the first set of statements the second set of statements the second result data set or the parse data structure s . The data storage may also store one or more grammars to be input to the parser generation module to generate the parser module s for each of one or more query languages employed by the first set of statements to be translated. In some cases the grammar s may include context free grammar s described using the Backus Naur Form or the Backus Normal Form BNF for grammars. The data storage may also store other data such as user authentication information or access control data. In some implementations at least a portion of the information stored in the data storage may be stored externally to the statement processing device on other devices that may communicate with the statement processing device via the I O interface s or via the network interface s .

At the first set of statements may be intercepted or otherwise received. The first set of statements may be sent by an executing process such as the application s and may be configured to interact with a first data storage that is implemented as hardware software or a combination of hardware and software. As described above the first set of statements may be described using a first query language that is supported by the first data storage .

At the first set of statements may be translated from the first query language to a second query language to generate the second set of statements described using the second query language. The translation is described further with reference to .

At in some implementations a first set of credentials may be determined the first set of credentials providing access to the first data storage . The first set of credentials may include a login password digital certificate token or any other type of credential. In some cases the first set of credentials may be included in the first set of statements . Alternatively the first set of credentials may be employed to establish a connection with the first data storage .

At a second set of credentials may be determined that enable access to the second data storage that is implemented as hardware software or a combination of hardware and software. In some cases the second set of credentials may correspond to the first set of credentials in that they provide access to the two storage devices for a same user a same device or a same process. In some implementations the second set of credentials may be determined based on mapping data that describes a correspondence between the first and second sets of credentials. In some implementations the second set of credentials may be determined through a call to Lightweight Directory Access Protocol LDAP service credentialing service or some other service. Such a service may execute on the statement processing device s or on another device. In some cases one or both of the first set of credentials and the second set of credentials may be included in a configuration file that is present on or accessible from the host device s or the statement processing device s .

At the second set of credentials may be employed to execute the second set of statements on the second data storage . At the second result data set generated from executing the second set of statements may be received. In some implementations the second result data set may be modified reformatted or otherwise processed at . For example the second result data set may be modified such that its format resembles a format corresponding to the first result data set . At the second result data set may be sent to the executing application s . In some cases the second set of credentials may be employed to establish an authenticated connection or communication session between the statement processing device s and the second data storage . Alternatively the second set of credentials may be included with one or more of the second set of statements and may be employed to authenticate the statement s .

At a determination may be made whether the executing application s exhibit a failure error exception or other problem after receiving the second result data set . Such a problem may indicate potential complications in refactoring or modifying the source code of the application s to access a different type of data storage. For example the application s may be written such that it expects one or more statements to be executed within a transactional block by a data storage and such transactional processing may not be supported by the second data storage . In such cases a transaction based failure of the application s may expose transactional processing as a potential problem to be addressed during refactoring of the source code for the application s .

At the first set of statements sent by the application s and sent by the application s may be intercepted or otherwise accessed as described above with reference to . At the first set of statements may be translated from a first query language supported by the first data storage to a second query language supported by the second data storage to generate the second set of statements as described above.

At the first result data set may be generated by executing the first set of statements e.g. the original not translated statements on the first data storage . At the second result data set may be generated by executing the second set of statements e.g. the translated statements on the second data storage . The first result data set may be received by the executing application s and the second result data set may be sent to the executing application s as described above. In some implementations the generation of the first result data set e.g. at may be performed at least partly in parallel with the generation of the second result data set e.g. at such that the first set of statements and the second set of statements are executed to access data that is substantially similar within a particular time period.

At the first result data set may be compared to the second result data set . In some cases differences between the two result data sets may indicate problems associated with migrating data from the first data storage to the second data storage . Differences between the two result data sets may also indicate problems that may be encountered when refactoring or otherwise modifying the source code of the application s to access the second data storage . Such differences may be reported to one or more users for further investigation.

At the first result data set and the second result data set may respectively be sent to the application s and the application s . At the behaviors of the application s and the application s may be compared and differences in behavior may be reported to one or more users for further investigation. In some cases differences in behavior may indicate problems to be addressed when refactoring or otherwise modifying the source code of the application s to access the second data storage .

Some implementations may perform operations e.g. at to compare the first result data set and the second result data set and may omit the operations e.g. at to compare the behaviors of the first and second instances of the executing application . In such implementations the second instance of the application may be executing and the first instance of the application may not be executing. The first set of statements may in such implementations be intercepted from the second instance of the application at and not from the first instance of the application .

At the first set of statements sent by the application s may be intercepted or otherwise accessed as described above with reference to . At the first set of statements may be parsed to generate the parse data structure . In some cases the parse data structure may be a parse tree or a modified parse tree exhibiting any branching factor. Implementations also support the use of other types of data structures. The parse data structure may describe one or more data access operations indicated by the first set of statements . As described above the parsing may be performed by a parser module that is generated based on a grammar for the first query language employed by the first set of statements .

At the parse data structure may be traversed and each of the data access operations may be analyzed and processed to generate the second set of statements . Such processing may include mapping one or more subsets of the nodes of the parse data structure to one or more statements to be included in the second set of statements . The second set of statements may then be executed on the second data storage as described above.

The examples of reference two example datasets. The first dataset is named employees and may include any number of records each providing information describing an employee. In the example the employees dataset includes four columns employee ID first name last name and department ID with employee ID being the hash key that is a searchable column of the dataset. The second dataset is named departments and may include any number of records each providing information describing a department of a business or other organization. In the example the departments dataset includes two columns department ID and department name with department ID being the hash key for the dataset. The employees and departments datasets in the key value store may include the second set of stored data that has been migrated e.g. copied and reformatted from the first set of stored data that includes two relational database tables employees and departments. Accordingly the second set of stored data may store substantially similar data to the first set of stored data in a different data storage format.

At the parse data structure is accessed and a set of one or more nodes may be identified as corresponding to a SQL statement. As described above the parse data structure may be a parse tree generated by parsing the first set of statements . In the example of the set of nodes may correspond to a select statement an update statement or a delete statement specified according to any version of SQL.

At a determination is made whether the statement includes a where clause to apply a condition to the select update or delete statement. If not the process may proceed to . Statements that do not include a where clause may be statements such as select from employees or delete from departments which may operate against all records of the dataset corresponding to the relational database table employees or departments. 

At the statement may be applied to all of the records in the dataset of the key value store that is referenced in the statement. For example based on a SQL statement of select from employees a statement of the second set of statements may be generated to retrieve all the records of the employees dataset in the key value store. In that case the second result data set may include all records from the employees dataset. As another example based on a SQL statement of delete from employees a statement of the second set of statements may be generated to delete all the records of the employees dataset in the key value store. In that case the second result data set may be empty or null. As another example based on a SQL statement of update employees set last name Smith a statement of the second set of statements may be generated to modify all the records of the employees dataset in the key value store and set each last name value to Smith. In that case the second result data set may be empty or null.

If it is determined at that the statement includes a where clause with one condition the process may proceed to . At a determination is made whether the where clause is a condition on a hash key of the key value store such as in the statement select first name from employees where employee ID 55. If so the process may proceed to . At the one or more records of the key value store are accessed based on the hash key and the statement may be applied to the accessed records. In the above example select first name from employees where employee ID 55 a statement of the second set of statements may be generated to retrieve the values of the data attribute first name from the employees dataset for all records that have the hash key equal to 55. The second result data set may then include the first name values of all such records. As another example based on a SQL statement of update employees set first name Austin where employee ID 55 a statement of the second set of statements may be generated to modify all such records to set the first name value to Austin. In that case the second result data set may be empty or null.

If it is determined at that the condition of the where clause is not on a hash key of the key value store such as in the statement select first name from employees where last name Smith the process may proceed to . At a determination is made whether there is an inversion table that associates the data attribute included in the where clause with the data attribute for the hash key in the key value store e.g. if the where clause is a condition on the hash key of an existing inversion table. If so the process may proceed to . If not the process may proceed to . At all records of the key value store may be accessed and filtered based on the condition in the where clause. Such filtering may include removing those records that do not satisfy the condition. The statement may then be applied to the filtered record s .

If it is determined at that an appropriate inversion table exists the inversion table may be accessed that associates the data attribute included in the where clause with the data attribute for the hash key in the key value store. In the above example select first name from employees where last name Smith an inversion table may be accessed that maps last name to employee ID. Any number of such inversion tables may be stored in the second set of stored data in the second data storage . In some cases the inversion table s may be created through pre processing of the second set of stored data prior to the dynamic statement translation operations described herein. In cases where the first data storage is a relational database managed through RDBMS indices present in the first data storage may be employed to create the inversion table s that are included in the second data storage .

At the inversion table may be employed to determine one or more hash key value s that correspond to the data attribute included in the where clause. At one or more records of the key value store may be accessed based on the hash key value s determined at and the statement may be applied to each of the accessed record s as described above.

Implementations support the application of where clauses in which the condition is an equality condition on a data attribute that is a hash key of the key value store or on a data attribute that is not a hash key. For example implementations support the application of a condition data attribute value. Some implementations also support the application of other types of conditions. In some cases where the condition to be applied is a range of values e.g. value

At the parse data structure is accessed and a set of one or more nodes may be identified as corresponding to a SQL statement. As described above the parse data structure may be a parse tree generated by parsing the first set of statements . In the example of the set of nodes may correspond to a select statement an update statement or a delete statement that includes a where clause having two or more conditions.

At a determination may be made whether the conditions include one or more conditions on hash key s of the targeted dataset in the key value store. If so the process may proceed to and retrieve one or more records of the key value store based on the hash key s to generate an initial result data set. By applying the condition on the hash key s first in the process implementations may reduce the number of records to be used in the subsequent application of the other conditions of the where clause. In some implementations further analysis may be performed to determine the first condition to apply based on which condition is likely to select the smallest set of records as the initial result data set e.g. which condition has the highest degree of cardinality . In cases where the conditions include at least two conditions on hash keys of at least two different datasets the hash keys may be employed to determine at least two sets of records by applying each condition on a hash key of a dataset. In such cases the initial result data set may be generated as a union e.g. a hash join of the at least two sets of records from the at least two different datasets. After or if it is determined at that the conditions do not include condition s on hash key s the process may proceed to .

At a condition is identified from among the remaining conditions included in the where clause of the statement. At an inversion table is accessed that associates the data attribute included in the condition with the data attribute for the hash key of the dataset in the key value store. At the inversion table may be employed to determine one or more hash key value s that correspond to the data attribute included in the condition. Employment of the inversion tables in and may proceed as described above with reference to . In cases where an inversion table is not present that associates the data attribute included in the condition with the data attribute for the hash key the process may access all records of the dataset of the key value store and filter the records based on the condition to be applied as described with reference to .

At if the process is on a first iteration and no initial result data set was determined at one or more records of the key value store may be accessed based on applying the hash key value s determined at and the record s may be incorporated into a working result data set. At if the process is on a first iteration and an initial result data set was determined at the hash key value s determined at may be employed to determine record s of the initial result data set with the hash key value s and the record s may be saved in memory as the working result data set. At if the process is on at least a second iteration the hash key value s determined at may be employed to determine record s of the current working result data set with the hash key value s and the record s may be saved in memory as the next iteration of the working result data set.

At a determination is made whether there is at least one additional condition to analyze from the conditions included in the where clause of the statement. If so the process may return to and identify another condition to analyze. If not the process may proceed to .

At in cases where the statement is a select statement one or more data attributes of the working result data set may be determined as the second result data set . For example if the SQL statement is select from employees inner join departments d on e.department ID d.department ID and first name Austin and department name ENG then all the records of the working result data set may be returned as the second result data set . If the SQL statement specifies one or more columns then the values of the corresponding data attribute s in the working result data set may be returned as the second result data set . At in cases where the statement is other than a select statement e.g. an update or delete statement then the statement may be applied to the records of the work result data set.

Table 1 provides a non limiting example of pseudo code that may be employed in at least some implementations. In the pseudo code of Table 1 the statement may be included in the first set of statements to be translated and the results may be included in the second result data set .

Although the examples herein may describe particular types of statements e.g. select update and delete statements implementations are not limited to these examples. Implementations also support the translation of SQL insert statements. In such cases the second set of statements may be determined to add additional records into the specified dataset of the key value store. Implementations also support the translation of hierarchical statements supported in Oracle SQL. Such statements may be translated into a series of statements in the second set of statements that recursively select subsets of records to generate results similar to those of a hierarchical statement. Implementations also provide for the translation of SQL analytic functions such as count max min sum and avg.

Although the above examples describe intercepting and translating statements sent by executing application s implementations are not so limited. Implementations may also be employed to translate data access statements present in source code of the application s while the application s are not executing. For example implementations may be employed to refactor or otherwise modify source code of an application to enable the application to access a different type of data storage than the application was originally designed to access. Implementations may also be employed to translate data access statements retrieved from logs of statements executed in a data storage device.

Those having ordinary skill in the art will readily recognize that certain steps or operations illustrated in the figures above may be eliminated combined or performed in an alternate order. Any steps or operations may be performed serially or in parallel. Moreover the methods described above may be implemented as one or more software programs for a computer system and may be encoded in a computer readable storage medium as instructions executable on one or more processors.

Embodiments may be provided as a computer program product including a non transitory computer readable storage medium having stored thereon instructions in compressed or uncompressed form that may be used to program a computer or other electronic device to perform processes or methods described herein. The computer readable storage medium may be one or more of an electronic storage medium a magnetic storage medium an optical storage medium a quantum storage medium and so forth. For example the computer readable storage media may include but is not limited to hard drives floppy diskettes optical disks read only memories ROMs random access memories RAMs erasable programmable ROMs EPROMs electrically erasable programmable ROMs EEPROMs flash memory magnetic or optical cards solid state memory devices or other types of physical media suitable for storing electronic instructions. Further embodiments may also be provided as a computer program product including a transitory machine readable signal in compressed or uncompressed form . Examples of machine readable signals whether modulated using a carrier or unmodulated include but are not limited to signals that a computer system or machine hosting or running a computer program can be configured to access including signals transferred by one or more networks. For example the transitory machine readable signal may comprise transmission of software by the Internet.

Separate instances of these programs can be executed on or distributed across any number of separate computer systems. Thus although certain steps have been described as being performed by certain devices software programs processes or entities this need not be the case and a variety of alternative implementations will be understood by those having ordinary skill in the art.

Additionally those having ordinary skill in the art readily recognize that the techniques described above can be utilized in a variety of devices environments and situations. Although the present disclosure is written with respect to specific embodiments and implementations various changes and modifications may be suggested to one skilled in the art. It is intended that the present disclosure encompass such changes and modifications that fall within the scope of the appended claims.

