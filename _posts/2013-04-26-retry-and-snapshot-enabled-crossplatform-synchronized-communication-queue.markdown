---

title: Retry and snapshot enabled cross-platform synchronized communication queue
abstract: A queue in a connector service provides a unified communication channel and stores service packets sent to a target service from client applications. Incoming service request packets are modified at run time to add valid security tokens without requiring the user's action or notice. Before sending the packets, the connector service determines whether the authentication tokens are valid. Packets with valid authentication tokens are sent to the target service. If the communication request fails, the queue automatically adds the original communication packet to the end of the queue, so that it can be conditionally retried. When a loss of connectivity is detected, the connector service takes a snapshot of the queue by copying the packets to a storage module in the same order. When the connectivity is restored, the queue loads the saved requests from the storage module and starts processing them in the order they were received.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09264414&OS=09264414&RS=09264414
owner: MICROSOFT TECHNOLOGY LICENSING, LLC
number: 09264414
owner_city: Redmond
owner_country: US
publication_date: 20130426
---
This application claims the benefit of the filing date of U.S. Provisional Patent Application No. 61 791 173 which is titled Retry and Snapshot Enabled Cross Platform Synchronized Communication Queue and was filed on Mar. 15 2013 the disclosure of which is hereby incorporated by reference herein in its entirety.

Many businesses provide target services such as enterprise resource planning ERP and customer relationship management CRM applications to support employee requirements such as tracking expenses tracking time entries and maintaining contact and account information. These applications often use and store confidential and proprietary company information such as financial data contact information and personnel files. Businesses need to limit access to these applications and their associated information to authorized users to prevent fraudulent use and privacy violations.

When users are on site using an enterprise computer network to access the services a business may authenticate users who access the enterprise network by requiring sign on credentials or other identifying information. However when users are off premises it becomes more difficult to authenticate users and to provide services in a secure manner. To maintain security users who access services via a mobile client such as a smartphone or tablet must be authenticated as authorized before being allowed to perform actions exposed by the services.

Client applications used to access business services need a reliable and synchronized communication link that allows users to interact with the services from a remote location. The communication link should also work across different client applications and devices. For example users may send authenticated requests and service calls to a cloud based ERP system and then receive business entities and ERP objects in response. In current systems if a communication link fails each individual client application must identify the failure determine which packets did not reach the target system and then resend those packets. For a temporary failure the resent packets may go through to the service on a first retry. However if the destination service is offline then the client application must store the packets and continue to retry sending the packets until the service is online. This can be a problem if the packets are sent with authentication tokens that may expire or otherwise need to be generated for the retry packets.

This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used to limit the scope of the claimed subject matter.

Embodiments of the invention provide a retry mechanism for packet sent from a client application to a target service such as a cloud based enterprise resource planning application or other business service. The retry mechanism recognizes failed requests and retries sending those failed requests to the target without notifying the client application. In the event that the target server is offline the retry mechanism saves a snapshot of the communication operations to capture a pending queue of packets.

When a loss of connectivity occurs this retry and snapshot mechanism saves business operations such as web service calls in the current queue and restarts the calls in the same order once connectivity is restored. This ensures that the packets can be authenticated when sent on a restored connection.

Incoming service request packets may be modified at run time to have valid security tokens such as an Active Directory Foundation Service token and or Access Control System token before being pushed into the queue. The tokens provide the service request packet with authentication rights that are needed to communicate with a target service. Additionally the security tokens are used to prevent unauthenticated calls from communicating with the target service.

The service request packets in the queue are processed in the order received. When a packet is ready to be sent to the target service a connector service may first perform a check to confirm that the authentication tokens for that packet are still valid. Once the service request packet is sent to target service the packet is removed from queue.

It will be understood that the target service may include any enterprise resource planning customer relationship management or other enterprise back office or back end service including for example but not limited to accounting planning scheduling personnel time capture expense capture project management resource management or approvals application or other back end system that exposes web services. In another embodiment target service may be a collection of different systems having any such services.

Client applications send service calls in packets on network to connector service which exposes one or more end points associated with target service . Depending upon the configuration of the client application packets may be associated with different protocols. For example the client applications may use Simple Object Access Protocol SOAP web services or Representational State Transfer REST web services to communicate with target service .

The communications between the client applications and target service may need to be authenticated for security reasons. Accordingly the client applications may use identity providers and security token services approved by the target service to generate authentication tokens. For example in one embodiment the tokens may be obtained from an Active Directory Federation Service and an Access Control System.

When a new packet is received connector service adds authentication tokens to the packet . The new packet is added to queue that holds a number of previously received packets . The packets in queue are maintained in the order they are received at connector service and are handled in a first come first served manner. Queue allows connector service to synchronize operations with target service and thereby avoid adverse communication scenarios such as race conditions.

Queue may be implemented in JavaScript in one embodiment. All HTTP communication to target service is first directed to connector service and is held in queue . This arrangement provides a unified communication channel for all web service requests and responses between the client application and the target service . Using queue connector service can easily manage update and authenticate all incoming communication service requests.

In one embodiment incoming service request packet may be modified at run time to have valid tokens such as an Active Directory Foundation Service token and Access Control System token before being pushed into the queue . Tokens provide service request packet with authentication rights that are needed to communicate with target service . The service request packets in queue are processed in the order received. When a packet is ready to be sent to target service connector service first performs a check to confirm that authentication tokens for that packet are still valid. Once the service request packet is sent to target service the packet is removed from queue .

By using queue any failed communication packets or any false or un intended communication request failure will be retried so that each packet has a high probability of reaching target service . Accordingly after the other packets are sent to target service connector service will again verify that tokens are valid and will resend packet .

If connector service determines that tokens are invalid when the time comes to resend packet then the packet will be discarded.

At any given time queue will contain unsent service requests . When it detects the loss of connectivity to the target service connector service immediately snapshots queue by copying the pending packets to a storage module in their current order.

In addition to the stored snapshot packets which have been saved in storage module in their original order of arrival any new incoming service requests and their associated tokens also get automatically saved to the storage module .

Eventually connectivity to target service will be restored such as when a host server comes back online or when a communication link is reestablished. At that time queue will load all the saved requests from storage module and connector service will start processing the packets in the order they were originally received. Prior to sending any packets to target service connector service will confirm if the tokens for service requests are still valid and unexpired. Any packets with valid tokens are sent to target service . In some cases packets may have authentication tokens that were valid when the snapshot was taken but that expired while waiting for connectivity to be restored. Those packets with expired or invalid tokens will be discarded before being sent to target service .

Connector supports making authenticated service calls over HTTP to any entity service such as target service or other business entity. Connector service works across all client platforms. Additionally connector service is agnostic to the type of device and or browser used by a client. Connector service may expose endpoints for the service calls to the target service. Any client application may send packets with the appropriate tokens to the exposed endpoints and connector service does not care where the service calls originate. Queue allows the connector service to keep the calls stateless but maintains enough information on each service call to be able authenticate the call and to talk to the target service.

In step the connector service evaluates if connectivity is available to a target service. Connectivity may be inferred by the connector service based upon network activity. In other embodiments if the target service is unavailable or not receiving service calls it may explicitly notify the connector service of connection status. If connectivity is available in step then the next packet is removed from the queue.

The tokens for that packet are inspected in step and evaluated for validity and currency. If the tokens are not valid and or are expired then the process moves to step and an exception is sent to the source application with an instruction to reinitiate the security token for that packet. The client application may resend the packet to the connector service after obtaining updated tokens. The connector service will process the resent packet with updated tokens in the same manner as any other newly received packet.

If the tokens for the packet are valid and unexpired in step then the packet is sent to the target service in step . The connector service monitors the packet in step and evaluates if the transmission to the target service failed. If the transmission has not failed i.e. if the packet was successfully sent to the target service in step then the connector service handles response callbacks from the target service in step .

If the transmission has failed i.e. if the packet was not successfully sent to the target service in step then the connector service evaluates whether to retry sending the packet in step . If the packet will not be retried then in step the connector service sends an exception to the client application. The exception may notify the client application that the packet was not successfully sent to the target service. The exception may include more detailed information with reasons for the failure such as any exception from the target service.

If the packet is going to be retried in step then the connector service updates a retry counter in step . The retry counter may be used for example in retry evaluation step to determine whether to allow any further retry attempts. The retry counter may be used to limit the number of retries to a predetermined number of attempts. In other embodiments the number of retries may be limited to a certain number of attempts within a designated period.

After updating the retry counter in step the process moves to step and the packet is inserted back into the start of the queue. The process continues with the next packet in the queue.

As noted above the connector service evaluates if connectivity is available to a target service in step . If connectivity is not available then the connector service takes a snapshot of the current queue in step . The connector service copies all of the packets in the queue along with any associated tokens and other information to a local storage. The stored packets may also be removed from the queue.

In step the connector service monitors connectivity and evaluates whether connectivity has been restored. As long as connectivity is still down the process will loop at step and periodically update connection status. During step any new received packets at the connector service are added to the local storage along with the other packets instead of being added to the queue.

The connector service will detect when connectivity has been restored either by observed network activity or after receiving a notification from the target service that is available. When the connectivity status has been updated in step the process moves to step where the packets are retrieved from the local storage. Then returning to step the packets are returned to the queue in the same order as they were received. The process then continues with the next packet in the queue.

It will be understood that steps of the process illustrated in may be executed simultaneously and or sequentially. It will be further understood that each step may be performed in any order and may be performed once or repetitiously.

Generally steps and represent typical packet flow through the connector service when connectivity is maintained and retries are not required. Step is performed when a packet s tokens are invalid or expired.

When a packet transmission fails between the connector service and the target service then steps are performed while the connector service attempts to retry sending the packet. The retry process is further illustrated and described in reference to above.

When connectivity has failed between the connector service and the target service then steps are performed while the connector service stores and protects the pending packets using the snapshot process. The snapshot process is further illustrated and described in reference to above.

The invention may be described in the general context of computer executable instructions such as program modules being executed by a computer. Generally program modules include routines programs objects components data structures and so forth which perform particular tasks or implement particular abstract data types. The invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment program modules may be located in local and or remote computer storage media including memory storage devices.

With reference to an exemplary system for implementing various aspects of the invention may include a general purpose computing device in the form of a computer . Components may include but are not limited to various hardware components such as processing unit data storage such as a system memory and system bus that couples various system components including the data storage to the processing unit . The system bus may be any of several types of bus structures including a memory bus or memory controller a peripheral bus and a local bus using any of a variety of bus architectures. By way of example and not limitation such architectures include Industry Standard Architecture ISA bus Micro Channel Architecture MCA bus Enhanced ISA EISA bus Video Electronics Standards Association VESA local bus and Peripheral Component Interconnect PCI bus also known as Mezzanine bus.

Processing unit may support a communication queue in a connector service. Data storage may be used to store communication packets such as a snapshot copy of communication packets from a queue.

The computer typically includes a variety of computer readable media . Computer readable media may be any available media that can be accessed by the computer and includes both volatile and nonvolatile media and removable and non removable media but excludes propagated signals. By way of example and not limitation computer readable media may comprise computer storage media and communication media. Computer storage media includes volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Computer storage media includes but is not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical disk storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can accessed by the computer . Communication media typically embodies computer readable instructions data structures program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term modulated data signal means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example and not limitation communication media includes wired media such as a wired network or direct wired connection and wireless media such as acoustic RF infrared and other wireless media. Combinations of the any of the above may also be included within the scope of computer readable media. Computer readable media may be embodied as a computer program product such as software stored on computer storage media.

The data storage or system memory includes computer storage media in the form of volatile and or nonvolatile memory such as read only memory ROM and random access memory RAM . A basic input output system BIOS containing the basic routines that help to transfer information between elements within computer such as during start up is typically stored in ROM. RAM typically contains data and or program modules that are immediately accessible to and or presently being operated on by processing unit . By way of example and not limitation data storage holds an operating system application programs and other program modules and program data.

Data storage may also include other removable non removable volatile nonvolatile computer storage media. By way of example only data storage may be a hard disk drive that reads from or writes to non removable nonvolatile magnetic media a magnetic disk drive that reads from or writes to a removable nonvolatile magnetic disk and an optical disk drive that reads from or writes to a removable nonvolatile optical disk such as a CD ROM or other optical media. Other removable non removable volatile nonvolatile computer storage media that can be used in the exemplary operating environment include but are not limited to magnetic tape cassettes flash memory cards digital versatile disks digital video tape solid state RAM solid state ROM and the like. The drives and their associated computer storage media described above and illustrated in provide storage of computer readable instructions data structures program modules and other data for the computer .

A user may enter commands and information through a user interface or other input devices such as a tablet electronic digitizer a microphone keyboard and or pointing device commonly referred to as mouse trackball or touch pad. Other input devices may include a joystick game pad satellite dish scanner or the like. Additionally voice inputs gesture inputs using hands or fingers or other natural user interface NUI may also be used with the appropriate input devices such as a microphone camera tablet touch pad glove or other sensor. These and other input devices are often connected to the processing unit through a user input interface that is coupled to the system bus but may be connected by other interface and bus structures such as a parallel port game port or a universal serial bus USB . A monitor or other type of display device is also connected to the system bus via an interface such as a video interface. The monitor may also be integrated with a touch screen panel or the like. Note that the monitor and or touch screen panel can be physically coupled to a housing in which the computing device is incorporated such as in a tablet type personal computer. In addition computers such as the computing device may also include other peripheral output devices such as speakers and printer which may be connected through an output peripheral interface or the like.

The computer may operate in a networked or cloud computing environment using logical connections to one or more remote devices such as a remote computer. The remote computer may be a personal computer a server a router a network PC a peer device or other common network node and typically includes many or all of the elements described above relative to the computer . The logical connections depicted in include one or more local area networks LAN and one or more wide area networks WAN but may also include other networks. Such networking environments are commonplace in offices enterprise wide computer networks intranets and the Internet.

In one embodiment network interface is used to exchange communication packets to and from a connector service. The network interface may support communication packets in various protocols such as REST and SOAP.

When used in a networked or cloud computing environment the computer may be connected to a public or private network through a network interface or adapter . In some embodiments a modem or other means for establishing communications over the network. The modem which may be internal or external may be connected to the system bus via the network interface or other appropriate mechanism. A wireless networking component such as comprising an interface and antenna may be coupled through a suitable device such as an access point or peer computer to a network. In a networked environment program modules depicted relative to the computer or portions thereof may be stored in the remote memory storage device. It may be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.

Although the subject matter has been described in language specific to structural features and or methodological acts it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the specific features or acts described above. Rather the specific features and acts described above are disclosed as example forms of implementing the claims.

