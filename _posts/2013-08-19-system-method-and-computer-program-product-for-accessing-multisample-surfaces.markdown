---

title: System, method, and computer program product for accessing multi-sample surfaces
abstract: A system, method, and computer program product are provided for accessing multi-sample surfaces. A multi-sample store instruction that specifies data for a single sample of a multi-sample pixel and a sample mask is received and the data for the single sample is stored to each sample of the multi-sample pixel that is enabled according to the sample mask. A multi-sample load instruction that specifies a multi-sample pixel is received, and, in response to executing the multi-sample load instruction, data for one sample of the multi-sample pixel is received. A determination is made that the data for the one sample of the multi-sample pixel represents multi-sample pixel data for at least one additional sample of the multi-sample pixel.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09436971&OS=09436971&RS=09436971
owner: NVIDIA Corporation
number: 09436971
owner_city: Santa Clara
owner_country: US
publication_date: 20130819
---
This application is a continuation of U.S. patent application Ser. No. 13 844 095 filed Mar. 15 2013 the entire contents of which is incorporated herein by reference.

When multi sampling techniques are used to produce anti aliased images the amount of processing for each pixel may increase as the number of samples per pixel increases. In addition to increased processing the amount of bandwidth that is consumed to transfer data between different processing units within a graphics processor also increases. The increases in processing demand and increased bandwidth consumption may result in decreased graphics processing performance and or increased system cost.

Thus there is a need for addressing the issues of increased processing and increased bandwidth consumption and or other issues associated with the prior art.

A system method and computer program product are provided for accessing multi sample surfaces. A multi sample store instruction that specifies data for a single sample of a multi sample pixel and a sample mask is received and the data for the single sample is stored to each sample of the multi sample pixel that is enabled according to the sample mask. A multi sample load instruction that specifies a multi sample pixel is received and in response to executing the multi sample load instruction data for one sample of the multi sample pixel is received. A determination is made that the data for the one sample of the multi sample pixel represents multi sample pixel data for all samples of the multi sample pixel or at least one additional sample of the multi sample pixel.

When conventional graphics processors are configured to generate multi sample surfaces the amount of memory that is allocated to store the multi sample pixel data increases based on the number of samples that are included in each pixel. As the number of samples per pixel increases the bandwidth consumed to read write and transmit the multi sample pixel data also increases.

When the data is the same for each sample of a pixel a single sample may be stored that represents all of the samples of a multi sample pixel or all of the samples of a portion of a multi sample pixel where the portion includes two or more samples. An encoding state may be associated with the multi sample pixel that indicates the single sample represents all of the samples i.e. 1SPP one sample per pixel portion . In one embodiment pixels are grouped into tiles and when all of the multi sample pixels within the tile may each be represented with a respective single sample an encoding state of 1SPP may be associated with the entire tile. When the encoding state is 1SPP the memory footprint for storing the multi sample pixel data is reduced and the bandwidth consumed to read write and transmit the multi sample pixel data is also reduced. Furthermore in some cases a processing unit may be configured to process the single sample to generate processed pixel data for the single sample that represents processed multi sample pixel data for two or more samples or even all of the samples of a pixel. Thus when the encoding state is 1SPP the processing capacity needed to process a multi sample pixel may also be reduced.

More illustrative information will now be set forth regarding various optional architectures and features with which the foregoing framework may or may not be implemented per the desires of the user. It should be strongly noted that the following information is set forth for illustrative purposes and should not be construed as limiting in any manner. Any of the following features may be optionally incorporated with or without the exclusion of other features described.

In addition to the pixel level the 1SPP encoding state may be applied to tiles of pixels or even an entire surface. A pixel tile may include one or more pixels that are adjacent in screen space or in memory. A size of the tile may be specified in storage units e.g. 256 bytes rather than as a quantity of pixels. Therefore the number of pixels in a tile may vary based on the multi sample mode i.e. more samples per pixel results in a smaller tile size . Pixels in the same tile do not necessarily need to be adjacent in screen space. In one embodiment a pixel tile is sized to correspond to a number of pixels that may be processed in parallel within a multi threaded graphics core.

As shown in the sample locations may be jittered i.e. distributed within each pixel to improve the image quality. In one embodiment a sample location may be positioned at the center of each pixel. Other multi sample pixel modes may include more than 4 samples or less than four samples for each pixel. The multi sample data for each sample may include z depth color texture coordinates or other attributes associated with graphics primitives.

In one embodiment the L2 cache stores or otherwise obtains the encoding state associated with the mufti sample surface. In one embodiment the encoding state may be stored within a memory controller for each page of memory of the frame buffer memory . The L2 cache is coupled to a Load Store unit via a crossbar . In one embodiment the frame buffer memory interfaces with the L2 cache through multiple memory interfaces and the crossbar is configured to route data between the Load Store unit and multiple L2 caches coupled to different memory interfaces as needed to reach corresponding memory locations in the frame buffer memory . illustrates more details regarding the memory interfaces. Multiple Load Store units may be coupled between the crossbar and multiple processing units that are configured to process pixel data.

Rather than being configured to replicate sample data for all of the samples in a mufti sample pixel when the encoding state is 1SPP to provide mufti sample pixel data to the Load Store unit the L2 cache may be configured to provide the multi sample pixel data with only one sample and the encoding state of 1SPP to the Load Store unit via the crossbar . Transmitting less data per pixel over the crossbar consumes less bandwidth. Because less data is transferred across the crossbar less power is also consumed. Therefore it is desirable to transmit the multi sample pixel data using the encoding state of 1SPP. In one embodiment the L2 cache may be configured to transmit the multi sample pixel data in tile sized increments 1SPP format or not to the Load Store unit via the crossbar . Accordingly the Load Store unit may be configured to store multi sample pixel data in tile sized increments. In other embodiments the L2 cache is configured to transmit a subset of the samples for a multi sample pixel based on a request received from the Load Store unit .

The Load Store unit is configured to provide multi sample pixel data to the processing unit when a load request is received from the processing unit . The Load Store unit is also configured to receive processed multi sample pixel data from the processing unit and store the multi sample pixel data. The Load Store unit may include a buffer for storing the processed multi sample data temporarily before outputting the processed multi sample data to the frame buffer memory via the crossbar and L2 cache . In one embodiment the Load Store unit functions at least in part as a cache that is configured to buffer multi sample pixel data received from the L2 cache and processed multi sample pixel data received from the processing unit in a single buffer. When an entry is not available in the buffer to store multi sample pixel data or processed multi sample pixel data one or more entries are written back to the frame buffer memory i.e. flushed via the crossbar and the L2 cache . When an entry has not been written with processed multi sample pixel data received from the processing unit the entry may be replaced and not flushed to the L2 cache . Details of the Load Store unit are described in conjunction with .

The Load Store unit receives the multi sample pixel data and determines the encoding state associated with the multi sample pixel data. When the encoding state is 1SPP data for one sample of a multi sample pixel and the encoding state are provided to the processing unit . When the encoding state is not 1SPP the Load Store unit may be configured to provide data for all samples or at least a portion of the multi sample pixel to the processing unit along with the encoding state.

In one embodiment the processing unit may be configured to load a single sample of a multi sample pixel instead of all samples of a multi sample pixel and if the single sample is returned and the encoding state for the single sample is 1SPP the processing unit processes the single sample. If the single sample is returned and the encoding state for the single sample is not 1SPP the processing unit then loads the remaining samples of the multi sample pixel and processes all of the samples of the multi sample pixel. By deferring loading of the remaining samples the bandwidth consumed to transfer the multi sample pixel data is reduced when the encoding state is 1SPP and the remaining samples are not loaded. In another embodiment if the single sample is returned and the encoding state for the single sample is not 1SPP the processing unit issues aloud request for one or more additional samples.

A multi sample load instruction that includes a mask corresponding to samples of the multi sample pixel may be used to load a single sample of a multi sample pixel or to load one or more additional samples of the multi sample pixel. In one embodiment the multi sample load instruction specifies an index corresponding to a sample to request the sample or a sequence of samples. When executed the multi sample load instruction may be configured to return the multi sample pixel data corresponding to the sample and a mask indicating other samples in the multi sample pixel that have the same multi sample pixel data and or the encoding state of the multi sample pixel.

When the encoding state is 1SPP the one sample of the multi sample pixel is processed by the processing unit to generate processed data for the one sample that represents processed multi sample pixel data for all samples or at least a portion of the multi sample pixel. When the encoding state is not 1SPP all of the samples of the multi sample pixel portion are processed to generate processed data for all of the samples. Therefore when the number of samples per pixel is 8 the amount of processing per pixel is 8 when the encoding state is not 1SPP compared with when the encoding state is 1SPP. The processing is proportionally reduced for other numbers of samples per pixel when the encoding state is 1SPP. Reducing the multi sample pixel processing may improve performance and may also reduce power consumption. As described in conjunction with in other embodiments the processing unit may be configured to process a subset of the samples and the processing unit provides information e.g. a per pixel sample mask or per pixel portion sample mask indicating which samples are represented by the processed multi sample data that is output to the Load Store unit .

When the processing unit is configured to perform a blending operation or a fragment shading operation the multi sample pixel is considered a destination pixel that is combined with source pixel data to produce the processed data for the multi sample pixel. It is not unusual for the source pixel data to have the same value for all samples of a multi sample pixel such that the blending or shading operation generates processed data for a single sample that represents all samples of the processed multi sample pixel. In this case the processing unit provides the processed data for the single sample in a store request to the Load Store Unit along with the encoding state of 1SPP. Otherwise when processed data is generated for all of the samples the processing unit provides the processed data for all of the samples in a store request to the Load Store Unit along with the encoding state of not 1SPP. A multi sample store instruction that includes a mask corresponding to samples of the multi sample pixel may be used to store a value to one or more samples of a multi sample pixel.

Efficiencies can be realized in transmitting less data for each multi sample pixel and in processing of the data by providing the encoding state with the data for the multi sample pixels. The amount of bandwidth that is consumed transmitting the data across the crossbar may be reduced for load operations and or store operations. A single processing thread may be allocated by the processing unit to generate the data for a multi sample pixel having the encoding state of 1SPP compared with allocating multiple threads to generate the data for a multi sample pixel having the encoding state that is not 1SPP. In one embodiment the Load Store unit may be configured to coalesce the data for the multi sample pixels received from the processing unit into a tile before transmitting the data over the crossbar to the L2 cache . When an entire tile of data is transmitted to the L2 cache the Load Store unit may provide the encoding state for the entire tile rather than for individual multi sample pixels.

In one embodiment the encoding state is received with the data from the L2 cache and the load request unit provides the encoding state to the processing unit along with the data. In another embodiment the load request unit does not receive encoding state from the L2 cache and the load request unit is configured to compare the values of data for different samples of a multi sample pixel or a portion of the multi sample pixel and determine the encoding state to be 1SPP when all of the samples of a multi sample pixel have the same value. Otherwise the load request unit determines that the encoding state is not 1SPP. In one embodiment the L2 cache is configured to compare the values of data for different samples of a multi sample pixel or a portion of the multi sample pixel and determine the encoding state for each pixel or for a tile of pixels in order to provide the encoding state to the Load Store unit . As described in conjunction with in other embodiments the L2 cache and or the Load Store unit may be configured to compare the values of data for different samples of a multi sample pixel or portion of a multi sample pixel and provide information e.g. a per pixel sample mask or per pixel portion sample mask indicating which samples are represented by the processed multi sample data that is output to the Load Store unit or the processing unit respectively.

Depending on the multi sample mode i.e. the number of samples used for a multi sample pixel the load request unit may be configured to generate the encoding state for a partial multi sample pixel i.e. portion of a multi sample pixel . For example when a cache line of the cache is 32 bytes and a multi sample surface stores 16 samples of 4 bytes each for each multi sample pixel the load request unit may be configured to compare 8 different samples of the multi sample pixel and determine an encoding state for the 8 samples. Thus each 16 sample multi sample pixel may have two encoding states one encoding state for each portion of samples. On the other hand when a multi sample surface stores 4 samples of 4 bytes each for each multi sample pixel the load request unit may be configured to compare 4 different samples for 2 different multi sample pixels and determine one encoding state for the two different multi sample pixels. Thus the granularity of the encoding state may vary according to the number of comparisons made by the load request unit and or the size of a cache line.

The coalesce unit receives processed data for multi sample pixels and encoding state corresponding to the multi sample pixels from the processing unit . The coalesce unit may include a coalesce buffer into which the processed data is stored. The coalesce buffer may be configured to store processed data for one or more tiles or even for a partial tile when the amount of storage needed in the coalesce buffer is not large enough to store the processed data for an entire tile. When the coalesce buffer stores more than one tile the coverage tracking unit is configured to track coverage for each tile. Furthermore when the multi sample mode may be different for each tile the coalesce unit stores information indicating the multi sample mode for each tile. When entries in the coalesce buffer are written a corresponding cache line or portion of a cache line in the cache may be invalidated.

In one embodiment the coalesce buffer is omitted and the processed data is stored in the cache . In other words the coalesce buffer is embodied as the entries within the cache that store data for the processed pixels. When the encoding state received from the processing unit is 1SPP all of the samples of the multi sample pixel or a portion of the multi sample pixel have the same values. The 1SPP encoding state may be used for a portion of a multi sample pixel when the number of samples is high. For example when the number of bytes needed to store the data for all of the samples in a multi sample pixel is greater than 256 Bytes or the size of a cache line.

In one embodiment the coverage tracking unit stores a single bit for each multi sample pixel and the bit is set when a store request is received by the Load Store unit for the multi sample pixel. When all of the bits for the multi sample pixels of a tile are set store requests have been received for all for the multi sample pixels in the tile and the tile is full . In another embodiment the coverage tracking unit uses a counter to track the number of store operations for a tile to determine if store requests have been received for all of the multi sample pixels in the tile. When a tile is full the data for the tile may be flushed from the coalesce buffer or the cache to the L2 cache . Entries in the cache storing the data for the tile may be marked as empty and the bits in the coverage tracking unit corresponding to the tile may be cleared when the tile is flushed.

When the coalesce buffer is configured to store a partial tile processed data for the partial tile may be flushed when the coverage tracking unit indicates that store operations have been received for all of the multi sample pixels in the partial tile. Entries in the cache storing the data for the partial tile may be marked as empty and the bits in the coverage tracking unit corresponding to the partial tile may be cleared when the partial tile is flushed. An advantage of storing processed data for groups of multi sample pixels is that a single encoding state may be output to the L2 cache for the entire group e.g. tile rather than outputting an encoding state for each multi sample pixel.

Under certain conditions a tile may be flushed by the coalesce unit before processed data for all of the multi sample pixels in the tile are received from the processing unit or when the tile is not full . A first condition is that processed data is received for a new tile and storage is not available in the coalesce buffer to coalesce a new tile. The second condition is that the processed data is for a multi sample pixel that has already been received for a tile being coalesced i.e. the bit associated with the multi sample pixel is set in the coverage tracking unit . The coalesce unit may flush the processed data that is already stored for the tile to begin coalescing the tile again with the new processed data. Alternatively the coalesce unit may compare the new processed data with the processed data stored in the coalesce buffer and if the new processed data equals the stored processed data the coalesce unit may discard the new processed data or overwrite the stored processed data with the new processed data and avoid flushing the tile. When the new processed data does not match the stored processed data the coalesce unit flushes the tile to begin coalescing the tile again with the new processed data. Alternatively the coalesce unit may flush one or more entries in the coalesce buffer that is occupied by the stored processed data and store the new processed data in the one or more entries.

When an incomplete tile i.e. a tile that is not full is flushed the load store unit outputs the processed data for the multi sample pixels that have been received from the processing unit . The tile coverage information maintained in the tracking unit may be used by the coalesce unit to determine which multi sample pixels are flushed. When the processed data is stored in the cache i.e. the coalesce buffer is omitted the processed pixel data may be flushed when a cache miss occurs. In one embodiment the processing unit is configured to process the data for samples that are within one tile in parallel to enable the load store unit to coalesce the sample into tiles that may be flushed to the L2 cache as full tiles.

The processed data for the multi sample pixels that is flushed may all have the same encoding state or an encoding state may be stored in the coalesce buffer for each multi sample pixel. The processed data for the incomplete tile may be output with a single encoding state or with an encoding state for each multi sample pixel per pixel encoding state or portion of a multi sample pixel. When all of the multi sample pixels have the same encoding state the processed data may be output with a tile mask indicating which of the multi sample pixels are included in the flush. When encoding state is maintained for each multi sample pixel the coalesce unit may be configured to examine the per pixel encoding state for the tile. When all of the per pixel encoding state is the same the processed data may be output with a tile mask indicating which of the multi sample pixels are included in the flush.

When the per pixel encoding state differs for at least one multi sample pixel the processed data associated with a 1SPP encoding state may be replicated for each sample in the respective multi sample pixel and all of the processed data may be output with a tile mask and an encoding state of not 1SPP. Alternatively the processed data may be output in two sub flushes. A first sub flush may include the processed data associated with the encoding state of 1SPP and a corresponding first tile mask. A second sub flush may include the processed data associated with the encoding state of not 1SPP and a corresponding second tile mask. Finally the processed data may be output with per pixel encoding state and a tile mask.

In one embodiment the coalesce unit is configured to snoop the writes to the cache that are received from the processing unit and update the tile coverage mask maintained by the coverage tracking unit . When a tile is full the coalesce unit reads the tile data from the cache . Entries in the cache storing the data for the tile may be marked as empty and the bits in the coverage tracking unit corresponding to the tile may be cleared when the tile is flushed.

In one embodiment when the encoding state for the processed data that is flushed is not 1SPP the coalesce unit is configured to analyze the processed data. The coalesce unit is configured to compare the values of the processed data for different samples of each mufti sample pixel or a portion of each mufti sample pixel and determine the encoding state for each pixel or for a tile of pixels in order to provide the encoding state to the L2 cache . The coalesce buffer may be configured to store the processed data for different samples while the analysis is performed. The coalesce buffer may also be configured to store the encoding state for each multi sample pixel or portion of each multi sample pixel as the processed data is analyzed.

When the coalesce buffer is configured to output a partial tile processed data for the partial tile may be flushed when the coverage tracking unit indicates that store operations have been received for all of the multi sample pixels in the partial tile. Entries in the cache storing the data for the partial tile may be marked as empty and the bits in the coverage tracking unit corresponding to the partial tile may be cleared when the partial tile is flushed.

Under certain conditions a tile may be flushed by the coalesce unit before processed data for all of the multi sample pixels in the tile are received from the processing unit or when the tile is not full . A first condition is that processed data is received for a new tile and storage is not available in the cache to coalesce a new tile. The second condition is that the processed data is for a multi sample pixel that has already been received for a tile being coalesced i.e. the bit associated with the multi sample pixel is set in the coverage tracking unit . The coalesce unit may flush the processed data that is already stored for the tile to begin coalescing the tile again with the new processed data. Alternatively the coalesce unit may flush one or more entries in the cache that are occupied by the stored processed data and store the new processed data in the one or more entries.

When an incomplete tile i.e. a tile that is not full is flushed the load store unit outputs the processed data for the multi sample pixels that have been received from the processing unit . The tile coverage information maintained in the tracking unit may be used by the coalesce unit to determine which multi sample pixels are flushed. The processed pixel data may be flushed when a cache miss occurs for the cache . In one embodiment the processing unit is configured to process the data for samples that are within one tile in parallel to enable the load store unit to coalesce the sample into tiles that may be flushed to the L2 cache as full tiles.

The processed data for the multi sample pixels that is flushed may all have the same encoding state or an encoding state may be stored in the coalesce buffer or the cache for each multi sample pixel. The processed data for the incomplete tile may be output with a single encoding state or with an encoding state for each multi sample pixel per pixel encoding state or portion of a multi sample pixel. When all of the multi sample pixels have the same encoding state the processed data may be output with a tile mask indicating which of the multi sample pixels are included in the flush. When encoding state is maintained for each multi sample pixel the coalesce unit may be configured to examine the per pixel encoding state for the tile. When all of the per pixel encoding state is the same the processed data may be output with a tile mask indicating which of the multi sample pixels are included in the flush.

When the per pixel encoding state differs for at least one multi sample pixel the processed data associated with a 1SPP encoding state may be replicated for each sample in the respective multi sample pixel and all of the processed data may be output with a tile mask and an encoding state of not 1SPP. Alternatively the processed data may be output in two sub flushes. A first sub flush may include the processed data associated with the encoding state of 1SPP and a corresponding first tile mask. A second sub flush may include the processed data associated with the encoding state of not 1SPP and a corresponding second tile mask. Finally the processed data may be output with per pixel encoding state and a tile mask.

In one embodiment the load store unit receives encoding state for the multi sample pixels with the multi sample pixel data. In another embodiment as described in further detail in conjunction with the load store unit is configured to perform an analysis of the multi sample pixel data to determine if the multi sample pixel data may be encoded in 1SPP format. At step when the load store unit determines that the multi sample pixel data may be encoded in 1SPP format by analyzing the multi sample pixel data the encoding state is set to 1SPP. At step the one sample of the pixel is processed by the processing unit to generate processed data for the all samples of the pixel.

If at step the load store unit determines that the encoding state associated with the multi sample pixel data is not 1SPP then at step the load store unit may provide data for all samples of each multi sample pixel or each multi sample pixel portion and the encoding state to the processing unit . At step the encoding state is set to not 1SPP and is output to the processing unit along with the data for all samples of each multi sample pixel or each multi sample pixel portion. At step the processing unit processes the data for an of the samples for each multi sample pixel or each multi sample pixel portion.

At step the processing unit sets the encoding state to 1SPP or not 1SPP based on the representation of the processed data. At step the processing unit outputs the processed data for each multi sample pixel or each multi sample pixel portion to the Load Store unit along with the encoding state. The processed data may include data for the one sample or for all samples of a multi sample pixel or for all samples of a multi sample pixel portion.

At step the Load Store unit receives the processed data for a multi sample pixel from the processing unit . At step the Load Store unit examines the encoding state that is provided by the processing unit with the processed data and determines if the encoding state is 1SPP. When the encoding state is not 1SPP the Load Store unit outputs the processed data to the L2 cache at step . In another embodiment when the encoding state is not 1SPP the Load Store unit stores the processed data for all of the samples in the coalesce buffer . When an entire tile is flushed from the coalesce buffer the Load Store unit then analyzes the processed data to determine if the processed data for the entire tile may be represented using only one sample for each multi sample pixel. The technique described in conjunction with may be applied to perform the analysis.

If at step the encoding state is 1SPP at step the Load Store unit determines if a new tile is needed to store the processed data because the multi sample pixel is not within a current tile that is stored in the coalesce buffer and if not the Load Store unit proceeds to step . If a new tile is needed at step the processed data for the current tile is flushed to the L2 cache and the tile coverage is cleared in the coverage tracking unit before the Load Store unit proceeds to step . If at step a new tile is not needed to store the processed data then at step the Load Store unit stores the processed data for the multi sample pixel in the coalesce buffer . At step the Load Store unit updates the tile coverage stored in the coverage tracking unit and the Load Store unit proceeds to step .

At step the Load Store unit determines if a tile stored in the coalesce buffer is fully covered and if so the processed data for the fully covered tile is flushed to the L2 cache and the tile coverage is cleared in the coverage tracking unit and the Load Store unit terminates handling of the process multi sample pixel data that was received at step . The steps described in conjunction with may also be performed for a partial tile when the coalesce buffer is configured to store a partial tile instead of an entire tile.

At step the Load Store unit determines if an encoding state of 1SPP was received with the multi sample pixel data and if so the Load Store unit proceeds to step . Otherwise at step the Loud Store unit analyzes the multi sample pixel data to determine if the multi sample pixel data may be encoded in 1SPP format. In one embodiment the Load Store unit compares values for all samples of each multi sample pixel or portion of a multi sample pixel to determine if a tile of pixel data received from the L2 cache can each be represented by single sample before storing the pixel data in the cache . In another embodiment the Load Store unit compares values for all samples of each multi sample pixel that is read from the cache for output to the processing unit to determine if the data can each be represented by single sample before outputting the pixel data to the processing unit . If at step the Load Store unit determines that the multi sample pixel data may be encoded in 1SPP format then the Load Store unit proceeds to step . Otherwise Load Store unit proceeds to step .

When the data is the same for each sample of a pixel the 1SPP encoding state may be used to reduce the memory footprint for storing the multi sample pixel data and also reduce the bandwidth consumed to read write and transmit the multi sample pixel data. Furthermore in some cases a processing unit such as the processing unit may be configured to process the single sample to generate processed multi sample pixel data for the single sample that represents processed multi sample pixel data for two or more samples or even all of the samples of a multi sample pixel.

In addition to an encoding state of 1SPP and not 1SPP an encoding state may be provided or determined that allows sample subsets for a multi sample pixel to have the same data values but does not require all samples in a multi sample pixel to have the same data values. Such an encoding state is referred to as a subset encoding state. In other words when the encoding state is subset data for single sample may be stored that represents multi sample pixel data for all samples in a subset of a multi sample pixel that includes the single sample. The multi sample pixel data is analyzed to identify subsets of samples of a multi sample pixel that have equal data when the subset encoding state may be used.

Each subset includes at least one sample and the encoding state of subset indicates which samples are included in a subset for a multi sample pixel. For example the subset encoding state may include a per pixel sample mask indicating the samples of the multi sample pixel that are included in the subset. Typically the subset encoding state is relevant for individual multi sample pixels. However the encoding state of subset may also be used for an entire tile or partial tile of multi sample pixel data.

The load request unit performs at least the functions of the previously described load request unit . The load request unit also includes an analysis unit that may be configured to analyze the multi sample pixel data to determine if the multi sample pixel data may be encoded in 1SPP format as previously described. Additionally the analysis unit may be configured to analyze the multi sample pixel data to determine if the multi sample pixel data may be encoded with an encoding state of subset. More specifically the analysis unit may generate a per pixel sample mask for each sample subset where all of the samples in a subset can be represented by a single sample of the subset i.e. the samples in the subset have the same data. The analysis unit may determine the encoding state that is output to the processing unit . In one embodiment the encoding state is received with the data from the L2 cache and the load request unit provides the encoding state to the processing unit along with the data.

The coalesce unit performs at least the functions as the previously described coalesce unit . The coalesce unit receives processed data for multi sample pixels and encoding state corresponding to the multi sample pixels from the processing unit . The coalesce unit may include a coalesce buffer into which the processed data is stored. The coalesce buffer may also be configured to store the per pixel sample masks for sample subsets when the encoding state is subset. Alternatively the per pixel sample masks may be stored in the coverage tracking unit and the coverage tracking unit may be configured to track multi sample pixel coverage as well as tile or partial tile coverage. The multi sample coverage masks may be merged using bit wise OR operations. When all of the bits in the stored multi sample coverage mask for a multi sample pixel are set the multi sample pixel is fully covered. However if the coalesce unit is configured to output processed multi sample pixel data with an encoding state of subset the separate per pixel coverage masks for each subset should be stored separately. In one embodiment a per pixel sample mask is stored in coalesce buffer with the processed multi sample pixel data for each subset.

The coalesce unit may also include the previously described analysis unit that may be configured to analyze the multi sample pixel data to determine if the multi sample pixel data may be encoded with an encoding state of 1SPP not 1SPP or subset. The analysis unit may determine the encoding state that is output to the L2 cache . In one embodiment the encoding state is received with the data from the processing unit and the coalesce unit provides the encoding state to the L2 cache along with the processed data.

When processed multi sample data is received for a multi sample pixel that has already been received for a tile being coalesced i.e. at least one bit associated with the multi sample pixel is set in the per pixel sample coverage mask stored in the coverage tracking unit the multi sample data may be merged when the encoding state for the multi sample pixel is subset if the new processed data equals the stored processed data. Otherwise the new processed data is stored separately from the stored processed data and the per pixel sample coverage mask stored in the coverage tracking unit is updated to merge the new per pixel sample coverage mask and the stored per pixel sample coverage mask.

When the per pixel encoding state differs for at least one multi sample pixel in a tile the processed data associated with a 1SPP encoding state may be replicated for each sample in the respective multi sample pixel and processed data associated with a subset encoding state may be replicated for each sample in the respective subset. Then all of the processed data may be output with a tile mask and an encoding state of not 1SPP. Alternatively the processed data may be output in two or three sub flushes. A first sub flush may include the processed data associated with the encoding state of 1SPP and a corresponding first the mask. A second sub flush may include the processed data associated with the encoding state of not 1SPP and a corresponding second tile flask. A third sub flush may include the processed data associated with the encoding state of subset including per pixel sample masks and a corresponding third tile mask. Finally the processed data may be output with per pixel encoding state and a tile mask where the encoding state for each pixel may include the encoding state of subset which comprises two of more per pixel sample masks.

In one embodiment the coalesce buffer stores the processed multi sample pixel data as a list of pixel x y processed data per pixel sample mask values. The x y coordinates may be tile relative. The values are stored as an array of tuples where a new incoming processed data is stored in the next available index rather than relative to the x y location of the multi sample pixel. This may allow equal processed data values corresponding to different samples of a multi sample pixel to be merged within the same entry of the coalesce buffer . In one embodiment the data values may be merged when the two values are within a threshold value of each other. In one embodiment a different threshold value may be specified for each attribute. Therefore color values may be merged using a different threshold value that is used for merging z values. In one embodiment the coalesce buffer may be implemented as a content addressable memory CAM . When the coalesce buffer is flushed the list of tuples may be output to the sent to L2 cache or the processed data stored in the coalesce buffer may be expanded to the format of not the 1SPP encoded state.

In one embodiment the coalesce unit is configured to snoop the writes to the cache that are received from the processing unit and update the tile coverage mask and per pixel sample coverage masks maintained by the coverage tracking unit . When a tile is full the coalesce unit reads the tile data from the cache . Entries in the cache storing the data for the tile may be marked as empty and the bits in the coverage tracking unit corresponding to the tile may be cleared when the tile is flushed.

In one embodiment the coalesce unit when the encoding state for the processed data that is flushed is not 1SPP the analysis unit within the coalesce unit is configured to analyze the processed data. The analysis unit may be configured to compare the values of the processed data for different samples of each multi sample pixel and determine the encoding state for each pixel or for a tile of pixels in order to provide the encoding state to the L2 cache . The coalesce buffer may be configured to store the processed data for different samples while the analysis is performed. The coalesce buffer may also be configured to store the encoding state for each multi sample pixel or portion of each multi sample pixel as the processed data is analyzed.

When the coalesce buffer is configured to output a partial tile processed data for the partial tile may be flushed when the coverage tracking unit indicates that store operations have been received for all of the samples of all of the multi sample pixels in the partial tile. Entries in the cache storing the data for the partial tile may be marked as empty and the bits in the coverage tracking unit corresponding to the partial tile may be cleared when the partial tile is flushed.

Under certain conditions a tile may be flushed by the coalesce unit before processed data for all of the multi sample pixels in the tile are received from the processing unit or when the tile is not full . A first condition is that processed data is received for a new tile and storage is not available in the cache to coalesce a new tile. The second condition is that the processed data is for a sample of a multi sample pixel that has already been received for a tile being coalesced i.e. the bit associated with the sample of the multi sample pixel is set in the coverage tracking unit . The coalesce unit may flush the processed data that is already stored for the tile to begin coalescing the tile again with the new processed data. Alternatively the coalesce unit may flush one or more entries in the cache that are occupied by the stored processed data and store the new processed data in the one or more entries.

When an incomplete tile i.e. a tile that is not full is flushed the load store unit outputs the processed data for the multi sample pixels that have been received from the processing unit . The tile coverage information maintained in the tracking unit may be used by the coalesce unit to determine which multi sample pixels are flushed. The processed pixel data may be flushed when a cache miss occurs for the cache . In one embodiment the processing unit is configured to process the data for samples that are within one tile in parallel to enable the load store unit to coalesce the sample into tiles that may be flushed to the L2 cache as full tiles.

The processed data for the multi sample pixels that are flushed may all have the same encoding state or an encoding state may be stored in the coalesce buffer or the cache for each multi sample pixel or for each sample subset of a multi sample pixel. The processed data for the incomplete tile may be output with a single encoding state or with an encoding state for each multi sample pixel per pixel encoding state or sample subset of a multi sample pixel. When all of the multi sample pixels have the same encoding state the processed data may be output with a tile mask indicating which of the multi sample pixels are included in the flush. When encoding state is maintained for each multi sample pixel the coalesce unit may be configured to examine the per pixel or per subset encoding state for the tile. When all of the per pixel encoding state is the same the processed data may be output with a tile mask indicating which of the multi sample pixels are included in the flush. Per pixel sample masks will be output by the coalesce unit when the encoding state is subset.

When the per pixel encoding state differs for at least one multi sample pixel in a tile the processed data associated with a 1SPP encoding state may be replicated for each sample in the respective multi sample pixel and processed data associated with a subset encoding state may be replicated for each sample in the respective subset. Then all of the processed data may be output with a tile mask and an encoding state of not 1SPP. When the per pixel encoding state differs for at least one multi sample pixel in a tile i.e. subset and 1SPP the processed data associated with the 1SPP encoding state may be encoded as a sample subset. Alternatively the processed data may be output in two or three sub flushes. A first sub flush may include the processed data associated with the encoding state of 1SPP and a corresponding first tile mask. A second sub flush may include the processed data associated with the encoding state of not 1SPP and a corresponding second tile mask. A third sub flush may include the processed data associated with the encoding state of subset including per pixel sample masks and a corresponding third tile mask. Finally the processed data may be output with per pixel encoding state and a tile mask where the encoding state for each pixel may include the encoding state of subset which comprises two of more per pixel sample masks.

In one embodiment the load store unit receives encoding state for the multi sample pixels with the multi sample pixel data in another embodiment the load store unit includes an analysis unit and is configured to perform an analysis of the multi sample pixel data to determine if the multi sample pixel data may be associated with an encoded state of 1SPP or subset. At step when the load store unit determines that the multi sample pixel data may be encoded in 1SPP format by analyzing the multi sample pixel data the encoding state is set to 1SPP. At step the one sample of the pixel is processed by the processing unit to generate processed data for the all samples of the pixel or pixel portion.

If at step the load store unit determines that the encoding state associated with the multi sample pixel data is not 1SPP then at step the load store unit determines if the multi sample pixel data may be associated with an encoded state of subset. At step when the load store unit determines by analyzing the multi sample pixel data that the multi sample pixel data may be encoded with an encoding state of subset the encoding state is set to subset and the corresponding per pixel sample mask is included in the encoding state for each sample subset. At step the encoding state is output to the processing unit along with the data for one sample of each sample subset. At step the one sample of the pixel is processed by the processing unit to generate processed data for the all samples of the sample subset.

If at step the load store unit determines that the encoding state associated with the multi sample pixel data is not subset then at step the load store unit may provide data for all samples of each multi sample pixel or each multi sample pixel portion and the encoding state to the processing unit . At step the encoding state is set to not 1SPP and is output to the processing unit along with the data for all samples of each multi sample pixel or each multi sample pixel portion. At step the processing unit processes the data for all of the samples for each multi sample pixel or each multi sample pixel portion.

At step the processing unit sets the encoding state to 1SPP subset or not 1SPP based on the representation of the processed data. At step the processing unit outputs the processed data for each multi sample pixel each multi sample pixel portion or each sample subset to the Load Store unit along with the encoding state. The processed data may include data for the one sample or for all samples of a multi sample pixel one sample of each sample subset one sample for all samples of a multi sample pixel portion or all samples of a multi sample pixel.

At step the Load Store unit receives the processed data for a multi sample pixel from the processing unit . At step the Load Store unit determines if a new tile is needed to store the processed data because the multi sample pixel is not within a current tile that is stored in the coalesce buffer and if not the Load Store unit proceeds to step . If a new tile is needed at step the processed data for the current tile is flushed to the L2 cache and the tile coverage is cleared in the coverage tracking unit before the Load Store unit proceeds to step .

At step the Load Store unit examines the encoding state that is provided by the processing unit with the processed data and determines if the encoding state is 1SPP. When the encoding state is not 1SPP at step the Load Store unit determines if the processed data can be encoded as one or more subsets. The Load Store unit may perform an analysis of the processed data using the analysis unit to determine the encoding state. If the processed data can be encoded as one or more subsets at step a per pixel sample mask is generated for each subset. At step the Load Store unit determines if an entry in the coalesce buffer matches the x y coordinates or other unique identifier for the multi sample pixel. If a matching entry is found at step then at step the Load Store unit merges the processed data into the matching entry. Otherwise at step the Load Store unit stores the processed data in an empty entry of the coalesce buffer .

If at step the Load Store unit determines that one or more subsets cannot be encoded then at step the Load Store unit stores the processed data in an empty entry of the coalesce buffer . When the processed data cannot be encoded as ism or subset the encoding state is not 1SPP and processed data for each sample is stored for the multi sample pixel. In another embodiment the Load Store unit outputs the processed data to the L2 cache when the encoding state is not 1SPP.

If at step the encoding state is 1SPP at step the Load Store unit stores the processed data for the multi sample pixel in the coalesce buffer . At step the Load Store unit updates the tile coverage stored in the coverage tracking unit . At step the Load Store unit determines if a tile stored in the coalesce buffer is fully covered and if so the processed data for the fully covered tile is flushed to the L2 cache and the tile coverage is cleared in the coverage tracking unit . Then the Load Store unit terminates handling of the process multi sample pixel data that was received at step . The steps described in conjunction with may also be performed for a partial tile when the coalesce buffer is configured to store a partial tile instead of an entire tile.

When the data is the same for one or more subsets of samples of a multi sample pixel the subset encoding state may be used to reduce the memory footprint for storing the multi sample pixel data and also reduce the bandwidth consumed to read write and transmit the multi sample pixel data. Furthermore in some cases a processing unit such as the processing unit or may be configured to process the single sample to generate processed multi sample pixel data for the single sample that represents processed multi sample pixel data for two or more samples or even all of the samples of a multi sample pixel.

As previously described a multi sample load instruction SULD.MS may be supported that returns a sample mask indicating which samples are known to have the same value. The multi sample load instruction also specifies an address or coordinates of a multi sample pixel. In one embodiment the multi sample load instruction returns a predicate indicating whether the multi sample pixel has an encoding state of not 1SPP i.e. a separate value is stored for each sample of the multi sample pixel . In another embodiment the predicate indicates the encoding state of the multi sample pixel e.g. 1SPP not 1SPP or subset.

In one embodiment inputs to the multi sample load instruction include a pixel address and sample identifier corresponding to one sample in the multi sample pixel. In addition to returning the data for the one sample the multi sample load instruction also returns an integer sample mask indicating which other samples in the multi sample pixel are known to have the same data as the one sample. The multi sample load instruction may be defined such that the sample mask can be computed opportunistically. For example if the multi sample pixel is known to be part of a tile having an encoding state of 1SPP then the sample mask will indicate that all samples of the multi sample pixel have the same data. When the encoding state of the multi sample pixel is subset the sample mask will indicate which samples are included in the same subset as the sample corresponding to the specified sample identifier. The load store unit or the L2 cache may be configured to analyze the multi sample pixel data and generate the per pixel sample mask corresponding to the subset that includes the sample corresponding to the specified sample identifier. The generated per pixel sample mask may be returned by the multi sample load instruction as the sample mask. In one embodiment the load store unit or the L2 cache analyzes the other samples stored in a cache line to generate the sample mask so the sample mask may not represent all of the samples in the subset when data for all of the samples cannot be stored in a single cache line.

Additionally a multi sample store instruction SUST.MS may be supported that accepts a sample mask where a value provided with the multi sample store instruction is stored to every sample of a multi sample pixel that is enabled according to the specified sample mask. In one embodiment a sample mask that indicates a fully covered pixel may be stored in a 1SPP format as shown in . In another embodiment a sample mask that indicates a partially covered pixel may be stored in a subset encoding.

The code shown in Table 1 illustrates an example of how the SUST.MS and SULD.MS instructions may be used in a shader program to compute and store a function of values of samples in a pixel that are covered by a primitive.

The pixel coverage mask indicates the sample coverage of a new primitive regardless of the values that are stored for each sample not the sample coverage for a subset where the samples all store the same data . In each iteration of the loop the value of one sample that is covered according to the coverageMask is loaded using the SULD.MS instruction. The SULD.MS instruction returns the per pixel sample mask or per cache line sample mask . The value of the requested sample is processed to generate a processed value.

The processed data for the one sample is returned and stored to all samples that have the same value as the one sample according to the per pixel sample mask and that are covered by the new primitive. The coverageMask is bit wise ANDed with the per pixel sample mask to ensure only samples that are covered by the new primitive are written. The coverageMask is then updated based on the samples that were written by SUST.MS. The loop is only executed for each sample subset rather than executing for each sample that is covered according to the pixel coverage mask.

In one embodiment the analyze unit is implemented as fixed function circuitry that is configured to implement comparison operations to compute the per pixel sample mask that is returned by the SUDAN instruction. An example implementation uses a 32 Byte cache line size and includes eight 4 Byte comparators. Groups of four bytes are multiplexed into the inputs of the comparators depending on the data format of the multi sample pixel. For example when the data format is 4BPP e.g. RGBA8 the 8 comparators perform comparisons for 8 dwords datawords where a dataword is 4 bytes 

If the data format of the multi sample pixel is 8BPP e.g. RGBA16F the comparisons may be arranged as follows 

An alternate embodiment filtering circuitry may be used to perform the comparisons. For example the Load Store Unit may implement MIN and MAX filtering modes that modes take a bilinear footprint four texels and rather than computing a weighted average are configured to compute a component wise minimum or maximum of the four texel values. In one embodiment the Load Store Unit includes a texture unit that is configured to perform texture operations. The texture unit may include at least four texels worth of comparators which can be be configured to perform equality comparisons as well as the MIN and MAX filtering mode operations. Similarly the Load Store Unit may support depth z comparison operations i.e. to compare sampled values against a shader provided reference value which may be used to perform comparisons for depth values.

In one embodiment the PPU includes an input output I O unit configured to transmit and receive communications i.e. commands data etc. from a central processing unit CPU not shown over the system bus . The I O unit may implement a Peripheral Component Interconnect Express PCIe interface for communications over a PCIe bus. In alternative embodiments the I O unit may implement other types of well known bus interfaces.

The PPU also includes a host interface unit that decodes the commands and transmits the commands to the grid management unit or other units of the PPU e.g. memory interface as the commands may specify. The host interface unit is configured to route communications between and among the various logical units of the PPU .

In one embodiment a program encoded as a command stream is written to a buffer by the CPU. The buffer is a region in memory e.g. memory or system memory that is accessible i.e. read write by both the CPU and the PPU . The CPU writes the command stream to the buffer and then transmits a pointer to the start of the command stream to the PPU . The host interface unit provides the grid management unit GMU with pointers to one or more streams. The GMU selects one or more streams and is configured to organize the selected streams as a pool of pending grids. The pool of pending grids may include new grids that have not yet been selected for execution and grids that have been partially executed and have been suspended.

A work distribution unit that is coupled between the GMU and the SMs manages a pool of active grids selecting and dispatching active grids for execution by the SMs . Pending grids are transferred to the active grid pool by the GMU when a pending grid is eligible to execute i.e. has no unresolved data dependencies. An active grid is transferred to the pending pool when execution of the active grid is blocked by a dependency. When execution of a grid is completed the grid is removed from the active grid pool by the work distribution unit . In addition to receiving grids from the host interface unit and the work distribution unit the GMU also receives grids that are dynamically generated by the SMs during execution of a grid. These dynamically generated grids join the other pending grids in the pending grid pool.

In one embodiment the CPU executes a driver kernel that implements an application programming interface API that enables one or more applications executing on the CPU to schedule operations for execution on the PPU . An application may include instructions i.e. API calls that cause the driver kernel to generate one or more grids for execution. In one embodiment the PPU implements a SIMD Single Instruction Multiple Data architecture where each thread block i.e. warp in a grid is concurrently executed on a different data set by different threads in the thread block. The driver kernel defines thread blocks that are comprised of k related threads such that threads in the same thread block may exchange data through shared memory. In one embodiment a thread block comprises 32 related threads and a grid is an array of one or more thread blocks that execute the same stream and the different thread blocks may exchange data through global memory.

In one embodiment the PPU comprises X SMs X . For example the PPO may include 15 distinct SMs . Each SM is multi threaded and configured to execute a plurality of threads e.g. 32 threads from a particular thread block concurrently. Each of the SMs is connected to a level two L2 cache via a Load Store unit and a crossbar or other type of interconnect network . The Load Store unit is configured to perform load and store operations received from the SM as previously described.

The L2 cache is connected to one or more memory interfaces . Memory interfaces implement 16 32 64 128 bit data buses or the like for high speed data transfer. In one embodiment the PPU comprises U memory interfaces U where each memory interface U is connected to a corresponding memory device U . For example PPU may be connected to up to 6 memory devices such as graphics double data rate version 5 synchronous dynamic random access memory GDDR5 SDRAM .

In one embodiment the PPU implements a multi level memory hierarchy. The memory is located off chip in SDRAM coupled to the PPU . Data from the memory may be fetched and stored in the L2 cache which is located on chip and is shared between the various SMs . The L2 cache may be replaced with the L2 cache . In one embodiment each of the SMs also implements an L1 cache. The L1 cache is private memory that is dedicated to a particular SM . Each of the L1 caches is coupled to the shared L2 cache . Data from the L2 cache may be fetched and stored in each of the L1 caches for processing in the functional units of the SMs .

In one embodiment the PPU comprises a graphics processing unit GPU . The PPU is configured to receive commands that specify shader programs for processing graphics data. Graphics data may be defined as a set of primitives such as points lines triangles quads triangle strips and the like. Typically a primitive includes data that specifies a number of vertices for the primitive e.g. in a model space coordinate system as well as attributes associated with each vertex of the primitive. The PPU can be configured to process the graphics primitives to generate a frame buffer i.e. pixel data for each of the pixels of the display . The driver kernel implements a graphics processing pipeline such as the graphics processing pipeline defined by the OpenGL API.

An application writes model data for a scene i.e. a collection of vertices and attributes to memory. The model data defines each of the objects that may be visible on a display. The application then makes an API call to the driver kernel that requests the model data to be rendered and displayed. The driver kernel reads the model data and writes commands to the buffer to perform one or more operations to process the model data. The commands may encode different shader programs including one or more of a vertex shader hull shader geometry shader pixel shader etc.

For example the GMU may configure one or more SMs to execute a vertex shader program that processes a number of vertices defined by the model data. In one embodiment the GMU may configure different SMs to execute different shader programs concurrently. For example a first subset of SMs may be configured to execute a vertex shader program while a second subset of SMs may be configured to execute a pixel shader program. The first subset of SMs processes vertex data to produce processed vertex data and writes the processed vertex data to the L2 cache and or the memory via the LoadStore units and the crossbar . After the processed vertex data is rasterized i.e. transformed from three dimensional data into two dimensional data in screen space to produce fragment data the second subset of SMs executes a pixel shader to produce processed fragment data which is then blended with other processed fragment data and written to the frame buffer in memory . The vertex shader program and pixel shader program may execute concurrently processing different data from the same scene in a pipelined fashion until all of the model data for the scene has been rendered to the frame buffer. Then the contents of the frame buffer are transmitted to a display controller for display on a display device.

The PPU may be included in a desktop computer a laptop computer a tablet computer a smart phone e.g. a wireless hand held device personal digital assistant PDA digital camera a hand held electronic device and the like. In one embodiment the PRI is embodied on a single semiconductor substrate. In another embodiment the PPU is included in a system on a chip SoC along with one or more other logic units such as a reduced instruction set computer RISC CPU a memory management unit MMU a digital to analog converter DAC and the like.

In one embodiment the PHI may be included on a graphics card that includes one or more memory devices such as GDDR5 SDRAM. The graphics card may be configured to interface with a PCIe slot on a motherboard of a desktop computer that includes e.g. a northbridge chipset and a southbridge chipset. In yet another embodiment the PPU may be an integrated graphics processing unit iGPU included in the chipset i.e. Northbridge of the motherboard.

In one embodiment the SM and Load Store unit are implemented within a GPU. In such an embodiment the Load Store unit comprises one or more texture units that are configured to load texture maps i.e. a 2D array of texels from the memory and sample the texture maps to produce sampled texture values for use in shader programs. The texture units implement texture operations such as anti aliasing operations using mip maps i.e. texture maps of varying levels of detail .

As described above the work distribution unit dispatches active grids for execution on one or more SMs of the PPU . The scheduler unit receives the grids from the work distribution unit and manages instruction scheduling for one or more thread blocks of each active grid. The scheduler unit schedules threads for execution in groups of parallel threads where each group is called a warp. In one embodiment each warp includes 32 threads. The scheduler unit may manage a plurality of different thread blocks allocating the thread blocks to warps for execution and then scheduling instructions from the plurality of different warps on the various functional units i.e. cores DPUs SFUs and LSUs during each clock cycle.

In one embodiment each scheduler unit includes one or more instruction dispatch units . Each dispatch unit is configured to transmit instructions to one or more of the functional units. In the embodiment shown in the scheduler unit includes two dispatch units that enable two different instructions from the same warp to be dispatched during each clock cycle. In alternative embodiments each scheduler unit may include a single dispatch unit or additional dispatch units .

Each SM includes a register file that provides a set of registers for the functional units of the SM . In one embodiment the register file is divided between each of the functional units such that each functional unit is allocated a dedicated portion of the register file . In another embodiment the register file is divided between the different warps being executed by the SM . The register file provides temporary storage for operands connected to the data paths of the functional units.

Each SM comprises L processing cores . In one embodiment the SM includes a large number e.g. etc. of distinct processing cores . Each core is a fully pipelined single precision processing unit that includes a floating point arithmetic logic unit and an integer arithmetic logic unit. In one embodiment the floating point arithmetic logic units implement the IEEE 754 2008 standard for floating point arithmetic. Each SM also comprises M DPUs that implement double precision floating point arithmetic N SFUs that perform special functions e.g. copy rectangle pixel blending operations and the like and P LSUs that implement load and store operations between the shared memory L1 cache and the register file . In one embodiment the SM includes 64 DPUs 32 SFUs and 32 LSUs .

Each SM includes an interconnect network that connects each of the functional units to the register file and the shared memory L1 cache . In one embodiment the interconnect network is a crossbar that can be configured to connect any of the functional units to any of the registers in the register file or the memory locations in shared memory L1 cache .

The PPU described above may be configured to perform highly parallel computations much faster than conventional CPUs. Parallel computing has advantages in graphics processing data compression biometrics stream processing algorithms and the like.

The system also includes input devices graphics processor and a display i.e. a conventional CRT cathode ray tube LCD liquid crystal display LED light emitting diode plasma display or the like. User input may be received from the input devices e.g. keyboard mouse touchpad microphone and the like. In one embodiment the graphics processor may include a plurality of shader modules a rasterization module etc. Each of the foregoing modules may even be situated on a single semiconductor platform to form a graphics processing unit GPU .

In the present description a single semiconductor platform may refer to a sole unitary semiconductor based integrated circuit or chip. It should be noted that the term single semiconductor platform may also refer to multi chip modules with increased connectivity which simulate on chip operation and make substantial improvements over utilizing a conventional central processing unit CPU and bus implementation. Of course the various modules may also be situated separately or in various combinations of semiconductor platforms per the desires of the user.

The system may also include a secondary storage . The secondary storage includes for example a hard disk drive and or a removable storage drive representing a floppy disk drive a magnetic tape drive a compact disk drive digital versatile disk DVD drive recording device universal serial bus USB flash memory. The removable storage drive reads from and or writes to a removable storage unit in a well known manner.

Computer programs or computer control logic algorithms may be stored in the main memory and or the secondary storage . Such computer programs when executed enable the system to perform various functions. The compiler program may be executed by the central processor or the graphics processor . The main memory the storage and or any other storage are possible examples of computer readable media.

In one embodiment the architecture and or functionality of the various previous figures may be implemented in the context of the central processor the graphics processor an integrated circuit not shown that is capable of at least a portion of the capabilities of both the central processor and the graphics processor a chipset i.e. a group of integrated circuits designed to work and sold as a unit for performing related functions etc. and or any other integrated circuit for that matter.

Still yet the architecture and or functionality of the various previous figures may be implemented in the context of a general computer system a circuit board system a game console system dedicated for entertainment purposes an application specific system and or any other desired system. For example the system may take the form of a desktop computer laptop computer server workstation game consoles embedded system and or any other type of logic. Still yet the system may take the form of various other devices including but not limited to a personal digital assistant PDA device a mobile phone device a television etc.

Further while not shown the system may be coupled to a network e.g. a telecommunications network local area network LAN wireless network wide area network WAN such as the Internet peer to peer network cable network or the like for communication purposes.

While various embodiments have been described above it should be understood that they have been presented by way of example only and not limitation. Thus the breadth and scope of a preferred embodiment should not be limited by any of the above described exemplary embodiments but should be defined only in accordance with the following claims and their equivalents.

