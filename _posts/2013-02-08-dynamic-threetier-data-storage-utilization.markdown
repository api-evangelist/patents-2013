---

title: Dynamic three-tier data storage utilization
abstract: A system for dynamically utilizing data storage comprises a processor and a memory. The processor is configured to determine whether a data storage criterion is satisfied; and, in the event that the data storage criterion is satisfied: determine a new archiving threshold based on a target data storage usage level; and set the archiving threshold. The memory is coupled to the processor and is configured to provide the processor with instructions.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09396131&OS=09396131&RS=09396131
owner: Workday, Inc.
number: 09396131
owner_city: Pleasanton
owner_country: US
publication_date: 20130208
---
Modern database systems can contain very large amounts of data. As storage costs decrease database systems take advantage of the easy availability of extra capacity storing more and more data that might not have previously been deemed worthwhile to keep. A database storage system that stores too much data in its online transactional systems can suffer performance degradation due to processing overhead. A common method of addressing this difficulty is to separate the data storage between two systems an online system that can access data more readily and an offline system that can store data without affecting the performance of the online system. When data from the offline system is required it is requested and transferred to the online system. Determining which data are important enough to store in the online system is a very taxing job for a system administrator and the division of data must be kept up to date as new data are added and usage patterns change.

The invention can be implemented in numerous ways including as a process an apparatus a system a composition of matter a computer program product embodied on a computer readable storage medium and or a processor such as a processor configured to execute instructions stored on and or provided by a memory coupled to the processor. In this specification these implementations or any other form that the invention may take may be referred to as techniques. In general the order of the steps of disclosed processes may be altered within the scope of the invention. Unless stated otherwise a component such as a processor or a memory described as being configured to perform a task may be implemented as a general component that is temporarily configured to perform the task at a given time or a specific component that is manufactured to perform the task. As used herein the term processor refers to one or more devices circuits and or processing cores configured to process data such as computer program instructions.

A detailed description of one or more embodiments of the invention is provided below along with accompanying figures that illustrate the principles of the invention. The invention is described in connection with such embodiments but the invention is not limited to any embodiment. The scope of the invention is limited only by the claims and the invention encompasses numerous alternatives modifications and equivalents. Numerous specific details are set forth in the following description in order to provide a thorough understanding of the invention. These details are provided for the purpose of example and the invention may be practiced according to the claims without some or all of these specific details. For the purpose of clarity technical material that is known in the technical fields related to the invention has not been described in detail so that the invention is not unnecessarily obscured.

Dynamic data storage utilization is disclosed. A system for adjusting an archiving threshold comprises a processor and a memory. The processor is configured to determine whether a first data storage criterion is satisfied and in the event that the first data storage criterion is satisfied determine a new first archiving threshold based on a first target usage level and set the first archiving threshold. The processor is additionally configured to determine whether a second data storage criterion is satisfied and in the event that the second data storage criterion is satisfied determine a new second archiving threshold based on a second target usage level and set the second archiving threshold. The memory is coupled to the processor and is configured to provide the processor with instructions.

Data in a database system is stored divided between three data storage units. A first data storage stores uncompressed data within a transactional server e.g. in randomly accessible memory RAM in a conventional hard drive in a solid state memory in a multi tiered memory etc. . A second data storage stores compressed data within the transactional server e.g. in RAM in a conventional hard drive in a solid state memory in a multi tiered memory etc. . In some embodiments the first data storage and the second data storage comprise a single data storage device. In some embodiments data objects are initially e.g. upon system startup stored as compressed objects in the second data storage. In some embodiments data objects are initially stored as compressed objects in the second data storage and as uncompressed objects in the first data storage. A third data storage stores compressed data within a data server e.g. in RAM in a conventional hard drive in a solid state memory in a multi tiered memory etc. . In some embodiments the third data storage stores all database system data. In some embodiments the third data storage stores only data with activity below a threshold.

The transaction server additionally comprises a transaction processing engine for processing transactions. The transaction processing engine comprises a local data storage for storing data during transaction processing. In some embodiments the local data storage comprises a temporary data storage. In some embodiments in the event that a data object is needed the data object is copied from the first data storage to the local data storage and provided for use in transaction processing using a processor of the database system. In some embodiments in the event that a data object is needed the data object is copied from the second data storage to the local data storage uncompressed and provided for use in transaction processing using a processor of the database system. In some embodiments in the event that a data object is needed the data object is copied from the third data storage to the local data storage uncompressed and provided for use in transaction processing using a processor of the database system. In some embodiments when transaction processing is complete it is determined that the data object is to be stored in uncompressed format in the first data storage. In some embodiments when transaction processing is complete it is determined that the data object is to be compressed and stored in the second data storage. In some embodiments when transaction processing is complete it is determined that the data object is to be compressed and stored in the third data storage. In some embodiments determining whether the data object is to be stored in uncompressed format in the first data storage to be compressed and stored in the second data storage or to be compressed and stored in the third data storage is performed using a keep threshold and an offloading threshold. In various embodiments a keep threshold comprises an activity threshold a performance threshold or any other appropriate threshold. In various embodiments an offloading threshold comprises an activity threshold a performance threshold or any other appropriate threshold. In some embodiments an activity threshold comprises a threshold based on a usage amount e.g. access per time period accesses per day accesses per hour etc. . In some embodiments a performance threshold comprises a threshold based on processing capability e.g. transactions completed per minute calculations per hour accesses per day etc. .

In some embodiments memory is reclaimed on the first data storage device. In some embodiments memory is reclaimed on the first data storage device using a first archiving threshold. In various embodiments a first archiving threshold comprises an activity threshold a performance threshold or any other appropriate threshold. In some embodiments the first archiving threshold is determined on the fly e.g. dynamically continuously periodically etc. . In some embodiments the first archiving threshold is determined in response to a data storage criterion being satisfied. In some embodiments determining whether a data storage criterion is satisfied comprises determining whether a server storage is above a threshold. In various embodiments determining whether a server storage is above a threshold occurs at one of the following continuously periodically at a fixed time at a regular interval or at any other appropriate time. A threshold data capacity e.g. an upper bound and a target data capacity e.g. optimum capacity or desired capacity utilization of a data storage less than the threshold data capacity for the first data storage are received e.g. specified by a user preset default set etc. .

In some embodiments if the threshold data capacity is reached data objects stored in the first data storage are analyzed. It is first determined how much data to remove from the first data storage to reach the target data capacity. It is then determined using the current usage patterns a first archiving threshold that will result in a sufficient number of data objects archived to remove the desired amount of data. In some embodiments determining the new first archiving threshold comprises determining a set of objects to remove to meet the target data storage usage level. For example each object is associated with an activity level and the objects are put in an ordered list by activity level. Either serially or in parallel for a given first archiving threshold the system determines the objects that are above the threshold and the storage space required to store those objects. The first archiving threshold that when selected would closest achieve the target data capacity is indicated to be selected. In some embodiments the first archiving threshold that when selected would achieve a memory usage just below the target data capacity is indicated to be selected. The first archiving threshold is then set to the new value. In various embodiments the first data storage is then processed to archive all data objects with activity below the first archiving threshold data objects are left on the first data storage when the first archiving threshold is changed and are archived at a predetermined time data objects are left on the first data storage when the first archiving threshold is changed and are archived when other processing activity is below a threshold or data objects are archived at any other appropriate time.

In some embodiments memory is reclaimed on the second data storage device. In some embodiments memory is reclaimed on the second data storage device using a second archiving threshold. In various embodiments a second archiving threshold comprises an activity threshold a performance threshold or any other appropriate threshold. In some embodiments the second archiving threshold is determined on the fly e.g. dynamically continuously periodically etc. . In some embodiments the second archiving threshold is determined in response to a data storage criterion being satisfied. In some embodiments determining whether a data storage criterion is satisfied comprises determining whether a server storage is above a threshold. In various embodiments determining whether a server storage is above a threshold occurs at one of the following continuously periodically at a fixed time at a regular interval or at any other appropriate time. A threshold data capacity e.g. an upper bound and a target data capacity e.g. optimum capacity or desired capacity utilization of a data storage less than the threshold data capacity for the second data storage are received e.g. specified by a user preset default set etc. .

In some embodiments if the threshold data capacity is reached data objects stored in the second data storage are analyzed. It is first determined how much data to remove from the second data storage to reach the target data capacity. It is then determined using the current usage patterns a second archiving threshold that will result in a sufficient number of data objects archived to remove the desired amount of data. In some embodiments determining the new second archiving threshold comprises determining a set of objects to remove to meet the target data storage usage level. For example each object is associated with an activity level and the objects are put in an ordered list by activity level. Either serially or in parallel for a given second archiving threshold the system determines the objects that are above the threshold and the storage space required to store those objects. The second archiving threshold that when selected would closest achieve the target data capacity is indicated to be selected. In some embodiments the second archiving threshold that when selected would achieve a memory usage just below the target data capacity is indicated to be selected. The second archiving threshold is then set to the new value. In various embodiments the second data storage is then processed to archive all data objects with activity below the second archiving threshold data objects are left on the second data storage when the second archiving threshold is changed and are archived at a predetermined time data objects are left on the first data storage when the second archiving threshold is changed and are archived when other processing activity is below a threshold or data objects are archived at any other appropriate time.

In some embodiments a performance metric is monitored e.g. continuously periodically etc. . Determining whether a data storage criterion is satisfied comprises determining whether a performance metric criterion is satisfied. A table or model is used to relate data storage usage and performance as measured by the metric. For example transaction processing rate data storage access time calculation speed of the system are related to data storage usage e.g. stored objects as a percentage of the first data storage total capacity . In the event that the performance metric dips below a performance threshold the system determines based on the model or table the data storage usage to achieve the target performance. The system indicates that this data storage usage is the new target and removes objects from the first data storage by archiving the objects to a second data storage or removes objects from the second data storage by archiving the objects to a third data storage. In some embodiments the objects are selected based on their activity level. In some embodiments objects are selected based on their last access time. In some embodiments objects are selected based on a combination of their last access time and activity level.

In some embodiments time is divided into N ticks . A tick does not necessarily map to a time period it could map to an amount of memory consumption for example if the difference between the lower and upper thresholds is 8 GB and we have 16 ticks then we could advance the tick each time 0.5 GB is consumed . In some embodiments time starts at tick 0. An object is marked with the last tick in which it was accessed. An access count is kept for the object and the last tick it was accessed in. The higher the tick value of an object the more recently it was accessed. An object has only 1 tick value at any time and that value will move only upwards. When cleaning up the tick value of each object is used to identify the objects more recently accessed to get us close to the reclaim target for example examining from tick 0 forward calculating how much memory reclaiming objects last accessed in that tick would reclaim. Once the segment is found which would push the system over the memory target that is being looked for the segment is examined and the threshold approach is applied using the access counts to first work out a threshold that would reclaim enough objects to satisfy the memory target and then use that threshold when reclaiming the objects. Future ticks after the one determined to provide enough reclaimed memory have no objects reclaimed and the tick values for those objects are reset to 0 and the cycle starts again.

Database system administrator comprises a database system administrator administrating database system . In some embodiments database system administrator comprises an employee at a company purchasing database system services. In some embodiments administrating database system comprises preparing configuring or modifying database system as desired by database system users e.g. database system user . In some embodiments database system administrator configures and modifies database system in ways not available to database system user . Database system user comprises a database user accessing database services on database system . In some embodiments database system user comprises a user who uses a user interface e.g. a keyboard a touch screen a display etc. to interact with database system . In various embodiments the user interface is associated with a desktop computer a laptop computer a local terminal or any other appropriate system with a user interface. In some embodiments database system user comprises an employee at a company purchasing database system services. In various embodiments there is are 1 2 4 13 22 115 or any other appropriate number of database system users accessing database services on database system . In some embodiments each database system user only has access to their own data stored on database system and is able to utilize database system as though they are the sole database system user. For example the system is a tenanted system where each tenant is only able to access their own data. In some embodiments a tenant or user associated with the tenant has access to tenant specific objects as well as universally or system accessible objects. In some embodiments database system user configures services on database system . In some embodiments the ability of database system user to configure database system is limited compared with that of database system administrator . In some embodiments a database system user e.g. database system user comprises a person accessing database system via a user interface e.g. a web page. In some embodiments a database system user comprises an automated system accessing database system via a machine interface e.g. a public application programming interface API .

Uncompressed data storage comprises data storage utilized by transaction processing engine for processing transaction requests. In some embodiments if a transaction request comprising a data request comprises a data request for data stored on uncompressed data storage transaction processing engine retrieves the requested data from uncompressed data storage and stores the data in local data storage . In some embodiments uncompressed data storage has unlimited capacity e.g. additional capacity can be added whenever the available capacity is filled . In some embodiments there is a practical limit to the capacity of uncompressed data storage e.g. past a certain capacity the performance of transaction processing engine falls to an unacceptable level . When there is a limit to the capacity of uncompressed data storage data exceeding the capacity of uncompressed data storage must be stored in another location.

Transaction server additionally comprises compressed data storage . Compressed data storage stores data in compressed format. In some embodiments compressed data storage comprises a backup or auxiliary copy of data stored in uncompressed data storage . In some embodiments compressed data storage can store data without the practical capacity limit of uncompressed data storage e.g. the amount of data stored in compressed data storage does not affect the performance of transaction processing engine . In some embodiments compressed data storage has unlimited capacity e.g. additional capacity can be added whenever the available capacity is filled . In some embodiments uncompressed data storage stores database data e.g. data accessed by transaction processing engine up to its practical capacity and compressed data storage stores overflow database data e.g. database data past the practical capacity of uncompressed data storage . In some embodiments there is a practical limit to the capacity of compressed data storage e.g. past a certain capacity the performance of transaction processing engine falls to an unacceptable level . When there is a limit to the capacity of compressed data storage data exceeding the capacity of compressed data storage must be stored in another location. In some embodiments compressed data storage stores all database data stored by database system and uncompressed data storage stores a subset of the data stored in compressed data storage . In some embodiments the subset of data stored in compressed data that is also stored in uncompressed data storage is a predetermined subset of data indicated e.g. by a list of data elements to store in uncompressed format. In some embodiments uncompressed data storage and compressed data storage store data as a collection of data objects. In some embodiments data objects stored in uncompressed data storage are stored in a data structure relating to their content e.g. in a tree graph or other appropriate data structure. In some embodiments data objects stored in compressed data storage are stored in a data structure optimized for efficient storage of a large number of data objects and not necessarily related to their content. In some embodiments when data objects requested by transaction processing engine are stored on compressed data storage but not on uncompressed data storage the data objects are requested from compressed data storage by transaction processing engine uncompressed and stored in local data storage .

Database system additionally comprises data server . Data server comprises offloaded data storage . In some embodiments offloaded data storage comprises a data storage for storing data. In some embodiments uncompressed data storage and compressed data storage store data up to their practical capacity and offloaded data storage stores overflow data e.g. data past the combined practical capacity of uncompressed data storage and compressed data storage . In some embodiments offloaded data storage comprises a backup or auxiliary copy of data stored in uncompressed data storage and compressed data storage . In some embodiments offloaded data storage can store data without the practical capacity limit of uncompressed data storage or compressed data storage e.g. the amount of data stored in offloaded data storage does not affect the performance of transaction processing engine . In some embodiments offloaded data storage has unlimited capacity e.g. additional capacity can be added whenever the available capacity is filled . In some embodiments offloaded data storage stores all database data stored by database system . In some embodiments offloaded data storage stores database data with activity below an activity threshold. In some embodiments data objects stored in compressed data storage are stored in a data structure optimized for efficient storage of a large number of data objects and not necessarily related to their content. In some embodiments when data objects requested by transaction processing engine are stored on offloaded data storage but not on compressed data storage or uncompressed data storage the data objects are requested from offloaded data storage by transaction processing engine uncompressed and stored in local data storage .

In some embodiments when the transaction processing engine needs data stored in offloaded data storage it is copied to local data storage decompressed and used. This is the swapping in of offloaded data for transaction processing. When transaction processing is complete the data either gets discarded again or if the data object usage is above the offloading threshold the data object is stored in compressed data storage .

In some embodiments when transaction processing is complete if the usage of a data object stored in local data storage is above a keep threshold the data object is stored in uncompressed data storage and deleted from local data storage . In some embodiments the data object is additionally deleted from compressed data storage . In some embodiments the data object is additionally deleted from offloaded data storage . In some embodiments the data object is not deleted from offloaded data storage . In some embodiments when transaction processing is complete if the usage of a data object stored in local data storage is below an offloading threshold the data object is stored in offloaded data storage and deleted from local data storage . In some embodiments when transaction processing is complete if the usage of a data object stored in local data storage is above an offloading threshold but below a keep threshold the data object is stored in compressed data storage and deleted from local data storage . In some embodiments when a system is initialized e.g. started up all database data is stored in compressed data storage and none is stored in uncompressed data storage and uncompressed data storage is filled as data objects are requested by transaction processing engine and found to have usage above the keep threshold. In some embodiments when a system is initialized e.g. started up a predetermined subset of data indicated e.g. by a list of data objects is transferred from compressed data storage to uncompressed data storage uncompressed and stored. In some embodiments when transaction processing is complete if the usage of a data object stored in local data storage is not above a keep threshold the data object is compressed and stored in compressed data storage and deleted from local data storage . In some embodiments when transaction processing is complete if the usage of a data object stored in local data storage is not above a keep threshold the data object is additionally deleted from uncompressed data storage . In some embodiments a keep threshold is based at least in part on an archiving threshold. In various embodiments a keep threshold comprises the number of times stored data was accessed in a given day a frequency of stored data access or any other appropriate activity threshold. In some embodiments a keep threshold is manually determined e.g. is set by a system designer or a system administrator e.g. database system administrator of . In some embodiments a keep threshold is set dynamically.

In some embodiments when a system is initialized e.g. started up offloaded data storage is empty and offloaded data storage is filled as data objects are requested by transaction processing engine and found to have below the offloading threshold. In some embodiments when a system is initialized e.g. started up offloaded data storage stores all database data. In some embodiments when a system is initialized e.g. started up offloaded data storage stores a predetermined set of database data.

In some embodiments data objects stored in compressed data storage comprise an indicator indicating whether after transaction processing is complete they should be left in uncompressed format and transmitted to uncompressed data storage compressed and transmitted to compressed data storage or compressed and transmitted to offloaded data storage . In some embodiments an indicator indicating whether data objects should be transmitted to uncompressed data storage compressed and transmitted to compressed data storage or compressed and transmitted to offloaded data storage once a transaction is complete is set based on a keep threshold and an offloading threshold.

When the system is configured e.g. by database system administrator of a storage threshold value and a storage target value are set for each of uncompressed data storage and compressed data storage . At predetermined intervals e.g. once an hour once a day once a week each time data is stored etc. it is determined whether uncompressed data storage has more data stored than the uncompressed storage threshold value. If it is determined that more data is stored than the uncompressed storage threshold value a new first archiving threshold is determined. A new first archiving threshold is determined by examining the activity of data objects stored in uncompressed data storage and setting the first archiving threshold such that enough data objects will be removed so the amount of data stored in uncompressed data storage will fall to the uncompressed storage target value. In some embodiments when the new first archiving threshold is determined data objects stored in uncompressed data storage are examined and any data object which has activity below the first archiving threshold is immediately removed from uncompressed data storage .

At predetermined intervals e.g. once an hour once a day once a week each time data is stored etc. it is determined whether compressed data storage has more data stored than the compressed storage threshold value. If it is determined that more data is stored than the compressed storage threshold value a new second archiving threshold is determined. A new second archiving threshold is determined by examining the activity of data objects stored in compressed data storage and setting the second archiving threshold such that enough data objects will be removed so the amount of data stored in compressed data storage will fall to the compressed storage target value. In some embodiments when the new second archiving threshold is determined data objects stored in compressed data storage are examined and any data object which has activity below the second archiving threshold is immediately removed from compressed data storage .

In some embodiments a server has metadata about objects. Some metadata is design time i.e. defining how a specific object should be handled in all cases etc. . Other metadata is runtime which is how we would track the access count for each data instance. So the server really has a bit of info about each data instance at runtime that tracks its access count.

In some embodiments when the first archive threshold is determined objects are or are not marked to be removed or not removed. In some embodiments the first archive threshold is compared against the current activity indicator on the object and as that is done the object is either removed or kept. In some embodiments there are two passes one to mark objects and the other to remove them. In some embodiments the first archive threshold comprises some simple numeric value. In some embodiments the first archive threshold comprises a combination of criteria e.g. most recently accessed least recently used access count access frequency etc. .

In some embodiments when the second archive threshold is determined objects are or are not marked to be removed or not removed. In some embodiments the second archive threshold is compared against the current activity indicator on the object and as that is done the object is either removed or kept. In some embodiments there are two passes one to mark objects and the other to remove them. In some embodiments the second archive threshold comprises some simple numeric value. In some embodiments the second archive threshold comprises a combination of criteria e.g. most recently accessed least recently used access count access frequency etc. .

In some embodiments the first and second archive thresholds are not stored. The first and second archive thresholds are dynamic values which have a one off use while clearing objects for a specific cleanup run. They do not persist and get used going forward. In some embodiments there are multiple thresholds at work. The first is a keep threshold at which we transition an object from compressed to being kept uncompressed the keep threshold this threshold may be adjusted after cleanup based on something like the time between cleanups move up or down to adjust towards a target time . There is additionally an offloading threshold at which we transition an object from compressed to being kept offloaded. Then there are the first and second archive thresholds which are calculated for recompression and offloading activities and then discarded. The first archive threshold could be used as an input when recalculating the keep threshold. The second archive threshold could be used as an input when recalculating the offloading threshold.

In it is determined whether a second data storage criterion is satisfied. In some embodiments determining whether a second data storage criterion is satisfied comprises determining whether the amount of data stored in a data storage exceeds a threshold. If it is determined that the second data storage criterion is not satisfied the process ends. If it is determined that the second data storage criterion is satisfied control passes to . In a new second activity threshold is determined based on a second target data storage usage level. In some embodiments the new second activity threshold comprises a second archiving threshold. In some embodiments the new second activity threshold comprises a offloading threshold. In some embodiments the second target data storage usage level comprises a compressed data storage level. In the second activity threshold is set e.g. the new second activity threshold is stored as the current second activity threshold .

Although the foregoing embodiments have been described in some detail for purposes of clarity of understanding the invention is not limited to the details provided. There are many alternative ways of implementing the invention. The disclosed embodiments are illustrative and not restrictive.

