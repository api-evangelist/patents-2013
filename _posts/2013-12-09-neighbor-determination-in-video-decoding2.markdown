---

title: Neighbor determination in video decoding
abstract: Video decoding innovations for multithreading implementations and graphics processor unit (“GPU”) implementations are described. For example, for multithreaded decoding, a decoder uses innovations in the areas of layered data structures, picture extent discovery, a picture command queue, and/or task scheduling for multithreading. Or, for a GPU implementation, a decoder uses innovations in the areas of inverse transforms, inverse quantization, fractional interpolation, intra prediction using waves, loop filtering using waves, memory usage and/or performance-adaptive loop filtering. Innovations are also described in the areas of error handling and recovery, determination of neighbor availability for operations such as context modeling and intra prediction, CABAC decoding, computation of collocated information for direct mode macroblocks in B slices, reduction of memory consumption, implementation of trick play modes, and picture dropping for quality adjustment.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09554134&OS=09554134&RS=09554134
owner: Microsoft Technology Licensing, LLC
number: 09554134
owner_city: Redmond
owner_country: US
publication_date: 20131209
---
This is a continuation of U.S. patent application Ser. No. 11 824 508 filed Jun. 30 2007 the disclosure of which is hereby incorporated by reference.

Companies and consumers increasingly depend on computers to process distribute and play back high quality video content. Engineers use compression also called source coding or source encoding to reduce the bit rate of digital video. Compression decreases the cost of storing and transmitting video information by converting the information into a lower bit rate form. Decompression also called decoding reconstructs a version of the original information from the compressed form. A codec is an encoder decoder system.

Compression can be lossless in which the quality of the video does not suffer but decreases in bit rate are limited by the inherent amount of variability sometimes called source entropy of the input video data. Or compression can be lossy in which the quality of the video suffers and the lost quality cannot be completely recovered but achievable decreases in bit rate are more dramatic. Lossy compression is often used in conjunction with lossless compression lossy compression establishes an approximation of information and the lossless compression is applied to represent the approximation.

A basic goal of lossy compression is to provide good rate distortion performance. So for a particular bit rate an encoder attempts to provide the highest quality of video. Or for a particular level of quality fidelity to the original video an encoder attempts to provide the lowest bit rate encoded video. In practice considerations such as encoding time encoding complexity encoding resources decoding time decoding complexity decoding resources overall delay and or smoothness in quality bit rate changes also affect decisions made in codec design as well as decisions made during actual encoding.

In general video compression techniques include intra picture compression and inter picture compression. Intra picture compression techniques compress a picture with reference to information within the picture and inter picture compression techniques compress a picture with reference to a preceding and or following picture often called a reference or anchor picture or pictures.

For intra picture compression for example an encoder splits a picture into 8 8 blocks of samples where a sample is a number that represents the intensity of brightness or the intensity of a color component for a small elementary region of the picture and the samples of the picture are organized as arrays or planes. The encoder applies a frequency transform to individual blocks. The frequency transform converts an 8 8 block of samples into an 8 8 block of transform coefficients. The encoder quantizes the transform coefficients which may result in lossy compression. For lossless compression the encoder entropy codes the quantized transform coefficients.

Inter picture compression techniques often use motion estimation and motion compensation to reduce bit rate by exploiting temporal redundancy in a video sequence. Motion estimation is a process for estimating motion between pictures. For example for an 8 8 block of samples or other unit of the current picture the encoder attempts to find a match of the same size in a search area in another picture the reference picture. Within the search area the encoder compares the current unit to various candidates in order to find a candidate that is a good match. When the encoder finds an exact or close enough match the encoder parameterizes the change in position between the current and candidate units as motion data such as a motion vector MV . In general motion compensation is a process of reconstructing pictures from reference picture s using motion data.

The example encoder also computes the sample by sample difference between the original current unit and its motion compensated prediction to determine a residual also called a prediction residual or error signal . The encoder then applies a frequency transform to the residual resulting in transform coefficients. The encoder quantizes the transform coefficients and entropy codes the quantized transform coefficients.

If an intra compressed picture or motion predicted picture is used as a reference picture for subsequent motion compensation the encoder reconstructs the picture. A decoder also reconstructs pictures during decoding and it uses some of the reconstructed pictures as reference pictures in motion compensation. For example for an 8 8 block of samples of an intra compressed picture an example decoder reconstructs a block of quantized transform coefficients. The example decoder and encoder perform inverse quantization and an inverse frequency transform to produce a reconstructed version of the original 8 8 block of samples.

As another example the example decoder or encoder reconstructs an 8 8 block from a prediction residual for the block. The decoder decodes entropy coded information representing the prediction residual. The decoder encoder inverse quantizes and inverse frequency transforms the data resulting in a reconstructed residual. In a separate motion compensation path the decoder encoder computes an 8 8 predicted block using motion vector information for displacement from a reference picture. The decoder encoder then combines the predicted block with the reconstructed residual to form the reconstructed 8 8 block.

Over the last two decades various video coding and decoding standards have been adopted including the 1 1.261 H.262 MPEG 2 and H.263 series of standards and the MPEG 1 and MPEG 4 series of standards. More recently the H.264 standard sometimes referred to as AVC or JVT and VC 1 standard have been adopted. For additional details see representative versions of the respective standards.

Such a standard typically defines options for the syntax of an encoded video bit stream according to the standard detailing the parameters that must be in the bit stream for a video sequence picture block etc. when particular features are used in encoding and decoding. The standards also define how a decoder conforming to the standard should interpret the bit stream parameters the bit stream semantics. In many cases the standards provide details of the decoding operations the decoder should perform to achieve correct results. Often however the low level implementation details of the operations are not specified or the decoder is able to vary certain implementation details to improve performance so long as the correct decoding results are still achieved.

During development of a standard engineers may concurrently generate reference software sometimes called verification model software or JM software to demonstrate rate distortion performance advantages of the various features of the standard. Typical reference software provides a proof of concept implementation that is not algorithmically optimized or optimized for a particular hardware platform. Moreover typical reference software does not address multithreading implementation decisions instead assuming a single threaded implementation for the sake of simplicity.

While some video decoding and encoding operations are relatively simple others are computationally complex. For example inverse frequency transforms fractional sample interpolation operations for motion compensation in loop deblock filtering post processing filtering color conversion and video re sizing can require extensive computation. This computational complexity can be problematic in various scenarios such as decoding of high quality high bit rate video e.g. compressed high definition video . In particular decoding tasks according to more recent standards such as H.264 and VC 1 can be computationally intensive and consume significant memory resources.

Some decoders use video acceleration to offload selected computationally intensive operations to a graphics processor. For example in some configurations a computer system includes a primary central processing unit CPU as well as a graphics processing unit GPU or other hardware specially adapted for graphics processing. A decoder uses the primary CPU as a host to control overall decoding and uses the GPU to perform simple operations that collectively require extensive computation accomplishing video acceleration.

In a typical software architecture for video acceleration during video decoding a video decoder controls overall decoding and performs some decoding operations using a host CPU. The decoder signals control information e.g. picture parameters macroblock parameters and other information to a device driver for a video accelerator e.g. with GPU across an acceleration interface.

The acceleration interface is exposed to the decoder as an application programming interface API . The device driver associated with the video accelerator is exposed through a device driver interface DDI . In an example interaction the decoder fills a buffer with instructions and information then calls a method of an interface to alert the device driver through the operating system. The buffered instructions and information opaque to the operating system are passed to the device driver by reference and video information is transferred to GPU memory if appropriate. While a particular implementation of the API and DDI may be tailored to a particular operating system or platform in some cases the API and or DDI can be implemented for multiple different operating systems or platforms.

In some cases the data structures and protocol used to parameterize acceleration information are conceptually separate from the mechanisms used to convey the information. In order to impose consistency in the format organization and timing of the information passed between the decoder and device driver an interface specification can define a protocol for instructions and information for decoding according to a particular video decoding standard or product. The decoder follows specified conventions when putting instructions and information in a buffer. The device driver retrieves the buffered instructions and information according to the specified conventions and performs decoding appropriate to the standard or product. An interface specification for a specific standard or product is adapted to the particular bit stream syntax and semantics of the standard product.

Given the critical importance of video compression and decompression to digital video it is not surprising that compression and decompression are richly developed fields. Whatever the benefits of previous techniques and tools however they do not have the advantages of the following techniques and tools.

In summary techniques and tools are described for various aspects of video decoder implementations. These techniques and tools help for example to increase decoding speed to facilitate real time decoding or to reduce computational complexity in scenarios such as those with processing power constraints and or delay constraints.

According to one aspect of the techniques and tools described herein a decoder receives a coded video bit stream including multiple pictures in serial coded order. The decoder decodes the multiple pictures with one or more central processing units CPUs and a graphics processing unit GPU . The CPU s perform multiple decoding operations e.g. picture extent discovery entropy decoding . The GPU performs multiple decoding operations e.g. intra prediction motion compensation loop filtering asynchronously from the multiple decoding operations performed by the CPU s . For a given picture the GPU can perform at least some of its decoding operations in parallel for multiple blocks with the given picture. The CPU s can generate tasks and insert them in a command buffer one at a time the GPU can extract primitives corresponding to the tasks and execute the primitives in serial order. The CPU s can also generate markers and insert them into a command buffer where a marker indicates completion of decoding of a corresponding picture the GPU can trigger the marker upon reaching the marker in the command buffer resulting in copying of the corresponding picture into an output buffer and marking it as available for reference in a decoded picture buffer.

According to another aspect a decoder receives a coded video bit stream that includes encoded video for multiple pictures in serial coded order. The decoder scans ahead in the bit stream to determine multiple resource usage patterns e.g. memory partitions image array slot assignments for the multiple pictures tracking the multiple resource usage patterns. The tracked patterns include at least some inconsistent resource usage patterns in flight during at least part of decoding. The decoder can also track commands for decoding operations in a command queue which represents the multiple resource usage patterns. The decoder performs decoding operations on the multiple pictures in serial coded order with a GPU.

According to another aspect a decoder organizes multiple blocks as multiple waves. Each of the multiple waves includes one or more of the blocks. For example the decoder groups as a first wave a first set of blocks having no dependencies on other blocks groups as a second wave a second set of blocks having no dependencies other than dependencies on the first set groups as a third wave a third set of blocks having no dependencies other than dependencies on the first and second sets and so on. The waves can de determined dynamically or statically. With a GPU the decoder performs decoding operations e.g. intra prediction loop filtering on the multiple blocks on a wave by wave basis. For at least one of the multiple waves the decoder with GPU processes blocks within the wave in parallel.

In other embodiments a decoder implements one or more of the innovations stated in the table at the end of the application.

The various techniques and tools can be used in combination or independently. Additional features and advantages will be made more apparent from the following detailed description of different embodiments which proceeds with reference to the accompanying figures.

The present application relates to innovations in implementations of video decoders. Many of these innovations reduce decoding complexity and or increase decoding speed to improve decoding performance. These innovations include 

For example in order to decode video in real time the decoding processes of a standard such as H.264 or VC 1 are analyzed to identify opportunities for algorithmic improvements. Specific examples of identified algorithmic improvements are described below. The decoding processes are also analyzed to identify opportunities for hardware specific performance improvements. Additional improvements for multithreading implementations further speed up the decoding processing and still other improvements help reduce memory consumption during decoding.

Collectively these improvements are at times loosely referred to as optimizations. As used conventionally and as used herein the term optimization means an improvement that is deemed to provide a good balance of performance in a particular scenario or platform considering computational complexity memory use processing speed and or other factors. Use of the term optimization does not foreclose the possibility of further improvements nor does it foreclose the possibility of adaptations for other scenarios or platforms.

Other innovations provide new decoder side features to improve the playback experience for end users. For example the present application describes efficient implementations for trick play modes e.g. fast forward fast rewind and recovery modes using picture dropping.

With these innovations efficient decoder implementations have been provided for diverse platforms. The implementations include media players for gaming consoles with complex special purpose hardware and graphics capabilities personal computers and set top boxes digital video receivers.

Various alternatives to the implementations described herein are possible. For example certain techniques described with reference to flowchart diagrams can be altered by changing the ordering of stages shown in the flowcharts by repeating or omitting certain stages etc. while achieving the same result. As another example although some implementations are described with reference to specific macroblock formats other formats also can be used. As another example while several of the innovations described below are presented in terms of H.264 AVC decoding examples the innovations are also applicable to other types of decoders e.g. MPEG 2 VC 1 that provide or support the same or similar decoding features.

The various techniques and tools described herein can be used in combination or independently. For example although flowcharts in the figures typically illustrate techniques in isolation from other aspects of decoding the illustrated techniques in the figures can typically be used in combination with other techniques e.g. shown in other figures . Different embodiments implement one or more of the described techniques and tools. Some of the techniques and tools described herein address one or more of the problems noted in the Background. Typically a given technique tool does not solve all such problems however. Rather in view of constraints and tradeoffs in decoding time and or resources the given technique tool improves performance for a particular implementation or scenario.

With reference to the computing environment includes at least one CPU and associated memory as well as at least one GPU or other co processing unit and associated memory used for video acceleration. In this most basic configuration is included within a dashed line. The processing unit executes computer executable instructions and may be a real or a virtual processor. In a multi processing system multiple processing units execute computer executable instructions to increase processing power. A host encoder or decoder process offloads certain computationally intensive operations e.g. fractional sample interpolation for motion compensation in loop deblock filtering to the GPU . The memory may be volatile memory e.g. registers cache RAM non volatile memory e.g. ROM EEPROM flash memory etc. or some combination of the two. The memory stores software for a decoder implementing one or more of the decoder innovations described herein.

A computing environment may have additional features. For example the computing environment includes storage one or more input devices one or more output devices and one or more communication connections . An interconnection mechanism not shown such as a bus controller or network interconnects the components of the computing environment . Typically operating system software not shown provides an operating environment for other software executing in the computing environment and coordinates activities of the components of the computing environment .

The storage may be removable or non removable and includes magnetic disks magnetic tapes or cassettes CD ROMs DVDs or any other medium which can be used to store information and which can be accessed within the computing environment . The storage stores instructions for the software .

The input device s may be a touch input device such as a keyboard mouse pen or trackball a voice input device a scanning device or another device that provides input to the computing environment . For audio or video encoding the input device s may be a sound card video card TV tuner card or similar device that accepts audio or video input in analog or digital form or a CD ROM or CD RW that reads audio or video samples into the computing environment . The output device s may be a display printer speaker CD writer or another device that provides output from the computing environment .

The communication connection s enable communication over a communication medium to another computing entity. The communication medium conveys information such as computer executable instructions audio or video input or output or other data in a modulated data signal. A modulated data signal is a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example and not limitation communication media include wired or wireless techniques implemented with an electrical optical RF infrared acoustic or other carrier.

The techniques and tools can be described in the general context of computer readable media. Computer readable media are any available media that can be accessed within a computing environment. By way of example and not limitation with the computing environment computer readable media include memory storage communication media and combinations of any of the above.

The techniques and tools can be described in the general context of computer executable instructions such as those included in program modules being executed in a computing environment on a target real or virtual processor. Generally program modules include routines programs libraries objects classes components data structures etc. that perform particular tasks or implement particular abstract data types. The functionality of the program modules may be combined or split between program modules as desired in various embodiments. Computer executable instructions for program modules may be executed within a local or distributed computing environment.

For the sake of presentation the detailed description uses terms like decide make and get to describe computer operations in a computing environment. These terms are high level abstractions for operations performed by a computer and should not be confused with acts performed by a human being. The actual computer operations corresponding to these terms vary depending on implementation.

For progressive video lines of a video frame contain samples starting from one time instant and continuing through successive lines to the bottom of the frame. An interlaced video frame consists of two scans one for the even lines of the frame the top field and the other for the odd lines of the frame the bottom field .

A progressive video frame can be divided into 16 16 macroblocks. For 4 2 0 format a 16 16 macroblock includes four 8 8 blocks Y0 through Y3 of luma or brightness samples and two 8 8 blocks Cb Cr of chroma or color component samples which are collocated with the four luma blocks but half resolution horizontally and vertically.

An interlaced video frame includes alternating lines of the top field and bottom field. The two fields may represent two different time periods or they may be from the same time period. When the two fields of a frame represent different time periods this can create jagged tooth like features in regions of the frame where motion is present.

Therefore interlaced video frames can be rearranged according to a field structure with the odd lines grouped together in one field and the even lines grouped together in another field. This arrangement known as field coding is useful in high motion pictures. For an interlaced video frame organized for encoding decoding as separate fields each of the two fields of the interlaced video frame is partitioned into macroblocks. The top field is partitioned into macroblocks and the bottom field is partitioned into macroblocks. In the luma plane a 16 16 macroblock of the top field includes 16 lines from the top field and a 16 16 macroblock of the bottom field includes 16 lines from the bottom field and each line is 16 samples long.

On the other hand in stationary regions image detail in the interlaced video frame may be more efficiently preserved without rearrangement into separate fields. Accordingly frame coding at times referred to coding with MBAFF pictures is often used in stationary or low motion interlaced video frames. An interlaced video frame organized for encoding decoding as a frame is also partitioned into macroblocks. In the luma plane each macroblock includes 8 lines from the top field alternating with 8 lines from the bottom field for 16 lines total and each line is 16 samples long. Within a given macroblock the top field information and bottom field information may be coded jointly or separately at any of various phases the macroblock itself may be field coded or frame coded.

The relationships shown between modules within the decoder indicate general flows of information in the decoder other relationships are not shown for the sake of simplicity. In particular while a decoder host performs some operations of modules of the decoder a video accelerator performs other operations such as inverse frequency transforms fractional sample interpolation motion compensation in loop deblocking filtering color conversion post processing filtering and or picture re sizing . For example the decoder passes instructions and information to the video accelerator as described in Microsoft DirectX VA Video Acceleration API DDI version 1.01 a later version of DXVA or another acceleration interface. In general once the video accelerator reconstructs video information it maintains some representation of the video information rather than passing information back. For example after a video accelerator reconstructs an output picture the accelerator stores it in a picture store such as one in memory associated with a GPU for use as a reference picture. The accelerator then performs in loop deblock filtering and fractional sample interpolation on the picture in the picture store.

In some implementations different video acceleration profiles result in different operations being offloaded to a video accelerator. For example one profile may only offload out of loop post decoding operations while another profile offloads in loop filtering fractional sample interpolation and motion compensation as well as the post decoding operations. Still another profile can further offload frequency transform operations. In still other cases different profiles each include operations not in any other profile.

Returning to the decoder processes video pictures which may be video frames video fields or combinations of frames and fields. The bit stream syntax and semantics at the picture and macroblock levels may depend on whether frames or fields are used. The decoder is block based and uses a 4 2 0 macroblock format for frames. For fields the same or a different macroblock organization and format may be used. 8 8 blocks may be further sub divided at different stages. Alternatively the decoder uses a different macroblock or block format or performs operations on sets of samples of different size or configuration.

The decoder receives information for a compressed sequence of video pictures and produces output including a reconstructed picture e.g. progressive video frame interlaced video frame or field of an interlaced video frame . The decoder system decompresses predicted pictures and key pictures. For the sake of presentation shows a path for key pictures through the decoder system and a path for predicted pictures. Many of the components of the decoder system are used for decompressing both key pictures and predicted pictures. The exact operations performed by those components can vary depending on the type of information being decompressed.

A demultiplexer receives the information for the compressed video sequence and makes the received information available to the entropy decoder . The entropy decoder entropy decodes entropy coded quantized data as well as entropy coded side information typically applying the inverse of entropy encoding performed in the encoder. A motion compensator applies motion information to one or more reference pictures to form motion compensated predictions of sub blocks blocks and or macroblocks of the picture being reconstructed. One or more picture stores store previously reconstructed pictures for use as reference pictures.

The decoder also reconstructs prediction residuals. An inverse quantizer inverse quantizes entropy decoded data. An inverse frequency transformer converts the quantized frequency domain data into spatial domain video information. For example the inverse frequency transformer applies an inverse block transform to sub blocks and or blocks of the frequency transform coefficients producing sample data or prediction residual data for key pictures or predicted pictures respectively. The inverse frequency transformer may apply an 8 8 8 4 4 8 4 4 or other size inverse frequency transform.

For a predicted picture the decoder combines reconstructed prediction residuals with motion compensated predictions to form the reconstructed picture . A motion compensation loop in the video decoder includes an adaptive deblocking filter . The decoder applies in loop filtering to the reconstructed picture to adaptively smooth discontinuities across block sub block boundary rows and or columns in the picture. The decoder stores the reconstructed picture in a picture buffer for use as a possible reference picture.

Depending on implementation and the type of compression desired modules of the decoder can be added omitted split into multiple modules combined with other modules and or replaced with like modules. In alternative embodiments encoders or decoders with different modules and or other configurations of modules perform one or more of the described techniques. Specific embodiments of video decoders typically use a variation or supplemented version of the generalized decoder .

For the sake of presentation the following table provides example explanations for acronyms and selected shorthand terms used herein.

In some embodiments a decoder uses one or more multithreading innovations when decoding video. Collectively the multithreading innovations efficiently find opportunities for parallel processing in the bit stream and support fine grained task scheduling in the decoding.

In contrast na ve implementations of the reference code for the H.264 standard are single threaded and synchronous. A decoder parses the bit stream for a picture initializes structures for the picture decodes the pictures and updates the decoded picture buffer then moves on to the next picture. This is inefficient for many modern architectures and impractical for many H.264 decoding scenarios.

Previous multithreading implementations provide coarse grained scheduling or only allow for parallel processing for entropy decoding. These implementations do not effectively look ahead in a bit stream to find other opportunities for parallel processing in decoding nor do they support finer grained scheduling for other types of operations.

This section describes flexible multithreading models that incorporate different multithreading implementations. A PED module finds complete pictures in a bit stream identifies opportunities for parallel processing and simulates a live DPB as in a single threaded implementation so as to help order picture commands. A picture command queue facilitates pipeline picture decoding potentially storing picture commands for pictures as those pictures are being decoded. A task scheduler distributes available tasks to different threads according to one of several available scheduling heuristics. An available task can process data for a picture slice or other segment collection of macroblocks . The multithreading models can be applied in a CPU GPU architecture multiple CPU architecture or multiple CPU GPU architecture.

The data structures used in multithreading are an important aspect of the overall design. In some embodiments a multithreaded decoder uses layered data structures as shown in . As shows the parameters of an encoded video bit stream are organized into layered hierarchical data structures generally according to their lifetime in the decoding process.

The Decoder structure stMSH264Decoder tag holds parameters and data structures for the decoder. These parameters and structures basically have the decoder s lifetime. For example it holds parameters and structures as follows.

The parameters in the Decoder structure can be accessed by working threads. The parameters are based upon for example sequence parameters and the parameters may change when a new SPS is processed.

A PictureHolder structure stPictureHolder tag holds temporary parameters for decoding a picture and references other structures used in decoding the picture. Once a picture is decoded some of the temporary picture parameters may be discarded. The decoded sample data for the picture along with certain parameters used for reference purposes are stored in a StorablePicture structure . For example the picture parameters are divided into several categories. Pointers that point to live instances in decoder structure include pstStorablePicPool pstMBOffsetTableVar pstMBOffsetTableMBAFFVar and pPPS. Cache pointers that point to the real memories inside StorablePicture include imgY imgUV pcRefldx1 pnMv0. Picture parameters for the picture in PictureHolder include PicWidthInMbs field pic flag bottom used forreference. The buffers arrays are shared by different slices in the picture these may be compressed buffer pointers stream buffer pointers slice parameter arrays rgSliceOpt macroblock arrays mb data opt . A SliceHolder Xarray holds all the Sliceholders in this picture.

A StorablePicture structure holds decoded pixel data side information and parameters for a reference picture and DPB management. The lifetime of a StorablePicture structure is different from that of a PictureHolder structure . A PictureHolder structure for a picture can be deallocated when the picture is decoded since the parameters in the PictureHolder structure are used for decoding. The parameters and data in a StorablePicture structure are valid until the corresponding picture is deleted from the decoder. For example the StorablePicture structure stores decoded picture data imgY imgUV ref idx pnMv0 which are used for the purpose of reference. It also stores DPB management parameters frame num long term pic num non existing. The values of these DPB parameters can be changed during DPB management. A private copy is stored in a PictureHolder structure for some DPB management parameters if the parameters are needed for the decoding of the picture itself. For example frame used for reference top used for reference . . . are the private copies of used for reference. The StorablePicture stricture also stores time stamp and display parameters e.g. uiAspectRatio bPicStructPresentFlag timeStampFlag bIsDiscontinuity and parameters used for picture skipping e.g. bSkipDecodingPicture bIPicture bBPicture .

A SliceHolder structure stSliceHolder tag holds the temporary parameters buffers and arrays for the decoding of one slice. Once the slice is decoded the parameters in this structure can be de allocated. For example a SliceHolder structure stores slice parameters e.g. start mb nr iSliceType current slice nr buffers e.g. pintraMBPosLevelBase pcITransBuffers and arrays e.g. mvscale listX listXsize .

A macroblock structure macroblock opt holds the temporary parameters to decode one macroblock. A PictureHolder structure holds macroblock structures for the macroblocks inside a picture. In some implementations the macroblock structure is highly compressed in that empty space in certain bytes is avoided by assigning different meanings to different bits within the bytes.

Alternatively the decoder uses different data structures for multithreading. For example the decoder uses data structures with other and or additional parameters or data.

In some embodiments a multithreaded decoder uses different code paths for different picture formats. For example an H.264 decoder includes different code paths for PROG pictures PICAFF pictures and MBAFF pictures. The following table shows different picture formats for different combinations of the parameters frame mbs only flag mb adaptive frame field flag and field pic flag for an H.264 decoder.

The PROG path processes pictures of format A the PICAFF path processes pictures of format B or C and the MBAFF path processes pictures of format D or E. The H.264 decoder also supports two different kinds of entropy encoding CABAC and CAVLC. Since different picture formats often use different optimization techniques the decoding process for different picture formats is separated into different code paths i.e. PROG code path PICAFF code path and MBAFF code path. In each code path entropy decoding can be CABAC or CAVLC.

In some embodiments a multithreaded decoder separates decoding processes into tasks as follows. shows stages of decoding for one picture in some implementations. The stages include a picture extent discovery PED stage for finding and initializing complete pictures an entropy decoder ED stage for entropy decoding transform coefficients motion vectors and other side information with CABAC decoding or CAVLC decoding a motion vector setup MV setup stage for reconstructing motion vectors in PB or B pictures a motion compensated prediction MC stage for reconstructing inter coded content using motion compensation an intra prediction INTRA stage for reconstructing intra coded content using spatial intra prediction and a loop filtering LF stage for performing deblock filtering and other processing on decoded pictures. Not all pictures are decoded with all stages. For example the MC stage is not used for I pictures and the INTRA stage is not used when decoding some P pictures.

Alternatively the decoder partitions decoding processes into other and or different stages for example by combining smaller tasks into larger ones. For example for some architectures the decoder puts decoding processes for MC INTRA and LF into a single task. Or a post processing stage POST is used for processing such as the addition of film grain noise to pictures before display.

In some embodiments a multithreaded decoder uses modules that facilitate multithreading by finding opportunities for fine grained parallel processing. For example for some implementations of H.264 decoders aside from the modules conventionally used for decoding these modules include a picture extent discovery module a picture command queue management module and a task scheduler.

The PED module finds a complete picture from the bit stream and initializes the parameters and data structures that will be used for decoding the picture. The PED module populates some of the initialized parameters and structures with parameters parsed from the bit stream. The PED module also enters the initialized but as yet un decoded picture into a live DPB which facilitates multithreaded decoding.

The picture command queue module manages picture commands such as output commands and delete commands which are stored in a command queue e.g. a FIFO queue . DPB management routines e.g. in the PED module produce picture commands associated with a dependent picture which is an initialized but un decoded picture in the DPB. When the dependent picture is decoded the associated commands for the picture can be executed. The command queue thus records commands associated with completion of decoding for the dependent picture and the commands are executed when the dependent picture is decoded which facilitates simulation of a live DPB from a typical single threaded decoding scenario.

When a working thread is ready out of waiting sleep state the task scheduler finds a ready task runs the ready task with the working thread updates the dependency graph on the completion of the task puts ready tasks into a ready queue and returns. To find the ready task the scheduler can use a task dependency graph that facilitates fine grained multithreading or some other threading model s dependent on the decoder settings.

Video decoding according to recent standards e.g. H.264 VC 1 can be too computationally intensive for a single hardware thread. In particular processes like CABAC and loop filtering can be performance bottlenecks.

In some embodiments a decoder includes a PED module that parses encoded video bit streams to discover segments e.g. groups of macroblocks slices pictures that can be independently decoded. For example the PED module finds picture boundaries and logs data in a lightweight look ahead process initializing parameters and data structures for pictures encountered in the bit stream thereby providing a snapshot of upcoming segments and their dependencies that a task scheduler and DPB manager can use in multithreaded decoding. The look ahead process is intrinsically serial in that the decoder traverses the serial encoded video bit stream but it results in the identification and organization of elements that can be decoded in parallel.

For a given picture the decoder e.g. a PED module in the decoder parses parameters for the picture from the encoded video bit stream. For example the decoder parses SPS PPS picture layer and slice layer parameters for the picture. Alternatively the decoder parses other and or additional parameters from the bit stream.

The decoder initializes structures for holding parameters and data for the picture. For example the decoder allocates memory and creates layered data structures for the picture as described above including data structures for the picture and one or more slices in the picture. The decoder can populate at least some of the data structures with parameters parsed from the bit stream. For other structures the decoder just creates placeholders for later defined values at the PED stage it may suffice to determine which pictures are going to be decoded and determine what the values of certain parameters are without referencing all pixel data. Alternatively the decoder initializes other structures for the picture.

The decoder also tracks dependencies for the picture. For example the decoder identifies and logs stages of decoding for the picture that depend on the completion of other stages of decoding for the picture or that depend on the completion of stages of decoding for other pictures. The decoder tracks the dependencies for example in a task dependency graph that includes as nodes decoding tasks for segments of the picture and other pictures and includes as edges the dependencies between tasks. Dependencies can be logged on a picture by picture basis slice by slice basis segment by segment basis or other basis for example decided by the threading model. Alternatively the decoder tracks dependencies using another type of tracking structure.

The decoder determines whether to continue with the next picture or end. If the decoder continues it parses parameters for the next picture. For multithreaded decoding the decoder typically scans ahead in the bit stream for multiple pictures before decoding begins for the scanned pictures. In this way the decoder can more efficiently use available processing resources and make more informed task scheduling decisions. In some implementations the decoder can have as many as 16 or 32 pictures in flight in various stages of decoding before output of those pictures.

The timing and aggressiveness of PED depends on implementation. In some cases a PED module when it executes tries to fill as many structures for pictures as possible up to a limit set for the PED module. The PED is blocked if the PED outputs are full or there is no input available for scanning.

Standards such as the H.264 standard may specify rules for the behavior and state of the DPB but typically do not detail how the DPB should be managed. In fact the standards and reference implementations assume changes to the DPB on a picture by picture basis with updates occurring in serial order.

In some embodiments the decoder e.g. the PED module plays a role in DPB management for multithreaded decoding. The decoder emulates a live DPB that behaves as in the simple single threaded situation. The decoder simulates decoding of pictures which would potentially update the DPB by entering initialized but as yet un decoded pictures into the DPB. The decoder inputs commands in a picture command queue uses to track completion of decoding tasks. A picture command in the queue associates a condition e.g. decoding of a particular picture with an action e.g. output of a picture from the DPB deletion of a picture from the DPB .

For example the decoder populates the picture command queue during PED. The decoder puts one or more picture commands in a picture command queue. Each of the picture commands has an associated condition and an action. For example the associated condition is completion of decoding of a particular picture whether successful or not and the action is to output or delete a picture from the DPB. An output picture is a picture to be displayed. When a picture is deleted tables parameters and other structures for the picture are removed from memory.

Alternatively the decoder uses a different data structure to track picture commands. For example a node of the queue corresponds to a condition e.g. completion of decoding of a particular picture and the node stores a single action to be performed upon satisfaction of the condition e.g. output one picture or delete one picture . With this structure the queue shown in would have 10 nodes one for each action. A node for Iwould have one output action associated with it and seven nodes for Pwould have seven actions associated with them respectively. Or the decoder uses queue nodes with other and or different fields.

In some embodiments the decoder uses a picture command queue to record and execute picture commands in decoding order. The picture command queue facilitates complex DPB management in multithreaded decoding with efficient use of memory and correct output of decoded pictures even though decoding may occur in parallel and finish for pictures in an order different than the coded bit stream order.

In conventional single threaded decoding the decoder timing is to traverse the bit stream for a picture decode the picture then put the picture in the DPB for output. When a decoded picture enters the DPB depending on the parameters in the input picture DPB management routines decide which picture s to output and which picture s to delete from the current DPB. The DPB is effectively a black box with input and output only. When the decoded picture enters the DPB as input the management routines can produce two types of commands output picture s and delete picture s .

For example when the input decoded picture is an instantaneous data refresh IDR picture all the pictures in the current DPB are output and deleted. Or according to reference implementations of the H.264 standard when the MMCO parameter is equal to 5 for the input decoded picture all the pictures in the current DPB are output and deleted. Generally if the decoder uses a bumping scheme for picture output the not yet output picture with smallest value of PicOrderCnt is output from the current DPB if the DPB is already full and any already output picture s marked as not used for reference are deleted from the current DPB.

The output and delete commands in the picture command queue for multithreaded decoding have similar meanings but the commands also have conditions e.g. decoding of particular pictures associated with them.

In multithreaded decoding pictures are not necessarily decoded in the coded order they appear in the bit stream. Pictures later in coded order might actually be decoded first. Simply entering decoded pictures into the DPB in the order of their actual decoding can cause problems when the pictures are not entered in coded order for example due to execution of DPB commands like output and delete in the wrong order.

So in some embodiments a decoder simulates the behavior of a live DPB with decoded pictures in it by entering initialized pictures in the DPB where the initialized pictures are not necessarily decoded. The decoder e.g. as part of PED scans ahead in the bit stream considering certain picture parameters for pictures but not sample data or side information such as motion vector information or reference picture identifier information for the pictures. The decoder allocates memory and creates data structures for a picture perhaps populating the picture with certain parameters then enters the initialized picture into the DPB in its correct coded order. Thus the decoder finds complete pictures which are initialized with parameters but not decoded and enters them in the DPB. Typically an initialized picture has its picture header and slice header parameters correctly decoded from the bit stream as part of PED but sample data and side information are not yet decoded.

The decoder can also record picture commands associated with the future completion of decoding of an initialized picture. The decoder records the commands for example in a FIFO queue such as the queue shown in . The decoder executes the commands in the queue when the conditions here the completion of decoding for the initialized pictures associated with the commands have been completed. The commands thus execute in correct order as set during PED but the execution of the picture commands may be blocked at times to wait for decoding to complete.

The decoder decodes a picture then checks a queue for picture commands that can be executed. The decoder determines whether a command is ready e.g. if the condition for the command at the head of the queue has been satisfied and if so removes the command from the queue executes the command and checks determines whether another command is ready.

A working thread for the LF task performs deblocking as the last part of decoding for a picture and determines whether there are any picture commands in the FIFO queue whose condition is completion of decoding for the just decoded picture. If so the working thread for the LF task executes the command s . Thus when a thread finishes the decoding for a dependent picture any commands associated with the dependent picture in the FIFO queue can be executed. The commands are executed in FIFO order. If decoding has not finished for a previous dependent picture represented in the FIFO queue the commands for a current dependent picture are not executed even if decoding has already finished for the current dependent picture.

Commands are put in the FIFO queue in the order pictures have in the bit stream regardless of the threading model. Although the command ordering is serial decoding can be in parallel for multithreaded decoding. As a result picture command execution can be blocked at a particular point in the FIFO queue pending completion of decoding of a dependent picture at that point.

In addition to recording output and delete commands associated with the completion of decoding for pictures the command queue can store other types of commands. For example in some implementations the command queue also stores commands associated with changes in SPS or PPS. When a SPS or PPS changes the associated action can be for example table re initialization for tables used in decoding pool re allocation for memory or commands on a parameter set map database. In general the commands are put in the FIFO queue in the serial order that the coded video bit stream provides for the commands. The decoder e.g. PED module puts the commands in the FIFO queue without executing the commands or waiting for completion of the conditions. The commands are later executed for example during multithreaded decoding when the conditions are satisfied.

In some embodiments a decoder organizes tasks using a task dependency graph and schedules execution of the tasks in multithreaded decoding.

To build the graph the decoder analyzes dependencies between past and current pictures. The decoder performs this analysis for example during PED. The decoder notes dependencies between stages of decoding for the pictures. In general a stage of decoding is a set of operations or steps performed to decode a picture or part of a picture for example PED ED MC INTRA LF or POST. In some implementations the decoder logs dependencies between segments where a segment is a group of macroblocks for part of a slice for a slice for parts of multiple slices for multiple slices or for a picture. Thus picture by picture dependencies and slice by slice dependencies are special cases of segment by segment dependencies.

Within a picture ED including CABAC is typically parallelizable from slice to slice which facilitates multithreaded decoding. A slice is not split into multiple segments for ED but a segment may include multiple slices for ED. After ED there may be inter picture dependencies for operations such as MC which relies on previously decoded reference pictures. Typically macroblocks can be segmented in arbitrary ways for MC stages. For LF a segment typically includes one slice. Overall the segmentation decision for macroblocks in a picture can be the same from stage to stage of decoding or the segmentation decisions can vary from stage to stage.

The decoder identifies dependencies for segments. For example the decoder identifies the dependencies for segments of a picture during a lightweight scan through the coded video bit stream as part of PED. Alternatively the decoder identifies dependencies using a different scanning mechanism.

The decoder then organizes the one or more segments regardless of slice boundaries. For example within a picture the decoder groups intra coded macroblocks together in a segment. In another picture the decoder groups motion compensated macroblocks that use the same reference picture together as one segment and the decoder groups motion compensated macroblocks that use a different reference picture together as a second segment.

The decoder then assimilates tasks for the segment s into a task dependency graph. For example the decoder builds a task dependency graph such as the one shown in for picture by picture dependencies. Or the decoder builds a task dependency graph with tasks for slices or more generally segments for nodes. In building the task dependency graph the decoder consider dependencies between different stages for the same segment e.g. INTRA depends on ED MC depends on ED LF depends on MC LF depends on INTRA and dependencies between stages for different segments e.g. INTRA for segment may depend on INTRA for segment in the same picture MC for segment may depend on LF for segment in another picture . Dependencies can be intra picture dependencies or inter picture dependencies.

The decoder determines whether to continue with the next picture and if so identifies dependencies for the next picture.

In some implementations graph nodes represent segments. If a picture has 8000 macroblocks the macroblocks might be organized as four segments for parallelization in multithreaded decoding. If decoding is split into 6 stages e.g. PED ED INTRA MC LF and POST and there are 15 20 pictures in flight at various stages of decoding the task dependency graph can easily include hundreds of nodes which facilitates fine grained scheduling of multithreaded decoding.

In some implementations the task dependency graph is organized as a set of nodes. A node structure has a counter that indicates how many task dependencies the node s task has. The counter is incremented or decremented when a task dependency is added or completed removed . For example a node structure for the MC for Picture task of would have a counter 3 then the counter would be decremented as the LF for picture ED for picture and LF for picture tasks complete. A node structure also has an expandable list of its dependencies. For example the node structure for the MC for Picture task of has one dependency in its list LF for picture . Dependencies are added to the list when noted during PED. When a task completes the task s dependent on the completion are notified with counter s for those task s being decremented. For example when the MC for Picture task of completes the counter for the node structure for the LF for picture task is decremented. When the dependency counter is zero for a task during decoding the task is put in the ready task list for scheduling. Alternatively the node structure for tasks in the task dependency graph includes other and or additional fields.

The decoder then schedules tasks for decoding using the task dependency graph. In implementations in which the graph nodes include dependency counters the decoder adds a task to a list of ready tasks when the dependency counter for the task reaches zero. During multithreaded decoding the decoder selects tasks from the ready list according to one or more heuristic approaches. For example the heuristic approach is 

 d number of dependencies on tasks task with most dependencies on it executes first such that completion of the task potentially unblocks more other tasks in the graph or

 e shortest critical path from task to output tasks that put pictures close to output are executed first.

In some embodiments a decoder includes special mechanisms for handling decoding of a corrupted bit stream or starting decoding from an arbitrary location in a bit stream. For example according to one recovery mechanism the decoder during PED finds a valid picture to start decoding after corruption of part of an encoded video bit stream or to start decoding from an arbitrary location indicated in the encoded video bit stream. According to another recovery mechanism the decoder during PED handles corrupted parameters in a slice header and attempts to recover. According to another recovery mechanism the decoder handles errors in other decoding stages e.g. ED MC INTRA LF . The mechanisms can be used in combination or separately. Collectively the mechanisms improve the robustness of decoding for bit streams that have a high probability of becoming corrupted.

An IDR picture is a valid starting point for decoding the pictures after an IDR picture do not reference pictures before the IDR picture for motion compensation. An IDR picture typically begins a video sequence but IDR pictures may be rare after that. For some applications IDR pictures appear only once per chapter of video or only once every 30 seconds in a sequence. When trying to start decoding from an arbitrary location in the bit stream there might not be an IDR picture for several seconds or even minutes. As a result while waiting for an IDR picture downloaded bits may be wasted or reasonable quality pictures may be skipped.

Therefore in some embodiments as part of a recovery mechanism a decoder e.g. a PED module seeks an I picture at which to start decoding as if the I picture were an IDR picture. An I picture is intra coded it includes I slices but not P slices or B slices.

To start the decoder finds a picture in the encoded video bit stream. For example a PED module of the decoder parses a NALU from the bit stream where the NALU is for a complete picture then initializes structures for parameters and data for the picture. Alternatively the decoder finds the picture using another mechanism.

The decoder determines whether the picture is an I picture. If not the decoder cleans up the picture. For example the decoder removes any picture commands put in a picture command queue for the picture and releases memory used for structures for the picture.

If the picture is an I picture the decoder schedules decoding for the picture. For example the decoder puts an initialized picture in the DPB puts picture commands for the picture in a picture command queue and assimilates one or more tasks for the picture into a task dependency graph for multithreaded decoding.

The decoder continues the technique until it finds a valid I picture or IDR picture in the bit stream. In some implementations a flag bFirstTimeSeek indicates whether the decoder should perform the technique . At the start of decoding or when recovering from an error bFirstTimeSeek is TRUE. When the flag is TRUE a PED module in the decoder finds a complete picture and checks whether the picture is an I picture. If the picture is an I picture the PED module sets the flag bFirstTimeSeek to be FALSE and decoding starts from the I picture. Otherwise the PED module continues trying to find an I picture.

Even after an I picture is found there may be errors in decoding starting from the I picture. For example macroblocks of later B pictures in coded order may reference pictures from before the I picture. Or macroblocks of a later P picture may reference by remote prediction pictures that are currently unavailable. Or there may be parts of the bit stream that are corrupted after the I picture. Some of the errors may be ignored or concealed e.g. errors in frame num gap reference pictures being unavailable . Other errors can require that a picture or part thereof be treated as corrupted however.

In some implementations a decoder handles errors differently depending on whether they are identified during a PED stage or during another decoding stage. When the decoder catches the error during a PED stage the decoding processes the error by cleaning up the picture in question and skipping decoding of the picture or just skipping decoding of the picture depending on the type of error. If the error occurs during another stage the decoder processes the error using another error handling mechanism such as skipping decoding of the affected part e.g. slice but decoding other parts or concealing the error in the affected part.

The decoder catches an error and determines whether or not the error is fatal. If the PED error is a fatal error e.g. an out of memory error the decoder cleans up the corrupted picture. For example the decoder cleans up any commands in a picture command FIFO queue that are dependent on the corrupted picture and the decoder releases memory for the structures for the picture back to a memory pool. The decoder also closes since the error was fatal.

If the PED error is not fatal the decoder determines whether the current picture can successfully be entered into the DPB as an initialized picture. Some types of errors in slice headers cause errors in DPB management routines preventing successful handling of the picture in the DPB. Other types of slice header errors do not interfere with DPB processing however.

If the initialized picture successfully enters the DPB the decoder enters the picture in the DPB but marks the picture as skipped. In some implementations the decoder marks the corrupted picture as skipped by setting a flag bSkipDecodingPicture TRUE. The decoder leaves the corrupted picture inside the DPB but decoding of it is skipped and it is processed like a skipped picture. For example the decoder causes display of a picture at the correct time for the corrupted picture by repeating the display of another picture. Alternatively the decoder handles skipped pictures in another way.

If the initialized picture does not successfully enter the DPB the decoder cleans up the corrupted picture. For example the decoder cleans up any commands in a picture command FIFO queue that are dependent on the corrupted picture and the decoder releases memory for the structures for the picture back to a memory pool. Sometimes the PED module finds an error in slice header parameters that prevents DPB processing so the whole picture is treated as corrupted and not entered in the DPB even if other slices in the picture are decodable.

After the decoder processes a non fatal PED error the decoder continues by processing the next picture in coded order. The decoder continues until it finds a valid error free picture reaches the end of the encoded video bit stream or encounters a fatal error.

When the decoder encounters an error during a non PED task e.g. ED MC INTRA or LF the decoder marks the slice including the error as corrupted and performs error handling for it. For example the decoder simply skips decoding of the slice but decodes other slices in the picture. Or the decoder skips decoding of the slice and attempts to conceal the error using other decoded content. If the picture is decoded with a GPU that operates on whole pictures however the picture including the corrupted slice is skipped.

In some embodiments a decoder uses table based mechanisms to determine the availability of neighboring macroblocks blocks and sub blocks during decoding. The table based neighbor availability determinations described herein especially when used with state machine transitions are both memory efficient and fast.

For many standards decoding an encoded video bitstream uses availability and location information about neighboring macroblocks sub macroblocks blocks and sub blocks. Neighbor availability decisions affect numerous decoding operations. For example in H.264 decoding the decoder considers neighbor context in setting up context for entropy decoding with CABAC entropy decoding with CAVLC spatial intra prediction and mode computation for intra prediction. Neighbor availability determinations may also be made as part of in loop deblock filtering motion vector prediction and other operations.

Despite the prevalence of the operations the H.264 standard specifies complex logic for determining available neighbors and neighbor positions. The logic is relatively slow often resulting in inefficient memory switching. The reference software also provides unsatisfactory performance for neighbor availability and position determinations.

In contrast table based neighbor determination mechanisms described herein are efficient and fast. A decoder reuses tables that are pre computed or computed a small number of times during a decoding session. The tables typically have a small memory footprint and the table lookup operations are relatively fast.

This section presents techniques for using table based neighbor availability determinations during decoding. A decoder such as the one described with reference to or other decoder performs one or more of the techniques.

In hierarchical approaches the decoder gets tables that drill down from macroblock neighbor availability information to sub macroblock neighbor availability information. For example for a progressive picture or field picture the decoder gets a first availability table indicating different macroblock or macroblock pair neighbor patterns and gets a second availability table indicating different sub macroblock e.g. block sub block neighbor patterns. Certain tables can be pre determined for certain configurations of video. Or where the same table is reused throughout decoding the decoder can compute the tables during initialization for a decoding session.

The decoder then uses the one or more tables to determine neighbor availability during decoding. For example the decoder uses the tables as described in the example implementations section. Alternatively the decoder uses the tables in different ways.

The way the decoder uses the tables can depend on whether the picture being decoded is a progressive picture field picture or MBAFF picture generally an interlaced frame with field frame coding decisions within the frame . For example for a progressive picture or field non MBAFF picture in some embodiments the decoder uses a first table to determine macroblock neighbor availability. For a MBAFF picture the decoder uses a first table to determine macroblock pair neighbor availability. The decoder then determines sub macroblock neighbor availability using a second table.

When the decoder sets up a state machine the decoder can use the state machine to quickly determine macroblock or macroblock pair information. shows a generalized technique for using a state machine and one or more tables to determine neighbor availability during decoding of a progressive or field picture.

To start the decoder gets two tables indicating availability relationships between macroblocks sub macroblocks blocks and or sub blocks. For a particular slice in the picture the decoder also sets up a state machine for the multiple macroblocks in the slice. A decoding task creates the state machine and uses the state machine for various decoding operations for the slice. For a given state the state machine stores information indicating number of consecutive macroblocks in the state and an index to a first availability table indicating availability information for the state. Or instead of storing indices for the respective states the state machine directly stores macroblock availability information on a macroblock by macroblock basis for example as a bit field with four bits per macroblock one bit for each possible neighbor macroblock. Alternatively the decoder sets up a state machine on a picture by picture or some other basis.

A first availability table associates different states with different macroblock neighbor availability patterns. The decoder determines macroblock neighbor availability using the state machine and the first availability table e.g. by lookup or writing values into the state machine . The decoder then determines sub macroblock e.g. 16 8 8 16 8 8 4 8 8 4 or 4 4 sizes neighbor availability using the macroblock neighbor availability and a second availability table. The second availability table associates different macroblock neighbor availability patterns with different block sub block neighbor availability patterns. The decoder then decides whether to continue with the next slice if any in the picture or finish.

Or for a MBAFF picture the decoder sets up a state machine for multiple macroblocks in a slice. A decoding task creates the state machine and uses the state machine for various decoding operations for the slice. For a given state the state machine stores information indicating number of consecutive macroblock pairs in the state and an index to a first availability table indicating macroblock pair neighbor availability information for the state. Or instead of storing indices for the respective states the state machine directly stores macroblock pair neighbor availability information on a macroblock pair by pair basis. The first availability table associates different states with different macroblock pair neighbor availability patterns. The decoder also sets up a neighbor context vector for each of the respective macroblocks of the pairs. The neighbor context vector indicates for example field or frame mode for a current macroblock field or frame mode for each of plural neighbor macroblocks and whether the current macroblock is a top or bottom macroblock in its macroblock pair. The decoder determines macroblock pair neighbor availability using the state machine and the first availability table. The decoder then determines sub macroblock neighbor availability using the macroblock pair neighbor availability and a second availability table. The second availability table associates different macroblock pair neighbor availability patterns with different block sub block neighbor availability patterns.

Aside from computing neighbor availability information the decoder also determines and stores neighbor locations for use in various decoding operations. In some implementations the neighbor locations are stored as offsets relative to the current macroblock.

In some implementations a decoder computes availability and location information via a hierarchical approach using a state machine and tables as described in this section.

In general the decoder uses a state machine to provide neighboring MB availability information in a non MBAFF picture or neighboring MB pair availability information in a MBAFF picture . The decoder uses the availability information to index tables that provide availability information for MB sub MB block and or sub block levels. During decoding the decoder deduces the availability of neighboring sample locations from the availability of neighboring partitions that contain those sample locations. The decoder uses additional tables to record offsets from the current MB sub MB sub block to neighboring MB sub MB sub block. The details of the table based neighbor determination vary depending on whether the content being decoded is part of a MBAFF picture or non MBAFF picture.

For a progressive picture or field picture a decoder uses a state machine for MB level neighbor availability determinations. The decoder sets up the state machine for each slice before entropy decoding. The state machine accounts for picture boundaries and slice boundaries and it provides the state of availability of neighboring MBs in the absence of flexible macroblock ordering . shows a chart indicating MB neighbors to the left of a current MB above the current MB above and to the right of the current MB and above and to the left of the current MB. For the sake of convention these are labeled A B C and D respectively.

The decoder uses two different state machines depending on whether the first MB in the slice is at the left edge of the picture. shows macroblocks for an example state machine . For the state machine the current slice shaded region begins in the middle of the picture. A simpler state machine can be used when the MB beginning the slice is at the left edge of the picture omitting certain categories of states. For a given state the state machine stores the following information 1 how long to stay in the current state the number of consecutive MBs in raster order that share this state 2 an index into an availability table that gives the availability information for this state e.g. the table shown immediately below and 3 the next state. For example at the beginning of the slice the state machine starts at state a which has a length of one MB. For the rest of the MBs in the row the state machine moves to state b. The next macroblock row begins with state c and so on. The following table shows MB neighbor availability information using labels A B C and D shown in associated with the different states in the state machine.

For instance state a corresponds to the case where none of the MB neighbors is available. In state b which may be skipped if the first MB in the slice is the last MB in the row the left neighbor is always available. Some states may be assigned different MB availability depending on the MB location. State c for example either has no available neighbors or has an available above right neighbor if the macroblock starting the slice is one MB position away in the horizontal direction . States i j and k are repeated starting from the fourth row of MBs in the slice. The MB neighbor availability information for a particular state can be represented with 4 bits one each for A B C and D where the 0 1 values indicates whether the neighbor MB is or is not available.

The decoder uses the MB neighbor availability information for macroblocks to determine the sub MB sub block neighbor availability using table lookups. Within a 16 16 MB there may be partitions used at various stages of decoding where the partitions have different sizes and appear at certain allowed locations. For example in the H.264 standard allowed sizes include 16 16 MB 16 8 blocks at any of 2 defined locations in a MB 8 16 blocks at any of 2 defined locations in a MB 8 8 blocks at any of 4 defined locations in a MB 8 4 blocks at any of 8 defined locations in a MB 4 8 blocks at any of 8 defined locations in a MB and 4 4 blocks at any of 16 defined locations in a MB. This yields 1 2 2 4 8 8 16 41 partition location combinations.

A table maps the MB neighbor availability information to the sub MB sub block neighbor availability information. For example for a particular partition e.g. 8 4 block at given location the decoder maps the MB neighbor availability pattern to a sub MB sub block neighbor availability pattern. Where there are four possible MB neighbors A B C and D there are 2 16 combinations and MB neighbor availability patterns. For the particular partition location combination where there are four possible partition neighbors A B C and D the decoder determines which of 16 partition neighbor availability patterns applies.

As an example a 4 4 block in the top row of a MB will not have an available 4 4 neighbor above it if the MB above the 4 4 block s MB is not available. On the other hand a 4 4 block on the second row of the MB will have a 4 4 neighbor above within the same MB . MBs sub MBs and sub blocks that occur later in decoding order are also considered to be unavailable. This includes MBs sub MBs and sub blocks that belong to MBs with bigger MB addresses compared to the current MB as well as MBs sub MBs and sub blocks that occur later in the scan during the decoding of the current MB where the scan order of partitions within a MB or block is generally left to right top to bottom.

The decoder also stores the locations of neighboring MBs for some sub MBs and sub blocks. The decoder stores the location information in the form of offsets from the current MB. The location of neighboring MBs is used during constrained intra prediction. In the progressive picture case the locations of neighboring 4 4 8 8 blocks and sample locations may be directly computed considering MB neighbor availability possibilities and whether positions are in the current MB. shows a pseudocode listing for example data structures used to store neighboring MB information for 8 8 blocks and 4 4 sub blocks.

For an MBAFF picture the decoder uses different tables and or operations. The decoder sets up a state machine used to determine MB pair level neighbor availability. In a MBAFF frame MB addresses MBAddr are ordered such that MBAddr 2 goes through MB pairs in raster scan order. Also MBs within a MB pair are both available or both not available. The decoder uses a state machine analogous to the one used for non MBAFF pictures but the output is interpreted as MB pair neighbor availability instead of MB neighbor availability. The decoder similarly uses a table mapping states to MB pair neighbor availability instead of MB neighbor availability .

The decoder also sets up a neighbor context bit vector for each MB. The vector indicates whether a given current MB is encoded in field or frame mode. For each of the four neighbor MB pairs A B C and D the vector also indicates whether the MB pair is encoded in field or frame mode. Finally the vector indicates whether the current MB is the top MB or bottom MB of its MB pair. shows an example neighbor context bit vector for an MB of an MBAFF picture.

The decoder uses MB pair neighbor information and current MB status information from the bit vector for the current MB to determine sub MB partition information using a table. The table maps different MB pair neighbor current MB patterns to different partition neighbor patterns. Within a 16 16 MB the possible partitions and locations are typically the same as for non MBAFF pictures e.g. 41 combinations for H.264 . Where there are four possible MB pair neighbors A B C and D there are 2 16 combinations and MB pair neighbor patterns. For each there are 4 combinations for field frame coding mode and top bottom status for the current MB. This yields 64 possible combinations for MB neighbor availability for indices to the table. For a particular partition location combination where there are four possible partition neighbors A B C and D the decoder determines which of 16 partition neighbor availability patterns applies.

An example data structure implementing a sub MB neighbor availability table for MBAFF pictures is the two dimensional array 

The decoder stores location information for neighbor MBs for some sub MB and sub blocks. In an MBAFF frame it is not as straightforward to compute the locations of the neighboring MBs sub MBs and sub blocks. Determining the location information is complicated by the possibility of different field frame coding mode decisions for neighbor MB pairs.

In each vector partition location position of the array MB neighbor locations and if appropriate 4 4 sub block or 8 8 block neighbor locations are stored. The MB locations are stored as offsets from the current MB address. 4 4 sub block neighbor locations store the vertical offsets in 4 4 sub block units from the top left 4 4 sub block of the current MB. 8 8 block neighbor locations can also be stored as offsets from the top left of the current MB. The horizontal offsets can be directly computed when needed as in the non MBAFF case.

In intra prediction the sample locations within each 4 4 or 8 8 block can have left neighbors belonging to two different MBs depending on whether the locations belong to the top or bottom field of the picture. This fact is especially important for constrained intra prediction where one of the neighboring MBs may be intra coded whereas the other is inter coded. Therefore two offsets are stored for the left MB neighbors for example by packing two different offset values into the variable bMbOffsetLeft.

Furthermore in intra prediction table lookup of neighboring sample locations can be completely avoided via the following deductions. The left neighbor if available is the sample location immediately to the left of the current sample location in the picture. If the current MB is frame coded the neighbor above if available is the sample location immediately above the current sample location in the picture. Otherwise if the current MB is field coded the neighbor above if available is the sample location immediately above the current sample location in the same field of the picture. The above right and above left neighbors if available can be derived in a similar manner.

In some embodiments when a decoder decodes CABAC encoded video information the decoder uses one or more innovations that improve the efficiency of the CABAC decoding. Many of the CABAC decoding innovations can be used in combination.

CABAC has remarkable compression properties but in standard implementations is computationally complex. CABAC encoding and decoding are notoriously slow and resistant to optimization for conventional architectures. These performance problems have several causes. First the core CABAC decoding routine serially processes one bit at a time off of a bit stream and decoding of some syntax elements does not advance the stream pointer at all. Second in standard implementations the decoder performs heavy processing for each bit which typically involves multiple conditional branches and context switching. Third in standard implementations the decoder inefficiently calls the core decoding function which is labeled biari decode symbol in many implementations . For example in many decoding functions that compute syntax elements calls to biari decode symbol are embedded in extensive conditional branches that are negotiated in order to select the appropriate situation. This organizational scheme leads to code that is not localized well. Based on what is happening at any given moment the routines may jump all over which results in incorrect loading of code into the instruction cache and leads to other inefficiencies. In practice na ve implementations of CABAC decoding can slow down decoding to the extent that 10 frame per second video is displayed at less than 1 frame per second.

Many of the CABAC decoding innovations described in this section are architecture independent stemming from recurrent inefficiencies in the core decoding function. Other innovations are architecture dependent and work for an architecture such as the x86 architecture or a gaming console architecture. Different architectures have different characteristics and correspondingly different innovations are adapted for different architectures.

In the pseudocode decoding function shown in during the renormalization of the range variable bits are read from the bit stream as needed. The value variable is updated on a single bit by bit basis indicated by the value updatevalue operation from a variable DBuffer that holds 8 bits of data. The variable Dbits to go keeps track of how many of the bits of the DBuffer byte have been transferred into the value variable. The bit stream is considered an array of bytes and when the DBuffer byte is used up the decoder loads another byte from the bit stream indicated by the get a byte function . This loading mechanism is inefficient in several respects. Loading bits from the bit stream on a byte by byte basis is inefficient. Moreover loading a single byte is inefficient in many architectures requiring mask shift and load operations to get the single byte.

According to a first aspect of the CABAC decoding innovations when a decoder performs context adaptive binary arithmetic decoding the decoder as necessary loads encoded video information from a bit stream on a machine word by machine word basis. The machine word is for example 32 bits or 64 bits. By loading bits on a machine word by word basis the decoder makes fewer calls to the get a byte function. If the word size is 32 or 64 the decoder makes or as many calls to the get a byte function. Moreover in many architectures loading an entire machine word is more efficient than loading a single byte which requires additional operations.

In some implementations the variable dBuffer holds the entire machine word. Updates are performed a word at a time.

In the reference pseudocode listing shown in three variables value DBuffer and DBits to go are intimately involved in keeping the value being decoded updated with bits off of the bit stream as needed. To update the value indicated by the value updatevalue operation the decoder performs a combination of instructions. The decoder shifts the value variable then performs mask shift load and or instructions in order to load each new bit from the stream from Dbuffer into the value variable. Theoretically the value is a 9 bit window on the bit stream with DBuffer holding the next bits to be loaded into value.

According to another aspect of the CABAC decoding innovations when a decoder performs context adaptive binary arithmetic decoding the decoder stores the value being decoded along with available stream bits together in a single variable. In a second variable the decoder stores bit count information about the first variable. The decoder then uses the first and second variables in the context adaptive binary arithmetic decoding.

In some implementations the decoder shifts the 9 bits for value to the left of a single variable e.g. 32 bit word and puts available stream bits in the other bits of the variable. The decoder performs arithmetic with the left adjusted integer for the value being decoded keeping future bits to be decoded on the right side of the same term. This saves single bit loading shifting and masking instructions that existed in the original implementations of the reference pseudocode . The value being decoded can be kept as the top x bits in a word e.g. top 9 bits with the rest of the word available for storing stream bits as they would otherwise be stored in DBuffer or the bit stream. For a 32 bit word or 64 bit word this leaves or 55 bit positions available.

For example the decoder loads a word into the single variable directly from the bit stream. The top 9 bits are the value being decoded. When the value is updated the single variable is bit shifted such that one or more bits of the value decoded are shifted out and one or more available stream bits previously to the right of the top 9 bits in the single variable are shifted into the value being decoded. The decoder thus avoids time consuming mask shift and load instructions for bitwise updates to the value being decoded. Once every half word of data or at some other interval the decoder reloads bits off of the bit stream into the single variable e.g. into the lower half word of bits in the single variable . The decoder thus uses two variables which can be labeled value the single variable for the value being decoded and some available stream bits and Dbits to go which tracks when there are no longer stream bits available at the left part of the single variable . Compared to the reference pseudocode the variable DBuffer is not needed which is an added efficiency gain.

In the reference pseudocode listing shown in a loop in the renormalization stage includes conditional execution branches. Specifically in a while loop the decoder checks a condition and left shifts value and range one bit at a time. The value being decoded is also updated with new bits from the stream one bit at a time as needed. The point of the loop is to left shift both value and range so that the top bit of range is a 1 and so that Value contains the current 9 bits off the stream that are being decoded.

According to another aspect of the CABAC decoding innovations during renormalization in context adaptive binary arithmetic decoding a decoder determines a multiplication amount e.g. based on a lookup of range in a table and multiplies range by the multiplication amount e.g. left shifting range by a left shift amount corresponding to the multiplication amount . The decoder can then also multiply value by the multiplication amount e.g. by left shifting . This can eliminate performance penalty of the while loop and conditional execution branches in the renormalization instead providing a simple fast and small footprint mechanism for renormalization.

In some architectures multiplications are costly operations and shifts are not so the decoder looks up shift amounts and performs left shifts. In other architectures integer multiplications are not costly and the decoder looks up multiplication amounts.

To start the decoder initializes variables for the context adaptive binary arithmetic decoding for example initializing variables as shown in the reference pseudocode listing of . The decoder then compares value and range and takes an appropriate action for example setting a state variable and if appropriate adjusting range and value as shown in the reference pseudocode listing of . Then the decoder if appropriate renormalizes range and adjusts value using a lookup table that maps different values of range to different shift amounts. The decoder looks up the current range in the table and finds an appropriate dynamic shift amount. The decoder can then shift range and value by the shift amount. The following table shows an example range lookup table.

Thus the decoder uses the lookup table instead of the while loop and range to determine a dynamic shift amount. The table lookup is fast no branches and precise. Moreover the number of shift operations per call to the core decoding function is reduced to one. The decoder performs one dynamic shift operation of x bits instead of x single bit shift operations.

In alternative embodiments the decoder uses multiple lookup tables. For example the decoder uses a first lookup table for the first n bits e.g. first 5 bits of range which addresses the most common cases for range. The smaller lookup table results in faster lookup operations most of the time. If the range is not in the first lookup table the decoder uses a second lookup table for the remaining bits of range. Or the decoder uses more lookup tables.

A range lookup table provides satisfactory performance when dynamic shifts are inexpensive instructions. In some architectures however dynamic shifts have a high computational cost.

According to another aspect of the CABAC decoding innovations a decoder uses unrolled loop logic when determining a shift amount for renormalization. In some implementations the decoder uses a mixed approach with unrolled loop logic and in place of some decision branches a range lookup table. For example during renormalization in context adaptive binary arithmetic decoding a decoder determines a multiplication amount e.g. shift amount using unrolled loop logic and potentially also using a range lookup table . The decoder then multiplies range by the multiplication amount e.g. by left shifting range . In some implementations the decoder traverses the unrolled loop logic checking common cases for range which have associated with them fixed shift amounts for fixed shift operations. If range is not one of the common cases the decoder looks up range in the lookup table to determine a dynamic shift amount.

To start the decoder initializes variables for the context adaptive binary arithmetic decoding for example initializing variables as shown in the reference pseudocode listing of . The decoder then compares value and range and takes an appropriate action for example setting a state variable and if appropriate adjusting range and value as shown in the reference pseudocode listing of . Then the decoder if appropriate renormalizes range and adjusts value using unrolled loop logic and potentially a lookup table that maps different values of range to different shift amounts. The decoder traverses the unrolled loop logic checking various common cases for the current range to find an appropriate shift amount. The decoder can then shift range and value by the shift amount. If the current range is not one of the common cases and uncommon cases are addressed with a lookup table the decoder looks up the range in the table.

In some implementations the loop logic for the renormalization stage is at least partially unrolled and goto statements are inserted as needed to break out of the unrolled loop. In particular the unrolled loop logic is structured e.g. as a cascade of if then statements or as a case statement to exploit a nearly uniform probability distribution that CABAC produces in the respective bits of range in many coding scenarios. The range is represented as a 9 bit number and the renormalization effectively shifts the range as needed to make range have a top bit of 1. Within range there is a near uniform expected distribution of 1s and 0s and each bit essentially has a 50 chance of being a 1. With this probability distribution pattern about 50 of the time the top bit is 1 and there is no shift. Zero is the most common shift value. If the top bit is 0 which happens about 50 of the time the next bit is 1 about half that time 25 and there is a shift of 1. Similarly there is a shift of 2 about 12.5 of the time and a shift by 3 about 6.25 of the time. More generally there is a shift by n bits about of the time.

In practice the actual probability distribution is rarely exactly uniform. The range is not allowed to be 0 and the shift is never by more than 7 bits at a time. The general distribution allows for design of efficient partially unrolled loop logic addressing common cases e.g. 97 of the time the shift will be 4 bits or less . The remaining cases can be addressed with a range lookup table indicating dynamic shift amounts. Mis predicted branches are expensive so after 4 mis predicts the cost of the dynamic shift is more acceptable.

The functions that call the core decoding function represented in conventionally have complicated conditional logic around calls to the core decoding function. The complicated logic in the calling functions often results in cache misses and other performance inefficiencies due to lack of compact code.

According to another aspect of the CABAC decoding innovations a decoder uses one or more state machines that call a core decoding function for context adaptive binary arithmetic decoding. A state machine implements for example a cascade of conditional logic for a particular decoding function. In some implementations a state machine uses a position state to effectively track position in the cases of conditional logic and it uses a transition table to switch between states. For example the transition table indicates a next state based at least in part upon a current state and results of a call to the core decoding function.

The decoder sets a state machine for the calling function initializing it and determines a state to be passed to the core decoding function. The decoder calls the core decoding function e.g. the function shown in or a modified version thereof incorporating one or more other CABAC implementations . The decoder then analyzes results of the core decoding function and determines a next state for CABAC decoding. For example the decoder uses the current state and results of the core decoding function to determine a next state. The decoder determines whether or not to continue and if so continues by determining the next state which is then used in calling the core decoding function.

In some implementations the decoder replaces complicated cascades of conditional logic with straightforward loops in state machines. For a particular state machine the decoder marks position in the cascade that is reflected in the state machine where the position is effectively the state in the decision tree of the cascade using a state variable. The state machine can have a two dimensional transition table that indicates to the decoder a new state based on the current state and the results of the most recent call to the core decoding function. Replacing complicated conditional logic with a state machine typically improves the compactness of code. The branch that remains the top of the loop is more reliably predicted. This is especially valuable on processors that show a significant performance penalty for branch mis predictions. For example a 50 line cascade of conditional logic with 25 calls to the core decoding function is replaced with a 5 line loop and known number of calls for a state machine resulting in much more compact code.

Moreover in some implementations the size of a state table is reduced by exploiting patterns within the state table. For example for a state table with x entries if entries 0 to 3 are the same entries 4 to 7 are the same and so on the decoder masks off those bits and performs state transitions based on the remaining bits in a state table with x 4 entries.

Transform coefficients for motion compensated prediction residuals tend to have non zero values as the DC coefficient and low frequency AC coefficients with higher frequency ranges being characterized by runs of zero value coefficients. Therefore transform coefficients are typically scanned according to a scan pattern which orders the coefficients to take advantage of run length coding or run level coding.

According to another aspect of the CABAC decoding innovations a decoder splits context adaptive binary arithmetic decoding for frequency coefficients into multiple decoding units each of the units being adapted for a different frequency interval for the frequency coefficients. For example the multiple decoding units include a first unit adapted for a low frequency range and a second unit adapted for higher frequency range. Alternatively the decoder uses more decoding units and frequency ranges. The units call a core decoding function.

The different units differ in the probabilistic expectations incorporated into the logic for the units. For example for a low frequency unit code is adapted for the AC coefficients being non zero. The non zero cases are the first cases in the decision trees for the code. For a high frequency unit code is adapted for AC coefficients being zero. These are the first cases in the decision trees for the code. More generally low cost branches are followed for expected values and higher cost branches are followed as needed when unexpected values are encountered. Splitting CABAC decoding into multiple units results in each unit being more compact and more efficient in processing of calls to the core decoding function.

The decoder calls a core decoding function e.g. the function shown in or a modified version thereof incorporating one or more other CABAC implementations and analyzes results of the call using frequency range specific logic. The decoder checks if it is done and if not checks whether to switch the range specific logic used in CABAC decoding. If not the decoder continues by calling the core decoding function. Otherwise the decoder switches the range specific logic used in CABAC decoding and continues by calling the core decoding function.

In one implementation the decoder switches from low frequency coefficient decoding logic to higher frequency coefficient decoding logic after the decoder decodes a DC coefficient and the first three AC coefficients for a block. Alternatively the decoder switches at a different position and or dynamically varies the switchover point.

In code for one implementation developers may use preprocessor conditionals macros and other standard mechanisms to switch between using different CABAC decoding features and different combinations of CABAC decoding features for different target architectures. One simple example of this is switching between using a lookup table and not using a lookup table when determining the result of processing a 5 bit input value. The relative speeds of the operations used for table lookups can vary depending on architecture the decision about whether or not to use lookup tables can be architecture dependent. Moreover when making such decisions the primary consideration can be computational speed of decoding memory footprint or some combination of the two.

Some playback devices provide only a simple playback mode at normal speed along with controls like play pause and stop. More advanced playback devices support trick play modes such as fast forward fast backward rewind slow forward slow backward and chapter selection. The implementation of these trick play modes can vary from device to device. Chapter selection is typically handled by a parser module in the device. Slow forward mode can be implemented by timestamp management. Other playback modes may use support from the video decoder.

In some embodiments a decoder supports one or more trick play modes in addition to a normal play mode using an innovative trick play mode framework. For example the decoder supports fast forward and fast backward modes. In normal play mode the decoder plays back video at the specified frame rate for the video. For fast forward trick play mode the decoder skips decoding and displaying of selected pictures to achieve fast forward effects which can allow users to have a quick view of the video. For fast backward trick play mode the decoder seeks backward in the bit stream and selectively decodes and displays pictures to achieve fast backward effects which allows users to view the video as it rewinds.

In the framework of the decoder decodes and displays only I pictures in the fast forward mode and fast backward mode . The I pictures are independently decodable and their display order is the same as their order in the coded video bit stream. At a basic fast forward or fast backward rate the decoder decodes and displays regularly spaced I pictures in the bit stream. Or for a different fast forward or fast backward rate the decoder skips the decoding and display of some proportion of I pictures. For example the decoder decodes displays alternating regularly spaced I pictures for 2 fast forward or fast backward effect. Or the decoder decodes displays every fourth I picture in a series with regularly spaced I pictures for 4 fast forward or fast backward effect. The decoder can similarly selectively decode display pictures for 3 8 or other speedup effects.

According to the framework shown in when the decoder transitions between modes the decoder drains so as to facilitate the transfer. shows a generalized technique for switching playback modes. A decoder such as the one described above with reference to or other decoder performs the technique .

The decoder decodes video in a first playback mode and receives a mode switch command. For example while decoding video in normal play mode the decoder receives a command to switch to fast forward or fast backward mode. Or while decoding video in fast forward mode the decoder receives a command to switch to normal play or fast backward mode. Alternatively the decoder switches between other and or different play modes.

The decoder drains the decoder. This involves using up previously received input releasing decoder resources and or completing in process tasks. For example the decoder stops input to the decoder and consumes the input it has previously accepted in the first playback mode. As another example the decoder releases memory used for decoding in the first playback mode and or waits for working threads for the first playback mode decoding to complete their processing and rest. In some implementations the draining is partial in that the decoder maintains resources e.g. allocated structures previously decoded pictures from the first playback mode that can be reused in the second playback mode.

After the decoder at least partially drains the decoder decodes video in the second playback mode. Example transition mechanisms and playback mechanisms are now described.

In some implementations the decoder switches from normal play mode to fast forward mode as follows. The decoder is drained by not feeding any more bits from the coded video bit stream to the decoder and letting the decoder decode the data already received in normal play mode. The working threads automatically die when there are no more decoding tasks to perform in the decoder. The decoder is not closed however even though the working threads are at rest so at least some of the memory pools available to the decoder can be used when the decoder starts again. One the working threads are dead or there are no more decoding tasks to perform in the decoder the decoder restarts the working threads.

The decoder or a parser outside the decoder parses new input from the coded video bit stream. When the fast forward mode is implemented by decoding and displaying only I pictures the decoder gets access units that are used for I pictures. According to the H.264 standard this includes SPS NALUs SEI NALUs PPS NALUs and slice NALUs.

After restarting working threads and accepting access units for the video to be decoded the decoder finds complete pictures to decode in the fast forward mode. For example the decoder process NALUs for 1 slices to find complete I pictures using a PED module such as described above. The decoder then decodes the complete pictures.

When the fast forward mode is implemented by decoding and displaying only I pictures the decoder can simplify processing by bypassing certain DPB management routines. The decoding order of the I pictures is the same as their output display order and I pictures do not use other pictures for reference. Therefore the decoder need not buffer I pictures in the DPB in the fast forward mode. Decoded I pictures are simply output and deleted. For example when PED finds a complete I picture output and delete picture commands are recorded in the picture command queue. Generally picture commands have corresponding dependent pictures entered in a DPB and the commands are executed when decoding is completed the respective dependent pictures. In fast forward mode however picture commands for I pictures need not have corresponding pictures in a DPB and DPB management routines can be bypassed. When an I picture is decoded the output and delete commands for it are executed. Or the decoder skips the use of the picture command queue and just outputs and deletes the I picture upon completion of decoding.

In some implementations the decoder switches from fast forward mode to normal play mode as follows. The decoder is drained finishing decoding for the fast forward mode data. The decoder then starts accepting data from the bit stream in normal play mode and begins decoding. For a transition period there may be problems decoding and displaying certain types of content. The decoder can use special transition mechanisms to smooth and otherwise improve the quality of playback across the transition.

Macroblocks in some pictures after an I picture in coded decoding order may reference pictures that were not decoded because they were skipped in the fast forward mode or transition. For example a B picture or P picture after the I picture in coded order can reference a I or P picture before the I picture in presentation order which is not currently available. If a B picture or P picture follows the first I picture in coded order for example but references a picture that is non available the B picture or P picture will have corrupted blocks if the decoder attempts to decode it. Rather than attempt to render corrupted blocks the decoder detects whether a picture being decoded uses any unavailable pictures for reference. If so the decoder skips decoding and displaying the picture. If another later picture in coded order uses the skipped picture for reference the decoder also skips decoding and display of that other picture. B and P pictures having available reference pictures are decoded and displayed as normal.

There may also be P pictures in the coded video bit stream that reference a first I picture but have presentation times before the first I picture. According to the H.264 standard presentation time stamps PTSs accompany I slice NALUs and picture display order may be different from coded order for 1 and P pictures. For such a P picture the decoder performs backward interpolation using the PTS of the first I picture and the current playback rate.

In some implementations the decoder switches between normal play mode and fast backward mode using mechanisms analogous to those described for normal play fast forward mode transitions. When switching to fast backward mode the decoder drains and starts to input data for fast backward mode in effect rewind seeking through the coded video bit stream. In fast backward mode the decoder uses mechanisms analogous to those used in fast forward mode for example decoding and displaying I pictures and the decoder can use analogous mechanisms to switch from fast backward mode back to normal play mode.

In some implementations the decoder switches between trick play modes e.g. fast forward to fast backward or vice versa using analogous mechanisms. For example when switching the decoder drains and starts to input data for the other trick play mode.

Another aspect of the trick play mode innovations is reduction of latency when switching from normal play mode to trick play mode. When switching to a trick play mode a long delay e.g. 4 5 seconds might irritate the user. The decoder uses any of several different mechanisms to reduce delay when transitioning to a trick play mode. Collectively these mechanisms can significantly reduce delay when switching from normal play mode to a trick play mode e.g. reducing a 4 5 second delay to a less than 2 second delay .

For one mechanism when the trick play mode decodes only I pictures the decoder reduces the amount of time it takes to identify complete I pictures. In some implementations there is a significant time interval e.g. 300 ms between reading the data for different I pictures due to delays in reading and parsing. The decoder typically identifies e.g. during PED the end of a complete I picture after the decoder parses the first slice of the picture following the I picture. According to the first delay reduction mechanism however the decoder receives information from decoder wrapper layer software e.g. MF pipeline software that indicates where pictures end and facilitates identification of I pictures. The decoder wrapper layer software might get this information for example from extra bit stream delimiters before and after I pictures. The decoder can begin decoding of the complete I picture without waiting for the first slice of the next picture which reduce overall latency e.g. saving 300 ms .

According to a second delay reduction mechanism the decoder bypasses the DPB for decoded pictures. Instead decoded pictures are put directly in an output buffer.

According to other delay reduction mechanisms the decoder changes system parameters to tune performance for the trick play mode. In the trick play mode the decoder typically attempts to reduce delay between the completion of decoding and output. So the decoder can reduce the output buffer size. For example the decoder reduces the output buffer size from 8 pictures to 2 pictures. The decoder can also reduce the maximum number of pictures in flight during multithreaded decoding.

The decoder reduces output buffer size. For example the decoder changes the output buffer to hold 2 pictures instead of 8 pictures which speeds up the processes of writing to and reading from the buffer. When finding an I picture to display the decoder uses extra delimiters in the bit stream to find complete I pictures faster. The decoder then decodes the complete I picture and puts the decoded I picture directly in the output buffer skipping the DPB. The decoder determines whether to continue and if so continues by finding the next I picture. Alternatively the decoder uses other and or additional mechanisms to reduce latency when switching to a trick play mode.

Many video decoders drop pictures in stress conditions such as those occurring when a decoder falls behind during real time decoding. Software decoders in particular usually support picture dropping since the software may be used on hardware configurations of varying capabilities including hardware configurations likely to encounter stress conditions during decoding.

In decoders operating according to some standards e.g. MPEG1 MPEG2 simple picture dropping strategies select pictures to drop based on picture type. In such standards picture dependencies tend to be simpler and short term. Typically P pictures depend on I pictures or other P pictures and B pictures depend on I pictures and or P pictures but not on other B pictures. Moreover the reference pictures used for a given P or B picture are implied or selected from very limited set of available pictures. According to one simple picture dropping strategy a decoder drops B pictures to reduce decoding complexity when the decoder falls behind in real time decoding.

On the other hand in decoders operating according to other standards e.g. H.264 simple picture dropping strategies may be inadequate. The H.264 standard allows complex picture dependencies. An 8 8 block in a picture can use up to two different reference pictures and the picture collectively can use up to 16 frames in a DPB as reference pictures. Moreover the H.264 standard also allows extensive temporal prediction support. The H.264 standard recognizes two kinds of reference pictures long term and short term. Long term reference pictures can be stored in a DPB and used as reference pictures indefinitely or at least until explicitly removed from the DPB by changing how flags for the long term reference pictures are marked .

In some embodiments a decoder uses picture dropping schemes that work for bit streams with complex reference picture dependencies and or work for multithreaded decoding.

In the architecture the decoder e.g. PED module parses a picture from a coded video bit stream. For example the PED module finds a complete picture as described above using a lightweight scan through the bit stream initializing structures for the parameters and data for the picture and entering an initialized picture into the DPB. Alternatively the decoder finds the picture in some other way.

The decoder also determines whether to drop the picture. In the PED module receives a control signal that indicates a picture dropping mode and the PED module determines whether to drop the picture according to the picture dropping mode. Example picture dropping modes including no picture dropping are described below. Alternatively the decoder uses other and or additional picture dropping modes.

If the picture is dropped the decoder recycles the dropped picture. For example the decoder releases memory used for at least some of the structures initialized for decoding the dropped picture. Dropping a picture may cause one or more other pictures to get dropped if those other pictures are dependent on the first dropped picture.

If the picture is not dropped the decoder decodes the picture. In the wrapper which may provided by DirectShow or Media Foundation Transform software the decoded picture is delivered to the renderer which displays the decoded picture.

The renderer and wrapper software also cooperate to provide feedback to the decoder for selection of a picture dropping mode. For example decoder wrapper software in a decoder DLL along with the decoder checks timestamps in an output pipeline and over time tracks whether the decoder s output rate is keeping up with the desired presentation rate. The decoder wrapper instructs the decoder about how late pictures are being output by the decoder e.g. with messages that the decoder is not late 50 ms late 100 ms late etc. . Alternatively the decoder receives feedback or measures progress using another mechanism.

When decoding and or rendering speed does not support the required display output speed the decoder starts to drop pictures. Depending on how slow the decoding and or rendering speed is e.g. how late pictures are being delivered to the renderer different picture dropping schemes can be selected. The decoder does not decode dropped pictures so the decoder tends to catch up to the display output speed or equivalently catch up to the render clock when pictures are dropped. More aggressive picture dropping schemes more quickly help the decoder catch up but do so at a higher cost to temporal quality. Less aggressive picture dropping schemes have a smaller quality penalty but do not help the decoder catch up as quickly. As a theoretically matter the decoder balances the goals of minimizing the quality penalty for frame dropping and trying to make the decoder return to normal speed playback as soon as possible.

The decoder selects a picture dropping mode and decodes in the selected picture dropping mode. Initially the decoder can select a no dropping mode. The decoder continues decoding for a fixed number of pictures in the selected mode. Alternatively the decoder continues decoding indefinitely until interrupted by a control signal or the end of the bit stream.

Eventually the decoder determines whether to switch modes. For example the decoder receives a control signal and decides whether to change picture dropping mode to another mode indicated by the control signal. Or the control signal indicates a latency value or other metric and the decoder switches selects the picture dropping mode based upon the control signal more aggressively dropping pictures as needed. The decoder can gradually switch modes from less aggressive to more aggressive for example switching one mode at a time or the decoder can switch in proportion to the extent the decoder needs to catch up. Alternatively the decoder makes the switching decision in some other way.

If the decoder decides to continue but switch picture dropping modes the decoder selects the new picture dropping mode. Otherwise the decoder determines whether to continue at all. If the decoder decides to continue in the same picture dropping mode the decoder decodes more video in the same picture dropping mode.

In some implementations the decoder selects from among the following available picture dropping modes. Alternatively the decoder selects from among other and or additional picture dropping modes.

In no dropping mode the decoder does not drop any pictures. If decoding speed is fast enough the decoder does not drop any pictures it tries to decode and display all of the pictures.

The decoder may tolerate some consistent amount of delay. In view of the long latency between the start of decoding of a picture and the sending the decoded picture to render the decoder may keep output pictures in a circular buffer. When the output circular buffer is initially filled the decoder sends decoded pictures as output for display. Keeping pictures in the output circular buffer can improve the user experience by ironing out short term variations between decoding speed and output display speed.

In drop non reference pictures mode the decoder drops pictures that are not used as reference pictures. If decoding speed is slower than required the drop non referenced pictures mode provides a gradual way to start dropping pictures. An H.264 decoder can use information in the coded video bit stream for a picture slice to determine whether or not the picture slice is used for reference. For example after the decoder parses the data NALU for the picture slice the decoder evaluates the used for reference flag for the picture slice and drops the picture slice if used for reference is false. For a picture that includes multiple slices the picture is not used for reference if none of the multiple slices is used for reference.

In drop B pictures and dependents mode the decoder drops B pictures as well as pictures that depend on the B pictures for reference. For example if the decoding speed in drop non reference pictures mode still does not catch up to the desired output display speed the decoder drops B pictures and their dependents. For an H.264 decoder a B picture is a picture where all of the slices in the picture are B slices and a B picture dependent picture uses at least one B picture as reference. In most coding scenarios B pictures are rarely used as references for other pictures. B pictures are common however for patterns such as the group of pictures shown in . Thus dropping B pictures and their dependents more aggressively helps the decoding sped catch up to the output display speed.

In drop P pictures and dependents mode the decoder drops P pictures as well as pictures that depend on the P pictures for reference. For example if after trying the drop B pictures and dependents mode the decoding speed is still too slow the decoder drops P pictures and their dependents. For an H.264 decoder a P picture is a picture where all of the slices in the picture are P slices and a P picture dependent picture uses at least one P picture as reference. In typical coding scenarios P pictures and their dependents are common and many pictures are usually dropped in this mode.

In I pictures only mode the decoder decodes only I pictures and drops all other pictures. For an H.264 decoder an I picture is a picture where all of the slices in the picture are I slices. In typical coding scenarios I pictures occur periodically e.g. every 12 or 15 pictures and many pictures are dropped in this mode.

Finally in an IDR pictures only mode the decoder only decodes I pictures that are also IDR pictures and the decoder drops non IDR pictures. For an H.264 decoder an IDR picture is a special I picture that effectively acts as the beginning of a new sequence. When the decoder encounters an IDR picture e.g. from the flag idr flag it signals to the decoder that none of the previously decoded pictures is used as a reference picture going forward. In some coding scenarios an IDR picture appears every 5 seconds. In other coding scenarios however IDR pictures are not used.

In some implementations a decoder creates a dependency tracking structure e.g. a task dependency graph to track reference relationships for picture dropping schemes. For example the decoder uses a task dependency graph that associates decoding stages with segments of video for nodes and tracks dependencies between the decoding stages for the segments. Some of the tracked dependencies indicate reference picture relationships. Alternatively the decoder uses another type of dependency tracking structure.

The decoder uses the dependency tracking structure for some types of picture dropping decisions. In the drop B pictures and dependents mode or drop P pictures and dependents mode the decoder identifies pictures that use B or P pictures as reference pictures. When a decoder builds a dependency tracking structure dropped B pictures or P pictures are marked as skipped or dropped in the tracking structure and the decoder propagates the skipped dropped status to pictures that would otherwise attempt to use a dropped picture as a reference picture. The decoder skips decoding of dropped skipped pictures but decodes and outputs other pictures.

According to another aspect of the picture dropping innovations a decoder integrates its picture dropping approach with DPB management. For example the decoder tracks the pictures in a coded video bit stream regardless of whether they are eventually decoded or skipped in a DPB and picture command queue. This helps the decoder maintain proper output timing even when pictures are dropping in different picture dropping modes.

During decoding e.g. during PED the decoder finds a complete picture and enters the initialized picture in a DPB. For example the decoder parses the coded video bit stream for parameters for the picture initializes structures for the parameters and data for the picture and puts an initialized picture container entry for the picture in the DPB as described above. The decoder can also put picture command queues associated with the picture in a FIFO queue.

The decoder e.g. during PED determines whether the picture is dropped skipped or not. If the picture is not skipped dropped the decoder decodes the picture and outputs the decoded picture. The non dropped picture is processed as normal during decoding and DPB management with the non dropped picture having a regular entry in the DPB.

If the picture is to be skipped or otherwise designated as a dropped picture the decoder need not decode the picture. The decoder marks the picture as skipped in the DPB and other tracking structures as needed and recycles at least some of the resources allocated to the picture for decoding so the resources can be reused. For example the decoder releases temporary memory and structures e.g. PictureHolder structures for a skipped picture after the skipped picture is found during PED but the decoder maintains other structures e.g. the initialized picture entry in the DPB a structure holding invalid YUV data that are still used for DPB management for picture bumping and or output timing DPB list formulation and DPB indexing. For output after PED the skipped dropped picture is treated is skipped picture are normally treated for example by repeating another previously decoded picture in place of the skipped picture.

The decoder then determines whether it should continue with the next picture and if so finds the next picture. For example after the decoder finishes PED for a skipped picture the decoder starts PED again for the next picture in the coded video bit stream. To process a long series of skipped pictures the decoder effectively calls PED again and again until a non dropped picture is found at which point the decoder decodes the non dropped picture.

Thus in some implementations the DPB stores entries for non dropped decoded pictures as well as entries for dropped skipped pictures. The DPB maintains entries for pictures regardless of whether the pictures are skipped or not. The decoder performs full PED analysis and recycles resources to improve performance but also marks dropped pictures as skipped and reserves enough resources to handle dropped pictures as skipped pictures. The decoder does not provide the dropped skipped pictures to other decoding tasks since skipped pictures are not decoded.

A direct mode macroblock uses information from a corresponding macroblock in a collocated picture when determining which motion vectors to apply in motion compensation. The information from the corresponding macroblock is an example of collocated macroblock information. In many encoding scenarios more than half of the macroblocks in B slices are direct mode macroblocks and efficient determination of collocated macroblock information is important to performance.

In some embodiments a decoder uses one or more mechanisms to improve the efficiency of determining collocated macroblock information. The mechanisms can be used separately or in combination and several improve performance in multithreaded decoding.

According to the H.264 standard a collocated picture is the first picture in a particular reference picture list namely LIST for a B slice. The H.264 standard provides algorithmic details about finding collocated pictures and computing collocated macroblock information which includes motion vectors and reference indices for macroblocks as well as scaling information that applies to macroblocks in a slice. According to the reference software for the H.264 standard the decoder computes collocated macroblock information for a picture whether or not any direct mode macroblock actually uses the collocated macroblock information from the picture. For example when a P picture is reconstructed and enters the DPB the decoder reorders the side information for the picture and makes the side information usable as collocated macroblock information. This is often an inefficient use of resources because not all pictures are used as collocated pictures and because collocated macroblock information is computed for a picture but the picture may never be used as a collocated picture.

In some embodiments a decoder computes collocated macroblock information as needed. For example the decoder computes collocated information e.g. retrieves and reorders side information for a picture when the picture is used as a collocated picture. Moreover the decoder can determine whether or not a macroblock of a B slice is a direct mode macroblock and if so compute the collocated macroblock information e.g. retrieve and reorder side information in the collocated macroblock accessed by the direct mode macroblock. The decoder thus retrieves collocated macroblock information that the decoder will use for the direct mode macroblocks. Computing collocated macroblock information as needed for a direct mode macroblock potentially saves memory compared to approaches in which collocated macroblock information is computed for an entire picture or slice.

In the H.264 reference software a single routine addresses all cases of computing collocated macroblock information. The logic depends on many factors including the format of the current picture with the B slice including the direct mode macroblock the format of the collocated picture with the collocated macroblock and the direct motion vector prediction mode spatial motion vector prediction or temporal motion vector prediction indicated by the slice level flag direct spatial mv pred flag . For MBAFF frames in which macroblocks are organized as macroblock pairs the logic also depends on the format of the MB pair including the direct mode macroblock field or frame and the position of the direct mode macroblock in the MB pair top or bottom . Given these possibilities the routine in the H.264 reference software includes too many paths resulting in too many branches.

In some embodiments the code that handles different cases for computing collocated macroblock information is separated. When decoding progressive video for example the decoder determines which routine to call depending on whether a direct mode macroblock uses spatial motion vector prediction or temporal motion vector prediction. For pictures that can be fields or frames the code is split into routines optimized for different current picture format collocated picture format direct prediction mode cases.

The decoder can select and call routines as needed during decoding to compute collocated macroblock information. For example the decoder selects and calls an appropriate routine when it identifies a direct mode macroblock in a B slice. The decoder thus avoids unnecessary calculations of collocated macroblock information for a whole collocated picture.

Alternatively the code for computing collocated macroblock information is separated in other and or different ways to partition the code to handle different cases.

When computing collocated macroblock information the decoder uses side information previously reconstructed for the collocated picture. As such the retrieval of the collocated macroblock information depends on the successful reconstruction of the information for the collocated picture.

In some embodiments the decoder puts computation of collocated macroblock information in an appropriate stage of the decoding pipeline to improve parallelism for multithreaded decoding. In particular the decoder separates computation of collocated macroblock information from entropy decoding tasks to facilitate multithreaded decoding. A task in which collocated macroblock information is computed can thus be scheduled separately from ED tasks.

To compute collocated information for a direct mode macroblock in a B slice an H.264 decoder gets side information motion vectors reference indices etc. from the first picture in reference picture list LIST. If the computation of collocated macroblock information is part of an ED task for the B slice the ED task for the B slice will have a dependency on the ED task for the relevant part of the first picture in LIST which provides the side information for the first picture . Creating dependencies between two ED tasks hurts parallelism however since ED tasks usually do not have dependencies between them. As another consideration an MC task for the B slice uses collocated macroblock information so it should be computed before the MC task.

In some implementations computation of collocated macroblock information for a B slice occurs as at the beginning of a MC task for the B slice. The MC task already has a dependency on an LF task and indirectly MC and ED tasks for the relevant part of the collocated picture.

In other implementations computation of collocated macroblock information for a B slice occurs as part of a separate task for the B slice. For example in a GPU architecture the COLOC task includes computation of collocated side information e.g. by retrieving side information and other GPU setup tasks. The COLOC task can be implemented for example as part of an MV setup task. shows an example task dependency graph that includes tasks for an I picture picture P picture picture and B picture picture . In many respects the task dependency graph resembles the graph of . The graph also includes a COLOC task for picture however which depends on the ED task for picture . If needed the COLOC task for picture can also depend on the ED task for picture . The MC task for picture in turn depends on the COLOC task for picture . More generally the decoder generates a task dependency graph for segments which may be pictures and in some implementations separates computation of collocated macroblock information and other GPU setup operations for scheduling as a separate task.

In some embodiments the decoder separates computation of slice level collocated macroblock information from computation of macroblock level collocated macroblock information. This improves performance when multiple direct mode macroblocks use the same slice level collocated macroblock information.

When processing a B slice the decoder computes slice level collocated macroblock information. For example the decoder retrieves common side information among the direct mode macroblocks of the B slice. The common side information can include motion vector scaling factors which are the same for the direct mode macroblocks in the slice and which are used in temporal direct mode. The common side information can also include a field picture selection which field should be chosen as the collocated picture . Alternatively the decoder computes other and or additional slice level information.

The decoder then computes macroblock level collocated macroblock information for the direct mode macroblocks in the picture. For example according to the technique shown in the decoder computes such information as needed during decoding. The decoder gets the next macroblock in the slice. The decoder determines whether the macroblock is a direct mode macroblock and if so computes macroblock level collocated macroblock information such as motion vectors and reference indices. The decoder determines whether there any other macroblocks in the slice and if so continues by getting the next macroblock.

The decoder stores the slice level collocated macroblock information and macroblock level collocated macroblock information for use in later decoding.

A reference index ref idx in H.264 in a slice is an index to a picture in a reference picture list of the slice. In different slices reference indices with the same value e.g. 3 may refer to different pictures because the reference picture lists for the different slices can be different. When the decoder retrieves collocated macroblock information for a direct mode macroblock in a B slice the decoder determines which picture if any in the B slice s reference picture list corresponds to the reference picture used for reference by the collocated macroblock that provides the collocated macroblock information.

A per macroblock way to find the correct reference picture is to determine a reference picture identifier of the reference picture for the collocated macroblock when computing the collocated macroblock information for a direct mode macroblock. For example the decoder determines the reference picture identifier using the reference picture index for the collocated macroblock. The decoder compares the reference picture identifier with the reference picture identifiers of the pictures in the B slices reference picture list. The decoder stops the comparison when is finds the reference picture used by the collocated macroblock. In the worst case in some implementations if the size of the reference picture list is LIST this involves 4 LIST64 bit integer comparisons for each direct mode macroblock. In many scenarios about 50 of the macroblocks in a B slice are direct mode macroblocks and performing comparisons for every direct mode macroblock is too computationally intensive.

In some embodiments on a slice by slice basis the decoder uses remapping techniques to re enable the reference indices in collocated pictures to reduce computations and save memory. For example reference indices that refer to reference pictures for a collocated slice which includes at least one collocated macroblock for a corresponding direct mode macroblock of a B slice are replaced with reference indices for a B slice that refer to the same reference pictures. The remapped reference picture indices are then stored for use in motion compensation for the direct mode macroblocks.

For example when the decoder computes collocated macroblock information for a B slice for each collocated slice in the collocated picture the decoder remaps the reference indices for the collocated slice in terms of the reference indices for the B slice. For a reference index of the collocated slice the decoder can do this by a finding the corresponding reference picture identifier for the reference picture index of the collocated slice b comparing the reference picture identifier with identifiers for pictures in the B slice s reference picture list and c when a matching reference picture identifier is found in the list remapping the reference index of the collocated slice to the reference index of the matching reference picture identifier for the B slice e.g. replacing the reference index of the collocated slice with the corresponding reference index of the B slice . If no match is found the reference picture index of the collocated slice is invalid for direct mode MB motion compensation.

In some implementations reference picture list size is limited to a maximum of 16 frame pictures or 32 field pictures. The number of comparisons is thus limited and the overall number of comparisons is reduced for typical sizes of B slices with expected proportions of direct mode macroblocks.

Decoding video can consume large amounts of memory resources especially for multithreaded decoding. In some embodiments a decoder uses one or more niechanisms to reduce memory consumption during decoding including 

After entropy decoding one way to store entropy decoded coefficient levels is to store all coefficient levels whether zero value or non zero value level in order in memory. In typical cases this is inefficient because much storage is spent buffering zero value levels.

In some embodiments a decoder packs or compresses entropy decoded transform coefficient levels for efficient intermediate storage. This typically reduces the memory consumed storing the entropy decoded coefficient levels for a given picture. The aggregate savings in memory can be dramatic where there are multiple pictures in flight during decoding.

When multiple pictures are in flight the coefficient levels are kept in packed format until the decoding stage in which the coefficient levels are further processed. In later decoding processes such as inverse scanning inverse quantization and inverse transform the entropy decoded coefficients are unpacked into a less compact representation that is easier to manipulate for those operations. The unpacking can be implemented in conjunction with inverse scanning and or inverse quantization.

In some implementations the decoder packs entropy decoded coefficient levels into data structures by storing a block position together with a non zero level value for each non zero coefficient level. The decoder packs the block position and non zero level value into a single multi bit value to save memory. Arrays of the single multi bit values stored multiple non zero coefficient levels for a block macroblock or other unit. Non zero values are not explicitly represented in the intermediate storage. Instead the zero value levels are implied at particular block positions where no values are stored for those particular block positions. In typical coding scenarios in which high frequency coefficients are often zero this representation can dramatically reduce intermediate storage requirements.

If the single multi bit value does not include enough bits to store some possible value the single multi bit value can include an extension flag that indicates whether an extension value is used for the coefficient level. If an extension value is used part of the non zero coefficient level is stored in the single multi bit value and the rest is stored in the extension value. To simplify manipulation of the coefficient levels the extension value can follow the single multi bit value and have the same size.

With another option the decoder stores a count value for a block e.g. 4 4 or 8 8 transform block that tracks how many non zero coefficient levels are in the block. The decoder can store the non zero coefficient count values for the blocks in a macroblock in an auxiliary buffer together with the count values for blocks of other macroblocks. Using non zero coefficient count values provides an efficient way to represent zero value blocks. It also can help the decoder access packed coefficient levels more efficiently by skipping ahead to the start of a particular block. If extension values can be interspersed with other values in the packed data however the decoder still traverses the packed data in a coefficient by coefficient manner to get the start of a block.

With another option the decoder sets a flag per macroblock indicating whether extension flags are set for any coefficient levels in the macroblock. If no extension flags are set in the macroblock no extension values are used and the decoder can skip checking for extension flags in individual non zero coefficient levels. The decoder can also make simplifying assumptions about block start locations in the packed data for example using counts of non zero coefficient values for blocks in the macroblock.

The multi bit value includes a 6 bit position value extension flag and 9 bit non extended non zero value of the coefficient. The lower 6 bits of the value store the location of the coefficient within a 4 4 or 8 8 block. Six bits are enough to store the 64 possible location values of an 8 8 block. The seventh bit is an extension bit that stores a 0 or 1 value indicating whether this coefficient has an extension value. The remaining 9 bits of the value store the 9 least significant bits of the coefficient level. In case 9 bits are not enough to store the coefficient level the extension bit is set to 1 and 16 additional bits are used to store the remaining bits required to represent the coefficient value. 16 additional bits may be more than are needed but using the same number of bits as the value facilitates representation as an array of shorts with extension values interspersed as needed.

An array of block count auxiliary arrays such as the array stores non zero coefficient count values for multiple macroblocks. For an entire picture the auxiliary buffer array is at least as large as 24 MBIN PIC bytes where MB IN PIC is the number of macroblocks in the picture. The auxiliary buffer array for a picture can be partitioned at the slice segment level and navigated to a current location by current location auxiliary buffer base location 24 starting macroblock address of slice segment . This facilitates access by multiple ED threads to the buffer at the same time.

After CABAC decoding of the coefficient levels within the sub blocks and blocks of the macroblock in a given plane Y U or V an additional bit is set to indicate whether any coefficients within the blocks uses an extension value. This flag makes decoding much faster when none of the coefficients uses an extension value.

Using compressed storage as shown in can provide substantial memory savings. These savings are especially important for multithreaded decoding when multiple frames are in flight. For example for test sequences of high definition content at 1920 1088 spatial resolution the storage requirements are cut down from 6 megabytes uncompressed storage to about 0.75 megabytes compressed packed storage per picture. A large proportion of this reduction is due to skipping of storage for insignificant zero value coefficient levels which are common. Moreover in practice most coefficient levels fit within 9 bits the use of extensions is rare.

In the worst case if every coefficient level has a non zero value and needs an extension there are 64 non zero levels per 8 8 block and 64 extension values. The amount of storage used is double the amount used for uncompressed storage. Such situations are extremely rare but the decoder keeps memory available in case it is needed.

The amount of intermediate storage needed for packed decoded coefficient levels varies depending on the complexity of the encoded video as well as bit rate and quality considerations. Allocating enough memory to a handle worst case situation is wasteful most of the time when far less memory is actually used.

In some embodiments a decoder dynamically grows the buffers used to store packed coefficient levels. The decoder fills a buffer fragment for example level after level for a block block after block for a macroblock and macroblock after macroblock for a segment. The decoder checks for the end of a packed buffer fragment periodically e.g. by checking every macroblock whether enough space remains for worst case macroblock storage or otherwise tracks available space in the fragment. If needed the decoder adds another buffer fragment to fill.

The decoder can allocate buffers on a slice by slice basis. If slices are small and the buffers are mostly unused however this is wasteful. Alternatively the decoder allocates buffers on a picture by picture basis segment by segment basis or other basis.

The pool of packed buffer fragments includes fragments such as the fragment array of which is an array of shorts that store packed coefficient levels. The fragments can all have the same size or they can have different sizes. In some implementations the packed buffer fragment size is set so that in most cases one fragment is enough to store the coefficient levels decoded in an ED task for a segment.

The pool includes free fragments available for adding to dynamically growing buffers. For example packed buffer fragments are allocated from the pool when necessary. When fragments are freed they are returned to the pool so that they can be reused for other packed buffers across multiple pictures.

In a buffer is implemented as a linked list of buffer fragments from the pool . Separate buffers are created for separate intra and inter passes of decoding. The intra buffer stores intra coefficient levels and the inter buffer stores inter coefficient levels. Alternatively a single buffer stores intra coefficient levels and inter coefficient levels.

In a single threaded mode two packed buffers 1 intra 1 inter per picture store the coefficient levels. In multithreaded mode the decoder may decode multiple segments in a picture in parallel. So the set of buffers includes two packed buffers 1 intra 1 inter associated with each of multiple worker threads. During an ED task for example a thread writes only to the buffers associated with it. For other decoding tasks e.g. MC INTRA LF multiple threads may read from a single buffer.

Using thread specific packed buffers helps delimit different portions of a packed buffer for different slices in a picture in advance without wasting storage as could easily be the case with slice specific buffers. Using separate thread specific packed buffers for segments also facilitates segment level multithreading. The number of threads is smaller than the number of possible slices organizing buffers in a thread specific manner gives an upper bound on the number of buffers that are used.

In H.264 reference model software when a decoder splits a decoded frame picture into field pictures e.g. to use in later decoding of other pictures the decoder allocates memory for the two split field pictures and performs expensive memory copy operations. This is an inefficient use of memory. A similar problem occurs when two decoded field pictures are combined into a single frame picture for output by allocating memory for the frame picture and performing expensive memory copy operations.

In some embodiments a decoder uses a single frame memory buffer to represent a video frame as well as two complementary top and bottom fields of the video frame. shows an example frame memory buffer for a frame. The frame buffer includes lines of sample values. A buffer structure for the top field includes pointers to the even lines of the frame in the frame buffer which facilitates access to the buffered top field. A buffer structure for the bottom field includes pointers to the odd lines of the frame in the frame buffer which facilitates access to the buffered bottom field. Another buffer structure not shown for the entire frame can include pointers to all lines of the frame in the frame buffer facilitating access to the frame as a whole.

The decoder writes fields into an appropriate frame buffer interleaving the lines of the field with lines of the complementary field from the start. This avoids extra memory copy operations from frames to fields and vice versa and conserves memory.

When the decoder decodes two complementary field pictures but outputs a single frame picture the decoder uses the single frame memory buffer to efficiently represent the field pictures and frame picture. An H.264 decoder generally outputs frame pictures even when the frame pictures are decoded as field pictures. Parameters in slice headers for the field pictures indicate whether the two field pictures are a pair of complementary fields. Two field pictures that are a pair are interleaved and put together as a frame picture not only for output purposes but also for reference. In some implementations the function Detect Field Picture Pair is used to detect whether two fields are a pair. When two field pictures are a pair they satisfy the logic in this function and are adjacent to each other in decoding order.

When two field pictures will share the same frame memory and the decoder pre interleaves them. The decoder makes pointers for the top field picture and bottom field picture point to the even and odd lines respectively in the frame size memory. This not only saves the additional memory for the combined frame picture but also avoids the memory copy operations.

When the decoder decodes a frame picture but splits it into complementary field pictures e.g. in the MBAFF or PICAFF code path to split the frame into reference fields the decoder uses the single frame memory buffer to efficiently represent the field pictures and frame picture. The decoder sets up pointers in the split field pictures and makes them point to the even and odd lines in the frame picture. This saves memory for the two split field pictures and save two substantial memory copy operations.

In some embodiments a decoder with GPU uses one or more memory usage innovations during GPU decoding. Some of these innovations relate to how reference pictures are represented in memory including 

One way to represent reference pictures in memory for GPU decoding is to simply allocate memory and organize the reference pictures in adjacent extents of memory. The reference pictures can then be accessed with normal memory access operations at their respective locations. For some GPU architectures this is an inefficient use of memory.

According to one reference picture storage innovation a decoder with GPU represents a reference picture as a texture in memory. Using a texture facilitates hardware support for fast random access texture operations across the horizontal x and vertical y dimensions of a reference picture image plane. When the decoder decodes a picture for example the decoder can use the fast texture operations to access the reference picture in memory during motion compensation.

When a decoder with GPU uses multiple reference pictures if the multiple reference pictures are simply put in memory memory access patterns may be inefficient. In one approach to addressing this problem the decoder sorts the blocks of a current picture being decoded according to reference picture used. The decoder performs motion compensation in multiple passes for the different reference pictures used one pass per reference picture. For example in a first pass the decoder performs motion compensation for blocks that use a first reference picture in a second pass the decoder performs motion compensation for blocks that use a second reference picture and so on. While this improves memory access patterns it also involves additional computation and switching between passes.

According to another reference picture storage innovation a decoder with GPU represents multiple reference pictures in an image array as a 3D texture. The 3D texture supports fast random access to different reference pictures along its depth z dimension and also supports fast random access within individual reference pictures. When the decoder decodes a picture for example the decoder can use the fast texture operations to access any of the reference picture in memory during motion compensation.

According to another reference picture storage innovation for GPU decoding complementary reference fields are stored as alternating rows of an image plane in a 3D texture. The GPU uses texture operations to access the top field even lines the bottom field odd lines and or a reference frame including the top and bottom fields even and odd lines . For example given a starting row y the GPU accesses rows in increments of two y 2 y 4 etc. to retrieve sample values for an individual field. Or to retrieve sample values for the reference frame the GPU accesses rows in order from the starting row. In some implementations when the GPU performs decoding operations for a given picture type frame or field or macroblock type field coded or frame coded it automatically accesses the correct rows of the field frame representation to retrieve sample values incrementing the rows to access them appropriately. The field frame representation efficiently uses memory for reference pictures by avoiding redundant storage of fields and frames as in the non GPU implementations . Moreover when the fields frame are stored as an image plane in a 3D texture for GPU decoding it also improves the efficiency of motion compensation by making access operations simpler and faster.

In many implementations a GPU unlike a CPU is single threaded. The GPU decodes pictures in coded video bit stream order. The GPU can employ parallel processing by splitting up certain decoding tasks such as an inverse transform and performing them in parallel for a particular segment or picture but from picture to picture the decoding occurs in serial order.

For purposes such as resource allocation even though pictures are decoded in serial order by the GPU the decoder scans ahead e.g. with a CPU using PED in the coded video bit stream. In some implementations the decoder orders tasks in a FIFO GPU command queue. Various commands in the GPU command queue can affect how the GPU uses memory or other resources. One task at a time and in serial order the GPU removes tasks and executes primitives for the tasks potentially changing how the GPU uses memory or other resources.

The GPU command queue can include commands with potentially inconsistent resource usage patterns for multiple pictures in flight during decoding. For example the decoder can scan ahead in the bit stream through pictures having different formats e.g. resolutions different ways of identifying reference pictures in memory or other different patterns of using resources. Resource usage patterns can be inconsistent from picture to picture in that they cause the GPU to use the same resource in different conflicting ways. Since the GPU removes commands one at a time in serial order however the GPU uses memory and other resources consistently for any given task primitive.

According to one aspect of the GPU resource management innovations a decoder represents multiple resource usage patterns for multiple commands in a GPU unit command queue for multiple pictures in flight during decoding. For example the resource usage patterns are memory partitions or slot assignments for reference pictures. The decoder decodes pictures in serial coded order with a GPU regulating memory based at least in part upon the multiple resource usage patterns.

According to another aspect of the GPU resource management innovations a decoder receives a coded video bit stream that includes encoded video for multiple pictures in serial coded order. The decoder scans ahead in the coded video bit stream to determine multiple resource usage patterns for the pictures and tracks the resource usage patterns e.g. in a GPU command queue that tracks commands and represents the resource usage patterns . The tracked resource usage patterns include at least some inconsistent patterns in flight during decoding. Typically each of such inconsistent patterns is valid during one part of decoding but invalid during a different part of decoding. For example the inconsistent patterns include different memory partitions for reference pictures. Or the inconsistent patterns include different slot assignments for reference pictures. The decoder with GPU performs decoding operations on the pictures in serial coded order e.g. as reflected in the GPU command queue .

As another example of resource usage patterns the decoder allocates different data structures for different formats resolutions of pictures. When decoding finishes for the last picture encountered thus far for a particular format the decoder can free memory used for the structures for pictures of that format.

In some embodiments for memory used by a GPU to store reference pictures a GPU command queue represents different memory partitions in flight including potentially inconsistent memory partitions. The decoder efficiently allocates and partitions GPU memory based on information in a GPU command queue.

In some implementations a GPU uses an image array to store reference pictures and potentially other decoded pictures as well. For example the decoder allocates an extent of memory to the GPU and the memory is partitioned to store 16 standard definition reference pictures and one standard definition picture being decoded. The decoder uses the partitioned memory when decoding standard definition pictures of a video sequence potentially having multiple pictures in flight. Later the pictures switch to high definition and the memory is partitioned to store four high definition reference pictures and one high definition picture being decoded. The decoder uses the re partitioned memory when decoding the high definition pictures.

The GPU uses the same image array for either standard definition or high definition decoding re partitioning the memory as appropriate when a new format is encountered. The decoder e.g. a CPU in a PED stage tracks format changes and manages the GPU command queue to reflect the changes. The GPU command queue which typically includes commands for multiple pictures in flight can thus include memory partitions for pictures in different formats. The memory partitions may be inconsistent but the GPU only uses memory partitioned one way the correct partition for current decoding at a time due to serial execution of commands from the GPU command queue.

In theory for some number e.g. 32 of pictures in flight the resolution might change several times even on a picture by picture basis. If pictures could be decoded in any order by the GPU this would complicate the management of memory used by the GPU when the memory is partitioned in different ways for different resolutions of reference pictures. Since the GPU decodes a single picture at a time in coded order however the decoder can more aggressively prune pictures from memory compared to multithreaded decoding approaches in which more pictures are buffered.

In some implementations the GPU maintains separate reference and output pictures. The reference pictures are used by the GPU and not output.

When driving a pipelined GPU multiple pictures in flight the decoder e.g. with a CPU in a PED stage can determine which reference pictures are reused from picture to picture as pictures are scanned and assimilated into the GPU command buffer. When a picture is scanned the decoder considers for example the picture s private DPB. Work for multiple pictures can be enqueued at one time in the GPU command buffer and the work can use memory inconsistently. Different commands can involve writes to or reads from the same memory location but relate to work for different pictures at the location. The decoder can effectively handle this potential inconsistency because the GPU processes commands in the GPU command queue in serial coded order and there is a maximum number of reference pictures e.g. four for high definition or 16 for QCIF . Changes to reference picture ordering or assignment are processed serially and according to expected limits on buffer size which facilitates pruning of reference pictures from memory.

In particular reference indices typically differ at different times during decoding. For pictures and for example picture can use reference pictures A B C and D. When work for picture is passed to the GPU the decoder marks where picture will be stored after it is decoded. When picture is decoded if reference picture A is no longer used in decoding the GPU writes picture to where picture A was. Because the GPU processes pictures in serial order the decoder can safely determine when no other picture relies on reference picture A and reference picture A can be overwritten.

For example a decoder with CPU using PED tracks the state of a DPB at the point it is parsing in a coded video bit stream. A picture in effect has its own view of the DPB and the PED stage tracks the live DPB. With this information the decoder pre assigns image array slots for pictures for the GPU to use. The decoder essentially decides where a next picture will be stored when it is decoded e.g. to slot or . The decoder can also determine when a reference picture is no longer used and thus determine when the reference picture can be overwritten during serial order decoding by the GPU. The GPU command queue in effect stores references to memory that the GPU will write to which the GPU may or may not have already written to but which will be available to the GPU when the command in question can execute and calls are made to the memory. The GPU performs work using the prospectively assigned slots in the image array at the appropriate times storing pictures in the appropriate slots in the memory array accessing the pictures and overwriting the pictures. This efficient reuse of image array slots as determined by DPB bumping logic in the PED stage facilitates memory management for the GPU.

When a decoder is allocated memory from system heap e.g. with the memory allocation routine malloc the system heap often becomes fragmented over time. With multithreaded decoding the problem of gradual fragmentation can be even worse.

In some embodiments a decoder imposes memory pool organization on top of a memory heap to reduce fragmentation. When the decoder processes the coded video bit stream or performs other decoding tasks it uses memory fragments of the same size for a particular type of operation. When done with the data in a memory fragment the decoder releases the memory fragment back to the pool.

In some implementations the decoder uses different pools for different data structures sets of data structures or decoding tasks. For example suppose that for a GPU setup task for a picture the decoder needs 1 MB of memory for the structures used. Instead of using malloc the decoder requests and is allocated an appropriately sized memory fragment from a pool of such memory fragments for GPU setup tasks. The GPU task populates the structures in the memory fragment and various other decoding tasks use the structures. Eventually the decoder releases the memory fragment back to the pool invalidating the data in it. From the pool the memory fragment can be allocated in later decoding. Allocation through such memory pools helps reduce memory fragmentation.

Example memory fragment sizes for PED and ED are 3 MB and 8 MB respectively. More generally different pools are specialized for different tasks and types of structures. For the memory fragments structure lifetime is mapped to lifetime of the data in the structures in the memory fragment.

In some embodiments a decoder uses other optimizations to improve performance in certain scenarios. These optimizations have some general themes but often are targeted to specific platforms or applications.

According to one optimization in some implementations the decoder uses a single instruction multiple data SIMD structure for an inverse transform according to the H.264 standard. In the H.264 standard a 4 4 inverse transform consists of the same set of instructions being executed on each of the four rows columns of the block. The transform can be carried out using 16 bit addition subtraction and shift arithmetic.

A 128 bit SIMD performs a maximum of 4 32 bit instructions 8 16 bit instructions or 16 8 bit instructions in parallel. To enhance parallelism an entire SIMD vector is used. Since the SIMD vectors can perform 8 16 bit operations at once but the inverse transform uses only four parallel operations for four rows or columns the decoder combines two 4 4 transforms into a single 8 4 inverse transform that uses one set of vector instructions.

Regardless of whether each block consists of sub blocks of 4 4 4 8 8 4 or 8 8 the inverse transform is done on the entire 8 8 block. By combining the inverse transforms of two 4 X sub blocks the number of transforms done can be reduced by half. Furthermore because there is no dependency between two adjacent X 4 sub blocks within a block they can be combined into a single function for more efficient scheduling and less function call overhead. Combining these optimizations allows calls to a single 8 8 inverse transform function for each block regardless of type of sub blocks within each block.

For the memory layout of the buffers used in the inverse transform a single vector load per row loads both 4 X sub blocks in the correct layout. This reduces the number of vector loads needed for the combined 8 8 transform. It also helps avoid additional vector loads and manipulation for setting the vectors up correctly which would result in performance loss.

According to another category of optimizations branches are eliminated in the code base of the decoder to improve memory performance. This is done for example by identifying code with numerous branches and replacing such code with a state machine or table based lookup mechanism.

According to still another category of optimizations dynamic shifts which are costly operations in some architectures are replaced with other operations. For example dynamic shifts are identified in the code and replaced by unrolling conditional logic and or using a state table.

In some embodiments a decoder operates on GPU platform or combined CPU GPU platform. Various decoding processes are mapped to the GPU including inverse transform inverse quantization motion compensation intra prediction deblocking and film grain noise addition.

In general a given decoding process can be mapped onto the GPU according to the following guidelines. The smallest unit or quantum of work for the decoding process is defined. The quantum does not depend on other quanta. Having small independent units for the quanta helps increase parallel processing in the GPU.

The inputs to the quantum for the decoding process are then defined. The inputs can include data streams images and or constants. In many implementations defining inputs as sequential reads improves performance. The outputs of the quantum are also defined. In some implementations the outputs are limited to four separate buffers and defining outputs as sequential writes improves performance even more than sequential reads .

Then an optimal balance between register usage memory access patterns and the number of passes through the data is found for the decoding process depending on target architecture and or expected usage patterns. For example an ideal shader program is configured to have minimal register usage minimal passes through the data and sequential memory access patterns in both input and output. In practice one or more of such constraints may be loosened. Where available native SIMD operations can be used to improve performance. Branches such as conditional logic can be replaced with other logic such as table lookups to improve performance.

Finally if data processed in the decoding process have data dependencies a wave approach can be applied to increase parallelism in processing with the GPU. The wave approach can be static or dynamic.

The intra prediction and loop filtering innovations using waves address dependencies that complicate parallel decoding with a GPU. The other innovations address memory consumption and other resource issues. In one H.264 implementation the GPU innovations collectively facilitate real time H.264 decoding of high definition content with a software only decoder. Before describing these innovations however example GPU architectures and CPU GPU interfaces are described.

In some embodiments the decoder operates in conjunction with a graphics processing unit in an architecture such as described herein. For purposes of video decoding the graphics processing unit is in some respects used as a general purpose unit. and the accompanying description illustrate features of example GPU architectures. Alternatively a decoder runs on a GPU architecture having other and or addition features.

The details of the GPU architecture vary depending on implementation. For example different implementations have different numbers of arithmetic logic units ALUs different numbers of registers different instructions different cycle timing and or different memory configurations.

The GPU architecture includes a shader processor with vertex fetch registers and ALUs shared between the vertex processor and pixel processor . The vertex fetch registers can be converted to texture fetch registers. Each of the ALUs is capable of running x identical instructions from x contexts executing in lockstep every y cycles.

Conventionally a shader is a graphics program that runs on the shader processor. For video decoding a shader is a simple program that runs on either the vertex processor or pixel processor . Shader programming is done for example using a high level shader language or microcode assembly language.

A primitive is a single set of data for a decoding pipeline. The pipeline is for example one vertex shader plus one pixel shader plus state for the shader units primitive assembly and blend unit etc. Even when a primitive includes two shaders the shader for the pixel processor can be a dummy no op shader when only the vertex processor is used.

In the GPU architecture a shader reads its input directly from main memory through a set of streams or textures. A pixel shader can also read data from the outputs of a primitive assembly module . A shader can accept as input various combinations of streams and textures. In general streams are useful for reading arrays of data structures where a given data structure can consist of heterogeneous data types. On the other hand textures are useful for reading 1D 2D or 3D images or arrays sometimes termed stacks of 2D images or cubic images where an image consists of homogeneous data types.

A shader can write its results directly to main memory using a memory export command. The memory export function allows the shader to write final or partial results to main memory without going through the more expensive dynamic memory to the main memory .

The vertex processor and pixel processor for practical purposes can be treated as a series of highly parallel execution units. Two features of the architecture facilitate parallelism. First the shared ALUs can operate as parallel execution units because of a deep pipeline and multithreading capability in each of the vector processor and pixel processor . The pipeline can effectively convert the ALUs with many execution units each to behave like ALUs with even more execution units each. The multithreading capability allows resources freed up by one primitive to be used by the next primitive which helps to hide memory latency from reads and writes. Second each of the execution units is capable of executing SIMD like instructions. Given this potential for parallel processing across execution units the GPU runs efficiently when each primitive runs the same shader on hundreds or even thousands of pieces of data simultaneously. When this parallel processing capacity is coupled with high memory bandwidth a single GPU completes some tasks quicker than three CPU cores working in unison on the same tasks.

The shader functional model applies for either a vertex processor or a pixel processor . The vertex processor and pixel processor can be implemented separately. Or they can share hardware that is reconfigured by the GPU on the fly to perform vertex processing or pixel processing in which case fetch units and ALUs are shared by the processors and dynamically allocated based on current workload. The main differences between the processors relate to how they input and output data. In example implementations decoding processes are mapped to a vertex shader running on the vertex processor to take advantage of how the vertex processor handles input. A vertex shader can be programmed using a high level shader language or microcode assembly language.

Calculations in an example shader use floating point representation and floating point arithmetic. Typical video decoding processes e.g. inverse transform or motion compensation as in the H.264 standard call for pixel manipulation and integer operations however. A set of integer functions macros facilitate pixel manipulation for the video decoding processes.

In addition the example shader use registers. All shaders in a shader unit ALU share these registers however as more registers are used to run a single shader fewer shaders in the unit run in parallel.

The example shader also supports static and dynamic branches functions and loops. Dynamic predication branches and loops are very costly however. For example in some cases a shader will take both branches of an if else statement thereby doubling the workload of the shader. Dynamic predication branches and loop are thus replaced in many cases for example with table lookups.

Finally one pair of vector and scalar instructions is executed per cycle. The number of instruction pairs in a shader is limited in some implementations. Complex functions such as deblocking can be written as several smaller shaders e.g. CalcBoundaryStrength DeblockVerticalEdges DeblockHorizontalEdges etc. to fit in program memory or as is more often the case for performance reasons. For example a long process can be split into sub processes that are parallelizable.

The example shader can use a table of constants. This is particularly useful for static tables such as user defined scaling lists used in inverse quantization. Finally a vertex shader has pointers to streams and or textures.

A vertex shader reads from memory using a stream and or texture. Streams and textures flexibly support a variety of formats e.g. float integer short sign scaled etc. . In particular streams are useful for reading arrays of data structures in which each data structure may hold heterogeneous elements. For example a shader can stream in macroblock data where each macroblock element consists of a mixture of unsigned chars and shorts for the parameters mb type mb field cbp etc. Textures on the other hand are useful for reading arrays of homogeneous data such as arrays of unsigned chars. For example a shader reads pixel data such as references images from the decoded picture buffer as texture.

A texture is specified by a texture sampler 3 pointers . Textures support wrapping clamping and mirroring at the hardware level. Automatic clamping can be used to handle unrestricted motion vectors in motion compensation. If an unrestricted motion vector points to a region outside the bounds of the reference picture the texture can automatically clamp the return results without the need to pad the reference picture. Textures also automatically support bilinear and anisotropic filtering. Bilinear filtering can be used for fast pel and pel interpolation in motion compensation. A cache supports reads from textures and is optimized for localized random access reads.

The example vertex shader can directly write to main memory using a specialized function MemExport. Writes using MemExport are especially effective if done sequentially. MemExport writes directly to main memory and does not automatically maintain cache coherency between the GPU read cache and CPU caches. It is up to the programmer to maintain this cache coherency using flush and store commands for the CPU caches and invalidate commands for the GPU caches.

As for shader hardware implementation an example shader processor contains vertex fetch units and ALUs shared between the vertex and pixel processors . The ALUs are also known as shader units and each contains execution units. The shader units run in parallel to each other. Within a given shader unit x simultaneous threads run in lockstep even if not used. Execution units are fully independent and do not use feedback from other execution units. For branches and loops the threads typically execute all the branches and loop iterations to finish all of them. It is efficient if all threads follow the same path branches can skip quickly .

In many decoding processes one tradeoff is to use simpler shaders that use fewer registers but make more passes through the input data. For example a shader for pel and pel interpolation in motion compensation can be implemented using large tables to hold 2D filter values running a 2D convolution on input pixel data in a single pass but using lots of registers to hold the input data and the 2D filter values. Alternatively the shader uses multiple passes for motion compensation and breaks the interpolation into several dependent passes one for Y2 pel interpolation and another one for pel interpolation. This illustrates the tradeoff between register usage parallelism and multi pass processing multiple reads writes . As a general rule as long as the number of passes is small gains in parallelism trump the greater number of dependent read writes and the shader will run faster on the GPU.

In some embodiments a CPU and GPU coordinate across a communications interface to decode video. Performance improves when decoding work is effectively partitioned between CPU core processors and the GPU with CPU processes and GPU processes running asynchronously.

In an example implementation decoding tasks are partitioned such that threads on CPU cores perform entropy decoding and the GPU performs remaining decoding tasks such as inverse transform inverse quantization motion compensation intra prediction deblocking and film grain noise addition. Entropy decoding especially CABAC decoding is serial in nature involving decisions and tables updated on a bit by bit basis. A CPU that contains a built in branch predictor and can handle read modify write operations on main memory millions of times per second is well suited for this serial processing. On the other hand the GPU is well suited for inverse transform operations that can be easily parallelized over an entire image of transform coefficients e.g. since each 4 4 or 8 8 inverse transform is independent to each other . The GPU can efficiently operate on multiple 4 4 or 8 8 blocks of data simultaneously.

In some implementations the GPU is a FIFO device. The CPU generates tasks corresponding to primitives for the GPU and inserts them in a FIFO command buffer queue. The GPU extracts primitives from the command buffer one at a time and executes them in serial order. The CPU and GPU maintain synchronization for example using fences. A fence is a marker inserted into the command buffer by the CPU. The fence is triggered once the GPU reaches it. Synchronization helps the CPU track when a picture has been completely processed by the GPU in order to reuse resources e.g. PicHolder structures and output the picture subject to display ordering constraints. When a fence is signaled the picture has been completely decoded. The fence is inserted after the last video decode algorithm e.g. film grain noise addition. The picture is then copied into an output buffer and marked as available for reference in the decoded picture buffer.

In some implementations the GPU is limited in how it uses memory. The GPU cannot do read modify write operations on main memory or read from memory a value that has been written by the same primitive. Working data is stored in the registers of each execution unit and there are not transfers of data between the execution units. When reading from memory the GPU has two small caches. Reading contiguous chunks of memory make effective use of the caches. The GPU reads directly from main RAM bypassing CPU caches. When writing to memory the GPU uses a write combine strategy bypassing the GPU read caches and the CPU caches. When implementing an algorithm for the GPU care is taken to understand what memory is resident in which cache and act accordingly flush or store to avoid data corruption.

In some embodiments a decoder uses inverse transform operations mapped to a GPU platform. For example integer transforms according to the H.264 standard are mapped to a GPU that natively supports floating point operations and matrix operations. The H.264 standard specifies two types of transforms a 4 4 transform used in luma 4 4 and chroma 4 4 modes and an 8 8 transform used in luma 8 8 mode. Features of the example H.264 GPU mapping include 

Alternatively the H.264 GPU mapping includes other and or additional features. For another type of transform or other type of GPU the mapping can include more or fewer types different types different quanta of work and or different operations.

The decoder then performs a three pass inverse transform with the GPU one pass for each transform coefficient type. The order of the three passes depends on implementation. Different shaders can implement the inverse transforms for the different passes.

In the luma 4 4 pass the decoder performs a fast 4 4 inverse transform on the luma 4 4 blocks in a picture. For example the decoder uses a 4 4 inverse transform implementation as shown in and described below. Alternatively the decoder uses another inverse transform implementation. For the luma 4 4 pass the quantum of work is four 4 4 blocks of transform coefficients.

In the chroma 4 4 pass the decoder performs a fast 4 4 inverse transform on the chroma 4 4 blocks in a picture. For the chroma 4 4 pass the quantum of work is two 4 4 blocks at a time one from the U channel and one from the V channel.

In the luma 8 4 pass the decoder performs a fast 8 8 inverse transform on the luma 8 8 blocks in a picture. For example the decoder uses an inverse transform implementation with matrix multiplications and matrix additions. Alternatively the decoder uses another inverse transform implementation. For the luma 8 8 pass the quantum of work is one 8 8 sub block of transform coefficients.

Alternatively instead of classifying transform coefficients for a picture and performing multiple passes across the picture the decoder operates on a slice by slice or other basis.

The decoder receives transform coefficients from video e.g. from inverse quantization and classifies the transform coefficients into multiple types. For example an H.264 decoder classifies the coefficients into luma 4 4 chroma 4 4 and luma 8 8 types. Alternatively e.g. for a different standard the decoder classifies the transform coefficients into other and or additional types.

The decoder with a GPU then performs inverse transforms on the transform coefficients in one of multiple passes that correspond to the multiple types respectively. Each of the multiple types has a quantum of work associated with it. Example quanta for an H.264 GPU mapping are described above. Alternatively e.g. for a different type of GPU the quanta are different to more efficiently use a different number of registers. For a different transform and or GPU the quanta are defined to be small independent units that increase parallelism on the architecture. The decoder determines whether to continue with another pass and if so performs the next inverse transform pass.

In some implementations a GPU uses an implementation of 4 4 inverse transform as follows for luma 4 4 blocks. The decoder with the GPU partitions a picture into 16 16 macroblocks and partitions the macroblocks into 4 4 blocks. For the inverse transform each of the 4 4 blocks is independent of the other 4 4 blocks and the GPU can perform the inverse transforms for different blocks in parallel.

The shader then performs an inverse transform scaling and transpose on each block. The GPU shaders natively support 4 4 matrixes and fast 4 4 matrix operations such as addition multiplication and transposition. As such the 4 4 fast inverse transform mode is implemented in terms of 4 4 matrix multiplications and additions. shows pseudocode for example bit exact matrix equations for the 4 4 inverse transform mode.

To start the input matrix A is multiplied by the transform matrix T using a native matrix multiplication and the result is stored in the intermediate matrix M. Rows and of the intermediate matrix M are adjusted by a constant matrix factor 1 1 1 1 before scaling the results by a factor of and flooring the scaled values. This essentially results in integer values in the intermediate matrix M.

Next the decoder multiplies a transpose of intermediate matrix M with the matrix T using a native matrix multiplication and the result is stored in the intermediate matrix M. The transpose operation completes the pre and post multiplication of the input data with the 4 4 transform basis vectors. Rows and of M are adjusted by the constant matrix factor before scaling by a factor of and flooring the final 4 4 results which are put in the output matrix B.

As shown in the decoder exports output data as 64 contiguous signed shorts e.g. blocks . . . in row order . Either the input reads or output writes can be sequential. For the architecture of the GPU in the example implementation making the writes sequential has greater performance benefits than making the reads sequential.

The GPU uses an analogous inverse transform implementation for 4 4 chroma blocks with a smaller input quantum but correspondingly higher parallelism. The GPU uses native matrix multiplication operations and native matrix addition operations for 4 4 chroma blocks and for luma 8 8 blocks.

In some embodiments a decoder uses inverse quantization operations mapped to a GPU platform. For example inverse quantization operations according to the H.264 standard are mapped to a GPU with constant registers that can hold user defined scaling lists. Features of the example H.264 GPU mapping include 

Alternatively the H.264 GPU mapping includes other and or additional features. For another type of quantization operation or other type of GPU the mapping can include more or fewer types different types different quanta of work and or different operations.

In the example H.264 GPU mapping a decoder performs inverse quantization in a framework with separate processing paths for different inverse quantization types according to the H.264 standard. In the framework a decoder classifies inverse quantization operations for a picture into five types for the GPU. In particular a classifier module classifies inverse quantization operations for the picture into luma DC coefficient chroma DC coefficient luma 4 4 block AC coefficient luma 8 8 block and chroma 4 4 block AC coefficients types.

The decoder then performs five pass inverse quantization with the GPU one pass for each inverse quantization operations type. The order of the five passes depends on implementation. Different shaders can implement the inverse quantization for the different passes.

In each of the respective passes the decoder implements the inverse quantization operations generally as specified in the H.264 standard potentially using floating point operations and matrix operations in places to expedite processing with the GPU.

In some GPU implementations the decoder uses a set of constant registers to hold a scaling list and or normalization adjustment matrix for inverse quantization operations. The H.264 standard and some other standards allow a user to define perceptual weights for transform coefficients. The scaling list is for example a user defined perceptual quantization matrix signaled in a picture header. Or the scaling list is a default scaling list having default perceptual weights. In some GPU implementations the set of constant registers is an array of 256 4D registers.

The quanta of work for the respective inverse quantization types facilitate parallel processing in each of the respective passes. Thus in the luma DC pass the GPU performs inverse quantization in parallel on different 4 4 blocks of DC coefficients. In the chroma DC pass the GPU performs inverse quantization in parallel on different 2 2 blocks of DC coefficients. The GPU similarly performs inverse quantization in parallel on multiple blocks of AC coefficients having the defined quantum size within the luma 4 4 pass luma 8 8 pass or chroma 4 4 pass.

Alternatively instead of classifying inverse quantization operations for a picture and performing multiple passes across the picture the decoder operates on a slice by slice or other basis.

The decoder receives transform coefficients from video e.g. from an entropy decoding task and classifies inverse quantization operations for the transform coefficients into multiple types. For example an H.264 decoder classifies the inverse quantization operations into luma DC chroma DC luma 4 4 AC luma 8 8 and chroma 4 4 AC types. Alternatively e.g. for a different standard the decoder classifies the inverse quantization operations into other and or additional types.

The decoder with a GPU then performs inverse quantization on the transform coefficients in one of multiple passes that correspond to the multiple types respectively. Each of the multiple types has a quantum of work associated with it. Example quanta for an H.264 GPU mapping are described above. Alternatively e.g. for a different type of GPU the quanta are different to more efficiently use a different number of registers. For a different inverse quantization operation and or GPU the quanta are defined to be small independent units that increase parallelism on the architecture. The decoder determines whether to continue with another pass and if so performs the next inverse quantization pass.

In some embodiments a decoder uses motion compensation and fractional interpolation operations mapped to a GPU platform. For example fractional interpolation operations according to the H.264 standard are mapped to multiple passes with a GPU. Features of the example H.264 GPU mapping include 

Alternatively the H.264 GPU mapping includes other and or additional features. For another type of interpolation operations or other type of GPU the mapping can include more or fewer types different types different quanta of work and or different operations.

Motion compensation according to the H.264 standard is computationally complex and has high memory access requirements. A 4 4 block can be assigned a unique motion vector that has a horizontal x component and vertical y component. The two rightmost bits of each motion vector component indicate the fractional sample position in the reference picture the value for the two bits indicates an integer position the value indicates a half pel position and the value or indicates a quarter pel position. The high computational complexity of motion compensation is due largely to the interpolation used to generate sample values at fractional sample positions in reference pictures. For example half pel offset positions are calculated by convolving the reference picture with a separable one dimensional 6 tap filter 1 5 20 20 5 1 in the horizontal direction and in the vertical direction.

To complicate matters in H.264 different 8 8 blocks can be assigned different reference picture indices referencing different reference pictures. This can result in high memory access costs and inefficient memory access patterns when for example many different 8 8 blocks point to many different reference picture in a decoded picture buffer. In a worst case scenario a motion compensation shader fetches pixel data from two vastly different positions in memory for each adjacent 8 8 block in a series of blocks with the random memory access pattern effectively thrashing the GPU read cache.

In the example H.264 GPU mapping the quantum of work for GPU motion compensation is a single 8 8 block. For motion compensation and fractional interpolation an 8 8 block is independent from other blocks. An 8 8 block uses one motion vector for each of its four 4 4 blocks up to four different motion vectors and uses a single reference picture index regardless of how the block and its containing macroblock are internally partitioned for motion compensation. The GPU effectively performs parallel processing across different 8 8 blocks in motion compensation tasks such as fractional interpolation. Alternatively for a different motion compensation operation fractional interpolation operation and or GPU the decoder uses a different quantum of work.

In the example H.264 GPU mapping the decoder allocates a contiguous image array to hold the decoded picture buffer. A given motion compensation shader maps the image array to a 3D texture. Using a 3D texture facilitates hardware support for fast random memory access across the horizontal x and vertical y dimensions of a reference picture image plane and it also facilitates hardware support for fast random memory access to different reference picture image planes along the depth z dimension of the 3D texture for the decoded picture buffer. Alternatively the decoder maps reference pictures to a different memory configuration.

In some implementations integer MV block center pel MV block and off center pel MV block types are used as follows. An integer MV block is an 8 8 block with motion vector s e.g. for the 4 4 blocks that reference integer sample positions e.g. G H M and N in . An off center MV block is an 8 8 block with motion vector s e.g. for the 4 4 blocks that reference certain fractional sample positions not dependent on the value at position j. This includes positions a b c d e g h m n p r and s. A center MV block is an 8 8 block for remaining cases. For these remaining cases at least one motion vector for an 8 8 block e.g. internal 4 4 block references sample values at position f i j k or q. So an 8 8 block for which each 4 4 block points to position f i j k or q is classified as a center MV block. An 8 8 block for which different 4 4 blocks point to a mixture of integer positions center positions such as j and off center positions such as c is also classified as a center MV block. Alternatively the MV block types have different definitions.

The decoder then performs three pass motion compensation with the GPU one pass for each motion vector type. The order of the three passes depends on implementation. Different shaders can implement the motion compensation and fractional interpolation for the different passes.

In the integer MV pass the decoder with GPU performs fast integer pel fetches from reference pictures in memory. For example for 4 4 blocks of an 8 8 block the decoder simply fetches sample values from a reference picture stored as an image plane in a 3D texture. Alternatively the decoder uses another implementation.

In the center MV pass the decoder with GPU performs fast center MV motion compensation . For example the decoder uses a fast center MV vertex shader as described below. Alternatively the decoder uses another shader for center MV motion compensation.

In the off center MV pass the decoder with GPU performs fast off center MV motion compensation . For example the decoder uses a fast off center MV vertex shader as described below. Alternatively the decoder uses another shader for off center MV motion compensation.

Alternatively instead of classifying blocks for a picture and performing multiple passes across the picture the decoder operates on a slice by slice or other basis.

Tests involving the sample video sequences Yozakura Tallships and Choochoo illustrate benefits of a multi pass approach that separates types of fractional sample interpolation. Yozakura is a high definition H.264 MBAFF bit stream that is difficult to decode in real time on many hardware architectures. The number of pel and pel motion vectors decoded per frame for Yozakura is much higher than Tallships and Choochoo. One reason Yozakura is tough to decode is the large number of interpolation operations needed for motion compensation per frame. For typical frames Yozakura uses twice as many interpolation operations per frame than Tallships and it uses 3 times as many interpolation operations per frame as Choochoo. Not all interpolation operations are the same in complexity for the GPU however. In particular off center pel interpolation can be performed much faster than center pel interpolation which illustrates a benefit of separating these two types of operations.

The decoder receives motion vectors for blocks and classifies the blocks into multiple motion vector types. For example an H.264 decoder classifies the blocks into integer MV center pel MV and off center pel MV types. Alternatively e.g. for interpolation according to a different standard the decoder classifies the blocks into other and or additional motion vector types.

The decoder with a GPU then performs motion compensation for the blocks in one of multiple passes that correspond to the multiple motion vector types respectively. Each of the multiple motion vector types has a quantum of work associated with it. Example quanta for an H.264 GPU mapping are described above. Alternatively e.g. for a different type of GPU the quanta are different to more efficiently use a different number of registers. For a different interpolation and or GPU the quanta are defined to be small independent units that increase parallelism on the architecture. The decoder determines whether to continue with another pass and if so performs the next motion compensation pass.

In some implementations the decoder runs a GPU shader for integer MV blocks using reference picture indices to identify image planes in a 3D texture for the decoded picture buffer fetching sample values as texture fetch operations and returning results in arrays of predicted blocks. The GPU shader for integer MVs is fast not performing sample interpolation. The decoder then runs a GPU shader that implements motion compensation and fractional interpolation for center MV blocks returning results in arrays of predicted blocks. Finally the decoder runs a GPU shader that implements motion compensation and fractional interpolation for off center MV blocks returning results in arrays of predicted blocks.

In some implementations a GPU uses a specialized vertex shader routine for off center MV motion compensation fractional interpolation and uses a specialized vertex shader routine for center MV motion compensation fractional interpolation.

An example vertex shader for center MV motion compensation performs motion compensation and fractional interpolation on a block by block basis for multiple 4 4 blocks in parallel. For a given 4 4 block the shader uses a 9 9 block of sample values to have the support for filtering with the 6 tap filter. The 9 9 block includes the 4 4 block starting on the third row down third column from the left to support the 6 tap filter at the 16 j positions throughout the 4 4 block. The shader loads the 9 9 block of sample values as needed.

In terms of when computing a sample value at position j or position f i k or q which depends on the value at j the shader computes sample values at positions aa bb b s gg and hh or cc dd h m ee and ff in a first stage then computes the value for position j using un normalized first stage values. The shader can store intermediate first stage values e.g. un normalized intermediate pel offset values to use in other interpolation operations.

An example vertex shader for off center MV motion compensation performs motion compensation and fractional interpolation on a block by block basis for multiple 4 4 blocks in parallel. For a given 4 4 block the shader uses 78 input samples and does not buffer intermediate results.

Generally reference pictures are stored in an array of buffers indexed in memory. When a decoder adds or deletes a reference image the data in the buffer changes. When the decoder performs other DPB management tasks it reorders pointers to the buffers. The example shaders organize reference pictures as image planes in a 3D texture and access the reference picture data using texture fetch operations.

In some implementations the decoder with GPU tiles data for 4 4 blocks. In motion compensation the decoder computes sample values for 4 4 blocks in memory not rows of sample values. Tiling of 4 4 blocks in intermediate processing can help improve cache locality. Reference field data can be kept in an interleaved manner in a single frame buffer or reference fields can be buffered separately from corresponding reference frames.

In some embodiments a decoder uses intra prediction operations mapped to a GPU platform. For example the decoder organizes intra blocks as dynamic waves and performs intra prediction on a wave by wave basis. Features of the example H.264 GPU mapping include 

In general the term intra prediction refers a spatial prediction mode in which redundancy between adjacent blocks of the same picture is exploited. The H.264 standard specifies four different intra macroblock types I 4 4 I 8 8 I 16 16 and I PCM. For the I PCM macroblock type raw Y U and V values are coded into the bit stream. Intra prediction is simply a copy operation handled before other intra prediction steps. For the other intra macroblock types predicted sample values are calculated for a 4 4 block for I 4 4 type 8 8 block for I 8 8 type or 16 16 block for I 16 16 type using a set of pixel values from the left macroblock above left macroblock above macroblock and or above right macroblock. These dependencies reduce the number of primitives separate sets of data that a GPU shader can execute in parallel within a wave for intra prediction.

More specifically the intra prediction modes used to predict sample values create dependencies between the sample values of a current block and the sample values of one or more neighbors. An intra macroblock type has a number of available prediction modes which typically correspond to different directions of extrapolation from the neighboring sample values into the current block. In the H.264 standard there are nine prediction modes for I 4 4 nine prediction modes for I 8 8 and four prediction modes for I 16 16.

The logic specified in the H.264 standard for calculating spatial predictions in the various modes includes numerous formulas typically handled by branches or indirect calls in a CPU architecture. A direct mapping of the CPU approach to the example GPU architecture could result in execution of all of the branches for many blocks which is very inefficient.

For the H.264 GPU mapping one goal is increase parallelism e.g. more primitives per shader and fewer shaders in execution of shaders for the intra prediction. Another goal is to reduce wasted computations.

In some embodiments the decoder with GPU uses waves to efficiently perform intra prediction on a GPU architecture. Basically the GPU uses different execution units to process different intra blocks within a wave in parallel. Effectively organizing waves helps the decoder reduce the number of waves while simultaneously increasing per wave parallelism.

To start the decoder organizes intra blocks as waves. A wave includes one or more of the intra blocks. For example the decoder organizes 4 4 8 8 and 16 16 intra blocks as waves. Alternatively the decoder organizes blocks of other and or additional sizes.

In some embodiments the decoder organizes the blocks as static waves based on how the blocks are laid out with respect to each other. Such static waves are laid out the same in different pictures regardless of different slice or macroblock patterns in the different pictures. In general a static wave is based on theoretical possibilities without considering actual data such as macroblock type and intra prediction mode. For example the static waves roughly correspond to diagonal lines of blocks starting from the top left corner and rippling toward the bottom right corner. The lines are tilted to the right because the neighboring sample values that can potentially be considered in spatial prediction for a current block are in blocks to the left of above left of above and above right the current block.

While using static waves increases parallelism in some scenarios the static waves may assume dependencies that do not actually exist between the blocks. Rather than assume a set of dependencies applies for a given block the decoder can instead determine which dependencies actually are present between blocks. For example if the context neighbors of a current intra block are in a different slice or are inter predicted in some implementations the current intra block does not use intra prediction from them and intra prediction dependencies can be removed.

Aside from considering macroblock types and slice patterns in some implementations the decoder also considers spatial prediction modes. Different spatial prediction modes have different dependencies roughly corresponding to different directions of spatial extrapolation. For example for many spatial prediction modes a current block has no dependencies on the block to its above right.

Often organizing intra blocks as static waves results in too many waves. This can hurt performance due to switching overhead from wave to wave. Considering actual dependencies can help the decoder combine waves making fewer waves that are typically bigger and therefore provide more opportunities for parallel processing.

So in some embodiments the decoder organizes the blocks as dynamic waves based on analysis of dependencies within the blocks. For example the decoder organizes blocks as described in the following section. Alternatively the decoder organizes blocks as dynamic waves using another approach.

In particular in B slices and P slices intra blocks are typically few in number and sparse. There are typically not many dependencies for intra blocks in B and P slices. Organizing intra blocks as dynamic waves considering macroblock type to identify isolated intra blocks with no intra dependencies can help process separate intra blocks in parallel within one wave for B and P pictures. For example if a B slice includes six isolated I 16 16 macroblocks that share no edges the six macroblocks are intra predicted in parallel in one wave.

For I slices I PCM macroblocks provide similar opportunities for removing intra prediction dependencies. I PCM macroblocks are uncommon in many coding scenarios however. Or if the decoder considers actual prediction modes organizing blocks as dynamic waves can help the decoder eliminate assumed spatial prediction mode dependencies that are not in fact present which helps increase parallelism.

Returning to after organizing blocks as waves the decoder performs intra prediction on a wave by wave basis. The decoder performs intra prediction for a wave and determines whether to continue with another wave. If so the decoder performs intra prediction for the next wave.

For example the decoder performs intra prediction for wave which includes the top left intra block in a picture and any other intra block that has no intra prediction dependencies on another intra block. In some implementations in a B picture or P picture isolated intra blocks all over the picture can be processed as part of the first wave since they have no intra prediction dependencies. The decoder then performs intra prediction for wave which includes intra blocks that only have intra prediction dependencies on intra blocks in wave . Then the decoder performs intra prediction for wave which includes intra blocks that have intra prediction dependencies on intra blocks in waves and . The decoder thus continues wave by wave through the picture.

Alternatively instead of organizing intra blocks for a picture and performing wave by wave intra prediction across the picture the decoder operates on a slice by slice or other basis.

In some embodiments the decoder with GPU organizes intra blocks as dynamic waves for intra prediction. Building dynamic waves for pictures helps improve performance by reducing the number of waves and correspondingly increasing the number of intra blocks in the remaining waves. In particular building dynamic waves improves performance for B and P slices because non intra coded macroblocks in them provide wave boost tending to cause intra blocks to be processed in earlier waves.

Initially the decoder assigns a wave number of zero to the intra blocks in the picture. For a current block the decoder identifies intra prediction dependencies for the block. For example the decoder scans the image in macroblock block order as in the H.264 standard.

The decoder identifies wave number s of neighbor block s upon which the current block has dependencies and assigns a wave number to the current block. For example the decoder assigns wave number max DEPBLK 1 to the current block. In an H.264 decoder DEPBLK represents wave number s for a set of one or more blocks whose members depend on macroblock type intra or inter prediction mode frame type and MBAFF macroblock flags. More generally DEPBLK indicates wave numbers for blocks upon which the current block depends for intra prediction. In some implementations DEPBLK is implemented as a table of offsets subtracted from the position of the current block to determine positions and then wave numbers of adjacent blocks. The decoder determines whether to continue with another intra block in the picture and if so identifies intra prediction dependencies for the next intra block.

In some implementations the block size for wave building is 8 8. Setting a block size sets a tradeoff between the number of waves and shader size. Setting block size to 4 4 typically doubles the number of waves but requires more memory wave building is more computationally intensive but still linear in complexity.

In some implementations the decoder increments a counter for number of blocks of different types within the respective waves. For example when a block is assigned a wave number a counter for that type of block based on the type of the macroblock including the block in that wave is incremented. Using the counters helps the decoder manage intra prediction computations more efficiently.

Finally to speed up the wave building process in some implementations the decoder performs the wave building on a slice by slice basis from the bottom up in a multi slice picture. The last slice is processed first and scanned according to macroblock block order within the slice. This makes the unavailability of neighboring macroblocks from different slices for purposes of intra prediction implicit.

In some embodiments the decoder with GPU tracks organization of intra blocks as waves using a data structure such as the structure shown in . Alternatively the decoder tracks organization of intra blocks as waves using another data structure.

The structure is organized wave by wave. The structure starts with a section for wave followed by a section for wave and so on. The section for a wave includes one or more sections for different block sizes for blocks in the wave. For example the section for wave includes an intra 4 4 section an intra 8 8 section and an intra 16 16 section. The intra 4 4 section includes indices of 4 4 intra blocks in wave the intra 8 8 section includes indices of 8 8 intra blocks of that size in wave and so on. The decoder uses raster scan numbering for example to index the blocks. As shows a given wave can include intra blocks of different sizes.

The decoder creates and populates the structure for example when building waves. For example the decoder performs an additional pass through a picture during wave building and records indices in an array of indices such as the structure . The GPU then uses the structure during the wave by wave intra prediction.

In some embodiments the decoder with GPU merges luma waves and chroma waves to increase parallelism. When chroma prediction is independent of luma prediction merging luma waves and chroma waves helps the GPU reduce the total number of waves and process more intra blocks in parallel within a given wave.

The decoder organizes intra luma blocks as waves. For example the decoder uses a wave building technique described above or uses another wave building technique. The decoder also organizes intra chroma blocks as waves. The decoder can use the same or different wave building techniques for chroma blocks performing the organizing separately in time or concurrently.

The decoder then merges the luma waves and chroma waves. For example the decoder combines luma intra blocks for wave with chroma intra blocks for wave and so on. The luma intra blocks and chroma intra blocks with a wave may be collocated or they may be at different locations due to different dependencies for luma and chroma. Luma prediction modes can be different than chroma prediction modes for example resulting in different dependencies.

In some embodiments the decoder with GPU uses refactored operations for intra prediction. This helps reduce wasted computation in intra prediction.

Formulas for different intra prediction modes have many computations in common. For example in the H.264 standard there are nine intra prediction modes for 4 4 intra blocks and some of the prediction modes include several branches but the different branches and modes have many computations in common.

Several of the prediction modes compute A B 1 2 as part of intra prediction. Several other prediction modes compute A 2B C 2 4. Collectively the intra prediction modes for intra 4 4 blocks excluding the DC prediction mode can be refactored using the following complete set of computations A B C B C D C D E D E F E F G F G H G H H I J K J K L J I X I X A X A B K L L A B B C C D D E E F F G G H I J J K K L I X and X A where the letters refer to the sample positions shown in the refactored operations with three sample positions x y z refer to an operation of the form x 2y z 2 4 and the refactored operations with two sample positions x y refer to an operation of the form x y 1 2.

To reduce shader branches a decoder can build a table that holds the results of the refactored operations for some or all of the modes of an intra macroblock type to simplify intra prediction by providing common parts of possible prediction results for those modes. The decoder then selects the appropriate results when performing the intra prediction actually specified for the current block. For example the decoder builds a table for eight 4 4 intra prediction modes not DC mode for a current 4 4 intra block and uses the table in intra prediction for the block selecting appropriate values for a spatial prediction mode. The decoder handles DC mode separately.

The decoder can compute the values for the table using matrix multiplications. For example the decoder computes the results of refactored operations for 4 4 intra prediction modes with two 4 4 matrix multiplications as follows.

Alternatively the results of the refactored operations are computed in a different way. Commonality refactoring can be performed similarly for the prediction modes for other intra block sizes.

During intra prediction the shader routine performs table lookups using the table. With the table the number of branches in the shader is reduced which speeds up execution and helps avoid wasted computation. Although computing the results of the refactored operations imposes additional overhead efficient mechanisms e.g. matrix multiplications for computing the results of refactored operations can be used.

In some embodiments a decoder uses loop filtering operations mapped to a GPU platform. For example the decoder organizes blocks as waves and performs loop filtering on a wave by wave basis. Features of the example H.264 GPU mapping include 

In some embodiments a decoder performs loop filtering in multiple independent passes to increase parallelism. For example the different passes are for computing edge strengths performing deblocking and reshuffling results of the deblocking.

In a first pass the decoder with GPU calculates boundary strengths and other data for each macroblock in a picture or each macroblock pair for an MBAFF picture .

In a second pass the decoder with GPU performs loop filtering on luma blocks and performs loop filtering on chroma blocks. For example the loop filtering includes deblocking blocks in parallel according to different shaders for luma and chroma. The second pass can include a luma pass with wave by wave loop filtering of luma blocks and a chroma pass with single wave loop filtering of chroma blocks. Loop filtering for a single wave can in turn be split into multiple passes for example a horizontal edge pass and vertical edge pass for luma loop filtering. Alternatively the decoder uses a different timing for loop filtering on the luma blocks and chroma blocks.

In a third pass the decoder with GPU shuffles sample values resulting from the second pass in a fully parallel reshuffling stage. The sample values generated by the second pass are put into final image buffers. With the potential for reshuffling in the third pass the decoder can exploit additional opportunities for efficient processing in the deblocking of the second pass.

In some embodiments the decoder with GPU uses waves to efficiently perform loop filtering of luma blocks on a GPU architecture. Basically the GPU uses different execution units to process different luma blocks within a wave in parallel.

To start the decoder organizes luma blocks as waves. In doing so the decoder identifies luma blocks that can be loop filtered in parallel.

In some embodiments the decoder organizes macroblocks or macroblock pairs as static waves along diagonal lines. Such static waves are laid out regardless of edge strengths but the structure of the waves does vary depending on the type of frame MBAFF macroblock pairs or not. The static waves roughly correspond to diagonal lines of blocks starting from the top left corner and rippling toward the bottom right corner. The number of waves relates to picture resolution and dimensions.

Alternatively the decoder organizes luma blocks as dynamic waves depending on boundary strengths. For example boundary strength values are computed for a macroblock and used to reduce dependencies between the macroblock and other macroblocks.

After organizing blocks as waves the decoder performs loop filtering on a wave by wave basis for the luma blocks. The decoder performs loop filtering on luma blocks for a wave and determines whether to continue with another wave. If so the decoder performs loop filtering for the next wave.

In some embodiments the decoder performs two passes for each loop filtering wave. The decoder performs loop filtering on vertical edges in the luma blocks in one pass then it performs loop filtering on horizontal edges in the luma blocks in another pass.

Depending on implementation a 4 4 block in the picture can be exported a variable number of times during different waves or passes within a wave. For instance in a progressive frame the top left 4 4 block of an interior macroblock is exported for the vertical pass of its macroblock and then for the horizontal pass. The bottom right 4 4 block of the same macroblock is exported for the vertical pass of its macroblock s wave then for the horizontal pass of the same wave it is also exported for the vertical pass of the wave of the macroblock to its right and finally for the horizontal pass of the wave of the macroblock below it. In some implementations the decoder uses a scratch buffer to avoid overwriting data and make exports faster. When horizontal and vertical results are deposited into separate memory locations it is possible to get the right information from horizontal and vertical buffers of a previous wave or from the unfiltered pixels of the source image.

In some implementations the decoder performs loop filtering by row or column in parallel not macroblock by macroblock. In one GPU implementation for each column or row of pixels in four 4 4 blocks in a macroblock the decoder accepts five 4 4 blocks as input namely the five blocks around four vertical or horizontal edges and outputs six 4 4 blocks. The decoder calculates and outputs one extra block above or to the left and another one of padding for alignment purposes. This extra redundancy facilitates loop filtering according to the different dependency rules that apply to macroblock interiors and at macroblock external edges for example so that the macroblocks in a diagonal including the edge macroblocks can be processed simultaneously.

In some embodiments a decoder with GPU performs loop filtering for chroma blocks in a single wave. When chroma blocks in a picture do not have dependencies for loop filtering e.g. due to filters not reaching across certain edges the chroma blocks are processed in parallel by the GPU. The chroma loop filtering can still include multiple passes for specialized loop filtering processing of different positions.

For some macroblock formats and filter types chroma blocks throughout a picture can be loop filtered in parallel by a GPU. For example for chroma loop filtering of 4 2 0 macroblocks according to the H.264 standard chroma blocks have relatively few filtered edges samples are spaced sufficiently far apart and filters are sufficiently short that chroma blocks do not have associated dependencies in loop filtering. As such chroma deblocking is performed without wave by wave processing. Instead chroma blocks are loop filtered as part of a single wave.

The single wave loop filtering can include multiple passes for different portions of the chroma blocks. The chroma blocks are processed in parallel with different block portions being filtered in different passes.

For example shows an 8 8 chroma block of a progressive macroblock. The 8 8 chroma block includes different portions that are loop filtered in different loop filtering passes. Specifically the 8 8 chroma block has 9 regions a 4 4 region M in the middle two 2 4 regions 5 on the left and right sides of the middle two 4 2 regions T above and below the middle and four 2 2 regions C in the corners.

Different regions in a block can be processed independently of the other regions in the block in loop filtering. Regions that touch the edge of a macroblock are processed together with the regions on the other side of the edge.

In some implementations the chroma blocks of a picture are loop filtered in four passes without any waves. One pass corresponds to 4 4 blocks centered around the top left corners of the chroma blocks. For the 8 8 chroma block of collocated with the luma macroblock and coextensive in the chroma plane the block s top left 2 2 corner is filtered in this pass along with corners from up to three other chroma blocks of macroblocks. The other 2 2 corners of the chroma block are similarly filtered in this pass with corner s from other chroma block s .

Another pass corresponds to 4 4 blocks centered on the top edges of the macroblocks and collocated chroma blocks . The top 4 2 region of the 8 8 block in is filtered with the bottom 4 2 region of the block above it if available and the bottom 4 2 region of the 8 8 block is filtered with the top 4 2 region of the block below it if available .

Another pass correspond to 4 4 blocks centered on the left edges of the macroblocks and collocated chroma blocks . The left side 2 4 region of the 8 8 block in is filtered with the right side 2 4 region of the block to the left if available and the right side 2 4 region of the 8 8 block is filtered with the left side 2 4 region of the block to the right if available .

In some implementations the loop filtering operations for chroma blocks use a set of intermediate buffers and include some redundant calculations. Overall however performing multi pass loop filtering within a single wave has increased parallelism compared to wave by wave approaches for chroma loop filtering.

Alternatively chroma blocks are filtered with other and or additional passes in a single wave. Or chroma blocks are loop filtered on a wave by wave basis.

In some embodiments a decoder uses memory usage innovations adapted for a GPU platform. For example the decoder uses memory tiling and 3D texture arrays for fast data access. Features of the example GPU mapping include 

Alternatively the H.264 GPU mapping includes other and or additional features. For other operations or another type of GPU the decoder uses different memory usage innovations.

Memory write patterns can dramatically affect performance for the GPU. In some implementations to improve performance a picture is kept in a 4 4 tiled format during decoding. This helps make both intra decoding and inter decoding e.g. motion compensation faster than if the normal scan line representation is used. Also for deblocking the decoder reads directly from the tiled image representation which avoids reshuffling.

Memory read patterns can also dramatically affect GPU performance. In some implementations the decoder extends the 4 4 tiled format to reference pictures in the decoded picture buffer e.g. implemented as a 3D texture . This facilitates fast fetching of data by motion compensation shaders.

Other aspects of these memory usage innovations e.g. representing reference pictures with textures field frame access having multiple memory partitions or slot assignments in flight are presented above e.g. in section X.D or in conjunction with specific decoding operations .

In some embodiments a decoder uses film grain noise generation mapped to a GPU platform. For example the decoder with GPU generates film grain noise and performs deblocking since the H.264 noise generation is block based . Features of the example H.264 GPU mapping include 

According to the H.264 standard certain types of supplemental enhancement information SEI messages support modeling of film grain as film grain parameters to be sent along with coded video. As post processing the decoded video can be enhanced with film grain noise synthesized according to parameters. In some implementations the decoder with GPU improves performance of film grain synthesis by using pre computed seed data and or performing pattern deblocking without dependencies.

At times a decoder may encounter content that is harder to decode e.g. because it has a higher complexity or is encoded at a higher quality or the decoder may experience an unexpected resource shortage e.g. lack of available processor cycles or memory because of other processes running . In such situations the decoder may need to degrade the quality of the decoded video to simplify decoding. The decoder can do this by dropping pictures for example but picture dropping may provide more of an adjustment than is needed.

In some embodiments a decoder uses adaptive loop filtering with quality feedback to gradually degrade video quality and simplify decoding. The quality feedback generally relates to performance of the decoder as it decodes video. For example the decoder switches between different deblocking algorithms for loop filtering. In some implementations e.g. H.264 decoders loop filtering is part of conformant decoding to correctly decode video and changing loop filtering can result in drift away from the correctly decoded video. Nevertheless in some decoding scenarios such quality degradation can be less objectionable to viewers than picture dropping to simplify decoding. Performance adaptive loop filtering can be used in conjunction with picture dropping such that playback glitches due to picture dropping are reduced by selectively switching loop filtering quality levels to relieve the decoder earlier in stress situations and overall quality is improved.

The decoder selects a loop filtering quality level from among multiple available loop filtering quality levels. Example quality levels in some implementations including no loop filtering full loop filtering and multiple fast loop filtering options in between are described below. Alternatively the decoder selects between other and or additional available loop filtering quality levels.

Initially the selected loop filtering quality level has a value set for the decoder or decoding session for example the highest loop filtering quality level. During decoding the decoder can adjust the selected loop filtering quality level from time to time as described below.

The decoder decodes video performing loop filtering at the selected loop filtering quality level. For example the decoder decodes one or more pictures of the video at the selected loop filtering quality level.

The decoder determines if it is done e.g. at the end of the sequence and if not measures performance. In some implementations the decoder measures a count of previously decoded pictures that are queued and ready for display and the decoder also measures how many decoded pictures in a given window or range of pictures have been decoded at a given quality level. Alternatively the decoder measures performance in other terms such as delay between presentation times of pictures versus actual delay or another measure of latency or current processing capacity.

In some implementations the decoder measures short term performance and long term performance as part of performance adaptive loop filtering. The decoder measures performance on picture by picture basis for example by tracking a count of pictures ready for display. The decoder concurrently measures longer term performance for n pictures in a window of pictures. Alternatively the decoder measures performance in some other interval.

Using the measured performance the decoder determines whether to change the loop filtering quality level. The decoder can use the measured performance directly or indirectly in the determination . For example the decoder uses a performance metric directly in conditional logic or a table lookup operation to determine whether to change the quality level and potentially selects a new loop filtering quality level. Or the decoder uses a performance metric to adjust other parameter s or decision s in turn used in determining whether to change the quality level. If the loop filtering quality level is unchanged the decoder continues decoding video with loop filtering at the same quality level. Otherwise the decoder selects a new loop filtering quality level and decodes video with loop filtering at the new quality level.

Loop filtering can be complex especially when a decoder makes content adaptive and dynamic decisions depending on macroblock and block types in a picture sample value differentials across edges etc. In performance adaptive loop filtering different available loop filtering quality levels basically trade off decoding complexity versus quality of reconstruction of the decoded video. Faster loop filtering quality levels typically have lower decoding complexity but lower quality e.g. more discrepancies and drift due to skipped decisions in loop filtering . The discrepancies can show up for example as increased blurriness for lower complexity and quality loop filtering levels. Slower loop filtering quality levels typically have higher decoding complexity and higher quality. In some implementations the decoder selects between the quality levels shown in the following table.

Alternatively the decoder uses other and or additional loop filtering quality levels in performance adaptive loop filtering for different tradeoffs in decoding complexity quality and robustness to levels of performance changes in decoding.

In some implementations the decoder measures short term performance as a count of how many pictures are buffered for digital to analog conversion DAC . In particular in one implementation the decoder determines how far ahead pictures are buffered for DAC measuring the difference between 1 the most recent vertical blanking interval VBI or presentation time generally the time at which the DAC will refresh the screen with video data from memory and 2 the VBI or presentation time for the picture as far ahead as any picture is currently scheduled for display. This count of pictures can be considered a queue length. Alternatively the decoder uses another metric for short term performance.

In some implementations the decoder measures long term performance as proportions of how many pictures in a window or range are decoded using different quality levels. Alternatively the decoder uses another metric for short term performance.

In some implementations the decoder uses a multi stage framework to organize the timing and types of level switching that happen performance adaptive loop filtering. In an example five stage framework each of five stages has associated with it one or more of quality levels A to E shown above. Each stage has different a stage best quality level within the stage. For stage the stage best quality level is A for stage the stage best quality level is B and so on. Within a stage the decoder selects between 1 level A 2 the lesser of level B and the stage best quality level for the stage and 3 the stage best quality level for the stage. The following table shows stages to in the example five stage framework.

Within a stage the decoder selects between the available loop filtering quality levels of the stage using directly or indirectly measured performance. For example the decoder uses a current queue length count of pictures ready for display for short term adjustments and uses a proportion of pictures decoded at stage best quality levels for long term adjustments. Depending on these measures the decoder can switch from a current stage to a lower stage to decrease decoding complexity quality or the decoder can switch from the current stage to a higher stage to increase decoding complexity quality. The decoder can switch between stages one at a time or more aggressively switch between stages depending on implementation.

In one implementation the decoder evaluates current queue length from time to time e.g. on a picture by picture basis and switches to a low complexity quality level when the queue length gets too short. For example if the queue length is less than two the decoder performs no loop filtering A and switches to the next lower stage. Otherwise if the queue length is less than four but more than one the decoder selects the lesser of level B and the stage best quality level but stays in the current stage. Otherwise queue length is four or more the decoder selects the stage best quality level and stays in the current stage. The thresholds for queue length also vary depending on implementation.

In the same implementations the decoder evaluates also evaluates proportions of pictures decoded at stage best levels from time to time e.g. on a picture by picture basis and switches between complexity quality levels depending on the proportions. For example if less than p of the pictures in a current window of n pictures were loop filtered at the stage best level for the current stage the decoder switches to the next lower stage. Or if more than q of the picture in the current window were loop filtered at the stage best level for the current stage the decoder switches to the next higher stage. The values p q and n depend on implementation and are for example p 80 q 90 and n 20. The decoder generally attempts to stay in the best quality stage 5 in the five stage framework as much as possible while still adapting to decoding performance for the content.

The decoder can reset statistics e.g. number of pictures deblocked at stage best quality level or min B stage best quality level when a window of pictures has been processed. Or the decoder can use a sliding window. The decoder typically resets such statistics when it changes stages in a multi stage framework.

Alternatively the decoder uses a framework for performance adaptive loop filtering with different timing and or types of loop filtering quality level switching.

Different embodiments may include one or more of the inventive features shown in the following table of features.

In view of the many possible embodiments to which the principles of the disclosed invention may be applied it should be recognized that the illustrated embodiments are only preferred examples of the invention and should not be taken as limiting the scope of the invention. Rather the scope of the invention is defined by the following claims. We therefore claim as our invention all that comes within the scope and spirit of these claims.

