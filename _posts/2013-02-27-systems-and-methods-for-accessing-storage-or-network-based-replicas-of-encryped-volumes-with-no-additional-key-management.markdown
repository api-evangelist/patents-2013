---

title: Systems and methods for accessing storage or network based replicas of encryped volumes with no additional key management
abstract: A computer implemented method for creating an encrypted logical unit is provided. A first identification number is received, the first identification number associated with a first encryption key used to encrypt a first logical unit. The first identification number and the first encryption key are stored at a first secure location, where the first secure location provides the first encryption key to a requester in response to receiving the first identification number from the requester, assuming the requester provides security credentials. A first metadata storage space is defined on the first logical unit, the first metadata storage space comprising a region on the first logical unit that remains unencrypted. The first identification number is stored in the first metadata storage space on the first logical unit.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08966281&OS=08966281&RS=08966281
owner: EMC Corporation
number: 08966281
owner_city: Hopkinton
owner_country: US
publication_date: 20130227
---
This application is a continuation application of U.S. patent application Ser. No. 12 242 690 filed on Sep. 30 2008 now U.S. Pat. No. 8 416 954 which is hereby incorporated herein by reference in its entirety.

This application is related to the following commonly assigned United States Patent Applications and or United States Patents each of which is hereby incorporated by reference 

It is expressly contemplated that that the invention described herein can be combined and or implemented together with any one or more of the above incorporated by reference patent applications.

Embodiments of the invention generally relate to devices systems and methods for data storage in computer systems. More particularly the invention relates to systems and methods for transparent encryption and decryption of data being written to and read from logical units and for replication of encrypted logical units.

Protecting confidential data such as medical records financial records personal data social security numbers credit card numbers corporate records intellectual property etc. and other sensitive information from theft and or unauthorized access is becoming increasingly important to businesses computer users and government organizations. Confidential data can exist as so called data at rest which is data stored on some type of a storage system such as an array or tape as well as data in flight also referred to as data in motion or data in transit which includes data as it exists during its transmission or that is temporarily residing in computer memory to be read or updated .

In recent years there have been numerous examples of security breaches involving thefts of both data at rest and data in motion from tens of millions of users. Information technology IT professionals use various methods to help prevent such data theft. Currently different techniques are used to protect data in motion as compared with protection of data at rest. For example secure sockets layers SSL virtual private networks VPNs and combinations of these are two examples of security technologies that can be fairly effective in protecting and securing data in flight especially when combined with other methods that protect that data from start to finish such as message level security and application level security. Data at rest however requires different types of protection. Because of data mobility data storage consolidation and data replication a single breach into data at rest can compromise many millions more records than with a single breach of data in flight.

Organizations have many options for securing data at rest including authentication controls logical separation physical security and encryption of information. Although each option has advantages and disadvantages when extremely large amounts of data are involved encryption can provide the most workable solution. Encryption of data as is well known involves converting data to an unintelligible form called ciphertext which cannot be read unless a key is used to decrypt the data in some types of encryption the same key also is used to encrypt the data . Encryption also can be an important way to protect data at rest in other situations including the electronic and physical movement of data for backup data recovery and or maintenance. In addition encryption helps to limit exposure to security breaches so even if someone is able to access the storage media the data is still protected to prevent unauthorized access to sensitive information on the storage media. Use of encryption also helps address compliance with industry regulations that require encryption such as the payment card industry Data Security Standard PCI DSS the Sarbanes Oxley Act the Gramm Leach Bliley Act GLBA the Health Insurance Portability and Accountability Act HIPAA the United Kingdom Data Protection act UK DPA the European Union Directive on personal information 95 46 EC various state statutes protecting personal information such as California s CA 1798 and the like.

The best place to implement encryption in a computer system especially a networked or enterprise computer system can vary depending on the use case and or the customer. For example in an enterprise level computer system encryption can be provided at the application level the host or operating system level within the network and or at the level where the physical device resides.

Encrypting at the application level allows for a significant amount of control over the encryption process because application users can dictate how to classify information who can access it and when. In addition application level encryption allows for granular specific information to be secured as it leaves the application. However encrypting at the application level has several disadvantages. For example one disadvantage of application based encryption is that it requires modification of the application which can be costly time consuming and difficult to implement especially if lots of legacy data that needs to be encrypted is involved.

Another disadvantage is that application based encryption does not take into account the impact of the encryption it provides on replicated data especially backed up or mirrored data data stored for disaster recovery purposes etc. . This makes some use cases of replication more difficult. For example data that is written by one application and encrypted cannot be used by another application without the first application also decrypting the data or providing a consistent encryption key management interface for applications to share data. Also for Disaster Recovery an application may have to be configured to use the same key s on both sites resulting in an extra management step

Network based encryption may be appropriate when network or storage level threats are a concern to the organization and network based encryption offloads the cost of encryption from the host. Here a network appliance can be used to present an unencrypted side and an encrypted side to the network. Network based encryption also presents challenges when coupled with storage based functionality such as replication. In particular network level encryption doesn t take into account its impact on replicated data. Any locally replicated information in storage e.g. a mirror or clone does not have visibility into the network device management and the keys and the network device does not have visibility into the replication process. Key management can become more complex and require more manual intervention as well as coordination between the security and storage domains which is time consuming and more expensive.

Encryption done where the physical device resides such as encryption on intelligent arrays includes encryption of storage media such as arrays disks or tapes which protects sensitive information residing on the storage media. Data written to the physical device is encrypted and stored as such and is decrypted when read from the device. Encryption done where the physical device resides is application and host independent and can be transport independent as well. This type of encryption can be advantageous when theft of the storage media is a concern. However because data is decrypted immediately off the storage media when accessed security breaches can occur throughout the network on the host and at the application. Keys can be acquired at the disk or tape level.

Tape encryption also presents key management challenges. For example tapes may be stored for an extended period of time before an attempt is made to recover information. During the normal process of managing encrypted data the program that originally wrote the tapes e.g. an archiving application may have re keyed the data on tape updating all data on the tape to a new key. Doing this would present the application with active live data using one key and data on tape using an older key. For example one problem arises when the live data is stored with a newer key and the user wants to restore some older data from tape that was stored with a different key. This rekeying problem exists with any data which is archived in an encrypted form but the archiving application is not in charge of the encryption. It can be difficult to manage keys for the lifetime of the data regardless of where the data is stored. A tape can be restored using any number of tape drives each of which would need access to a key. Another issue is that because tapes are transportable keys must be as well. If an encrypted tape is replicated association of the correct key with the replica needs to be done manually adding an extra step and burden.

Organizations have sometimes been reluctant to deploy encryption of data at rest for various reasons. Some reasons include the complexity of managing many keys the need to add extra steps to existing processes for data storage which can be difficult and time consuming especially if existing management scripts for replication need to be modified the expense the time and for some implementations the need to add one or more appliances to a network. Other issues with deployment of encryption include management complexity the cost and complexity associated with deploying and managing multiple encryption technologies and key manager scalability across an enterprise many point solutions for encryption do not scale across application types or infrastructure elements and disruption to service levels installing encryption technologies and appliances may require a network outage and or reconfiguration .

The following presents a simplified summary in order to provide a basic understanding of one or more aspects of the invention. This summary is not an extensive overview of the invention and is neither intended to identify key or critical elements of the invention nor to delineate the scope thereof. Rather the primary purpose of the summary is to present some concepts of the invention in a simplified form as a prelude to the more detailed description that is presented later.

Encrypting in the host below the applications or encrypting in the network or encrypting on the array is simpler to deploy than techniques such as application level encryption because applications don t have to be modified and the same encryption deployment can benefit multiple applications. Other advantages include that implementation can be immediate and non disruptive requiring no application or hardware modifications. Host based encryption involves encrypting information on host based systems and host based encryption is deployed between storage systems and a server host. Host based encryption can be done in software using host processing resources and encryption keys stored in host memory. Alternatively the host can be configured to offload encryption to specialized hardware. For example a host bus adaptor HBA resident on the host can dedicate encryption to a particular transport connection from the host such as Fibre Channel.

With host based encryption encryption can be performed at the file level for all applications running on a host. In some instances implementations of host based encryption can be implemented to encrypt any data leaving the host as files blocks or objects. For example in accordance with one embodiment of the invention a host based implementation operating on a logical unit at the block level is provided by providing the encryption as part of an operating system OS independent input output I O filter system with I O filter driver such as the EMC POWERPATH ENCRYPTION with RSA product available from EMC Corporation of Hopkinton Mass. As is explained further herein however the invention is not limited to providing the I O filter system with I O filter driver as part of a host based implementation. In other embodiments the invention is implemented in other environments where I O filtering is or can be used including but not limited to in a switch in a virtualization appliance in a network and in an intelligent array of storage.

If the encryption is implemented using an OS independent I O filter system including an I O filter driver running on a host as is described for at least some embodiments herein the host based encryption can support multiple operating systems running on enterprise servers or across a domain. Another advantage is that this type of host based encryption can be storage and array independent for example to support legacy storage systems without requiring new hardware. Still another advantage is that host based encryption can support multiple applications and multiple arrays.

Host based encryption also can present a challenge when coupled with storage based functionality such as replication because of the need to track replicas and keys. If replication is employed underneath the host encryption level for example it is advantageous if the host based encryption is able to track replicas and associated encryption keys to eliminate the need for user to manually manage replication and encryption technology. In at least one embodiment of the invention further described herein systems and methods are provided to manage replicas of encrypted information so as to allow for coordinated key management between source and replicated volumes independent of user intervention.

For example consider a situation where the property of encryption is turned on for a logical unit LU the logical unit is the entity upon which an encryption key is applied an LU identifier can be stored with the encryption key so that the encryption key for the LU can be found in the future. An external key manager provides the encryption key. One concern with this approach is how to find the key for a replica of such an LU. At least some embodiments of the invention resolve this concern by virtualizing the LU when the encryption property is turned on and dedicating a small area in the LU storage to store metadata relating to encryption. Within this metadata an identifier key id which optionally can be unique globally unique across a given domain etc. that is associated with the key can be stored and can be used to obtain the key provided that all permissions and credentials are in place.

For example when the key id is presented to the key manager with appropriate credentials the host system is allowed to obtain the key used to encrypt decrypt the LU. When replicas of the LU are created this metadata is replicated along with the encrypted areas of the LU. Replicating the metadata means that the key for decrypting the encrypted data on the LU also can be obtained for the replica with no need to store knowledge of specific devices within the key manager. This allows a user to continue to use replicas as the user already has been using them without introducing new management steps when a replica is created. Further no other software used in the enterprise needs to be modified and no specific management actions are required to permit replication of the encrypted volume and the ability to read write the encrypted data on the replica. These and other embodiments of the invention can be applied to data encrypted at the network or logical device level as well.

In one aspect the invention provides a computer implemented method for creating an encrypted logical unit. A first identification number is received the first identification number associated with a first encryption key used to encrypt a first logical unit. The first identification number and the first encryption key are stored at a first secure location where the first secure location provides the first encryption key to a requester in response to receiving the first identification number from the requester assuming the requester provides security credentials. A first metadata storage space is defined on the first logical unit the first metadata storage space comprising a region on the first logical unit that remains unencrypted. The first identification number is stored in the first metadata storage space on the first logical unit.

In further embodiments the method includes storing in the metadata information indicating that the first logical unit is encrypted such as by storing them together in a first key manager. In further embodiment the first logical unit is operably coupled to a first host and the first key manager is in operable communication with the host.

In still another embodiment the method includes the unordered steps of receiving from the first secure location information used to encrypt and decrypt data with the first encryption key and storing the information used to encrypt and decrypt data with the first encryption key in a first data structure in a kernel running on the first host.

In yet another embodiment the method includes the unordered steps of receiving a request to write data to the first logical unit providing the information in the first data structure to a cryptographic module providing the data to be encrypted to the cryptographic module and receiving at the first logical unit data that has been encrypted by the cryptographic module.

In a further embodiment the method include the unordered steps of receiving a request to read data from the first logical unit providing the information in the first data structure to a cryptographic module providing to the cryptographic module encrypted data stored on the first logical unit receiving at the first logical unit plaintext data that has been decrypted by the cryptographic module.

In still another embodiment the first logical unit has a first size and further comprising the unordered steps of providing a second logical unit the second logical unit having a size greater than or equal to the size of the first logical unit replicating the first logical unit to the second logical unit such that the second logical unit includes a second respective metadata storage space storing therein a copy of the first identification number configuring the second logical unit to a second host the second host being in operable communication with the first secure location and being a host capable of providing security credentials to the first secure location.

In another aspect the invention provides a method of enabling encryption of data written to a first logical unit LU in communication with a host that is running an operating system having a kernel. This method comprising the unordered steps of 

defining a first device identifier device id for the first LU obtaining from a key server for the first LU a key a key identifier key id and associated key information the associated key information comprising information used by an encryption algorithm associated with the key storing the key id in a metadata region on the LU where the metadata region comprises a first unencrypted region on the logical unit defining a first encrypted region on the logical unit for storing encrypted data storing the first device id and a first keyblob data structure in a first device data structure in the kernel where the first keyblob data structure comprises the key and the information used by the encryption algorithm associated with the key and wherein the first device id identifies the first LU and is used to look up the first keyblob data structure and using information in the first keyblob to encrypt with the key data written to the encrypted region of the first LU.

in a processor generating an identification number for an encryption key used to encrypt a logical unit 

The drawings are not necessarily to scale emphasis instead generally being placed upon illustrating the principles of the invention. In the Figures like numbers denote like elements.

Before discussing the details of the invention a preliminary discussion is provided giving an overview of the type of computing environment in which at least some embodiments of the invention are realized followed by a brief overview of operation of one embodiment of the invention. The methods and apparatus of at least some embodiments of the invention may take the form at least partially of program code i.e. instructions embodied in tangible media such as floppy diskettes CD ROMs hard drives universal serial bus USB memory devices memory cards random access or read only memory or any other machine readable storage medium including a transmission medium. When the program code is loaded into and executed by a machine such as a computer the machine becomes an apparatus for practicing the invention. The methods and apparatus of the invention also may be embodied in the form of program code that is transmitted over some transmission medium such as over electrical wiring or cabling through fiber optics or via any other form of transmission. When implemented on a general purpose processor the program code combines with the processor to provide a unique apparatus that operates analogously to specific logic circuits. The program code software based logic for carrying out the method is embodied as part of the system described below.

Systems and methods in accordance with at least some embodiments of the invention can be implemented using any type of general purpose computer system including but not limited to a personal computer PC laptop computer client network appliance server workstation personal digital assistant PDA mobile communications device interconnected group of general purpose computers host computer systems enterprise computer system etc. running any one of a variety of operating systems. The general purpose computer system advantageously includes and or is capable of communicating with storage devices or systems including enterprise storage systems remote storage systems intelligent storage systems disaster recovery systems etc. that store data and or computer programs used by the general purpose computer system. An example of a system that includes a general purpose computer system and storage systems usable with at least one embodiment of the invention is shown in .

Referring now to the host computer also referred to herein as a general purpose computer includes a processor which can include one or more central processing unit CPU chips and one or more host bus adapters that each controls communication between the processor and one of the storage systems via a corresponding one of the communication buses . Each bus can be any of a number of different types of communication links with the host bus adapter and storage bus directors being adapted to communicate using an appropriate protocol via the communication buses coupled there between. For example each of the communication buses can be implemented as a SCSI bus with the storage bus directors and host bus adapters each being a SCSI driver. Alternatively communication between the host computer and the storage systems can be performed over a Fibre Channel fabric. In still another alternative embodiment communication between the host computer and the storage systems can be performed in accordance with standards for the Internet Small Computer System Interface iSCSI or the Fibre Channel over Ethernet FCoE . Other implementations are of course possible.

In addition those of skill in the art who are familiar with such general purpose computer systems know that such systems can include elements not explicitly illustrated in such as random access memory RAM for storing programs and or data an input output I O controller a network interface a display device one or more input devices and optionally one or more removable storage devices including but not limited to a CD DVD drive unit a floppy disk drive unit a tape drive unit a PCMCIA or other card drive a USB based flash drive unit and the like and a data bus coupling these components to allow communication therebetween.

The CPU can be any type of microprocessor such as a PENTIUM processor made by Intel of Santa Clara Calif. The display device can be any type of display such as a liquid crystal display LCD cathode ray tube display CRT light emitting diode LED and the like capable of displaying in whole or in part any outputs generated in accordance with the systems and methods of the invention. The input device can be any type of device capable of providing the inputs described herein such as keyboards numeric keypads touch screens pointing devices switches styluses and light pens. The network interface can be any type of a device card adapter or connector that provides the computer system with network access to a computer or other device such as a printer a computer network a storage area network etc.

In at least some embodiments of the invention one or more computer programs such as applications and an operating system define the operational capabilities of the computer system . Operating systems usable with at least some embodiments of the invention include but are not limited to systems available from Sun Microsystems and running the Solaris operating system a version of Unix HP UX a Hewlett Packard operating system running a Hewlett Packard version of the Unix operating system available from Hewlett Packard Corporation AIX an IBM version of Unix available from IBM Corporation and or any other operating system such as LINUX WINDOWS VISTA WINDOWS XP or WINDOWS NT the latter three are available from Microsoft Corporation . These programs can be loaded into the computer system in many ways including but not limited to a hard disk drive a CD DVD drive and the network interface. Alternatively the programs can reside in a permanent memory portion e.g. a read only memory ROM chip of the main computer system memory. Further those of skill in the art will recognize that the computer system can include specially designed dedicated hard wired electronic circuits that perform all functions described herein without the need for instructions from computer programs.

The I O filter system includes an I O filter driver . The I O filter driver portion of the I O filter system facilitates the sending of I O requests from applications running on the computer system which can for example be a host to the data storage subsystem . For example in at least some embodiments the I O filter driver queues I O requests from the computer system directed to data storage subsystems note that data storage subsystem is illustrated further in as comprising a combination of primary storage systems and replica storage systems . In addition in some embodiments the I O filter driver implements algorithms to decide which I O requests to send how many I O requests to send and the speed at which to send I O requests. The I O filter driver in some embodiments keeps a record of I O requests that are sent to data storage subsystems until the I O request is processed by data storage subsystems . An exemplary host I O filter system that includes an I O filter driver is the POWERPATH software available from EMC Corp.

At least some embodiments of the systems methods and apparatuses of the invention described herein are intended for use in connection with storage area networks SANs that include data storage systems such as the SYMMETRIX Integrated Cache Disk Array System or the CLARIION Disk Array System available from EMC Corporation of Hopkinton Mass. as well those provided by vendors other than EMC Corporation especially SANs including arrays where replication takes place such as by using array or switch facilities.

The storage systems which can be logical units make storage resources available to the host computer for assignment to entities therein such as a file system a database manager not shown a logical volume manager an I O filter system with driver a block driver and an HBA driver . If the storage systems are so called dumb storage systems the storage resources that are made available to the host computer will correspond in a one to one relationship to physical storage devices within the storage systems. However when the storage systems are intelligent storage systems they will present logical units of storage to the host computer that need not necessarily correspond in a one to one relationship to any physical storage devices within the storage system. Instead the intelligent storage systems may map each logical unit of storage presented to the host across one or more physical storage devices.

One environment in which the storage systems of may be used is as part of an enterprise storage system. Enterprise storage systems store data in large scale environments and differ from consumer storage systems in both the size of the environment and the types of technologies that store and manage the data. SANs are commonly used in enterprise storage systems to transfer data between computer systems and storage devices. An exemplary SAN provides a communication infrastructure including physical connections between computer systems storage devices and a management layer which organizes the connections storage devices and computer systems.

In a SAN environment computer systems typically referred to as hosts connect to the SAN via one or more host bus adapters. The SAN itself may include thousands of different inter related logical and physical entities. In the case of a Fibre Channel SAN these entities which comprise the connections between hosts and storage devices may include Fibre Channel host bus adapters Fibre Channel switches Fibre Channel routers and the like. The entities may be physically connected through the use of twisted pair copper wire optical fiber or any other means of signal transmission.

Storage devices may include multiple disk drives that combine to form a disk array. A typical disk array includes a disk array controller a cache disk enclosures and a power supply. Examples of disk arrays include the SYMMETRIX Integrated Cache Disk Array System and the CLARIION Disk Array System both available from EMC Corporation of Hopkinton Mass. Such a data storage device system and its implementation is fully described in U.S. Pat. No. 6 101 497 issued Aug. 8 2000 and also in U.S. Pat. No. 5 206 939 issued Apr. 27 1993 each of which is assigned to EMC the assignee of this invention and each of which is hereby incorporated by reference. Consequently the discussion herein makes only general references to the operation of such systems.

A disk array controller is a piece of hardware that provides storage services to computer systems that access the disk array. The disk array controller may attach to a number of disk drives that are located in the disk enclosures and communicates with the storage bus director via an internal bus . For example the disk drives may be organized into RAID groups for efficient performance and data protection. RAID redundant array of inexpensive disks is a system that uses multiple disk drives that share or replicate data among the drives. Accordingly in a RAID system instead of identifying several different hard drives an operating system will identify all of the disk drives as if they are a single disk drive.

Disk array controllers connect to storage bus directors via internal buses and via a port. A port serves as an interface between the disk array controller and other devices such as the hosts in the SAN. As illustrates the storage bus directors connect to a SAN. Each disk array controller typically includes two or more ports. Disk array controllers may communicate with other devices using various protocols such as the SCSI Small Computer System Interface command protocol over a Fibre Channel link to the SAN. In the SCSI command protocol each device is assigned a unique numerical identifier which is referred to as a logical unit number LUN . Further communication using the SCSI protocol is said to occur between an initiator e.g. a host and a target e.g. a storage device via a path. For example a path may include a host bus adapter an associated SCSI bus or Fibre Channel cabling and a single port of a disk array controller. For example the aforementioned path management software e.g. EMC POWERPATH ENCRYPTION with RSA can be used to manage the paths used to communicate data in the SANs and among other things can detect load imbalances for storage bus directors in a SAN and can select alternate paths through which to route data.

Data storage devices such as disk drives may be presented to one or more hosts such as host computer as a logical volume. A logical volume can represent a particular physical storage device such as one of disk drives . Note that a physical disk is formatted into a physical volume as presented by the storage device for use by management software such as Logical Volume Manager LVM software available from EMC . It should be noted that LVM functions can be implemented in several places including within arrays and on hosts in however the LVM is illustrated as functioning on a host. Each physical volume is split up into discrete chunks called physical partitions or physical extents. Physical volumes are combined into a volume group. As those of skill in the art know a logical volume consists of some number of physical partitions extents allocated from a single volume group where a volume group is a collection of disks which could be a physical volume treated as one large storage area. A logical volume may also be referred to as a logical unit LU . An identifier of a logical volume also called a logical volume identifier includes information specific to the logical volume it identifies. One example of a logical volume identifier is the Fibre Channel World Wide Names WWN of the logical volume. Another example of a logical volume identifier is information that was assigned by the array manufacturer and that is provided in response to a SCSI inquiry. Still another logical volume identifier is the world wide name WWN which also can be provided in response to a SCSI inquiry. Note also that as used herein a device is a generic term for any number or kind of logical unit especially used for storage.

In one embodiment the I O filter system is implemented to use pseudodevices to represent devices that it is managing. The pseudodevice is a logical representation of the device that assigns it a name chosen by the I O filter driver instead of the name assigned it by the Operating system . Use of pseudodevices to represent devices that the I O filter system is managing is advantageous when the I O filter driver is transforming those devices in some way such as using a part of the device to write metadata.

As is understood in the art a pseudodevice is a special type of port located in the kernel of an operating system that acts like a device but does not correspond to any actual hardware and doesn t interface to a hardware device instead the pseudodevice interfaces to a managing device driver that maps it to one or more underlying hardware devices. Thus a host interacting with a pseudodevice treats the pseudodevice as sort of a forwarding mechanism through which a physical device can be reached such that the host treats a pseudodevice as if it were a physical I O device even though it is not. With some embodiments of the invention which can use multipathing in the I O filter system of the invention a pseudodevice represents a single logical device as defined by I O filter system and the path set leading to it which can contain any number of physical paths. In at least some further embodiments of the invention a pseudodevice explained further herein is used to represent the eVLU which has a hidden private region of metadata that is only available to the filter driver . A pseudoname is the name used to identify the pseudodevice.

In at least one embodiment of the invention the computer system of is networked to other devices such as in a client server or peer to peer system. This is illustrated and described in greater detail in connection with herein which include example embodiments showing first and second computer systems A B networked to each other via a host interconnect network which can for example be a local area network LAN or a wide area network WAN as well as embodiments showing a host computer running a client application that communicates with a remote server application running at a remote host. The network could be an internet protocol IP network but many other types of networks are usable as will be appreciated by those of skill in the art. The computer system thus includes elements that can act as a client system a server system or a peer system and the entire computer system likewise can act as a client server or peer. It should be noted however that although the computer host can act as a server in a general sense the key manager server is a very specific and particular type of server as explained elsewhere herein and will not necessarily have the same behavior as when the host acts as a server.

As will be explained further herein the client can be any entity such as the system host computer and or or specific components thereof e.g. terminal personal computer mainframe computer workstation hand held device electronic book personal digital assistant peripheral etc. or a software program e.g. an I O filter driver system program running on a computer directly or indirectly connected or connectable in any known or later developed manner to any type of computer network such as the Internet. A client may also be a notebook computer a handheld computing device e.g. a PDA an Internet appliance a switch a mobile communications device a telephone an electronic reader device and or any other such device capable of connecting to a computer network or a storage network.

Of course those skilled in the art will appreciate that computer systems embodying the invention need not include every one of the aforementioned elements and that equivalents to each of the elements are intended to be included within the spirit and scope of the invention.

A brief summary of the overall operations of one embodiment of the invention is now provided followed by detailed descriptions of the various aspects components and processes of embodiments of the invention.

In one aspect the invention provides an I O filter system that provides an information centric protection mechanism for data e.g. user data stored on logical units LUs . The I O filter system encrypts and decrypt all data although not necessarily operating system OS metadata or the I O filter system metadata on an encrypted virtualized logical unit eVLU where the virtualization is done by the I O filter system . Data on such an LU is encrypted and decrypted transparently by the I O filter system no application changes are required. This also means however that data on such an LU is encrypted and thus accessible only through I O filter system note that backup applications that run on plaintext data above the I O filter system are backing up plaintext and not cipher text and thus such applications are accessible independent of the I O filter system 

A user is able to encrypt existing data by copying it from a plain text LU to an eVLU using a data migration or data copying tool one example of such a tool usable with at least some embodiments of the invention is the POWERPATH MIGRATION ENABLER PPME product available from EMC Corporation of Hopkinton Mass. These features also enable protection of data on storage devices e.g. drives that are removed from arrays. Because metadata on the LU stores information in plaintext that can be used to obtain the key for the data on the LU given permission to obtain the key it is possible for replicas to be made of a logical unit where the replica keeps intact the encryption and also includes in the replica the information necessary to obtain a key for decryption.

In a further aspect of the invention to protect an entire drive s contents all the LUs that are using the physical drive are encrypted. However in another embodiment if it is desired to protect only some of the content on an LU e.g. to protect only the sensitive and or confidential data on an LU but not necessarily all data it may be sufficient for only those LUs that contain such data to be encrypted on a particular physical drive. The I O filter system described herein also is useful to prevent unauthorized access to a volume s content on a per host basis.

In one embodiment the I O filter system provides a command line interface CLI to perform various actions needed to manage the eVLU. For example the CLI allows an administrator to designate a particular LU to be encrypted which renders any previously existing user data on the LU inaccessible through the I O filter system . When an LU is designated to be encrypted it will be converted to an eVLU and a key will be provisioned for it and cached in the I O filter system kernel. At the same time a key identifier key id associated with that key is stored in the I O filter system s metadata region on the LU. In some embodiments of the invention for example some embodiments that use the RSA Key Manager as the key manager the key id is a globally unique key id. In at least some other embodiments e.g. some embodiments that use a key manager other than the RSA Key Manager the key id is unique within a given domain but not necessarily globally unique. In still further embodiments the key id need not be unique

Once the key id is stored in metadata all writes to the eVLU are encrypted and all subsequent reads are decrypted. The device can then be put into service as a new LU or it can be used as the target e.g. of a PPME migration where the source is an LU with existing data. Note that when migrating from an existing LU for some of the embodiments of the invention the target may need to be slightly larger in order to accommodate the I O filter system metadata required for a virtualized LU.

When the I O filter system starts up after a host boot the I O filter system detects all encrypted virtualized LUs. Reads and writes to encrypted parts of the VLU will be disabled to these devices until the key is looked up and cached in the kernel. The I O filter system gets the key for each eVLU based on information stored in the I O filter system metadata which is in a private region of the LU.

Advantageously in the I O filter system data at rest encryption is built on top of VLUs to enable the I O filter system to detect and properly handle replicas such as replicas created by products such as EMC Symmetrix Remote Data Facility SRDF EMC MirrorView EMC Snapview EMC Timefinder as well as other mirroring disaster recovery and or replication products. An eVLU contains metadata that enables the I O filter system to identify the LU as virtualized and as encrypted. In the case of a replica the I O filter system metadata ensures that the key associated with the eVLU is the same as the key of the source eVLU for the replica.

As those of skill in the art will appreciate embodiments of the invention can greatly simplify making replicas of encrypted storage devices and managing the associated encryption keys. In prior art systems a manual operation is needed to associate each replica with the key that was provisioned for the primary device. Thus without the advantages provided in the embodiments of the present invention every time a device being used as a replica is re purposed another manual operation is required.

Having described the environment of the invention and provided a brief overview of one embodiment of the invention including its advantages for replication the details of at least some embodiments of the invention are now provided.

Note also that two separate protected perimeters can share selected elements i.e. have elements in common . Consider for example which is an illustration showing a second protected perimeter configuration in which two protected perimeters A B share both a key manager server and a set A that includes primary storage devices A and replica storage devices A. It should be understood that protected perimeters that share components are not required to share any or all of the shared components specifically shown in . The specifically illustrated shared components in are provided by way of illustration only and are not limiting. In other embodiments for example the storage interconnect could be the shared component. Generally however the host and I O filter system are not shared between protected perimeters .

A pair of protected perimeters also can be in communication over a network and arranged so that a first protected perimeter A serves as a primary protected perimeter and a second protected perimeter B serves as a replica of the primary protected perimeter A. Together the interconnected protected perimeters A B can form a third protected perimeter C. Consider for example which is an illustration showing a third protected perimeter configuration C that consists of first protected perimeter A and a second protected perimeter B connected via a remote network in which there is a key manager server for each of the primary and replica logical units in accordance with one embodiment of the invention. The embodiment and configuration of can be especially useful for disaster recovery applications. For example the configuration of can be used with replication for disaster recovery where the arrays of the storage devices A A A of protected perimeter A are replicated into the arrays of the storage devices B B B respectively of protected perimeter B and where the replica key manager server B is a replica of primary key manager server A. In a disaster recovery application e.g. SRDF the replica key manager server B is a disaster recovery replica of primary key server manager A primary storage device is a disaster recovery replica of primary storage device A and the primary portion of replica set is a disaster recover replica of the primary portion of replica set A. Thus for disaster recovery all the primary storage of protected perimeter A is replicated in protected perimeter B. In some embodiments however local replicas within a protected perimeter e.g. the replica A of perimeter A has a remote replica in protected perimeter C as those of skill in the art will appreciate.

Referring now to each protected perimeter also illustrates some components used to implement at least one embodiment of the invention including a pair of host computers A B similar to the computer of each host computer A B having a respective I O filter system with encryption A B. The host computers A B in this embodiment are shown for illustrative purposes to be in operable communication with each other but it should be noted that the host computers A B being in operable communication is entirely optional so long as each host computer is in communication with the key manager server . The host computers A B communicate with the external key manager server via a host interconnect . In addition the host computers A B communicate via a storage interconnect with a plurality of primary storage devices replica storage devices and a set that includes both primary and replica storage devices.

A host computer that is initialized and configured with the I O filter system with encryption which can for example be provided as the EMC POWERPATH ENCRYPTION with RSA product are considered to be within the protected perimeter . As will be explained further herein using the I O filter system with encryption helps to ensure that if any storage devices within the protected perimeter are physically removed from the protected perimeter the data contained on the storage devices will be encrypted so as to maintain confidentiality.

The storage interconnect of can be any type of network capable of interconnecting storage devices with host computers. In some embodiments the storage devices and host computers are interconnected in a manner such that to the operating systems running on the host computers A B the storage devices appear as locally attached but this is not required for the invention. The storage interconnect provides communications between the various entities in the protected perimeter such as the host computers A B and storage devices . The storage interconnect may be a shared public or private network and encompasses a wide area or local area and can be implemented through any suitable combination of wired and or wireless communication networks. Furthermore the storage interconnect may include a local area network LAN a wide area network WAN an intranet or the Internet. For example in one embodiment the storage interconnect works with Fibre Channel connectivity and is implemented via a SAN. In another embodiment the storage interconnect works with internet protocol IP connectivity and is implemented via an Internet Small Computer System Interface iSCSI for Fibre Channel . Those of skill in the art will recognize that other implementations are of course possible.

The key manager server provides key manager functionality and the key manager server communicates and cooperates with a key manager client running at each host A B for simplicity the key manager client is not shown in but is illustrated in . The key manager server is in one embodiment a server appliance that includes all components required to be a key manager for the datacenter within the protected perimeter and which is capable of looking up a globally unique identifier. An illustrative example of a key manager server usable with at least some embodiments of the invention is the RSA KEY MANAGER appliance manufactured by EMC Corporation of Hopkinton Mass. however the invention is not of course limited to use of the RSA KEY MANAGER.

The key manager server in cooperation with the key manager client which operates remotely and in concert with the key manager server running at the host controls the generation protection storage replacement and elimination of encryption keys. In particular the key manager server creates encryption keys and also creates the key id an identifier that is associated with the encryption key and can be used to obtain the encryption key provided that all permissions and credentials are in place and is responsible for that association and for allowing lookup of an encryption key using the key id. Note that the key id in some embodiments e.g. those using the RSA KEY MANAGER is globally unique. In some embodiments the key id is unique within a domain. In other embodiments the key id might not necessarily be unique. Thus one role of the key manager server in is to securely create store and return keys to authorized entities such as the I O filter system with I O filter driver of e.g. such as EMC POWERPATH ENCRYPTION with RSA . It should be understood however that the key id could instead be created at the host . It is more advantageous to create the key id at the key manager server as this results in fewer process steps overall.

As will be explained in greater detail herein plaintext data e.g. data generated by an application running at the host transmitted from a host system to a storage device is encrypted using an encryption key provided by the key manager server . As will also be explained in greater detail herein the encrypted data is stored on an encrypted virtual logical unit eVLU on one or more of the storage devices along with the key id which is later used to get an encryption decryption key from the key manager server . An eVLU also known as a cipher text logical unit is a logical unit with encryption turned on. Note that all eVLUs are also virtual LUs. is a first block diagram illustrating a first input output I O stack configuration illustrating the location of the I O filter driver of the I O filter system of relative to other components in the stack in accordance with one embodiment of the invention and is a block diagram illustrating a second input output I O stack configuration that includes a SCSI driver in the stack and illustrates the location of the I O filter driver of the I O filter system relative to other components in the stack in accordance with one embodiment of the invention also provides a schematic representation of a number of mapping layers that exist in exemplary embodiments of the computer system of as well as schematic illustrations of an eVLU

Referring to the I O stack configuration includes an application layer which includes application programs executing on the processor of the host computer . The application layer generally will refer to storage locations used thereby with a label or identifier such as a file name and will have no knowledge about where the file is physically stored on the storage system . Below the application layer is the file system layer followed by the logical volume manager LVM layer . The LVM layer presents a logical volume to the file system layer . The LVM layer maps that logical volume to what appears to be a physical volume to the LVM but which may be another logical construct presented by a layer lower in the stack. In the illustration of for example the LVM maps to the logical unit LU also referred to herein as a virtual logical unit when the LU has been virtualized .

In the embodiments of the invention both the file system layer and the LVM layer are optional layers. An optional database manager layer also could be implemented in connection with the embodiments of the invention and the database manager layer would be outside the kernel at the same level or below the application layer . Of course one of skill in the art will recognize any particular application can make use of none some or all of the layers described herein and or illustrated in .

The virtual logical unit VLU represents a device presented by the I O filter driver to the layers above it. In contrast an LU represents the VLU as seen without virtualization. The VLU A as illustrated in is shown as containing plaintext data also referred to as clear text . A virtualized LU represents what any entity above the I O filter driver gets when accessing the eVLU that is the entity gets the plaintext version of the data the VLU is a logical representation of the eVLU as seen by entities above the I O filter driver . The plaintext data will be encrypted via the I O filter driver and written to the storage device represented by the eVLU . The eVLU is used in the same manner as any other logical unit that is the eVLU can be used for raw access file systems can be mounted on it and it can be placed under control of the LVM . Encrypted Data on the eVLU excepting the metadata which is unencrypted is returned as cipher text to any application or other entity user that accesses the data without going through the I O filter system . For example if a database is configured to read the native device corresponding to a device containing an eVLU and the database does not go through the I O filter driver the database retrieves cipher text.

In the embodiments of the I O filter driver which is part of I O filter system not shown sits below the applications file system and LVM in the I O stack . Note that the invention does not require that the I O filter driver be implemented below the LVM or file system in the I O stack . In the particular embodiment illustrated in the OS includes an I O filter driver that sits above a SCSI device driver . For some embodiments of the invention that include the SCSI device driver the LU that happens to be an eVLU is read by portions of the OS that live below the I O filter driver or execute before the I O filter driver is loaded such as the SCSI device driver . As explained further herein in connection with certain embodiment of the invention if the eVLU can be read by portions of the OS that live below the I O filter driver or execute before the I O filter driver is loaded then the I O filter driver stores information indicating the portions of the eVLU that can be read by those portions of the OS so that the portions read by the OS can be left unencrypted. The information can be stored for example in the metadata of the eVLU but that location is not limiting. Those of skill in the art will appreciate that information designating unencrypted regions can be stored in many different structures in other embodiments e.g. tables the actual code itself etc. 

In general in accordance with the invention the I O filter driver can sit above or below any component in the I O stack except that it cannot sit below the HBA driver . The I O filter system in which the I O filter driver resides includes functionality to act as an encryption manager in the I O stack . As described previously the I O filter system in one embodiment is the EMC POWERPATH ENCRYPTION with RSA system.

The I O filter driver creates a virtualized LUN designating some space in the LUN to store its metadata and the key id in that metadata space. For example a given storage device is virtualized into a Virtual Logic Unit VLU and at least one metadata storage space is allocated in the physical space of the device where the key id is stored in the metadata storage space so as to indicate that the LU is encrypted i.e. the LU becomes an eVLU see . For example a primary eVLU can be replicated to a replica eVLU where the replica eVLU contains the same key id as the primary eVLU indicating that the replica eVLU is encrypted with the same key as the primary eVLU . described further below provide more details about the components of the I O filter system itself.

Referring again to anything executing above the I O filter driver e.g. user applications databases file systems logical volume managers etc. but that is using the I O filter driver sees data stored on the LU as plaintext and cannot see the metadata region on the underlying logical unit. That is an application or other component executing above the I O filter driver sees only a virtualized LUN minus the metadata the metadata is invisible to the component above the I O filter driver . 

In at least some embodiments of the invention the virtualizing of the LUN is more of a host based virtualization than a switch based or array based virtualization. With at least some embodiments of the invention the virtualization of the LUN is a generalized facility added to the I O filter system that allows for storing metadata or properties on a device for any reason. The Xcrypt manager extension described further below in connection with uses this abstraction layer to store the key id information for an encrypted device. The presence of the key metadata or key property on a device indicates the device is encrypted and should be treated by the Xcrypt manager as such. It should be understood however that the actual encryption key is not stored in the metadata as this would violate security requirements. Rather as explained herein what is stored in the metadata is information about the key that allows lookup of the key from the Key Manager server assuming the requester is allowed access to that key.

With the eVLU and metadata herein the metadata is created during virtualization where the virtualization driver I O filter driver which can be accomplished using many techniques known to those of skill in the art ensures that code running above the I O filter driver can see only the virtualized logical unit portion of the eVLU without ever knowing that the metadata is there. In one embodiment this virtualization is accomplished using size spoofing of the LU where the size spoofing involves showing the code running above the I O filter driver that the size of the device e.g. LU is the size minus the size of the metadata area which has the effect that no entity other than the I O filter system and I O filter driver is able to access the metadata region .

In a further embodiment the virtualization is accomplished using geometry spoofing. Geometry spoofing is discussed further in Prakash Venkatanaryanan et. al Methods and Systems for Preserving Disk Geometry of Virtualized Data Volumes application Ser. No. 11 478 897 filed Jun. 30 2006 allowed Sep. 9 2008 U.S. Pat. No. 7 469 313 which is hereby incorporated by reference. In a still further embodiment areas of the LU that need to remain unencrypted such as the metadata and OS specific areas can be put into a partition not used for data and or put in some other area of the storage device and protected by the I O filter driver from unwanted access.

The metadata itself is not encrypted. Note also that the metadata can in at least some embodiments be used to implement functions such as mirroring and or partitioning in addition to providing a location on the eVLU for storage of the key id. In certain embodiments the metadata stores information about regions of the eVLU that are to be left as plaintext. In addition note that although only a single metadata region is illustrated in in some implementations there can be more than one metadata region .

Referring again to the eVLU includes a logical unit portion which stores the encrypted data as well as a metadata portion which stores metadata which itself is unencrypted . In at least one embodiment of the invention the logical unit portion includes at least a section that stores unencrypted data and a section that stores encrypted data and the I O filter system keeps track of these sections. The order of the sections shown is not limiting that is the first section need not be the one that stores unencrypted data it could for example store encrypted data . The sections storing encrypted and unencrypted data can be anywhere in the eVLU and there can be more than one section of each type.

In one embodiment described further herein the metadata portion includes information about which regions in the logical unit portion are designated plaintext unencrypted regions. The metadata provides enough identification information but not the actual encryption key itself to enable a host running the I O filter system and in communication with the eVLU to get the actual encryption key from the key manager server as is described further in connection with and A B.

Providing a key id in metadata where the key id is presented to a key manager server to get a key provides advantages especially for replication that would not be available with other arrangements. Consider for example an alternate arrangement where instead of a key manager server storing a database that associates a key id with a key as is done with the present invention the key manager server instead stored a database associating a given key with the unique identifier associated with a source LUN itself e.g. a device ID . On the one hand because every LUN has its own unique device ID such an arrangement would provide a way to get an encryption key for a given LUN from a key manager server based only on the device ID of a given LUN and furthermore this alternative arrangement would not even require an area of metadata on a LUN. However this alternate arrangement might not be as optimal for situations where replicas are made of a LUN because the replica being a different device would have its own device ID and the replica device ID that would not be the same as the device ID of the source from which it was replicated.

Thus if a source LUN in this alternately considered arrangement were encrypted with a given key stored at a key manager server and the key manager server stored info linking just the source LUN device ID with the encryption key a replica LUN made of the source LUN would not be able to access the appropriate encryption key at the key manager server because the replica is on a LUN with a different device ID. Thus extra steps would be required for the replica to obtain the device ID of the source LUN and to present the source device ID to the key manager so that the key could be obtained. This would require considerable extra steps as compared to the implementations of the invention described herein. Replication also could require extra steps potentially requiring changes in existing scripts for replication. Further this alternate arrangement would not permit replication writing data reading data etc. to be transparent as it is with the embodiments of the invention described herein.

In contrast in accordance with embodiments of the invention described herein providing a metadata area that stores an identifier that can be used to acquire an encryption key helps to ensure that creating and reading encrypted replica eVLUs is transparent and requires no additional steps beyond a regular replication process assuming security requirements are met . The information needed for decryption is inherently made part of any replica made with any replication method in accordance with the embodiments of the invention. Furthermore a replica eVLU created in accordance with embodiments of the invention described herein will still be subject to the protections that the key manager server provides as to unauthorized access. Even if an unauthorized entity gains custody of a replica eVLU the unauthorized entity still will not be able to access data because the key manager will fail any unauthorized attempts to look up the key that is the security checks on the key manager see will not be met.

The invention can be implemented in many alternative embodiments as well. For example in one alternative embodiment the device ID of a replica eVLU is registered in the key manager server and is associated in some way there with the key of the source eVLU. In still another alternative embodiment the device ID of the primary eVLU is written in metadata and then used to look up the key.

Referring again to the key id in metadata also serves as identifier of sorts for the eVLU to help the kernel of an operating system running on the host recognize that a given LU is in fact an eVLU this is discussed in more detail in connection with . That is when the I O filter driver is running and encounters a new logical unit the I O filter driver can check first to see if the metadata region is present and can be read and second to see if the metadata includes a key id which indicates that the logical unit contains encrypted data which tells the I O filter driver that the LU is an eVLU B and that it needs to get the encryption key from the key manager server this process is described more fully in connection with . Another advantage of writing the key id in metadata is with replication any host that has permissions to communicate with the key manager server and which meets all security requirements can access every replica made of an eVLU and get the key and decrypt the replica. In addition in at least some embodiments of the invention there are two or more separate pieces of information stored in the metadata such as one that says the LU is encrypted and another that gives information used to look up the key.

Accordingly whatever protections a key manager server has in place for restricting a host from obtaining the key for an eVLU are likewise in place for replicas of the eVLU . Thus even if an unauthorized entity physically takes a storage device containing a replica of an eVLU and mounts it to a different unauthorized host the unauthorized entity won t be able to access the data on the replica because unauthorized host will not be able to meet the security requirements of the key manager server and therefore will not be successful in obtaining the key. Further this requires no extra steps or added management scripts to implement. These and other processes are explained in greater detail in connection with the flow charts of 7 17 herein.

In the eVLU the location of the metadata is platform specific and may depend further on the formatting of the device on that platform. Its illustration in as being at the end of the eVLU is not limiting although it is applicable for at least some embodiments of the invention.

In at least one embodiment of the invention the eVLU includes two copies of metadata referred to as the primary and alternate copies. The primary and alternate copies need not be in contiguous segments but could be in separate segments such as at the beginning and the end . A valid primary copy of metadata is always the authoritative copy as metadata updates are always performed on the primary copy first more below . The alternate copy of metadata is for robustness to rollback to previous metadata state as appropriate. A copy of metadata is composed of two parts header and data areas. The metadata header is a single block 512 bytes in size but this size is not limiting. The metadata data area is a variable length list of property name property value pairs. Each property name is also variable length. In one embodiment the key id stored in the data portion of the metadata has a size of 16 bytes and this size is illustrative and not limiting.

In addition in at least some embodiments of the invention the processes that perform encryption have predetermined knowledge that certain blocks or other regions in the LU should be kept as plaintext e.g. region of and not be encrypted. For example with certain operating systems the first block in a volume corresponds to the volume table of contents VTOC and must be kept plain in addition the VTOC can include information identifying the location of the beginning of alternate cylinders where all data from that point on is to be kept plain. The point is that any OS metadata that is accessed below the I O filter driver or prior to the loading of the I O filter driver at startup of the host must be kept in plain text because the I O filter driver has not yet been loaded to unencrypt it. However only OS metadata not any application data is accessed in this way.

As an example in one embodiment the eVLU can be implemented where some areas of the eVLU other than the metadata are left unencrypted that is the entire logical unit portion is not encrypted but is divided into unencrypted region and encrypted region as shown in . This helps to support the needs of certain operating systems to access their own metadata when it is accessed at different places e.g. lower in the I O stack than where the I O filter driver resides and or at different times e.g. startup than the I O filter driver is running. For example when using the IBM AIX OS sector 0 in a logical unit cannot be encrypted. For WINDOWS the device signature written to the logical unit is accessed below I O filter driver or before I O filter driver is loaded and must be kept in plain text. In another example on THE SUN SOLARIS OS VTOC formatted devices holds the label VTOC and geometry information in the first block block 0 . This block is not encrypted so that the kernel layers below the I O filter driver that need to access this information can do so without use of the Xcrypt manager . Access to this information does not in itself constitute a security violation. Another unencrypted region for VTOC formatted devices are areas known as the alternate cylinders. Other platforms may be different based on device format and operating system specifics.

Leaving certain areas of the eVLU unencrypted other than the metadata areas helps to prevent the I O filter system from encrypting operating system metadata stored on the eVLU . In one embodiment the I O filter driver of the I O filter system determines whether a request to write data is to a portion of the eVLU used by the operating system . In such instances the I O filter driver keeps certain data unencrypted that an operating system OS accesses below the level of the I O filter driver . In one embodiment this is accomplished by recording in code a data structure a map a table or in the metadata itself the block ranges that are and or must be in plain text. The block ranges that are left as plaintext depend on the operating system as will be appreciated by those of skill in the art.

The c clamp I O filter driver supports components for providing platform independent functionality for the I O filter driver system see and also supports various platform dependent components for supporting specific operating systems.

Referring again to the OS interface may be for example an interface to any operating system OS such as Sun s SOLARIS IBM AIX HPUX LINUX and or Microsoft s WINDOWS NT. The HBA interface includes platform dependent code comprising an interface to relevant host bus adapters. The Common API comprises a series of common Application Programming Interfaces APIs . An advantage of the C clamp configuration of is that extensions can be written in a platform independent manner because the OS Interface HBA Interface and Common API s translate all of the platform dependent communications into more generic communications. Various extensions through are enveloped between the OS Interface and the HBA Interface . Note that although each extension is illustrated as a single extension each extension could consist of a plurality of extensions.

The vertical line in running vertically from the operating system through the host bus adapter and pointing downward helps to indicate the direction and order that data takes from the operating system through the I O filter driver and to an eVLU and generally corresponds to the order in which the extensions are executed in response to an IO request. As those of skill of the art will appreciate if a first extension needs processing or input provided by a second extension then the second extension must be processed before the first extension in the I O stack. For example input to the I O filter driver from the operating system is acted upon by the OS Interface then the xcrypt manager then the virtual LU metadata manager vlumd before it passes out through the HBA interface to the host bus adapter . Similarly the vertical line running upward from the host bus adapter towards the operating system indicates the direction of that data takes when it is output from an eVLU to the operating system . This is the direction of configuration of a device LU as will be described further in connection with as well.

In addition to a plurality of existing extensions all are not illustrated but the data migration extension is illustrative two new extensions are added in the embodiment of to manage I O requests and encryption and decryption as well as a number of other features of the present invention. These extensions are explained below and further herein.

The xcrypt manager extension xcrypt is an extension that includes functionality to turn encryption on or off for a given logical unit in response to a command from user space. The xcrypt manager extension is the only extension that interacts with the crypto kernel see and can interface with various user space components see using both kernel events mapped to the libemcp events library and IOCMDs see . The xcrypt manager supports several input output commands IOCMDs that are used by a component called libemcp xcrypt see to communicate with it. The libemcp xcrypt component services user commands from the powervt API component and coordinates the events such as look up key event in the kernel . These commands which are explained more fully as part of the flowcharts of herein do the following things 

Whenever an eVLU is encountered by the I O filter driver usually at startup of the host it is configured into the I O filter system by the xcrypt manager . At that point the xcrypt manager requests the key lookup of the encryption key by passing the key id to a user space daemon the xcrypt daemon see where the daemon is running a key manager client that communicates with the key manager server to get the key see the processes of . Once the key lookup is accomplished the daemon sends the encryption key to the xcrypt manager which then has it available for doing I O see . This request and response also contains a device id which identifies the underlying LUN that is encrypted and is used to lookup the data structure where the encryption key is stored in the kernel. As further described in connection with both read and write operations require the xcrypt manager to allocate an additional buffer to hold the encrypted data. The original buffer will always hold the plain text version of the data.

The virtual logical unit metadata MD manager vlumd extension takes care of establishing a metadata region on a device where the metadata region can be unambiguously recognized and provides controlled access to the metadata protecting it from inappropriate access. The vlumd extension also sets name value pairs into metadata and gets the value back when presented with the name it will be understood by those of skill in the art however that there are many other alternatives to the use of name value pairs. The vlumd extension provides a vlumd interface usable by the xcrypt manager extension . In one embodiment of the invention the only user of the vlumd interface is the xcrypt manager extension . However in other embodiments the vlumd manager is able to be extended to support other types of LU virtualization and LU functions such as mirroring striping and thin provisioning.

The general purpose extension is an intermediary between certain of the extensions e.g. the xcrypt extension the data migration extension and the vlumd extension and the c clamp and provides more flexibility to the extensions by allowing dynamic loading.

Referring now to the I O filter system includes components in both user space and kernel space . The I O filter system components in kernel space are the ones that interact with the storage arrays . In kernel space the I O filter system includes an I O filter driver having the previously described in C clamp architecture that includes an xcrypt manager and a vlumd manager along with kernel events . The kernel space portion of the I O filter system is in communication with a crypto kernel which is illustrated in as the B SAFE CRYPTO KERNEL and in by the combination of the cryptography key manager CKM kernel and encryption decryption library which together form a crypto kernel . The crypto kernel including the CKM kernel portion is in communication with the xcrypt manager of the I O filter driver .

In one exemplary embodiment the crypto kernel is implemented using the B SAFE CRYPTO KERNEL product available from RSA Security which is owned by EMC Corporation of Hopkinton Mass. to provide a cryptographic foundation for other security products that interact with the I O filter system such as the key manager server . In one embodiment the crypto kernel provides a collection of cryptographic algorithm implementations including for example at least one of Advanced Encryption Standard AES also known as Rijndael cipher block chaining AES CBC encryption 256 bit keys and or AES tweakable block ciphers encryption two 128 bit keys . Other cipher key strengths e.g. a 128 192 256 or 512 bit encryption key sizes also are usable with embodiments of the invention.

Use of a symmetric encryption technique such as AES based encryption is advantageous for embodiments of the invention where it is required that the size of the block remain the same after encryption as before as those of skill in the art are aware a number of encryption algorithms increase the size of a data block . As will be understood by those of skill in the art the invention is not limited to only AES based encryption algorithms. In certain embodiments any encryption algorithm that does not change block size is usable. In at least some other embodiments it may be possible to use encryption algorithms that do change the block size. Note that in the embodiment of the crypto kernel protects its data via encryption using a data encryption key DEK .

The kernel provides abstraction layers for hardware memory processors and input output I O and makes these tools available to the user space through system calls. The kernel events supports input output commands IOCMDs such as waiting for an event getting an event argument and one call that any kernel extension can use to notify an event that is put it on a queue for a user space entity to retrieve through a wait.

Referring again to the user space components of the I O filter system include a common security toolkit CST an xcrypt daemon which runs a key manager client several user space data files including a set of configuration files signed and made tamper proof by CST a lockbox also provided by CST and a key cache a powervt command line interface CLI a powervt application programming interface API a cryptographic key manager CKM client interface a key manager client a libemcp xcrypt userspace library and a libemcp events userspace library . One or more applications also run in user space but the applications are not part of the I O filter system . The I O filter system also includes several user space scripts including the xcrypt config script and the xcrypt startup script. The xcrypt config script is run only once after the initial installation of the I O filter system to execute all the commands that configure all the I O filter system components for performing encryption functions using the configuration files see e.g. block of the process of . The xcrypt startup script is run to start the daemon after reboot of the host and is also called from the xcrypt config script to start the daemon for the first time.

The key manager client is a component of the key manager server that operates remotely incorporated into the IO filter driver system on host and the key manager client operates in concert with the key manager server server. In the embodiment of keys are only provisioned by the key manager server by going through the key manager client . Referring again to provisioning happens starting in the powervt CLI going through the powervt API libemcp xrypt to CKM client through key manager client not going through the daemon . It will be appreciated by those of skill in the art however that embodiments of the invention could be implemented where a different component provides keys to the key manager server for provisioning to the I O filter system that is it is possible to generate keys outside of the key manager itself but later store the keys on the key manager .

The key manager client can cache certain encrypted keys and therefore does maintain and obtain encryption keys but only as a cache of what is on the key manager server which advantageously is the definitive source for encryption keys . The encryption keys include keys for encrypting and decrypting data. Note that there also are master keys for encrypting the encryption keys i.e. key encryption keys KEKs to provide further key security but the KEKs are stored in the lockbox and are used in at least some embodiments of the invention including but not limited to embodiments that are implemented in hardware based environments to encrypt the data encryption keys DEKs stored in the client key cache . Only encrypted keys are stored in the key cache . Note that in some embodiments the KEK is not used.

The I O filter system can be configured to work with various types of keys such as 64 128 or 256 bit keys and with various encryption algorithms. In one embodiment the keycache is accessible only in user space . In another embodiment the keycache grants read only access to the kernel .

The CST includes command line interfaces CLIs application programming interfaces APIs and libraries to help provide functions such as user authentication e.g. via CST Authentication role management authorization e.g. via CST role management account verification security functionality and password protection. In addition the CST includes a lockbox to securely store security information configurations and passwords including a CST master key. Passwords are encrypted using CST facilities and stored in the lock box or in the configuration files in the encrypted form. The Lockbox keeps the key for these encryptions in a secure fashion. The CST also stores configuration files in a tamper proof fashion by implementing configuration services to securely sign configuration files for the key manager client and the configuration files are signed to detect tampering with configuration information . The CLI uses the CST to authenticate users of the CLI . Authorization happens in the API using role management and the authentication token passed in to the API from the CLI .

The key manager client can cache encryption keys also referred to as data encryption keys DEK locally in the secure key cache along with other key attribute information. Usually this is done at the time the encryption key is first created and sent to the key manager client by the key manager server as will be explained further herein. These locally cached data encryption keys in the keycache are encrypted using a locally and automatically generated key encryption key KEK that is secured using a master key provided via lockbox and the CST encryption function. In one embodiment the keycache is accessible only in user space . In another embodiment the keycache grants read only access to the kernel . Note that the KEK is automatically generated at the time the host is setup to use encryption services.

Communications between the I O filter system including those of the key manager client and key manager server are protected in various ways including use of trusted root and key manager server certificates to prevent spoofing of the key manager server and an encrypted secure sockets layer SSL protecting the communications themselves.

The CKM client provides an abstract interface to the key manager client . For at least some embodiments of the invention it is advantageous to abstract the interface to the key manager client and key manager server components so that other code providing these functions could be used in the future and to separate cryptography from the I O control and operational paths. One concept for this abstraction is to create a context used by encrypt decrypt in the kernel . The context includes a keyblob.

The keyBlob is an abstraction that contains all the information stored by the key manager server that is needed by the encrypt decrypt code. None of the information stored internally in the keyBlob is needed by the I O filter system so it is possible for the structure of the keyBlob to be opaque to the I O filter system . There is a unique keyBlob for each logical unit and as explained further in the flowcharts of herein the keyBlob is looked up by key id a globally unique identifier and provisioned by a policy such as key class. A keyblob includes the actual encryption key plus other information used by a given encryption algorithm provided in accordance with a class definition provided to the key manager server . The key class definition includes information relating to information stored in the keyBlob which include but are not limited to Key key length encryption algorithm and mode of encryption algorithm. Note that although the keyBlob is a data structure handled in both user space and the kernel in at least some of the embodiments described herein the keyblob is primarily used for encryption in the kernel and the keyblob s handling in user space is primarily related to getting the keyblob to the kernel .

The xcrypt daemon launches the key manager client to look up keys actually keyBlobs on behalf of the xcrypt manager running in the kernel . The xcrypt daemon calls into the library libemcp xcrypt see to wait for key lookup requests and once the xcrypt daemon receives the request the daemon looks up the keyblob which may involve requesting it form the key manager server or could involve getting it from the client cache and then pushing the keyblob back into the kernel . The xcrypt daemon is launched when the one time use script xcrypt config is run and every time the host is rebooted.

As shown in the powervt CLI interface is a command interface to the powervt API . In other implementations a web based interface not shown may be included in addition to or in alternative to the powervt CLI interface . The powervt API represents an implementation of an application program interface API that provides a set of routines in libraries for implementing encryption on logical units.

The libemcp xcrypt library is the userspace interface to the xcrypt manager running in the kernel. The xcrypt library interfaces with the libemcp events event subsystem the xcrypt manager and the CKM client and provides functions to do the following 

The libemcp events is a userspace library that supports the events subsystem. The userspace calls go through this library to wait for events from the kernel events . Libemcp events is used by the xcrypt daemon to wait for key lookup events posted by the xcrypt manager through the kernel events subsystem .

The processes of are illustrated approximately in the order that they would occur. Note however that not every process shown in the blocks of necessarily will occur for every I O filter system . Initially the host is configured block using e.g. the process of block . When configuration is done encryption is turned on for a storage device and the storage device is established as an eVLU block e.g. via the process of . Note that the VLU represents a logical version of eVLU and the LU is the combination of and together the actual device. Block includes provisioning a key as well via the process of . Another process that can occur is configuring the eVLU to a host after the host has restarted or is rebooted block which process is discussed in greater detail in block .

A process for looking up a key for an already configured eVLU also can occur block as further shown in block . Processes for writing encrypted data to and reading encrypted data from an eVLU blocks respectively also are provided corresponding to the flowcharts of . The source eVLU can be replicated to a replica eVLU block via the process of and the metadata on an eVLU can be re read to determine if the state of an eVLU has changed block via the process of . Finally an optional process is provided for turning encryption off for an eVLU block via the process of .

Note that in some embodiments of the invention the host must receive a license for the I O filter system e.g. a license for POWERPATH ENCRYPTION WITH RSA before running the configuration script below.

In block a configuration script e.g. xcrypt config as described herein is run to enable the host for encryption. The xcrypt config is run once and only once on a host . Running xcrypt config implements a number of components and actions including

If the xcrypt manager indicates that the state of the device LU is already encrypted i.e. a valid key id already exists in the metadata an error is returned block and the process ends block . If a device state is not encrypted waiting for key or no key and not unencrypted it is in an unknown state and an error also is returned block and the process ends block . If at block a device s state is returned as unencrypted a process begins to turn on encryption for the device LU .

If the device e.g. LU is unencrypted the process begins to get a key. A key and key id are requested from the key manager server blocks and in the context of a call into libemcp xcrypt to turn encryption on for a particular LU . At this point the code in libemcp xcrypt calls into the key manager client code through the CKM interface to provision a key. Referring briefly now to is a flow chart showing a method of provisioning a key id and key keyblob for a device configured in accordance with the process of in accordance with one embodiment of the invention. The blocks of are processed at and in cooperation with the key manager server in one embodiment of the invention. When the request for a key and key id are received block an encryption key is provisioned block . A unique key id also is generated block note that generation of the key id could take place at another entity other than the key manager server and then be provided in response to the request of block .

A copy of the key key id and associated key information which is used to accomplish encryption decryption and which will later become part of a keyblob is stored at the key manager server block . The key id key and associated key information also are returned block to the requester. Note that the key lookup of can in one embodiment be accomplished locally via a lookup to the keycache that the key manager client keeps on the host and or in the host file system where the key cache can be preloaded with a new key however in this alternate embodiment the steps of would be performed in advance of turning on encryption for a particular device LU . Alternately as described herein the key can be obtained directly from the key manager server .

Referring again to at block the key id key and associated key information e.g. key length key algorithm are received block at the I O filter system into libemcp xcrypt . A keyblob is created e.g. by the CKM client based on the received key and associated key information block . The libemcp xcrypt then calls into the kernel to push the keyblob into the kernel. The keyblob and key id are sent to the xcrypt manager through an IOCMD. In addition a flag is set to indicate that the VLU is new i.e. this is a device newly having encryption turned on . block After the keyblob and key id are pushed a check is made as to whether the VLU is in use block . If yes then an error is returned block . If no then the xcrypt manager writes the key id into the metadata such as via the vlumd manager block which allocates metadata space writes a signature into metadata space and writes the key id into metadata space. After the completion of block the LU will be recognized by a host or other entities as an eVLU because the key id has been written into metadata . The xcrypt manager stores the keyblob and key id in a device data structure kept in non pageable kernel memory block which ensures that the keyblob and key id are protected by the kernel and never get written to a persistent storage device like a disk. The device data structure on the eVLU also includes device identifier device id information where the device id is used to identify the underlying LUN that is encrypted and is used to lookup the data structure where the encryption key is stored in the kernel. Once block is complete the state of the eVLU is set to encrypted in the device data structure and the device is now an eVLU . At this point the I O filter driver is ready to handle I O to the newly created eVLU

First a determination is made as to whether metadata can be read block . For example the xcrypt manager attempts to read the key id from the metadata via the vlumd manager . If the metadata region cannot be read it is presumed that the device state is unknown and the device state is set to unknown in the device data structure block . If the device state is unknown read access is permitted to areas of the LU device that are known not to be encrypted regardless of whether or not the device is an encrypted eVLU and all other I O to the device LU is failed block . Note that in at least some embodiments of the invention the I O filter system keeps track of regions or blocks of a device that are kept in plain text even if the device is encrypted. Furthermore in accordance with at least some embodiments of the invention there are two types of regions that are unencrypted. As noted previously some regions are known to be unencrypted for any device block 0 on Solaris or Windows or AIX for instance . Other regions are device dependent stored in the metadata and can t be known at this point the regions are known only after metadata can be read.

If the metadata location was able to be read block a check is made as to whether there is valid metadata in the location and whether that metadata contains a key id block . For example in one embodiment the xcrypt manager of the I O filter driver in one embodiment checks whether there is valid metadata in the location. Note that a virtualized LUN could have a defined metadata region with metadata on it but the metadata might not include a key id. As those of skill in the art are aware there are other types of metadata. If the answer to either of those questions is no then it is presumed that the device is unencrypted the device state is set to unencrypted in the device data structure and all I O to all regions of the device is permitted block consistent with the type of device for example if the device is read only write I O will not of course be permitted . All I O to all regions of the device is permitted by xcrypt.

If the metadata region contains a key id block then the key id can be used to get a key for access to data on the eVLU block . A request for key lookup is made to the key manager client such as via the xcrypt daemon block . The request includes the device id and the key id which is provided for key lookup. The device id in one embodiment is used to identify the underlying LUN that is encrypted and is used to lookup the data structure e.g. the xcrypt manager within the I O filter driver where the encryption key is going to be stored in the kernel . The key lookup request goes into a queue of kernel requests block as part of the kernel events . Note that there is a queue of requests in the kernel and this request is added to the queue. The user space daemon is constantly waiting for requests to be added to the queue in the kernel .

At the kernel in the xcrypt manager the key id is stored in the device data structure for the device denoted by the device id for later checks block . The state of the eVLU is set to waiting for key block . In the waiting for key state for an eVLU I O to all encrypted areas is disabled and or pended until the key is looked up and cached in the kernel in xcrypt manager . I O is permitted however to non encrypted areas as described above for the state being unknown. For example if there are device specific regions that are in plain text the device specific regions can also have I O access because the metadata can be read to get this information as to the regions that are in plaintext. The daemon will request this particular event lookup of a key .

As illustrates the state of each device also is stored in the device data structure that is the state as kept by the xcrypt manager which also keeps the device data structure . While the state of the eVLU is waiting for a key processing moves to which is a flow chart showing a method for getting a key for a device that has encryption turned on in accordance with one embodiment of the invention. This process is executed by the daemon . At block a call is made into the kernel into I O filter driver to get a key lookup request. If the key lookup request is not received at the kernel block then a timeout occurs block and calls are made again into the kernel and the daemon waits in the kernel until either a key lookup request arrives or the timeout occurs. If the key lookup request is received by the daemon daemon goes through the key manager client to request the key associated with the unique key id in the request. The key manager client first attempts to find the key in the keycache block . If the key is in the keycache then the keyblob is returned block and a call is made into the kernel with the keyblob and key id block . Note that in this block when the keyblob is pushed a flag is not set as it was in block of FIG. because the device in this block is not newly having encryption turned on.

A check is made block as to whether the key id provided in the IOCMD sending the keyblob into the kernel matches the key id that was previously stored in the device data structure at the time the key lookup request was made i.e. at block of . For example the IOCMD sending the keyblob into the kernel includes the unique key id and device id that were part of the key lookup request in block . The xcrypt manager uses the device id to locate the device data structure and then matches the unique key id. If there is no match block it is assumed that a later request in the queue of requests will have the correct key id and the process returns to the user space daemon running at block to wait for such a request.

If the key id matches at block the keyblob is stored in the device data structure block and the eVLU device state is set to encrypted block . Because the encryption key is available reads and writes are enabled into all areas of the eVLU that were previously disabled if applicable block and the process returns to the user space daemon running at block to wait for further key lookup requests.

If at block the key was not in the keycache then the key must be obtained from the key manager server . Note that although not illustrated explicitly in if the key server is not found or cannot be connected to an error can be returned as would be expected by those of skill in the art. First security checks are performed between the key manager client and the key manager server to verify that the host where the client is running is allowed access to the server and that the server is authentic blocks . If the security checks fail an error is returned block and the kernel xcrypt manager is informed that the key lookup failed block . If security checks pass then the key id is provided to the key manager server to request a key and keyblob related information from the key manager server block . An additional security check is performed at the key manager server block to verify that the host where the client is running is allowed to access the key associated with the unique key id. If the security is not OK an error is returned block indicating that key lookup failed block . If the security is OK however a check is made as to whether the key manager server has returned a keyblob block . If the keyblob was returned aforementioned blocks through are performed as discussed previously.

If the keyblob was not returned at block a call is made into the kernel xcrypt manager to indicate that the key lookup failed block . When key lookup fails the state of the device is set to encrypted but no key. Read I O and write I O in some instances is permitted to non encrypted areas of the eVLU only but all other I O fails block . The process proceeds back to the userspace daemon and block block .

With the flowcharts of it is still important to remember that having the key id alone is not enough to get a key to decrypt data. It is still necessary to fulfill all other security requirements including for replicas. These security requirements include but are not limited to 

Of course those of skill in the art will appreciate that many different security techniques and implementations are usable with one or more embodiments of the invention.

Referring again to if the device state is encrypted but the I O request is to write data to a nonencrypted area or block of the eVLU block then write I O is permitted block and the I O request is passed down the I O stack. If the device state is encrypted and the I O request is to write data to an encrypted area of the eVLU whether by default because the entire eVLU is encrypted or because the I O filter driver of the I O filter system is aware that the blocks to be written to are encrypted blocks then the process to encrypt data written to the eVLU is begun block . The xcrypt manager is used to accomplish this as well as the other steps of except for the encrypt call itself block which is made from the xcrypt manager to the crypto kernel module code.

Optionally the existing user buffer is mapped into the kernel virtual address space in order to make it accessible from the kernel block . The xcrypt manager allocates a private local buffer as an encryption buffer to hold the encrypted data before it is written to the eVLU block . To ensure that the data to be written is going to be encrypted before being written the I O request is modified so as to temporarily use the encryption buffer in place of the user buffer block . The location of the original user buffer is retained for later restoration.

The xcrypt manager calls encrypt by passing the device specific keyblob to the CKM kernel of the crypto kernel and the CKM kernel passes the keyblob to the encrypt decrypt lib of the crypto kernel . The crypto kernel uses the keyblob to encrypt data as it is moved from the user buffer to the encryption buffer block . The encryption buffer now contains encrypted data block . The I O request to write data is passed down the I O stack block . I O then passes through its normal places in the I O stack e.g. as partially shown in eventually passing through the HBA and to the storage device. Processing at this point proceeds to the process of block .

Before proceeding with one path in still requires discussion. In block if the state of the device isn t encrypted a check is made as to whether the state of the device is unencrypted block . If the device state is not unencrypted and isn t encrypted then the device state is one of three other states unknown waiting for key no key block . In one embodiment the I O filter system follows a set of I O rules for the state and conditions applicable to the device based on device state which depends on the validity and or availability of the key id and the keyblob block . Table 1 lists some exemplary rules for at least one embodiment of the invention for encrypted regions of the device and in accordance with another embodiment of the invention for unencrypted regions of the device is provided below these rules are illustrative and not limiting.

Referring again to the encryption buffer is de allocated block . If necessary the user buffer is unmapped from kernel if such mapping occurred in block of or block of . The I O request is modified so that it again points to the user buffer block .

When an I O request to read data from a device is received block the I O filter system actually the xcrypt manager within the I O filter driver checks whether the device state stored in the device data structure is encrypted block . If the device state isn t encrypted then all read I O is permitted block . In block if the state of the device isn t encrypted a check is made as to whether the state of the device is unencrypted block . If the device state is not unencrypted and isn t encrypted then the device state is one of three other states unknown waiting for key no key block . In one embodiment the I O filter system follows a set of I O rules for the state and conditions applicable to the device based on device state which depends on the validity and or availability of the key id and the keyblob block . Table 1 listed above in connection with block of also is applicable to block of .

If the device is encrypted i.e. is an eVLU an optional check is made as to whether the request to read data involves reading data from an encrypted area of the eVLU block . Recall that in some embodiments the eVLU can be configured so as to have in addition to the metadata region a non encrypted area and an encrypted area . If the eVLU is configured such that all areas of it excepting the metadata are encrypted then the optional check at block may not be necessary.

Referring again to if the eVLU is encrypted but the I O request is to read data from a nonencrypted area or block of the eVLU then read I O is permitted block and the I O request is passed down the I O stack. If the eVLU is encrypted and the I O request is to read data from an encrypted area of the eVLU whether by default because the entire eVLU is encrypted or because the I O filter system in particular the xcrypt manager in driver is aware that the blocks to be read from are encrypted blocks then the process to decrypt data written to the eVLU is begun block . The xcrypt manager is used to accomplish this as well as the other steps of except for the decrypt call itself block of which is made from the xcrypt manager to the crypto kernel module code.

Optionally the existing user buffer is mapped into the kernel virtual address space in order to make it accessible from the kernel block . The xcrypt manager allocates a private local buffer as a decryption buffer to hold the encrypted data cipher text when it is read from the eVLU block . To ensure that the data to be read is going to be decrypted before being returned to the caller the I O request is modified so as to temporarily use the decryption buffer in place of the user buffer block . The location of the original user buffer is retained for later restoration. The I O request to read data is then passed down the I O stack block . I O then passes through its normal places in the I O stack e.g. as partially shown in . Processing at this point proceeds to the process of block .

In the context of the reading data from the eVLU in accordance with the process of for asynchronous I O as is known in the art whenever data is received an acknowledgement such as an I O DONE interrupt is received block . If the original request was to read data block and the I O done interrupt is received then the xcrypt manager calls decrypt by passing the device specific keyblob to the crypto kernel block . The crypto kernel decrypts data as it is moved from the decryption buffer to the user buffer block . The user buffer now contains plaintext block and the read request was successful. The encryption buffer is de allocated block . If necessary the user buffer is unmapped i.e. if such mapping was done at block of . The I O request is modified so that it again points to the user buffer block .

The primary source eVLU is replicated to a replica LUN. The replication can be by methods that include but are not limited to methods such as those used in the aforementioned SRDF Timefinder and Mirrorview products from EMC. As part of replication the data on the replica LUN is synchronized with the data on the source eVLU . Known replication technology such as Timefinder replication within an array or SRDF replication between arrays over a network that connects them directly for the SYMMETRIX line of disk arrays available from EMC Corp. can for example be used for synchronization. In another example an appliance or switch in the network can replicate between two devices on the network on the same or different arrays. In still another example where the source and replica logical volumes are located within a single array data can be transmitted from the source logical volume to the target logical volume without involving a network or a host. During the synchronization an application on host may have continued access to the information on the source eVLU

The synchronization part of replication involves moving or copying the data from the source or primary eVLU to the replica LUN. As is understood in the art various techniques can be used to perform synchronizations. For example a mirroring facility such as the SYMMETRIX Remote Data Facility SRDF available from EMC Corporation Hopkinton Mass. may be used to create mirrors between source and target volumes on different storage systems and to then synchronize them so that the storage systems themselves perform the copy.

In another situation the replica eVLU might be removed from the host while synchronizing and is then configured back to the host when synchronization is complete. Note that removing a device from the host causes the host to notice that the device has been removed and the host discards its cached information about the device.

Referring again to after replication and synchronization the replica LUN becomes a replica eVLU and because the metadata was also replicated the replica eVLU has in its metadata the same key id as the metadata on the source primary eVLU block . Optionally the source primary eVLU can be separated or split from the replica eVLU if that step is required by the replication method block . If the replica eVLU was already configured to the host with which it is to be used block then processing proceeds to block block . If however the replica eVLU is not yet configured to the host with which it is to be used then the process of is run to configure the replica eVLU to a host that has been configured to use the key manager server that holds the key for the primary eVLU per block . Depending on the protected perimeter desired the replica eVLU can be configured to the same host as the source eVLU or can be configured to a different host. However the replica eVLU and the source eVLU need access to the same key manager server or replicas of that key manager server.

Note that configuration will lead to looking up a key for the replica eVLU block where the key itself will be the same as that for the source eVLU. Once the replica eVLU is configured to a host and the key is available block encrypted data on the replica eVLU can be read such as via the process of .

One point that should be appreciated regarding the process of is that no extra steps are required over what is required to replicate a plain text volume so long as each host that sees an eVLU is properly configured with the I O filter system and that all hosts that share replicas e.g. like the arrangement shown in the protected perimeter of use have access to the same key manager server. Generally for replica eVLUs the key to access encrypted data on the eVLU is looked up either by configuring the replica block or by opening the replica eVLU for those operating systems that have device open as a feature . The key id stored in the metadata in the replica eVLU is used to obtain the key the same as occurs with a non replica eVLU. For some situations e.g. those running on WINDOWS based operating systems and other situations where a replica LUN is not opened before access a command such as powervt update might need to be run to trigger the kernel to recognize the change in state of a device e.g. a LUN going from unencrypted to being an eVLU . This is further addressed in . In another situation the replica device is removed from the host while synchronizing and is then configured back to the host when synchronization is complete in this case the processes shown in will be executed and the powervt update command is not needed.

In block of a device open or powervt update has occurred or some other event has occurred that triggers a re read of metadata on a device. A process is begun to detect whether a particular device being opened or updated is an eVLU device starting with an attempt by the vlumd manager to read metadata on the device to determine if there is a key id is in the metadata block . If the metadata location cannot be read block then the state of the device is set to unknown that is it cannot be determined if the device is an eVLU and read I O and in some instances write I O is permitted to non encrypted areas of the device assuming that the I O filter system has knowledge of which areas if any are non encrypted but all other I O fails block . The situation of a metadata location being unable to be read can occur for example if a storage device is offline or not ready which is the state of a TIMEFINDER business continuance volume BCV for example when it is being synchronized with the primary device. 

If at block the metadata location can be read a check is made as to whether there is valid metadata containing a key id block . If there is not valid metadata containing a key id a check is made e.g. by the vlumd manager whether a key id is stored in the device data structure in the xcrypt manager block . If no key id is stored in the device data structure then there has been no change in the state of the device block and the device state remains unencrypted and all I O is permitted block . Note that all blocks in after block take place in one embodiment in the kernel.

If there is not valid metadata containing a key id but there was a key id stored in the kernel i.e. a yes answer at block then that indicates that the device has changed state block namely going from having a key id to having no key id meaning that the device has changed state from encrypted to unencrypted. For the unencrypted device state all I O is permitted block .

If there is valid metadata that can be read and it contains a key id then a determination must be made if this represents a change in state and or if the key is in the device data structure block . If a key id was returned in block then determinations need to be made as to whether this represents a change in state for the device whether the key id is the same as that previously stored in the device data structure and also whether the keyblob associated with the key id is stored in the device data structure block . If the key id returned in block is the same as that stored in the device data structure in the kernel block then a check is made as to whether the device state stored in the device data structure is encrypted. If the state is encrypted then the associated keyblob is also stored in the device data structure block . If the device state stored in the device data structure is listed as encrypted that means that there has been no change in state.

If the device state stored in the device data structure is not listed as encrypted then a check is made as to whether the device state stored in the device data structure is no key block which means that there is no keyblob in the device data structure but the device is encrypted. If Yes the key needs to be retrieved and the process of is used to look up the key that goes with the key id block . If the device state is not no key then by process of elimination it must be waiting for key block . In this case the key id is unchanged and the request to lookup the key has not yet been responded to by the xcrypt daemon .

If at block the key id on the device being read is not the same as the key id that was stored in the device data structure for that device then one of two conditions has occurred. One alternative is that the key id changed e.g. from key id1 to key id2 which can indicate that a device that was synchronized with e.g. source device A has since system reboot or since the last time the device was opened been made the replica of and synchronized with source device B . Under this alternative the device state is set to waiting for the key block that goes with the unique device id currently in the device metadata. The other alternative is that the device went from no key id in metadata at the time of system reboot last device open to having a key id in metadata which can occur when an unencrypted device becomes synchronized with an encrypted device. In this situation as well the device state is set to waiting for the key that goes with the unique device id currently in the device metadata. For either case the next step is to discard the keyblob in the device data structure if applicable i.e. if there is one to discard as a correct one will be pushed into the kernel to the xcrypt manager when the correct key is returned. The process of starting at block is used to look up the key that goes with the key id.

If security is OK a check is made to see if the metadata on the device can be read as part of verifying that the device is in fact encrypted block . If the metadata cannot be read then the attempt to turn encryption off fails and an error is returned block . If the metadata location can be read the metadata is checked to see if the eVLU is already unencrypted e.g. by checking whether the metadata includes a device id block . If the device state is already unencrypted then it is unnecessary to remove the encryption property and the process stops block .

If the device state is not unencrypted and the metadata location can be read then the device is in fact encrypted block . An attempt is made to undo the eVLU encrypted property by attempting to remove the key id from the metadata region of the eVLU such as by setting a property of the key id to null and size to zero which indicates that the name value pair for the key id is no longer stored in the metadata.

If the attempt to undo the encryption property in metadata was unsuccessful block then an error is returned. Note that all processes from block on take place in the kernel . If the attempt was successful then the keyblob and key id are removed from the device data structure in the kernel block . The device state is set in the device data structure to unencrypted. Block and all I O to the LU is permitted including to unencrypted regions if applicable although ability to decrypt to the encrypted data is now lost block .

The methods disclosed herein are especially useful in computer systems utilizing an enterprise storage system however one of ordinary skill in the art will appreciate that the features and principles of the present invention may be implemented in many other types of computer systems. One of ordinary skill in the art will also appreciate that features and principles of the present invention may be implemented in different components of a computer system with at least one associated data storage subsystem.

In describing the embodiments of the invention illustrated in the figures specific terminology is used for the sake of clarity. However the invention is not limited to the specific terms so selected and each specific term at least includes all technical and functional equivalents that operate in a similar manner to accomplish a similar purpose.

As those skilled in the art will recognize the invention described herein can be modified to accommodate and or comply with existing and or newly developed technologies and standards. In addition variations modifications and other implementations of what is described herein can occur to those of ordinary skill in the art without departing from the spirit and the scope of the invention as claimed. Further virtually any aspect of the embodiments of the invention described herein can be implemented using software hardware or in a combination of hardware and software.

It should be understood that in the Figures of this application in some instances a plurality of system elements or method steps may be shown as illustrative of a particular system element and a single system element or method step may be shown as illustrative of a plurality of a particular systems elements or method steps. It should be understood that showing a plurality of a particular element or step is not intended to imply that a system or method implemented in accordance with the invention must comprise more than one of that element or step nor is it intended by illustrating a single element or step that the invention is limited to embodiments having only a single one of that respective elements or steps. In addition the total number of elements or steps shown for a particular system element or method is not intended to be limiting those skilled in the art will recognize that the number of a particular system element or method steps can in some instances be selected to accommodate the particular user needs. Moreover the steps of the disclosed methods may be modified in any manner including by reordering steps and or inserting or deleting steps without departing from the principles of the invention.

The processes flow charts and flow diagrams provided herein do not depict the syntax of any particular programming language. Rather they illustrate the functional information one of ordinary skill in the art requires to fabricate circuits or to generate computer software to perform the processing required of the particular apparatus. It should be noted that many routine program elements such as initialization of loops and variables and the use of temporary variables are not shown. It will be appreciated by those of ordinary skill in the art that unless otherwise indicated herein the particular sequence of steps described is illustrative only and can be varied without departing from the spirit and scope of the invention.

It is believed that computer programs based on the written description and methods of this invention are within the skill of an experienced developer. The various programs or program modules can be created using any of the techniques known to one skilled in the art or can be designed in connection with existing software. For example program sections or program modules can be designed in or by means of Java C C HTML XML or HTML with included Java applets. In addition one or more of such software sections or modules can be integrated into a computer system or browser software.

Although the invention has been described and pictured in a preferred form with a certain degree of particularity it is understood that the present disclosure of the preferred form has been made only by way of example and that numerous changes in the details of construction and combination and arrangement of parts may be made without departing from the spirit and scope of the invention as hereinafter claimed.

