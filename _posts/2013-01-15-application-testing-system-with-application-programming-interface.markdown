---

title: Application testing system with application programming interface
abstract: A system is described for testing an application on one or more host devices in a host device farm. A build server uses an application programming interface (“API”) to send a test package containing an application to a test server. The sending may be initiated by a single action such as a click on a control in a user interface, or may be automatic such as on completion of a build. The test server may then execute and test the application across one or more host devices. These host devices may include smartphones, tablet computers, televisions, set-top boxes, in-vehicle computer systems, home entertainment systems, and so forth. Test results based at least in part on the execution of the application module on the one or more host devices may then be provided to the build server.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09274935&OS=09274935&RS=09274935
owner: Google Inc.
number: 09274935
owner_city: Mountain View
owner_country: US
publication_date: 20130115
---
With the growing popularity of computing devices there is an increasing demand for applications or apps to run on such devices. These devices may include smartphones tablet computers televisions set top boxes in vehicle computer systems home entertainment systems and so forth. To satisfy this demand programmers are constantly building testing and maintaining applications. Testing of these applications is useful for quality assurance to find and correct errors.

Certain implementations and embodiments will now be described more fully below with reference to the accompanying figures in which various aspects are shown. However various aspects may be implemented in many different forms and should not be construed as limited to the implementations set forth herein. Like numbers refer to like elements throughout.

A wide variety of applications or apps are developed for execution on computing devices including smartphones tablet computers televisions set top boxes in vehicle computer systems home entertainment systems and so forth.

There is an increasing demand for software users to build apps to run on such devices. Software users build test and maintain applications using a variety of development and build tools. Testing provides many benefits including finding and correcting errors improving performance and so forth. Testing may include observing processor usage observing memory allocation programmatic debugging determining usability validating functionality identifying regressions and so forth.

Continuous integration and other application development methodologies encourage frequent testing of ongoing builds of an application. For example code for an application may be checked into a build server which creates a build. This build may then be used for ongoing development troubleshooting testing and so forth. By increasing the frequency of builds of the application problems with a build may be identified more quickly and the application development process may be improved.

Traditional testing systems lack the ability to provide development tools for testing of applications executing on computing devices. Software users have had to rely on cumbersome methods for testing including use of software simulators manually provisioning and testing on computing devices connected to a particular user s desktop computer and so forth. Simulators lack the full fidelity provided by execution on the actual computing device resulting in incomplete testing. Manual provisioning and testing with a connected computing device is time intensive and may result in the user s desktop computer being occupied with running the testing process in conjunction with the connected computing device.

This disclosure describes embodiments of systems and methods for testing applications using one or more actual computing devices also known as host devices. A client device such as a desktop computer laptop and so forth may work in conjunction with a build server. The build server may be configured to support development of the application by maintaining and generating one or more builds of the application from source code code provided by users or other sources. These builds may then be sent for testing.

In one implementation the build server may generate a test package including a build of the application. The test package is sent to a test server using an application programming interface API . The API may implement a representational state transfer REST sent using hypertext transfer protocol HTTP . The generation of the test package sending the test package or both may be initiated by a user activating a control automated process or combination thereof.

The test server receives the test package and configures one or more host devices to execute the application. This execution may include testing monitoring and so forth configured to generate test results. The test results may then be returned to the build server the client devices or both. In some implementations the test results may comprise information expressed as extensible markup language XML JavaScript Object Notation JSON or both.

By providing the functionality for the build server to easily transfer the test package to the test server and return test results the overall testing process for applications configured for deployment and execution on the host devices may be expedited. The host devices used during testing may vary from one another in hardware software configuration and so forth. Additionally the use of a plurality of host devices allows for contemporaneous testing in parallel reducing time to provide test results compared to a sequence of serial tests on a single host device. Finally the use of the actual computing device during testing provides the highest fidelity testing available which is representative of the end user experience which may improve quality of the application as released to the end user.

The application may be a native app a markup language application hybrid app or a browser based application. Native applications are those which are written and compiled for execution on the particular device. For example native applications may be written in a programming language such as C or Objective C and compiled into native code such as a binary executable for use on the device. Markup language applications include one or more instructions in a markup language which may be rendered by a layout engine and one or more instructions in a scripting language which may be interpreted by a scripting language engine during execution. For example a hypertext markup language HTML version 5 or greater markup language application may include HTML cascading style sheets CSS and JavaScript. In some implementations the markup language application may have multiple instances of the UIWebView class references. Hybrid applications include native code and markup language application portions. Browser based applications are processed within a web browser application and are limited in execution. The browser based applications may have only a single UIWebView instance.

The build server may comprise one or more modules such as a source code control module build module and so forth. The source code control module may be configured to provide control of source code check in check out of source code to users and so forth. The build module is configured to take associated source code and generate a build of the application . The application as built comprises source code configured for execution on the host device. In some implementations the application as built may include executable binaries markup language applications and so forth. In some implementations the users may use the build server to implement a continuous integration methodology of software development in which workspaces of the users are merged frequently such as several times per day.

The build server may be configured to implement or work in conjunction with systems implementing one or more of the Rational ClearCase family of tools from IBM Corp the Hudson tool developed at least in part by Kohsuke Kawaguchi and available at hudson ci.org the Jenkins tool as forked from Hudson and promulgated by Kohsuke Kawaguchi which is available at jenkins ci.org Perforce from Perforce Software Inc. of Alameda Calif. or GitHub from GitHub Inc. of San Francisco Calif.

The build server is configured to couple to one or more networks . The networks may include public networks such as the Internet private networks such as an institutional and or personal intranet or some combination of private and public networks. The networks may also include any type of wired and or wireless network including but not limited to local area networks LANs wide area networks WANs Wi Fi WiMax and mobile communications networks e.g. 3 G 4 G and so forth . The networks may utilize communications protocols including packet based and or datagram based protocols such as internet protocol IP transmission control protocol TCP user datagram protocol UDP or other types of protocols.

A test server may also couple to the one or more networks . Communication may be established between the build server and the test server . The build server is configured to generate and send a test package to the test server . The test package may comprise the application build tests configuration data build information and so forth. The build server may send the test package using a uniform resource locator URL which is associated with a particular account on the test server . The URL used by the build server to send the test package may be unique to a particular user group of users build server entity organization and so forth.

The test server comprises a test server API module configured to accept and respond to the test package sent by the build server . In one implementation the test server API module may implement a representational state transfer REST responsive to data sent using a hypertext transfer protocol HTTP . The exchange of information between the build server and the test server may be encrypted. For example transfers of the test package may use HTTP secure HTTPS .

As described above the build server may be configured to implement or work in conjunction with various systems to support development. In one implementation the build server may implement a Hudson Jenkins build server system with plugins configured to interface with the test server using the test server API module . The plugins may allow for opening a specific host device with an installed specific build of the application as a post build option. The plugins may also allow for automated calls to the test server to interact with particular builds.

In some implementations the test server may be configured to work with various tools such as ClearCase Jenkins Hudson Perforce GitHub and so forth. Similarly the test server and the services provided by the test server may be configured to integrate with various software development kits SDKs . For example integration may be provided for SDKs promulgated by Sencha Inc. of Redwood City Calif. PhoneGap by Adobe Systems of San Jose Calif. AppGyver by AppGyver Inc. of San Francisco Calif. Eclipse by the Eclipse Foundation of Ottawa Ontario and so forth. The test server or portions thereof such as the test server API module may be customized to allow for integration with particular users or entities. Users with appropriate access rights to these tools may able to make API calls to the test server to allow for the selection of a particular application for testing or other actions. The selection of the particular application may be automated such that operation occurs without human intervention.

An unpack module may be configured to unpack the test package . This unpacking may include one or more of separating out the executables tests configuration data build information and so forth.

A host device remote control module is configured to couple to one or more host devices in a host device farm . The host devices may include smartphones tablet computers televisions set top boxes in vehicle computer systems home entertainment systems and so forth. The host device farm may include different varieties of host devices . These varieties may reflect differences in hardware software configuration and so forth. For example the host device farm may include host devices from manufacturer A manufacturer B and so forth. Furthermore these host devices may be of different generations capabilities and so forth. Continuing the example the host devices from the manufacturer A may include tablet computers smartphones and so forth.

In some embodiments the test server may employ one or more input output I O interfaces comprising an electrical or optical connection to couple to the one or more host devices in the host device farm . In one embodiment a universal serial bus USB . or better connection may be used to communicatively couple the host device to the test server . The USB connection may be used to transfer data from the host device to the test server or another test server using TCP as a communication protocol. The data may include the application testing applications screenshots test results diagnostic data and so forth.

The USB connection may support high speed data rates exceeding 400 Mb sec and up to 480 Mb sec enabling a video stream from the host device display to be provided to the test server which is a high fidelity representation of the images presented on the host device . Other implementations of USB such as USB 3.0 and beyond may also be used. In other implementations other connections may be used including but not limited to high definition multimedia interface HDMI Institute of Electrical and Electronics Engineers IEEE 1394 interface Ethernet external serial attachment interface eSATA and so forth.

The host device remote control module is configured to send using the I O interface one or more instructions to an input virtualization module executing on at least a portion of the one or more host devices in the host device farm . The one or more instructions are configured to perform at least one input event on the one or more host devices during the execution of the application .

The host device remote control module may provide other instructions to the host device . For example the instructions may initiate one or more test applications diagnostic functions and so forth on the host device such as described below.

The host device remote control module may also be configured to receive information from the one or more host devices . This information may include diagnostic output testing outputs screenshots of one or more of the displays of the one or more host devices and so forth. The screenshots may be stored as still images or combined to form a video stream representative of information presented on the display of the host device . The screenshots generated as the one or more host devices execute the application may be received by the test server for analysis presentation to the user stored and so forth.

Additional details on remote control of the host device may be found in U.S. patent application Ser. No. 13 619 867 filed on Sep. 14 2012 titled Remote Control of a Mobile Device to Manish Lachwani et al. which is incorporated by reference into this disclosure.

A traffic modification module is configured to modify communications between the host devices and one or more external devices . The external devices may include servers or other devices which are accessible using the one or more networks . As described above the networks may include local or wide area networks. The modification may be used to introduce into the testing environment of the application conditions associated with different network conditions such as a particular carrier network low signal strength and so forth. The traffic modification module may be configured with network profile data which comprises network profile parameters. The network profile parameters are configured to instruct the traffic modification module to modify at least a portion of network traffic between one or more of the host devices and the external devices .

Additional details on the traffic modification module may be found in U.S. patent application Ser. No. 13 680 671 filed on Nov. 19 2012 titled Configurable Network Virtualization to Manish Lachwani et al. which is incorporated by reference into this disclosure.

An application validation module may also be provided in the test server . The application validation module is configured to use assembly code data generated during execution of the application on the host device to generate object level hierarchy data associated with the application . The object level hierarchy data indicates a hierarchical association between a plurality of objects based on one or more determined parent child relationships between the objects. In some embodiments the application validation module may iteratively request portions of the assembly code data to analyze address data for objects listed in the assembly code data determine parent child relationships among the objects or generate one or more object level hierarchies based on the objects and their relationships. As used herein address data describes addresses for locations in virtual memory on the device where the application is executing. Address data may also describe addresses for locations in active memory or program memory on a device.

Object level hierarchies for different application builds may be compared to identify differences between them. For example differences between the current version and the previous version may be identified. Embodiments may identify one or more of differences in the number or identity of objects in the hierarchy differences in the relationships between the objects or differences in one or more attributes associated with the objects. In this way embodiments may identify regressions or bugs in a particular feature set of the application through comparison of object level hierarchies generated for multiple versions of the application . Information associated with the object level hierarchy may also be used to confirm compliance with target character sets e.g. for localization of the application .

Additional details on the application validation module may be found in U.S. patent application Ser. No. 13 631 919 filed on Sep. 29 2012 titled Application Validation Through Object Level Hierarchy Analysis to Manish Lachwani et al. which is incorporated by reference into this disclosure.

The test server may also incorporate an audit module . The audit module is configured to analyze object data resulting from assembly code generated during execution of the application on the host device to identify objects which communicate with external devices or services while executing on the host device . This analysis may reveal one or more security risks associated with execution of the application . Identification of security risks may indicate that the application includes features that may lead to data corruption data destruction data theft data leakage or data intrusion on the host device or on a networked device in communication with the host device such as the external device .

Additional details on the audit module may be found in U.S. patent application Ser. No. 13 655 667 filed on Oct. 19 2012 titled Application Auditing Through Object Level Code Inspection to Manish Lachwani et al. which is incorporated by reference into this disclosure.

A markup language hybrid testing module is configured to provide testing functionality associated with markup language applications or hybrid applications. Additional details on the markup language application and hybrid application testing may be found in U.S. patent application Ser. No. 13 721 632 filed on Dec. 20 2012 titled System for Testing Markup Language Applications to Manish Lachwani et al. which is incorporated by reference into this disclosure.

A test result module is configured to generate test results based at least in part on information provided by one or more of the host device remote control module the traffic modification module the application validation module the audit module and so forth. The test server API module may be used to provide the test results to the build server the client devices or both. In one implementation the test results may be expressed using extensible markup language XML JavaScript Object Notation or both. For example a view hierarchy of a user interface associated with the application may be generated during testing. For example rendering of the user interface of the application may vary based on form factor of the host devices build of the application and so forth. The test result module may be configured to provide test results comprising view hierarchy information in an XML format for sending to the build server or another device for analysis. In some implementations the test server API module may be configured to allow for interaction elements of the view hierarchy. For example the user may use an API call to the test server API module to interact with a specific UIView in the view hierarchy.

The build server may receive the test results . The build server may provide at least a portion of the test results or information based at least in part on the test results to the client devices for presentation to the users . In some implementations the build module may use information in the test results to indicate portions of the application which have passed or failed testing by the test server .

The modules of the build server the test server the host devices and so forth are described in this disclosure as separate modules. In some implementations at least a portion of the functionality of these modules may be combined into a single module or incorporated into another module.

The build server may include one or more input output I O interface s to allow the build server to communicate with other devices. The I O interface s may couple to one or more I O devices . In some embodiments the I O device s may be physically incorporated with the build server or be externally placed.

The build server may also include one or more network interfaces to enable communications between the build server and other networked devices. Such network interface s may include one or more network interface controllers NICs or other types of transceiver devices configured to send and receive communications over the network s . For example the network interface s may be configured to provide a Wi Fi connection compliant with one or more IEEE 802.11 standards such as 802.11g or 802.11n. The build server may also include one or more busses or other internal communications hardware or software that allow for the transfer of data between the various modules and components of the build server .

The build server includes one or more memories . The memory comprises one or more computer readable storage media CRSM . The CRSM may be any one or more of an electronic storage medium a magnetic storage medium an optical storage medium a quantum storage medium a mechanical computer storage medium and so forth. The memory provides storage of computer readable instructions data structures program modules and other data for the operation of the build server .

The memory may include at least one operating system OS module . The OS module is configured to manage hardware resources such as the I O interface s and network interface s and to provide various services to applications or modules executing on the processor s .

The memory may include a user interface module the application the source code control module the build module or other module s . The user interface module is configured to provide a user interface to the one or more client devices . In some implementations the user interface may comprise a graphical user interface and may be delivered as hypertext markup language HTML data configured for presentation on the client devices .

In some implementations the functionality of the build server may exist across one or more devices. For example a first build server may provide the user interface module while a second build server provides the source code control module a third server provides the build module and so forth.

The memory may also include a datastore to store information for operations of the build server . The datastore may comprise a database array structured list tree or other data structure. In some implementations the datastore may store the test package before transmission to the test server the test results received from the test server and so forth.

The test package may include information including build information executable files custom tests or other data P such as testing configuration data. The build information may provide information indicative of libraries used host devices supported build version number information and so forth for a particular application build. For example the build information may indicate that the test package includes build 5.13.1030.1 which is configured for execution on a particular computing device model from manufacturer A . The executable files may include executable binaries markup language applications and so forth which are configured for execution on the host devices . The custom tests comprise information indicative of tests test scripts designation portions of the application to test and so forth. For example the user may generate a custom test to exercise particular functionality of the application . These custom tests may comprise unit tests configured for use on the host devices in the host device farm . For example the custom tests may include those developed in the OCUnit testing framework promulgated by sente.ch from Sen te of Switzerland Calabash as promulgated by lesspainful.com of Denmark Frank as promulgated by testingwithfrank.com as associated with ThoughtWorks Inc. of Chicago Ill. The test package may include other data P such as user identification account information and so forth.

Other data may also be stored such as the API URL associated with the test server historical test results version information code check in check out information build status and so forth.

The test server may include one or more I O interface s to allow the test server to communicate with other devices. For example the I O interface s may be configured to provide a universal serial bus USB connection to couple to the host device . The I O interfaces may also be known as communication interfaces. 

The I O interface s may couple to one or more I O devices such as described above. In some embodiments the I O device s may be physically incorporated with the test server or be externally placed.

The test server may also include one or more network interfaces to enable communications between the test server and other networked devices such as those depicted in . Such network interface s may include one or more NICs or other types of transceiver devices configured to send and receive communications over the network s . For example the network interface s may be configured to provide a Wi Fi connection compliant with one or more IEEE 802.11 standards such as 802.11g or 802.11n. The test server may also include one or more busses or other internal communications hardware or software that allow for the transfer of data between the various modules and components of the test server .

The test server includes one or more memories . The memory comprises one or more CRSM as described above. The memory provides storage of computer readable instructions data structures program modules and other data for the operation of the test server .

The memory may include at least one OS module . The OS module is configured to manage hardware resources such as the I O interface s and network interface s and to provide various services to applications or modules executing on the processor s .

The memory may store one or more of the test server API module the unpack module the host device remote control module the traffic modification module the application validation module the audit module the test result module and so forth.

The test server API module is configured to accept and respond to the test package or other information sent by the build server . The test server API module may also be configured to send the test results or other information to the build server . Use of the test server API module allows the build server to integrate the testing functionality of the test server into the automated or semi automated testing processes associated with the application build.

The unpack module may be configured to unpack the test package . The unpacking may include one or more of separating out the application build tests configuration data build information and so forth. The unpack module may also be configured to verify account information associated with the build server and so forth.

As described above the host device remote control module is configured to allow the test server to send instructions and data to the host devices receive information from the host devices and so forth. As also described above the traffic modification module is configured to modify communications between the host devices and one or more external devices . The modification may be used to introduce into the testing environment of the application conditions associated with different network conditions such as a particular carrier network low signal strength and so forth.

The memory may also include the application validation module configured to validate the object level hierarchy of the application and so forth as described above. The audit module may be configured to analyze object data resulting from assembly code generated during execution of the application on the host device . The analysis may identify objects in the application which communicate with the external devices or services while executing on the host device . The markup language hybrid testing module is configured to provide testing functionality associated with markup language applications or hybrid applications.

The test result module is configured to generate test results based at least in part on information provided by one or more of the host device remote control module the traffic modification module the application validation module the audit module and so forth.

Other modules may also be stored in the memory . These may include an account billing module configured to bill for testing services host device management module for administering the host device farm benchmarking module service level agreement SLA management module and so forth.

The benchmarking module may be configured to gather performance benchmarks associated with the application . These performance benchmarks may include but are not limited to load time responsiveness to inputs and so forth. The performance benchmarks may be measured across different devices device configurations or both which are available in the host device farm .

In one implementation the benchmarking module may be configured to calculate load time metrics for applications web sites or both. The host devices may be configured with different Internet browsers layout rendering engines JavaScript engines and so forth. The benchmarking module may be configured to measure load time on the host device of pages associated with a particular web site. For example the load time of a root page of a web site designed for mobile users may be tested. The load time may also be recursively measured for child pages of the web site. Rendering time on the different host devices or on different applications such as Internet browsers on the host devices may also be measured. For example load times and rendering times for a particular application and web site may be tested across several different Internet browsers for the same host device . As with the other modules the functions of the benchmarking module may be automated accessed using the test server API module or both.

The SLA management module may be configured to provide a particular level of service as defined by one or more metrics. These metrics may include response times diversity in host devices used and so forth. The SLA management module may coordinate and monitor operation of the test server such that test results are provided within a predetermined time. For example a SLA may specify the test results are to be returned within one hour. The SLA management module may prioritize processing of test packages based on the SLA associated with the test package . For example test packages which have a SLA specifying a one hour response may be prioritized for testing over those test packages with SLAs for eight hour response time.

The memory may also include a datastore to store information for operations of the test server . The datastore may comprise a database array structured list tree or other data structure. The datastore may store machine generated test sequences manually generated test sequences or both. The machine generated test sequences may be generated at least in part by automated processes which execute on the build server . For example the test server may automatically generate the machine generated test sequences to navigate through all user selectable options in the application . In comparison the manually generated test sequences may be created by the user or another party. The test sequences are configured to exercise particular functionality portions of the code user interface functionality and so forth. The test sequences may comprise scripts code markup language and so forth.

The datastore may also include the test package as received from the build server using the test server API module . Host device output may also be stored. The host device output comprises information received from the host devices in the host device farm . The host device output is discussed in more detail below with regard to .

The test results may also be stored in the datastore along with other data . The other data may include account information billing preferences test configurations and so forth.

Similar to the devices described above the host device may include one or more I O interface s to allow the host device to communicate with other devices. The I O interface may be configured to provide a USB connection.

The I O interface may couple to one or more I O devices . The I O devices may include user input devices such as one or more of a keyboard a mouse a pen a game controller a voice input device a touch input device gestural input device and so forth. The I O devices may include output devices such as one or more of a display a printer audio speakers haptic output device and so forth. In some embodiments the I O devices may be physically incorporated with the host device or be externally placed.

The host device may also include one or more network interfaces configured to send and receive communications over the one or more networks . The host device may also include one or more busses or other internal communications hardware or software that allow for the transfer of data between the various modules and components of the host device .

The host device may include a hardware based video encoder decoder . While a hardware based video encoder decoder is described in some implementations a hardware based video encoder may be used. The video encoder decoder may be incorporated into a common die with the one or more processors or may be on a separate die. The video encoder decoder may be configured to enable the capture of screenshot data in the H.264 or MPEG 4 Part compliant format.

The host device includes one or more memories . The memory comprises one or more CRSM as described above. The memory may include at least one operating system OS module . The OS module is configured to manage hardware resources such as the I O interfaces and provide various services to applications or modules executing on the one or more processors . The OS module may comprise mobile operating systems configured for execution on mobile computing devices. The operating systems module may implement one or more of iOS from Apple Corp. of Cupertino Calif. Windows Mobile from Microsoft Corp. of Redmond Wash. Android from Google Corp. of Mountain View Calif. and its derivatives from various sources Palm OS from Palm Computing Inc. of Sunnyvale Calif. and its derivatives from various sources BlackBerry OS from Research In Motion Ltd. of Waterloo Ontario Canada or other operating systems such as VxWorks from Wind River Systems of Alameda Calif.

The memory may also include one or more of the application an input virtualization module a display capture module a performance debug data capture module an environment adjustment module an assembly code generation module or other modules .

The application is configured to execute on the host device . For example this may be the application in the test package received from the build server .

The input virtualization module is configured to virtually execute input events. These input events may be received as instructions from the host device remote control module .

The display capture module is configured to capture screenshots of the host device display and generate screenshot data . The screenshot data may be generated using the hardware based video encoder decoder . Use of the hardware based video encoder decoder allows for the high fidelity capture and presentation of images presented on the display of the host device . This high fidelity is based on the ability to capture the screenshots at the full resolution and at the full frame rate or redraw rate of the display.

The performance debug data capture module is configured to capture one or more of performance data about the host device code level debug data for apps or other processes running on the host device and so forth. The information may be provided to the build server the user or both.

The environment adjustment module is configured to adjust the host device environment based on input from the test server . The environment includes OS OS version firmware firmware version language in use date time location position orientation and so forth.

The environment adjustment module may modify the location of the host device such that processes running on the host device behave as though the host device were located in a location other than its actual physical location. For example the host device may be located in a test facility in San Francisco Calif. but the OS module of the host device or other applications may report a location of London England.

The environment adjustment module may also generate loads on the one or more processors memory I O devices or a combination thereof. For example the environment adjustment module may be configured to execute an application which consumes 50 of the processor resources and uses enough memory to result in a low memory state in the OS module . The application may then be executed and tested under these loaded conditions. In some implementations the user may use a user interface on the client device to remotely control the host device in real time to check for responsiveness behavior and so forth.

The assembly code generation module is configured to generate assembly code for the application during execution. In some implementations the assembly code generation module may comprise a debugger.

The other modules may also be included in the host device . These other modules may include but are not limited to other application modules not under test.

The memory also includes a datastore to store information for operations of host device . The datastore may comprise a database array structured list tree or other data structure. The datastore may store the host device output which may comprise the screenshot data generated by the display capture module . The screenshot data may be stored until such data is retrieved from the host device by the test server or overwritten by the display capture module . The host device output may also include device performance and or debug data gathered by performance debug data capture module . As above the data may be stored until retrieved by the test server . Other host device output H may also be stored. Other data may also be stored in the datastore .

The client device sends changes to the application build to the build server . For example the user may have changed some of the source code in the application during development and checked in those changes into the source code control module . After sending the changes the client device may continue on with other activities . For example the user may check email continue development on the application and so forth.

The build server receives the changes from the client device . At the build server generates an application build which may include the changes as checked in. The application build is configured for execution on one or more of the host devices . For example the application may be configured to execute on a tablet computer from Manufacturer A . The application build may be for the complete application or for particular modules or portions of the application which are to be tested.

At the build server generates the test package . As described above the test package may comprise the build information one or more executable files custom tests testing configuration data and so forth. At the test package is sent to the test server . The sending may be facilitated using the test server API module . For example the build server may access the API URL which is unique to the entity operating the build server . The build server may send using HTTPS the test package to the test server using the URL associated with the entity.

At the test server unpacks the test package . For example the test server may extract and separate the build information the executable files and so forth for processing. At the test server distributes the application and associated tests to the host devices in the host device farm . In some implementations the unpacking may be based at least in part on the URL which was used to transfer the test package . For example a particular URL may be associated with tests configured for a particular entity or group within the entity. As described above the test server may use the I O interface such as the USB interface to exchange information with the host device .

At the host device executes the application and associated tests. The execution may include processing instructions from the host device remote control module with the input virtualization module to simulate user input on the host device . The execution may also include use the assembly code generation module to produce assembly code associated with the executing application . In some embodiments the assembly code generation module may be a debugger such as the GNU debugger gdb or may include at least a portion of the functionality of a debugger. However embodiments are not so limited and any type of the assembly code generation module may be employed to generate the assembly code data for an application.

At the host device output is sent from the host device to the test server . The test server receives the host device output and generates the test results based at least in part on the host device output . As described above the test results may comprise information expressed as XML JSON or both.

At the build server receives and stores the test results . The build server may then provide the test results or information based at least in part thereon to the client device for presentation to the user as shown at . For example the client device may use a web browser application to present at least a portion of the test results to the user .

The interface may include a summary section describing characteristics of the application build. For example as shown here it may indicate the name of the application ExampleApp and the current build number 5.13.1030.1 .

A deploy to test control may be presented. The control is configured to on activation generate and send the test package to the test server for testing without further intervention by the user . In some implementations the generation and sending of the test package may be initiated automatically such as at a pre determined time upon check in of all portions of the application upon completion of a process and so forth.

A current test parameter section provides information about the current configuration of the tests to be completed. For example the test parameters may specify particular date and time geographic location CPU loading and memory usage to be used during testing and so forth. Information about the network profile parameters to be used by the traffic modification module may also be specified. For example as shown here the wireless wide area network is set to provide an environment representative of service from ABCCell Corp. with a signal level as received at the host device of 35 .

The current test parameter section may also provide information such as what tests are to be run time frame to provide results how to apply those tests and so forth. For example as shown here the testing level is set to aggressive in which all available tests will be scheduled to run against the application . The user may specify a time requested to deliver such as as soon as possible reduced cost and so forth. For example the as soon as possible may prioritize and conduct tests for the application ahead of other applications which have selected the reduced cost option. The reduced cost option may thus be offered at a lower cost relative to the as soon as possible option given the potential delay in providing the test results . Host device variety may also be specified enabling the application to be tested against all available devices compatible with the application against a certain model and so forth. This allows for testing to be conducted easily and quickly with several models of the host device . For example the host device farm may include legacy host devices which are no longer available for purchase or pre release models of a next generation host device to allow for advance testing.

A configure testing control may be presented. The configure testing control is configured to on activation provide for modification of one or more of the test parameters. In one implementation activation of the configure testing control may present a user interface allowing the user to change the test parameters. For example the user may select options to enable debug options which provide details on UIView.

A test results section provides information based at least in part on the test results as received from the test server . The information may include screenshot data device performance debut data and so forth. For example the user may watch a stream of video taken during a portion of the testing of the application on the one or more host devices to observe behavior during testing. Other information such as UIView details a portion of a UI layout hierarchy dump application load times web site load times and so forth may also be presented.

The output of the test results may be configurable to meet the specific requirements of particular users . For example one user may request reports to be provided as XML data while another user may request reports to be delivered as JSON data.

Block receives one or more changes to an application . For example the user may check in a portion of code for the application which has been modified or added.

Block presents a control associated with initiation of testing the application . This control may comprise a button or other user interface element presented within a graphical user interface a particular spoken phrase in an audible user interface and so forth. For example in one implementation the control may comprise the deploy to test control described above in .

Block receives user input associated with activation of the control. For example the user input may comprise a mouse click to select the deploy to test control or utterance of the particular spoken phrase.

In some implementations based at least in part on the activation of the control block generates a build of the application . In other implementations the built application may be available before the activation of the control. As described above the application may comprise executable code configured for execution on the one or more host devices .

Based at least in part on the activation of the control block generates a test package . As described above the test package may comprise at least a portion of the application . In some implementations the test package may include source code of the application while in other implementations the test package may omit source code.

Block sends the test package to the test server . As described above the test server is configured to perform one or more tests on one or more host devices . These tests may be performed for at least a portion of the application . For example the testing may be for a particular part of the user interface in the application or may be for all user interfaces and functions in the application . In one implementation the sending may occur as a transaction implementing a representational state transfer REST using HTTP with the test server API module .

As described above the one or more tests may be executed contemporaneously across a plurality of the one or more host devices . For example one hundred different tests may be executed simultaneously on one hundred different host devices . In one implementation at least a portion of the one or more host devices configured to test the application may differ from one another by one or more of make model form factor input devices or output devices. In another implementation at least a portion of the one or more host devices configured to test the application may differ from one another by one or more of operating system version installed applications reported geographic location apparent network connectivity or memory usage. For example the host devices may be configured to report during testing a geographic location which differs from their actual location in a facility housing the host device farm . In another example the traffic modification module may modify traffic such that the host device appears to be connected to a particular network service provider with a particular signal strength and data loss.

Block receives test results from the test server . As described above the test results may be expressed as XML JSON or a combination thereof.

Block receives a test package . As described above the test package may comprise a build of the application . The build may include build info one or more executable files custom tests and so forth. The test package is received with the network interface using the test server API module .

Block unpacks the application from the test package . This unpacking may include decompression separating out the executables tests and so forth.

Block determines a testing account associated with the test package . In one implementation the test package may include an account identification number account credentials and so forth. The testing account may be used to select particular test configuration parameters bill for testing services and so forth.

Block configures one or more host devices to test the application . As described above this configuration may use one of the I O interfaces such as the USB I O interface coupled to the host devices .

Block sends at least a portion of the application to one or more of the host devices . As described above the sending may use the I O interface .

Block initiates testing and execution of the application on the one or more host devices . For example instructions may be sent to execute the device provide for simulated user input and so forth. The testing may involve the use of a portion of the host devices available in the host device farm . For example application may be tested on host devices while application is tested on host devices .

Block may provide testing using the input virtualization module . As described above the host device remote control module may send using the I O interface one or more instructions to the input virtualization module which is executing on the one or more host devices . The one or more instructions are configured to perform at least one input event on the one or more host devices during the execution of the application .

Block may provide testing functionality of retrieving screenshot data associated with the execution of the application from at least a portion of the one or more host devices used during testing. A plurality of screenshot data of a display of the one or more host devices generated by the display capture module as the one or more host devices execute the application are retrieved using the I O interface . This screenshot data may be provided as still images or as a stream of video. As described above the screenshot data may be processed at least partly by the hardware based video encoders of the one or more host devices .

Block provides testing functionality of modifying traffic to or from the one or more host devices and the external devices . The traffic may comprise packets of data. This functionality may be provided by the traffic modification module as described above.

In one implementation the testing may include receiving an indication of a first network profile to be applied to network traffic between at least a portion of the one or more host devices and the external device such as a server device. The first network profile may include a first set of network profile parameters which specify how the traffic is to be modified. The traffic modification module receives a plurality of packets included in the network traffic sent from the one or more host devices and addressed to the external device . The traffic modification module may then modify at least one of the plurality of packets based at least in part on the first set of network profile parameters. The modified plurality of packets is then sent to the external device .

In another implementation the testing may include receiving an indication of a second network profile to be applied to the network traffic. The second network profile includes a second set of network profile parameters that at least partly differ from the first set of network profile parameters. The second network profile may be used to modify at least another one of the plurality of packets based at least partly on the second set of network profile parameters. This modification may be to packets sent from the external device to the host device . The modification of the at least another one of the plurality of packets may be performed after the modification of the at least one of the plurality of packets.

Block may provide testing to validate the object level hierarchy of the application . This block may be configured to receive assembly code generated from execution of an application on the host device . The assembly code is analyzed to identify a plurality of objects associated with the application and to determine at least one relationship between the plurality of objects. Based on the plurality of objects and the at least one relationship an object level hierarchy for the application is generated. The application may then be validated based at least in part on the object level hierarchy.

Block provides testing by analyzing assembly code data generated during execution of the application to identify at least one communication between the application and the external device . An assembly code generation module may be executed on at least a portion of the one or more host devices to generate the assembly code data associated with the executing application .

The testing of may use the techniques and functions available from the markup language hybrid testing module as described above. For example where the application comprises a hybrid application portions may be tested using embedded test tools in a layout engine module executing on the host devices .

Block receives using the I O interface information associated with the execution. This information may comprise host device output such as screenshot data device performance debug data and so forth.

Block generates one or more test results based at least in part on the information associated with the execution. For example the test results may use the device performance debug data to determine a number of frames per second FPS at which the display was updated during execution of the application .

Block distributes the one or more test results to another device such as the build server . This distribution may include sending the test results using the test server API module and the network interface . In one implementation the test results may comprise information expressed as XML JSON or both.

Block generates billing information associated with the testing account. The billing information may be based on resources used by the test server during testing flat fee tiered pricing and so forth.

Those having ordinary skill in the art will readily recognize that certain steps or operations illustrated in the figures above can be eliminated combined subdivided executed in parallel or taken in an alternate order. Moreover the methods described above may be implemented as one or more software programs for a computer system and are encoded in a computer readable storage medium as instructions executable on one or more processors.

Separate instances of these programs can be executed on or distributed across separate computer systems. Thus although certain steps have been described as being performed by certain devices software programs processes or entities this need not be the case and a variety of alternative implementations will be understood by those having ordinary skill in the art.

Additionally those having ordinary skill in the art readily recognize that the techniques described above can be utilized in a variety of devices environments and situations. Although the present disclosure is written with respect to specific embodiments and implementations various changes and modifications may be suggested to one skilled in the art and it is intended that the present disclosure encompass such changes and modifications that fall within the scope of the appended claims.

