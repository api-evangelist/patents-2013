---

title: System, method, and computer program product for implementing anti-aliasing operations using a programmable sample pattern table
abstract: A system, method, and computer program product are provided for implementing anti-aliasing operations using a programmable sample pattern table. The method includes the steps of receiving an instruction that causes one or more values to be stored in one or more corresponding entries of the programmable sample pattern table and performing an anti-aliasing operation based on at least one value stored in the programmable sample pattern table. At least one value is selected from the programmable sample pattern table based on, at least in part, a location of one or more corresponding pixels.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09437040&OS=09437040&RS=09437040
owner: NVIDIA Corporation
number: 09437040
owner_city: Santa Clara
owner_country: US
publication_date: 20131115
---
The present invention relates to graphics processing and more particularly to anti aliasing techniques.

Anti aliasing techniques are well known in the art of computer generated graphics. Aliasing refers to image artifacts caused by a limited sampling resolution of smooth curves. One common artifact produced as a result of aliasing is a Moire pattern which is a type of spatial aliasing that causes alternating bands of light and dark colors to appear when e.g. two grids are overlaid at an angle.

There are many common techniques to reduce the artifacts caused by aliasing. For example supersample anti aliasing SSAA is a technique that selects multiple points within each pixel not just the pixel center shades each of the multiple points to generate multiple color values for the pixel and then blends the multiple color values to generate a filtered color value for the pixel. It will be appreciated that SSAA increases the resolution of the generated digital image and then down samples the digital image i.e. filters to get a digital image at the desired resolution. The artifacts due to aliasing in the down sampled digital image are reduced when compared to an image generated at the final resolution. However SSAA has drawbacks in that each point sampled within a pixel increases the computation required to generate the digital image e.g. 4 SSAA requires approximately 4 times the number of texture operations compared to techniques which compute a single color for the pixel at the center of the pixel .

Another anti aliasing technique is multi sample anti aliasing MSAA which is a special case of SSAA. In MSAA the graphics processing pipeline implements certain operations using multiple sample points within each pixel however the fragment shading program is only computed once per pixel and is typically evaluated based on a sample location at the center of the pixel. MSAA typically involves a smaller number of computations when compared to SSAA because e.g. texture reads are only performed for a single point for each pixel.

Modern graphics processors typically implement at least one technique to reduce aliasing artifacts. However implementation of anti aliasing techniques may reduce the processing efficiency of the graphics processing pipeline. Furthermore many implementations of SSAA or MSAA in graphics processors utilize a fixed set of sample positions stored in static random access memory SRAM which limits the different anti aliasing algorithms that can be implemented by software. Some algorithms for implementing anti aliasing may benefit from varying sample patterns across the pixels of a digital image which is not possible with fixed sample positions specified by the hardware architecture. Thus there is a need for addressing this issue and or other issues associated with the prior art.

A system method and computer program product are provided for implementing anti aliasing operations using a programmable sample pattern table. The method includes the steps of receiving an instruction that causes one or more values to be stored in one or more corresponding entries of the programmable sample pattern table and performing an anti aliasing operation based on at least one value stored in the programmable sample pattern table. At least one value is selected from the programmable sample pattern table based on at least in part a location of one or more corresponding pixels.

Existing graphics hardware typically implements fixed sample patterns stored in SRAM that are utilized by various anti aliasing algorithms implemented on the graphics hardware. However for some classes of anti aliasing algorithms varying the sample pattern across pixels may be desired to produce better results. For example support for jittered sample patterns may produce less regular roping aliasing artifacts littering generates a more random noise within the digital image that is less disturbing to a viewer. Consequently graphics hardware could benefit from allowing a programmer to specify the sample patterns for the different pixels in a digital image using various commands implemented by an Application Programming Interface API .

In one embodiment a processor implements one or more programmable sample pattern tables that specify relative sample locations within pixels for implementing anti aliasing techniques. Multiple sub units within the processor may include a separate and distinct programmable sample pattern table. The programmable sample pattern table may be configured via an instruction that is executed prior to processing one or more pixels by the sub unit. Examples of various sub units of the processor that may include a programmable sample pattern table are described in more detail below.

At step an anti aliasing operation is performed. The anti aliasing operation is based on at least one value stored in the programmable sample pattern table. In the context of the present description an anti aliasing operation comprises any type of operation corresponding to a sample location for a pixel that includes two or more sample locations. In other words an anti aliasing operation is any operation that depends on the location of the sample in the pixel. Examples of typical anti aliasing operations include but are not limited to computing a z value for a geometric primitive at a corresponding sample location or generating a color value by sampling a texture map based on at least one texture coordinate interpolated at a corresponding sample location.

More illustrative information will now be set forth regarding various optional architectures and features with which the foregoing framework may or may not be implemented per the desires of the user. It should be strongly noted that the following information is set forth for illustrative purposes and should not be construed as limiting in any manner. Any of the following features may be optionally incorporated with or without the exclusion of other features described.

In one embodiment the PPU includes an input output unit configured to transmit and receive communications i.e. commands data etc. from a central processing unit CPU not shown over the system bus . The unit may implement a Peripheral Component Interconnect Express PCIe interface for communications over a PCIe bus. In alternative embodiments the unit may implement other types of well known bus interfaces.

The PPU also includes a host interface unit that decodes the commands and transmits the commands to the task management unit or other units of the PPU e.g. memory interface as the commands may specify. The host interface unit is configured to route communications between and among the various logical units of the PPU .

In one embodiment a program encoded as a command stream is written to a buffer by the CPU. The buffer is a region in memory e.g. memory or system memory that is accessible i.e. read write by both the CPU and the PPU . The CPU writes the command stream to the buffer and then transmits a pointer to the start of the command stream to the PPU . The host interface unit provides the task management unit TMU with pointers to one or more streams. The TMU selects one or more streams and is configured to organize the selected streams as a pool of pending grids. The pool of pending grids may include new grids that have not yet been selected for execution and grids that have been partially executed and have been suspended.

A work distribution unit that is coupled between the TMU and the SMs manages a pool of active grids selecting and dispatching active grids for execution by the SMs . Pending grids are transferred to the active grid pool by the TMU when a pending grid is eligible to execute i.e. has no unresolved data dependencies. An active grid is transferred to the pending pool when execution of the active grid is blocked by a dependency. When execution of a grid is completed the grid is removed from the active grid pool by the work distribution unit . In addition to receiving grids from the host interface unit and the work distribution unit the TMU also receives grids that are dynamically generated by the SMs during execution of a grid. These dynamically generated grids join the other pending grids in the pending grid pool.

In one embodiment the CPU executes a driver kernel that implements an application programming interface API that enables one or more applications executing on the CPU to schedule operations for execution on the PPU . An application may include instructions i.e. API calls that cause the driver kernel to generate one or more grids for execution. In one embodiment the PPU implements a SIMD Single Instruction Multiple Data architecture where each thread block i.e. warp in a grid is concurrently executed on a different data net by different threads in the thread block. The driver kernel defines thread blocks that are comprised of k related threads such that threads in the same thread block may exchange data through shared memory. In one embodiment a thread block comprises related threads and a grid is an array of one or more thread blocks that execute the same stream and the different thread blocks may exchange data through global memory.

In one embodiment the PPU comprises X SMs X . For example the PPU may include 15 distinct SMs . Each SM is multi threaded and configured to execute a plurality of threads e.g. 32 threads from a particular thread block concurrently. Each of the SMs is connected to a level two L2 cache via a crossbar or other type of interconnect network . The L2 cache is connected to one or more memory interfaces . Memory interfaces implement 16 32 64 128 bit data buses or the like for high speed data transfer. In one embodiment the PPU comprises U memory interfaces U where each memory interface U is connected to a corresponding memory device U . For example PPU may be connected to up to 6 memory devices such as graphics double data rate version 5 synchronous dynamic random access memory GDDR5 SDRAM .

In one embodiment the PPU implements a multi level memory hierarchy. The memory is located off chip in SDRAM coupled to the PPU . Data from the memory may be fetched and stored in the L2 cache which is located on chip and is shared between the various SMs . In one embodiment each of the SMs also implements an L1 cache. The L1 cache is private memory that is dedicated to a particular SM . Each of the L1 caches is coupled to the shared L2 cache . Data from the L2 cache may be fetched and stored in each of the L1 caches for processing in the functional units of the SMs .

In one embodiment the PPU comprises a graphics processing unit GPU . The PPU is configured to receive commands that specify shader programs for processing graphics data. Graphics data may be defined as a set of primitives such as points lines triangles quads triangle strips and the like. Typically a primitive includes data that specifies a number of vertices for the primitive e.g. in a model space coordinate system as well as attributes associated with each vertex of the primitive. The PPU can be configured to process the graphics primitives to generate a frame buffer i.e. pixel data for each of the pixels of the display . The driver kernel implements a graphics processing pipeline such as the graphics processing pipeline defined by the OpenGL API.

An application writes model data for a scene i.e. a collection of vertices and attributes to memory. The model data defines each of the objects that may be visible on a display. The application then makes an API call to the driver kernel that requests the model data to be rendered and displayed. The driver kernel reads the model data and writes commands to the buffer to perform one or more operations to process the model data. The commands may encode different shader programs including one or more of a vertex shader hull shader geometry shader pixel shader etc. For example the TMU may configure one or more SMs to execute a vertex shader program that processes a number of vertices defined by the model data. In one embodiment the TMU may configure different SMs to execute different shader programs concurrently. For example a first subset of SMs may be configured to execute a vertex shader program while a second subset of SMs may be configured to execute a pixel shader program. The first subset of SMs processes vertex data to produce processed vertex data and writes the processed vertex data to the L2 cache and or the memory . After the processed vertex data is rasterized i.e. transformed from three dimensional data into two dimensional data in screen space to produce fragment data the second subset of SMs executes a pixel shader to produce processed fragment data which is then blended with other processed fragment data and written to the frame buffer in memory . The vertex shader program and pixel shader program may execute concurrently processing different data from the same scene in a pipelined fashion until all of the model data for the scene has been rendered to the frame buffer. Then the contents of the frame buffer are transmitted to a display controller for display on a display device.

The PPU may be included in a desktop computer a laptop computer a tablet computer a smart phone e.g. a wireless hand held device personal digital assistant PDA a digital camera a hand held electronic device and the like. In one embodiment the PPU is embodied on a simple semiconductor substrate. In another embodiment the PPU is included in a system on a chip SVC along with one or more other logic units such as a reduced instruction set computer RISC CPU a memory management unit MMU a digital to analog converter DAC and the like.

In one embodiment the may be included on a graphics card that includes one or more memory devices such as GDDR5 SDRAM. The graphics card may be configured to interface with a Pete slot on a motherboard of a desktop computer that includes e.g. a northbridge chipset and a southbridge chipset. In yet another embodiment the PPD may be an integrated graphics processing unit iGPU included in the chipset i.e. Northbridge of the motherboard.

As described above the work distribution unit dispatches active grids for execution on one or more SMs of the PPU . The scheduler unit receives the grids from the work distribution unit and manages instruction scheduling for one or more thread blocks of each active grid. The scheduler unit schedules threads for execution in groups of parallel threads where each group is called a warp. In one embodiment each warp includes 32 threads. The scheduler unit may manage a plurality of different thread blocks allocating the thread blocks to warps for execution and then scheduling instructions from the plurality of different warps on the various functional units i.e. cores DPUs SFUs and LSUs during each clock cycle.

In one embodiment each scheduler unit includes one or more instruction dispatch units . Each dispatch unit is configured to transmit instructions to one or more of the functional units. In the embodiment shown in the scheduler unit includes two dispatch units that enable two different instructions from the same warp to be dispatched during each clock cycle. In alternative embodiments each scheduler unit may include a single dispatch unit or additional dispatch units .

Each SM includes a register file that provides a set of registers for the functional units of the SM . In one embodiment the register file is divided between each of the functional units such that each functional unit is allocated a dedicated portion of the register file . In another embodiment the register file is divided between the different warps being executed by the SM . The register file provides temporary storage for operands connected to the data paths of the functional units.

Each SM comprises L processing cores . In one embodiment the SM includes a large number e.g. 192 etc. of distinct processing cores . Each core is a fully pipelined single precision processing unit that includes a floating point arithmetic logic unit and an integer arithmetic logic unit. In one embodiment the floating point arithmetic logic units implement the IEEE 754 2008 standard for floating point arithmetic. Each SM also comprises M DPUs that implement double precision floating point arithmetic N SFUs that perform special functions e.g. copy rectangle pixel blending operations and the like and P LSUs that implement load and store operations between the shared memory L1 cache and the register file . In one embodiment the SM includes 64 DPUs 32 SFUs and 32 LSUs .

Each SM includes an interconnect network that connects each of the functional units to the register file and the shared memory L1 cache . In one embodiment the interconnect network is a crossbar that can be configured to connect any of the functional units to any of the registers in the register file or the memory locations in shared memory L1 cache .

In one embodiment the SM is implemented within a GPU. In such an embodiment the SM comprises J texture units . The texture units are configured to load texture maps i.e. a 2D array of texels from the memory and sample the texture maps to produce sampled texture values for use in shader programs. The texture units implement texture operations such as anti aliasing operations using mip maps i.e. texture maps of varying levels of detail . In one embodiment the SM includes 16 texture units .

The PPU described above may be configured to perform highly parallel computations much faster than conventional CPUs. Parallel computing has advantages in graphics processing data compression biometrics stream processing algorithms and the like.

As shown in the graphics processing pipeline comprises a pipeline architecture that includes a number of stages. The stages include but are not limited to a data assembly stage a vertex shading stage a primitive assembly stage a geometry shading stage a viewport scale cull and clip VSCC stage a rasterization stage a fragment shading stage and a raster operations stage . In one embodiment the input data comprises commands that configure the processing units to implement the stages of the graphics processing pipeline and geometric primitives e.g. points lines triangles quads triangle strips or fans etc. to be processed by the stages. The output data may comprise pixel data i.e. color data that is copied into a frame buffer or other type of surface data structure in a memory.

The data assembly stage receives the input data that specifies vertex data for high order surfaces primitives or the like. The data assembly stage collects the vertex data in a temporary storage or queue such as by receiving a command from the host processor that includes a pointer to a buffer in memory and reading the vertex data from the buffer. The vertex data is then transmitted to the vertex shading stage for processing.

The vertex shading stage processes vertex data by performing a set of operations i.e. a vertex shader or a program once for each of the vertices. Vertices may be e.g. specified as a 4 coordinate vector associated with one or more vertex attributes. The vertex shading stage may manipulate properties such as position color texture coordinates and the like. In other words the vertex shading stage performs operations on the vertex coordinates or other vertex attributes associated with a vertex. Such operations commonly including lighting operations i.e. modifying color attributes for a vertex and transformation operations i.e. modifying the coordinate space for a vertex . For example vertices may be specified using coordinates in an object coordinate space which are transformed by multiplying the coordinates by a matrix that translates the coordinates from the object coordinate space into a world space or a normalized device coordinate NCD space. The vertex shading stage generates transformed vertex data that is transmitted to the primitive assembly stage .

The primitive assembly stage collects vertices output by the vertex shading stage and groups the vertices into geometric primitives for processing by the geometry shading stage . For example the primitive assembly stage may be configured to group every three consecutive vertices as a geometric primitive i.e. a triangle for transmission to the geometry shading stage . In some embodiments specific vertices may be reused for consecutive geometric primitives e.g. two consecutive triangles in a triangle strip may share two vertices . The primitive assembly stage transmits geometric primitives i.e. a collection of associated vertices to the geometry shading stage .

The geometry shading stage processes geometric primitives by performing a set of operations i.e. a geometry shader or program on the geometric primitives. Tessellation operations may generate one or more geometric primitives from each geometric primitive. In other words the geometry shading stage may subdivide each geometric primitive into a finer mesh of two or more geometric primitives for processing by the rest of the graphics processing pipeline . The geometry shading stage transmits geometric primitives to the viewport SCC stage .

The viewport SCC stage performs viewport scaling culling and clipping of the geometric primitives. Each surface being rendered to is associated with an abstract camera position. The camera position represents a location of a viewer looking at the scene and defines a viewing frustum that encloses the objects of the scene. The viewing frustum may include a viewing plane a rear plan and four clipping planes. Any geometric primitive entirely outside of the viewing frustum may be culled i.e. discarded because the geometric primitive will not contribute to the final rendered scene. Any geometric primitive that is partially inside the viewing frustum and partially outside the viewing frustum may be clipped i.e. transformed into a new geometric primitive that is enclosed within the viewing frustum. Furthermore geometric primitives may each be scaled based on depth of the viewing frustum. All potentially visible geometric primitives are then transmitted to the rasterization stage .

The rasterization stage converts the 3D geometric primitives into 2D fragments The rasterization stage may be configured to utilize the vertices of the geometric primitives to setup a set of plane equations from which various attributes can be interpolated. The rasterization stage may also compute a coverage mask for a plurality of pixels that indicates whether one or more sample location for the pixel intercept the geometric primitive. In one embodiment z testing may also be performed to determine if the geometric primitive is occluded by other geometric primitives that have already been rasterized. The rasterization stage generates fragment data i.e. interpolated vertex attributes associated with a particular sample location for each covered pixel that are transmitted to the fragment shading stage .

The fragment shading stage processes fragment data by performing a set of operations i.e. a fragment shader or a program on each of the fragments. The fragment shading stage may generate pixel data i.e. color values for the fragment such as by performing lighting operations or sampling texture maps using interpolated texture coordinates for the fragment. The fragment shading stage generates pixel data that is transmitted to the raster operations stage .

The raster operations stage may perform various operations on the pixel data such as performing alpha tests stencil tests and blending the pixel data with other pixel data corresponding to other fragments associated with the pixel. When the raster operations stage has finished processing the pixel data i.e. the output data the pixel data may be written to a render target such as a frame buffer a color buffer or the like.

It will be appreciated that one or more additional stages may be included in the graphics processing pipeline in addition to or in lieu of one or more of the stages described above. Various implementations of the abstract graphics processing pipeline may implement different stages. Furthermore one or more of the stages described above may be excluded from the graphics processing pipeline in some embodiments such as the geometry shading stage . Other types of graphics processing pipelines are contemplated as being within the scope of the present disclosure. Furthermore any of the stages of the graphics processing pipeline may be implemented by one or more dedicated hardware units within a graphics processor such as PPU . Other stages of the graphics processing pipeline may be implemented by programmable hardware units such as the SM of the PPU .

In one embodiment the raster operations ROP units include a z raster operations ZROP engine and a color raster operations CROP engine . The ZROP engine compares Z values for pixel data to previously stored Z values for the corresponding sample locations. The results from the ZROP engine determine if the various pixel data for a fragment will be kept or discarded. More specifically the ZROP engine compares the Z value of each sample location with the Z value of a corresponding sample location stored in a depth map i.e. Z buffer . This process is known as Z testing. If the current fragment passes Z testing then the ZROP engine optionally writes the Z value for the current fragment to the corresponding sample location in the depth map. If the current fragment does not pass Z testing then the pixel data may be discarded and the Z value for the current fragment is not written to the depth map. The CROP engine writes the color value for the current fragment to the frame buffer if the fragment passes the Z testing.

In one embodiment the number of ROP units may be equal to the number of memory partitions with each ROP unit allocated to a particular memory partition . The ZROP unit or the CROP unit reads or writes values to the L2 cache . Then the L2 cache manages memory fetch requests from the memory or the write back of dirty data from the L2 cache into the memory . Although not explicitly shown the ROP units may be coupled to the L2 Cache as well as the SM and the PROP units via the crossbar .

The PROP units manage the flow of pixel data between the ZROP engine the CROP engine and the SM . In one embodiment the number of PROP units matches the number of SMs with each PROP unit allocated to a particular SM . It will be appreciated that the number of PROP units is not necessarily the same as the number of ROP units . Again although not explicitly shown the PROP units may communicate with the ROP units via the crossbar .

In addition to the ROP units and the PROP units the PPU includes one or more rasterizers coupled to the one or more SMs . In one embodiment the number of rasterizers equals the number of SMs . Each rasterizer is a dedicated hardware unit configured to perform at least a portion of the operations of the rasterization stage of the graphics processing pipeline described above. For example the rasterizer may receive a geometric primitive from the VSCC stage and set up plane equations corresponding to the geometric primitive. Although not explicitly shown the rasterizers may be coupled to the crossbar in order to communicate with other units of the PPU such as the SMs or a hardware unit configured to implement at least a portion of the operations of the VSCC stage of the graphics processing pipeline .

It will be appreciated that the rasterizers implement anti aliasing operations. For example in order to calculate a coverage mask for a tile of pixels the rasterizer performs intersection tests that determine whether rays that intersect each sample location in the tile of pixels intersect a geometric primitive. The intersection tests indicate whether the sample locations associated with the rays are covered by the geometric primitive. The coverage information is passed down the graphics processing pipeline to the fragment shading stage . If anti aliasing techniques are implemented then the intersection tests should be computed for each of the two or more sample locations within a pixel. Therefore the rasterizer includes a programmable sample pattern table for determining a location for each of the sample locations within a particular pixel.

In one embodiment the rasterizers may be configured to cull small triangles. Culling by the VSCC stage may be performed based on the extents of the surface i.e. window . However there may also be some primitives that while included within the extents of the surface do not intersect any of the programmable sample locations within a surface. For example very small or thin triangles might intersect one or more pixels without actually intersecting any of the programmable sample locations within those pixels. In such cases the rasterizers may be configured to cull these primitives based on the locations included in the programmable sample pattern tables. In another embodiment the VSCC stage may be configured to cull such small primitives. Additional units within the PPU may also implement anti aliasing operations including the ZROP engine and any SM configured to execute a fragment shader.

While jittering the sample locations alleviates the aliasing artifacts rendering the image at a higher resolution and then down sampling the high resolution image to generate the resulting image data helps reduce aliasing artifacts even more. As shown in each pixel and in the pixel quad includes two sample locations. Two sample locations per pixel corresponds to 2 anti abasing 2 AA . Again the sample locations in the sample pattern for the pixel quad may be randomly distributed within the pixels. As shown in a pixel quad may include pixels and that include four sample locations corresponding to 4 anti aliasing 4 AA . A sample pattern defining sample locations that are distributed within less than four pixels or more than four pixels is contemplated as being within the scope of the present disclosure.

Some graphics hardware may be limited in the number of fixed sample locations that are stored in hardware units. For example some hardware units may have a limit of 16 sample locations per pixel quad. While this limitation enables 4 AA for a pixel quad 8 anti aliasing 8 AA cannot be performed for a pixel quad because this configuration may require 32 sample locations. In such cases two pixels can be processed substantially simultaneously in either a 1 2 array of pixels or a 2 1 array of pixels . As shown in each pixel and in the pixel pair includes eight sample locations. Similarly as shown in each pixel and in the pixel pair includes eight sample locations. Furthermore with such limitations each pixel will have the same sample locations when implementing 16 AA.

In one embodiment the sample pattern table s store the sample locations for a sample pattern associated with an anti aliasing algorithm. For example a sample pattern table for the 1 AA algorithm shown in may include four entries corresponding to each of the sample locations for the pixel quad . Each entry in the sample pattern table may specify an offset from an origin of a corresponding pixel. For example if the offset is the center of the pixel each entry may include two signed integers that represent a horizontal and a vertical displacement of the sample location from the center of the pixel. In another example if the offset is at a corner of the pixel each entry may include two unsigned integers that represent a horizontal and a vertical displacement of the sample location from the corner of the pixel.

If the graphics processor is configured to use a 2 AA algorithm then the hardware unit may be configured to select a second sample pattern table that includes eight entries which correspond to the eight sample locations for a pixel quad processed using the 2 AA algorithm. A first entry may specify an offset for a first sample location for a first pixel in a pixel quad a second entry may specify an offset for a second sample location for the first pixel in the pixel quad a third entry may specify an offset for a first sample location for a second pixel in the pixel quad a fourth entry may specify an offset for a sample location for the second pixel in the pixel quad and so forth i.e. entries correspond to the first and second sample locations for the third pixel and fourth pixel of the pixel quad respectively .

Similarly if the graphics processor is configured to use a 4 AA algorithm then the hardware unit may be configured to select a third sample pattern table that includes sixteen entries which correspond to the sixteen sample locations for a pixel quad processed using the 4 AA algorithm. The first four entries i.e. entries of the third sample pattern table may specify an offset for four corresponding sample locations for a first pixel in a pixel quad the next four entries i.e. entries of the third sample pattern table may specify an offset for four corresponding sample locations for a second pixel in a pixel quad and so forth.

It will be appreciated that although not explicitly shown multiple tables may be used to specify different sample patterns for the same anti aliasing algorithm. For example where the sample locations of sample pattern table specify the centers of the pixels another four entry sample pattern table may be included in the sample pattern tables that specifies jittered sample locations rather than the pixel centers. Multiple sample pattern tables for the same anti aliasing algorithm e.g. 1 AA enable different configurations to be selected when sampling pixels.

It will be appreciated that a different sample pattern table must be included in each hardware unit within the graphics processor in order to implement each distinct anti aliasing algorithm that is enabled. In the case where the graphics processor includes many different hardware units configured to implement different stages of the graphics processing pipeline many instances of these sample pattern tables will be implemented in the different hardware units. Implementing many instances of many different tables takes up valuable die overhead increasing the size and complexity of the graphics processor integrated circuit.

In one embodiment each slot of the programmable sample pattern table stores an 8 bit value that indicates an offset from the upper left corner of a pixel using two 4 bit values where a first portion i.e. the four most significant bits of the 8 bit value indicates a horizontal offset from the upper left corner of the pixel and a second portion i.e. the four least significant bits of the 8 bit value indicates a vertical offset from the upper left corner of the pixel. In other words each value stored in a slot of the programmable sample pattern tables indicates one of 256 possible sample locations within a pixel relative to the upper left corner of the corresponding pixel. In other embodiments each slot of the programmable sample pattern table may store a number of bits less than or more than 8 bits. For example each slot of the programmable sample pattern table may store 64 bits holding two 32 bit single precision floating point values that range between 0.0 and 1.0 that indicate a relative position within the pixel where the upper left corner of the pixel corresponds to an entry of and the lower right corner of the pixel corresponds to an entry of .

As shown in the programmable sample pattern table includes sixteen entries and . It will be appreciated that sixteen entries is the maximum entries for any of the example anti aliasing algorithms illustrated in . In one embodiment the PPU has an architecture that executes sixteen threads in parallel simultaneously thereby calculating values for each of the samples in a pixel quad or a pixel pair in the case of 8 AA in parallel. Thus a sixteen entry programmable sample pattern table is large enough to handle every sample executed in parallel and can be reprogrammed for subsequent pixel quads if necessary. However there is no inherent reason to limit the number of entries of the programmable sample pattern table to sixteen entries for other architectures and a different number of entries less than or greater than sixteen is contemplated as being within the scope of the present disclosure.

In operation a host processor may generate instructions within a stream of instructions and data to be processed by the PPU that as the instructions are passed down the graphics processing pipeline and received by the various hardware units of the PPU cause new values to be written into the programmable sample pattern table . The instruction may be ordered prior to data to be processed using sample locations that correspond to the new values. For example a first instruction may configure the hardware unit to process a first pixel quad according to a 4 AA algorithm using a first set of sample locations. Once the first pixel quad has been processed and prior to a second pixel quad being processed a second instruction may re configure the hardware unit to process the second pixel quad according to the 4 AA algorithm using a second set of sample locations that is different than the first set of sample locations. Alternately the second instruction could re configure the hardware unit to process the second pixel quad according to a different anti aliasing algorithm entirely such as a 2 AA algorithm.

It will be appreciated that the programmable sample pattern table may include more entries than sample locations that are specified for a particular anti aliasing algorithm. For example a 1 AA algorithm requires only four sample locations per pixel quad. In one embodiment the first four entries i.e. entries may be filled with valid sample location data and the other twelve entries of the programmable sample pattern table may contain invalid data. Similarly for a 2 AA algorithm that requires eight sample locations per pixel quad the first eight entries i.e. entries may be filled with valid sample location data and the other eight entries of the programmable sample pattern table may contain invalid data.

In another embodiment a first instruction may configure the programmable sample pattern table such that each entry of the table contains valid sample location data. However when a 1 AA or a 2 AA algorithm is enabled multiple sets of sample locations may be stored in the programmable sample pattern table simultaneously and each pixel quad may specify which of the patterns in the programmable sample pattern table should be used for that particular pixel quad. For example in conjunction with a 1 AA algorithm the first four entries i.e. entries may be filled with valid sample location for a first set of sample locations the second four entries i.e. entries may be filled with valid sample location for a second set of sample locations and so forth. Pixel quads may then be configured to use one of the four valid sets of sample locations stored in the programmable sample pattern table . In one embodiment the x coordinate and y coordinate of at least one pixel in the pixel quad may be used at least in part to select which of the sets of sample locations should be associated with the pixel quad. For example a function based on the x coordinate and y coordinate of the upper left pixel in the pixel quad could be used to calculate which of the four sets of sample locations are associated with that particular pixel quad e.g. x y y 4 .

In yet another embodiment the programmable sample pattern table may include sixteen unrelated entries representing sixteen different locations relative to the upper left corner of a pixel. For each sample in a particular pixel a hash function may be used to generate an index that points to an entry of the programmable sample pattern table that specifies the location of the sample relative to the upper left corner of the pixel. Each sample in a pixel may be required to hash to a different index such as by the function x y i g x y 4 i where i is an index for the sample for the pixel. Because g x y 4 is constant for a particular pixel each sample will generate a different index within the programmable sample pattern table.

In one embodiment the values in the programmable sample pattern table may be normalized to enable window offset support or y inversion support. In other words the values included in the programmable sample pattern table may be surface relative while the application expects the values to be window relative . In other words the application expects a first sample location in the upper left pixel in the active window to be associated with the first sample location in the programmable sample pattern table . However if the active window is offset relative to the display surface the upper left pixel may not correspond to the expected values in the programmable sample pattern table .

In order to correct for this window offset the values of the programmable sample pattern table may be rearranged such that the surface relative pixel coordinates for pixels in the active window correspond to the expected window relative index into the programmable sample pattern table . For example if the window is shifted one pixel to the right and the surface is divided into pixel quads having indices of one for the upper left pixel in the pixel quad two for the upper right pixel in the pixel quad three for the lower right pixel in the pixel quad and four for the lower left pixel in the pixel quad then the values specified for the first pixel of the pixel quad may be inserted into the second index of the programmable sample pattern table the values specified for the second pixel of the pixel quad may be inserted into the first index of the programmable sample pattern table the values specified for the third pixel of the pixel quad may be inserted into the fourth index of the programmable sample pattern table and the values specified for the fourth pixel of the pixel quad may be inserted into the third index of the programmable sample pattern table . This arrangement of the values in the programmable sample pattern table may be made automatically by the hardware units to correct for the window offset. A similar effect can be performed for enabling y inversion support i.e. where y coordinates are specified from the bottom of the window rather than the top of the window . In alternative embodiments the hash function can be adjusted to correct for window offset or y inversion rather than changing the order of the values in the programmable sample pattern table .

It will be appreciated that the flexibility of the programmable sample pattern table may be utilized to increase processing efficiency of graphics hardware. For example a user may want to utilize a 4 AA algorithm with a particular application such as a video game. However the graphics hardware may not have the processing capacity to implement the 4 AA algorithm at a sufficient frame rate. Instead the graphics hardware can implement a 2 AA algorithm for a first frame using a first set of sample locations and then implement a 2 AA for a second frame using a second set of sample locations alternating between the first set of sample locations and the second set of sample locations every other frame. In doing so the graphics hardware produces video data that is effectively 4 AA by dithering between two values every other frame. In sonic cases every other pixel can be configured to use a different set of sample locations such that some artifacts are not as noticeable. For example with long narrow geometric primitives that span multiple pixels the first set of sample locations might not intersect the geometric primitive at all while the second set of sample locations does intersect the geometric primitive. By alternating which pixels in a particular frame use the first set of sample locations and the second set of sample locations each frame includes pixels representing a portion of the geometric primitive rather than having one frame that includes pixels that represent the geometric primitive and a subsequent from that does not include pixels that represent the geometric primitive.

At step the hardware unit receives a second instruction that causes one or more new values to be stored in the programmable sample pattern table. Again the one or more new values may be included in the second instruction or the second instruction may include a pointer to a location in a memory that stores a copy of the one or more new values. Importantly the second instruction can be included anytime within the data stream being processed by the hardware unit . In other words the sample locations stored in the programmable sample pattern table can be changed after every frame after every pixel tile after every pixel quad or even after every pixel depending on the implementation. At step the hardware unit performs a second anti aliasing operation based on at least one new value stored in the programmable sample pattern table.

At step the hardware unit transmits the instruction to a second hardware unit . In one embodiment the hardware unit may be e.g. a rasterizer which transmits the instruction to a ZROP engine for performing a Z test. The instruction causes the second hardware unit to store the one or more values in a second programmable sample pattern table.

The system also includes input devices a graphics processor and a display i.e. a conventional CRT cathode ray tube LCD liquid crystal display LED light emitting diode plasma display or the like. User input may be received from the input devices e.g. keyboard mouse touchpad microphone and the like. In one embodiment the graphics processor may include a plurality of shader modules a rasterization module etc. Each of the foregoing modules may even be situated on a single semiconductor platform to form a graphics processing unit GPU . In one embodiment at least one module in the graphics processor comprises a hardware unit that includes the programmable sample pattern table .

In the present description a single semiconductor platform may refer to a sole unitary semiconductor based integrated circuit or chip. It should be noted that the term single semiconductor platform may also refer to multi chip modules with increased connectivity which simulate on chip operation and make substantial improvements over utilizing a conventional central processing unit CPU and bus implementation. Of course the various modules may also be situated separately or in various combinations of semiconductor platforms per the desires of the user.

The system may also include a secondary storage . The secondary storage includes for example a hard disk drive and or a removable storage drive representing a floppy disk drive a magnetic tape drive a compact disk drive digital versatile disk FWD drive recording device universal serial bus USB flash memory. The removable storage drive reads from and or writes to a removable storage unit in a well known manner.

Computer programs or computer control logic algorithms may be stored in the main memory and or the secondary storage . Such computer programs when executed enable the system to perform various functions. The memory the storage and or any other storage are possible examples of computer readable media.

In one embodiment the architecture and or functionality of the various previous figures may be implemented in the context of the central processor the graphics processor an integrated circuit not shown that is capable of at least a portion of the capabilities of both the central processor and the graphics processor a chipset i.e. a group of integrated circuits designed to work and sold as a unit for performing related functions etc. and or any other integrated circuit for that matter.

Still yet the architecture and or functionality of the various previous figures may be implemented in the context of a general computer system a circuit board system a game console system dedicated for entertainment purposes an application specific system and or any other desired system. For example the system may take the form of a desktop computer laptop computer server workstation game consoles embedded system and or any other type of logic. Still yet the system may take the form of various other devices including but not limited to a personal digital assistant IDA device a mobile phone device a television etc.

Further while not shown the system may be coupled to a network e.g. a telecommunications network local area network LAN wireless network wide area network WAN such as the Internet peer to peer network cable network or the like for communication purposes.

While various embodiments have been described above it should be understood that they have been presented by way of example only and not limitation. Thus the breadth and scope of a preferred embodiment should not be limited by any of the above described exemplary embodiments but should be defined only in accordance with the following claims and their equivalents.

