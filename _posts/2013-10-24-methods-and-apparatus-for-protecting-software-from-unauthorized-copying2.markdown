---

title: Methods and apparatus for protecting software from unauthorized copying
abstract: A processing device provides a method for protecting a program from unauthorized copying. The processing device may include an encrypted version of the program. According to one example method, the processing device creates a secure enclave, and in response to a request to execute the encrypted program, the processing device automatically generates a decrypted version of the program in the secure enclave by decrypting the encrypted program in the secure enclave. After automatically generating the decrypted version of the program in the secure enclave, the processing device may automatically execute the decrypted version of the program in the secure enclave. Other embodiments are described and claimed.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09536063&OS=09536063&RS=09536063
owner: Intel Corporation
number: 09536063
owner_city: Santa Clara
owner_country: US
publication_date: 20131024
---
This application is a national stage application under 35 U.S.C. 371 of international application serial no. PCT US2013 066715 entitled METHODS AND APPARATUS FOR PROTECTING SOFTWARE FROM UNAUTHORIZED COPYING filed on Oct. 24 2013.

Embodiments described herein generally relate to data processing and in particular to methods and apparatus for protecting software from unauthorized copying.

The hardware and firmware components in a conventional data processing device may be referred to collectively as the system platform. An operating system may run on top of the system platform providing a layer of abstraction that enables developers to disregard many of the specific details of the various hardware and firmware components of the underlying system platform. Many different operating systems have been created for many different system platforms.

In addition software has been created to allow a single application to run on different operating systems. Such software provides another layer of abstraction on top of the operating system. That layer of abstraction may be referred to as a virtual machine VM or a virtual runtime environment VRE .

If an application is designed to run in a VRE the application is not limited to a particular system platform or a particular operating system but can be used on various different platforms with various different operating systems. The term virtual application may be used in general to refer to a program an application an applet and or other software that is designed to run in a VRE. By contrast the term virtualization software may be used in general to refer to software that is designed to provide the VRE itself. For instance a processing device may run virtualization software that creates a VRE which in turn enables a virtual application to run within that VRE.

Virtualization software typically includes a collection of components which work together to create the VRE. That collection of components may be referred to as a virtualization package.

Different developers have created various different virtualization packages to provide various different varieties of VREs. For instance software distributed under the JAVA trademark provides a so called Java Runtime Environment JRE or Java Virtual Machine JVM . That virtualization package includes core classes and supporting libraries for implementing the JRE. Other software packages designed to provide VREs include without limitation products distributed under names or trademarks such as PARROT and COMMON LANGUAGE RUNTIME CLR .

One of the challenges currently faced by the software industry is the challenge of protecting virtual applications and other software from unauthorized copying. Unauthorized copying of software may also be referred to as software piracy.

One way to discourage the unauthorized copying of software is to encrypt the software before distributing it. However the software will need to be decrypted before it runs. So there remains a risk that the software will be copied after it has been decrypted.

As described in greater detail below the present disclosure describes technology which allows the software provider to distribute an encrypted version of an application to a customer s processing device and which allows that processing device to run a decrypted version of the application in a secure enclave without ever exposing the decrypted version of the application outside of the enclave.

As used herein the terms processing system and data processing system are intended to broadly encompass a single machine or a system of communicatively coupled machines or devices operating together. For instance two or more machines may cooperate using one or more variations on a peer to peer model a client server model or a cloud computing model to provide some or all of the functionality described herein. In the embodiment of the processing devices in processing system connect to or communicate with each other via one or more networks . The networks may include local area networks LANs and or wide area networks WANs e.g. the Internet . For purposes of this Description of Embodiments local processing device may also be referred to simply as processing device . 

In the embodiment of processing device features at least one central processing unit CPU or processor along with random access memory RAM a network port and one or more nonvolatile mass data storage devices such as a hard disk drive HDD responsive to or coupled to processor . Processor may include one or more processor cores. A processor core may also be referred to as a processing unit or a processing element. Additional input output I O components e.g. a keyboard a display etc. may also be responsive to or coupled to processor . Processor may include a platform key .

In the embodiment of processing device is configured to sequester some of RAM as illustrated by the vertical dashed line in RAM to provide for one or more secure enclaves . The sequestered memory space may be referred to as the crypto memory aperture CMA . In one embodiment CMA is a region of the physical address space which is reserved to provide for one or more secure enclaves. In the embodiment of CMA contains secure enclave along with associated structures or items for supporting security. For instance CMA may include a secure enclave control structure SECS and SECS may contain a secure enclave measurement and an application key B as described in greater detail below. The memory space outside of CMA which may be referred to as the native memory may remain relatively unprotected.

In one embodiment a secure enclave provides an isolated execution environment for any application to process confidential data. An enclave is privacy and integrity protected so that only the code inside an enclave can access that enclave s data. Also a secure enclave does not allow code from outside of the enclave to be executed. For instance if a conventional application were to run in a secure enclave that application would be unable to access operating system application programming interfaces APIs residing outside of the enclave. Further details on secure enclaves according to at least one embodiment are described in greater detail below. In addition more details for at least one embodiment of secure enclave technology may be found in U.S. patent application publication no. 2012 0159184 entitled Technique for Supporting Multiple Secure Enclaves hereinafter the Secure Enclave Application .

In the embodiment of HDD and or other storage media in processing device contains various software components which may be copied into RAM and executed. For instance HDD includes an operating system OS and a native library . Native library may include software that is designed to run on operating system . In the embodiment of that software includes a native called module and a native calling statement .

HDD also includes virtualization software . Processing device may use virtualization software to create VRE for example. For instance virtualization software may include code for implementing an interpreter that allows virtual applications to execute in VRE . Virtualization software may also contain supporting libraries core classes and other components for VRE .

Operating system may run from native memory and it may provide a distinct stack for each active thread. OS may also include various APIs which enable other software components to use services provided by operating system . In one embodiment software running in secure enclave is not allowed to access any of the OS APIs . However as described in greater detail below processing device provides new calling conventions to enable software to call functions across enclave boundaries. For instance a protected calling statement that runs in VRE within secure enclave may use those conventions to call native called module and native calling statement may use those conventions to call a protected called module that runs in VRE within secure enclave . In addition processing device provide an SE driver that loaders for protected applications may use to create secure enclaves. For example SE driver may be a kernel mode component it may be untrusted and it may be used for managing an enclave page cache within CMA . In one embodiment SE driver participates in enclave creation only enabling a program or application to invoke specialized instructions for preparing enclaves like ECREATE EADD EEXTEND and EINIT. In the embodiment of SE driver does not belong to any particular application and it is provided as part of operating system .

HDD may also include a virtual application that is designed to run within VRE . However that virtual application may be stored on HDD in a partially or completely encrypted form as depicted in by protected application A. In the embodiment of protected application A includes a main routine A a protected calling statement A and a protected called module A. In addition the key for decrypting protected application A may itself also be stored on HDD . In the embodiment of such a key is saved in encrypted form as depicted by protected application key A.

The protected components that are stored on HDD may be partially or completely encrypted using any suitable encryption technology. In one embodiment protected application A has been completely encrypted using symmetric key encryption based on a decrypted version B of protected application key A. In one embodiment protected application key A has been completely encrypted using symmetric key encryption based on an enclave key and enclave key is tied to secure enclave . For instance a protected application loader PAL may derive enclave key based at least in part on secure enclave measurement and platform key . Thus protected application key A may be tied to a specific enclave in a specific device.

From one perspective components such as main routine A protected calling statement A and protected called module A may be considered virtual applications. From another perspective such modules may be considered components of a larger virtual application such as protected application A. In one embodiment protected application A is bytecode. Additionally many different approaches and or mechanisms may be used to implement protected applications. For instance an application may be implemented as a class library. Also an application may also be referred to as a program and an application key may be referred to as a program key. Also a program executing within a secure enclave may be referred to as a protected program while a program executing outside of a secure enclave may be referred to as an unprotected program.

In one embodiment protected application A is a virtual application that was created by a software developer and that may be distributed by the software developer or by some other authorized entity such as an independent software vendor ISV or a distributor. For purposes of this document unless the context clearly requires otherwise the term developer denotes the software developer and or any related entities such as ISVs distributors licensing authorities that provide authentication services for the software developer etc.

HDD may also include a secure enclave loader SEL a protected application provisioner PAP and a protected application loader PAL . As described in greater detail below SEL PAP and PAL when launched may perform various operations to prepare processing device to execute one or more protected applications. For instance SEL may create a secure enclave and may launch PAP and or PAL within that secure enclave.

HDD may also include a secure enclave runtime library SERL . SERL may include functions programs APIs etc. that other components e.g. SEL may use to create secure enclaves and SERL may facilitate data exchange between an enclave and its hosting application. SERL may include libraries linked into both trusted and untrusted parts of an application. Accordingly some components of SERL may run from native memory and others may run within a secure enclave. In one embodiment SERL provides functions for creating and managing enclaves such as functions for building or compiling an enclave image file at build time and functions for loading an enclave into the EPC from its image file at run time using instructions such as ECREATE EADD EEXTEND and EINIT. SERL may also provide functions for managing trusted threads and SERL may use SE driver to perform certain subtasks in the untrusted space. SERL may also provide the program that serves as the entry point for a secure enclave. SERL may also provide wrappers for certain specialized instructions designed for enclaves enclave get key or EGETKEY enclave report or EREPORT and enclave exit or EEXIT and SERL may govern the calling conventions for calling in to a secure enclave and for calling out from a secure enclave.

In one embodiment secure enclaves must be fully created before being entered. In one embodiment SEL is responsible for properly laying out the content of a secure enclave in memory before launching software in that enclave. For example SEL may be responsible for laying out a secure enclave for PAL the same way each time in order to achieve the same valid enclave measurement each time PAL executes. Likewise SEL may be responsible for laying out other secure enclaves e.g. one secure enclave for an independent PAP and another secure enclave for the PAL and the protected application the same way each time.

In the embodiment of virtualization software also includes control logic and other data for implementing a VRE native counterpart VNC that resides in native memory . VNC may facilitate cooperation between protected virtual applications in VRE and applications outside of VRE . For instance as described in greater detail below VNC may enable a protected calling statement B within VRE to interact with native called module and VNC may enable native calling statement to interact with a protected called module B.

For instance VNC may include a specialized function or program that enables modules outside of secure enclave to call modules within secure enclave . This specialized function may be referred to as an enclave call in ECI function ECIF . Similarly a statement which uses ECIF may be referred to as an ECI statement. Thus native software may include an ECI statement that uses ECIF to call in to protected software within secure enclave . VNC may also facilitate execution of protected applications within VRE for instance by providing access to operating system services.

Similarly secure enclave may include a specialized function that enables modules within VRE within secure enclave to call modules outside of secure enclave . This specialized function may be referred to as an enclave call out ECO function ECOF . Similarly a statement which uses ECOF may be referred to as an ECO statement. Thus an application may include an ECO statement that uses ECOF to call out to native software from inside secure enclave .

For purposes of this disclosure the term VRE native interface VNI call may be used to refer to a a call from a module running within VRE to a module outside of VRE as well as a call from outside of VRE to a module within VRE . For instance ECIF and ECOF may use VNI calls. In some respects. VNI calls may be similar to Java Native Interface JNI calls.

To provision or install a protected application processing device may use a process like the one illustrated in for example.

Processing device may then receive a request to install protected application A as shown at block . In response processing device may use SEL to create a secure enclave and SEL may launch PAP to execute within that secure enclave as indicated at block .

In the embodiment of SEL is an untrusted component that runs from native memory . SEL may use various operations or instructions to create the secure enclave and to launch PAP within the secure enclave. For instance SEL may call SE driver with parameters instructing SE driver to invoke ECREATE. SEL may then make a sequence of calls to SE driver with parameters instructing SE driver to execute a sequence of EADD or extend instructions to add and measure code and data pages. PAP may be included in those pages. SEL may then call SE driver with parameters instructing SE driver to execute an EINIT instruction to finish the enclave initialization process and lock down the measurement. In one embodiment an enclave cannot be entered until after EINIT has been invoked and once EINIT has been invoked no further EADD or extend operations are allowed. In one embodiment SEL is a user mode component but some or all of the instructions used by SE driver to provision the secure enclave are privileged instructions that can only be invoked in kernel mode. Accordingly SE driver enables SEL to create an enclave by invoking those privileged instructions in kernel space on behalf of SEL .

In one embodiment ECIF operates as a proxy and SEL uses ECIF to interact with the secure enclave. For instance after ENIT has been invoked SEL may then call ECIF with parameters that a instruct ECIF to enter the secure enclave that b identify PAP as the program within the secure enclave to ultimately receive control after the secure enclave has been entered and that c provide the address of a memory buffer holding protected application A. ECIF may marshall the parameters to identify PAP and to locate protected application A onto the stack. Then ECIF may execute EENTER with a parameter that provides the linear address of a thread control structure TCS within the enclave. In particular the TCS parameter of the EENTER instruction may identify a TCS which contains the address of a thread entry point for the enclave. In other words the TCS may contain a pointer to a program within the enclave that serves the entry point for the enclave. That program may be referred to as the main enclave routine and it may come from SERL . In one embodiment TCS pages are measured. Consequently the untrusted code cannot use an address different than the one assumed by the enclave vendor without breaking the measurement. The TCS may also contain a pointer to a state save area SSA for the enclave.

In addition SERL may use a table generated at build time to track the addresses of stubs inside the enclave and an ECIF proxy may provide the index of its corresponding stub in a register before invoking EENTER to enable main enclave routine to dispatch the call. For instance ECIF may provide an index to identify a corresponding ECIF stub within secure enclave .

Accordingly when EENTER is executed processor may a enter a specific thread of the enclave b mark the TCS for that thread as busy c transition the thread into enclave mode and d transfer control to the identified entry point within the enclave. For instance as indicated above on behalf of SEL ECIF may execute EENTER with an entry point parameter that points to the main enclave routine. Consequently processing device launches main enclave routine in secure enclave and then main enclave routine calls ECIF stub . ECIF stub then unmarshalls the identifier for PAP from the stack and in response launches PAP and supplies PAP with the address for protected application A.

One important aspect of installing protected application A is to provide for application key B which is needed to convert decrypt protected application A to plaintext protected application B so that protected application B can be executed. Accordingly as indicated at block once PAP is launched it may determine as part of the process for installing Or provisioning protected application A whether or not processing device already contains protected application key A. To make that determination PAP may consult a protected application registry in VNC for instance. In the embodiment of if PAP is unable to find protected application key A. PAP may send a request for the key to a licensing authority for protected application A as shown at block . The licensing authority may use remote processing device for instance to service key requests.

The licensing authority may do a license check before provisioning the application key to processing device . In one embodiment the licensing authority will not release the application key to processing device unless the licensing authority can verify that the user who is requesting the key has purchased the protected application. Accordingly upon receipt of the key request remote processing device may send a request for authentication to processing device as shown at block . If processing device has not already been licensed to execute protected application A processing device may perform additional operations to obtain the license. For example a user may be prompted to enter a verification code to prove that the user purchased a valid unused copy of protected application A. In addition or alternatively PAP may collect user identity data from the user.

As indicated at block PAP may then send authentication data e.g. the verification code and or the user identity data to remote processing device to prove that processing device is or should be licensed to execute protected application A. Alternatively PAP may include some or all of the necessary authentication data when submitting the request for the key instead of after submitting the request.

In addition PAP may be required to attest itself to the licensing authority. In one embodiment PAP provides for remote attestation by first performing a local attestation by generating a measurement report that can be verified by other enclaves running on the same processor in the same session. PAP then uses a quoting enclave to verify and digitally sign the report to make the report verifiable globally. The digital signature will certify that the report along with its attached data was generated by an enclave having a specified measurement and running on an approved processor with enclave technology enabled. PAP may send the signed report to the licensing authority. The challenger e.g. license authority may then determine based on the report whether or not to trust PAP . In one embodiment the attached data in the report will contain some proof of purchase by the end user and the License Agent could decide to honor or deny the request based at least in part on that proof of purchase.

As shown at block if the licensing authority accepts the authentication and attestation data as valid remote processing device may then send the key for protected application A to processing device . When the application key is sent to processing device the licensing authority may use Secure Sockets Layer SSL Transport Layer Security TLS or any other suitable means to protect the key.

In addition since PAP is running in a secure enclave PAP may be unable to access operating system APIs directly. However VNC may provide services to allow PAP to access operating system services indirectly. Thus PAP may use services from VNC to communicate with the licensing authority. In particular ECOF may serve as a proxy VNC may include a corresponding ECOF stub and PAP may use ECOF to obtain services from operating system via VNC . In addition or alternatively native memory may include a different entity such as a PAP native counterpart PNC that provides services for PAP in a manner similar to the way VNC provides services for interpreter .

PAP may then prepare to seal the application key against the identity of the enclave in which the protected application will subsequently be launched. Consequently the application key could only be unsealed using the same identity as was used for sealing.

For purposes of this disclosure the secure enclave that receives and seals the application key may be referred to as the installation enclave and the secure enclave within which the protected application is authorized to execute may be referred to as the execution enclave.

Different types of identity may be required for different embodiments or protected applications depending on the preferences of the developer. In the embodiment of the developer requires the application key to be sealed to an identity based on a measurement of the secure enclave MR ENCLAVE . MR ENCLAVE may be a measurement e.g. a hash of the enclave code and data. Accordingly the secure enclave that PAP has been running in also includes the components that will eventually be needed to execute the virtual application such as PAL VRE and protected application A. For example PAP may be embedded or integrated into secure enclave and PAP may be linked statically with other components of the enclave such as VRE . Therefore PAP may share the enclave specific keys with VRE . Consequently PAP may obtain enclave key based on the measurement of secure enclave as indicated at block . PAP may use operations like those described below with regard to block of to obtain enclave key for instance. As shown at block PAP may then seal the key for protected application A to secure enclave . For example PAP may use enclave key to create an encrypted version A of application key B. For instance PAP may use symmetric encryption with enclave key to seal the application key. And since PAP and protected application A reside in the same enclave or in separate enclaves sighed by the same key and sharing the same product ID as indicated below PAL will be able to unseal the application key in subsequent sessions.

Alternatively under some conditions the developer may allow the measurement for the installation enclave to be different from the measurement for the execution enclave. For example the developer may allow for the PAP to be part of the installation enclave but not the execution enclave. The execution enclave may only contain the PAL the VRE and the protected application for instance. However the application key must be sealed against the execution enclave in some manner. In such a case the developer may require the application key to be sealed to an identity based on a hash or other measurement MR SIGNER of a signing key e.g. a Rivest Shamir Adleman RSA key used to sign the execution enclave. Thus instead of using the measurement of the installation enclave to seal the application key the PAP seals the application key against MR SIGNER. This approach allows for smaller enclaves e.g. the PAP need not be linked in to the secure enclave for the protected application although this approach might not be quite as secure. Furthermore if MR SIGNER is chosen in EGETKEY to derive the sealing key any secret sealed by an enclave could be unsealed by any other enclaves that have the same product ID if the enclave is signed by the same signing key. For purposes of this disclosure the product ID is a number that is assigned by the developer and embedded in the enclave signature. Processor may provide instructions e.g. EGETKEY which allow programs to use that number along with the hash of a signing key to derive enclave specific keys. Furthermore every enclave may have a secure version number SVN in its signature assigned by the developer. The SVN may also be included in key derivations. An enclave may request a derived key from MR SIGNER by calling EGETKEY with a target SVN and processor will make sure the caller s SVN is at or above the target SVN before deriving the key. This approach ensures that to newer version of the same enclave could open blobs sealed by an older version but not vice versa.

Referring again to as shown at block PAP may then save protected application key A to HDD . In addition PAP may update a data structure in VNC with data to tie protected application key A to protected application A and to specify where protected application key A is stored e.g. by file path name . That data structure may be referred to as a protected application registry PAR . More or less conventional techniques may be used to complete any addition installation steps required. The installation process may then end.

SEL may then create and populate CMA . For example as shown at blocks and SEL may load PAL protected application A protected application key A and any other necessary data into CMA . PAL may use protected application registry to find protected application key A. Alternatively the protected application and other components could be embedded into the enclave in which case those components would not need to be individually loaded into the CMA. SEL may also load PAP into CMA so the measurement of secure enclave will match the measurement used to seal the application key. In one embodiment SEL uses SE driver and SE driver executes instructions like EADD EINIT and EENTER for the operations described above. As shown at block . SEL may then enter secure enclave . For example SEL may call ECIF with parameters that identify PAL as the program to be executed within the secure enclave after the secure enclave is entered and that identify the location of protected application A.

As shown at block processing device may then launch PAL within secure enclave . In particular processing device may launch main enclave routine main enclave routine may launch ECIF stub and ECIF stub may unmarshall the parameters and launch PAL . As shown at block PAL may then derive enclave key for secure enclave based on secure enclave measurement . Enclave key may be tied to secure enclave and also tied to processor and PAL may use a specialized function or instruction to obtain enclave key . Such a specialized instruction may be referred to as an EGETKEY instruction. The EGETKEY instruction may derive enclave key from a package unique value in processor e.g. platform key and from the identity of secure enclave . The identity of a secure enclave means the measurement e.g. a 512 bit secure hash algorithm or SHA 512 value that reflects how the enclave was loaded or what it contains. Thus two enclaves will have the same identity if and only if they occupy the same size of virtual address have the same set of code and data pages and those pages are mapped at the same addresses relative the enclave base address and in the same order. In at least one embodiment the EGETKEY instruction will always return the same value for the enclave key if called from a future instance of the same secure enclave on the same platform but the EGETKEY instruction will return a different value if called from a different secure enclave. Additional details for the EGETKEY instruction may be found in the Secure Enclave Application. Since PAL is running in secure enclave the secure enclave s attestation infrastructure e.g. the EGETKEY instruction provisions enclave key to PAL securely.

As shown at block PAL may then use enclave key to decrypt protected application key A thereby generating protected application key B. As shown at block of PAL may then use protected application key B to decrypt protected application A thereby generating protected application B. As indicated in the decrypted application may include main routine B protected calling statement B and protected called module B each of which is also decrypted. In one embodiment PAL decrypts protected application A in place. Other approaches may be used in other embodiments such as decrypting the protected application into open space that has already been allocated to the secure enclave.

As shown at block PAL may then use virtualization software to create VRE within secure enclave . PAL may then transfer control to protected application B in VRE as indicated at block . For instance PAL may call into the entry point for VRE with parameters instructing VRE to launch main routine B. Interpreter may then execute protected application B as shown at block . For instance interpreter may execute main routine B.

Furthermore as described in greater detail below with regard to protected calling statement B may cooperate with native called module and protected called module B may cooperate with native calling statement . The process of may then end.

In one embodiment PAL is native code that runs in secure enclave . Other arrangements may be used in other embodiments. For instance the PAL could be bytecode that runs on the interpreter in the secure enclave or the PAL could be part of the interpreter. However only the intended enclave on the intended platform can open the sealed application key and decrypt the protected application. In at least one embodiment the enclave must be exactly the same every time to get to the exact seal key used to decrypt the protected application key. In one embodiment the PAL uses an attestation function or instruction to obtain unique attestation data for the secure enclave. This process may be referred to as quoting. For example the PAL may use EREPORT to generate a locally verifiable certificate for the quoting enclave to verify and the certificate may then be signed digitally by the quoting enclave to become globally verifiable. The certificate may constitute a report containing all identifiable info for the enclave e.g. the measurement the hash of the signing key the product ID etc. along with custom data provided by the enclave who invoked the EREPORT instruction.

CMA may contain an enclave page cache EPC an enclave page cache map EPCM and a backing store as part of the physical address space . Software such VRE may run from within an enclave within EPC . EPC may also include an SSA that provides space for saving state data or context for secure enclaves. Additional details on how a processing device may use features like those described above to protect the information in secure enclaves may be found in the Secure Enclave Application.

In addition to CMA physical address space contains the relatively unprotected native memory address space . VNC operating system and modules from native library such as called module and calling statement may run from native memory .

Dashed line in shows from a high level perspective that protected calling statement B in VRE calls native called module outside of secure enclave with native called module returning results to protected calling statement B. However as described in greater detail below the solid lines with arrow heads show at a lower level how those interactions are supported.

At or after build time the software developer may also generate a corresponding CI proxy routine for each CI stub. The CI proxy routines and CI proxy stubs may include control logic for transferring control across the enclave boundary and for marshalling and unmarshalling parameters to facilitate communication across the enclave boundary. The CI proxy routines may be based on the names parameters and return types of the CI proxy stubs for instance.

VNC may include a CI proxy module and a CO manager . CO manager is described in greater detail below. CI proxy module may include the CI proxy routines referenced above. Alternatively a CI proxy module could contain pointers or indexes to CI proxy routines. CI proxy module may operate more or less like a JNI environment JNIEnv interface. However instead of carrying out the called function like a JNIEnv CI proxy module may marshall the parameters for the called function and then send control to VRE for invocation of the called function. In particular CI proxy module may use the CI proxy routines to perform operations like marshalling parameters for called functions and then sending control to VRE .

The process of starts with protected application B running in VRE within secure enclave as indicated at block . As shown at block interpreter may then determine whether protected application B is trying to call a module outside of secure enclave . For instance interpreter may be interpreting protected calling statement B which calls native called module . If protected application B is trying to call an outside module or function e.g. native called module interpreter may use CO proxy module to handle the call.

Referring also to line depicts interpreter using CO proxy module to handle a call from protected calling statement B to native called module .

CO proxy module may then automatically perform operations that enable control and information to pass out of secure enclave and back into secure enclave . Thus CO proxy module may serve as a generic or general purpose proxy routine.

For instance as indicated at block of CO proxy module may use any suitable mangling rules to generate a unique name or identifier for native called module . CO proxy module may generate that identifier based on attributes of the function such as class name method name argument types and return type for instance. Thus CO proxy module may encode those attributes into the identifier that CO proxy module generates for native called module . In addition SSA may include a pointer to the stack for the current thread and CO proxy module may then marshall the parameters for the native function onto stack as shown at block . For instance CO proxy module may a load the identifier and the parameter values for the native function into a marshalling buffer b update the value of a stack pointer register RSP inside SSA to allocate space on stack for the marshalling buffer and c then push that marshalling buffer onto stack . For example if 100 bytes are needed for the marshalling buffer CO proxy module may decrement the stack pointer by 100 bytes. As illustrated in unlike the CMA stack may reside in native memory . Stack may be managed by operating system for instance. Consequently the marshalling buffer may be accessed after control has left secure enclave .

As shown at block after marshalling the parameters CO proxy module may call the native routine. In one embodiment CO proxy module uses ECOF to call the native routine. In one embodiment ECOF executes an EEXIT instruction. The EEXIT instruction may cause control to pass to the proxy routine that had originally called EENTER to enter secure enclave . When that proxy receives control the thread uses the new value for the stack pointer. That proxy then determines whether control should then be passed back up to its caller or to CO manager if the EEXIT was due to a call from within secure enclave to a module outside of secure enclave . Since the current process involves a call to a module outside of secure enclave the proxy will invoke CO manager .

Referring again to line depicts CO proxy module calling out from secure enclave and CO manager in VNC subsequently receiving control.

As shown at block CO manager in VNC may then serve as a generic or general purpose native stub for handling calls from secure enclave . CO manager may use the same basic kinds of policies to handle those calls as those used by CO proxy module . For instance CO manager may pop out the function name or identifier e.g. the function s address and unmarshall the parameters for native called module from stack as shown at blocks and . As shown at block CO manager may then call native called module .

Line in also depicts control passing from CO manager to native called module . When native called module is finished executing control may pass back to CO manager as indicated by line in . As shown at block CO manager may then marshall the return parameters onto the stack. As shown at block CO manager may then return control to CO proxy module . Line in also shows control returning to CO proxy module .

In particular CO manager may use EENTER to reenter the enclave. Accordingly control may first pass to the entry point for the secure enclave such as main enclave routine . Main enclave routine may then distinguish between new calls into secure enclave and returning calls from secure enclave to native functions and main enclave routine may then restore the stack pointer appropriately. For returning calls execution will resume at the instruction that follows EEXIT inside the ECOF . ECOF may then invoke CO proxy module .

As shown at block of CO proxy module may then unmarshall the parameters from stack . CO proxy module may then supply those parameters to protected calling statement B thereby completing the call from protected calling statement B to native called module as shown at block . Line in also indicates that protected calling statement B in effect completes execution.

In another embodiment CO proxy routines are generated in advance before the interpreter starts executing a protected application and or a protected calling statement. Those CO proxy routines may be compiled into native code and linked into the protected application or they may be written in bytecode and just in time JIT compiled for instance. Those CO proxy routines may include control logic for performing the operations described above with regard to CO proxy module . A CO proxy generator may generate that control logic based on the argument types and the return type for the called module for instance. The CO proxy routines may then be saved in a CO proxy module or the CO proxy module may be loaded with information to enable the interpreter to find those routines. Thus the CO proxy module may look up the correct proxy based on the fully qualified name of the called module. The interpreter for the VRE may consult the CO proxy module wherever a call out statement is encountered and the interpreter could generate an error e.g. an exception should no proxy be found. Alternatively a CO proxy module may dynamically generate CO proxy routines as needed for instance in response to the interpreter reaching a call out statement. Depending on requirements the CO proxy module may be configured to generate CO proxy routines in native code or in bytecode which could be JIT compiled into native code.

Similarly a CO manager may automatically generate and launch a distinct native function stub for each native module in response to that native module being called. In addition or alternatively the CO manager may be populated in advance with some or all of the necessary native stubs e.g. before the native modules are called .

Referring again to block of after protected calling statement B has completed the process may then pass through page connector A to . As shown at block VNI may then determine whether a native statement is calling a module of protected application B VRE . For instance native calling statement may be calling protected calling module B possibly via the corresponding CI proxy routine and CI stub.

In the embodiment of protected application B provides a fixed set of functions such as protected called module B which can be called by native code. Protected called module B may be identified by a descriptor which is an opaque structure internal to VRE . In a conventional processing system a native calling statement locates a descriptor for a module in a VRE by providing at runtime the module s fully qualified name comprised of the package class and method names. Other approaches may be used in other embodiment. As indicated above processing device includes CI proxy routines and CI stubs for functions or modules in VRE that may be called from outside of secure enclave .

Block of shows native calling statement executing a call to protected called module B. However from a high level perspective VNC intercepts that call and in response to the call executes the corresponding the CI proxy routine as shown at block . As shown at block the CI proxy routine may then marshall parameters for the CI stub. As shown at block the CI proxy routine may then use ECIF to call protected called module B via the CI stub. As shown at block VNI may intercept that call. If VNI determines that the CI proxy routine for protected called module B is calling the CI stub for protected called module B VNI may execute that CI stub as indicated at block . As shown at block the CI stub may then unmarshall parameters from the CI proxy routine. As shown at block the CI stub may then call protected called module B. The CI proxy routine and the CI stub may use the stack to marshall and unmarshall parameters.

Referring now to dashed line shows from a high level perspective that native calling statement outside of secure enclave calls protected calling module B in VRE within secure enclave with protected calling module B returning results to native calling statement . However the solid lines with arrow heads show at a lower level how those interactions are supported. For example VNC may serve as an intermediary between native calling statements and VRE . For instance VNC may use CI proxy module to handle calls to VNI . And as indicated above CI proxy module may use CI proxy routines as intermediaries between native calling statements and protected called modules. Also as indicated above VNI function table may be preloaded with CI stubs.

To invoke protected called module B native calling statement may actually call CI proxy routine from CI proxy module as indicated by line . That CI proxy routine may call a CI stub from VNI function table as indicated by line . That CI stub may call protected called module B as indicated by line . Line shows that control returns to the CI stub when protected called module B completes execution. Line shows that control returns to the CI proxy routine when the CI stub completes execution. Line shows that control returns to native calling statement when the CI proxy routine completes execution.

Referring again to protected called module returns control to the CI stub upon completion as shown at block . As shown at block the CI stub may then marshall parameters a return value for consumption by the CI proxy routine. For instance the CI stub may gather all parameters and lay them out continuous on untrusted stack as described above. As shown at block the CI stub may then cause the process or thread to exit secure enclave with control returning to the CI proxy routine. For instance the CI stub may return with the value returned by protected called module B. The CI proxy routine may then resume execution unmarshalling parameters from the CU stub as shown at block . As shown at block the CI proxy routine my complete with control then returning to calling statement . As shown at block calling statement may then resume receiving results from protected called module B via the correspond CI stub and CI proxy routine. Execution outside of secure enclave may then end or it may continue depending on whether native calling statement is the end of a program. And within VRE within secure enclave execution of protected application B may continue as indicated at block of which may be reached via page connector B of .

One or more embodiments are described above with regard to a virtual runtime environment. In other embodiments the teaching of the present disclosure may be used in other environments. For instance those environments may use interpretive languages such as those distributed under the names or trademarks C JAVASCRIPT etc. to decrypt and execute protected applications.

One or more embodiments may provide the following advantages The technology may provide for secure execution of a protected application even though the memory pages containing that application could be marked as writable. The technology may allow code in a secure enclave to call or otherwise utilize services from code outside of the enclave even though only code that resides within the enclave may be executed in the enclave. For instance the technology may allow an applet or other code running in a VRE to communicate with and invoke the applet s dependent native libraries. The technology may also provide for transparent marshalling of parameters for transportation across the enclave boundary in both directions calls in to the enclave and calls out of the enclave.

In light of the principles and example embodiments described and illustrated herein it will be recognized that the illustrated embodiments can be modified in arrangement and detail without departing from such principles. Also the foregoing discussion has focused on particular embodiments but other configurations are contemplated. Also even though expressions such as an embodiment one embodiment another embodiment or the like are used herein these phrases are meant to generally reference embodiment possibilities and are not intended to limit the invention to particular embodiment configurations. As used herein these phrases may reference the same embodiment or different embodiments and those embodiments are combinable into other embodiments.

Any suitable operating environment and programming language or combination of operating environments and programming languages may be used to implement components described herein. As indicated above the present teachings may be used to advantage in many different kinds of data processing systems. Example data processing systems include without limitation distributed computing systems supercomputers high performance computing systems computing clusters mainframe computers mini computers client server systems personal computers PCs workstations servers portable computers laptop computers tablet computers personal digital assistants PDAs telephones handheld devices entertainment devices such as audio devices video devices audio video devices e.g. televisions and set top boxes vehicular processing systems and other devices for processing or transmitting information. Accordingly unless explicitly specified otherwise or required by the context references to any particular type of data processing system e.g. a mobile device should be understood as encompassing other types of data processing systems as well. Also unless expressly specified otherwise components that are described as being coupled to each other in communication with each other responsive to each other or the like need not be in continuous communication with each other and need not be directly coupled to each other. Likewise when one component is described as receiving data from or sending data to another component that data may be sent or received through one or more intermediate components unless expressly specified otherwise. In addition some components of the data processing system may be implemented as adapter cards with interfaces e.g. a connector for communicating with a bus. Alternatively devices or components may be implemented as embedded controllers using components such as programmable or non programmable logic devices or arrays application specific integrated circuits ASICs embedded computers smart cards and the like. For purposes of this disclosure the term bus includes pathways that may be shared by more than two devices as well as point to point pathways.

This disclosure may refer to instructions statements functions procedures data structures application programs configuration settings and other kinds of data. As described above when the data is accessed by a machine the machine may respond by performing tasks defining abstract data types or low level hardware contexts and or performing other operations. For instance data storage RAM and or flash memory may include various sets of statements which when executed perform various operations. Such statements may be referred to as instructions and sets of statements may be referred to in general as software. In addition the term program may be used in general to cover a broad range of software constructs including applications applets routines modules drivers subprograms processes and other types of software components. Also programs and or other data that are described above as residing on a particular device in an example embodiment may in other embodiments reside on one or more other devices. And computing operations that are described above as being performed on a particular device in an example embodiment may in other embodiments be executed by one or more other devices.

It should also be understood that the hardware and software components depicted herein represent functional elements that are reasonably self contained so that each can be designed constructed or updated substantially independently of the others. In alternative embodiments many of the components may be implemented as hardware software or combinations of hardware and software for providing the functionality described and illustrated herein. For example alternative embodiments include machine accessible media encoding instructions or control logic for performing the operations of the invention. Such embodiments may also be referred to as program products. Such machine accessible media may include without limitation tangible storage media such as magnetic disks optical disks RAM ROM etc. For purposes of this disclosure the term ROM may be used in general to refer to non volatile memory devices such as erasable programmable ROM EPROM electrically erasable programmable ROM EEPROM flash ROM flash memory etc. In some embodiments some or all of the control logic for implementing the described operations may be implemented in hardware logic e.g. as part of an integrated circuit chip a programmable gate array PGA an ASIC etc. . In at least one embodiment the instructions for all components may be stored in one non transitory machine accessible medium. In at least one other embodiment two or more non transitory machine accessible media may be used for storing the instructions for the components. For instance instructions for one component may be stored in one medium and instructions another component may be stored in another medium. Alternatively a portion of the instructions for one component may be stored in one medium and the rest of the instructions for that component as well instructions for other components may be stored in one or more other media. Instructions may also be used in a distributed environment and may be stored locally and or remotely for access by single or multi processor machines.

Also although one or more example processes have been described with regard to particular operations performed in a particular sequence numerous modifications could be applied to those processes to derive numerous alternative embodiments of the present invention. For example alternative embodiments may include processes that use fewer than all of the disclosed operations process that use additional operations and processes in which the individual operations disclosed herein are combined subdivided rearranged or otherwise altered.

In view of the wide variety of useful permutations that may be readily derived from the example embodiments described herein this detailed description is intended to be illustrative only and should not be taken as limiting the scope of coverage.

Example A1 is a data processing system with features for protecting software from unauthorized copying. The data processing system comprises a secure enclave loader which enables the data processing system to create a secure enclave. The data processing system also comprises a protected application loader which when executed in the secure enclave enables the data processing system to perform operations comprising a automatically decrypting an encrypted program in the secure enclave thereby generating a decrypted version of the program and b after automatically decrypting the encrypted program in the secure enclave automatically executing the decrypted version of the program in the secure enclave.

Example A2 includes the features of Example A1 and when the data processing system creates the secure enclave the secure enclave comprises protected storage that cannot be accessed from outside of the secure enclave. Also the operation of automatically decrypting the encrypted program in the secure enclave comprises storing the decrypted version of the program in the protected storage.

Example A3 includes the features of Example A1 and the operation of automatically decrypting the encrypted program in the secure enclave comprises using a key that is tied to the secure enclave to decrypt the encrypted program in the secure enclave. Example A3 may also include the features of Example A2.

Example A4 includes the features of Example A1. Also the secure enclave loader enables the data processing system to include virtualization software in the secure enclave. Also the virtualization software enables the data processing system to create a virtual runtime environment VRE in the secure enclave. Also an interpreter in the VRE enables the data processing system to execute the decrypted version of the program in the secure enclave. Example A4 may also include of any one or more of Examples A2 and A3.

Example A5 includes the features of Example A1. Also the secure enclave comprises an execution enclave. Also the secure enclave loader enables the data processing system to create a secure enclave to serve as an installation enclave. In addition the data processing system comprises a protected application provisioner which when executed in the installation enclave enables the data processing system to perform operations comprising a obtaining from within the installation enclave a program key capable of decrypting the encrypted program and b sealing the program key in a way that ties the sealed program key to the execution enclave. Example A5 may also include the features of any one or more of Examples A2 A3 and A4.

Example A6 includes the features of Example A5. Also the protected application provisioner enables the data processing system to perform operations comprising a using a measurement associated with the execution enclave to obtain an enclave key for the execution enclave and b using the enclave key to decrypt the program key. Also the operation of decrypting the encrypted program comprises using the decrypted program key to decrypt the encrypted program in the secure enclave. Example A6 may also include the features of any one or more of Examples A2 A3 and A4.

Example A7 includes the features of Example A5. Also the installation enclave and the execution enclave have matching enclave measurements. Also the sealed program key is tied to the measurement of the installation enclave. Example A7 may also include the features of any one or more of Examples A2 A3 A4 and A6.

Example A8 includes the features of Example A5. Also the installation enclave and the execution enclave have different enclave measurements. Also the sealed program key is tied to a signing key for the execution enclave. Example A8 may also include the features of any one or more of Examples A2 A3 A4 and A6.

Example B1 is a method for protecting a program from unauthorized copying. The method comprises creating a secure enclave in a processing device and in response to a request to execute an encrypted program in the processing device performing operations comprising a automatically generating a decrypted version of the program in the secure enclave by decrypting the encrypted program in the secure enclave and b after automatically generating the decrypted version of the program in the secure enclave automatically executing the decrypted version of the program in the secure enclave.

Example B2 includes the features of Example B1. Also the secure enclave comprises protected storage that cannot be accessed from outside of the secure enclave. Also the operation of automatically generating the decrypted version of the program in the secure enclave comprises storing the decrypted version of the program in the protected storage.

Example B3 includes the features of Example B1. Also the operation of automatically generating the decrypted version of the program in the secure enclave comprises using a key that is tied to the secure enclave to decrypt the encrypted program in the secure enclave. Example B3 may also include the features of Example B2.

Example B4 includes the features of Example B1. Also the operation of creating the secure enclave is performed by a secure enclave loader. Also the operation of automatically generating a decrypted version of the program in the secure enclave is performed by a protected application loader in the secure enclave. Example B4 may also include the features of any one or more of Examples B2 and B3.

Example B5 includes the features of Example B1. Also the operation of creating the secure enclave comprises including virtualization software in the secure enclave. In addition the method comprises using the virtualization software to create a virtual runtime environment VRE in the secure enclave and the decrypted version of the program is executed in the secure enclave by an interpreter for the VRE. Example B5 may also include the features of any one or more of Examples B2 B3 and B4.

Example B6 includes the features of Example B1. Also the secure enclave comprises an execution enclave. In addition the method comprises before decrypting the encrypted program in the secure enclave a saving the encrypted program in unprotected storage b creating a secure enclave to serve as an installation enclave c obtaining from within the installation enclave a program key capable of decrypting the encrypted program and d sealing the program key in a way that ties the sealed program key to the execution enclave. Example B6 may also include the features of any one or more of Examples B2 B3 B4 and B5.

Example B7 includes the features of Example B6 and the method further comprises a using a measurement associated with the execution enclave to obtain an enclave key for the execution enclave and b using the enclave key to decrypt the program key. Also the operation of automatically generating the decrypted version of the program comprises using the decrypted program key to decrypt the encrypted program in the secure enclave. Example B7 may also include the features of any one or more of Examples B2 B3 B4 and B5.

Example B8 includes the features of Example B6. Also the operation of sealing the program key in a way that ties the sealed program key to the execution enclave is performed by a protected application provisioner executing with the installation enclave. Example B8 may also include the features of any one or more of Examples B2 B3 B4 B5 and B7.

Example B9 includes the features of Example B6. Also the installation enclave and the execution enclave have matching enclave measurements and the program key is tied to the measurement of the installation enclave. Example B9 may also include the features of any one or more of Examples B2 B3 B4 B5 B7 and B8.

Example B10 includes the features of Example B6. Also the installation enclave and the execution enclave have different enclave measurements and the program key is tied to a signing key for the execution enclave. Example B10 may also include the features of any one or more of Examples B2 B3 B4 B5 B7 and B8.

Example B11 includes the features of Example B1. Also the operation of decrypting the encrypted program comprises using a key for the encrypted program to decrypt the encrypted program. In addition the method comprises before using the key to decrypt the encrypted program a sending authentication data to a licensing authority to prove that the processing device is authorized to use the program and b obtaining the key only after sending the authentication data to the licensing authority. Example B11 may also include the features of any one or more of Examples B2 B3 B4 B5 B6 B7 B8 B9 and B10.

Example B12 includes the features of Example B11. In addition the method comprises a saving an encrypted version of the key in the processing device and b automatically decrypting the encrypted version of the key in the secure enclave. Example B12 may also include the features of any one or more of Examples B2 B3 B4 B5 B6 B7 B8 89 and B10.

Example B13 includes the features of Example B12. Also the operation of automatically decrypting the encrypted version of the key in the secure enclave is performed in response to the request to execute the encrypted program. Example B13 may also include the features of any one or more of Examples B2 B3 B4 B5 B6 B7 B8 B9 and B10.

Example C is at least one machine accessible medium comprising computer instructions for protecting software from unauthorized copying. The computer instructions in response to being executed on a data processing system enable the data processing system to perform a method according to any of Examples B1 through B13.

Example D is a data processing system with features for protecting software from unauthorized copying. The data processing system comprises a processing element at least one machine accessible medium responsive to the processing element and computer instructions stored at least partially in the at least one machine accessible medium. The computer instructions in response to being executed enable the data processing system to perform a method according to any of Examples B1 through B13.

Example E is a data processing system with features for protecting software from unauthorized copying. The data processing system comprises means for performing a method according to any of Examples B1 through B13.

Example F1 is at least one machine accessible medium comprising computer instructions fir protecting software from unauthorized copying. The computer instructions in response to being executed on a data processing system enable the data processing system to pectoral operations comprising a creating a secure enclave in the data processing system and b in response to a request to execute an encrypted program in the data processing system performing operations comprising i automatically generating a decrypted version of the program in the secure enclave by decrypting the encrypted program in the secure enclave and ii after automatically generating the decrypted version of the program in the secure enclave automatically executing the decrypted version of the program in the secure enclave.

Example F2 includes the features of Example F1. Also the secure enclave comprises protected storage that cannot be accessed from outside of the secure enclave. Also the operation of automatically generating the decrypted version of the program in the secure enclave comprises storing the decrypted version of the program in the protected storage.

Example F3 includes the features of Example F1. Also the operation of automatically generating the decrypted version of the program in the secure enclave comprises using a key that is tied to the secure enclave to decrypt the encrypted program in the secure enclave. Example F3 may also include the features of Example F2.

Example F4 includes the features of Example F1. Also the operation of creating the secure enclave comprises including virtualization software in the secure enclave. In addition the operations further comprise using the virtualization software to create a virtual runtime environment VRE in the secure enclave. The decrypted version of the program is executed in the secure enclave by an interpreter for the VRE. Example F4 may also include the features of any one or more of Examples F2 and F3.

Example F5 includes the features of Example F1. Also the secure enclave comprises an execution enclave. In addition the operations comprise before decrypting the encrypted program in the secure enclave a saving the encrypted program in unprotected storage b creating a secure enclave to serve as an installation enclave to obtaining from within the installation enclave a program key capable of decrypting the encrypted program and d sealing the program key in a way that ties the sealed program key to the execution enclave. Example F5 may also include the features of any one or more of Examples F2 F3 and F4.

Example F6 includes the features of Example F1. In addition the operations comprise a using a measurement associated with the execution enclave to obtain an enclave key for the execution enclave and b using the enclave key to decrypt the program key. Also the operation of automatically generating the decrypted version of the program comprises using the decrypted program key to decrypt the encrypted program in the secure enclave. Example F6 may also include the features of any one or more of Examples F2 F3 F4 and F5.

Example F7 includes the features of Example F1. Also the installation enclave and the execution enclave have matching enclave measurements and the program key is tied to the measurement of the installation enclave. Example F7 may also include the features of any one or more of Examples F2 F3 F4 F5 and F6.

Example F8 includes the features of Example F1. Also the installation enclave and the execution enclave have different enclave measurements and the program key is tied to a signing key for the execution enclave. Example F8 may also include the features of any one or more of Examples F2 F3 F4 F5 and F6.

Example F9 includes the features of Example F1. In addition the operations comprise a saving an encrypted version of the key in the processing device and b automatically decrypting the encrypted version of the key in the secure enclave. Example F9 may also include the features of any one or more of Examples F2 through F8.

