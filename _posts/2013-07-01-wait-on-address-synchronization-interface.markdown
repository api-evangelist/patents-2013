---

title: Wait on address synchronization interface
abstract: In a first thread of a process a determination is made that a current value at a target address is not a desired value. In response to this determination, a first application programming interface (API) is invoked to indicate that the first thread is to sleep and be woken up when a second thread modifies the value at the target address. When a second thread modifies the value at the target address, the second thread invokes a second API to indicate that the value at the target address has been modified. In response to the second API being invoked, the first thread is woken up.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08782674&OS=08782674&RS=08782674
owner: Microsoft Corporation
number: 08782674
owner_city: Redmond
owner_country: US
publication_date: 20130701
---
This application is a continuation of U.S. patent application Ser. No. 12 958 721 filed Dec. 2 2010 entitled Wait On Address Synchronization Interface the entire disclosure of which is hereby incorporated by reference herein in its entirety.

Computer software applications are oftentimes run as processes that include multiple different threads with each thread performing particular tasks or carrying out particular functionality of the application. These multiple threads are typically scheduled to run at different times on a processor. A thread is put to sleep when it is not scheduled to run and then woken up when it is scheduled to run. Although running programs with different threads can have performance improvements it is not without its problems. One such problem is that situations can arise where a thread is waiting for a particular variable to have a particular value and does not proceed until that particular variable has that particular value. This can result in the thread being repeatedly woken up to run only to have the thread be put back to sleep because that particular variable does not yet have that particular value. Such results can lead to inefficient scheduling of threads and reducing the performance of the computer running the application.

This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used to limit the scope of the claimed subject matter.

In accordance with one or more aspects a first application programming interface is exposed that when invoked by a first thread of a process receives from the first thread both a target address and a current value observed by the first thread at the target address. A record of both the first thread and the target address is maintained allowing the first thread to be identified if a value at the target address is subsequently modified. Additionally the first thread is put to sleep in response to the first application programming interface being invoked.

In accordance with one or more aspects in a first thread of a process a determination is made that a current value at a target address is not a desired value. In response to the current value at the target address not being the desired value a first application programming interface is invoked to indicate that the first thread is to sleep and be woken up when a second thread modifies the value at the target address. Invoking the first application programming interface includes identifying both the target address and the current value as parameters of the first application programming interface.

A wait on address synchronization interface is discussed herein. A wait synchronization module exposes two application programming interfaces APIs to processes running on a computing device a Wait On Address API and a Wake Address API. The Wait On Address API is invoked by a thread of a process the thread identifying both a target address and a value observed by the thread at the target address. The Wait On Address API allows the thread to indicate that it is relinquishing control of the processor e.g. is going to sleep until the value at the target address changes. The wait synchronization module verifies that the target address still has the value identified by the thread. If the target address no longer has the value identified by the thread then the thread is not put to sleep and an indication is returned to the thread that the value at the target address has changed. However if the target address still has the value identified by the thread then the thread is put to sleep. The wait synchronization module maintains a record of the thread to indicate that the thread is waiting on the value at the target address to change. This record includes an indication of both the thread and the target address which is the address on which the thread is waiting .

When a thread modifies the value at the target address this modifying thread invokes the Wake Address API specifying the address that was modified. The wait synchronization module checks its record to determine if any threads are waiting on that target address and if one or more threads are waiting on that target address then the wait synchronization module wakes up at least one of those one or more threads.

Putting threads to sleep and waking up threads are discussed herein. Although the concepts of putting threads to sleep and waking up threads are well known to those skilled in the art a brief discussion of putting threads to sleep and waking up threads is included here for the convenience of the reader. Generally an operating system includes a module or component such as a thread scheduling module that schedules different threads of a process for execution by a processor or processor core at different times. Typically the thread is scheduled for an amount of time e.g. referred to as a time slice during which it can execute. After that amount of time elapses the thread scheduling module schedules another thread to execute. When a thread is put to sleep the thread scheduling module does not schedule the thread for execution and the thread does not execute while the thread is sleeping. When the thread is woken up the thread scheduling module resumes scheduling the thread for execution and the thread executes.

Computing device includes hardware an operating system that includes a wait synchronization module and one or more x processes . . . x . Processes can each include one or more threads and different processes can include different numbers of threads. For example process is illustrated as including one or more m threads . . . m and process x is illustrated as including one or more n threads . . . n .

Hardware includes various hardware components of a computing device. For example hardware can include one or more processors memory components e.g. random access memory RAM read only memory ROM etc. input components such as keyboards or motion sensors output components such as speakers or display screens and so forth. Hardware supports execution of operating system which is typically implemented in software and or firmware.

Operating system manages the execution of applications on computing device which are referred to as processes . Operating system can be any of a variety of different operating systems. Operating system includes a wait synchronization module that implements the wait on address synchronization interface discussed herein exposing the wait on address synchronization interface to the various processes . Although wait synchronization module is illustrated as being implemented in operating system alternatively wait synchronization module can be implemented in hardware .

Although system is discussed with reference to threads and it is to be appreciated that various other threads can wait optionally concurrently with thread and or thread on the value for the same or different memory locations to be modified and that various other threads can change the value at those particular memory locations. It should be noted that a developer of the process or processes including threads and is expected to take care to avoid a deadlock situation in which two threads are each waiting on the other to change a value of a memory location.

Wait synchronization module includes a Wait On Address API and a Wake Address API that module exposes to threads and . Wait synchronization module also includes a wait control module a wake control module and a thread identification store . Wait synchronization module synchronizes different threads e.g. threads and allowing one thread that is waiting for a value at a memory location to be changed to go to sleep and subsequently be woken up when the value at that memory location is changed by another thread.

When executing a thread or can desire that a value stored at a particular memory location typically identified by the address of that memory location has a particular value or range of values. The thread or reads the value at that particular memory location and checks whether the value stored at that particular memory location has the desired value or is within the desired range of values and if so then proceeds with its operation. However if the thread or determines that the value stored at that particular memory is not the desired value or is not within the desired range of values then the thread or notifies wait synchronization module that the thread or desires to wait on that memory location and be notified when the value at that memory location is changed or modified. A thread waiting to be notified by wait synchronization module when the value at a memory location changes or is modified is also referred to as a waiting thread.

The waiting thread notifies wait synchronization module that it desires to wait on that memory location by invoking Wait On Address API . As part of invoking Wait On Address API the waiting thread identifies as one or more parameters of Wait On Address API both a target address and a current value. The actual target address and or current value can be included as parameters of Wait On Address API or alternatively pointers or references to the target address and or current value can be included as parameters of Wait On Address API . The target address is the address of the memory location that the waiting thread is waiting on and the current value is the value observed by the waiting thread as being stored at the target address which is the value read by the thread from the target address .

Wait On Address API provides the received parameters to wait control module . In response to Wait On Address API being invoked wait control module stores a record of the waiting thread in thread identification store . The record of the waiting thread includes both an identification of the waiting thread and an indication of the target address. The identification of the waiting thread is received from the waiting thread when the Wait On Address API is invoked. Additional information regarding the waiting thread or parameters received when Wait On Address API was invoked can also be included in the record.

Thread identification store can be maintained in a variety of different manners. In one or more embodiments thread identification store is implemented as a hash table and corresponding hash buckets. Wait control module generates a hash value for the waiting thread by applying a hash function to the target address. A variety of different conventional hash functions can be used by wait control module . The record of the waiting thread is stored in a hash bucket corresponding to the hash value along with any other waiting threads that are waiting on a target address that hashes by applying the hash function to that same hash value. A hash bucket refers to any of a variety of different data structures that store the records corresponding to the hash value such as a linked list of the records.

Alternatively thread identification store can be maintained in different manners using a variety of different data structures. For example thread identification store can be an ordered list of records each record including an identification of both the waiting thread and the target address. The list can be ordered by target addresses e.g. from lowest address to highest address from highest address to lowest address and so forth by waiting thread identifiers and so forth.

Wait control module also reads the current value at the target address and determines whether the current value at the target address is the same as the current value observed by the waiting thread provided by the waiting thread when invoking the Wait On Address API . If the current value at the target address is not the same as the current value observed by the waiting thread then wait control module assumes that another thread has changed the value at the target address after the waiting thread last accessed the memory location. Accordingly the current value at the target address may be the value or within the range of values desired by the waiting thread. Thus wait control module removes the record of the waiting thread from thread identification store and returns an indication to the waiting thread to recheck the value at the target address. This indication for the waiting thread to recheck the thread can be provided in different manners such as a result code returned to the waiting thread by Wait On Address API e.g. returning a result code of false or fail .

In one or more embodiments wait control module checks whether the current value at the target address is the same as the current value observed by the waiting thread and if not removes the record of the waiting thread from thread identification store as an atomic operation. Performing these as an atomic operation ensures that another thread cannot change or modify the value at the target address between the time when wait control module checks whether the current value at the target address is the same as the current value observed by the waiting thread and the time when wait control module removes the record of the waiting thread to thread identification store .

It should be noted that by checking whether the current value at the target address is the same as the current value observed by the waiting thread wait control module resolves potential race conditions without requiring the waiting thread to obtain any type of lock on the memory location. Wait control module returns an indication to recheck the thread if the current value at the target address is not the same as the current value observed by the waiting thread so if another application has modified the value at the memory location since the waiting thread checked the value the waiting thread is not waiting for a modification to the memory location that has already occurred.

However if the current value at the target address is the same as the current value observed by the waiting thread then wait control module keeps the record of the waiting thread in thread identification store . In addition if the current value at the target address is the same as the current value observed by the waiting thread then the waiting thread is put to sleep. In one or more embodiments wait control module sends a request or message to a thread scheduling module of the operating system e.g. operating system of to put the waiting thread to sleep. Alternatively after invoking the Wait On Address API the waiting thread itself can send a request or message to the thread scheduling module to put the waiting thread to sleep. The waiting thread can be put to sleep as soon as the waiting thread requests that it be put to sleep or as soon as wait control module adds the record of the waiting thread to thread identification store or alternatively the waiting thread can be put to sleep a particular amount of time e.g. a particular number of milliseconds after the waiting thread requests that it be put to sleep or after wait control module adds the record of the waiting thread to thread identification store . Waiting this particular amount of time allows for example the waiting thread to not be put to sleep until after wait control module has checked whether the current value at the target address is the same as the current value observed by the waiting thread.

In alternate embodiments rather than adding the record of the waiting thread to thread identification store and then checking whether the target address is the same as the current value observed by the waiting thread wait control module can check whether the target address is the same as the current value observed by the waiting thread before adding the record of the waiting thread to thread identification store . If the current value at the target address is the same as the current value observed by the waiting thread then the record of the waiting thread is added to thread identification store otherwise the record is not added to thread identification store and an indication is returned to the waiting thread to recheck the value at the target address. In such alternate embodiments wait control module can check whether the current value at the target address is the same as the current value observed by the waiting thread and add the record of the waiting thread to thread identification store as an atomic operation.

In the discussions above Wait On Address API is discussed as having both a target address and a current value as parameters. In other embodiments in addition to the current value or alternatively in place of the current value the waiting thread can provide a desired value parameter. The waiting thread indicates via the desired value parameter thread the value or range of values that the waiting thread desires to be at the target address. In such embodiments wait control module checks if the current value at the target address satisfies e.g. is the same as or is within the range of values the value or range of values that is desired by the waiting thread. If the current value at the target address does satisfy the value or range of values that is desired by the waiting thread then wait control module returns an indication to the waiting thread to recheck the value at the target address. However if the current value at the target address does not satisfy the value or range of values that is desired by the waiting thread then wait control module keeps the record of the waiting thread in thread identification store . This record includes an indication of the value or range of values that is desired by the waiting thread.

When thread modifies the value at a target address on which a thread is waiting or may be waiting thread invokes Wake Address API . A thread invoking Wake Address API is also referred to as a waking thread. Thread does not typically have access to thread identification store and thus is not aware of whether a thread is actually waiting on a particular target address. However the developer of threads and are typically aware of different addresses that a thread may wait on and accordingly designs threads and to invoke Wake Address API when the value at such an address is modified regardless of whether a thread is actually waiting on that address when Wake Address API is invoked .

As part of invoking Wake Address API the waking thread identifies as one or more parameters of Wake Address API an address. The actual address value can be included as a parameter of Wake Address API or alternatively a pointer or reference to the address can be included as a parameter of Wake Address API . The address is the address of the memory location that the waking thread modified.

Wake Address API provides the received one or more parameters to wake control module . In response to Wake Address API being invoked wake control module checks thread identification store to determine whether any threads are waiting on the address that was modified the address identified as a parameter of the Wake Address API . The manner in which wake control module checks thread identification store to determine whether any threads are waiting on the address that was modified can vary based on the manner in which thread identification store is implemented.

In one or more embodiments in which thread identification store is implemented as a hash table and corresponding hash buckets as discussed above wake control module generates a hash value by applying a hash function to the address that was modified. Wake control module uses the same hash function or a hash function that provides the same results as the hash function that was used by wait control module . Wake control module checks the hash bucket corresponding to the hash value to determine whether any records of waiting threads correspond to that hash value. If no records of waiting threads correspond to that hash value then no threads are currently waiting on the address that was modified and wake control module need wake up no threads.

However if one or more records of waiting threads correspond to that hash value then wake control module checks those one or more records to determine whether any of the waiting threads are waiting on the address that was modified. As multiple different addresses can and typically do correspond to the same hash value wake control module checks whether any of the waiting threads are waiting on the specific address that was modified. If one or more threads are waiting on the address that was modified then at least one of those threads is selected by wake control module and woken up.

In one or more embodiments wake control module sends a request or message to a thread scheduling module of the operating system e.g. operating system of to wake up a particular thread that is sleeping. An identification of the waiting thread to be woken up can be included in the record for that waiting thread that is maintained in thread identification store . The thread scheduling module proceeds to wake up that particular thread which can then recheck the value at the address for which the thread was waiting. When waking up a thread wake control module also removes from thread identification store the record of the waiting thread that module is waking up.

In situations in which multiple threads are waiting on the address that was modified wake control module can wake up all of the multiple threads waiting on the address or alternatively a selected one or more of the multiple threads. Whether wake control module is to wake up all of the multiple threads waiting on the address or a selected one or more of the multiple threads can be identified for example by the waking thread. For example different Wake Address APIs can be exposed such as a Wake All API and a Wake Single API. If the Wake All API is invoked by the waking thread then wake control module wakes up all of the multiple threads waiting on the address. If the Wake Single API is invoked by the waking thread then wake control module wakes up one of the multiple threads waiting on the address. Alternatively whether wake control module is to wake up all of the multiple threads waiting on the address or a selected one or more of the multiple threads can be identified in other manners such as being pre configured in wake control module being identified by the waking thread as a parameter of the Wake Address API and so forth.

If wake control module is to wake up fewer than all of the multiple threads waiting on the address then the particular one or more threads that wake control module is to wake up can be identified in a variety of different manners. For example records of waiting threads can have an associated timestamp e.g. provided by wait control module in thread identification store indicating when the thread began waiting e.g. when the thread invoked Wait On Address API or when the record was added to thread identification store or can be stored in thread identification store with an ordering indicating which threads began waiting before which other threads e.g. a list of records in which the thread identified by an earlier record in the list began waiting before a thread identified by a later record in the list . In such situations the thread that has been waiting the longest is the thread selected by wake control module as the thread to wake up.

As discussed above in one or more embodiments in addition to the current value or alternatively in place of the current value the waiting thread can provide a desired value parameter. In such embodiments in addition to determining if one or more threads are waiting on the address that was modified before waking a thread wake control module also determines whether the current value at the address has the desired value or is within the range of values. An indication of the desired value or range of values is included in the record stored in thread identification store and wake control module can readily determine if the current value at the address has the desired value or is within the range of values. If the current value at the address has the desired value or is within the range of values then wake control module wakes up the thread. However if the current value at the address does not have the desired value or is not within the range of values then wake control module does not wake up the thread.

In one or more embodiments Wait On Address API is exposed using the format WaitOnAddress and includes at least a target address parameter that is the target address for which a thread is waiting as discussed above. The Wait On Address API can also include a value parameter that is the current value that is observed by the waiting thread as being stored at the target address as discussed above. Additionally the Wait On Address API can include one or more of the following parameters size timeout mask desired value and reason. One or more of these parameters can be provided by the waiting thread when invoking the Wait On Address API . When values for one or more of these parameters are provided by the waiting thread the one or more values provided by the waiting thread are included in the record for the waiting thread that is maintained in thread identification store .

The size parameter is used to indicate a size of the value e.g. in bits or bytes of the value stored at the target address for which the thread is waiting. Using the size parameter allows wait control module and wake control module to know the size of the value that is stored at the target address. Alternatively the size of the value can be inherent in the Wait On Address API. For example one or more size specific Wait On Address APIs can be used such as a WaitOnAddressByte for values that are 8 bits in size WaitOnAddressWord for values that are 16 bits in size and so forth.

The timeout parameter is used to indicate an amount of time e.g. in milliseconds or seconds after which the thread is to be woken up even if the target address on which the thread is waiting has not been modified. Wake control module monitors the timeout values and wakes up a waiting thread if a record of the thread is still included in thread identification store after the amount of time e.g. based on when the Wait On Address API was invoked or the record was stored in thread identification store indicated in the timeout parameter has lapsed.

The mask parameter is used to indicate a portion of the value stored at the target address that is of interest to the waiting thread. The portion of the value can be identified in different manners such as a mask value that identifies particular bits of the value stored at the target address that are of interest to the waiting thread. If the target address is modified wake control module wakes up the waiting thread only if the portion of the value stored at the target address that is of interest to the waiting thread has been modified. Wake control module can compare the current value at the target address to the value stored in the record maintained in thread identification store for the waiting thread and readily determine if the portion of the value that is of interest to the waiting thread has been modified. For example the waiting thread can indicate that it is interested in the first third and sixth bits of the value at the target address. Accordingly if the current value at the target address has different values for the first third and sixth bits than the value included in the record maintained in thread identification store then the portion of the value stored at the target address that is of interest to the waiting thread has been modified. However if the current value at the target address has the same values for the first third and sixth bits as the value included in the record maintained in thread identification store then the portion of the value stored at the target address that is of interest to the waiting thread has not been modified.

The desired value parameter is used for the waiting thread to indicate that the current value at the target address is to have a particular value or be within a particular range of values in order for wake control module to wake up the thread as discussed above.

The reason parameter is used to indicate one or more reasons why the waiting thread is waiting on the target address. The reason parameter is similar to the desired value parameter but differs in that the reason parameter specifies the reason that the thread is waiting rather than a particular value that the target address is to have or a particular range of values that the target address is to be within in order to be woken up. For example the waiting thread can indicate that it is waiting on the target address because the value at the target address is not a zero value. When using the reasons parameter before waking a thread wake control module determines whether the reason specified by the waiting thread still exists. An indication of the reason is included in the record stored in thread identification store by wait control module and wake control module can readily determine if the reason still exists e.g. based on the current value at the target address . If the reason that the thread is waiting no longer exists then wake control module wakes up the thread. However if the reason that the thread is waiting still exists then wake control module does not wake up the thread.

In one or more embodiments Wake Address API is exposed using the format WakeAddress and includes at least an address parameter that is the address that the waking thread modified as discussed above. The Wake Address API can be implemented for example as a WakeAll API indicating that all threads waiting on the address that the waking thread modified are to be woken up or as a WakeSingle API indicating that a single thread waiting on the address that the waking thread modified is to be woken up.

It should be noted that in embodiments in which wait synchronization module is implemented at least in part in hardware wake control module need not wait until Wake Address API is invoked to wake up one or more threads. Rather the hardware itself can detect when a particular memory location that one or more threads are waiting on has been modified and wake up at least one of the waiting threads in response to detecting modification to that particular memory location. In such embodiments Wake Address API need not be exposed by wait synchronization module and or may be exposed but not result in any action performed by wait synchronization module when invoked.

In process the first thread checks whether a current value at a target address is a desired value act . This desired value can be a single value or a range of values as discussed above.

Process proceeds based on whether the current value is a desired value act . If the current value at the target address is a desired value then operation of the thread continues act . This continuing of operation refers to the thread continuing to execute whatever instructions are included in the thread after verifying that the current value at the target address is a desired value.

However if the current value is not a desired value then the first thread invokes a Wait On Address API act . The first thread provides as parameters of the Wait On Address API an indication of both the target address which is the address of the memory location that the first thread is waiting on and the current value which is the value observed by the waiting thread as being stored at the target address . Other parameters can also be provided in addition to or in place of these parameters as discussed above.

The first thread is then put to sleep act . The first thread can put itself to sleep or a module or component of the wait synchronization module can put the first thread to sleep as discussed above. Alternatively as discussed above if the value at the target address was changed after the check was made in act the first thread can be kept awake and return to act to recheck whether the current value at the target address is a desired value.

The second thread modifies the value at the target address act . This modification can be performed at different times and typically is performed after the first thread is put to sleep in act .

After modifying the value at the target address the second thread invokes a Wake Address API act . The second thread provides as a parameter of the Wake Address API an indication of the address that the second thread modified the target address in act .

In response to the Wake Address API being invoked the first thread is woken up act . Upon waking up the first thread returns to act to recheck whether a current value at a target address is a desired value. Process then proceeds based on whether the first thread determines that the current value at the target address is a desired value as discussed above.

A target address and current value are received from a first thread invoking the Wait On Address API act . The target address and current value are received as parameters of the Wait On Address API as discussed above. Other parameters of the Wait On Address API can optionally be received as discussed above.

A record of the first thread and the target address are stored indicating that the first thread is waiting on the target address act . This record can be stored in a data structure corresponding to a hash value generated from applying a hash value to the target address as discussed above.

A check is made as to whether the value at the target address has changed act . This check can be made for example by reading a current value at the target address and checking whether that value is the same as the current value received in act as discussed above.

If the target address has changed then the record of the first thread is removed from the stored records and the first thread is kept awake act . The first thread is not put to sleep and an indication is returned to the first thread to recheck the value at the target address act . This rechecking is a checking of whether the current value at the target address is a desired value as discussed above.

Returning to act if the value at the target address has not changed then the first thread is put to sleep act .

Eventually an address from a second thread is received as a parameter of the Wake Address API invoked by the second thread act . One or more threads if any are identified from the stored records that have a target address that matches the address received in act . A thread in a stored record has a target address that matches the received address if for example the target address in the stored record is the same as the received address.

At least one of the one or more threads identified in act are woken up act . All threads identified in act can be woken up or alternatively only select threads can be woken up as discussed above. Additionally the record of the at least one thread that is woken up is removed from the stored records act .

Computing device includes one or more processors or processing units one or more computer readable media which can include one or more memory and or storage components one or more input output I O devices and a bus that allows the various components and devices to communicate with one another. Computer readable media and or one or more I O devices can be included as part of or alternatively may be coupled to computing device . Bus represents one or more of several types of bus structures including a memory bus or memory controller a peripheral bus an accelerated graphics port a processor or local bus and so forth using a variety of different bus architectures. Bus can include wired and or wireless buses.

Memory storage component represents one or more computer storage media. Component can include volatile media such as random access memory RAM and or nonvolatile media such as read only memory ROM Flash memory optical disks magnetic disks and so forth . Component can include fixed media e.g. RAM ROM a fixed hard drive etc. as well as removable media e.g. a Flash memory drive a removable hard drive an optical disk and so forth .

The techniques discussed herein can be implemented in software with instructions being executed by one or more processing units . It is to be appreciated that different instructions can be stored in different components of computing device such as in a processing unit in various cache memories of a processing unit in other cache memories of device not shown on other computer readable media and so forth. Additionally it is to be appreciated that the location where instructions are stored in computing device can change over time.

One or more input output devices allow a user to enter commands and information to computing device and also allows information to be presented to the user and or other components or devices. Examples of input devices include a keyboard a cursor control device e.g. a mouse a microphone a scanner and so forth. Examples of output devices include a display device e.g. a monitor or projector speakers a printer a network card and so forth.

Various techniques may be described herein in the general context of software or program modules. Generally software includes routines programs objects components data structures and so forth that perform particular tasks or implement particular abstract data types. An implementation of these modules and techniques may be stored on or transmitted across some form of computer readable media. Computer readable media can be any available medium or media that can be accessed by a computing device. By way of example and not limitation computer readable media may comprise computer storage media and communications media. 

 Computer storage media include volatile and non volatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Computer storage media include but are not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can be accessed by a computer.

 Communication media typically embody computer readable instructions data structures program modules or other data in a modulated data signal such as carrier wave or other transport mechanism. Communication media also include any information delivery media. The term modulated data signal means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example and not limitation communication media include wired media such as a wired network or direct wired connection and wireless media such as acoustic RF infrared and other wireless media. Combinations of any of the above are also included within the scope of computer readable media.

Generally any of the functions or techniques described herein can be implemented using software firmware hardware e.g. fixed logic circuitry manual processing or a combination of these implementations. The terms module and component as used herein generally represent software firmware hardware or combinations thereof. In the case of a software implementation the module or component represents program code that performs specified tasks when executed on a processor e.g. CPU or CPUs . The program code can be stored in one or more computer readable memory devices further description of which may be found with reference to . The features of the wait on address synchronization interface described herein are platform independent meaning that the wait on address synchronization interface can be implemented on a variety of commercial computing platforms having a variety of processors.

Although the subject matter has been described in language specific to structural features and or methodological acts it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the specific features or acts described above. Rather the specific features and acts described above are disclosed as example forms of implementing the claims.

