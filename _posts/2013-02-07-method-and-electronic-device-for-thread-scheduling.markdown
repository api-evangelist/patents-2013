---

title: Method and electronic device for thread scheduling
abstract: A method for performing thread scheduling in an electronic device having a hardware processor configured for executing an operating system is provided. The operating system includes a thread scheduler and a queue manager. The method includes the following steps. In response to one of a plurality of predefined conditions is met, enable a virtual manager executed by the hardware processor. Receive a request by the thread scheduler for scheduling a thread to be executed. Mask the scheduler by the virtual manager from accessing a first queue including a plurality of first threads in a runnable state. Direct the scheduler to a first virtual queue including a first portion of the plurality of first threads in the first queue for selecting the thread to be executed. The first portion of the first threads associated with at least one application currently running. Schedule execution of the selected thread by the hardware processor.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09274832&OS=09274832&RS=09274832
owner: HTC Corporation
number: 09274832
owner_city: Taoyuan
owner_country: TW
publication_date: 20130207
---
The present invention relates to a method and a system for thread scheduling. More particularly the present invention relates to a method and a system for user centric thread scheduling.

In a modern operating system a run queue is maintained in which one thread is chosen as the next scheduled candidate for execution. Concerning fairness each thread is assigned a time slice which defines how long at most the thread is able to run at its scheduling interval. Priority is set for each thread as well to determine its execution order. The scheduler of the operating system inserts all runnable threads to a run queue in prioritized order and picks up the thread with the highest priority as the next scheduled candidate to be executed by the processor.

User experience is a very important aspect of consumer electronic devices such as smart phones tablet computers and personal computers. However the computing resources of a consumer electronic device are limited. When the processor of such a consumer electronic device is executing too many processes or threads at the same time the user often feels obvious lag.

Accordingly the present invention is directed to a method and a system for thread scheduling which can concentrate the schedule of the processor on the foreground process and the related processes of the operating system to provide friendly and smooth user experience. The method and the system provided by the present invention are simple and easy to implement.

According to an embodiment of the present invention a method for performing thread scheduling in an electronic device having a hardware processor configured for executing an operating system is provided. The operating system includes a thread scheduler and a queue manager. The method includes the following steps. Determine whether at least one of a plurality of predefined conditions is met. In response to one of the plurality of predefined conditions is met enable a virtual manager executed by the hardware processor. Receive a request by the thread scheduler for scheduling a thread to be executed. Mask the scheduler by the virtual manager from accessing a first queue including a plurality of first threads in a runnable state. Direct the scheduler to a first virtual queue including a first portion of the plurality of first threads in the first queue for selecting the thread to be executed. The first portion of the first threads associated with at least one application currently running. Schedule execution of the selected thread by the hardware processor.

According to another embodiment of the present invention a thread scheduling system for use in an electronic device is provided. The thread scheduling system includes a system queue a thread scheduler a queue manager and a virtual manager. The system queue includes a first queue for maintaining a plurality of first threads in a first state and a second queue for maintaining a plurality of second threads in a second state. The thread scheduler is configured to receive request for scheduling execution of at least one of the first threads and updating status of the second threads. The queue manager is configured to receive request for updating threads in the first queue and the second queue. The virtual manager is configured to intercept the request received by the thread scheduler and the queue manager for accessing the first queue update threads in the first queue and the second queue and is configured to map the first threads in the first queue into a first virtual queue and a second virtual queue according to a white list associated with at least one application currently running.

According to another embodiment of the present invention a method for performing thread scheduling in an electronic device having a hardware processor configured for executing an operating system is provided. The operating system includes a run queue and a sleep queue. The method includes the following steps. Generate a white list including processes associated with applications currently running by the hardware processor. Schedule execution of threads in the run queue according to the white list by the hardware processor. Update threads in the sleep queue into the run queue according to the white list by the hardware processor.

Reference will now be made in detail to the present embodiments of the invention examples of which are illustrated in the accompanying drawings. Wherever possible the same reference numbers are used in the drawings and the description to refer to the same or like parts.

There may be one or more processes in the operating system . Each process may include one or more threads. The thread list records all of the threads in the operating system and the state of each thread. The state of a thread may be running runnable sleeping or blocked. The running state means the thread is currently executed by the processor of the electronic device. The runnable state means the thread is ready to be executed by the processor but is not yet running. The blocked state means the thread is waiting for a preset event to occur such as an interrupt from a hardware component of the electronic device or the release of an exclusive object previously acquired by another thread. The system run queue records all of the runnable threads while the system sleep queue records all of the blocked threads. The system run queue records the threads in prioritized order which means the threads in the system run queue are sorted in order of priority. The first thread of the system run queue has the highest priority. On the other hand the threads in the system sleep queue are sorted according to the lengths of sleep time of the threads. The first thread of the system sleep queue has the shortest sleep time.

The scheduler arranges thread execution of the processor of the electronic device. In other words the scheduler determines the execution order of the threads in the operating system . The QM deals with all requests which intend to insert or remove threads to or from the system run queue and the system sleep queue and ensures the requests are properly serialized.

The VM of the invention is disposed as a middle layer between the scheduler the QM the system run queue and the system sleep queue . The VM interacts with the thread scheduler and the QM in place of the system run queue and the system sleep queue . The VM may direct the scheduling of the scheduler to threads with higher importance for example threads associated with applications user is currently concentrated on so that such processes can be prioritized for execution. The VM may refer to the thread list to inquire the current states of the threads. Furthermore the VM supports the capability of being installed or uninstalled at runtime transparent to the operating system which means the VM may be enabled or disabled flexibly.

When the VM is disabled the scheduler and the QM are unaffected by the VM and the operating system behaves just like a conventional multi tasking operating system. In this case the scheduler moves the threads which should awake at this moment from the system sleep queue to the system run queue in prioritized order and then the scheduler selects the first thread in the system run queue as the next thread to be executed by the processor. The selected thread can run for the minimum of its remaining time quantum and or the sleep time of the first thread in the system sleep queue .

When the VM is enabled the VM classifies the threads in the system run queue into two portions and manages the scheduling of thread execution by the processor with reference to the user activities for example foreground application currently running. The processing details of the VM are discussed below.

In one embodiment of the invention the control unit may poll the switch module periodically to detect the on off state of the switch module . When the switch module turns on control unit is enabled and starts executing the method for thread scheduling whose flow is shown in to . When the switch module turns off the control unit is disabled and stops executing the method for thread scheduling. In another embodiment of the invention the switch module may signal the control unit to be enabled in response to the switch module is in on state which means at least one of the predetermined conditions is satisfied. Similarly the switch module may signal the control unit to be disabled when the conditions are released.

When the control unit is enabled the control unit maps threads in the system run queue into the virtual run queue or the virtual block queue according to the white list . When the parent or associated process of a thread in the system run queue is in the white list the thread is mapped into the virtual run queue . Otherwise the thread is mapped into the virtual block queue . The white list records processes that are important to the user and or the operating system . In one embodiment of the invention the white list may include all threads associated with foreground application services crucial to the operating system and other important processes that cannot be interrupted. Therefore threads in the virtual run queue are those relatively important from user s point of view while threads in the virtual block queue are comparatively less important and thus can be delayed for processing.

The white list may include a static white list and a dynamic white list. The static white list may include one or more predetermined processes that are fundamental to the operating system and should not be blocked in any case such as kernel file system and hardware device drivers of the operating system . The static white list is fixed which means processes listed in the static white list would not be changed or removed. The dynamic white list includes other processes that are currently running for example foreground process of the operating system . The foreground process is the process currently displayed on the screen of the electronic device. As a result the foreground process should have higher priority than other running processes. Moreover the foreground process is the application which is currently used by the user and is currently interacting with the user. Processes of background applications that cannot be terminated are added in the dynamic white list as well for example audio media playback such as music player radio etc. When a requested service is associated with at least one process in the dynamic white list the process that provides the service is dynamically added into the white list . The white list is maintained by the control unit and is updated upon application switch.

For example when the user is browsing a web site with a browser the browser is the foreground process. When the user clicks a plug in of the browser to view a streaming video the plug in launches a process to download and play the video and launches another process to play the audio part of the streaming video. Since the browser requests the service of the plug in and the plug in requests the services of the download process and the audio playback process the control unit adds the plug in process the download process and the audio playback process into the white list . Therefore following requests regarding plug in download and audio playback would be placed into virtual run queue so that they can be properly scheduled for execution.

The control unit may send a query to the operating system to know which processes are the foreground process and the background processes. This query may be performed periodically or at predetermined moments. For example the control unit may send the query every time when the control unit is enabled upon receiving request for scheduling or occurrence of other conditions. In prior system when it is time to perform thread rescheduling the scheduler would check system block queue and bring threads that have passed sleeping period to runnable state and choose threads with higher priority in system run queue for scheduling. However in the invention the control unit can intercept this intention of the scheduler and redirect the scheduler to select a candidate thread for scheduling from virtual run queue . In addition when a process is requested for service by a process in the white list at least one thread of the requested process has to be inserted by the QM into the system run queue to provide the service. When the QM is about to insert a thread into the system run queue the control unit can intercept this intention of the QM and place the thread into the virtual run queue or virtual block queue according to the white list .

In addition to the maintenance of the control unit the operating system may provide a dedicated application programming interface API for the processes to modify the dynamic white list. A process may add itself or other processes into the dynamic white list by sending a request to the dedicated API. A process may also remove itself or other processes from the dynamic white list by sending another request to the dedicated API. This dedicated API provides more flexibility and efficiency to the construction of the white list .

The control unit works by keeping the threads important to the user and the operating system in the virtual run queue and keeping irrelevant threads in the virtual block queue temporarily. The control unit concentrates the execution cycles of the processor on the threads of the virtual run queue to quicken the responses of the threads closely related to the user so the user can feel that all resources are dedicated to him or her and enjoy a smooth experience. The threads in the virtual block queue are not scheduled for execution temporarily during the activation of the virtual manager . The details are recited in the steps of the method for thread scheduling whose flow is shown in to .

Next at step enable the VM by intercepting the operations of the scheduler and the QM on the system run queue . After the installation the control unit can intercept various operations of the scheduler and the QM on the system run queue and execute the flows shown in to in response. In the flows shown in to the control unit translates the intercepted operations on the system run queue into operations on the virtual run queue and the virtual block queue . Any operations on the system sleep queue is just passed on without any interference since they do not actually affect user experience.

In step the VM generates a white list including processes associated with applications currently running on the electronic device. The white list may include processes associated with foreground application system critical services and timing critical background applications or services. Then the VM maps threads in system run queue which contains threads in runnable state into virtual run queue and virtual block queue according to the white list in step . Threads that are associated with processes in the white list are mapped to the virtual run queue while threads not in the white list are mapped into the virtual block queue .

Next at step a request is received for scheduling a thread to be executed by the thread scheduler . The request may be received upon a sleeping thread is about to awake or the execution or time quantum of a running thread is used up. In response to the request the VM masks the thread scheduler from accessing the system run queue for selecting and scheduling a thread to be executed in step . As described above normally the thread scheduler would pick up a thread from system run queue according to the priority. In this embodiment the VM would intercept the request and direct the thread scheduler to select a thread for execution from the virtual run queue as shown in step . The selected thread may be scheduled for execution by the thread scheduler in step .

Next at step redirect the scheduler to select the first thread of the virtual run queue as the next thread to execute. At step intercept a decision coming from the scheduler . The decision includes the thread selected by the scheduler .

Next at step check whether the parent process of the thread selected by the scheduler is in the white list or not. When the parent process of the thread selected by the scheduler is in the white list the flow proceeds to step to schedule the processor to execute the thread selected by the scheduler . When the parent process of the thread selected by the scheduler is not in the white list the flow proceeds to step to insert the thread selected by the scheduler into the virtual block queue in prioritized order and then triggers the selection procedure of the scheduler again to return to step .

At step when the intercepted operation is a deletion of a thread the flow proceeds to step to simply remove the thread from the virtual run queue .

Firstly at step awake the blocked thread. At step awake the threads in the virtual block queue whose parent processes are in the white list . At step remove the threads awaked at steps and from the virtual block queue . At step insert the threads awaked at steps and into the virtual run queue in prioritized order.

Firstly at step mask the interrupts of the electronic devices to prevent rescheduling and guarantee the consistency of all of the queues. At step reconstruct the system run queue by merging the threads of the virtual run queue and the virtual block queue in prioritized order. The system run queue becomes empty after the initialization procedure shown in . The scheduler and the QM access the system run queue directly when the VM is shut down. Therefore the system run queue has to be reconstructed. At step uninstall the VM by undoing the intercepting of the operations of the scheduler and the QM on the system run queue at step in . Any effects of the VM on the scheduler the QM and the operating system are all rolled back. Next at step unmask the interrupts of the electronic devices. After step the VM is completely shut down and the operating system behaves just like the VM does not exist.

In summary the present invention classifies the runnable threads in the operating system according to the relation between the runnable threads and the foreground process and adjusts the schedule of the processor to concentrate the execution cycles on the threads closely related to the foreground process. As a result the operation of the foreground process is smooth and responsive which improves user experience.

It will be apparent to those skilled in the art that various modifications and variations can be made to the structure of the present invention without departing from the scope or spirit of the invention. In view of the foregoing it is intended that the present invention cover modifications and variations of this invention provided they fall within the scope of the following claims and their equivalents.

