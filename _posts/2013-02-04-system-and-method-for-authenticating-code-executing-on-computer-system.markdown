---

title: System and method for authenticating code executing on computer system
abstract: A code authentication architecture is used to sign code by adding one or more digital signatures to it. The digital signatures identify what authority signed the code, what the code contains, what type of program the code is, or other identifying information. When the signed code is later executed on a computer system, its identity is obtained by accessing encrypted information of the code stored on disk. The architecture then determines whether the identity satisfies at least one requirement imposed on the code for some purpose. If the code has been altered from when it was signed or it fails to satisfy a requirement imposed, the code will not have a valid identity. In addition to verifying the identity of the code, the architecture also validates executing code immediately responsible for managing the code and additional executing code in a chain of hosts responsible for managing one another.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08782807&OS=08782807&RS=08782807
owner: Apple Inc.
number: 08782807
owner_city: Cupertino
owner_country: US
publication_date: 20130204
---
This application is a continuation application of U.S. patent application Ser. No. 11 620 599 filed Jan. 5 2007 now published as U.S. Publication 2008 0168553 which is incorporated herein by reference.

The subject matter of the present disclosure relates to a system and method for authenticating the identity of code executing on a computer system against various constraints.

The following table shows 6 files that are provided as computer program listing filed electronically herewith as text files which are hereby incorporated by reference in their entirety.

The identity and authenticity of programs stored and running on a computer system is a fundamental security issue for users. Essentially users want the programs they interact with and that operate on their behalf to perform as the program is advertised. Users may encounter problems when they trust a specific program but the program behaves in an unexpected way. In some situations the program may have been deliberately altered or a virus or other security issue may be present. More often than not the program simply behaves differently than the user initially expected because it does not come from a trusted source it has been altered at some point rendering it incompatible with other components or it is ineffective for whatever reason.

Current operating systems do not have consistent mechanisms for establishing and authenticating identities of programs. In Mac OS X for example many components are capable of storing paths which are used to identify programs. Such a stored path is useful for determining if the program has been relocated from where the stored path indicates. However the stored path does not bind the identity of the program does not allow the program to be legitimately relocated e.g. on non local disk media and does not address any alteration of the program after it was produced by the manufacturer.

In another example other components of Mac OS X use bundle identifiers or other fields in an Info.plist of a program and trust these identifiers to establish the identity of the program. As is known an Info.plist is an Information Property List File that is required for Mac OS X software programs packaged in the form of a bundle. The Info.plist contains key value pairs that specify information used at runtime by the operating system and the software program that contains the property list. However any benefit of identifying and authenticating the program using the bundle identifiers in the Info.plist can be easily circumvented when the Info.plist is copied and edited.

In yet another example components of Mac OS X may use a keychain layer to establish the identity of programs and to assign access privileges to resources based on the identity of programs that are visible to the user. As is known a Keychain is an encrypted container that holds Keychain items which can be passwords keys certificates text strings and the like. Keychains can be used to manage the multiple passwords keys certificates etc. that are needed in a computer system to access programs or to use secure services.

Because Keychains are secure storage containers access to their contents cannot be obtained unless the Keychain is unlocked by a password or key. Once unlocked trusted programs are allowed to access the keychain items contained in the Keychain. To allow access to trusted programs the Keychain includes an Access Control List ACL layer that allows access to Keychain items based directly on what program is calling the Keychain. The ACL layer specifies what operations can be done with Keychain items such as decrypting or authenticating and specifies what trusted programs can perform the specified operations without authorization from the user. Accordingly these trusted programs usually only need to call a Keychain Service API to store or retrieve Keychain items in an unlocked Keychain.

The Keychain layer in Mac OS X allows programs to be relocated if necessary and provides some tamper protection for the programs. However the benefits of the Keychain layer for identifying programs may be lost whenever the program is altered e.g. by software updates or the like . For example the Keychain layer uses a hash scheme to recognize a program as being trusted for access to the Keychain items. If the program has been changed by an update or the like then hash values for the updated program will not be recognized because they will not match the values in the Keychain layer. By default the Keychain Services API automatically dialogs the user in this situation. In the dialog the user is asked to recognize the updated program as being essentially the same as or different from the program when it was formerly trusted. Thus the user must explicitly allow the updated program to access the implicated Keychain from then on. If a user s system receives multiple updates to multiple programs repeated dialogs to the user are needed to grant the newly updated programs access to various Keychains. Not only does this have implications when a user s system is legitimately updated or changed but there are also security implications involved when programs on a user s system are illegitimately changed or new programs are added that have or request access to Keychains.

In addition to the issues above all these mechanisms blindly trust on disk static code. Consequently any properly timed modifications to on disk code can attack program files after checks have been made circumventing any benefits of these mechanisms. Furthermore a redirection attack can fool the operating system into believing the wrong program is actually running Finally all these mechanisms rely on a very specific definition of what constitutes a program for identity purposes. Usually a program is only an application bundle or only an executable file. Ancillary elements e.g. AppleScripts applets widgets etc. may simply not register as a program with these mechanisms or they may improperly register as a browser a widget runner an AppleScript interpreter etc.

Consequently a mechanism is needed for establishing and authenticating the identity of code in a number of forms while it is on disk and while it is running on a computer system. The subject matter of the present disclosure is directed to overcoming or at least reducing the effects of one or more of the problems set forth above.

The subject matter of the present disclosure relates to a system and method for authenticating the identity of code executing on a computer system against various constraints. A code authentication architecture provides an infrastructure and rule set for assigning an identity to code and verifying the authenticity of that identity when the code is executing on a computer system. In the architecture a vendor signs their code as being properly made by them using a digital signature. The types of code that can be signed can include any element that can be exploited changed or altered to make a system perform in ways unexpected to the user.

The architecture computes the validity of signed code identities expresses constraints or requirements that the signed code must satisfy to be valid includes Application Programming Interfaces to evaluate results and set parameters and distributes responsibilities of validating signed among code having host guest relationships. Once the code is signed for example the architecture can detect modifications that occur to the signed code caused by incidental or deliberate corruption while the code is stored and or executing on a user s computer system. Detecting such modifications allows the executing code to be reliably and persistently identified. In another example the architecture can allow a user s computer system to reliably determine that two pieces of signed code are meant to be treated the same even though they may not be byte for byte identical. In particular the code s manufacturer can express unambiguously using signed information in the code that a piece of new code is meant to be an update to older code. In this way the user is not required to verify the identity of the new code when loaded on the user s computer system.

The foregoing summary is not intended to summarize each potential embodiment or every aspect of the present disclosure.

While the subject matter of the present disclosure is susceptible to various modifications and alternative forms specific embodiments thereof have been shown by way of example in the drawings and are herein described in detail. The figures and written description are not intended to limit the scope of the inventive concepts in any manner. Rather the figures and written description are provided to illustrate the inventive concepts to a person skilled in the art by reference to particular embodiments as required by 35 U.S.C. 112.

Turning to the drawings one embodiment of a code authentication architecture is shown in and its operation is shown in . As shown a vendor s computer system is shown in relative to a user s computer systems which can be a personal computer laptop or other computing device. In general the architecture is used to identify code generated by the vendor and associate signing identity having various pieces of encrypted information with that identified code at the vendor s computer system . Code in the present disclosure generally includes any software element that can be exploited changed or altered to make a computer system perform in ways unexpected to the user.

Once the signing identity is associated with the identified code to produce signed code S the architecture is used at runtime on the user s system to verify the authenticity of that signed code s identity against various requirements or constraints imposed by the user s system and or other code running on the user s system . In this respect authenticating the identity of the signed code S involves two combined approaches that work together on the user s computer system . A first approach addresses the static integrity of the signed code S on disk in the user s system . A second approach addresses the dynamic validity of code executing code E and other code while executing in the user s system .

As explained in more detail below the notion of identity for the signed code S executing on the user s system has typically two parts 1 the authority of the vendor who signed the code e.g. Apple signed this code and 2 something that the authority said about the code e.g. Apple said this is a mail application or Apple said this application has access to .mac password information . The signing identity lock the code and associated encrypted information against tampering so that the user s system can determine if any changes were made to the code after signing. In this way the user s system can determine whether a piece of code running on the system has a valid identity. Based on that valid identity the user s computer system can then implicitly trust that the code really implements runs executes what it claims and has not been altered from when it was signed at the vendor s system . In addition the user s computer system can determine whether the code satisfies other requirements or constraints.

Initially the vendor who can be any type of software manufacturer or developer creates code such as a main executable and other related files and and bundles these together using known techniques to produce final code of a software program application or the like for users See Block . If the final code is intended to run on a Mac OS X operating system the other related files can include an Info.plist file and resource files e.g. libraries nib files images etc. which are packaged together in a bundle with the main executable code . For purposes of the present disclosure the final code may be any software elements that can be identified as code and can include but is not limited to a process object code single executable file bundle nib resource file interpreted script Applet widget library plug in and any code like data format.

The vendor then signs the final code to produce signed code S See Block . This signing step adds data structures that bind the main executable code and optionally additional files e.g. Info.plist file and resource files with a signing identity associated with the vendor as signer. This data then becomes part of the signed code S s bundle and is delivered and copied along with it. Signing of the final code to produce the signed code S preferably occurs after all of the editing has been completed all of the resources are properly set and the software program is ready to ship to users.

In its basic form signing the code involves indicating that certain portions of the final code will uniquely identify the code being signed and associating a signing identity to that identifying code. In this way the signing identity indirectly secures the signed code S from being modified or altered by ensuring that the identified code remains intact from the point when the vendor signed the code and has not been modified thereafter. Taken together the identifying code and the signing identity securing it constitute an identity claim of the signed code S. This identity claim gives the user s computer system a way to validate the signed code S and ensure that someone other than the vendor did not fake the identity claim itself or alter the signed code S of the program in some way.

In the code signing for example the vendor can use a code signing operation e.g. codesign command in a program building application which can be a development tool for creating programs for Apple s Mac OS X for example. In the code signing operation the vendor can package component files a digital signature and a code directory on disk. In general some elements of the code suitable for being signed include the directory the object code Info.plist file nib files other resource files and other code or code like components that are at least helpful in securing the identity of a program or ensuring its integrity. In one embodiment the digital signature is embodied in a Cryptographic Message Syntax CMS data structure that secures the code directory against modification and contains the vendor s chosen certificate chain . In turn the code directory contains a unique identifier not shown chosen by the vendor for example com.apple.Mail cryptographic hashes not shown of the various component files and various other information useful for verification such as a list not shown of internal requirements discussed later .

Once signed the signed code S can be moved copied packaged compressed or the like without destroying the signing identity associated with it as long as the code remains the same as it was when signed. In addition the signed code S can be transferred to the user by shipping installing downloading patching or any other known method and can be ultimately stored on the user s system as long as the signed code S eventually installed on disk at the user s system is the same as it was on the vendor s system after being signed See Block . With the signed code S installed and the requirements stored on the user s system the CMS signature secures the integrity of the code directory against modification which in turn protects the integrity of the component files internal requirements and other parts of the signed code S.

One or more requirements are also stored in storage on the user s computer system See Block . As will be explained later some of these requirements e.g. internal and designated requirements can be retrieved from the signed code S itself. Other requirements can be obtained independently of the signed code S and depend on constraints of the user s system such as constraints from other executing code running on the user s system .

Eventually the signed code S may be run on the user s system See Block . While run as executing code E various calls can be made to a verification API to authenticate the identity claim of the executing code E and validate that identity against various requirements See Block . What various API calls are made and what requirements are imposed may depend on what other executing code has loaded the signed code S what other executing code utilizes the executing code E etc. For example other executing code on the user s system may typically make a call to the verification API when it is loading the signed code S and wants to impose one or more requirements on the signed code S it is loading.

When called the verification API determines whether the digital signature s and other encrypted information in the signed code S satisfies the requirements being imposed See Decision . If they do then the API produces a successful result for some purpose associated with the other executing code on the user s system Block . In the requirements are not satisfied an error is produced for the result and the other executing code enforces the error according to its design Block .

In the present embodiment the code authentication architecture lacks mechanism for enforcing results and lacks mechanisms for denying or allowing access to information or services. Instead these mechanisms are the province of the callers of the validation API to implement based on the API s results. In other embodiments however the architecture can include these types of mechanisms.

There are various situations where the executing code E will fail to satisfy requirements resulting in an error. In one situation the identity claim of the executing code D may be invalid because the signed code S has been altered in some way from when it was signed by the vendor. In one example an identified resource in the signed code S may have been changed. Thus the altered resource will not have the same hash values as those hash values for the identified resource contained in the information secured by the CMS signature of the signed code S. Because the hash values do not match the identity of the signed code S is invalid.

In another situation the identity of the signed code S may be valid but that valid identity simply does not meet the requirements imposed. For example the signed code S may validly indicate it was signed by Signing Authority A but the other executing code loading the signed code S may have a requirement that the code that it loads be signed by Signing Authority B instead.

Because a valid identity of the signed code S requires that it not be altered after it has been signed the signed code S to be used for authentication purposes must be immutable and cannot be changed while it is on disk static in the user s system from the state in which it was originally signed by the vendor. If the signed code S is self modifying or stores anything mutable within its bundle the signed code S will lose its identity when modified. Therefore the signed code S should not include modifiable components such as preferences icons editable configuration files and the like that can be and often are modified. Instead these types of modifiable elements are preferably maintained separate from the signed code S and could be contained in libraries or the like.

In addition any scheme that rewrites as opposed to merely copying the signed code S on disk in the user s system will cause the signed code S to lose its identity. If a re writing scheme must be used with respect to the signed code S a cache can be established for the rewritten code instead of rewriting the original signed code S on disk. The integrity of this cache can be locally secured by the user s system . When needed an appropriate link can be provided between the original and rewritten copy of the signed code S for verification purposes.

With an understanding of the code signing architecture we now turn to a brief discussion of the verification API . Preferably the verification API is based on Apple s Core Foundation and is part of Security.framework. The verification API consists of multiple header files that include SecCode SecStaticCode and SecRequirement for the verification API which are incorporated in the computer program listing.

The verification API uses three API object types including SecCodeRef SecStaticCodeRef and SecRequirementRef. SecCodeRef identifies the running code to be verified and SecRequirementRef identifies the requirement to be applied to this code. Another type SecStaticCodeRef identifies code on disk such as bundles tools and scripts. Example script of the verification API may be 

In this example SecRequirementCreateFromData obtains a binary blob of the requirement stored in the user s system and makes the requirement into the SecRequirementRef API object. SecCodeCreateWithPID obtains the code identifier for the process associated with an entered Process ID PID and SecCodeCheckValidity does the verification by checking the validity of the code s claimed identity and determines whether the code satisfies the requirements. Verification succeeds if all rc noErr .

As discussed previously requirements are used by the verification API to validate the executing code E. Architecturally the requirements can be script written in a small dedicated language and can contain formulas describing conditions restrictions or constraints that the signed code S must satisfy to be acceptable for some purpose. Preferably the requirements have an extensible nature and can act as a programming language being interpreted during code authentication. The requirements can be stored in binary blob form in storage of the user s system such as in a configuration file and they can be converted into an API type when needed by the verification API .

Several types of requirements can be used some of which are discussed below. The requirements can contain a constraint on the certificate chain of the digital signature by placing a constraint on the signing anchor of the certificate chain . This is essentially a constraint on the authority that signed the code. A typical example of such a requirement would be that the signing anchor be Apple s signing anchor indicating that the code was signed by Apple. In this case the requirement would be satisfied if the signing anchor associated with the certificate chain of the signed code s digital signature has a hash value that matches a hash value for a specific signing authority in the requirement .

The requirements can also be directed to an identifier embedded in the signature data. One example of such a requirement would be that an embedded identifier matches com.apple.Mail. Other requirements can be directed to the contents of the signed code S the Info.plist or something else that must match a constraint on the contents as specified in the requirement . Still other requirements can be directed to application groups such as a constraint that the signed code S is a member of the dot mac application group. These constraints anchor identifier Info.plist content and application group and other constraints can be combined together using one or more logical operators to make additional requirements .

Based on the concepts above requirements can be classified into external code requirements stored separately on the User s Computer System internal requirements and designated requirements . Each of these will be discussed below.

Code requirements are imposed externally on the executing code E and are used to validate the identity of the executing code E as being what it claims i.e. as coming from the vendor unchanged from when it was signed . Typically other executing code on the user s system calls the verification API and imposes a code requirement on executing code E. If the underlying code has been altered from when it was originally signed or the code s signing authority does not match that contained in the code requirement then the verification API determines that the code s identity fails to meet the code requirement and produces an error result that the other executing code will then enforce according to its design.

In one example other code executing on the user s system may want to determine whether the subject code E that it is loading is actually an authentic mail application e.g. Apple s Mail.app . In this situation the executing code E will need to meet code requirements that it was actually signed by Apple and that the Info.plist bundle identifier is com.apple.Mail. In another example the executing code E might need to meet code requirements that it was signed by Apple with a particular release certificate and thereby known to be part of an official software release signed by the Apple. If the verification API determines that the executing code E does not meet these code requirements then the other executing code may kill the executing code E or not allow it to perform some operation or have access to information.

An independent party would not be able to independently sign code or alter existing signed code S to meet these code requirements without actually having the signing key for Apple to reproduce Apple s digital signature . In the architecture a third party must independently sign code that it modifies or creates so that the third party cannot make a custom identity incorporating another signer s digital signature. Therefore the claimed authority of the third party would derive from their signing identity and would be entirely separate from any original code signature given by the original signing vendor.

The code requirements are constraints on the state of the signed code S and its bundle. Therefore the code requirements depend on constraints associated with the user s computer system used to verify the identity claim contained the signed code S and they do not depend on constraints from the vendor who signed the code. Different user computer systems may have different code requirements for the same signed code S when executed such that some user computer systems may find their code requirements satisfied while others do not even though the various user computer systems access the same underlying code with the same identity claim. 

The code authentication architecture can validate some of the executing code E s identity against a code requirements so that the user s computer system can be assured that the part of the code secured by the signature is intact and trustworthy for the system s purposes. However other supporting code e.g. libraries plug ins etc. may not necessarily be signed. This other supporting code is often used by the primary signed code and may affect the integrity of the primary signed code. For this the host computer system may simply trust the primary signed code S to maintain its integrity for identity purposes when executing. Put simply by trusting the identity of some signed code S the user s system may implicitly trust that the vendor of that signed code S has taken proper measures to maintain the integrity of the code throughout its execution. For example the user s system may trust that the executing code E will not to blindly load plug ins without knowing what they are or what they do. Using the verification API to validate the code requirements against the claimed identity of executing code E does not determine how trustworthy the actual raw code itself is. Instead the verification by the API expresses trust in the signer vendor of the signed code S as long as the identity of that code is validated and the user s constraints are met with respect to the source of the code.

Using another type of requirement however trust can be explicitly extended to other code. This type of requirement is an internal requirement mentioned only briefly in the code signing operation. The vendor embeds these internal requirements into the signed code S when signing the code S so that the internal requirements are directly secured by the vendor s digital signature and a hash in the code s directory . Once on the user s system the internal requirements are retrieved from the signed code S on disk. When running the executing code E these internal requirements are used to verify the claims of other code that the executing code E wishes to use or to verify the claims of other executing code wishing to use the executing code E if its signed code S contains internal requirements .

The internal requirements can be distinguished by what other code outside the code in which they are embedded that they want to constrain. Some examples of possible internal requirements are provided below. However the set of internal requirements is extensible. A Host Requirement constrains the host code that is allowed to run supervise control the subject code with the embedded host requirement. A Guest requirement constrains what guests other code that a subject code is allowed to run safely . A Library requirement constrains dynamic libraries with which the subject code may be linked. A Plug in requirement constrains code plug ins that the subject code is allowed to load.

For example if the signed code S is a RUBY interpreter then an internal requirement in the signed code S may specify that its guest any executing code for which it is responsible for loading and managing must be a Ruby script signed by Apple. Likewise if the signed code S is a RUBY script then an internal requirement in the signed code S may specify that its host any executing code responsible for loading and managing the signed code must be a Ruby interpreter signed by Apple. Some examples of supporting code that may be designed to meet internal requirements include libraries plug ins interpreting scripts etc. Preferably resources are directly identified through the code directory and are not constrained by internal requirements .

Another type of requirement is a designated requirement used designate an identity of subject code for various purposes. In a typical situation an application may select a code bundle or file to perform a particular operation on the user system but the application often has no pre conceived notion of what code should be trusted. For example the user may be implementing parental controls on the user s system and may be using a parental controls application to browse through application folders and select various application files for permission privileges. In this situation a designated requirement is produced that can be used later by the verification API to re identify the executing code E associated with those files selected by the user with the parental controls application. In this way any current identity of those files their current location on disk Info.plist contents etc. can be compared to the designated requirement generated when they were originally selected.

To produce a designated requirement the code authentication architecture includes a Designation API operating on the user s system that responds to API calls from executing code . The Designation API may be part of the verification API or separate . The Designation API receives the call and returns a designated requirement for the subject code implicated in the call. When called the Designation API produces an API requirement object that is suitable for uniquely identifying the code S. In one embodiment the Designation API can build the code identifier heuristically based on what is contained in the subject code s data signature path Info.plist contents hash of code directory etc. .

In our previous example the user selects a file and the parental control application calls the Designation API which returns a designated requirement for that selected file. The designated requirement in this case may be a code identifier heuristically built from what is currently contained in the file s data signature path Info.plist contents etc. . Later other executing code e.g. a web browser may wish to verify the validity of the file by calling the verification API . Using the designated requirement for the file the verification API can determine whether the current file subject to the call is still the same as the file when it was originally selected by examining the file s data at this later time against the previously produced code identifier.

In the previous embodiment the designated requirement is generated by an API call and synthesized as needed. In another embodiment a designated requirement such as a code identifier can be directly embedded in signed code as an internal requirement and secured by the digital signature of the vendor as opposed to being heuristically built. In this way the signer can override the normal automatic generation of a designated requirement by adding an internal requirement that is a type designated requirement to the signed code S. The Designation API will retrieve it when asked for one. Therefore this type of designated requirement is internal when classified by storage mode though it is really an explicit designated requirement. In one example the vendor may find it useful to allow a group of programs to have the same designated identity. In this case the vendor can directly embed the code identifier as a designated requirement in the subject code of the group of programs and secure it by digital signatures.

In the previous discussions other executing code on the user s system has been described as calling the verification API to verify that the executing code E satisfies various requirements . The other executing code may be responsible for loading and managing the execution of the signed code S. In this case the other executing code may be considered a host of the executing code E which in turn is considered a guest. 

Conceptually all executing code on the user s system can be part of a hierarchy of executing code having host and guest relationships. In these relationships executing code may be a host responsible for running managing and controlling its guest and protecting itself against intrusion and subversion by its guest. Likewise the same executing code may itself be a guest supervised by another host. Thus in the user s system various host guest relationships may develop between executing code so that all of the executing code can be organized into a hierarchical tree of hosts and guests with the operating system kernel at the root.

In this example tree the kernel which may be implicitly trusted is at the root and acts as host to two UNIX processes. The first UNIX process has a web application e.g. Safari as guest which in turn has two Java Applets as guests. The second UNIX process has an executing code as its guest and that executing code in turn acts as host to another executing code which will be referred here sometime as target code.

Because each executing code is a guest such that it is run by another executing code acting as host a chain of hosts or hosting chain is formed in the tree . By default executing code in the user s system is identified as belonging to and being part of its host. Thus each host defines and organizes the distinction between its guests and itself. For example the kernel is in charge of separating and identifying different processes e.g. the UNIX processes . The web application is in charge of identifying its applets e.g. the Java Applets and answering calls such as Which of your Applets tried to open this file Thus the web application could then answer this Applet creating in the process a separate code identity for it or it could answer myself 

In the embodiment of hosts e.g. executing code and guests e.g. target code share the work of ensuring the validity of executing code in the user s system . For example a host ensures that the link to information in signed code on disk for its guest is maintained and that the main executable whatever it is for the guest is really what is executing. A guest on the other hand controls what additional executing code it utilizes or incorporates and the guest asks its host to mark its identity as invalid if it utilizes executing code that violates the guest s own internal requirements.

To achieve this division of work each host manages and stores dynamic information about each of its guests . The managed information includes mapping information validity information and guest to resource information . For the mapping information each host maps for each of its guests the location of on disk static code e.g. files on disk from which the guest was launched under control of the host . The host then stores this as one or more links in its mapping information for the guest . In this way the mapping information links the executing code of the guest to the location of the signed on disk code including its digital signatures signed directory code identifiers etc. for that executing code.

For the validity information each host maintains a flag for each of its guests that indicates whether the identity of the guest is valid. During the supervised loading of its guest the host verifies that the signed information in the on disk code satisfies specified requirements as it loads and the host sets the flag in the validity information for the guest accordingly. In this verification when the main executable of the on disk code is loaded under the supervision of the host the host uses the verification API and requirements discussed previously.

When the host loads the guest it incrementally validates portions pages of the guest s code as the code is brought into memory and latches the flag if validation fails. Once latched as invalid the flag is not reset. If validation is successful at loading subsequent activity during execution may alter the guest and logic for checking the validity of the guest can latch this flag to indicate the validity as invalid. The flag may be latched as invalid if the guest fails to have a valid identity for whatever reason such as violating its own internal requirements. Alternatively the flag may be latched if a link provided in the mapping information to the location of the on disk code becomes invalid such as when the on disk code has been moved or an improper replacement for the on disk code has been utilized.

For the guest to resource information each host identifies which of its guests is associated with a particular resource in the host s context and stores this association as part of the guest to resource information . For example the host will store whether the guest is associated with a given Process ID PID port parent process ID process group ID Saved User ID terminal window from which the process was launched or other distinguishing resource. This guest to resource information can then be used to locate a host for a given guest .

At some point during execution the guest target code may call some other executing code referred to here as a client to request some operation or to gain access to information. In this situation the client may need to verify the identity of target code . For example the client may be a background server process daemon providing access to a keychain via a Keychain Service API not shown and the target code may be requesting access to the keychain to obtain one of the keychain items e.g. a .mac password . In this situation the client needs to determine whether the target code should be granted access to the keychain .

To determine whether to allow access the client calls the verification API . Although authenticating the target code s identity will be performed according to the techniques discussed previously See host guest validation services are performed behind the scenes using a Host API and the previously described managed information of the hosts .

In these host guest validation services the target code is validated by recursively validating the target code and the various hosts in the hosting chain associated with the target code . In the recursive validation the Host API determine the validity of the target code its host executing code that host s host e.g. second UNIX process and so on though the hosting chain until the kernel or some designated root code is reached in the tree . The Host API does this by validating internal requirements of the executing codes in the hosting chain which is formed only when needed based on the dynamic information maintained by hosts through the Host API .

If each of the validations in the hosting chain is successful then verification of the target code s identity against external requirements will be performed according to the techniques discussed previously by a separate call from the client to the verification API . The Host API and the complexity of its validation logic are preferably hidden from callers of the verification API . Therefore the client calling the verification API only deals with obtaining a code identity and matching it against requirements using the validation API .

The header file for the Host API is SecCodeHost.h incorporated in the computer program listing. The Host API is called by code hosts except for the kernel that has a different interface fashioned through system calls . Also used is a code hosting InterPorcess Communication IPC interface that is called answered by hosts to respond to queries about their guests. A Mach Interface Generator MIG file for the code hosting IPC interface is the cshosting file incorporated in the computer program listing.

The source files responsible for validating various parts of the on disk static data structures of subject code are provided in the StaticCode file incorporated in the computer program listing. Furthermore a brief excerpt of code for implementing dynamic validation in the hosting chain is provided below 

With the on disk code located the Host API performs computations to determine if the on disk code is intact and valid in the context of the host See Block and Decision . In determining the validity of the on disk code for example the Host API can verify the cryptographic signature of the on disk code and can verify that all the signed component files resources etc. are intact. This can be done using internal logic of the Host API for checking validity and or using calls to the verification API .

In addition the Host API can compare information in the on disk code against information in the target code s host and against any constraints between the host and the target code . For example the Host API can examine any internal requirements in the on disk code . As discussed previously such internal requirements and other qualifying and classifying information for host guest relationships can be embedded into the signed on disk code e.g. placed into the Info.plist of the signed code and can include constraints on what form of executing code can be a host for the signed code and what form of executing code if any can be the signed code s guest.

If the computations succeed the Host API then checks the status of the dynamic flag in the validity information for the target code maintained by the host to determine if the executing target code is still identified and valid for the host See Block and Decision . If the flag indicates that the executing target code is still identified and valid for the host then the target code has a valid identity as to its host .

If the executing target code has a valid identity as to its immediate host then the host guest validation services are applied recursively through the hosting chain until the kernel or some designated root code is reached See Block . For each of these recursive validations the services determine whether the on disk code of the immediate host s guest are intact and whether the validity flag indicates that the immediate host considers the identity of its executing guest to be identified and valid. The kernel or other designated root code may be implicitly trusted when it is reached. If all validity checks are satisfied See Decision a valid identity has been established for the target code and an indication is returned that the target code has a valid identity See Block .

At various points in the service validation may fail. For example the computations may indicate that the on disk code for the target code is not valid or intact or a flag may be latched as invalid. In the event of a validation failure an indication is returned that the target code has an invalid identity See Block . Ultimately the client may deny the target code access to the keychain if the verification fails.

If the recursive validation has completed without any error results through the hosting chain then a check is made to determine whether the valid identity of the target code is acceptable to the client . Here the verification API discussed previously checks the valid identity of the target code against any associated requirements . As before the requirements can be as simple or complex as needed and they are applied to the on disk code for the executing target code using the verification API . As in previous examples the code requirements may specify that the target code must be signed by Apple and that the CFBundleIdentifier must be com.apple.mail which translates to indicating that the target code is Apple s genuine Mail program any version. 

If the target code satisfies the requirements and is acceptable to the client the verification API produces a favorable result Block . Ultimately the client may allow the target code to access the keychain to obtain the keychain item which might be a user s .mac password for example. Although the above example has described gaining access to keychain it will be appreciated that the host guest validation services Host API and verification API of the present disclosure can be applied to numerous other situations on the user s computer system .

In one client of the verification API has been shown to be the keychain layer on the user system . It will be appreciated that the keychain layer is but one example of a client that can use the verification API and that the verification API and other features of the disclosed architecture are not limited to being used for just the purpose of accessing Keychains. In general any entity on the user system can use the verification API for various purposes.

As alluded above code as defined herein for the purposes of code signing and authentication is meant to have a broad meaning beyond obvious executable code. As used herein and in addition to executables code includes any element of software that can make a system perform arbitrary operations within its scope and is not limited to one particular well constrained data set. In addition code as used herein includes virtual code such as Java binary code scripts such as Perl scripts and startup scripts UNIX style . rc files .

It will be appreciated that various low level utilities are required to implement the code authentication disclosed herein. Preferably two types of user space drivers for code file formats and code types with multiple implementations are also used to implement the code authentication disclosed herein. The code format drivers provide extensible expression for file formats of on disk code and the code type drivers provide extensible expression of the behavior associated with different types of running code.

The foregoing description of preferred and other embodiments is not intended to limit or restrict the scope or applicability of the inventive concepts conceived of by the applicants. In exchange for disclosing the inventive concepts contained herein the applicants desire all patent rights afforded by the appended claims. Therefore it is intended that the appended claims include all modifications and alterations to the full extent that they come within the scope of the following claims or the equivalents thereof.

