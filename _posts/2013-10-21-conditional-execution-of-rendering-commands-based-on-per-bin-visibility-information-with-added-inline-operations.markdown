---

title: Conditional execution of rendering commands based on per bin visibility information with added inline operations
abstract: A GPU may determine, based on a visibility stream, whether to execute instructions stored in an indirect buffer. The instructions include instructions for rendering primitives associated with a bin of a plurality of bins and include one or more secondary operations. The visibility stream indicate if one or more of the primitives associated with the bin will be visible in a finally rendered scene. The GPU may, responsive to determining not to execute the instructions stored in the indirect buffer, execute one or more secondary operations stored in a shadow indirect buffer. The GPU may, responsive to determining to execute the instructions stored in the indirect buffer, execute the instructions for rending the primitives associated with the bin of the plurality of bins and executing the one or more secondary operations stored in the indirect buffer.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09286649&OS=09286649&RS=09286649
owner: QUALCOMM Incorporated
number: 09286649
owner_city: San Diego
owner_country: US
publication_date: 20131021
---
This application claims the benefit of U.S. Provisional Application No. 61 829 564 filed May 31 2013 the entire content of which is hereby incorporated by reference.

This disclosure relates to techniques for graphics processing and more particularly relates to techniques for rendering primitives in graphics processing.

Visual content for display such as content for graphical user interfaces and video games may be generated by a graphics processing unit GPU . A GPU may convert two dimensional 2D or three dimensional 3D graphical objects into a 2D pixel representation that may be displayed on a display device. Converting information about 3D objects into a 2D pixel representation that can be displayed is known as pixel rendering and may require considerable memory and processing power.

In general this disclosure describes techniques for conditional execution of rendering instructions for bin based rendering based on per bin visibility information. By executing rendering instructions of a bin if and in some examples only if the primitives in the bin are visible a graphics processing unit GPU can improve its performance in rendering graphical objects and scenes that comprise primitives. The GPU may determine if the primitives in a bin are visible in the rendered graphical object or scene based on a visibility stream for the bin that indicates if any primitives in the bin are visible.

In one aspect the disclosure is directed to a method for rendering a scene. The method includes determining based on a visibility stream whether to execute instructions stored in an indirect buffer wherein the instructions stored in the indirect buffer include instructions for rendering primitives associated with a bin of a plurality of bins and further include one or more secondary operations and wherein the visibility stream indicates if the bin is associated with at least one primitive that will be visible in a finally rendered scene. The method further includes responsive to determining based on the visibility stream not to execute the instructions stored in the indirect buffer executing one or more operations stored in a shadow indirect buffer wherein the one or more operations stored in the shadow indirect buffer includes the one or more secondary operations. The method further includes responsive to determining based on the visibility stream to execute the instructions stored in the indirect buffer executing the instructions stored in the indirect buffer for rendering the primitives associated with the bin of the plurality of bins and executing the one or more secondary operations stored in the indirect buffer.

In another aspect the disclosure is directed to a device configured for graphics processing. The device includes a graphics processing unit GPU configured to determine based on a visibility stream whether to execute instructions stored in an indirect buffer wherein the instructions stored in the indirect buffer include instructions for rendering primitives associated with a bin of a plurality of bins and further include one or more secondary operations and wherein the visibility stream indicates if the bin is associated with at least one primitive that will be visible in a finally rendered scene responsive to determining based on the visibility stream not to execute the instructions stored in the indirect buffer execute one or more operations stored in a shadow indirect buffer wherein the one or more operations stored in the shadow indirect buffer includes the one or more secondary operations and responsive to determining based on the visibility stream to execute the instructions stored in the indirect buffer execute the instructions stored in the indirect buffer for rendering the primitives associated with the bin of the plurality of bins and executing the one or more secondary operations stored in the indirect buffer.

In another aspect the disclosure is directed to a computer readable storage medium having instructions stored thereon that when executed cause one or more processors to perform operations. The operations include determining based on a visibility stream whether to execute instructions stored in an indirect buffer wherein the instructions stored in the indirect buffer include instructions for rendering primitives associated with a bin of a plurality of bins and further include one or more secondary operations and wherein the visibility stream indicates if the bin is associated with at least one primitive that will be visible in a finally rendered scene. The operations further include responsive to determining based on the visibility stream not to execute the instructions stored in the indirect buffer executing one or more operations stored in a shadow indirect buffer wherein the one or more operations stored in the shadow indirect buffer includes the one or more secondary operations. The operations further include responsive to determining based on the visibility stream to execute the instructions stored in the indirect buffer executing the instructions stored in the indirect buffer for rendering the primitives associated with the bin of the plurality of bins and executing the one or more secondary operations stored in the indirect buffer.

In another aspect the disclosure is directed to a device. The device includes means for determining based on a visibility stream whether to execute instructions stored in an indirect buffer wherein the instructions stored in the indirect buffer include instructions for rendering primitives associated with a bin of a plurality of bins and further include one or more secondary operations and wherein the visibility stream indicates if the bin is associated with at least one primitive that will be visible in a finally rendered scene. The device further includes responsive to determining based on the visibility stream not to execute the instructions stored in the indirect buffer means for executing one or more operations stored in a shadow indirect buffer wherein the one or more operations stored in the shadow indirect buffer includes the one or more secondary operations. The device further includes responsive to determining based on the visibility stream to execute the instructions stored in the indirect buffer means for executing the instructions stored in the indirect buffer for rendering the primitives associated with the bin of the plurality of bins and executing the one or more secondary operations stored in the indirect buffer.

A graphics processing unit GPU is often used to render a three dimensional scene. Because such rendering of three dimensional 3D scenes can be very memory bandwidth intensive a specialized graphics memory GMEM is located close to the graphics processing core of the GPU so that it has a very high memory bandwidth. A scene can be rendered by the graphics processing core of the GPU to the GMEM and the scene can be resolved from GMEM to memory e.g. a frame buffer so that the scene can then be displayed at a display device. However because the size of the GMEM may be limited due to physical area constraints the GMEM may not have sufficient memory capacity to contain an entire three dimensional scene. Instead a three dimensional scene may need to be split into tiles so that each tile making up the scene can fit into GMEM. For example if the GMEM is able to store 512 kB of data then the scene may be divided into tiles such that the pixel data contained in each tile is less than or equal to 512 kB. In this way the scene can be rendered by dividing up the scene into tiles that can be rendered into the GMEM and individually rendering each tile of the scene into the GMEM storing the rendered tile from GMEM to a frame buffer and repeating the rendering and storing for each tile of the scene. Accordingly the scene can be rendered tile by tile using multiple rendering passes to render each tile of the scene.

A scene can be made up of primitives such as triangles and each of the tiles making up the scene may include one or more of the primitives. The tiles making up a scene can each be associated with a bin in memory that stores the primitives included in each respective tile. Rendering a tile of the scene into the GMEM may include executing commands to render the primitives in the associated bin into the GMEM. A binning pass of the GPU can sort the primitives making up a scene into the appropriate bins. The binning pass of the GPU may also create visibility streams for each bin that indicates whether or not any primitives in the bin will be visible in the final rendered scene.

The commands to render the primitives in a bin are loaded in an indirect buffer and the GPU executes the commands stored in the indirect buffer to render the primitives included in the bin. If the visibility stream for a bin indicates that the bin does not contain any visible primitives i.e. all of the primitives in the bin will not be visible in the final rendered scene performance may be improved if the GPU does not render the primitives in the bin by skipping execution of the instructions in the indirect buffer associated with the bin.

However in addition to storing the command stream to render the primitives in a particular bin many modern graphics applications or compositing systems use the indirect buffer to store secondary commands. These secondary commands may be commands that are unrelated to the rendering of primitives for the particular bin. For example the secondary commands may include inline operations e.g. fast clears that clear multiple areas inline tileable blits that transfer image block from one portion of the scene to another and other bit block transfers and other state updates. While the inline operations and other state updates may not contribute to the visibility stream by design they may contribute to the resulting rendering of the scene. Thus if the GPU does not execute those instructions in the indirect buffer associated with the bin because the visibility stream for the bin indicates that there are no visible primitives associated with the bin the secondary commands in the indirect buffer are also not executed thereby resulting in corruption of the final scene.

To ensure that the GPU executes the secondary commands included in an indirect buffer even if the GPU based on the visibility stream for a bin determines that the bin does not include any primitives that will be visible in the final rendered scene the GPU and or the graphics driver can allocate a shadow indirect buffer in memory e.g. system memory store the secondary commands from the indirect buffer for the bin to the shadow indirect buffer and the GPU may execute the secondary commands stored in the shadow indirect buffer. When no primitives are visible for a given bin the GPU can conditionally not execute commands to render the primitive e.g. the draw commands stored in the original rendering indirect buffer and may instead execute the secondary commands e.g. inline operations and state updates in the shadow indirect buffer. In this way the GPU can still execute the secondary commands stored together in the same indirect buffer as the command stream of a particular bin even if none of the primitives of that bin will be visible in the final rendered scene.

The shadow indirect buffer is a subset of the corresponding indirect buffer for the bin in that it may in some examples only include the secondary commands of the corresponding indirect buffer. In some examples the GPU can allocate a shadow indirect buffer in memory and each bin that includes one or more secondary commands other than instructions for rendering primitives may store the one or more secondary commands in the shadow indirect buffer. The shadow indirect buffer can be populated by the GPU with secondary commands of a bin at the same time as the indirect buffer is populated with instructions for rendering primitives of that bin. In other examples a shadow indirect buffer may store secondary commands of a bin if the GPU determines based on the visibility stream that the corresponding bin does not include any primitives that will be visible in the finally rendered scene.

Any tile based rendering GPU that stores both inline operations and commands for rendering primitives in the same bin can conditionally execute instructions in a shadow indirect buffer instead of instructions in a corresponding indirect buffer based on the visibility stream associated with the corresponding bin. By skipping parsing and execution of indirect buffers that do not include commands for rendering any visible primitives while still executing inline operations in the shadow indirect buffer the rendering performance of the GPU can be improved without affecting the final rendered scene.

In the example of processor system memory and GPU may be part of a device. Examples of the device include but are not limited to video devices media players set top boxes wireless handsets such as mobile telephones and so called smartphones personal digital assistants PDAs desktop computers laptop computers gaming consoles video conferencing units tablet computing devices and the like.

Processor may be the central processing unit CPU . GPU may be a processing unit configured to perform graphics related functions such as generate and output graphics data for presentation on a display as well as perform non graphics related functions that exploit the massive processing parallelism provided by GPU . For example GPU may execute both graphics applications and non graphics applications. Because GPU may provide general purpose processing capabilities in addition to graphics processing capabilities GPU may be referred to as a general purpose GPU GP GPU .

Examples of processor and GPU include but are not limited to a digital signal processor DSP a general purpose microprocessor application specific integrated circuit ASIC field programmable logic array FPGA or other equivalent integrated or discrete logic circuitry. In some examples GPU may be a microprocessor designed for specific usage such as providing massive parallel processing for processing graphics as well as for executing non graphics related applications. Furthermore although processor and GPU are illustrated as separate components aspects of this disclosure are not so limited. For example processor and GPU may reside in a common integrated circuit IC .

Software application that executes on CPU may include one or more graphics rendering instructions that instruct CPU to cause the rendering of graphics data to a display not shown . In some examples the graphics rendering instructions may include software instructions may conform to a graphics application programming interface API such as e.g. an Open Graphics Library OpenGL API an Open Graphics Library Embedded Systems OpenGL ES API a Direct3D API an X3D API a RenderMan API a WebGL API or any other public or proprietary standard graphics API. In order to process the graphics rendering instructions CPU may issue one or more graphics rendering commands to GPU e.g. through graphics driver to cause GPU to perform some or all of the rendering of the graphics data. In some examples the graphics data to be rendered may include a list of graphics primitives e.g. points lines triangles quadrilaterals triangle strips etc.

GPU may be configured to perform graphics operations to render one or more graphics primitives to a display. Thus when one of the software applications executing on CPU requires graphics processing CPU may provide graphics commands and graphics data to GPU for rendering to the display. The graphics data may include e.g. drawing commands state information primitive information texture information etc. GPU may in some instances be built with a highly parallel structure that provides more efficient processing of complex graphic related operations than CPU . For example GPU may include a plurality of processing elements that are configured to operate on multiple vertices or pixels in a parallel manner. The highly parallel nature of GPU may in some instances allow GPU to draw graphics images e.g. GUIs and two dimensional 2D and or three dimensional 3D graphics scenes onto the display more quickly than drawing the scenes directly to the display using CPU .

GPU may be directly coupled to graphics memory . In other words GPU may process data locally using a local storage instead of off chip memory. This allows GPU to operate in a more efficient manner by eliminating the need of GPU to read and write data via a bus which may experience heavy bus traffic. In some instances however GPU may not include a separate memory but instead utilize system memory . Graphics memory may include one or more volatile or non volatile memories or storage devices such as e.g. random access memory RAM static RAM SRAM dynamic RAM DRAM and one or more registers.

CPU and or GPU may store rendered image data in a frame buffer . Frame buffer may be an independent memory or may be is allocated within system memory . A display processor not shown may retrieve the rendered image data from frame buffer and display the rendered image data on a display.

System memory is the system memory of the device and resides external to processor and GPU i.e. off chip with respect to processor and off chip with respect to GPU . System memory may store applications that are executed by processor and GPU . Furthermore system memory may store data upon which the executed applications operate as well as the data that result from the application. However not all such data needs to be stored in system memory in every example. In some instances the data may be stored locally on processor or GPU . For example some or all of the data may be stored locally within on chip GPU memory e.g. graphics memory .

System memory may store program modules and or instructions that are accessible for execution by CPU and or data for use by the programs executing on CPU . For example system memory may store a window manager application that is used by CPU to present a graphical user interface GUI on a display. In addition system memory may store user applications and application surface data associated with the applications. System memory may act as a device memory for GPU and may store data to be operated on by GPU as well as data resulting from operations performed by GPU . For example system memory may store any combination of texture buffers depth buffers stencil buffers vertex buffers frame buffers or the like.

System memory may be an example of a computer readable storage medium. For example system memory may store instructions that cause processor and GPU to perform functions ascribed to each in this disclosure. System memory may be considered as a computer readable storage medium comprising instructions that cause one or more processors e.g. processor or GPU to perform various functions.

Examples of system memory include but are not limited to a random access memory RAM a read only memory ROM or an electrically erasable programmable read only memory EEPROM or any other medium that can be used to carry or store desired program code in the form of instructions or data structures and that can be accessed by a computer or a processor. As one example system memory may be removed from the device and moved to another device. As another example a storage device substantially similar to system memory may be inserted into the device.

In accordance with techniques of the present disclosure CPU may issue one or more graphics rendering commands to GPU to render a graphical scene made up of primitives. GPU may perform a binning pass to sort the primitives making up the graphical scene into a plurality of bins so that each bin of primitives may when rendered fit entirely into graphics memory . GPU when performing the binning pass may also create a visibility stream for each bin in the plurality of bins. The visibility stream associated with a bin may indicate if the bin is associated with at least one primitive that will be visible in the finally rendered scene.

Each bin in the plurality of bins may be associated with instructions for rendering the primitives in the associated bin. For each of the plurality of bins the associated instructions may in turn bin by bin be stored in an indirect buffer in memory . The associated instructions for a bin stored into the indirect buffer may include the associated instructions as well as secondary instructions. Secondary instructions may be instructions that are unrelated to the rendering of the primitives in the bin. However the secondary instructions may in some instances be image related operations. Secondary instructions may include inline operations such as fast clears that clear pixels from multiple areas of a scene inline tileable blits that transfer image block e.g. groups of pixels from one portion of the scene to another and other bit block transfers as well as other state updates. If the indirect buffer includes one or more secondary instructions for a bin the same one or more secondary instructions for the bin may be stored in a shadow indirect buffer in memory . In some examples the secondary instructions are associated with the bin because the secondary instructions operate within the tile associated with the bin. For example the associated tile may include pixels other than primitives and one of the areas of the scene cleared by a fast clear secondary operation may include at least a portion of the associated tile. In another example the tileable blit secondary operation may transfer an image block from the associated tile or to the associated tile.

GPU may render the graphical scene by rendering bin by bin the primitives making up the graphical scene. GPU may determine for each bin based on the visibility stream for the bin whether to execute instructions of the bin stored in the indirect buffer or whether to execute the instructions of the bin stored in a shadow indirect buffer. The instructions stored in the indirect buffer may include instructions for rendering primitives associated with the bin of the plurality of bins. The instructions stored in the indirect buffer may further include one or more secondary operations. As discussed above the secondary operations may be operations unrelated to the rendering of primitives for the bin. Responsive to determining based on the visibility stream not to execute the instructions stored in the indirect buffer GPU may execute the instructions for the bin stored in the shadow indirect buffer wherein the instructions stored in the shadow indirect buffer include the one or more secondary instructions. Alternatively responsive to determining based on the visibility stream to execute the instructions stored in the indirect buffer GPU may execute the instructions for the bin stored in the indirect buffer for rendering the primitives associated with the bin of the plurality of bins and also executing the one or more secondary operations stored in the indirect buffer.

The goal of the binning pass is to identify primitives that intersect the current bin. As such only the position of the vertices of the primitive may need to be determined to identify if a primitive intersects a particular bin. The binning pass may operate by using a simplified vertex shader in GPU s graphics pipeline that only includes instructions that affect the position of the vertices. For example color instructions texture coordinates and other instructions that do not affect the position of primitive vertex may be removed from the simplified vertex shader used for the binning pass. The binning pass also uses coarse rasterization rather than fine rasterization to determine an approximate depth of each primitive. Coarse rasterization calculates a depth value at a lower precision e.g. using a lower number of bits than fine rasterization. Only approximate depth values are necessary to determine if a primitive is visible in the bin. In some examples pixel shaders are not used in the binning pass.

In some examples the generated visibility stream may include a bit for each primitive in the bin that indicates if the primitive is visible in the final rendered scene so that the visibility stream may be a string of bits that indicates whether or not a specific primitive in the rendered bin is visible e.g. 1 indicates a primitive is visible 0 indicates a primitive is not visible . If the bit corresponding to a primitive in a bin is on it may indicate that the corresponding primitive is visible in the final rendered scene. In contrast if the bit corresponding to a primitive in a bin is off it may indicate that the corresponding primitive is not visible in the final rendered scene. In some examples GPU may compress the visibility streams resulting in less memory consumption and faster skipping of non visible primitives during the rendering of the scene.

GPU renders the graphical scene by executing the command stream of each bin to render the primitives in each of the bins onto graphics memory. GPU may further store the command stream for rendering the primitives of a bin in an indirect buffer . The command stream stored into the indirect buffer may include a series of state commands and draw commands for drawing the primitives of the particular bin. The state commands may affect the behavior of the graphics processing pipeline executed by GPU . For example state commands may change the color polygon mode e.g. points instead of solids or lines blending on off depth testing on off texturing on off culling clipping and other logical operations.

The command stream stored into the indirect buffer may also include secondary commands supported by many modern graphics applications or compositing systems such as Microsoft Desktop Window Manager. These secondary commands may be unrelated to the rendering of primitives for the particular bin. For example the secondary commands may include inline operations e.g. fast clears that clear multiple areas inline tileable blits that transfer image block from one portion of the scene to another and other bit block transfers and other state updates. While the inline operations and other state updates may not contribute to the visibility stream by design they may contribute to the resulting rendering of the scene.

If the visibility stream for a bin indicates that the bin does not contain any visible primitives i.e. all of the primitives in the bin will not be visible in the final rendered scene performance may be improved if GPU does not render the primitives in the bin by skipping execution of the instructions in the indirect buffer associated with the bin. However as discussed above besides storing the command stream to render the primitives in a particular bin the indirect buffer may also include secondary commands such as inline operations and state updates. While the inline operations and state updates may not contribute to the visibility stream by design they may contribute to the resulting rendering of the scene. Thus if GPU does not execute those instructions in the indirect buffer associated with the bin because the visibility stream for the bin indicates that there are no visible primitives associated with the bin the secondary commands in the indirect buffer are also not executed thereby resulting in corruption of the final scene.

To ensure that GPU executes the secondary commands included in an indirect buffer even if GPU based on the visibility stream for a bin determines that the bin does not include any primitives that will be visible in the final rendered scene GPU and or graphics driver can store the state updates and secondary commands from the indirect buffer for the bin to a shadow indirect buffer allocated in memory e.g. system memory . If no primitives are visible for a given bin GPU can conditionally determine to not execute the more complicated original rendering indirect buffer and instead may just execute the shadow inline rendering indirect buffer if there are secondary commands for the given bin in the shadow indirect buffer. In this way GPU can still execute the secondary commands stored together in the same indirect buffer as the command stream of a particular bin even if none of the primitives of that bin will be visible in the final rendered scene. In some examples GPU may store the state updates and secondary commands from the indirect buffer to the shadow indirect buffer in response to determining based on the visibility stream for the bin if the bin includes primitives that will be visible in the finally rendered scene.

The shadow indirect buffer includes a subset of the commands and operations stored in the corresponding indirect buffer for the bin. In some examples the shadow indirect buffer includes only the secondary commands of the corresponding indirect buffer. In some examples the one or more secondary commands are commands other than instructions for rendering primitives. GPU can populate the shadow indirect buffer with secondary commands for a bin at the same time as GPU populates the corresponding indirect buffer with instructions for the bin for rendering primitives. In other examples GPU may populate the shadow indirect buffer with the secondary commands of a bin if GPU determines based on the visibility stream that the corresponding bin does not include any primitives that will be visible in the finally rendered scene.

The loading of secondary commands into the shadow indirect buffer and the conditional execution of instructions in the shadow indirect buffer in lieu of instructions in a corresponding indirect buffer may be implemented by any tile based rendering GPU such as GPU that executes inline operations along with commands for rendering primitives in a bin. For example graphics driver may include a conditional ib2 X else Y packet where X is rendering pass for the indirect buffer and Y is the shadow indirect buffer containing inline instructions. In some examples such a conditional packet can be implemented in hardware such as the hardware of GPU . By skipping parsing and execution of the indirect buffer if it does not include commands for rendering any visible primitives while still executing inline operations in the shadow indirect buffer GPU s rendering performance can improved.

GPU may determine based on the visibility stream for a bin whether to execute instructions included in the indirect buffer including determining based on the visibility stream for the bin if the bin includes one or more primitives that will be visible in the finally rendered scene . As discussed above each bin may be associated with a visibility stream and a visibility stream may include a bit that is switched on e.g. set to 1 for each primitive in the bin that is visible in the final rendered scene. If the visibility stream for the bin includes one or more bits that are switched on then GPU may determine that the bin includes one or more primitives that will be visible in the finally rendered scene. In contrast if the visibility stream for the bin does not include any bits that are switched on then GPU may determine that the bin does not include one or more primitives that will be visible in the finally rendered scene.

Responsive to determining based on the visibility stream to execute the instructions in the indirect buffer including responsive to determining based on the visibility stream that the bin does include one or more primitives that will be visible in the finally rendered scene GPU may execute the instructions stored in the indirect buffer . GPU may execute the instructions for drawing primitives for the bin as well as the one or more secondary operations included in the bin.

Responsive to determining based on the visibility stream not to execute the instructions in the indirect buffer including responsive to determining based on the visibility stream that the bin does not include one or more primitives that will be visible in the finally rendered scene GPU may instead execute the instructions stored in the shadow indirect buffer . GPU may execute the one or more secondary operations included in the shadow indirect buffer.

GPU may determine whether it has finished rendering the scene . If GPU determines that there are additional tiles of the scene that it has yet to render GPU may move on and render the next tile of the scene by storing the command stream for the bin associated with the next tile of the scene into the indirect buffer and may store secondary commands for the bin into the shadow indirect buffer .

Preamble instruction in IB1 may point to preamble IB2 that includes instructions for establishing the static state of GPU and sets the initial rendering state of GPU . The static state of GPU includes settings that do not change based on the particular application. The rendering state on the other hand includes GPU settings that may change based on the particular application e.g. an OpenGL application vs. a Direct X application . For example the instructions may establish that GPU will perform a binning pass for primitives of the 3D object to be rendered. After the commands in the preamble IB2 are completed control returns to IB1 to perform the next execution command.

The next execution command in IB1 may be binning pass instruction . Binning pass instruction in IB1 may point to binning IB2 that includes instructions for performing a binning pass as described above with respect to .

IB1 may also include instructions for GPU to perform a rendering pass to render the primitives of the 3D object. Load bin instruction in IB1 may point to load IB2 that includes instructions for loading data for a particular bin into graphics memory. Conditional render bin instruction may point to rendering IB2 that includes a series of state commands and draw commands for drawing the primitives of the particular bin having data loaded into the graphics memory as well as shadow rendering IB2 that include inline operations and state updates. If the visibility stream for the bin indicates that there are one or more visible primitives in the bin GPU may execute the instructions in rendering IB2 . As shown in rendering IB2 state commands may be issued on a per triangle or per primitive basis. That is the command State Tri A may affect the behavior of GPU when drawing triangle A while the State Tri B1 and State Tri B2 commands may affect the behavior of GPU when drawing triangle B. The State Tri B1 and State Tri B2 commands merely indicate that multiple state commands may be executed for each triangle. On the other hand if the visibility stream for the bin indicates that the bin includes no visible triangles then GPU may execute the state updates and inline operations stored in shadow rendering IB2.

Store bin instruction may point to store IB2 that includes commands to store the rendered bin from GMEM into memory such as a frame buffer. The rendering pass may be repeated for each of the remaining bins associated with tiles that make up the scene.

GPU may render a triangle by executing a command for rendering the triangle. Thus GPU may render graphical object by executing commands for rendering each of the triangles making up graphical object . GPU may sort the triangles of a scene into bins so that each bin may include a command stream a set of commands to render the triangles included in the bin. Because there are a total of 25 tiles for scene there may be 25 corresponding bins for scene . GPU may store the command stream for each bin in an indirect buffer in memory such as system memory shown in . GPU renders the graphical object by executing the command stream of each bin to render the triangles in each of the bins onto graphics memory . After GPU renders the portion of scene contained in a bin onto graphics memory that rendered portion of scene is loaded from graphics memory to a memory such as frame buffer shown in . GPU may repeat the process of executing the command stream rendering the trianges of the bin onto graphics memory and loading the rendered portion of the scene from graphics memory to a frame buffer for each bin to render the entire scene .

GPU may also determine which triangles in the bin are actually visible in the final rendered scene by performing a binning pass. For example some triangles may be behind one or more other triangles and will not be visible in the final rendered scene. In this way triangles that are not visible need not be rendered for that bin.

GPU may determine which triangles intersect each bin by for each bin identifying primitives that intersect that bin including determining the position of the vertices of the primitives. GPU may determine the position of the vertices by using a simplified vertex shader in its graphical pipeline that only includes instructions that affect the position of the vertices. For example color instructions texture coordinates and other instructions that do not affect the position of primitive vertex may be removed from the simplified vertex shader. GPU may also use coarse rasterization rather than fine rasterization to determine an approximate depth of each primitive. Coarse rasterization calculates a depth value at a lower precision e.g. using a lower number of bits than fine rasterization. Only approximate depth values may be necessary to determine if a primitive is visible in the bin.

Besides using the binning pass to determine the primitives contained in each bin GPU may also use the binning pass to generate a visibility stream that indicates whether or not specific primitives in the bin are actually visible in the final rendered scene. For example some primitives may be behind another primitive in the scene and will not be visible in some scenarios e.g. when the primitive in front is opaque or when no blending is used . More specifically a primitive may not be visible in the final rendered scene in a particular bin if the primitive is backface culled if the primitive does not hit the bin area or if the primitive is occluded by a depth test such as a low resolution Z check. Performing a binning pass may include executing commands that cause GPU to perform a simplified version of a graphics pipeline but with the additional step of updating a visibility stream for each primitive in the bin based on a depth test Z test and any additional tests that determines whether or not the primitive is visible in the final rendered scene.

While performing a particular rendering pass the pixel data for the bin associated with that particular rendering pass may be stored in a graphics memory such as graphics memory shown in sometimes called a bin buffer . After performing the rendering pass GPU may transfer the contents of graphics memory to frame buffer . In some cases the GPU may overwrite a portion of the data in frame buffer with the data stored in graphics memory . In other cases GPU may composite or combine the data in the frame buffer with the data stored in graphics memory . After transferring the contents of graphics memory to frame buffer GPU may initialize the graphics memory to default values and begin a subsequent rendering pass with respect to a different bin.

In the example of device may include processor system memory and GPU . For purposes of brevity processor system memory and GPU are not further described with respect to as these components have been previously described with respect to . Device may also include display processor transceiver module user interface and display . Transceiver module and display processor may both be part of the same integrated circuit IC as processor and or GPU may both be external to the IC or ICs that include processor and or GPU or may be formed in the IC that is external to the IC that includes processor and or GPU .

Device may include additional modules or units not shown in for purposes of clarity. For example device may include a speaker and a microphone neither of which are shown in to effectuate telephonic communications in examples where device is a mobile wireless telephone or a speaker where device is a media player. Device may also include a video camera. Furthermore the various modules and units shown in device may not be necessary in every example of device . For example user interface and display may be external to device in examples where device is a desktop computer or other device that is equipped to interface with an external user interface or display.

Examples of user interface include but are not limited to a trackball a mouse a keyboard and other types of input devices. User interface may also be a touch screen and may be incorporated as a part of display . Transceiver module may include circuitry to allow wireless or wired communication between device and another device or a network. Transceiver module may include modulators demodulators amplifiers and other such circuitry for wired or wireless communication.

In some examples GPU may store a fully formed image in system memory . Display processor may retrieve the image from system memory and output values that cause the pixels of display to illuminate to display the image. Display may the display of device that displays the image content generated by GPU . Display may be a liquid crystal display LCD an organic light emitting diode display OLED a cathode ray tube CRT display a plasma display or another type of display device.

In one or more examples the functions described may be implemented in hardware software firmware or any combination thereof. If implemented in software the functions may be stored on or transmitted over as one or more instructions or code on a computer readable medium. Computer readable media may include computer data storage media or communication media including any medium that facilitates transfer of a computer program from one place to another. Data storage media may be any available media that can be accessed by one or more computers or one or more processors to retrieve instructions code and or data structures for implementation of the techniques described in this disclosure. By way of example and not limitation such computer readable media can comprise RAM ROM EEPROM CD ROM or other optical disk storage magnetic disk storage or other magnetic storage devices. Disk and disc as used herein includes compact disc CD laser disc optical disc digital versatile disc DVD floppy disk and Blu ray disc where disks usually reproduce data magnetically while discs reproduce data optically with lasers. Combinations of the above should also be included within the scope of computer readable media.

The code may be executed by one or more processors such as one or more digital signal processors DSPs general purpose microprocessors application specific integrated circuits ASICs field programmable logic arrays FPGAs or other equivalent integrated or discrete logic circuitry. Accordingly the term processor as used herein may refer to any of the foregoing structure or any other structure suitable for implementation of the techniques described herein. In addition in some aspects the functionality described herein may be provided within dedicated hardware and or software modules configured for encoding and decoding or incorporated in a combined codec. Also the techniques could be fully implemented in one or more circuits or logic elements.

The techniques of this disclosure may be implemented in a wide variety of devices or apparatuses including a wireless handset an integrated circuit IC or a set of ICs i.e. a chip set . Various components modules or units are described in this disclosure to emphasize functional aspects of devices configured to perform the disclosed techniques but do not necessarily require realization by different hardware units. Rather as described above various units may be combined in a codec hardware unit or provided by a collection of interoperative hardware units including one or more processors as described above in conjunction with suitable software and or firmware.

Various examples have been described. These and other examples are within the scope of the following claims.

