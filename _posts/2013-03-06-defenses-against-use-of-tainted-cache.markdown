---

title: Defenses against use of tainted cache
abstract: Systems, methods, and computer readable media are described for validating objects stored in a web cache. In one embodiment, a computing device caches objects received while accessing networked content over a network. The computing device generates a description of conditions associated with the caching of the objects. When the computing device accesses networked content via a second network, the computing device or a remote server connected thereto utilizes the description to determine whether an object in the cache is trusted or untrusted. The server manages a policy that defines rules for making the determination. The policy can be generated based on descriptions received from a plurality of devices.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09471533&OS=09471533&RS=09471533
owner: Amazon Technologies, Inc.
number: 09471533
owner_city: Seattle
owner_country: US
publication_date: 20130306
---
This application is related by subject matter to that which is disclosed in the following commonly assigned application U.S. patent application Ser. No. 13 787 553 filed Mar. 6 2013 entitled SERVER DEFENSES AGAINST USE OF TAINTED CACHE and U.S. patent application Ser. No. 13 787 576 filed Mar. 6 2013 entitled CACHE VALIDATION AS A SERVICE . The entirety of each application is hereby incorporated by reference herein.

Web caching is a commonly used technique implemented in web browsing. The technique involves a client temporarily storing objects downloaded from a server for later retrieval. The technique may also involve a proxy located between the client and the server and configured to temporarily store the downloaded objects. Web caching typically improves the quality of services associated with the delivery of objects to the client. The improvements include reduced bandwidth consumption reduced server load and reduced latency.

Web caching however does not typically prevent an unauthorized entity from serving tainted objects. For example the unauthorized entity may be positioned to intercept and modify network traffic within a computing environment. In such situations the unauthorized entity can serve the tainted objects that the client or the proxy caches. When the tainted objects are later retrieved and executed within the same or a different computing environment the unauthorized entity can overcome security settings associated with the computing environment.

The following detailed description is directed to technologies for validating cached objects. Generally cached objects can be validated against parameters that are defined by the objects author and embedded within the cached objects. The cached objects can also be validated against parameters that are defined by a client device that caches the objects. The client defined parameters can be embedded within the cached objects or can be stored as a file associated with the cached objects and can describe a context associated with the caching. The description includes any of for instance information about a server from which the objects were downloaded information about a network over which the objects were downloaded and information about the client device.

To validate the cached objects a policy may be employed. A policy server may collect parameters associated with the cached objects from a plurality of client devices to generate the policy. The validation of the cached objects may be executed against the policy locally on the client device or remotely on the policy server or may be distributed between the client device and the policy server. For example the policy server can push the policy to the client device can provide the policy upon request to the client device or can validate the cached objects of the client device.

The validation can be optimized to minimize costs associated with available resources and infrastructure. Such costs include for instance network bandwidth and resource loads. By way of example when the client device detects a type of network that communicatively couples the client device and the policy server the client device transmits information associated with its cached objects to the policy server and in response receives a validation service from the policy server.

To better understand various embodiments of the present disclosure relevant aspects of caching are described herein below. Caching is a technique for the temporary storage of objects such as content documents pages images multimedia video audio HTML files cascading style sheets libraries plug ins JavaScript scripts or other files downloaded when a network based resource is visited. The objects can be used to satisfy subsequent requests to access the same or a different network based resource.

Caching techniques can be used by various systems including a browser of a computing device a proxy server a content delivery network CDN or a search engine. For example the browser can store objects downloaded from a visited network based resource such as a web based resource or a web site in a cache of the computing device. When the browser revisits the same or a different web site the browser may determine whether the objects in the cache are valid or invalid. The valid objects may be reused. On the other hand the invalid objects are not used until they are refreshed.

In the case of caching by a proxy server the proxy server caches the objects on behalf of the computing device. For example the proxy server can be located between the computing device and the network based resource typically near a network gateway. When the computing device requests the objects from the network based resource the proxy server delivers the objects from its cache to the computing device.

In a CDN architecture the objects are stored in cache at multiple datacenters. When the computing device connects to a datacenter to access content objects associated with the content are served from the cache of the datacenter.

Web crawling by a search engine can also be thought of as a caching technique. In this technique the search engine methodically browses websites to cache objects. The search engine can satisfy the computing device s request for objects of a particular website from the cache.

Other caching techniques may also be implemented and may include forward caching and reverse caching. In forward caching frequently accessed objects are stored on a local network for retrieval by computing devices internal to the local network without visiting an external network. As such forward caching reduces bandwidth consumption on the external network and accelerates access of the computing devices to the objects. In reverse caching frequently accessed objects on the local network are cached at the local network s edge for consumption by computing devices on the external network. As such reverse caching reduces network bandwidth consumption on the local network and accelerates access of the external computing devices to the objects.

To further improve the efficiency of accessing and retrieving cached objects the caching techniques may be implemented across multiple servers configured to store the cached objects. For example the cached objects can be distributed across a plurality of servers located throughout a network. In another example the servers can be located at different nodes of the network in a hierarchical fashion. The cached objects are first served from a node at a lower level in the hierarchy. If the cached objects are unavailable from the node in the lower level of the hierarchy the cached objects are served from a node at a higher level in the hierarchy.

When multiple servers are used as described above various protocols can be implemented in order to retrieve the cached objects from one of the servers before resorting to an external network if the cached objects are not found. These protocols allow the servers to communicate in order to locate the cached objects and include cache array routing protocol CARP Internet cache protocol ICP hypertext caching protocol HTCP web cache coordination protocol WCCP and cache digests.

As described above the cached objects can comprise content documents pages images multimedia files video files audio files libraries plug ins scripts and the like and can be used to interact with network based resources such as web sites servers that host network based applications and the like. These objects commonly comprise software code or scripts such as hypertext markup language HTML JavaScript cascading style sheets CSS and document object model DOM files.

HTML is the main markup language for displaying web pages and other information in a browser. It allows objects to be embedded within a web page and can be used to generate interactive forms. Scripts in non HTML languages such as JavaScript can also be embedded in HTML. Further HTML enables structured documents by denoting structural semantics for text such as headings paragraphs lists links quotes and other items.

JavaScript is a scripting language that adds interactivity to HTML pages by inserting scripts into HTML pages for execution by the browser. JavaScript commonly employs jQuery which is a multi browser JavaScript library that simplifies the scripting of HTML. JQuery s syntax allows designs of dynamic web pages and applications by simplifying rules that are executed to navigate a document select DOM elements create animations handle events develop applications and create plug ins. These plug ins comprise any of for example Ajax helpers webservices datagrids dynamic lists XML and XSLT tools drag and drop events cookie handling and modal windows.

Cascading Style Sheets CSS is a style sheet language used for describing the appearance and layout of a document written in a markup language such as HTML XML XHTML and the like. CSS separates document content typically written in the markup language from document presentation that includes elements such as layout colors and fonts. This separation enables multiple pages to share formatting and a same page to be displayed in different formats.

The Document Object Model DOM is an application programming interface API for HTML XML and XHTML data and documents. It defines the logical structure and the methods for accessing and manipulating the documents. DOM allows documents to be navigated and elements therein to be edited deleted or added.

When a cached object is retrieved it is typically validated prior to being reused according to various validation techniques. These techniques mostly rely on attributes that are associated with the object prior to its caching and that are defined by an author of the object or by a network based source from which the object is cached. For example a designer of a web page from which the object is cached can insert a set of attributes in HTML tags of the web page whereas the web page can apply protocols such as hypertext transfer protocol HTTP 1.0 and 1.1 to define another set of attributes.

The attributes can comprise freshness and control rules that define when the cached object is valid and when it needs to be revalidated. The revalidation may comprise a browser fetching a new copy of the object or checking with a server to determine whether the cached version of the object is still authorized. The freshness attributes define a period of time in which the cached object can be used. If the period expires the cached object becomes stale and must be revalidated. These attributes can be defined in for example an HTTP Expires or Last Modified header. On the other hand the control attributes include directives to declare what objects in a document are cacheable modifications of the expiration mechanism and revalidation and reload controls and can be defined in for instance an HTTP Cache Control header. For example a server can generate an entity tag ETag that uniquely identifies an object and can update the ETag every time the object is modified. In this way a computing device may determine when an object in its cache is valid based on whether the cached object is associated with the most up to date ETag.

The above validation techniques may be insufficient in certain situations. For example if an unauthorized third party is capable of intercepting communications between a client device and a server the unauthorized third party may re route requests of the client device to another computing device or modify responses from the server. In this case the unauthorized third party may serve tainted objects to the client device which in turn may cache the tainted objects in its local cache. The tainted objects may otherwise have proper validation attributes that are defined by the original author of the objects or by the unauthorized third party. Because the validation is executed against these attributes the client device would unknowingly determine that the tainted objects in its cache are valid for reuse.

For example the tainted objects may have a malicious script that inserts an advertisement when executed. The freshness attributes of the tainted objects may have an extended expiration date e.g. a week from the time of caching the tainted objects. When the client device attempts to visit a web page within the extended time period the tainted objects are determined to be valid and may be used to interact with the web page. Thus the client device executes the malicious script and causes the advertisement to be displayed within the web page. This problem of not checking for potentially tainted objects is exacerbated when the client device moves between an insecure and secure network as described herein below.

Various aspects of the disclosure are described herein with regard to certain examples and embodiments which are intended to illustrate but not to limit the disclosure. It should be appreciated that the subject matter presented herein may be implemented as a computer process a computer controlled apparatus a computing system or an article of manufacture such as a computer readable storage medium. While the subject matter described herein is presented in the general context of program modules that execute on one or more computing devices those skilled in the art will recognize that other implementations may be performed in combination with other types of program modules. Generally program modules include routines programs components data structures and other types of structures that perform particular tasks or implement particular abstract data types.

Those skilled in the art will also appreciate that the subject matter described herein may be practiced on or in conjunction with other computer system configurations beyond those described herein including multiprocessor systems microprocessor based or programmable consumer electronics minicomputers mainframe computers handheld computers personal digital assistants e readers cellular telephone devices special purposed hardware devices network appliances and the like. The embodiments described herein may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment program modules may be located in both local and remote memory storage devices.

A computing node such as a user node a client node an administrator node or a server node may be implemented on a wide variety of computing environments such as commodity hardware computers virtual machines computing clusters and computing appliances. Any of these computing devices or environments may for convenience be described as computing nodes. Similarly for convenience a computing node may be referred to as a computing device or an electronic device.

In a basic configuration the system of comprises a client device that may connect to a first network and then later connect to a second network . For example first network may be a network operated by a business such as a coffee shop that offers network connectivity and second network may be a private network such as a corporate network. The system also comprises an administrator device that may be configured to manage access of client device to second network and an unauthorized device that may be positioned to intercept data exchange between client device and a server over first network .

Devices and may comprise a desktop computer a laptop computer an electronic device a smartphone a tablet or any other general or specialized device capable of interacting with servers and over networks and . Client device may be associated with an authorized user and may cache objects accessed at servers and such as objects of a first website hosted on server and objects of a second website hosted on server . Likewise administrator device may enable an administrator to manage the use of the cached objects by the authorized user over second network . Unauthorized device may allow a hacker to inject tainted objects into objects cached by client device over first network .

Servers and may comprise any devices suitable for interacting with devices and over networks and and may be configured to provide web based services such as hosting websites and . For example servers and may be components within a web server or components within a datacenter. In another example servers and may also be the same computing device. Similarly websites and may be the same website or maybe two distinct websites.

Networks and may comprise any type of communications networks that are suitable for providing communications and transmitting data between devices and and servers and and may comprise a combination of discrete networks which may use different technologies. For example networks and may comprise a cellular network a WiFi broadband network a local area network LAN a wide area network WAN a telephony network a fiber optic network or combinations thereof. In an example embodiment the WiFi broadband network may be adapted to communicate with the Internet.

Networks and may also be associated with security layers and respectively. These security layers may differ from one another and may define parameters or levels for enabling access of client device to networks and . For example first network may be an insecure network or a public network accessible to all users with minimum or no authentication. By comparison second network may be a secure network or a private network that has various security safeguards that are defined in security layer and that authenticate the authorized user. The safeguards may include for example firewalls encryption authentication credentials communication protocols filters and the like. A virtual private network may be used to extend a private network s operation over a public network. Determining whether a network is secure or insecure may be based on various parameters that may include for example information about the network s security layer whether it is a private or public network and an identifier that may associate the network with a whitelist or blacklist managed by administrator device .

The authorized user may operate a browser on client device to interact with first website over first network . The browser caches objects of first website in a cache of client device shown as web cache in . The cached objects in web cache may have attributes that are defined by server or by an author of first website and that may be configured to allow the browser to validate the cached objects during a subsequent use.

At a later time the authorized user may direct client device to connect to second network . The connection may involve authenticating the authorized user based on security layer . When the authorized user directs the client device to connect to second website over second network second website may use the objects that were cached in associated with first website . As such instead of downloading the objects the browser may fetch and validate them from web cache . If the browser determines that the objects are valid the browser may use the objects to access second website . If the browser determines that the objects are invalid the browser refreshes web cache by replacing the invalid objects with objects from second website .

As noted above a malicious or undesired program may have been installed on a network device in first network that causes the network device to intercept communications between client device and server and route the requests to unauthorized device or cause the network device to respond to client device as if it was server . After the communications are intercepted the network device or unauthorized device may serve tainted objects to client device that are then cached in web cache . For example when the browser of client device attempts to connect to first website over first network unauthorized device may spoof the browser by providing objects from an alternate website that appears to come from first website . As such the browser may accept and store in web cache tainted objects that may include malicious code. At a later time when the browser connects over second network to the same or another website such as second website the browser may fetch the tainted objects from web cache and may unsuspectingly execute the malicious code.

To improve browser security additional data may be associated with the cached objects in web cache and used to verify whether the cached objects are trusted. For example even when client device validates the cached objects based on their freshness attributes client device may further verify the cached objects based on the additional data. If the verification indicates that the cached objects are trusted client device may allow their use. On the other hand if the verification indicates that the cached objects are untrusted client device may disable their use and may attempt to refresh them. The additional data associated with the cached objects may be generated by a cache validator operating on client device .

Cache validator may be integrated with the browser or with an application other than the browser or may be a standalone application and may be configured to verify cached objects in web cache as described herein below. In an example cache validator may include scripts stored in an HTTP client library or may be provided within an application software development kit SDK . Although the following paragraphs describe that cache validator verifies the cached objects upon detecting that the browser is requesting to reuse these object objects this verification can occur when client device boots up based on a predefined rule or upon detection of a network condition.

In one example cache validator may associate verification information with the cached objects of web cache . The verification information may be in the form of metadata that describes conditions in which the objects were retrieved and cached. The metadata may be stored as a caching context in web cache or alternatively in a metadata file associated with web cache . For instance the metadata file may be located in the same or a different local folder that stores web cache on client device . Cache validator can also facilitate edits to the metadata by for example enabling the authorized user to retrieve and annotate caching context with additional verification information.

As used herein caching context generally includes a description of a context in which the objects were stored in a cache such as web cache . More particularly caching context may include a variety of information about first website server first network the authorized user client device the connection between these different devices and the like. For example an address such as a uniform resource locator URL of first website an internet protocol IP address of server or a media access control MAC address of server and a description of a digital certificate associated with first website or server may be included in caching context .

The information about first network may contain an identifier of first network a description about security layer data about an entity or an administrator of first network a geographic location of first network and the like. For example the identifier may be a service set identifier SSID an IP address or a MAC address of a wireless access point associated with first network . The description of security layer may indicate whether first network is a public or private network and information about the type of authentication used by first network . When first network is associated with an entity such as a store or a company an identification of the entity and its geographic location can be included in caching context .

Caching context may also include an identifier of client device such as its IP or MAC address a description of an operating system of client device and information about the browser. Likewise the authorized user may be described in caching context by using his or her user name privileges and function. For example caching context may indicate whether the authorized user is an administrator of first network .

The information about the connection between the various devices captured in caching context may include a trace route of the network connection between client device and website a latency or response time associated with computing device s access to website and information about nodes or gateways between client device and server . Also caching context may include a timestamp identifying the time when a particular object in web cache were downloaded and a geographic location of client device at that time.

When the authorized user directs client device to connect to second network and causes the browser to access network based resources via second network the browser may attempt to reuse previously cached objects from web cache . In this case cache validator can verify whether the cached objects may be trusted or untrusted based on caching context . For example cache validator may compare the current network conditions to the attributes stored in caching context . The current conditions may be stored as a connection context that may include similar attributes to those stored in caching context . For example when the browser connects to second website connection context may include information about second website server second network client device the authorized user and information about the connection between these modules. As used herein connection context generally includes a description of a context in which cached objects from web cache will be reused by client device . Connection context can but need not be saved on client device .

Cache validator may have a policy e.g. a set of rules that defines when the cached objects in web cache should be considered trusted based on a comparison of caching and connection contexts and . For example the policy may define a minimum set of information that need to match between the two contexts. In one example cache validator can compare requirements of security layer to requirements of security layer as described in caching context and connection context respectively. If cache validator determines that first network is more secure than second network e.g. an identifier for first network is stored on a whitelist whereas an identifier for second network is not cache validator may declare cached objects in web cache that were obtained while connected to first network as trusted and enable the browser to reuse these cached objects over second network . In another example cache validator may determine that the authorized user was acting in an administrator function when objects were cached in web cache and is currently acting as a user with limited privileges on second network . In such an example the application may determine that these cached objects in web cache are trusted and again enable the browser to reuse them on second network . These various examples are merely illustrative and other implementations may be utilized based on the information that is included in caching context and that is available to cache validator when client device is connected to second network .

Various actions may be performed by cache validator or client device when the cached objects in web cache are determined to be untrusted. For example cache validator may fetch new versions of the cached objects while connected to second network or may purge web cache all together and download new objects from second website over second network . Also cache validator may also display a warning to the authorized user describing a risk associated with the untrusted objects.

Administrator device may also be configured to assist cache validator in verifying whether the cached objects in web cache are trusted. For example administrator device may comprise a policy for verifying objects based on context information. As such administrator device may receive caching context from client device may receive or derive connection context and may compare caching and connection contexts and to determine whether policy is met. If the policy is met administrator device may return an indication that the cached objects in web cache are trusted. Otherwise administrator device may return an indication that they are untrusted. If untrusted administrator device may also instruct client device to refresh the cached objects in web cache may transmit new objects to client device with instructions to purge and replace corresponding cached objects in web cache or may direct client device to a trusted server from which new objects may be retrieved.

Operation illustrates client device generating and storing a context that includes information describing conditions under which the objects were cached. For example the information could indicate a network identifier for the first network a timestamp etc. Operation illustrates client device connecting to second network that may be associated with a rule. The rule may require client device to automatically verify objects in its web cache when the connection is established or to periodically perform such verification. Operation may be followed by operation A or operation B described in more detail below depending on whether the verification is performed locally on the client device or is distributed between client device and a policy server associated with second network .

When the verification is performed locally on client device Operation A illustrates client device generating a context associated with the connection to second network . For example the context can include an identifier for the second network a timestamp indicating when the connection to the second network was made etc. Following Operation A operation A illustrates client device comparing the stored context to this generated context. Client device may determine that the two contexts are compatible based on a policy. Such a policy can be embedded within cache validator stored locally at client device or retrieved from the policy server. Operation A may be followed by operation A when the contexts are compatible. Otherwise operation A may be followed by operation B.

Operation A illustrates client device determining that the cached objects e.g. objects within the cache that were obtained via the first network are trusted and may be used over second network . Client device may further validate the cached objects based on attributes embedded therein by an author of the objects. Operation B illustrates client device determining that the cached objects are untrusted.

When the verification is distributed between client device and the policy server Operation B illustrates client device transmitting the generated context to the policy server. The policy server may store a policy that defines requirements for determining whether cached objects are trusted or not. In one example the policy server compares the received context to the policy and returns an assessment to client device . In such a situation operation B may be followed by operation B. In another example the policy server may return the policy or relevant sections of the policy to client device based on the received context. In such a situation operation B may be followed by operation C.

Operation B illustrates client device receiving an indication from the policy server whether the cached objects are trusted. The instructions may include a risk or a likelihood of having malicious code inserted in the cached objects. The instructions may also authorize client device to use the cached objects when determined to be trusted. If the cached objects are untrusted the instructions may require client device to fetch new objects from second website or from a trusted source. Operation A illustrates client device determining whether the received instructions indicate that the cached objects are trusted. If the cached objects are trusted operation A may be followed by operation A. Otherwise operation A may be followed by operation B.

Operation C illustrates client device receiving the policy from the policy server. In such a case client device may store the policy locally. The policy may be integrated with cache validator . Operation B illustrates client device comparing the stored context to the policy. Operation B may be similar to operation A. More particularly client device may determine whether a minimum set of requirements that are defined in the policy are satisfied by the stored context information. If the requirements are met client device may determine that the stored context and the policy are compatible indicating that the cached objects are trusted. Otherwise client device may determine that they are incompatible indicating that the cached objects are untrusted. Operation B may be followed by operation A when the cached objects are trusted. Otherwise operation B may be followed by operation B.

Another example of a system in which the disclosed techniques may be employed is depicted in . In particular illustrates one example embodiment of a system for providing server based verification of cached objects. In a basic configuration the system may comprise some or all elements of the system of and may comprise a managed infrastructure that is configured to control access of a plurality of user devices A C to other components of managed infrastructure . For instance a user may direct user device A to access data controlled by managed infrastructure or to connect to a public server through managed infrastructure to cache objects from a website hosted on public server .

When connected to managed infrastructure user device A may use cached objects from user cache A and a context A to interact with network based services internal and external to managed infrastructure . User cache A and context A may comprise some or all elements of web cache and caching context of respectively. Similarly user device B may also store user cache B and a context B.

To control access of user devices A C to components of managed infrastructure managed infrastructure may comprise a manager device that administers access to a managed network and to a managed server . Manager device may enable a manager to provide administrative functions that can include for example setting a security layer that authenticates user devices A C generating and updating a network access policy and the like. Network access policy may define rules that allow user devices A C to connect to managed network and that enable cached objects from user caches A and B to be used by applications running on user devices A C. For example the cached objects from user caches A and B may be used to interact with an internal website hosted on managed server and with an external website to managed infrastructure such as website depending on network access policy .

In an embodiment managed server may be configured as a cache server that hosts objects in a trusted web cache for replacing the cached objects in user caches A and B when they are untrusted or otherwise unusable. For example when user device A connects to the managed network or connects to website over managed network particular objects stored in user cache A may be determined to be untrusted. In such a situation objects from trusted cache may be sent to user device A to replace the particular objects in user cache A. In another example when user device C connects to website over managed network user device C may not have an object in its cache that is usable with respect to website . In such a situation a corresponding object from trusted cache can be sent to user device C.

To determine whether an object stored in a cache is trusted a context associated with the object may be compared to network access policy . In an embodiment network access policy can be generated and updated independently of information available from user devices A C. For example the manager may define a set of rules that comply with the overall security requirements of managed network . In such a situation network access policy may comprise a list of trusted sources such as websites servers networks and computing devices. A source may be added to the list of trusted sources for a number of predetermined reasons. For example a source may be added when the manager determines that it meets or exceeds the security requirements. As another example a source may be added to the list of trusted sources based on an agreement between the manager and an administrator of that source. The agreement may include for example a certification by a third party or by an auditor of the security credentials of the source.

When user device A connects to managed network context A may be analyzed with respect to network access policy . The analysis may be performed by manager device . Context A may comprise a plurality of elements such as an identification of one or more of website public server user device A and a network over which an object in user cache A was downloaded. To determine that a particular cached object in user cache A is trusted network access policy may require a number of conditions from context A to match a number of sources from the list of trusted sources. For example network access policy may require at least one condition all conditions or some subset of conditions in context A to be found on the list of trusted sources. In another example network access policy may include a predefined threshold that is used to determine whether the cached object is trusted. Manager device may determine a likelihood of having a trusted object based on the frequency of elements matched between the list of trusted sources and the context. If the likelihood is larger than the predefine threshold manager device may declare that the cached object is trusted.

Network access policy can also be generated and updated based on information received from user devices A C. For example manager device may receive contexts over time from user devices A and B such as context A and B. Manager device may analyze and correlate these contexts to generate a history of the conditions contained therein. The history may be saved in network access policy . To determine whether a particular cached object in user cache A is trusted manager device can compare context A to the history. For instance the history may indicate that a particular public network is frequently used in caching untrusted objects. Network access policy may indicate that such a network should not be trusted. Thus when context A comprises an identification of this public network manager device may determine that the cached object is untrusted.

Network access policy can be further generated and updated based on information received from both the manager and user devices A C. For example the manager may identify a particular network that is a likely untrusted source of untrusted objects whereas the analysis of received contexts A and B may indicate that objects cached within a timeframe from the particular network are actually tainted. As such network access policy may be updated to list the particular network as a potential source of untrusted objects and to indicate that all objects cached from the source within the time frame are untrusted.

In addition to receiving contexts A and B manager device may also receive the cached objects in user caches A and B. The received objects may be analyzed to update network access policy . For example manager device may determine that a particular website is popular among users based on contexts A and B. In that instance manager device may access cache objects from the popular website over managed network . These objects can be compared to the cached objects in user cache A by comparing for example their hashes to determine whether there are differences. If differences exist manager device may tag the cached objects in user cache A as suspicious and may update network access policy to indicate that the popular website is suspicious.

Another technique for using hashes of cached objects includes comparing hashes received from user devices A C. For example manager device may receive from user devices A C descriptions associated with content of a particular object and descriptions associated with networks over which the particular object was cached. Each of the content descriptions may include a hash of the content and each of the network descriptions may include an identifier of the network. To determine whether the particular object cached at user device A is trusted manager device may compare the hash of the content received from user device A to the hashes of content received from user devices B C and may determine that the particular object is untrusted when there are differences. Otherwise manager device may compare the identifier received from user device A to the identifiers received from user devices B C and may determine that the particular object is untrusted when the identifier changes. Otherwise manager device may receive and compare context A to network access policy .

Independent of the technique used to generate and update network access policy the policy comprises a set of rules used to determine whether a cached object is trusted or untrusted. Network access policy also comprises instructions about a use of the cached object based on whether it is trusted or not. The instructions may direct a computing device to use the cached object when trusted or to flush the cached object when untrusted. To use network access policy manager server may share it in various ways with user devices A C.

One way for sharing network access policy with user devices A C is to push the policy to the devices. For example managed network may be associated with a private network of a company and user devices A C may be mobile computing devices associated with employees of the company such as laptop computers tablets smart phones and the like. In this example network access policy may be downloaded to the mobile computing devices when they are assigned to the employees. When network access policy is updated updates to the policy can be sent to the mobile computing devices. Further because network access policy is saved locally on the mobile computing devices the verification of whether the cached object is trusted can be performed locally on the mobile computing devices. As such the mobile computing devices need not transmit contexts to manager device to verify the cached object.

Another way for providing sharing network access policy includes transmitting the policy to user device A upon detection of a connection between manager device and user device A. This transmission may also occur upon demand. For example when user device A connects to managed network user device A may request and download network access policy from manager device .

Network access policy may also not be provided to user device A. Instead manager device may receive and analyze context A against network access policy and may accordingly return a service to user device A. The service may depend on the rules and the instructions defined in network access policy . When the cached object is trusted the service may include for instance an indication that the object is trusted or an authorization to use the object within managed infrastructure . When the cached object is untrusted the service may include for instance an indication that the cached object is untrusted an indication of a likelihood that the cached object is untrusted instruction not to use the cached object within managed infrastructure a permission to use the cached object outside of managed infrastructure instructions to fetch a new object over a trusted network or from a trusted source.

As described above the trusted source may be for example managed server that may include trusted cache . When the cached object is untrusted user device A may connect to managed server and retrieve a copy of the object from trusted cache . If the copy is not available in trusted cache managed server can download it from a website over managed network .

The use of network policy may also not be limited to manager device and user devices A C. For example network access policy may comprise instructions for reporting a likelihood of tainted objects to third parties. The third parties may comprise an auditor that assesses web securities or an administrator of a network over which the tainted objects were cached. When network access policy indicates that objects cached over a particular network are tainted network policy may generate a notification that identifies the particular network the likelihood of a network hacking or a violation of the policy and may direct manager device to automatically transmit the notification to the administrator of the particular network.

Operation A illustrates the verification service determining whether the policy may be shared with a computing device associated with managed infrastructure . This determination may be based on various parameters including for example whether the computing device is managed by the verification service conditions of a network connection between the verification service and the computing device a configuration of the verification service and the like. If the policy is shared the verification server may push the policy to the computing device that may use the policy to locally verify cached objects in its cache as shown in operation B. If the policy is not shared the verification services may verify the cached objects on behalf of the computing device and may return an indication of the verification to the computing device as shown in operations C B. Although illustrates a decision under operation A one skilled in the art will appreciate that operation A is optional. For example one skilled in the art may implement the verification service to always verify the cached objects on behalf of the computing device.

Operation B illustrates the verification service transmitting the policy to the computing device. In one example the verification service can push the policy or updates thereto to the computing device when the computing device is associated with managed infrastructure . In another example the verification service may transmit relevant sections of the policy to the computing device based on a context received from the computing device. Once the policy is pushed to the computing device it can be used locally at the computing device. On the other hand operation C illustrates the verification service receiving from the computing device information about its cached objects. The information may include for example a list of the cached objects and contexts that describe conditions under which the cached objects were cached at the computing device.

Operation illustrates the verification service comparing the received information to the policy. For example to determine whether a cached object of the list of cached objects is trusted the verification service may compare the cached object s context to the policy. The context may identify the computing device a user of the computing device and the network over which the cached object was downloaded. The policy may weigh these parameters differently. For instance the context is declared to be compatible with the policy when both the computing device and the user are found or when only the network is identified on the list of trusted sources. As such the identity of the network is accorded a larger weight than the individual identities of the computing device and the user. The verification service may also determine a likelihood of the cached object being untrusted based on for example a frequency associated with occurrences of the parameters on the list of trusted networks.

Operation illustrates the verification service determining whether the cached object is trusted or untrusted based on the comparison of the context and the policy. For example the cached object is trusted when the context is compatible with the policy or when the determined likelihood exceeds a predefined threshold. In such a case operation may be followed by operation A. Otherwise the cached object is declared as untrusted and operation may be followed by operation B.

Operation A illustrates the verification service transmitting instructions to the computing device indicating that its cached object is trusted. The verification service may also use the determination that the cached object is trusted as a factor in authenticating a user of the computing device by for example providing the computing device with access to the managed network when the object is trusted. The verification service may further authorize the computing device to use the cached object to interact with network based resources over the managed network.

On the other hand Operation B may be performed to manage the use of the untrusted cached object. When the cached object is untrusted the verification service may indicate to the computing device that its cached object is untrusted and may execute further actions based on the rules defined in the policy. For example the verification service may deny the computing device from accessing the managed network or from using the cached object to interact with the network based resources over the managed network. Operation illustrates the verification service analyzing the context to update the policy. For example parameters of the context can be added to the listed of trusted or untrusted networks based on whether the cached object was found to be trusted or untrusted.

Another example of a system in which the disclosed techniques may be employed is depicted in . In particular illustrates one example embodiment of a system providing verification of cached objects as a service. The system may implement various policy based techniques on a user device or on a policy server for preventing the caching of tainted objects and for verifying cached objects. In a basic configuration the system of may comprise some or all elements of the system of and may comprise a user device configured to access network based resources such as websites A C hosted on web servers A C over a connection facilitated by a network A. User device may cache objects from theses network based resources shown as cache and may generate context describing conditions of caching the objects and information about the cached objects.

The system may also include a trusted server configured to verify the cached objects for user device and cached objects of other computing devices. For each of the devices trusted server may use an application program interface API to customize and configure the verification as a service based on for example an account associated with the device or a user of the device. For instance the verification service provided to a computing device may include pushing or otherwise transmitting policy to the computing device. In comparison the verification service provided to user device may be different and may include an authorization to cache objects a determination whether the cached objects in cache are trusted and a transmission of new objects when the cached objects are found untrusted as described herein below.

In order to determine whether an object is trusted before caching the object in cache trusted server may compare policy can to a current context of user device prior to the caching. The current context may describe conditions of a current connection between user device and a network based resource from which the object is to be cached. If the conditions of the current context meet policy user device is allowed to cache the objects in cache . Otherwise user device is prohibited from caching the objects. This pre caching verification may also be performed by user device if policy is stored locally on user device . For example policy may indicate that network A is a trusted network web server A is a trusted web server and web server B is an untrusted web server. Thus when user device connects to web server A over network A and its browser connects to website A the browser is permitted to cache objects of website A in cache . That is because the current context of user device comprises a trusted network and a trusted web server. On the other hand when user device connects to web server B over network A and the browser connects to website B the browser is not authorized to cache objects of website B in cache . That is because the current context of user device comprises an untrusted web server.

On the other hand to verify whether an object that has already been cached in cache is trusted trusted server may compare the context associated with the cached object such as context to policy . This type of verification can be performed in real time periodically or at time intervals. In an example user device may be configured to automatically request the verification service from trusted server when the object is cached. In another example user device can be configured to periodically request the verification service from trusted server to verify the cached object. Similarly the user account managed at trusted server can be configured to periodically trigger trusted server to verify the cached object in cache . If context has not already been received by trusted server prior to the trigger trusted server may automatically request context from user device . In yet another example trusted server may request user device at time intervals to verify the cached object and to transmit a report of the verification to trusted server . If user device fails to verify the cached object trusted server may execute additional actions such as requesting user device to transmit context or limiting access of user device to a managed infrastructure.

A time interval associated with the service for verifying cached objects in cache can be derived from parameters associated with user device and trusted server . The parameters may comprise a time of day an identification of a network an available bandwidth a data cost an idle resource at user device a geographic location of user device an available resource at trusted server and the like. The parameters may also be associated with a change in a network connection between user device and trusted server . The change may be associated with a transition from a metered network e.g. cellular to an unmetered network e.g. WiFi a change of network connectivity the reaching of a particular time window a change in network usage rates e.g. rates of an off peak period and of a peak period and the like.

For example the browser at user device may be configured to transmit context to trusted server every night between 12 00 am and 4 00 am. The user account may be configured to trigger trusted server to request context from user device when trusted server detects that a specific network such as network B connects user device thereto. User device may transmit context to trusted server when a bandwidth greater than for example 10 Mbps is detected by user device . If user device is associated with a cellular plan that has a data size limit and if the limit is reached user device may transmit context to trusted server only when a WiFi network is detected in order to reduce the data transmission cost. The time interval can be also set such that when user device determines that no data is queued for transmission user device may transmit context to trusted server . Further user device can be configured to transmit context when user device detects that it is within a certain range of a predefined access point. Trusted server may also detect that a resource thereat is available and may allocate that resource to user device and may instruct user device to transmit context . These various examples are merely illustrative and other implementations may be utilized.

Operation illustrates the computing device determining that the condition is met and transmitting the context to the trusted source. Operation may be followed by operation A operation B or operation C depending on an account associated with the computing device. Operation A illustrates the computing device receiving verification whether the cached object is trusted from the trusted source. The verification may comprise an indication whether the cached object is trusted or untrusted and other information and actions related to the indication. Operation A illustrates the computing device deleting and replacing the cached object with a new object when the cached object is found untrusted. The computing device may also use the cached object when it is found to be trusted.

Operation B illustrates the computing device receiving the policy or updates to the policy from the trusted source. The policy may comprise rules for validating the cached object based on the context associated with the cached object. Operation B illustrates the computing device comparing the context to the policy. If the context is compliant with the policy the cached object may be found to be trusted. Otherwise the cached object may be found to be untrusted.

Operation C illustrates the computing device transmitting the cached object to the trusted source. The trusted source may analyze the cached object to determine whether the cached object contains tainted code. Operation C illustrates the computing device receiving a trusted object from the trusted source. For example the trusted source may replace an untrusted cached object with a trusted object and transmit the trusted object to the computing device. The computing device may use the trusted object to interact with the network based resource.

Operation illustrates the trusted source associating the policy with the computing device based on for example an account associated with the computing device and managed at the trusted source. Operation illustrates the trusted source determining a condition associated with transmitting data to the computing device and initiating the verification of the cached object based on the determined condition. Operation illustrates the trusted source receiving the context from the computing device when the verification is initiated. Operation illustrates the trusted source returning a service associated with the verification of the cached object to the computing device based on a comparison of the received context and the policy. The service may include for example instructions to the computing device to retrieve a new object when the cached object is untrusted.

When the policy is associated with the network that the trusted source manages Operation illustrates the trusted source associating the policy with the network and enforcing the policy against the computing device when connected to the network. Operation illustrates the server transmitting relevant sections of the policy to the computing device upon detecting the connection of the computing device to the network. Operation illustrates the server enforcing the policy against a use of the cached object by the computing device to access and interact with the network based resource over the network. For example the trusted source may require the computing device to provide a confirmation that the cached object was verified based on the policy.

In addition to validating an object in a cache of a computing device based on attributes associated with the object and to verifying whether the object is trusted based on a context associated with the object and a policy as described above a service can be configured to provide such validation and verification while optimizing data and bandwidth usages at the computing device. For example the computing device may maintain a summary of cached objects and of attributes associated with the cached objects. The computing device may use the summary to manage the service based on bandwidth requirements. For instance when the summary indicates that a cached object is no longer usable based on its freshness attribute the computing device may determine a favorable network condition and may refresh the cached object based on that condition. This and other techniques for optimizing data and bandwidth usages are described in . More particularly illustrates one example embodiment of a system for optimizing device based services.

The system of may comprise a client device in communication with a server over a first network . Client device may be configured to manage a service for validating objects in its cache based on available resources and infrastructure. More particularly client device may store in its cache objects from a network based resource such as a website hosted on server over first network . As such the cache may comprise objects associated with various attributes such as freshness attributes that define a period of time in which the objects are usable.

To maintain the usability of the objects client device may operate an application such as a browser configured to validate the objects. In an example the application may access the cache of client device and maintain a list of the objects therein. The list may include descriptions or hashes of the objects the attributes and addresses of network based resources from which the objects were cached. To optimize the data and bandwidth usages the application may also include rules that define parameters for validating the objects. The rules may be time and resource based. For example time based rules may require the application to validate only objects in the cache that have expired or that will expire in a certain timeframe such as in a day a week and the like. These rules may also define a frequency and a time of day when the validation can occur to minimize network loads. For example the application may be configured to periodically refresh or replace unusable objects between midnight and 2 00 am over first network .

The resource based rules may relate to the underlying infrastructure of the system of . More particularly these rules may depend on the resources available at client device and on the connection between client device and server . By way of example client device may be associated with a data plan that limits the amount of the data that client device may receive or send over first network on a monthly basis. This data plan may be an input to the resource based rules that may allocate the validation of the cached objects accordingly. For example when the application detects that the limit has been reached for a certain month the application may not refresh the cached objects over first network . Instead the application may utilize a second network to refresh the cached objects or may delay the refreshing over first network until the next month. On the other hand if the application detects that the limit is not reached but that the data plan is about to expire for that certain month the application may refresh the cached objects over first network even when the cached objects have not expired yet. Other device based rules may also be implemented. For instance when client device is performing a function that is independent of refreshing the cached objects such as placing a voice call to another device client device may determine an impact of performing the refresh on the quality of service associated with this function and may reschedule the refresh based on the impact.

Similarly to the device based rules connection based rules may be configured to optimize bandwidth cost and security. For example these rules may dictate a certain network throughput to allow a fast validation. As such when first network does not meet this throughput requirement because for instance it is a third generation 3G cellular network the application may validate the cached objects when a faster network is detected such as second network that may be a fourth generation 4G cellular network. In another example the rules may require the use of an unmetered network to minimize the data cost associated with the validation of the cached objects. For example when first network is a cellular network and second network is a WiFi network the application may not validate the cached objects until client device connects to second network . In yet another example the rules may provide a secure validation by requiring a trusted network over which the validation of the cached objects may be performed. For instance when first network is a public network and second network is a private network the application may refresh the cached objects only when client device is connected second network .

To illustrate this optimization associated with the validation of the cached object describes one example embodiment of a procedure that can be performed by client device of . Operation illustrates client device connecting to a plurality of servers including server over first network and caching objects from a plurality of network based resources including website . Operation illustrates client device generating a summary of the objects contained in its cache. Operation illustrates client device determining that a subset of the objects needs to be validated based on attributes included in the summary. Operation illustrates client device determining whether time and resource based rules are satisfied to validate the subset of objects. This determination may be based on information that includes for example a time of day available resources at client device and the network that client device is connected to. Operation illustrates client device refreshing the subset of objects from the same or different network based resources when the time and resource based rules are met. For example client device may retrieve the addresses of the network based resources from the summary connect to these network based resources check whether the objects are still valid or whether updates thereto are needed download any needed new objects or updates to the cache of client device and update the attributes and the summary.

The validation of cached objects may be further optimized by using an intermediary server located between client device and server . More particularly the intermediary server may be a cache server such as a proxy or CDN server may serve cached objects to client device and may manage some or all aspects of the cached objects of client device . Such architecture may reduce the cost resource and bandwidth usage and may improve the security of client device . For example instead of validating the cached objects by committing various resources and using bandwidth to connect to a plurality of network based resources client device needs only to request the validation from the intermediary server. In turn the intermediary server may connect to the plurality of network based resources or to other network based resources to refresh the cached objects and return the refreshed objects to client device . provides one example embodiment of a system for providing server based validation of the cached objects that takes advantage of this architecture. As shown in the intermediary server is configured as a cache server that may cache and serve objects to client device over first network or second network . Client device may in turn cache the served objects in its cache.

More particularly cache server may connect to server over a third network to cache objects from a network based resource such as website . The cached objects may be transmitted from cache server to client device that may then display website . Server may be further configured to monitor attributes associated of the cached objects and to validate the cached objects based on the attributes. The validated objects may be transmitted to client device depending on time and resource based rules similar to what is described herein above. The various features of the system of are described in more detail herein below.

In an example cache server may be associated with a network based service and may be configured to support a split architecture that distributes browser functionalities e.g. connecting to website retrieving HTML and JavaScript codes processing the retrieved codes and rendering website between cache server and the browser of client device . This functionality distribution may decrease the time it takes to load and render network based resources e.g. websites and may reduce resource and power consumption at client device . Further the split architecture may be implemented on the server side for example as a virtual machine that is instantiated and operated on cache server and that enables all the browser functionalities. On the device side the browser of client device may embed a browser engine such WebKit to render the network based resources and may utilize a networking protocol such as HTTP 2.0 and SPDY to reduce load time and improve security. When the browser requests objects of website and other network based resources the browser may decide which functionalities are to be operated locally on client device and which are to be operated remotely on the virtual machine hosted on cache server . In turn cache server may funnel the requests connect to website and the other network based resources retrieve the requested objects and process the objects based on the functionality distribution. Cache server may also cache the retrieved objects. The cached objects can be pushed to client device transmitted to client device upon request or made available by for example storing the cached objects on a network based resource such as a webpage hosted on cache server and sending a corresponding link to client device .

To validate the cached of client device based on the intermediary server architecture of various techniques may be implemented and may or may not include requests from client device to cache server for validating the cached objects. In a first technique client device may request cache server to validate the cached objects in client device s cache. For example the application operated on client device may generate a summary associated with the cached objects in its cache as previously described. The application may include data based on the summary in a request sent to cache server for validating the cached objects. The request may be customized to reduce bandwidth usage by taking advantage of the cache that is maintained at cache server . For example the request need not include the cached objects to be validated. Instead the request may include the summary or information based on the summary. The information may include a description checksum or hash of client device s cached objects that need to be validated. In another example the application may generate a hash of the summary or of client device s cache and may include this information in the request. Further depending on time and resource based rules associated with client device and with the connection to cache server the request may be transmitted to cache server .

In turn cache server may receive the request and determine the cached objects that need to be validated and the network based resources that can be used to refresh the cached objects. This determination may depend on the data included in the request. For example when the request identifies the cached objects cache server may update a list that tracks objects that need to be validated with this information. In another example when the request includes a hash of the cache of client device cache server may process the hash identify the associated objects access its cache determine which objects are expiring and the network based resources from which the expiring objects can be refreshed and add this information to the list.

Another technique for validating the objects does not involve a request from client device but instead takes advantage of the cache of cache server . Because the cached objects of client device s cache are also cached at and served from cache server to client device cache server may monitor and determine the objects that have been transmitted to client device and that need to be validated. This monitoring may be based on for example the freshness attributed of the transmitted objects and may include maintaining a summary similar to the summary generated by the application of client device . When an object needs to be refreshed cache server may determine a network based resource that can be used to refresh the object and may add an identifier of the object and of the network based resource to the list that tracks the objects that need to be validated.

Regardless of which of the two techniques is used to initiate the validation of the objects cache server may validate the objects identified on the list by connecting to the associated network based resources checking whether the objects are still valid or whether updates thereto are required downloading new objects or updates to the cache of cache server and updating any summary of the cache. A service may be returned to client device based on the validated objects and depending on the time and resource based rules. The service may include transmitting the validated objects to client device . The transmission may include pushing the validated objects to client device or sending a link to a webpage hosted on cache server and that includes the validated objects. In this latter example client device may retrieve the validated objects from the webpage by following the link. Additionally to further save bandwidth when an object has expired but is determined to still be valid cache server need not transmit the updated object to client device . Instead cache server may transmit instructions to client device to update the freshness attribute of the object.

In yet another technique for validating the cached objects server may not refresh the objects. Instead cache server may transmit the list that tracks the objects that need to be validated to client device depending on the time and resource based rules. In turn client device may process the information from the list connect to the listed network based resources and refresh the associated objects from these network based resources.

In addition to enabling the validation of the cached objects based on the time and resource based rules other rules may be implemented. For example cache server may maintain accounts associated with client device and other devices. These accounts may mandate the frequency the time and the rules for validating the cached objects of each client device. For instance client device may be associated with an account that requires cache server to validate objects cached from website on a daily basis and objects cached from another website on a monthly basis. These account rules may be coupled with time based rules that require the validation of the objects to occur at 10 00 pm. As such cache server may transmit validated objects associated with website to client device on a daily basis at 10 00 pm and validated objects associated with the other website on the first Monday of each month at 10 00 pm.

To illustrate the bandwidth optimization associated with the validation of the cached objects when an intermediary server is used describes one example embodiment of a procedure that can be distributed between cache server and client device of . Operation illustrates cache server connecting to network based resources including website over third network and caching objects from these network based resources. The cached objects can be served to client device . Operation illustrates cache server validating the cached objects. This validation may be based on a request received from client device or may be based on monitoring attributes of the objects served to client device and may take into account time resource and account based rules. The validation may also include determining which objects from the cache of cache server are no longer usable and connecting to network based resources to refresh the determined objects. Operation illustrates cache server updating its cache with validated objects and updating a summary related to the cache with information about the validated objects. Operation illustrates cache server returning a service based on the validated objects to client device . The returned service may include transmitting the validated objects a link to a network based resource from which client device may retrieve the validated objects or information to update attributes of the cached objects cached of client device s cache. This transmission may also take into account the time resource and account based rules. As such cache server may be configured to act as a single point in the system that client device interfaces with to validate the cached objects of client device s cache.

It should be appreciated that the network topologies illustrated in the figures have been greatly simplified and that many more networks and networking devices may be utilized to interconnect the various computing systems disclosed herein. These network topologies and devices should be apparent to those skilled in the art.

It should also be appreciated that the systems in the figures are merely illustrative and that other implementations might be used. Additionally it should be appreciated that the functionality disclosed herein might be implemented in software hardware or a combination of software and hardware. Other implementations should be apparent to those skilled in the art. It should also be appreciated that a server gateway or other computing device may comprise any combination of hardware or software that can interact and perform the described types of functionality including without limitation desktop or other computers database servers network storage devices and other network devices PDAs tablets cellphones wireless phones pagers electronic organizers Internet appliances television based systems e.g. using set top boxes and or personal digital video recorders and various other consumer products that include appropriate communication capabilities. In addition the functionality provided by the illustrated modules may in some embodiments be combined in fewer modules or distributed in additional modules. Similarly in some embodiments the functionality of some of the illustrated modules may not be provided and or other additional functionality may be available.

Each of the operations processes methods and algorithms described in the preceding sections may be embodied in and fully or partially automated by code modules executed by one or more computers or computer processors. The code modules may be stored on any type of non transitory computer readable medium or computer storage device such as hard drives solid state memory optical disc and or the like. The processes and algorithms may be implemented partially or wholly in application specific circuitry. The results of the disclosed processes and process steps may be stored persistently or otherwise in any type of non transitory computer storage such as e.g. volatile or non volatile storage.

The various features and processes described above may be used independently of one another or may be combined in various ways. All possible combinations and sub combinations are intended to fall within the scope of this disclosure. In addition certain method or process blocks may be omitted in some implementations. The methods and processes described herein are also not limited to any particular sequence and the blocks or states relating thereto can be performed in other sequences that are appropriate. For example described blocks or states may be performed in an order other than that specifically disclosed or multiple blocks or states may be combined in a single block or state. The example blocks or states may be performed in serial in parallel or in some other manner. Blocks or states may be added to or removed from the disclosed example embodiments. The example systems and components described herein may be configured differently than described. For example elements may be added to removed from or rearranged compared to the disclosed example embodiments.

It will also be appreciated that various items are illustrated as being stored in memory or on storage while being used and that these items or portions of thereof may be transferred between memory and other storage devices for purposes of memory management and data integrity. Alternatively in other embodiments some or all of the software modules and or systems may execute in memory on another device and communicate with the illustrated computing systems via inter computer communication. Furthermore in some embodiments some or all of the systems and or modules may be implemented or provided in other ways such as at least partially in firmware and or hardware including but not limited to one or more application specific integrated circuits ASICs standard integrated circuits controllers e.g. by executing appropriate instructions and including microcontrollers and or embedded controllers field programmable gate arrays FPGAs complex programmable logic devices CPLDs etc. Some or all of the modules systems and data structures may also be stored e.g. as software instructions or structured data on a computer readable medium such as a hard disk a memory a network or a portable media article to be read by an appropriate drive or via an appropriate connection. The systems modules and data structures may also be transmitted as generated data signals e.g. as part of a carrier wave or other analog or digital propagated signal on a variety of computer readable transmission media including wireless based and wired cable based media and may take a variety of forms e.g. as part of a single or multiplexed analog signal or as multiple discrete digital packets or frames . Such computer program products may also take other forms in other embodiments. Accordingly the present invention may be practiced with other computer system configurations.

Conditional language used herein such as among others can could might may e.g. and the like unless specifically stated otherwise or otherwise understood within the context as used is generally intended to convey that certain embodiments include while other embodiments do not include certain features elements and or steps. Thus such conditional language is not generally intended to imply that features elements and or steps are in any way required for one or more embodiments or that one or more embodiments necessarily include logic for deciding with or without author input or prompting whether these features elements and or steps are included or are to be performed in any particular embodiment. The terms comprising including having and the like are synonymous and are used inclusively in an open ended fashion and do not exclude additional elements features acts operations and so forth. Also the term or is used in its inclusive sense and not in its exclusive sense so that when used for example to connect a list of elements the term or means one some or all of the elements in the list.

While certain example embodiments have been described these embodiments have been presented by way of example only and are not intended to limit the scope of the inventions disclosed herein. Thus nothing in the foregoing description is intended to imply that any particular feature characteristic step module or block is necessary or indispensable. Indeed the novel methods and systems described herein may be embodied in a variety of other forms furthermore various omissions substitutions and changes in the form of the methods and systems described herein may be made without departing from the spirit of the inventions disclosed herein. The accompanying claims and their equivalents are intended to cover such forms or modifications as would fall within the scope and spirit of certain of the inventions disclosed herein.

