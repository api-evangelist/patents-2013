---

title: Method and system for bin coalescing for parallel divide-and-conquer sorting algorithms
abstract: A system and method for performing sorting. The method includes partitioning a plurality of keys needing sorting into a first plurality of bins, wherein the bins are sequentially sorted. The plurality of keys is capable of being sorted into a sequence of keys using a corresponding ordering system. The method includes coalescing a first pair of consecutive bins, such that when coalesced the first pair of bins falls below a threshold. The method also includes ordering keys in the first coalesced pair to generate a first sub-sequence of keys in the sequence of keys.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09619204&OS=09619204&RS=09619204
owner: Nvidia Corporation
number: 09619204
owner_city: Santa Clara
owner_country: US
publication_date: 20130614
---
This invention was made with Government support under Agreement HR0011 13 3 0001 awarded by DARPA. The Government has certain right in the invention.

Sorting is germane to many algorithms in computer science and software applications frequently rely upon efficient sorting primitives for good performance. A top down divide and conquer sorting method operates by repeatedly applying a partial ordering to a sequence of keys creating two or more bins which can then be sorted independently. More particularly the simplest top down sorting approaches operate by recursively partitioning the input until each bin contains only a single key and is thus trivially sorted .

Most practical implementations switch to another block sorting method when the bin size falls below a certain threshold B. The block sorting component is typically designed and optimized for problems that fit entirely within the storage resources of a single processor core viz. registers cache shared memory etc. .

To provide good load balance amongst parallel processing elements top down approaches performed across multiple threads and or processor cores generally strive to construct uniformly sized bins for block sorting regardless of input size and distribution. Otherwise it is possible for a majority of processing elements handling small or average sized bins to quickly perform their partitioning responsibilities and then wait idly for a small minority to process much larger bins thus underutilizing processing resources.

To these ends comparison based implementations e.g. sample sort quicksort etc. have traditionally focused on choosing a dynamic set of splitting points that approximate the input sequence s key distribution. This can be done e.g. by sampling the input keys sorting the samples and then selecting splitters from the sorted samples at regular intervals. However for processor genres having wide parallelism per core e.g. deep multithreading SIMD SIMT vector etc. dynamically adjustable splitting points may be difficult to implement due to the complexities of cooperation between fine grained parallel processing elements.

Furthermore such parallel processor genres can incur steep performance penalties for bin sizes that fall short of the ideal block sorting threshold B. That is processor efficiency is maximized when the utilization of fast local storage resources are maximized. In some cases under filled bins are caused by 1 non uniform key distributions that result in uneven bin sizes and 2 mismatches between the input problem size N and the bin splitting factor S. In particular top down sorting operations performed in parallel using the most significant digit MSD radix sorting method are prone to producing bin sizes that are substantially smaller than the block sorting threshold B.

One commonplace method of achieving final block sizes approaching B elements is to dynamically adjust the splitting factor S for each recursive partitioning step. However it is often difficult to dynamically adjust the splitting factor on such parallel architectures due to the complexities of cooperation between fine grained parallel processing elements.

In embodiments of the present invention a computer implemented method for causing a computer system to perform a method for sorting. In other embodiments a non transitory computer readable medium is disclosed having computer executable instructions for causing a computer system to perform a method for sorting. The method includes partitioning a plurality of keys needing sorting into a first plurality of bins that are sequentially sorted wherein the plurality of keys is capable of being sorted into a sequence of keys using a corresponding ordering system. The method includes coalescing a first pair of consecutive bins such that when coalesced said first pair of bins falls below a threshold. The method also includes ordering keys in said first pair to generate a first sub sequence of keys in said sequence of keys.

In still other embodiments of the present invention a computer system is disclosed comprising a processor and memory coupled to the processor and having stored therein instructions that if executed by the computer system cause the computer system to execute a method for sorting. The method includes partitioning a plurality of keys needing sorting into a first plurality of bins that are sequentially sorted wherein the plurality of keys is capable of being sorted into a sequence of keys using a corresponding ordering system. The method includes coalescing a first pair of consecutive bins such that when coalesced said first pair of bins falls below a threshold. The method also includes ordering keys in the first coalesced pair to generate a first sub sequence of keys in said sequence of keys.

These and other objects and advantages of the various embodiments of the present disclosure will be recognized by those of ordinary skill in the art after reading the following detailed description of the embodiments that are illustrated in the various drawing figures.

Reference will now be made in detail to the various embodiments of the present disclosure examples of which are illustrated in the accompanying drawings. While described in conjunction with these embodiments it will be understood that they are not intended to limit the disclosure to these embodiments. On the contrary the disclosure is intended to cover alternatives modifications and equivalents which may be included within the spirit and scope of the disclosure as defined by the appended claims. Furthermore in the following detailed description of the present disclosure numerous specific details are set forth in order to provide a thorough understanding of the present disclosure. However it will be understood that the present disclosure may be practiced without these specific details. In other instances well known methods procedures components and circuits have not been described in detail so as not to unnecessarily obscure aspects of the present disclosure.

Some portions of the detailed descriptions that follow are presented in terms of procedures logic blocks processing and other symbolic representations of operations on data bits within a computer memory. These descriptions and representations are the means used by those skilled in the data processing arts to most effectively convey the substance of their work to others skilled in the art. In the present application a procedure logic block process or the like is conceived to be a self consistent sequence of steps or instructions leading to a desired result. The steps are those utilizing physical manipulations of physical quantities. Usually although not necessarily these quantities take the form of electrical or magnetic signals capable of being stored transferred combined compared and otherwise manipulated in a computer system. It has proven convenient at times principally for reasons of common usage to refer to these signals as transactions bits values elements symbols characters samples pixels or the like.

It should be borne in mind however that all of these and similar terms are to be associated with the appropriate physical quantities and are merely convenient labels applied to these quantities. Unless specifically stated otherwise as apparent from the following discussions it is appreciated that throughout the present disclosure discussions utilizing terms such as partitioning coalescing ordering sorting generating or the like refer to actions and processes e.g. flowcharts A B and of respectively of a computer system or similar electronic computing device or processor e.g. system . The computer system or similar electronic computing device manipulates and transforms data represented as physical electronic quantities within the computer system memories registers or other such information storage transmission or display devices.

Other embodiments described herein may be discussed in the general context of computer executable instructions residing on some form of computer readable storage medium such as program modules executed by one or more computers or other devices. By way of example and not limitation computer readable storage media may comprise non transitory computer storage media and communication media. Generally program modules include routines programs objects components data structures etc. that perform particular tasks or implement particular abstract data types. The functionality of the program modules may be combined or distributed as desired in various embodiments.

Computer storage media includes volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Computer storage media includes but is not limited to random access memory RAM read only memory ROM electrically erasable programmable ROM EEPROM flash memory or other memory technology compact disk ROM CD ROM digital versatile disks DVDs or other optical storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium that can be used to store the desired information and that can accessed to retrieve that information.

Communication media can embody computer executable instructions data structures and program modules and includes any information delivery media. By way of example and not limitation communication media includes wired media such as a wired network or direct wired connection and wireless media such as acoustic radio frequency RF infrared and other wireless media. Combinations of any of the above can also be included within the scope of computer readable media.

Both the central processing unit CPU and the graphics processing unit GPU are coupled to memory . System memory generally represents any type or form of volatile or non volatile storage device or medium capable of storing data and or other computer readable instructions. Examples of system memory include without limitation RAM ROM flash memory or any other suitable memory device. In the example of memory is a shared memory whereby the memory stores instructions and data for both the CPU and the GPU . Alternatively there may be separate memories dedicated to the CPU and the GPU respectively. The memory can include a frame buffer for storing pixel data drives a display screen .

The system includes a user interface that in one implementation includes an on screen cursor control device. The user interface may include a keyboard a mouse and or a touch screen device a touchpad .

CPU and or GPU generally represent any type or form of processing unit capable of processing data or interpreting and executing instructions. In certain embodiments processors and or may receive instructions from a software application or hardware module. These instructions may cause processors and or to perform the functions of one or more of the example embodiments described and or illustrated herein. For example processors and or may perform and or be a means for performing either alone or in combination with other elements one or more of the monitoring determining gating and detecting or the like described herein. Processors and or may also perform and or be a means for performing any other steps methods or processes described and or illustrated herein.

The system also includes a sorting module configured to implement embodiments of the present invention. In particular sorting module is configured to perform bin coalescing such that previously partitioned bins of keys are dynamically sacrificed in order to construct larger more efficient bin sizes for purposes of final sorting.

In some embodiments the computer readable medium containing a computer program may be loaded into computing system . All or a portion of the computer program stored on the computer readable medium may then be stored in system memory and or various portions of storage devices. When executed by processors and or a computer program loaded into computing system may cause processor and or to perform and or be a means for performing the functions of the example embodiments described and or illustrated herein. Additionally or alternatively the example embodiments described and or illustrated herein may be implemented in firmware and or hardware.

Accordingly embodiments of the present invention provide for a bin coalescing technique used for improving the local in core efficiency of divide and conquer sorting strategies. In particular embodiments provide for bin coalescing in order to dynamically sacrifice previously performed splitting work in order to construct larger more efficient bin sizes that are then internally sorted.

Although embodiments of the present invention are presented within the context of parallel most significant digit MSD radix sorting embodiments of the present invention are implementable within any top down divide and conquer approach where a partial ordering is applied to a sequence of keys thereby creating two or more bins which can then be sorted independently. Examples of top down partitioning approaches include the algorithmic families of sample sort quicksort e.g. with one or more pivots burst sort etc.

At the method includes partitioning a plurality of keys needing sorting into a first plurality of bins. In addition the plurality of keys is capable of being sorted into a sequence of keys using a corresponding ordering system e.g. alphabetical lettering numeric ordering etc. . More particularly the plurality of keys is partitioned into a partial ordering wherein two or more bins are created which then can be sorted independently. Examples of such top down partitioning based sorting methods include sample sort quicksort burst sort MSD radix sorting etc.

Further a given plurality of keys is partitioned into at most S bins. This process is conducted recursively such that each bin is itself partitioned into at most S child bins designated for further processing. This occurs until no bins contain elements numbering greater than some final processing threshold B e.g. 1 128 2048 etc. .

At the method includes opportunistic coalescing of a first pair of consecutive bins into a resulting bin that is equal to or nearly equal to but does not exceed the final processing threshold B. That is before final processing of remaining bins a pair of adjacent bins is identified and processed as targets for coalescing reducing the plurality of remaining bins by one. In some embodiments a second pair of consecutive bins in the second plurality of bins may be coalesced i.e. coalescing is performed until no further pairings of consecutive bins can be coalesced without exceeding the threshold B. In these cases each remaining bin may comprise more than one pair of coalesced bins.

Although bin coalescing has the effect of undoing some of the previous partitioning effort such lost effort is far outweighed by the benefit of fuller bins formed for final block sorting.

Any coalescing embodiment must observe the requirement that once each remaining bin has been fully sorted internally the consecutive concatenation of these remaining bins effectively realizes the sorted ordering of the original plurality of input keys. As a requirement only neighboring consecutive or adjacent bins are candidates for coalescing.

In one embodiment these bins can be described by memory offset and length. For each pair of coalesced bins the previous logical bin descriptions are replaced with a new description whose offset is that of the leftmost comprising bin and whose length is the sum of the lengths of each coalesced bin.

Different embodiments may choose to coalesce candidate pairings of adjacent bins in different orders. In one embodiment the first pair of bins includes a previously coalesced pair. That is candidate bins are considered one at a time greedily coalescing adjacent bins until that aggregation would exceed a threshold B. In another embodiment the order in which consecutive bins candidates are coalesced is chosen with the goal of globally maximizing the average size of the remaining bins.

At the method includes a final ordering of keys in remaining bins to generate one or more sub sequences of keys in the fully sorted ordering of the original input plurality of keys. For example a first remaining is ordered to generate a first sub sequence of keys in the fully sorted ordering of the original input plurality of keys. In one embodiment the same sorting algorithm used to partition the keys is used to order keys. In another embodiment a second sorting e.g. block sorting operation is used to order the keys in the remaining bins. This second sorting operation is typically designed and optimized for problems of size B where B is the limit of keys that fit entirely within the resources of a single processor core e.g. registers cache shared memory etc. . For instance embodiments of the invention implement a second sorting operation that includes for example insertion sort bitonic sort merge sort least significant digit LSD radix sort etc. .

Since the block sorting phase often comprises the majority of the overall sorting overhead performing bin coalescing in embodiments of the present invention facilitates bin sizes that are more uniformly sized. For instance as the average size of bins trends towards the threshold B all threads and or cores performing block sorting benefit from high utilization and even workload balance.

In one embodiment the sorting is performed in parallel using a plurality of processor cores and or processing threads. More particularly the sorting including partitioning and final ordering phases is performed in parallel using a plurality of threads and or processor cores which may be logical or physical in nature. In one embodiment each plurality of keys including pluralities that comprise previously partitioned bins as well as the original plurality of input keys is partitioned and or sorted by a separate thread and or processor core. In this fashion the amount of parallelism expressed expands as bins are further subdivided. In another embodiment multiple threads and or processor cores may work together to cooperatively partition and or sort a given plurality of keys. As such the amount of parallelism expressed can remain constant typically matching that exposed by the underlying computer hardware.

At the method includes partitioning a plurality of keys needing sorting into a first plurality of bins. In addition the plurality of keys is capable of being sorted into a sequence of keys using a corresponding ordering system. The operation performed at is analogous to the operation in .

At the method includes performing recursive halving on the plurality of bins based on a threshold e.g. threshold B . More specifically at each stage of the recursive bin coalescing phase each pair of consecutive bins is considered to determine whether their coalescing would exceed the threshold B. In one embodiment these pairwise evaluations can be performed concurrently by parallel threads and or processor cores. If a given pair can be coalesced then the coalescing process is recursively applied to determine whether the next adjacent bin is capable of being absorbed. At each recursive step the number of remaining bins may be reduced by up to half. The recursive process ends when the bin size exceeds the threshold B at which point the last cluster of coalesced bins with a size not exceeding the threshold B is set and ready for final ordering.

The process illustrated in is performed across one or more threads and or processor cores. Further individual operations in flow diagram may be split off and performed by one or more threads and or processor cores.

As shown in at the method includes partitioning a plurality of keys needing sorting into a plurality of bins. In addition the plurality of keys is capable of being sorted into a sequence of keys using a corresponding ordering system.

At decision step the method determines if consecutive pairs of bins can be coalesced. If no pairs can be coalesced then the process proceeds to . On the other hand if a pair of bins can be coalesced then the process proceeds to where consecutive bins in the plurality of bins are coalesced. For instance consecutive bins are coalesced when their combined bin size falls below or is equal to a threshold B.

The method illustrates recursive halving when performing bin coalescing at decision step where the method determines whether newly formed consecutive bins are capable of being coalesced. If so then the process returns to to coalesce consecutive bins recursively until the final coalesced bin size approaches but does not exceed the threshold B.

When it is determined that no further bins are capable of being coalesced then the process proceeds to decision step where it is further determined whether any of the remaining bins need further partitioning. That is if all bins have sizes that are less than or equal to a threshold B then the process turns to where final ordering is performed on all remaining bins.

On the other hand if there are bins that need further sorting i.e. they have bin sizes that exceed the threshold B then the process proceeds to where each bin needing further partitioning is isolated. Each of the isolated bins are then further partitioned by returning to step on the same or on a separate thread and or processor core. Further remaining bins that do not need further partitioning are ready for final ordering. This final ordering process is independently handled from the partitioning process and may occur simultaneously concurrently and or sequentially to the partitioning process on the same or different threads and or processor cores used to perform partitioning.

In one embodiment for comparison based sorting bin coalescing can be viewed as a form of graph clustering. That is a sequence of weighted vertices needing clustering is presented along a linear path graph. The clustering criteria include maximizing the average cluster weight without forming any clusters whose aggregate weight exceeds the threshold B.

For a given splitting factor e.g. S RADIX DIGITS the algorithm presented in pseudocode iteratively tries to coalesce pairs of bins whose keys are separated by progressively shorter substrings of prefix bits characters digits i.e. it prefers to coalesce bins having longer common prefixes. For instance pseudocode first tries to coalesce odd bins into even bins e.g. 0 1 2 3 4 5 and 6 7 . The resulting bins lose one bit of radix progress. If successful it is attempted to coalesce pairs of bins having multiple of two indices e.g. 0 2 and 4 6 which loses another bit of radix progress. Once a bin has failed to coalesce a peer it is not eligible to coalesce more distant peers. This property is transitive such that if bin A coalesced bin B which failed to coalesce bin C then bin A also becomes ineligible for coalescing more distant peers. The work complexity of this bin coalescing algorithm is O SlogS .

Without coalescing the keys at each level in the tree would have all been binned to the same bitwise digit place. Bins are labeled by the common bitwise prefix of the keys they comprise. As such all bins at each level would have the same number of remaining bits to sort over as shown in the first partitioning of the 16 348 keys in .

However bin coalescing complicates the bitwise progression of MSD sorting. Coalescing two consecutive bins effectively pushes the radix progression back up by at least one bit for the resulting bin. For example it creates a more general prefix with more remaining bits to sort over. As shown in the bins b010 . . . and b011 . . . have been coalesced to form a bin with prefix b01 . . . . In one embodiment bin descriptions also track their own bitwise radix progress independently.

As shown the plurality of bins includes bins of the following sizes bin 0 4086 bin 1 2040 bin 2 950 bin 3 1028 bin 4 4080 bin 5 1034 bin 6 692 and bin 7 2474 . The bins are arranged according to their most significant bits that are shared. For instance keys in the bin 0 all share the same prefix b000 . . . keys in bin 1 share prefix b001 . . . keys in bin 2 share prefix b010 . . . keys in bin 3 share prefix b011 . . . keys in bin 4 share prefix b100 . . . keys in bin 5 share prefix b101 . . . keys in bin 6 share prefix b110 . . . and keys in bin 7 share prefix b111 . . . . For purposes of bin coalescing all these bins 0 7 have ACTIVE flags that indicate that corresponding bin is available for coalescing a distant peer e.g. to the right in .

At this point bin coalescing is performed. That is it is determined whether consecutive pairs of bins are capable of being coalesced. Using one technique illustrated in pseudocode of progressively more distant pairs of bins are potentially coalesced i.e. bins that are separated by progressively smaller shared prefixes. In this embodiment the number of bins that are unmasked and can consider agglomerating peers is recursively halved. To begin odd bins are analyzed to determine if they can be coalesced into even bins. Specially bins 0 2 4 and 6 are unmasked. Because all four unmasked bins are flagged ACTIVE all four of these bins can attempt to agglomerate consecutive and neighboring peers.

In particular a pair of bins includes bins 0 and 1 which cannot be coalesced because they exceed the threshold B. In this case bin 0 changes its flag to INACTIVE though the flag of bin 1 remains ACTIVE. As shown a pair of bins 2 3 are coalesced into a coalesced bin of size 1978. That is bin 2 now is of size 1978 and bins 2 and 3 have flags that remain ACTIVE. Also a pair of bins 4 5 cannot be coalesced and as such the flag for bin 4 is INACTIVE though the flag for bin 5 remains ACTIVE. Further a pair of bins 6 7 cannot be coalesced in which case bin 6 changes its flag to INACTIVE though the flag of bin 7 remains ACTIVE.

In the next phase of coalescing bins 1 2 3 and 5 and 7 remain ACTIVE. Bins 0 and 4 are unmasked. Because neither of these bins is INACTIVE they each cannot attempt to agglomerate neighboring peers.

Also bins that need further partitioning are identified. For instance bins 0 4 and 7 are identified as needing further portioning because they are of a size that exceeds the threshold B. The identified bins are separated and a new sorting process is independently performed on each of these bins such as performing partitioning bin coalescing and final sorting. As shown bin 0 is partitioned 8 ways into bins of sizes 500 520 524 502 509 515 517 and 499. During the recursive halving coalescing phase these bins are coalesced recursively into 2 bins of sizes 3040 and 2046. Also bin 4 is partitioned 8 ways into bins of sizes 509 516 517 511 496 520 513 and 498. During the recursive halving coalescing phase these bins are coalesced recursively into 3 bins of sizes 1025 1028 and 2027 that are ready for final block sorting. Further bin 7 is partitioned 8 ways into bins of sizes 280 321 305 610 77 254 318 and 309. During the recursive halving coalescing phase these bins are coalesced recursively into 2 bins of sizes 1516 and 958 that are ready for final block sorting.

Further in all of these coalescing phases bins that are ready for final block sorting are also indentified. For instance bins 0 5 and 6 are identified without further coalescing for final block sorting. Thereafter the bin of size 1978 dotted block that coalesced bins 2 and 3 is also identified for final block sorting. Also bins that were further partitioned into sub bins that were then coalesced are also identified for sorting e.g. bins of sizes 2040 2046 1025 1028 2027 and 1516 and 958 also identified as dotted blocks .

As a further illustration of bin coalescing consider 8 partitioned bins 0 7. In the first step all bins 0 7 are labeled ACTIVE. Even bins 0 2 4 and 6 are unmasked. Because all four unmasked bins are still flagged ACTIVE they each can attempt to agglomerate neighboring peer bins. Consider the following scenario where bins 0 4 and 6 successfully agglomerate peer bins 1 5 and 7 respectively because their combined sizes are less than or equal to the threshold B. Bins 0 4 and 6 remain ACTIVE because their agglomerated peers were also flagged ACTIVE such that no gaps occur between the agglomerated peers. On the other hand bin 2 is unable to merge with bin 3 because the combined size exceeds the threshold B. As such bin 2 is flagged INACTIVE.

In the second step bins 0 1 3 4 5 6 and 7 are still labeled ACTIVE. Now bins 0 and 4 are unmasked. Because bins 0 and 4 are still ACTIVE both can attempt to agglomerate peers. Consider the following scenario where bins 0 and 4 successfully agglomerate peer bins 2 and 6 respectively again because their combined sizes are under the threshold B. Bin 0 can still agglomerate an bin 2 that is marked INACTIVE. Now bin 0 is flagged INACTIVE because its agglomerated peer bin 2 was flagged INACTIVE thereby indicating that bin 0 cannot further agglomerate distant peers because there is a gap between neighboring bins. Also bin 4 remains ACTIVE because its agglomerated peer bin 6 was also flagged ACTIVE.

In the third step bins 1 3 4 5 6 and 7 are labeled ACTIVE. Bin 0 is unmasked. Because bin 0 is flagged INACTIVE it cannot attempt agglomeration.

Thus according to embodiments of the present disclosure systems and methods are described providing for bin coalescing that is used for improving the local in core efficiency of divide and conquer sorting strategies.

While the foregoing disclosure sets forth various embodiments using specific block diagrams flowcharts and examples each block diagram component flowchart step operation and or component described and or illustrated herein may be implemented individually and or collectively using a wide range of hardware software or firmware or any combination thereof configurations. In addition any disclosure of components contained within other components should be considered as examples in that many architectural variants can be implemented to achieve the same functionality.

The process parameters and sequence of steps described and or illustrated herein are given by way of example only and can be varied as desired. For example while the steps illustrated and or described herein may be shown or discussed in a particular order these steps do not necessarily need to be performed in the order illustrated or discussed. The various example methods described and or illustrated herein may also omit one or more of the steps described or illustrated herein or include additional steps in addition to those disclosed.

While various embodiments have been described and or illustrated herein in the context of fully functional computing systems one or more of these example embodiments may be distributed as a program product in a variety of forms regardless of the particular type of computer readable media used to actually carry out the distribution. The embodiments disclosed herein may also be implemented using software modules that perform certain tasks. These software modules may include script batch or other executable files that may be stored on a computer readable storage medium or in a computing system. These software modules may configure a computing system to perform one or more of the example embodiments disclosed herein. One or more of the software modules disclosed herein may be implemented in a cloud computing environment. Cloud computing environments may provide various services and applications via the Internet. These cloud based services e.g. software as a service platform as a service infrastructure as a service etc. may be accessible through a Web browser or other remote interface. Various functions described herein may be provided through a remote desktop environment or any other cloud based computing environment.

The foregoing description for purpose of explanation has been described with reference to specific embodiments. However the illustrative discussions above are not intended to be exhaustive or to limit the invention to the precise forms disclosed. Many modifications and variations are possible in view of the above teachings. The embodiments were chosen and described in order to best explain the principles of the invention and its practical applications to thereby enable others skilled in the art to best utilize the invention and various embodiments with various modifications as may be suited to the particular use contemplated.

Embodiments according to the present disclosure are thus described. While the present disclosure has been described in particular embodiments it should be appreciated that the disclosure should not be construed as limited by such embodiments but rather construed according to the below claims.

