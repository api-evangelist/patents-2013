---

title: Extensible multi-tenant cloud-management system and methods for extending functionalities and services provided by a multi-tenant cloud-managment system
abstract: The current document is directed to an interface and authorization service that allows users of a cloud-director management subsystem of distributed, multi-tenant, virtual data centers to extend the services and functionalities provided by the cloud-director management subsystem. A cloud application programming interface (“API”) entrypoint represents a request/response RESTful interface to services and functionalities provided by the cloud-director management subsystem as well as to service extensions provided by users. The cloud API entrypoint includes a service-extension interface and an authorization-service management interface. The cloud-director management subsystem provides the authorization service to service extensions that allow the service extensions to obtain, from the authorization service, an indication of whether or not a request directed to the service extension through the cloud API entrypoint is authorized.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09356962&OS=09356962&RS=09356962
owner: VMware, Inc.
number: 09356962
owner_city: Palo Alto
owner_country: US
publication_date: 20130910
---
The current document is directed to virtualization technologies and in particular to a subsystem of multi tenant distributed cloud computing facilities and to methods carried out by the subsystem that provide for access controlled extensions to services and functionalities provided by the subsystem.

The development and evolution of modern computing has in many ways been facilitated by the power of logical abstraction. Early computers were manually programmed by slow and tedious input of machine instructions into the computers memories. Over time assembly language programs and assemblers were developed in order to provide a level of abstraction namely assembly language programs above the machine instruction hardware interface level to allow programmers to more rapidly and accurately develop programs. Assembly language based operations are more easily encoded by human programmers than machine instruction based operations and assemblers provided additional features including assembly directives routine calls and a logical framework for program development. The development of operating systems provided yet another type of abstraction that provided programmers with logical easy to understand system call interfaces to computer hardware functionality. As operating systems developed additional internal levels of abstraction were created within operating systems including virtual memory implemented by operating system paging of memory pages between electronic memory and mass storage devices which provided easy to use linear memory address spaces much larger than could be provided by the hardware memory of computer systems. Additional levels of abstractions were created in the programming language domain with compilers developed for a wide variety of compiled languages that greatly advanced the ease of programming and the number and capabilities of programming tools with respect those provided by assemblers and assembly languages. Higher level scripting languages and special purpose interpreted languages provided even higher levels of abstraction and greater ease of application development in particular areas. Similarly block based and sector based interfaces to mass storage devices have been abstracted through many levels of abstraction to modem database management systems which provide for high available and fault tolerant storage of structured data that can be analyzed interpreted and manipulated through powerful high level query languages.

In many ways a modem computer system can be thought of as many different levels of abstractions along many different often interdependent dimensions. More recently powerful new levels of abstraction have been developed with respect to virtual machines which provide virtual execution environments for application programs and operating systems. Virtual machine technology essentially abstracts the hardware resources and interfaces of a computer system on behalf of one or multiple virtual machines each comprising one or more application programs and an operating system. Even more recently the emergence of cloud computing services can provide abstract interfaces to enormous collections of geographically dispersed data centers allowing computational service providers to develop and deploy complex Internet based services that execute on tens or hundreds of physical servers through abstract cloud computing interfaces.

The abstract interfaces provided by cloud computing allow users to access various services and functionalities used to manage distributed multi tenant virtual data centers. Designers developers vendors and users of these abstract interfaces continue to seek functionality to expand the services and functionalities accessed through the abstract interfaces.

The current document is directed to an interface and authorization service that allows users of a cloud director management subsystem of distributed multi tenant virtual data centers to extend the services and functionalities provided by the cloud director management subsystem. A cloud application programming interface API entrypoint represents a request response RESTful interface to services and functionalities provided by the cloud director management subsystem as well as to service extensions provided by users. The cloud API entrypoint includes a service extension interface and an authorization service management interface. The cloud director management subsystem provides the authorization service to service extensions that allow the service extensions to obtain from the authorization service an indication of whether or not a request directed to the service extension through the cloud API entrypoint is authorized.

As discussed above modern computing can be considered to be a collection of many different levels of abstraction above the physical computing hardware level that includes physical computer systems data storage systems and devices and communications networks. The current document is related to a multi cloud aggregation level of abstraction that provides homogenous cloud and heterogeneous cloud distributed management services each cloud generally an abstraction of a large number of virtual resource pools comprising processing storage and network resources each of which in turn can be considered to be a collection of abstractions above underlying physical hardware devices. The current document is directed to extension of services and functionalities provided by a management subsystem that provides a management interface to distributed multi tenant virtual data centers resident within various physical cloud computing facilities and in particular to an authorization service that allows users of the management subsystem interface to extend services in a multi tenancy compatible fashion. The following discussion includes three subsections 1 Computer Architecture Virtualization Electronic Communications and Virtual Networks 2 RESTful APIs and 3 Authorization Service to Facilitate Multi Tenancy in Cloud Computing Facilities.

The term abstraction is not in any way intended to mean or suggest an abstract idea or concept. Computational abstractions are tangible physical interfaces that are implemented ultimately using physical computer hardware data storage devices and communications systems. Instead the term abstraction refers in the current discussion to a logical level of functionality encapsulated within one or more concrete tangible physically implemented computer systems with defined interfaces through which electronically encoded data is exchanged process execution launched and electronic services are provided. Interfaces may include graphical and textual data displayed on physical display devices as well as computer programs and routines that control physical computer processors to carry out various tasks and operations and that are invoked through electronically implemented application programming interfaces APIs and other electronically implemented interfaces. There is a tendency among those unfamiliar with modern technology and science to misinterpret the terms abstract and abstraction when used to describe certain aspects of modern computing. For example one frequently encounters assertions that because a computational system is described in terms of abstractions functional layers and interfaces the computational system is somehow different from a physical machine or device. Such allegations are unfounded. One only needs to disconnect a computer system or group of computer systems from their respective power supplies to appreciate the physical machine nature of complex computer technologies. One also frequently encounters statements that characterize a computational technology as being only software and thus not a machine or device. Software is essentially a sequence of encoded symbols such as a printout of a computer program or digitally encoded computer instructions sequentially stored in a file on an optical disk or within an electromechanical mass storage device. Software alone can do nothing. It is only when encoded computer instructions are loaded into an electronic memory within a computer system and executed on a physical processor that so called software implemented functionality is provided. The digitally encoded computer instructions are an essential control component of processor controlled machines and devices no less essential than a cam shaft control system in an internal combustion engine. Multi cloud aggregations cloud computing services virtual machine containers and virtual machines communications interfaces and many of the other topics discussed below are tangible physical components of physical electro optical mechanical computer systems.

Of course there are many different types of computer system architectures that differ from one another in the number of different memories including different types of hierarchical cache memories the number of processors and the connectivity of the processors with other system components the number of internal communications busses and serial links and in many other ways. However computer systems generally execute stored programs by fetching instructions from memory and executing the instructions in one or more processors. Computer systems include general purpose computer systems such as personal computers PCs various types of servers and workstations and higher end mainframe computers but may also include a plethora of various types of special purpose computing devices including data storage systems communications routers network nodes tablet computers and mobile telephones.

Until recently computational services were generally provided by computer systems and data centers purchased configured managed and maintained by service provider organizations. For example an e commerce retailer generally purchased configured managed and maintained a data center including numerous web servers back end computer systems and data storage systems for serving web pages to remote customers receiving orders through the web page interface processing the orders tracking completed orders and other myriad different tasks associated with an e commerce enterprise.

Cloud computing facilities are intended to provide computational bandwidth and data storage services much as utility companies provide electrical power and water to consumers. Cloud computing provides enormous advantages to small organizations without the resources to purchase manage and maintain in house data centers. Such organizations can dynamically add and delete virtual computer systems from their virtual data centers within public clouds in order to track computational bandwidth and data storage needs rather than purchasing sufficient computer systems within a physical data center to handle peak computational bandwidth and data storage demands. Moreover small organizations can completely avoid the overhead of maintaining and managing physical computer systems including hiring and periodically retraining information technology specialists and continuously paying for operating system and database management system upgrades. Furthermore cloud computing interfaces allow for easy and straightforward configuration of virtual computing facilities flexibility in the types of applications and operating systems that can be configured and other functionalities that are useful even for owners and administrators of private cloud computing facilities used by a single organization.

While the execution environments provided by operating systems have proved to be an enormously successful level of abstraction within computer systems the operating system provided level of abstraction is nonetheless associated with difficulties and challenges for developers and users of application programs and other higher level computational entities. One difficulty arises from the fact that there are many different operating systems that run within various different types of computer hardware. In many cases popular application programs and computational systems are developed to run on only a subset of the available operating systems and can therefore be executed within only a subset of the various different types of computer systems on which the operating systems are designed to run. Often even when an application program or other computational system is ported to additional operating systems the application program or other computational system can nonetheless run more efficiently on the operating systems for which the application program or other computational system was originally targeted. Another difficulty arises from the increasingly distributed nature of computer systems. Although distributed operating systems are the subject of considerable research and development efforts many of the popular operating systems are designed primarily for execution on a single computer system. In many cases it is difficult to move application programs in real time between the different computer systems of a distributed computer system for high availability fault tolerance and load balancing purposes. The problems are even greater in heterogeneous distributed computer systems which include different types of hardware and devices running different types of operating systems. Operating systems continue to evolve as a result of which certain older application programs and other computational entities may be incompatible with more recent versions of operating systems for which they are targeted creating compatibility issues that are particularly difficult to manage in large distributed systems.

For all of these reasons a higher level of abstraction referred to as the virtual machine has been developed and evolved to further abstract computer hardware in order to address many difficulties and challenges associated with traditional computing systems including the compatibility issues discussed above. illustrates one type of virtual machine and virtual machine execution environment. uses the same illustration conventions as used in . In particular the computer system in includes the same hardware layer as the hardware layer shown in . However rather than providing an operating system layer directly above the hardware layer as in the virtualized computing environment illustrated in features a virtualization layer that interfaces through a virtualization layer hardware layer interface equivalent to interface in to the hardware. The virtualization layer provides a hardware like interface to a number of virtual machines such as virtual machine executing above the virtualization layer in a virtual machine layer . Each virtual machine includes one or more application programs or other higher level computational entities packaged together with an operating system such as application and operating system packaged together within virtual machine . Each virtual machine is thus equivalent to the operating system layer and application program layer in the general purpose computer system shown in . Each operating system within a virtual machine interfaces to the virtualization layer interface rather than to the actual hardware interface . The virtualization layer partitions hardware resources into abstract virtual hardware layers to which each operating system within a virtual machine interfaces. The operating systems within the virtual machines in general are unaware of the virtualization layer and operate as if they were directly accessing a true hardware interface. The virtualization layer ensures that each of the virtual machines currently executing within the virtual environment receive a fair allocation of underlying hardware resources and that all virtual machines receive sufficient resources to progress in execution. The virtualization layer interface may differ for different operating systems. For example the virtualization layer is generally able to provide virtual hardware interfaces for a variety of different types of computer hardware. This allows as one example a virtual machine that includes an operating system designed for a particular computer architecture to run on hardware of a different architecture. The number of virtual machines need not be equal to the number of physical processors or even a multiple of the number of processors. The virtualization layer includes a virtual machine monitor module that virtualizes physical processors in the hardware layer to create virtual processors on which each of the virtual machines executes. For execution efficiency the virtualization layer attempts to allow virtual machines to directly execute non privileged instructions and to directly access non privileged registers and memory. However when the operating system within a virtual machine accesses virtual privileged instructions virtual privileged registers and virtual privileged memory through the virtualization layer interface the accesses may result in execution of virtualization layer code to simulate or emulate the privileged resources. The virtualization layer additionally includes a kernel module that manages memory communications and data storage machine resources on behalf of executing virtual machines. The kernel for example may maintain shadow page tables on each virtual machine so that hardware level virtual memory facilities can be used to process memory accesses. The kernel may additionally include routines that implement virtual communications and data storage devices as well as device drivers that directly control the operation of underlying hardware communications and data storage devices. Similarly the kernel virtualizes various other types of I O devices including keyboards optical disk drives and other such devices. The virtualization layer essentially schedules execution of virtual machines much like an operating system schedules execution of application programs so that the virtual machines each execute within a complete and fully functional virtual hardware layer.

A virtual machine or virtual application described below is encapsulated within a data package for transmission distribution and loading into a virtual execution environment. One public standard for virtual machine encapsulation is referred to as the open virtualization format OVF . The OVF standard specifies a format for digitally encoding a virtual machine within one or more data files. illustrates an OVF package. An OVF package includes an OVF descriptor an OVF manifest an OVF certificate one or more disk image files and one or more resource files . The OVF package can be encoded and stored as a single file or as a set of files. The OVF descriptor is an XML document that includes a hierarchical set of elements each demarcated by a beginning tag and an ending tag. The outermost or highest level element is the envelope element demarcated by tags and . The next level element includes a reference element that includes references to all files that are part of the OVF package a disk section that contains meta information about all of the virtual disks included in the OVF package a networks section that includes meta information about all of the logical networks included in the OVF package and a collection of virtual machine configurations which further includes hardware descriptions of each virtual machine . There are many additional hierarchical levels and elements within a typical OVF descriptor. The OVF descriptor is thus a self describing XML file that describes the contents of an OVF package. The OVF manifest is a list of cryptographic hash function generated digests of the entire OVF package and of the various components of the OVF package. The OVF certificate is an authentication certificate that includes a digest of the manifest and that is cryptographically signed. Disk image files such as disk image file are digital encodings of the contents of virtual disks and resource files are digitally encoded content such as operating system images. A virtual machine or a collection of virtual machines encapsulated together within a virtual application can thus be digitally encoded as one or more files within an OVF package that can be transmitted distributed and loaded using well known tools for transmitting distributing and loading files. A virtual appliance is a software service that is delivered as a complete software stack installed within one or more virtual machines that is encoded within an OVF package.

The advent of virtual machines and virtual environments has alleviated many of the difficulties and challenges associated with traditional general purpose computing. Machine and operating system dependencies can be significantly reduced or entirely eliminated by packaging applications and operating systems together as virtual machines and virtual appliances that execute within virtual environments provided by virtualization layers running on many different types of computer hardware. A next level of abstraction referred to as virtual data centers or virtual infrastructure provide a data center interface to virtual data centers computationally constructed within physical data centers. illustrates virtual data centers provided as an abstraction of underlying physical data center hardware components. In a physical data center is shown below a virtual interface plane . The physical data center consists of a virtual data center management server and any of various different computers such as PCs on which a virtual data center management interface may be displayed to system administrators and other users. The physical data center additionally includes generally large numbers of server computers such as server computer that are coupled together by local area networks such as local area network that directly interconnects server computer and and a mass storage array . The physical data center shown in includes three local area networks and that each directly interconnects a bank of eight servers and a mass storage array. The individual server computers such as server computer each includes a virtualization layer and runs multiple virtual machines. Different physical data centers may include many different types of computers networks data storage systems and devices connected according to many different types of connection topologies. The virtual data center abstraction layer a logical abstraction layer shown by a plane in abstracts the physical data center to a virtual data center comprising one or more resource pools such as resource pools one or more virtual data stores such as virtual data stores and one or more virtual networks. In certain implementations the resource pools abstract banks of physical servers directly interconnected by a local area network.

The virtual data center management interface allows provisioning and launching of virtual machines with respect to resource pools virtual data stores and virtual networks so that virtual data center administrators need not be concerned with the identities of physical data center components used to execute particular virtual machines. Furthermore the virtual data center management server includes functionality to migrate running virtual machines from one physical server to another in order to optimally or near optimally manage resource allocation provide fault tolerance and high availability by migrating virtual machines to most effectively utilize underlying physical hardware resources to replace virtual machines disabled by physical hardware problems and failures and to ensure that multiple virtual machines supporting a high availability virtual appliance are executing on multiple physical computer systems so that the services provided by the virtual appliance are continuously accessible even when one of the multiple virtual appliances becomes compute bound data access bound suspends execution or fails. Thus the virtual data center layer of abstraction provides a virtual data center abstraction of physical data centers to simplify provisioning launching and maintenance of virtual machines and virtual appliances as well as to provide high level distributed functionalities that involve pooling the resources of individual physical servers and migrating virtual machines among physical servers to achieve load balancing fault tolerance and high availability.

The distributed services include a distributed resource scheduler that assigns virtual machines to execute within particular physical servers and that migrates virtual machines in order to most effectively make use of computational bandwidths data storage capacities and network capacities of the physical data center. The distributed services further include a high availability service that replicates and migrates virtual machines in order to ensure that virtual machines continue to execute despite problems and failures experienced by physical hardware components. The distributed services also include a live virtual machine migration service that temporarily halts execution of a virtual machine encapsulates the virtual machine in an OVF package transmits the OVF package to a different physical server and restarts the virtual machine on the different physical server from a virtual machine state recorded when execution of the virtual machine was halted. The distributed services also include a distributed backup service that provides centralized virtual machine backup and restore.

The core services provided by the VDC management server include host configuration virtual machine configuration virtual machine provisioning generation of virtual data center alarms and events ongoing event logging and statistics collection a task scheduler and a resource management module. Each physical server also includes a host agent virtual machine through which the virtualization layer can be accessed via a virtual infrastructure application programming interface API . This interface allows a remote administrator or user to manage an individual server through the infrastructure API. The virtual data center agents access virtualization layer server information through the host agents. The virtual data center agents are primarily responsible for offloading certain of the virtual data center management server functions specific to a particular physical server to that physical server. The virtual data center agents relay and enforce resource allocations made by the VDC management server relay virtual machine provisioning and configuration change commands to host agents monitor and collect performance statistics alarms and events communicated to the virtual data center agents by the local host agents through the interface API and to carry out other similar virtual data management tasks.

The virtual data center abstraction provides a convenient and efficient level of abstraction for exposing the computational resources of a cloud computing facility to cloud computing infrastructure users. A cloud director management server exposes virtual resources of a cloud computing facility to cloud computing infrastructure users. In addition the cloud director introduces a multi tenancy layer of abstraction which partitions VDCs into tenant associated VDCs that can each be allocated to a particular individual tenant or tenant organization both referred to as a tenant. A given tenant can be provided one or more tenant associated VDCs by a cloud director managing the multi tenancy layer of abstraction within a cloud computing facility. The cloud services interface in exposes a virtual data center management interface that abstracts the physical data center.

Considering the VDC server and cloud director layers of abstraction can be seen as discussed above to facilitate employment of the virtual data center concept within private and public clouds. However this level of abstraction does not fully facilitate aggregation of single tenant and multi tenant virtual data centers into heterogeneous or homogeneous aggregations of cloud computing facilities. The current document is directed to providing an additional layer of abstraction to facilitate aggregation of cloud computing facilities.

Client systems may include any of many types of processor controlled devices including tablet computers laptop computers mobile smart phones and other such processor controlled devices. These various types of clients may include only a subset of the components included in a desktop personal component as well components not generally included in desktop personal computers.

Electronic communications between computer systems generally comprises packets of information referred to as datagrams transferred from client computers to server computers and from server computers to client computers. In many cases the communications between computer systems is commonly viewed from the relatively high level of an application program which uses an application layer protocol for information transfer. However the application layer protocol is implemented on top of additional layers including a transport layer Internet layer and link layer. These layers are commonly implemented at different levels within computer systems. Each layer is associated with a protocol for data transfer between corresponding layers of computer systems. These layers of protocols are commonly referred to as a protocol stack. In a representation of a common protocol stack is shown below the interconnected server and client computers and . The layers are associated with layer numbers such as layer number 1 associated with the application layer . These same layer numbers are used in the depiction of the interconnection of the client computer with the server computer such as layer number 1 associated with a horizontal dashed line that represents interconnection of the application layer of the client computer with the applications services layer of the server computer through an application layer protocol. A dashed line represents interconnection via the application layer protocol in because this interconnection is logical rather than physical. Dashed line represents the logical interconnection of the operating system layers of the client and server computers via a transport layer. Dashed line represents the logical interconnection of the operating systems of the two computer systems via an Internet layer protocol. Finally links and and cloud together represent the physical communications media and components that physically transfer data from the client computer to the server computer and from the server computer to the client computer. These physical communications components and media transfer data according to a link layer protocol. In a second table aligned with the table that illustrates the protocol stack includes example protocols that may be used for each of the different protocol layers. The hypertext transfer protocol HTTP may be used as the application layer protocol the transmission control protocol TCP may be used as the transport layer protocol the Internet protocol IP may be used as the Internet layer protocol and in the case of a computer system interconnected through a local Ethernet to the Internet the Ethernet IEEE 802.3u protocol may be used for transmitting and receiving information from the computer system to the complex communications components of the Internet. Within cloud which represents the Internet many additional types of protocols may be used for transferring the data between the client computer and server computer.

Consider the sending of a message via the HTTP protocol from the client computer to the server computer. An application program generally makes a system call to the operating system and includes in the system call an indication of the recipient to whom the data is to be sent as well as a reference to a buffer that contains the data. The data and other information are packaged together into one or more HTTP datagrams such as datagram . The datagram may generally include a header as well as the data encoded as a sequence of bytes within a block of memory. The header is generally a record composed of multiple byte encoded fields. The call by the application program to an application layer system call is represented in by solid vertical arrow . The operating system employs a transport layer protocol such as TCP to transfer one or more application layer datagrams that together represent an application layer message. In general when the application layer message exceeds some threshold number of bytes the message is sent as two or more transport layer messages. Each of the transport layer messages includes a transport layer message header and an application layer datagram . The transport layer header includes among other things sequence numbers that allow a series of application layer datagrams to be reassembled into a single application layer message. The transport layer protocol is responsible for end to end message transfer independent of the underlying network and other communications subsystems and is additionally concerned with error control segmentation as discussed above flow control congestion control application addressing and other aspects of reliable end to end message transfer. The transport layer datagrams are then forwarded to the Internet layer via system calls within the operating system and are embedded within Internet layer datagrams each including an Internet layer header and a transport layer datagram. The Internet layer of the protocol stack is concerned with sending datagrams across the potentially many different communications media and subsystems that together comprise the Internet. This involves routing of messages through the complex communications systems to the intended destination. The Internet layer is concerned with assigning unique addresses known as IP addresses to both the sending computer and the destination computer for a message and routing the message through the Internet to the destination computer. Internet layer datagrams are finally transferred by the operating system to communications hardware such as a network interface controller NIC which embeds the Internet layer datagram into a link layer datagram that includes a link layer header and generally includes a number of additional bytes appended to the end of the Internet layer datagram. The link layer header includes collision control and error control information as well as local network addresses. The link layer packet or datagram is a sequence of bytes that includes information introduced by each of the layers of the protocol stack as well as the actual data that is transferred from the source computer to the destination computer according to the application layer protocol.

Next the RESTful approach to web service APIs is described beginning with . illustrates the role of resources in RESTful APIs. In and in subsequent figures a remote client is shown to be interconnected and communicating with a service provided by one or more service computers via the HTTP protocol . Many RESTful APIs are based on the HTTP protocol. Thus the focus is on the application layer in the following discussion. However as discussed above with reference to the remote client and service provided by one or more server computers are in fact physical systems with application operating system and hardware layers that are interconnected with various types of communications media and communications subsystems with the HTTP protocol the highest level layer in a protocol stack implemented in the application operating system and hardware layers of client computers and server computers. The service may be provided by one or more server computers as discussed above in a preceding section. As one example a number of servers may be hierarchically organized as various levels of intermediary servers and end point servers. However the entire collection of servers that together provide a service are addressed by a domain name included in a uniform resource identifier URI as further discussed below. A RESTful API is based on a small set of verbs or operations provided by the HTTP protocol and on resources each uniquely identified by a corresponding URL Resources are logical entities information about which is stored on one or more servers that together comprise a domain. URIs are the unique names for resources. A resource about which information is stored on a server that is connected to the Internet has a unique URI that allows that information to be accessed by any client computer also connected to the Internet with proper authorization and privileges. URIs are thus globally unique identifiers and can be used to specify resources on server computers throughout the world. A resource may be any logical entity including people digitally encoded documents organizations and other such entities that can be described and characterized by digitally encoded information. A resource is thus a logical entity. Digitally encoded information that describes the resource and that can be accessed by a client computer from a server computer is referred to as a representation of the corresponding resource. As one example when a resource is a web page the representation of the resource may be a hypertext markup language HTML encoding of the resource. As another example when the resource is an employee of a company the representation of the resource may be one or more records each containing one or more fields that store information characterizing the employee such as the employee s name address phone number job title employment history and other such information.

In the example shown in the web servers provides a RESTful API based on the HTTP protocol and a hierarchically organized set of resources that allow clients of the service to access information about the customers and orders placed by customers of the Acme Company. This service may be provided by the Acme Company itself or by a third party information provider. All of the customer and order information is collectively represented by a customer information resource associated with the URI http www.acme.com customerInfo . As discussed further below this single URI and the HTTP protocol together provide sufficient information for a remote client computer to access any of the particular types of customer and order information stored and distributed by the service . A customer information resource represents a large number of subordinate resources. These subordinate resources include for each of the customers of the Acme Company a customer resource such as customer resource . All of the customer resources are collectively named or specified by the single URI http www.acme.com customerInfo customers . Individual customer resources such as customer resource are associated with customer identifier numbers and are each separately addressable by customer resource specific URIs such as URI http www.acine.com customerInfo customers 361 which includes the customer identifier 361 for the customer represented by customer resource . Each customer may be logically associated with one or more orders. For example the customer represented by customer resource is associated with three different orders each represented by an order resource. All of the orders are collectively specified or named by a single URI http www.acme.com customerInfo orders . All of the orders associated with the customer represented by resource orders represented by order resources can be collectively specified by the URI http www.acme.com customerInfo customers 361 orders . A particular order such as the order represented by order resource may be specified by a unique URI associated with that order such as URI http www.acme.com customerInfo customers 361 orders 1 where the final 1 is an order number that specifies a particular order within the set of orders corresponding to the particular customer identified by the customer identifier 361. 

In one sense the URIs bear similarity to path names to files in file directories provided by computer operating systems. However it should be appreciated that resources unlike files are logical entities rather than physical entities such as the set of stored bytes that together compose a file within a computer system. When a file is accessed through a path name a copy of a sequence of bytes that are stored in a memory or mass storage device as a portion of that file are transferred to an accessing entity. By contrast when a resource is accessed through a URI a server computer returns a digitally encoded representation of the resource rather than a copy of the resource. For example when the resource is a human being the service accessed via a URI specifying the human being may return alphanumeric encodings of various characteristics of the human being a digitally encoded photograph or photographs and other such information. Unlike the case of a file accessed through a path name the representation of a resource is not a copy of the resource but is instead some type of digitally encoded information with respect to the resource.

In the example RESTful API illustrated in a client computer can use the verbs or operations of the HTTP protocol and the top level URI to navigate the entire hierarchy of resources in order to obtain information about particular customers and about the orders that have been placed by particular customers.

As further discussed below and as mentioned above a service may return in response messages various different links or URIs in addition to a resource representation. These links may indicate to the client additional resources related in various different ways to the resource specified by the URI associated with the corresponding request message. As one example when the information returned to a client in response to a request is too large for a single HTTP response message it may be divided into pages with the first page returned along with additional links or URIs that allow the client to retrieve the remaining pages using additional GET requests. As another example in response to an initial GET request for the customer info resource in the service may provide URIs and in addition to a requested representation to the client using which the client may begin to traverse the hierarchical resource organization in subsequent GET requests.

Returning of hyperlinks or additional URIs by a service to a client can also be used to dynamically extend an initial API. illustrate extension of the simple RESTful API discussed above with reference to D. illustrates the hierarchical organization of resources in the initial RESTful API . illustrates an extended RESTful API . The extension involves adding an additional set of resources at the lowest hierarchical level that represent the status of orders. Thus each order resource such as order resource is now associated with a corresponding status resource . This RESTful API extension may be undertaken by the service or may be undertaken by an appropriately authorized client. However in either case once the extension is carried out the service needs to inform clients unaware that the extension has occurred of the availability of additional information. This can be accomplished by including additional links in responses.

As can be appreciated from the high level control flow diagram A C in the approach illustrated in these figures the server bears a rather significant processing burden with respect to the extension of an API. Extension of the API based on the resources shown in for example to the resources shown in may require significant specialized control logic such as a series of conditionals and routine calls similar to step and in in order to provide links to the new status resources in response messages corresponding to GET requests for orders. Should the server wish to add additional links to GET requests for the collection of orders then even greater computational and development burdens would ensue. Although it may be possible to write somewhat more generic logic for handling the simple extension illustrated in the somewhat more generic logic would still require significant development efforts. For a more complex API featuring significantly more types of resources and more resources of particular types the computational and development burdens may become significant and even prohibitive. Were clients to extend the API through PUT requests then an even more complex distributed effort would be needed to enable clients to alter server logic for processing requests and adding additional related links to request responses.

The a new approach for extending RESTful APIs without incurring significant computational and development overheads as discussed above with reference to is next discussed. The approach uses a link registry. The link registry is a collection of link registry entries each of which represents additional links added to response messages corresponding to request messages directed to a particular resource. illustrate an example link registry. illustrates one implementation of a link registry entry. The link registry entry is a variable length record that includes numerous fields. In example link registry entry these fields include 1 ResourceURI a field containing a symbol string representation of the URI to which a request message may be directed 2 numKvp the number of key value pairs that follow this field 3 a number of key value field pairs equal to the value in the field numKvp the key value pairs representing various types of conditions or constraints with respect to returning additional links further discussed below 4 numLinks a field indicating the number of links that follow this field and 5 a number of link fields such as fields and equal to the value stored in the numLinks field each link field storing a representation of a link to be added to the response message such as the related link in . Note that each link may include multiple key value pairs such as the three key value pairs included in link .

A link registry entry may be represented in JSON. illustrates a JSON encoding of a particular link registry entry. Key value pairs are used in the JSON representation to represent the various fields and values stored in the fields. For example the Resource URI field in is represented by key ResourceURI and a particular symbol string representation of a particular URI . Similarly the numKvp field in is represented by key and value .

In one implementation the link registry is made accessible via a simple link registry API which is a subset of the RESTful customer information API discussed above with reference to . shows example method calls to a simple link registry API. The link registry is associated with a URI . The link registry can be accessed using the GET PUT POST and DELETE HTTP methods. Examples are provided in . The GET request can be used to obtain a representation of the entire link registry including representations of all of the link registry entries. GET request may be used to find a link registry entry corresponding to the collective customers resource. PUT request can be used to store or update the link registry entry for the customers collective resource with the link registry entry represented by symbol string LinkRegistryEntry . The link registry entry corresponding to the collective customers resource can be deleted using the DELETE request . The link registry entry corresponding to a particular customer can be retrieved using GET request .

The key value pairs contained in a link registry entry provides a mechanism for directing additional links to response messages with particular characteristics. For example because resources are often hierarchically organized it may be desirable in certain cases for additional links to be added with respect to an intermediate level resource in the path of a lower level resource. In other words as shown in when the value of the resource URI field is http www.acme.com customerInfo customers the creator of the link registry entry may desire for the additional link specified in the link registry entry to be added in a response message to a request for a representation of the resource http www.acme.com customerInfo customers 361 orders 1. On the other hand the author of the link registry entry may wish for the additional links only to be added when a representation of the specific resource http www.acme.com customerInfo customers is requested in a request message. In one scheme illustrated in the key appliedTo may be associated with either the value terminal or non terminal. When the value is terminal then the specified additional links are added only when the URI in the request message exactly matches the URI in the field ResourceURI of the link registry entry. However when the value is non terminal then a requested URI that contains the value of the Resource URI field as an initial substring should be responded to with a response message that contains the additional links. Other key value pairs may indicate that the additional link should only be added for response messages containing particular values and or for request messages containing particular values. In the example shown in the two key value pairs specify that the additional link should be included in a response message only when the body of the response message contains the key value pairs city Des Moines and state Iowa. In alternative implementations a link registry entry may omit the numKvp and kvp keys and associated values and simply add additional links into the response message corresponding to a request message requesting a representation of a resource specified by a URI that exactly matches the value of the ResourceURI field of the link registry entry. In yet alternative implementations many different types of additional filtering and selection specifiers may be included in a link registry entry including range specifiers relational operators and other features common to for example relational database queries.

The VCC server and VCC nodes discussed above provide a virtualization infrastructure for the management of distributed multi tenant virtual cloud computing facilities or virtual data centers. The management functionality is referred to as the cloud director. The cloud director is implemented as a distributed management infrastructure implemented by a combination of the VCC nodes and the VCC server and provides both a management interface as well as a suite of software services and facilities accessible to cloud operators system administrators and other such clients of the cloud director.

While the cloud director provided functionalities and services are of great benefit to cloud director users it is often the case that for particular virtual data centers and collections of virtual data centers a cloud operator or system administrator may wish to supplement and enhance the facilities and services provided by the cloud director. In certain cases a cloud operator or system administrator may wish to provide additional functionalities and services based on existing functionalities and services that were not developed for multi tenant VDCs and which are unaware of and cannot use the multi tenancy infrastructure used by cloud director provided facilities and services. Currently incorporating multi tenancy unaware facilities and services into the cloud director provided functionalities and services can be a rather daunting task for developers and users of the cloud director interface.

As one example of the cloud director provided extensibility through the cloud API entrypoint a cloud operator may extend through the cloud operator interface the services provided by the cloud director to include a newly developed or legacy backup service for VDCs that can then be accessed through the client interface portion of the cloud API entrypoint by various types of authorized users including other cloud operators system administrators and other types of privileged users. In addition a cloud director provided service may be redefined by extension.

In only a few fields for each data object are shown. The data objects may include additional fields or different fields in different implementations. A resource class data object such as data object includes the name of the resource class and a resource class ID or resource ID. Resource classes refer to general classes of services. A particular instance of a resource class is a service resource represented by a service resource data object such as data object . A service resource data object includes a name service ID organization ID and resource class ID. As one example backup services may be described by a particular resource class represented by a resource class data object and each particular instance of the backup resource class may each be described by a service resource data object. An entity data object such as data object represents either a resource class or a service. An entity data object includes a name entity ID a type indicating whether the entity represents a resource class or service resource and the ID for the resource class or service resource. An organization data object such as data object includes the name of an organization and an organization ID associated with the organization. An action data object such as data object includes the name of an action an action ID the identifier of the entity that represents a resource class or service resource that supports the action and a URI pattern that specifies one or more URIs that represent the action. An action is equivalent to a function provided by a type of resource class or by a specific service resource. For example an action can be defined for all backups or for a particular backup service resource. The URI pattern is a named regular expression in which matches one or more resource identifiers. The id tag may or may not be present in a particular URI pattern. A user data object such as data object includes the name of a user the ID of the organization the user is a member of and a user ID. A group data object such as data object includes the name of the group an organization ID for the organization that supports the group and the group ID. A right data object such as data object includes the name of a right and an ID associated with the right. A role data object such as data object includes the name of a role and an ID associated with the role. A security principles data object such as data object includes a name an ID associated with the security principle a type indicating one of a user group right or role and the ID of the user group right or role.

All of the above discussed data objects including resource class service resource action organization user group right role entity and security principle data objects are used to define ACL rules. An ACL rule represents a specific authorization to which a request for a service can be matched in order to determine whether or not the request is authorized. Each ACL rule such as ACL rule includes an ID of an entity data object an ID of an action data object an ID of an organization data object the ID of the security principle data object and an ACL ID . An ACL rule thus defines a relationship between a resource class or service an action an organization and one of a user group right or role. For example an ACL rule may authorize for a specific action that may be requested of a specific service resource access by a member of an organization according to a particular security principle. The security principle can specify a specific user of the organization that can access the action of the service a group of users of the organization that can access the action of the service a member of an organization holding a particular right to access the action of the service or a member of the organization that is associated with a particular role to access the action of the service. Various different types of rights and roles can be defined. Roles may include job titles job descriptions or positions such as cloud owner or system administrator. Rights may include various types of access rights such as superuser access rights. An ACL rule may specify authorization for a particular service resource or for a particular resource class of which there are one or more service resource instances. The authorization service database includes various types of default data objects such as any data objects that operate much like wildcards in ACL rules and shared data objects. An any data object matches any other data object of the same type. A shared data object matches multiple organization data objects.

A subset of the cloud operator interface in provided through the cloud API entrypoint is an authorization service management interface. This is a RESTful interface that allows for the creation retrieval and deletion of various data objects in the authorization service database described above with reference to . provides a table based description of a portion of the authorization service management interface. For example the table in a first column includes four authorization service management interface ASMI operations that allow for the creation of a resource class retrieval of a description of the resource class by resource class ID retrieval of a list of resource classes and deletion of a resource class. In a second column of table the corresponding HTTP operations are shown for each ASMI operation. shows as one example an HTTP XML implementation of the ASMI operations in associated with resource classes. Thus the ASMI subset of the cloud operator interface subset of the cloud API entrypoint allows authorized cloud director users to create and delete primitive and collective data objects in the authorization service database as well as to create and delete ACL rules. Creation and deletion of data objects stored in the authorization service database alters operation of the authorization service and defines how requests to service actions are authorized by the authorization service. Of course access to the ASMI interface is controlled by the cloud director multi tenancy infrastructure so that only authorized and verified users can alter and manage portions of the authorization service interface.

Thus the authorization service provided by the cloud director backend and the ASMI provided through the cloud API entrypoint provides a flexible and powerful access control functionality to the various services and functionalities added to the cloud director provided functionalities and services by the extension facility provided through the cloud operator interface via the cloud API entrypoint. Cloud operators and other superusers can therefore supplement and even redefine cloud director provided functionalities and services while at the same time associating the functionality and services with access control rules in order that the functionalities and services operate within a multi tenant VDC environment.

Although the present invention has been described in terms of particular embodiments it is not intended that the invention be limited to these embodiments. Modifications within the spirit of the invention will be apparent to those skilled in the art. For example the authorization service can be implemented in many different ways by varying any of many different design implementation and deployment parameters including the virtualization layer in which the stretch deploy operation is implemented programming language control structures data structures modular organization and other such design and implementation parameters. In the above discussed implementation of the authorization service specific types of data objects and primitives are stored in the authorization service database and used to specify ACL rules. In alternative implementations other types of data objects may be stored for the purpose of defining ACL rules. ACL rules may be expressed in many different types of encodings in alternative implementations.

It is appreciated that the previous description of the disclosed embodiments is provided to enable any person skilled in the art to make or use the present disclosure. Various modifications to these embodiments will be readily apparent to those skilled in the art and the generic principles defined herein may be applied to other embodiments without departing from the spirit or scope of the disclosure. Thus the present disclosure is not intended to be limited to the embodiments shown herein but is to be accorded the widest scope consistent with the principles and novel features disclosed herein.

