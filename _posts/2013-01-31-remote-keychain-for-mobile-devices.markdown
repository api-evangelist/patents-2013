---

title: Remote keychain for mobile devices
abstract: An app of a mobile device registers the mobile device for a remote credential server (RCS) and receives a device token. When a credential for a remote asset is supplied on the mobile device it is routed to the RCS and stored external to the mobile device but referenced on the mobile device via an asset token. When the credential is needed, the device token and the asset token permit the RCS to authenticate and return the credential to or on behalf of the mobile device so that the mobile device can authenticate to and access the remote asset.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08904504&OS=08904504&RS=08904504
owner: NetlQ Corporation
number: 08904504
owner_city: Provo
owner_country: US
publication_date: 20130131
---
As the industry increases the use of mobile devices there is a problem when users work in a mixed environment of desktop machines and mobile devices.

Beyond interface issues associated with the smaller device screens of mobile devices enterprises face a plethora of security related issues when allowing these mobile devices to access enterprise assets. Yet there is a tremendous need for allowing access to assets via mobile devices since this is the manner in which people work and communicate nowadays and since the growth of mobile usage has been exponential in recent years.

Consider the security issue associated with the corporate credentials or secrets such as name and passwords which can be stored on a user s mobile device. Various vendors such as Apple have tried to make this safer by providing a keychain. The keychain provides a place where credentials can be encrypted on the device for safer storage. The problem is that the credentials are still stored on the device and if the device is lost or stolen the corporate credentials can be discovered and exposed. The amount of work to get the credentials varies greatly depending on the device state. Some examples of a device state can be suspension or hibernation. In addition access to the credentials might depend on if they were ever cached in memory. In either case if a device is lost the user or administrator must change all corporate passwords that were stored on the lost device. This is further compounded as the user may not realize the device is lost and or be able to signal the system that they lost his her device. Once the loss of the device is discovered the user or administrator has no way to know if the secrets have been discovered.

In addition storing the password on the device means it must be sent from the mobile device to a backend enterprise service. This adds a risk that the password may be discovered while it is being sent and is exposed on a network.

Lastly Apple mobile devices that use iOS separate keychains on the device for each application and are not shared. This means that if more than one application needs the same credentials they must be entered and stored once for each application. This introduces the possibility of transcription errors as well as exposure to the passwords.

As stated above and for other reasons security is an issue of import when enterprises attempt to integrate mobile device access to enterprise assets.

Various embodiments of the invention provide techniques for remoting a keychain of a mobile device. In an embodiment a method for remoting a mobile device keychain is presented.

Specifically a device token is requested from a remote server and the device token is returned in response to that request. Next the device token is passed to a keychain application for storage in a keychain. Then a reference identifier and a credential are sent to the remote server with the device token and in response an asset token linked to the credential and reference identifier are acquired. Finally the keychain application is instructed to store the asset token and the reference identifier in the keychain. In retrieving the credential the device token the asset token and the reference identifier are sent to the remote server and the remote server returns the credential for use with authenticating and access a remote asset.

A resource includes a user service system device directory data store groups of users combinations and or collections of these things etc. A principal is a specific type of resource such as an automated service or user that at one time or another is an actor on another principal or another type of resource. A designation as to what is a resource and what is a principal can change depending upon the context of any given network transaction. Thus if one resource attempts to access another resource the actor of the transaction may be viewed as a principal. Resources can acquire and be associated with unique identities to identify unique resources during network transactions.

An identity is something that is formulated from one or more identifiers and secrets that provide a statement of roles and or permissions that the identity has in relation to resources. An identifier is information which may be private and permits an identity to be formed and some portions of an identifier may be public information such as a user identifier name etc. Some examples of identifiers include social security number SSN user identifier and password pair account number retina scan fingerprint face scan etc.

A processing environment defines a set of cooperating computing resources such as machines processor and memory enabled devices storage software libraries software systems etc. that form a logical computing infrastructure. A logical computing infrastructure means that computing resources can be geographically distributed across a network such as the Internet. So one computing resource at network site X and be logically combined with another computing resource at network site Y to form a logical processing environment.

The phrases processing environment cloud processing environment and the term cloud may be used interchangeably and synonymously herein.

Moreover it is noted that a cloud refers to a logical and or physical processing environment as discussed above.

Also the techniques presented herein are implemented in machines such as processor or processor enabled devices hardware processors . These machines are configured and programmed to specifically perform the processing of the methods and systems presented herein. Moreover the methods and systems are implemented and reside within a non transitory computer readable storage media or machine readable storage medium and are processed on the machines configured to perform the methods.

Of course the embodiments of the invention can be implemented in a variety of architectural platforms devices operating and server systems and or applications. Any particular architectural layout or implementation presented herein is provided for purposes of illustration and comprehension only and is not intended to limit aspects of the invention.

It is within this context that embodiments of the invention are now discussed within the context of the and .

The techniques herein allow credentials used for accessing remote network resources such as enterprise systems and or assets to be accessible in an automated manner from a mobile device of a user may also be referred to as a principal . The credentials are not stored on the mobile device but rather remotely stored and secured external to the mobile device. As stated above this plugs a security hole associated with providing access to assets via a mobile device.

A mobile device can refer to a smartphone a tablet a laptop or any other device that is capable of wireless communications and includes one or more processors with memory and or storage.

The techniques herein improve on the current state of the industry by enhancing mobile processing to provide additional functionality in the form of a Mobile Identity Vault MIV and a Mobile Remote KeyChain MRK Software Development Kit SDK . While expanding on current mobile functionality the techniques also expand a local mobile device s keychain such as iOS to allow application writers software developers to use a similar SDK call structure to store credentials on a remote Identity Vault. In the examples of the the SDK provides the same call structure as the iOS KeyChain SDK with a few enhancements. Generally the IOS KeyChain SDK provides the ability to add delete read and modify items in a keychain for applications. Each item can have attributes which describe the item and secret data that is encrypted and stored in the KeyChain. Under iOS the secret data can only be read by the application on the device that wrote it. However with the embodiments herein the secret is stored remotely away from the device with a goal of protecting the secret against a lost or compromised device. The secret is stored on a server and the server provides back a token which goes into the keychain on the mobile device. The token can later be used to retrieve the secret from the remote source. This token can also be used by other applications if policy allows accessing the secret. Each time a secret is retrieved from the MIV an audit event is created this provides detection of secrets being used after the loss of a mobile device.

Reference is now made to the processing interactions discussed between a mobile device and a remote keychain server as shown in the .

The iOS Application makes a request to initialize the Mobile Remote KeyChain MRK SDK via A . The MRK makes a call to get a DeviceOrServiceToken DOST from the local KeyChain via B but there is no valid DOST as of yet. So the MRK prompts for a valid credential such as a name and password this maybe the credentials of the end user or some other person assigned to setup mobile devices. The MRK calls the Remote KeyChain Service RKS with a request for a DOST and the credentials via C . The policy of the MRK validates credentials and policy. If allowed the RKS sends a valid DOST to the MRK via D . The DOST is now stored in the Local iOS KeyChain via E . The MRK then uses the DOST to complete the original request of the application via F . This is described in greater detail herein and below. Credentials that are used are removed from the device and the MRK returns to the iOS Application via G .

The techniques provide a same functionality as the iOS KeyChain SDK does but uses the Mobile Remote KeyChain to store the attributes without storing the secret data on the mobile device. In the secret data s place a SecetDataAccessToken SDAT is stored in the mobile KeyChain which is used by a remote server to access the secret data. The SDAT is used to get the secret data the requestor user or principal must also have a DOST that is authorized to retrieve the secret data.

The is a flow diagram that shows how a mobile device obtains a credential such as a name and password for the user and stores and retrieves the credential using techniques presented herein. This process flow uses Apple iOS as an example but the invention is not limited to iOS again iOS is used for purposes of illustration and comprehension with the examples provided in the .

For context a normal flow of an iOS application using the iOS KeyChain is initially discussed. The application prompts a user for a Name and Password and if they are correct the application calls the iOS SDK and stores the information in the keychain via A with a reference ID. The next time the user needs to login the application requests the password from the keychain SDK with the reference ID and it is returned to the application via B . The password is protected such that only the iOS application on the mobile device that wrote it is allowed to read it.

With the techniques herein the flow and SDK calls from the view of the application are similar. The application prompts the user for a Name and Password and if they are correct the application calls the Mobile Remote KeyChain MRK SDK with reference ID to store the information via C .

The processing changes and traditional processing enhanced by the MRK reading the DOST from the local KeyChain via D and receiving the DOST via E . The MRK now sends the name password and reference ID via F to the Remote KeyChain Service RKS using the DOST as an authorization token. This example can use the OAuth Open Standards for Authentication protocol. The RKS validates the DOST and identifies the user and the device. The RKS now uses policy to determine the rights of the device and user. If allowed the name password and reference ID are written to the identity vault via G . The RKS now builds an SDAT that allows access to the name and password just stored in the identity vault. This SDAT is sent back to the MRK via H . The SDAT and reference ID is now stored in the Local iOS Key Chain. From the view of the application the steps C J are the same as step A .

When the mobile application needs to retrieve the name and password stored using the MRK it makes an SDK call to the MRK using the reference ID used to store it via L . The reference ID can be a single value or made up of multiple attributes that identify the secret. The MRK now uses the reference ID to read the local iOS keychain via M and retrieves the SDAT and the DOST from the iOS keychain via N . The DOST SDAT and reference ID are sent to the RKS via P . The RKS now uses policy to determine the rights of the device and user. If allowed the name password pointed to by the reference ID are requested from the identity vault via R and returned via S . The RKS sends the password via T to the MRK. The MRK now returns that name and password to the iOS application via U . These steps L U from the view of the application are the same as step B .

As an option the MRK can also generate a secret which can be stored in the Local iOS KeyChain and used to encrypt the secret before it is sent to the RKS. The secret can be linked to the DOST and or the SDAT. This means that the data stored in the Mobile Identity Vault MIV cannot be used without the Local KeyChain on the mobile device. This feature limits the share function described herein and below.

The is an example of how the embodiments of the invention can be used to share secrets between applications on an iOS device. Currently iOS does NOT allow applications from different vendors to share KeyChain secrets. So techniques herein allow policy on a remote server to enable such a feature on an iOS device.

The iOS Application 1 stores a secret with a reference ID of XYZ using the MRK the same as shown in the above example SecretWriteandRead steps C J . Application 1 passes the SDAT for the XYZ secret to Application 2. This can be done as Application 1 launches Application 2. This is not show in the . Application 2 makes a request to the MRK asking for a secret with a reference ID of XYZ using the SDAT it received from Application 1 via A . The MRK requests and gets its DOST from its Local IOS KeyChain via B . Each application has its own DOST saved in its own KeyChain. All applications on the iOS have their own KeyChain. The MRK now makes a request to the RKS asking the secret of the XYZ secret using its DOST and the SDAT received from Application 1 via F . The MRK now validates policy to verify that Application 2 is allowed to use a SDAT from Application 1 and if allowed the RKS retrieves the secret via G . The RKS now sends the secret to the MRK via H and then the SDAT may be stored in the Local KeyChain for Application 2 to use later via J . The RKS then sends the XYZ secret to Application 2 via K .

The is an example of how the techniques herein can be used to share secrets between a mobile application on an iOS device and a backend service. This allows a remote service to use corporate credentials without sending them over the network wire or storing them on the mobile device.

The iOS Application 1 stores a secret with a reference ID of XYZ using the MRK the same as shown in above example SecretWriteandRead steps C J . This is not shown in this flow diagram. The Application makes a request to the MRK for a SDAT via C . NOTE this is not a secret but rather a SDAT. The MRK requests and gets the SDAT via D . The MRK returns the SDAT to the Application via E . The Application now sends the SDAT as part of a normal request to the Remote Service via G . The SDAT can be sent as a Hyper Text Transfer Protocol HTTP Cookie Header or other means. The Remote KeyChain Access RKA in this example is acting as a proxy protecting the service. The RKA can also be an SDK included in the service. The RKA has its own DOST and sends it and the SDAT it just received to the RKS via H . The RKS validates the DOST and the SDAT and then verifies that policy allows the Remote Service to use the SDAT from the Client. If all is allowed the RKS retrieves the XYZ secret from the Identity Vault via I and then sends it to the RKA via J . The RKA uses the secret by injecting the XYZ secrets in the data stream to the Service via K . The secret can be injected in many ways such as the author s header form fill in or other headers.

As will become more apparent to one of ordinary skill in the art the techniques herein 1 keep secrets off of the mobile device by storing them on a corporate secure remote server 2 allows secrets to be shared between apps on devices that do not allow sharing of secrets between applications such as iOS devices 3 allows secrets to be shared with services at the corporation this prevents secrets from being stored on the mobile device or sent over the Internet from the mobile device for each access 4 may include additional keys used to decrypt the secret this prevents secrets from being discovered on the server to gain access to the secret BOTH the mobile device token mobile key and data on the sever are required 5 allows the device to send a token that may be used by other apps for services to obtain secrets 6 controls all of the above features by policy stored on the corporate secure remote servers this allows control of the corporate secrets 7 allows audits of all use or attempted use of the secrets used by services and or application 8 allows the detection of secrets used after the loss of the mobile device and or 9 allows all secrets to be disabled or destroyed by a user or an administrator without access to the mobile device. Lost stolen or misused devices can have the tokens to secrets rendered useless without recovering the device.

The mobile device credential manager provides the processing perspective of an agent that processes as an app or service on a mobile device phone tablet etc. . The mobile device credential manager interacts with a remote secure server service described below with reference to the .

At the mobile device credential manager requests a device token from a remote server. Examples of the remote server were presented above in the and are further presented below with reference to the . The request can occur indirectly when a principal automated application or a user attempts to access a remote asset resource via a keychain or authentication module on the mobile device that is processing the mobile device credential manager. Here the keychain is detected as lacking a device token and the mobile device credential manager makes a request to the remote server on behalf of the mobile device for the device token.

According to an embodiment at the mobile device credential manager authenticates the mobile device processing the mobile device credential manager and or the principal automated application or user to the remote server.

At the mobile device credential manager receives the device token back from the remote server. The device token provides a mechanism for the remote server to authenticate or partially authenticate the mobile device and or the principal.

In an embodiment at the mobile device credential manager obtains a signed device token signed by the remote server. For added security the device token s signature can be verified by the mobile device credential manager before being relied upon and used with a keychain application.

At the mobile device credential manager passes the device token to a keychain application for storage in a keychain. It is noted that the existing SDK or Application Programming Interface API for the keychain application that processes on the mobile device can be used and the keychain application does not have to be modified to integrate with the mobile device credential manager in the manners discussed herein.

According to an embodiment at the mobile device credential manager signs via the mobile device credential manager or the mobile device that processes the mobile device credential manager the device token before the device token is passed to the keychain application for storage in the keychain.

At the mobile device credential manager sends a reference identifier and a credential to the remote server with the device token. The reference identifier referring to a remote access remote resource . The credential is one or more sets of information used to authenticate either to or through a front end authentication service of the remote asset.

In an embodiment at the mobile device credential manager encrypts the credential before sending to the remote server over a network connection. This can ensure greater security for the credential. Moreover the connection between the mobile device and the remote server can itself be achieved via a secure connection.

In another case at the mobile device credential manager prompts a principal of the device to dynamically enter the credential for sending to the remote sever. So the credential is never stored on the mobile device although it may temporarily exists in memory on the mobile device. In some cases the principal may provide a reference to a third party identity service that can supply the credential on behalf of the principal. In this latter case the principal never actually enters and transmits the credential from the mobile device.

At the mobile device credential manager acquires an asset token linked to the credential and reference identifier. The asset token provides a mapping at the remote server between the remote asset via the reference identifier and the credential. The credential is not retained on the mobile device rather it is retained and managed on the remote server.

At the mobile device credential manager instructs the keychain application via a SDK or API of the keychain application to store the asset token and the reference identifier in the keychain.

According to an embodiment at the mobile device credential manager ensures the credential is deleted and removed from memory and storage on the device. This ensures that the credential is not accessible directly on the mobile device. So should the mobile device become stolen or lost there is little danger that access to the remote asset can be compromised and if compromised the damage can be restricted by revoking the device token at the remote server.

In an embodiment at the mobile device credential manager executes as a mobile device app that monitors calls made to and information produced from the keychain application. In this way and as stated above the keychain application does not have to be changed to interact with the mobile device credential manager. In fact the mobile app which is the mobile device credential manager can be acquired initially via an app store and dynamically downloaded and installed on the mobile device.

In another scenario at the mobile device credential manager provides the reference identifier to the keychain application. Next the mobile device credential manager receives the device token and the asset token back from the keychain application. Then the mobile device credential manager sends the reference identifier the device token and the asset token to the remote server wherein in response thereto the credential is received back from the remote server. Finally the mobile device credential manager uses the credential to authenticate to and access a remote asset.

Continuing with the embodiment of and at the mobile device credential manager obtains the credential in an encrypted format from the remote server.

In another case at the mobile device credential manager provides the reference identifier to the keychain application and in response thereto the device token and asset token are returned by the keychain application. Next the mobile device credential manager sends the reference identifier the device token and the asset token to the remote server. Up until this point the processing at is similar to that which was described above at . Finally the mobile device credential manager accesses the remote asset after the remote server authenticates the mobile device to the remote asset by providing the credential on behalf of the mobile device to the remote asset or an authentication service of the remote asset. This was discussed above with reference to the .

According to an embodiment at the mobile device credential manager communicates the reference identifier and the asset token to a mobile app that the mobile app can use with the remote server to authenticate to and access a remote asset using the credential managed by the remote server. This permits a credential to be shared across different keychains for different applications and perhaps even different mobile devices. This situation was discussed above with reference to the .

The server credential manager is presented from the perspective of a remote secure server device or cloud processing environment that interacts with clients via the mobile device credential manager discussed above with reference to the .

At the server credential manager registers a mobile device and supplies a device token to the mobile device to subsequently identifier and perhaps authenticate the mobile device.

At the server credential manager stores an association relation or relationship between a reference identifier and a credential received from the mobile device. The reference identifier identifies a remote asset and the credential provides authenticated access to the remote asset.

According to an embodiment at the server credential manager encrypts the credential with a secret associated with the mobile device or a principal of the mobile device before storing within the association on the server.

In another situation at the server credential manager decrypts the credential received from the mobile device and verifies a mobile device signature associated with the credential before storing within the association on the server.

At the server credential manager returns an asset token back to the mobile device. As discussed in detail herein and above the asset token is used on the mobile device within a keychain application or authentication manager to remotely reference via the server credential manager the credential needed to access the remote asset.

According to an embodiment at the server credential manager receives the device token the reference identifier and the asset token from a mobile device app on a mobile device such as the one discussed above with reference to the method of the . Then the server credential manager returns the credential back to the mobile device via the mobile device app. The mobile device can then use the credential to authenticate to and access the remote asset.

In one situation at the server credential manager receives a different device token for a different mobile device the reference identifier and the asset token. Then the server credential manager returns the credential back to the different mobile device when policy permits. This situation was discussed above with reference to the and permits credential sharing across mobile devices and or mobile device applications essentially keychain sharing in some instances .

In an embodiment at the server credential manager receives the device token the resource identifier and the asset token. Then the server credential manager supplies the credential to authenticate the mobile device or a principal associated with the mobile device to the remote asset. This situation was referred to above with reference to the .

According to an embodiment the keychain remoting system implements inter alia the features of the and .

The keychain remoting system includes a server device having memory configured with the server credential manager . Example processing associated with the server credential manager was presented above in detail with reference to the and . The server credential manager interacts with instances of mobile device credential managers described above with reference to the and the .

The server credential manager is configured to manage and dynamically distribute asset credentials for remote assets that are remote from mobile devices by supplying tokens to keychain applications to reference the asset credentials on the mobile devices and when the asset credentials are needed dynamically providing the asset credentials to the mobile devices or to the remote assets on behalf of the mobile devices.

According to an embodiment the server credential manager is further configured to distribute mobile apps when registering the mobile devices the mobile apps interact with the server credential manager and the keychain applications on the mobile devices. In an embodiment the mobile apps are instances of the method discussed above with reference to the .

The above description is illustrative and not restrictive. Many other embodiments will be apparent to those of skill in the art upon reviewing the above description. The scope of embodiments should therefore be determined with reference to the appended claims along with the full scope of equivalents to which such claims are entitled.

