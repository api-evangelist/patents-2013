---

title: System for selecting software components based on a degree of coherence
abstract: Disclosed is a novel system and method to select software components. A set of available software components are accessed. Next, one or more dimensions are defined. Each dimension is an attribute to the set of available software components. A set of coherence distances between each pair of the available software components in the set of available software components is calculated for each of the dimensions that have been defined. Each of the coherence distances are combined between each pair of the available software components that has been calculated in the set of the coherence distances into an overall coherence degree for each of the available software components. Using the overall coherence degree, one or more software components are selected to be included in a software bundle.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09043752&OS=09043752&RS=09043752
owner: International Business Machines Corporation
number: 09043752
owner_city: Armonk
owner_country: US
publication_date: 20130918
---
This application is based upon and claims priority from prior U.S. patent application Ser. No. 13 787 164 filed on Mar. 6 2013 now U.S. Pat. No. Pending the entire disclosure of which is herein incorporated by reference in its entirety.

The present invention relates to software distributions and more particularly to software selection and software grouping.

A common practice in business is to have software grouping for providing solutions to customers. Bundling or grouping of software components is quite a successful marketing strategy. For example software providers typically bundle a word processor a spreadsheet and a database into a single office suite rather than offer these products individually.

With the development of cloud computing it is easier to provision software through a virtualized environment without the traditional installation and manual configuration. In cloud environments IT solution providers offer users a variety of software components bundled together to meet their business needs. In cloud computing environments there are multiple categories of software components that are grouped or bundled together. A first category of software components bundled together is Software as a Service SaaS . Software components are bundled together under SaaS to meet specific requirements of users with such bundles typically hiding the underlying infrastructure from the end users. A second category of software components bundled together is the images themselves used to build the virtualized environment. A third category of software components bundled together is the middleware bundles which can be composed into any images to pre build the software stacks for SaaS.

Providing each of these categories of bundled software components to meet user requirements has resulted in a large proliferation of custom software bundles. This proliferation of customized software bundles is costly. Each custom software bundle or custom software image must be created configured tested and maintained though upgrade and software maintenance practices such as installing software patches. Accordingly a need exists to easily select and create software bundles.

Disclosed is a novel system and method to select software components. The method begins with accessing a set of available software components the set of available software components containing at least two software components. Next one or more dimensions are defined. Each dimension is an attribute to the set of available software components. The dimensions at least include a provider of a software component an industry a software component is supported a function a software component performs an implementation of a software component and an operating system support for a software component. A set of coherence distances between each pair of the available software components in the set of available software components. A coherence distance is calculated along each of the dimensions that have been defined. An overall coherence degree for each pair of the available software components is computed by combining each distance of the pair of software components. Using the overall coherence degree one or more software components are selected to be included in a software bundle.

In one example the set of coherence distances between each pair of software components is calculated using a relationship ontology assigning similarity factors for each relationship kind in the relationship ontology and constructing a semantic tree of the set of software components.

In another example the set of a plurality of available software components being accessed includes one or more binary coded operating systems middleware applications and software applications.

In still another example the software bundle is assembled into a disk image with a specific operating system for use on a cloud enabled system.

In yet another example each of the coherence distances are combined that has been calculated in the set of the coherence distances into an overall coherence degree for each of the available software components only when each of the coherence distances are above a predefined threshold. Optionally the software components selected to be included in a software bundle is performed only when there is no conflict therebetween.

The set of coherence distances may be calculated between each pair of the available software components in the set of available software components along each of the dimensions j that have been defined by a coherence distance between each pair of the available software components using an equation where is a scalar metric value assigned to the component i i a dimension j.

Alternatively the set of coherence distances are calculated between each pair of the available software components in the set of available software components along each of the dimensions j that have been defined by a coherence distance l along path l for each pair from to of the available software components using an equation

The combining each of the coherence distances between each pair of the available software components that has been calculated in the set of the coherence distances into an overall coherence degree for each of the available software components includes using an equation

An apriori algorithm as used herein refers to an algorithm for learning association rules. See online URL http en.wikipedia.org wiki Apriori algorithm which is hereby incorporated by reference in its entirety. Apriori algorithm is designed to operate on databases containing transactions for example collections of items bought by customers or details of a website visits. Web retailers want to cross sell or up sell consumers and users. Stated differently when a user purchases an item A the retailer is interested in presenting other items the user would want to purchase as well such as presenting an HDMI cable when a user purchases a flat screen television. This type of selection identifies correlations between purchased items and other items based on a user s transaction record. When the correlation between two items is above a threshold these two items are considered to be related and hence presented together to the user. See for example C. Borgelt. Apriori Finding Association Rules with the apriori algorithm free computer software under the GLPL at online URL http fuzzy.cs.uni magdeburg.de borgelt apriori . Apriori algorithm is used to promote other related products if users buy one product.

 Correlation analysis as used herein refers to calculating the spatial or temporal distance between two variables. See online URL http en.wikipedia.org wiki Correlation and dependence which is hereby incorporated by reference in its entirety. Correlation analysis has been applied to find other key words related to a user s input. Correlation analysis has also been applied to determine user similarity. Typically Pearson s correlation coefficient is used to calculate user similarity. If two people are similar they may have similar preferences for product items. Based on the similarity product providers recommend products for users.

 Profit maximization as used herein refers to the process of determining the price and output level the returns the greatest profit. See online URL http en.wikipedia.org wiki Profit maximization which is hereby incorporated by reference in its entirety. Profit Maximization is used to get maximal profit by product providers. They get the maximal profit mainly through sale s policy. And they bundle the products that is not based on user s preference but for economic purpose.

With any of these technologies such as apriori algorithm from data mining domain correlation analysis from information retrieval domain and profit maximization. It is a challenge to set a proper threshold. For example two items may be transitively related even though their correlation is low.

Unlike traditional correlation analysis the present invention selects software components to bundle based on a coherence degree. The present invention is not based on history data of software usage. The coherence of software components themselves is analyzed but not from the historical data from users. The use of coherence factors describes the inner relationship between software components more exactly. Unlike profit maximization the present invention does not select software components to group based on profit but rather from their inner relationship.

The present invention identifies software to bundle based on coherence distance analysis between software products. In order to identify the software to bundle a coherence degree is used to compute the feasibility of bundling software components together by considering multiple dimensions such as provider industry and function. Some dimensions can be analyzed using simple Euclidean distance values. Other dimensions can be characterized by a relationship tree where each software product is modeled as a node of a graph structure represented by a semantic tree. For these dimensions relationships are defined and a similarity compatibility factor is used to calculate a coherence distance for two components. Product bundles are defined based on this coherence analysis.

First a bundled software solution is modeled as a graph structure represented by a semantic tree. Each leaf of the semantic tree represents an individual enablement artifact such as a product from a software vendor. The top of the tree represents the software capabilities and functions to satisfy specific business goals. The traversing from the top to bottom reflects the specification process of finding a software product. The process of coherence analysis start from defining a threshold and is completed by creating multiple partitions of the graph. Coherence degrees are calculated between any two products by combining all the coherence distances from different dimension. Second a threshold is defined such that two products can be combined together if their coherence is bigger than the defined threshold. Third a starting point is found and the semantic tree is searched for all software products that can coexist with it. Fourth all software products that can coexist for all leaf nodes of the semantic tree are identified by repeating the second step. Last all product sets that their items can coexist each other are outputs as possible product bundles.

The present invention provides the advantage of performing coherence analysis directly based on software products without needing any customer or user data. This saves a tremendous amount of time and the attendant costs by eliminating the requirement to collect this user data. The results of the coherence analysis are provided to cloud solution providers to more efficiently bind software products.

The process of coherence analysis from provider s dimension will be used as an example to illustrate how to calculate a coherence degree . A similar process to calculate the coherence degree in different dimensions. An example of a coherence degree in different dimensions is illustrated in . is the coherence distance between software component and along coherence dimension j. The following mathematical equation is used to compute coherence degree with multiple dimensions 

In the case of k 2 it is just a well known Euclidean norm used for geographic distance. Here m represents the number of coherence dimensions. For example suppose we have coherence dimensions such as j 1 provider j 2 implementation j 3 industry and j 4 function. In this case m 4. Furthermore this model Equation 1 can also be extended by adding weights to each dimension j. Then

The selection of the norm k typically relies on the characteristics of the dimension. For those dimensions that can be measured in scalar non negative values with linear scale k can be chosen to be 1. Examples of such dimensions include cost expense range the memory requirement for components and bandwidth requirements. In this case the equation for coherence distance between components iand iin dimension j becomes the L k 1 norm which is given by EQ. 3 where and are simply the measurement of the attribute in the dimension j. For example if the dimension j represents memory requirement and software component irequires 512 megabytes of memory and software component irequires 768 megabytes then 512 MB 768 MB and 1512 7681 256. The use of this distance measure implies that components with similar memory requirements should stay together.

Not all the dimensions can be measured using scalar distance like cost memory and bandwidth. One very important dimension is the manageability due to compatibility and business functionality of two candidate software components which co exist in one bundle. For example if you have components requiring different operating systems then bundling those components together will cause manageability problems and make the bundle not feasible to be consumed. For such dimensions concepts of relationship such as class subclass conflict and so on will be used to define the relationship of two components.

Turning now to shown is an example relationship tree . This relationship tree is defined as a generic solution in our algorithm therefore it can be used by a specific example coherence graph CG in . A specific example should be constrained by the relationship ontology. The relationship property of an edge can be converted to directed edge with similarity compatibility value assigned according to the relationship property. A coherence graph CG is used to calculate the coherence distance along each dimension j. To build the CG a relationship tree is used along with understanding of the software component relationship in that dimension j. We will use relationship ontology from software products dimension as an example to illustrate how to build relationship ontology. Furthermore a similarity factor for each relationship to show how similar two software components are with this relationship.

Turning to shown is a directed graph of the specific example in . Once the CG is built the similarity factors are used along with the CG to calculate the coherence distance. A value is assigned to each edge of the graph. For example for different versions of the Windows operating system backwards compatibility relationships exist from Windows 95 to Windows XP Windows XP to Windows 7 and Windows 7 to Windows 8. That means applications developed for Windows 95 Windows XP and Windows 7 are still being able to execute in a Windows 8 environment. We assign edge value 1 for Windows 95 to Windows XP Windows XP to Windows 7 and Windows 7 to Window 8. However since forwards compatibility is not typically maintained we assign the value 100 to edges for Windows 8 to Windows 7 Windows 7 to Windows XP and Windows XP to Windows 95 as we have to modify any applications developed specifically for Windows 8 if we want it to be executable on Windows 7 and the same relationship holds for Windows 7 Windows XP and Windows 95 . For different Linux operating systems as an application developed for RedHat Ubuntu and SUSE can be executed on other Linux OSes we assign an edge value of 0 for these compatibility relationships.

Based on the specific business requirements that are driving the grouping of software components the user determines both the set of dimensions for the coherence analysis and the specific function to be used for measuring coherence distance in each of the dimensions.

Next the user determines the method for computing coherence degree from the coherence distances. After the coherence degree is found the software components can be bundled by using coherence degree illustrated in as follows.

Turning to shown is a flow chart of software component selection and grouping. The process begins in step and immediate proceeds to step in which software and hardware IT Products are split into two or more sets based on deduced rules. It is important to note that this is done without the need to considering pre existing image or pre existing bundle.

Step is an optional step to make certain restrictions to candidates. By applying certain restrictions will reduce the number of candidate components that need to be considered for bundling. Some obvious restrictions could be the characteristics of the potential clients and the software components themselves. For example the industry sectors vendor of software the supporting operating system and so on.

Coherence distances are calculated in all dimensions in steps and by rendering the mathematical model on same set. The coherence degree of two candidate components considering all the dimensions can be computed using Equation 1 where we can simply choose k 2.

In step an average coherence degree is computed for all the coherence distances calculated in steps through . The average coherence degree is computed as the average coherence distance of all the pair wise candidate components this number reflects the coherence degree based on selected dimension and the measurement chosen.

Next in step a set of pre defined software components which must be grouped together as a cloud image. We can repeat above steps to create multiple sets of software components into multiple cloud images. This bundling input could come from client requirements or existing packaging practice. A set of pre defined software is not a null or empty set. In one example neighbors with coherence degree constrained by a threshold are found. Alternatively find the k nearest neighbors where k is chosen based on some business or technical constraint on the maximum size of a grouping.

The process completes in step in which the IT product bundles are presented to a user as an output and the process ends in step .

In another example a new component is added into one or more of the existing portfolio of images. The new component is added by computing and sorting the coherence degrees to each software image or software bundle. Then those software images or software bundles with minimal coherence degrees are selected to the candidate component to update the images to create new images. The computation of the coherence degree of a component to an image with multiple components as following 1 Compute the coherence degree pair wise for each component of existing image with the candidate component and 2 compute the average of the coherence degrees of above step as the coherence degree of a software component to an existing image.

The bus represents one or more of any of several types of bus structures including a memory bus or memory controller a peripheral bus an accelerated graphics port and a processor or local bus using any of a variety of bus architectures. By way of example and not limitation such architectures include Industry Standard Architecture ISA bus Micro Channel Architecture MCA bus Enhanced ISA EISA bus Video Electronics Standards Association VESA local bus and Peripheral Component Interconnects PCI bus.

The system memory can also include computer system readable media in the form of volatile memory such as random access memory RAM and or cache memory . The information processing system can further include other removable non removable volatile non volatile computer system storage media. By way of example only a storage system can be provided for reading from and writing to a non removable or removable non volatile media such as one or more solid state disks and or magnetic media typically called a hard drive . A magnetic disk drive for reading from and writing to a removable non volatile magnetic disk e.g. a floppy disk and an optical disk drive for reading from or writing to a removable non volatile optical disk such as a CD ROM DVD ROM or other optical media can be provided. In such instances each can be connected to the bus by one or more data media interfaces. The memory can include at least one program product having a set of program modules that are configured to carry out the functions of an embodiment of the present invention.

Program utility having a set of program modules may be stored in memory by way of example and not limitation as well as an operating system one or more application programs e.g. the software component grouping manager other program modules and program data. Each of the operating system one or more application programs other program modules and program data or some combination thereof may include an implementation of a networking environment. Program modules generally carry out the functions and or methodologies of embodiments of the present invention.

The information processing system can also communicate with one or more external devices such as a keyboard a pointing device a display etc. one or more devices that enable a user to interact with the information processing system and or any devices e.g. network card modem etc. that enable computer system server to communicate with one or more other computing devices. Such communication can occur via I O interfaces . Still yet the information processing system can communicate with one or more networks such as a local area network LAN a general wide area network WAN and or a public network e.g. the Internet via network adapter . As depicted the network adapter communicates with the other components of information processing system via the bus . Other hardware and or software components can also be used in conjunction with the information processing system . Examples include but are not limited to microcode device drivers redundant processing units external disk drive arrays RAID systems tape drives and data archival storage systems.

The OS fingerprinting in the present invention can be leveraged for other business cases including Bring Your Own Device BYOD business policies and enhances mobile security. Add layers for finer grain classification and identification of VMs. Differential DHCP Lease does not require any protocol changes Can be deployed as a software solution in DHCP servers and removes the burden of updating all leases when new devices are introduced.

As will be appreciated by one skilled in the art aspects of the present invention may be embodied as a system method or computer program product. Accordingly aspects of the present invention may take the form of an entirely hardware embodiment an entirely software embodiment including firmware resident software micro code etc. or an embodiment combining software and hardware aspects that may all generally be referred to herein as a circuit module or system. Furthermore aspects of the present invention may take the form of a computer program product embodied in one or more computer readable medium s having computer readable program code embodied thereon.

Any combination of one or more computer readable medium s may be utilized. The computer readable medium may be a computer readable signal medium or a computer readable storage medium. A computer readable storage medium may be for example but not limited to an electronic magnetic optical electromagnetic infrared or semiconductor system apparatus or device or any suitable combination of the foregoing. More specific examples a non exhaustive list of non transitory computer program product or computer readable storage medium would include the following an electrical connection having one or more wires a portable computer diskette a hard disk a random access memory RAM a read only memory ROM an erasable programmable read only memory EPROM or Flash memory an optical fiber a portable compact disc read only memory CD ROM an optical storage device a magnetic storage device or any suitable combination of the foregoing. In the context of this document a computer readable storage medium may be any tangible medium that can contain or store a program for use by or in connection with an instruction execution system apparatus or device.

A computer readable signal medium may include a propagated data signal with computer readable program code embodied therein for example in baseband or as part of a carrier wave. Such a propagated signal may take any of a variety of forms including but not limited to electro magnetic optical or any suitable combination thereof. A computer readable signal medium may be any computer readable medium that is not a computer readable storage medium and that can communicate propagate or transport a program for use by or in connection with an instruction execution system apparatus or device.

Program code embodied on a computer readable medium may be transmitted using any appropriate medium including but not limited to wireless wireline optical fiber cable RF etc. or any suitable combination of the foregoing.

Computer program code for carrying out operations for aspects of the present invention may be written in any combination of one or more programming languages including an object oriented programming language such as Java Smalltalk C or the like and conventional procedural programming languages such as the C programming language or similar programming languages. The program code may execute entirely on the user s computer partly on the user s computer as a stand alone software package partly on the user s computer and partly on a remote computer or entirely on the remote computer or server. In the latter scenario the remote computer may be connected to the user s computer through any type of network including a local area network LAN or a wide area network WAN or the connection may be made to an external computer for example through the Internet using an Internet Service Provider .

Aspects of the present invention have been discussed above with reference to flowchart illustrations and or block diagrams of methods apparatus systems and computer program products according to various embodiments of the invention. It will be understood that each block of the flowchart illustrations and or block diagrams and combinations of blocks in the flowchart illustrations and or block diagrams can be implemented by computer program instructions. These computer program instructions may be provided to a processor of a general purpose computer special purpose computer or other programmable data processing apparatus to produce a machine such that the instructions which execute via the processor of the computer or other programmable data processing apparatus create means for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

These computer program instructions may also be stored in a computer readable medium or computer program storage product that can direct a computer other programmable data processing apparatus or other devices to function in a particular manner such that the instructions stored in the computer readable medium produce an article of manufacture including instructions which implement the function act specified in the flowchart and or block diagram block or blocks.

The computer program instructions may also be loaded onto a computer other programmable data processing apparatus or other devices to cause a series of operational steps to be performed on the computer other programmable apparatus or other devices to produce a computer implemented process such that the instructions which execute on the computer or other programmable apparatus provide processes for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

The terminology used herein is for the purpose of describing particular embodiments only and is not intended to be limiting of the invention. As used herein the singular forms a an and the are intended to include the plural forms as well unless the context clearly indicates otherwise. It will be further understood that the terms comprises and or comprising when used in this specification specify the presence of stated features integers steps operations elements and or components but do not preclude the presence or addition of one or more other features integers steps operations elements components and or groups thereof.

The description of the present invention has been presented for purposes of illustration and description but is not intended to be exhaustive or limited to the invention in the form disclosed. Many modifications and variations will be apparent to those of ordinary skill in the art without departing from the scope and spirit of the invention. The embodiment was chosen and described in order to best explain the principles of the invention and the practical application and to enable others of ordinary skill in the art to understand the invention for various embodiments with various modifications as are suited to the particular use contemplated.

