---

title: Computer program product and method for order preserving symbol based encryption
abstract: A method for processing symbols by a first computerized entity, the method may include receiving, by a first computerized entity and over a communication network, text that comprises multiple random tokens and a plurality of plaintext symbols; wherein the multiple random tokens are generated by a second computerized entity; wherein a value of each random token that represents a plaintext symbol is responsive to values of random tokens that represents plaintext symbols that have a lower lexicographic value than the plaintext symbol; and processing the text by the first computerized entity.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09100183&OS=09100183&RS=09100183
owner: salesforce.com, inc.
number: 09100183
owner_city: San Francisco
owner_country: US
publication_date: 20130403
---
This application is a continuation of U.S. patent application Ser. No. 13 579 934 filing date Aug. 19 2012 titled METHOD AND COMPUTER PROGRAM PRODUCT FOR ORDER PRESERVING SYMBOL BASED ENCRYPTION which is a national phase application of PCT patent application PCT IB11 50726 having an international filing date of Feb. 22 2011 which claims priority from U.S. provisional patent Ser. No. 61 307 079 filing date 23 Feb. 2010 all applications being incorporated herein by reference.

The present invention generally relates to the field of data encryption. More specifically the present invention relates to order preserving encryption and for an encryption dictionary that facilitates order preserving encryption.

Currently there are no known solutions that enable sorting of encrypted data and encryption is usually done on the data being stored to a storage area or on information transmitted between two parties. In both cases before the data is process by the application it must be decrypted.

All known existing solutions to secure data sent to a Software as a Service SaaS application secure the pipe between user end user or the enterprise network and the service and rely on the security provided by the SaaS vendor. However the SaaS user does not control his sensitive data and in case there is leakage of information from the SaaS provider confidential data may be exposed. Furthermore standard encryption solutions do not enable the SaaS application to process the encrypted data content i.e. to perform operations like search sort making reports on the encrypted data content.

There is a need to enable the usage of external resources such as SaaS applications and cloud computing services while ensuring the confidentiality and privacy of the user corporate sensitive data.

A method for processing symbols by a first computerized entity the method comprising receiving by a first computerized entity and over a communication network text that comprises multiple random tokens and a plurality of plaintext symbols wherein the multiple random tokens are generated by a second computerized entity wherein a value of each random token that represents a plaintext symbol is responsive to values of random tokens that represents plaintext symbols that have a lower lexicographic value than the plaintext symbol and processing the text by the first computerized entity.

A non transitory computer readable medium that stores instructions for receiving by a first computerized entity and over a communication network text that comprises multiple random tokens and a plurality of plaintext symbols wherein the multiple random tokens are generated by a second computerized entity wherein a value of each random token that represents a plaintext symbol is responsive to values of random tokens that represents plaintext symbols that have a lower lexicographic value than the plaintext symbol and processing the text by the first computerized entity.

A system comprising a first computerized entity for receiving over a communication network text that comprises multiple random tokens and a plurality of plaintext symbols wherein the multiple random tokens are generated by a second computerized entity wherein a value of each random token that represents a plaintext symbol is responsive to values of random tokens that represents plaintext symbols that have a lower lexicographic value than the plaintext symbol and processing the text by the first computerized entity.

It will be appreciated that for simplicity and clarity of illustration elements shown in the figures have not necessarily been drawn to scale. For example the dimensions of some of the elements may be exaggerated relative to other elements for clarity. Further where considered appropriate reference numerals may be repeated among the figures to indicate corresponding or analogous elements.

In the following detailed description numerous specific details are set forth in order to provide a thorough understanding of the invention. However it will be understood by those skilled in the art that the present invention may be practiced without these specific details. In other instances well known methods procedures and components have not been described in detail so as not to obscure the present invention.

There is provided an appliance a system a method and corresponding software components for symbol based encryption of data. According to some embodiments of the present invention there may be provided a symbol based encryption module hereinafter encryption module adapted to encrypt data such as data included in a file such as a document or an application request transaction on a per symbol basis.

The term symbol may be defined as a word a phrase a number or any set of characters including alphanumeric characters in any known language. The terms symbol and data elements shall be interchangeable through this application.

The terms plaintext un encrypted decrypted and non encrypted shall be interchangeable throughout this application.

The term random token may mean a data element that is generated by a process that includes at least one stage that is random or pseudo random.

According to an embodiment of the invention there is provided a sort and search preserved encryption module that may provide sort and search preserving encryption that allows other modules or other computerized entities that may not be aware of the plaintext symbols to sort random tokens to search for random tokens and even to perform both sort and search processes. The terms search and sort preserve encryption and order preserve encryption shall be interchangeable throughout this application.

The computerized entities and methods illustrated below can be used in various environments and operate in various scenarios. For example when a corporate is using a Customer Relationships Management CRM in the Software as a service SaaS model such as salesforce.com the data sent to salesforce.com servers may contain sensitive data elements. A computerized entity can understand the salesforce.com application protocol detect the sensitive data elements in an HTTP requests sent to the salesforce.com application and encrypt these elements utilizing a symbol based encryption that can be a sort and search preserved encryption.

Thus the HTTP request structure remains the same and only the sensitive data elements are replaced with the encrypted elements and as a result the salesforce.com application can process the request as a normal request. The sort and search preserved encryption enables the Salesforce.com application to search within the encrypted data elements e.g. to search for a contact given its name to sort the encrypted data elements e.g. to sort the contacts names in a lexicographic order and to prepare reports using the encrypted data elements while the values of the sensitive data elements processed and stored in the salesforce.com databases encrypted. Thus even if there is a leakage of information from the salesforce.com server side applications and databases there is no exposure of corporate sensitive information.

According to some embodiments of the present invention when the user is retrieving a web page that contains an encrypted element a decryption module that may reverse the operation of an encryption module may detect the encrypted element s in the web page returned by the web application e.g. the SaaS application and may decrypt them. Thus the web page received by the user user browser may contain a non encrypted plain text response page and all the information presented to the user may be in plaintext.

According to further embodiments of the present invention a user requesting to export the data stored in a web application to any text based file e.g. a word document an excel document or even a PDF file the returned file may be processed by the device s in order to detect the sensitive elements in the text file and optionally replace them by their plaintext value. Thus the exported file may be in plaintext.

In most of the cases textual sensitive data elements are not used for any numeric analysis and as a result their encryption doesn t affect the SaaS application functionality since the encryption applied to these textual sensitive data elements preserve the ability of the SaaS application to search of sort the encrypted data elements. For example in a CRM application the name of customer who made the call is not important to the analysis of the call center performance and thus the fact that it is encrypted doesn t prevent any analysis done by the CRM application. In contrast the call duration and the waiting time are necessary for the numeric analysis of the call center performance and they of course are not encrypted since they are not considered as sensitive data elements according to the regulations .

In order to preserve the functionality of the application the suggested encryption scheme encrypts the sensitive elements that don t affect the application functionality and the encryption of sensitive data elements is done in a transparent way from the SaaS application perspective in order to prevent any need for changes in the SaaS application. To achieve this goal the device encrypts each word phrase in a data element by itself and in a way that preserves the search and sort functionality of the SaaS application on each data element word phrase .

To preserve the ability to sort the encrypted values and to search within the encrypted data elements the encryption scheme replaces each data element with a random token in such a way that the lexicographic order between the random tokens preserve the order e.g. the lexicographic order between the plaintext data elements they represent.

According to various embodiments of the invention the encryption module can define a space of possible random tokens and generate random tokens within that space.

The space of possible random tokens can be of any size. The size of this space can be determined according to the number of possible different plaintext data elements to be encrypted. This space can be span by random tokens of a length that can be 64 bits 128 bits or any other size.

Based on the size of the random tokens the encryption module generates random tokens for the plaintext symbols so that the order e.g. the lexicographic order between the random tokens generated for the data elements in the encryption dictionary preserves the order between the clear text data elements they represent. This mapping between the random tokens generated and their corresponding clear text data elements may be stored in a hash table in memory and additionally or alternatively in a database.

When the encryption module needs to encrypt a data element the encryption module can execute the following stages 

It is noted that since a random token is associated with each plaintext element the search capability is preserved.

It is noted that the encryption module requires a definition of the sorting method. In case of textual alpha numeric data elements the lexicographic sorting is assumed as default. However it is noted that the encryption module can generate random tokens that preserve orders that differ from lexicographic orders. Thus if a set of data elements are orders according to a certain order and are associated with ascending or descending values than any of the mentioned below methods can be applied to provide an order preserving encryption.

According to an embodiment of the invention the first letter of a data element can remain non encrypted while other letters are encrypted so that an application that receives the random tokens can still be able to present all the data elements starting with A B C . . . Z.

According to an embodiment of the invention multiple random tokens can be assigned to a single plaintext data element. Such an allocation can be provided for various reasons such as but not limited to a need to smooth or flatten an uneven distribution of data elements. This may occur if there are popular data elements i.e. data elements that appear frequently in the plaintext .

When multiple random tokens are generated for a single plaintext data element these random tokens can be consecutive from lexicographic order perspective but from the random token perspective there may be no sign that these random tokens correspond to the same plaintext element.

When searching for a plaintext data element that was encrypted using multiple substitutions the encryption module should search for all the random tokens that correspond to the plaintext data element using an OR operation.

According to an embodiment of the invention the number of random tokens per plaintext data element can be stored in multiple manners. For example the number of random tokens of plaintext data elements that have multiple random tokens are stored in the encryption dictionary or in another data structure. Yet according to an embodiment of the invention separate encryption dictionary can be allocated for plaintext data elements that have multiple random tokens.

In order to define the space of the random tokens the size and number of the possible data elements i.e. the possible number of first names last names etc. should be estimated. If an exact estimate is not provided than at least a gross estimate can be provided such a gross estimate can provide an order of magnitude i.e. thousands tens of thousands hundreds of thousands millions tens of millions etc. .

The data elements to be encrypted are usually of a known type. They are usually fields in a structured text that are known in advance. It is noted that the sensitivity detection mechanism can detect sensitive data elements in a non structured data in a mechanism similar to a DLP mechanism. Non limiting examples of such fields can include a name of a person a name of a company a bank account number a credit card number and the like. The size of the space of the plaintext elements to be encrypted may be finite and as a result tokenization can be applied.

For example if the data elements to be encrypted are names of people then a reference to the number of different names can be found for example in http www.census.gov genealogy names . For example in order to provide 90 coverage of first and last names in the United States of America there is a need to allocate 4 250 female names 1 250 male names and 88 000 last names. In this case 20 bits spanning a space that is about million possibilities may be enough to cover the space of first and last names of people and we can use these names to build our initial dictionary of random tokens.

If for example the characteristics of the data elements to be encrypted are unknown e.g. names of projects or companies the encryption module can generate an initial encryption dictionary that include multiple combinations of letters. For example such an initial encryption dictionary can include all tuples of three or four characters of the alphabet.

For a given space estimation the random token should be much larger for example at least 40 bits larger than the size of the plaintext elements to be encrypted. Thus if the estimated space of the plaintext elements in 20 bit around one billion then the random tokens should be for example 64 bits long.

In the generation of the initial mapping the encryption module can use the output of a random or pseudo random generator. The pseudo random generator can be an output of an AES encryption algorithm in CBC mode or in CTR mode where the key and the IV are randomly generated using a hash function on some data gathered.

The encryption module may sort the plaintext data elements in the initial encryption dictionary and processes them one by one according to their order.

For each plaintext data element the encryption module generates at least 40 bit random value random number and translates it to an integer number. Then the encryption engine adds the random values associated with all the plaintext elements till that data element including the random value generated for that data element to generate the random token for that data element. For example 

According to an embodiment of the invention the encryption dictionary can be stored in one or more data structures can be at least partially replicated can be stored in a hierarchical memory data structures can be at least partially stored in cache and the like. Once a new random token is generated it can be stored in one data structure and then be updated to another data structure if necessary.

The random token generated by the encryption module can be encoded utilizing hex encoding using the first 16 alphabetic characters according to their lexicographic order so that each 4 bits of a numerical value of the random token are represented by a letter between a and p.

These letters can be converted to upper case letters and lower case letters by using letter case information representative of the types of letters lower case or upper case of the plaintext data element that is being encrypted.

Alternatively each 5 bits of a numerical value of the random token are represented by an Armenian letter having 36 letters . This encoding can also preserve the letter case of the original data element.

Case preserving encoding allows an application such as a SaaS application to choose case sensitivity of sorting and searching according to its needs transparently of encryption.

In many cases such as a search operation the operation is required to be case insensitive and as a result the search engine is translating both the data to be searched and the search term into lower case before the search operation. As a result the suggested encryption also translates the plaintext data elements and the search terms into lower case before encrypting them. This ensures that the search done on the random tokens will be case insensitive.

In order that when a data element is decrypted the decryption module will preserve the case sensitivity of the original data element the encryption algorithm generates letter case information that indicates which character is upper case and which is lower case.

Before the encryption module encrypts a plaintext data element it may generate a bit vector that may include 1 for an upper case letter characters and 0 for lower case letter character digits and additional characters or use any other values that differ from each other . Then the encryption module can translate the data element into lower case characters if applicable and generates a random token for the data element as described above.

The encoding of the random token may be done utilizing an encoding such as a hex encoding using the first 16 alphabetic characters according to their lexicographic order i.e. 0 will be encoded by the lowest character in the alphabet . The characters used are lower case a p characters. but can be any set of 16 characters that are ordered lexicographically and have upper case and lower case representation.

Then the encryption module may convert the characters to upper case using the bit vector that was generated before the data element encryption. Thus for each 1 bit in the bit vector the corresponding character is translated to upper case.

For example if the word was David the first character in the encoded random token will be upper case and all the rest of the characters will be lower case.

When a decryption module decrypts a random token into the plaintext data element it reverses the above process. Before the decryption the encryption module generates a bit vector that contains 1 for an upper case letter characters and 0 for lower case letter character or use any other values that differ from each other .

Then it translates the random token into lower case characters and searches for the plain text data element in the encryption dictionary. The plaintext data element found is in lower case.

Then the decryption module converts the characters to upper case using the bit vector that was generated before the random token decryption. Thus for each 1 bit in the bit vector the corresponding character in the plain text data element is translated to upper case.

In cases where the initial encryption dictionary that may be used for the sort preserved encryption is based on all the tuples i.e. all the permutations of 4 characters of the alpha Beth than when the user enter the first characters of the word for which it is required to provide auto complete the device can look for these character string in the internal dictionary as well as for the next tuple with the same number of characters and find their random tokens.

In each of the above cases an application server e.g. the SaaS application server may be requested to bring all the values that are greater or equal to the encryption of the string entered by the user and are smaller than the encryption of next string in the lexicographic order. Since the encryption is preserving the order this will bring all the strings that start with the character entered by the user.

In case the username is composed from few elements separated by . or then each element can be encrypted separately.

According to an embodiment of the invention emails or other plaintext data elements having a predefined format can be encrypted in a format preserving manner.

In case the SaaS application is performing a format validation at the server side then an encryption scheme that preserves the data element format can be applied. However if the format validation is done on the client side then the device can use any encryption scheme even if it doesn t preserve the format in case using this encryption scheme can be more secure and more efficient to implement.

For example an email address is usually composed from two plaintext strings that are separated by an at sign i.e. user name domain name.com the encryption module may encrypt the user name by itself and the domain name by itself and recomposes the new email address using the encrypted values of the user name and the domain name.

Thus an email address can be converted to an encrypted email address that includes two random tokens RT q and RT j that are separated by an at sign for example RT q RT j .

This preserves the structure of the email address enables sorting of encrypted email addresses and ensures the confidentiality of both the user name and the domain name.

Yet according to another embodiment of the invention an email address that includes two plaintext strings that are separated by an at sign is converted to an encrypted email address that includes two random tokens that may be separated by a symbol and are followed by an at sign wherein the at sign is followed by a predefined domain name that identifies a computerized entity owned by the device i.e. the enterprise that is arranged to assist in decrypting the encrypted email address RT q .RT j predefined domain name and the email message body. This also enables the device to catch emails sent to the encrypted email address.

The computerized entity may decrypt the encrypted email address and the email message body or send it to a decryption module. After the email is decrypted it and the email message associated with it are sent to the destination defined by the email address.

If email addresses are encrypted according to one of these embodiments then the decryption module can search for expressions like a RT q RT j encrypted value encrypted value decrypt each of the random tokens and recomposes the email address using the plain text values for the user name and the domain names or ii RT q .RT j predefined domain name.

According to an embodiment of the invention different mapping between plaintext data elements and random tokens can be provided for different users devices applications and the like.

According to an embodiment of the invention different encryption policies and different encryption dictionaries can be used in different contexts.

For example an encryption module or different encryption modules can apply a different encryption policy that define which data elements should be encrypted for each SaaS application. Thus for certain functionality the device will have to be familiar with the SaaS application protocol. Note The knowledge on the SaaS application protocol will be gathered by an off line process. 

In addition a SaaS application may provide a very detailed API that enables developers to develop their own applications on top of that SaaS application services. This APIs which defines the meaning and the semantic of each parameter in that SaaS application may enable to prepare a detailed policy for that SaaS application and for each application developed on top of it APIs since the device intercept the calls to the APIs and will apply the privacy policy to the parameters according to the application security policy for the requested APIs.

According to an embodiment of the invention a device is provided. The device can include the encryption module and additionally or alternatively a decryption module and can act as a proxy or a reverse proxy between a SaaS application client running usually in the end user browser and a SaaS application server side running on the SaaS provider servers. As a proxy or a reverse proxy all or a part of the traffic between the SaaS application client side and the SaaS application server side can be monitored requests and responses .

The device can detect the application according to the domain name in the request. According to the URL the device detects the request type and according to the request type it knows per a predefined definition what sensitive data elements that should be encrypted are included in the request.

Since the requests are usually HTTP request which are using key value pairs the device can easily detect the relevant parameters by their names and replaced their value in the request with the encrypted value. In case it is a post request with a XML body the device may use a XML parser to query and extract the value of the sensitive data elements and replace their plain text value with the encrypted value. In case it is a post request with a JSON body the device may use a JSON parser to extract the value of the sensitive data elements and replace their plain text value with the encrypted value. The device can handle requests that their body is a combinations of key value pairs XML and JSON as well as other formats and detect in these requests the sensitive values.

In order to enable easy detection of the textual encrypted value in the response the device may add a prefix and a suffix to each encrypted element as will be explained later .

In case a textual search request is detected the device may detect the textual search text in the request and the device applies the same encryption to search terms in order to preserve the server or the application search functionality.

When the response is returning from the SaaS application it is usually a web page. In order to ease the detection of textual encrypted elements each encrypted element has a unique prefix and suffix. The device may be using this prefix and suffix to detect the textual encrypted elements in the web page and replace them with their plaintext values. The same apply to XML documents and JSON responses that returned as a response and or to textual files and or to documents that are downloaded from the SaaS provider server.

As explained above the device may function as a proxy or a reverse proxy between the client side application running usually at the user s browser and the application server side running on the SaaS provider servers. In case of a corporate it makes a lot of sense to position the device in the corporate network perimeter close to the firewall. The advantage of this position is that only users that work within the enterprise network can work with the application normally and any users that are not passing through the device will view only the encrypted data elements. This enables the enterprise to audit the access to the application and prevent any unauthorized access to the application from outside of the corporate network since even if the user has somehow a username and password to the application he she would see only the random tokens and the sensitive data will not be exposed.

This topology may handle scenarios of an ex employee that have left the organization but for some reason was not deleted from the SaaS application users list. This topology also handles the scenario where somehow a username and password of the application were revealed to an unauthorized user outside of the enterprise.

Another advantage of this topology is that the enterprise has full control on the device and the device secret keys including the encryption dictionary remains with the enterprise. As explained above the device enables the corporate IT or the compliancy officer full control on the Privacy policy enforced by the device.

In order to enable remote users to work properly with the SaaS application they will have in this topology to connect to the enterprise network using SSL VPN and work though the enterprise network.

This proxy can be implemented as software running on the end user s desktop laptop to address to consumer market.

On the Linux an Apache can run in proxy reverse proxy mode as a HTTP HTTPS proxy server utilizing the Apache mode ssl . The device can run other proxies to support other protocols as well.

The system or appliance may include a web based GUI will enable the user to define the privacy policy and to manage the device secret key.

The device may have i A secret key management GUI that will be available only to very minimal number of users ii policy management GUI that will be available to Policy administrators wherein for each application supported by the device will have a dedicated GUI that will be tailored to the specific application.

The policy screen will enable the policy administrator to define which data elements are sensitive data elements and how to encrypt them i.e. what encryption engine to use .

For example a file that is attached to an email can be encrypted as one entity to achieve additional security and only the name of the file should be encrypted using the search and sort preserved encryption scheme.

The illustrated devices and methods can provide to the device administrator full control of the information that is sent out side from the enterprise network e.g. to the SaaS provider i.e. control what can go to the SaaS and what cannot and minimize the exposure of enterprise confidential data it can enforce the enterprise data privacy policy and enable the compliance officer to easily define and enforce a corporate policy regarding i Data that can be exported externally the security compliancy officer can define that certain data elements e.g. credit card numbers should be masked before being sent out side of the enterprise due to PCI DSS compliancy ii Data that should be secured although the device provides predefined configuration of sensitive data elements for different SaaS applications the security compliancy officer can modified it to tailor it to the enterprise security policy.

The described methods and devices can enable CXO to use the SaaS model to reduce costs by using SaaS application without exposing confidential data and as a result without risking privacy regulations. They allow juresdiction definition and simplify reduce audit requirements. They reduce recurring compliance audit costs of SaaS solutions and reduce the need for auditing the SaaS provider.

In case of any SaaS related security breach no notification will be required to customers according various regulations e.g. CA SB1386 2003 since the sensitive and privacy related data was encrypted.

The methods and device may allow monitoring and Audit SaaS usage and SLA may enable monitoring of SaaS applications usage by the enterprise may enable enforcement of enterprise specific access control policy on SaaS usage by users can detect abnormal usage of SaaS applications and may monitor SaaS application availability and response time can enhance the attractiveness of SaaS applications by overcoming one of the major prospects inhibitor which is the privacy and confidentiality of the data can reduce liability in case of data exposure since the sensitive information is encrypted even if the information leak that is no damage. The suggested encryption even if it does not eliminate any other security measured that should be taken by the enterprise it is still the last defense in case all the other defense layers have failed.

The methods and devices described herein illustrate some of the benefits of using the sort and search preserved encryption method for SaaS application scenarios. However there are various additional business applications that can benefits from it such as cloud computing and internal usage of the device within the enterprise to protect the data stored within the organization storage and or database from any unauthorized use.

It is noted that the security module can include software components hardware components and the like. The security module or one of more of its components hardware software or a combination thereof can be regarded as a second computerized entity and can be a device. A first computerized entity can be arranged to utilize the random tokens generated by the security module . The first computerized entity can be a SaaS application a server running the SaaS application and the like.

The security module can have at least one input and at least one output . These inputs and outputs can represent physical communication links virtual communication links or a combination thereof.

The input can receive text and the output can output encrypted text. The received text can include plaintext symbols while the encrypted text can include random tokens representative of some of the received plaintext symbols. The encrypted text can include a combination of plaintext symbols and random tokens thus only a part of the received text can be encrypted.

The security module includes a communication module that is arranged to receive data elements and can output data elements and random tokens. The communication module can include one or more proxies such as but not limited to HTTP proxy SMTP proxy pop3 proxy or any other proxies.

The communication module is coupled to a sensitivity module that may select plaintext symbols to be encrypted and send these plaintext symbols to an encryption module . The sensitivity module can receive instructions relating to which fields of the text to encrypt.

The sensitivity module may be integral or otherwise functionally associated with the encryption module . The sensitivity module may estimate or determine based on a pre defined security policy the sensitivity level of some given data i.e. symbol or group of symbols and may indicate to the encryption module whether or not to encrypt the given data element symbol s and how the encrypt the given data element symbol. The higher the sensitivity level of the given data the more likely it will be encrypted. The sensitivity module may be adapted to detect and classify the sensitivity level of some or all symbols or groups of symbols of a data file document or application request transaction for example peoples names addresses account information etc. based the symbol s data format or other characteristics. According to yet further embodiments of the present invention there may be provided templates or configuration files associated with each type of data file documents or application s messages which templates of configuration files may indicate to the sensitivity module data symbol characteristics or parameters of data symbols found in the file document or application s messages type to be classified as sensitive.

According to yet further embodiments of the present invention an encryption module s decision as to whether or not to encrypt a given data symbol may be influenced by an indication e.g. user defined of a security level for the entire file or document or application message e.g. request transaction . Accordingly the same data symbol considered sensitive and in need of encryption when found in a document classified as having a high security level may be considered non sensitive and thus not encrypted when found in a document having a lower indicated security level.

The encryption module may perform the search and sort preserve encryption to provide random tokens. The random tokens and plaintext symbols that were not selected to be encrypted by the encryption module can be sent by the communication module to a first computerized entity such as a SaaS server.

The encryption module may perform one or more encryption operations such as but not limited to the encryption methods illustrated in the following figures. For example the encryption module can perform the symbol based encryption illustrated in the following figures as well as other encryptions such as standard encryption based on for example on NIST standard algorithms and best practices and the like. The encryption module can perform case preserving encryption using case type information case sensitive encryption i.e. encrypting the plain text symbol as it is search enabled encryption sort and search enabled encryption standard block encryption algorithms such as AES in CBC mode wherein non limiting of such encryption methods are illustrated in the following figures.

The encryption module can be used to encrypt only selected data elements. The data elements may be selected based on their sensitivity. The sensitivity can reflect a security level of a data element damage that may result from an exposure of the data element value of the data element and the like. The sensitivity can be determined in advance be calculated by applying a function can be updated over time and the like.

Either one of the sensitivity module or the communication module can be familiar with understand the application protocol in order to extract and allow the sensitivity module to detect which plaintext symbols to send to the encryption module.

The security module can be used in various scenarios including but not limited to SaaS providers that should not be aware to the plaintext symbols that were encrypted.

The sensitivity module or another module such as a communication module may intercept application request messages that are sent to an application server and send selected plaintext symbols to the encryption module if these plaintext symbols are sensitive enough.

The encryption module may encrypt the plaintext symbols selected by the sensitivity module before they are sent to a SaaS provider.

As a result sensitive data elements are encrypted before being sent to processed by and stored in the SaaS application database while the SaaS application functionality is preserved and without any need to change the SaaS application.

According to some embodiments of the present invention the encryption module and other associated components such as software components may be implemented anywhere along a data file or document generation storage chain or the route from the end user device e.g. browser to the SaaS application server.

According to an embodiment of the invention the encryption module may be integral or otherwise functionally associated with a computational platform e.g. plug in or add on on which an application used to generate documents e.g. MS word runs. When the document is saved by the application it may be automatically symbol based encrypted by the encryption module as part of the saving process.

According to some embodiments of the present invention some or all of the functionality of the encryption module may be executed using a removable peripheral e.g. USB device where the peripheral may include data storage and encryption logic.

According to some embodiments the encryption module as well as the sensitivity detection module may be integral or otherwise functionally associated with an organization s document repository e.g. document management system running on an organization s server such that all documents stored on the repository are encrypted as they enter the repository.

According to yet further embodiments of the present invention the encryption module may be integral or otherwise functionally associated with an organizational gateway to an external document repository e.g. document management system running on a third party server provided by a document repository services provider e.g. Google Iron mountain etc. 

According to embodiments of the present invention where the encryption module is associated with either a data server or with a gateway to an external application server e.g. a SaaS application server the encryption module may be functionally associated with a communication module that is adapted to receive and send network data traffic.

The communication module may include networking hardware and network protocol logic e.g. TCP IP stack adapted to receive and transmit data using any network standard known today or to be devised in the future.

As part of the encryption module s operation the encryption module may utilize an encryption dictionary such as an encryption dictionary that maps plaintext symbols to random tokens. It is noted that the encryption module may encrypt only a portion and even only a small portion of a text so that random tokens as well as plaintext symbols can be sent to a computerized entity that is unaware to the plaintext symbols that were encrypted and or replaced by random tokens.

According to embodiments the random token may have no meaning whatsoever thus the random token does not provide a meaningless phrase or expression.

According to an embodiment of the invention the encryption module applies an search and sort preserving encryption that is order preserving in the sense that the order of plaintext symbols is the same to the order of the random token that represent these plaintext symbols.

According to yet further embodiments of the present invention each user and or organization may be associated with a different and substantially unique encryption dictionary.

The encryption dictionary may be a dynamically updatable table and may be updated during operation. For example when a user organization starts using an encryption module according to some embodiments of the present invention the encryption dictionary for the given user organization may include mappings for a set of symbols likely to be found e.g. statistically often used within documents used by the user organization.

When during operation however the encryption module receives a new plaintext symbol that is not currently included in the encryption dictionary the encryption module can update the encryption dictionary by adding a random token that represents the new plaintext symbol while preserving the order of the random tokens. A non limiting example of such an update is provided in .

If a document to be encrypted includes a plaintext symbol that does not have a corresponding mapping entry in the encryption dictionary then the encryption module or another associated software component may generate for example by using a random symbol generator a corresponding cipher entry a new mapping between the new plaintext symbol and a new random token and may update the encryption dictionary accordingly. Thus a encryption dictionary used by a user or organization may grow as more traffic is passing through the device. The encryption dictionary may be stored within a database that can be part of a device and or the system that implements the invention.

According to some embodiments of the present invention utilizing a encryption dictionary may result in a sort and search preserved encryption of some or all of a document s encrypted data symbols. Accordingly textual search and sort functionality of a remote service server and or application based is preserved and can be applied to the random tokens. Thus the remote service server and or application can sort the random tokens and when the sorted random tokens are returned to the user and the random tokens are converted into their plaintext symbols the result is a sorted plaintext symbols. In addition a document search engine or utility according to the present invention may scan through a set of documents encrypted according to embodiments of the present invention and may search for one or more search terms by running the search query via the encryption module that converts the search terms i.e. symbols to their corresponding random tokens using the same encryption dictionary as used to encrypt the documents and then the first computerized entity can perform the search query on the documents based on the encrypted converted search symbols.

According to further embodiments of the present invention there may be provided a decryption module that may reverse the operation of the encryption module . illustrates the decryption module as being included in the security module but this is not necessarily so and the encryption and the decryption can be executed by multiple distinct computerized entities.

Decryption module can be adapted to use either one of the encryption dictionary or a reverse encryption dictionary . It can use either one of these data structures when decrypting files documents that were previously encrypted according to some embodiments of the present invention.

The decryption module associated with a given encryption module may be adapted to either use a decryption dictionary that can be an inverse encryption dictionary relative to the encryption dictionary used by the encryption module or to perform a reverse lookup on the same encryption dictionary as the one used by the encryption module . However if the encryption and decryption modules are using different encryption dictionaries then the dictionaries used for encryption and decryption have to be synchronized.

Upon retrieval of the encrypted data and or data which is the result of a manipulation of the encrypted data by the remote service server and or application the decryption module may be adapted to decrypt the one or more random tokens by utilizing the inverse of the encryption dictionary that was used for the encryption which they are a result of into their corresponding clear symbols prior to output presentation to the user. The decryption module may scan the returned text to detect the encrypted elements included in that text and replace them with their corresponding plaintext elements.

According to some embodiments of the present invention the encryption decryption modules and may be functionally associated with applications including word processing applications accounting applications email applications spread sheet applications CRM applications etc. According to further embodiments of the present invention the encryption decryption modules and may be functionally associated with Software as a Service applications provided by third parties over the internet or other distributed data networks.

By exercising the symbol based encryption illustrated in any of the following methods as well as the symbol based decryption external resources such as SaaS applications and cloud computing services can be used while ensuring the confidentiality and privacy of the user corporate sensitive data.

The mentioned above security module is capable of applying sort and search preserved encryption methods that may enable a SaaS application to sort the encrypted data elements as well as to search the encrypted data elements although the data elements are encrypted. In addition our innovation enables to detect and decrypt encrypted elements on various formats of documents as well as in various protocols e.g. SMTP HTTP in order to ensure transparent functionality to the user. This enables the users of such a technology to maintain their customers privacy without the need to change the SaaS application.

The encryption dictionary includes a mapping between multiple plaintext symbols and random tokens that represent the multiple plaintext symbols Method may start by stage of generating a random value for each plaintext symbol of multiple plaintext symbols.

Stage may include applying a random or a pseudo random process. Random values RV RV n are calculated for plaintext symbols PS PS n .

The plaintext symbols can be for example private names such as Bob John Rob and Helen. After being sorted these private names are ordered accordingly Bob Helen John and Rob. Four random values RV RV are calculated for these four names.

The plaintext symbols may include letters numbers or a combination thereof. The random values can be numerical values.

Stage may be followed by stage of calculating using a monotonic function such as a increasing monotonic function a random token for each plaintext symbol based on a random value of the plaintext symbol and on random values of other plaintext symbols that have a lower lexicographic value than the plaintext symbol. Thus assuming that PS PS n are lexicographically ordered then the k th random value k ranges between 1 and n is responsive to the first random value till k th random value. For example the k th random value is an outcome of a monotonic function that is applied on the first till k th random values. The monotonic function can also be a decreasing monotonic function but in this case the order may be reversed and an additional order reversing operation may be applied.

According to an embodiment of the invention stage includes calculating the random token RT of a plaintext symbol by summing the random values of other plaintext symbols that have a lower lexicographic value than the plaintext symbol. Thus RT k SUM RV .RV k for each value of k between 1 and n.

For example the random token RT of Bob will equal RV the random token of Helen RT will equal RV RV the random token of John RT will equal RV RV RV and the random token RT of Rob will equal RV RV RV RV .

According to another embodiment of the invention stage may include calculating the random token of the plaintext symbol by applying a weighted sum of the random values of other plaintext symbols that have a lower lexicographic value than the plaintext symbol.

Method of differs from method of by calculating for at least one plaintext symbol multiple random tokens. Thus one or more other plaintext symbols can have multiple random tokens each. Multiple random tokens can be calculated for plaintext symbols that are more popular than other plaintext symbols or are more popular that a popularity threshold although the selection can be done according to any other criterion.

The popularity can be monitored can be evaluated over time and can represent statistics about the usage of plaintext symbols. The popularity can be evaluated per language per application per user and the like.

Method may start by stage of determining a number of random tokens to generate for each plaintext symbol out of multiple plaintext symbols. For one or more plaintext symbols this number exceeds one. Thus stage can include selecting plaintext symbols that their popularity exceeds a threshold. For example it may be assumed that John is very popular and that two random tokens should be generated for John RT and RT .

Stage may be followed by stage of generating a random value for each plaintext symbol of multiple plaintext symbols. Stage may include applying a random or a pseudo random process. Random values RV RV m are calculated for plaintext symbols PS PS n . If a single random value is calculated per each plaintext symbol then n equals m. If one or more plaintext symbol is associated with multiple random tokens then m n. Referring to the example above n 4 and m 5 as John is allocated with two random tokens.

Stage may be followed by stage of calculating using a monotonic function at least one random token for each plaintext symbol based on a random value of the plaintext symbol and on random values of other plaintext symbols that have a lower lexicographic value than the plaintext symbol. Stage may include applying a monotonic increasing function.

If for example a group of multiple random values are generated per a certain plaintext symbol then different random values of the group are responsive to the random values of plaintext symbols that precede that certain plaintext symbol. The values of random values of the group can also be affected by each other.

Stage may include calculating multiple random tokens for a single plaintext symbol so that values of the random tokens of other plaintext symbols are outside a range that is span by values of the multiple random tokens of the single plaintext symbol.

Method can start by stage of receiving a new plaintext symbol that is not included in an encryption dictionary. The encryption dictionary may be generated by any one of methods or a combination of one or more of these methods.

The new plaintext symbol can be received at any time after the encryption dictionary is generated. It is noted that the encryption dictionary can also be updated by removing unused plaintext symbols but this is not necessarily so.

Stage may be followed by stage finding a first plaintext symbol that belongs to the encryption dictionary and has a nearest smaller lexicographic value to a lexicographic value of the new plaintext symbol and of finding a second plaintext symbol that belongs to the encryption dictionary and has a nearest larger lexicographic value to the lexicographic value of the new plaintext symbol.

Stage may be followed by stage of assigning to the new plaintext symbol a new random token that has a new value that is between values of the random tokens of the first and second plaintext symbols.

Stage may include randomly selecting the new value of the random token within a range of numbers that is limited by values of the random tokens of the first and second plaintext symbols.

Stage may include assigning the new random token by adding a suffix to the random token of first plaintext symbol. The addition of a suffix least significant bits does not change the location of the new random token as lexicographic sort operation operate from the most significant bit towards the least significant bits from left to right .

According to an embodiment of the invention at least one plaintext symbol may be represented by a group of random tokens. If for example it is desired that a new random token will not be located within a space that is span by the group of random tokens then the selection of the first and second plaintext symbols should be responsive to the values of random tokens of the group. For example if the new random token should have a value that is greater than all the random tokens of the group then the biggest random token of the group should be taken into account when calculating the value of the new random token. Yet for another example if the new random token should have a value that is lower than all the random tokens of the group then the lowest random token of the group should be taken into account when calculating the value of the new random token.

Accordingly if the first plaintext symbol is represented by the group of random tokens than the new random token should have a value that is higher than the value of the highest random token of the group. If the second plaintext symbol is represented by the group of random tokens than the new random token should have a value that is lower than the value of the lowest random token of the group. Thus as the limits for choosing a new token we are taking in this case by the highest random value that represent the plaintext symbol that has the nearest smaller lexicographic value to lexicographic value of the new plaintext value and the lowest random value that represent the nearest larger lexicographic value to the lexicographic value of the new plaintext symbol.

Information about the allocation of more than a single random token per plaintext symbol or information about the number of random tokens per plaintext symbols can be included in the encryption table or in another data structure.

Method starts by stage of receiving or generating an encryption dictionary. The encryption dictionary can be generated by any method of methods and can be updated by method . The encryption dictionary is generated or received by a second computerized entity.

It is noted that an encryption dictionary can be generated per user per application per organization and the like. For simplicity of explanation the following example refers to a single encryption dictionary.

Stage may be followed by stage of receiving by an encryption module a group of plaintext symbols to be encrypted. Stage may be preceded by a stage not shown of selecting which plaintext symbol to encrypt said selection can be executed by a sensitivity module.

Stage may be followed by stage of encrypting by the encryption module the group of plaintext symbols by using the encryption dictionary to provide a group of random tokens. Stage can include selecting which encryption dictionary to use whether to perform an order preserving encryption or not.

Stage may be followed by stage of providing the group of random tokens to a first computerized entity that differs from the second computerized entity. Stage may also include providing to the first computerized entity at least one plaintext symbols that was not encrypted. It is noted that a text can be received by the first computerized entity while most of the text is not encrypted for example a file can be provided wherein only 5 percent of the file is encrypted. It is noted that most of the file and even the entire file can be encrypted.

Stage may be followed by stage of processing encrypted text that includes the group of random tokens and the at least one plaintext symbol. The processing can be executed by the first computerized entity and may include sorting searching and the like. The sorting or searching can be case sensitive or case insensitive.

It is noted that decryption methods can be provided. Each decryption method reverses the operation of an encryption method. Thus case sensitive encryption may be followed by case sensitive decryption but this is not necessarily so.

Stage may include detecting predefined patterns that should be encrypted according to predefined encryption schemes. For example stage may include detecting an email address that comprises two plaintext strings that are separated by an at sign and generating an encrypted email address that comprises two random tokens that are separated by an at sign RT q RT j .

Stage may include detecting an email address that includes two plaintext strings that are separated by an at sign and converting it to an encrypted email address that includes two random tokens that may be separated by a symbol and are followed by an at sign wherein the at sign is followed by a predefined domain name that identifies a computerized entity that is arranged to assist in decrypting the encrypted email address RT q .RT j predefined domain name .

Method starts by stage of receiving or generating an encryption dictionary. The encryption dictionary can be generated by any method of methods and can be updated by method . The encryption dictionary is generated or received by a second computerized entity.

Stage may be followed by stage of receiving by an encryption module a group of plaintext symbols to be encrypted. Stage may be preceded by a stage not shown of selecting which plaintext symbol to encrypt said selection can be executed by a sensitivity module.

Stage may be followed by stage of generating letter case information relating to multiple plaintext symbols. For example for each one of Bob Helen John and Rob the case letter information will indicate that only the first letter is an upper case letter. Thus four vectors can be generated 1 0 0 1 0 0 0 0 1 0 0 0 and 1 0 0 .

Stage may be followed by stage of converting the multiple plaintext symbols to a format that is case insensitive. Stage can include converting all upper case letters to lower case letters or converting all lower case letters to upper case letters. It is assumed for convenience of explanation that all letters are converted to lower case letters so that stage provides lower case plaintext symbols. For example Bob Helen John and Rob can be converted to bob helen john and rob.

Stage may be followed by stage of encrypting by the encryption module the group of plaintext symbols by using the encryption dictionary to provide a group of random tokens. Stage can include selecting which encryption dictionary to use whether to perform an order preserving encryption or not.

Stage may be followed by stage of encoding the random tokens or more specifically the numerical value of the random token by letters. The encoding can be can be case insensitive so that the random tokens are represented by letters of the same case.

Although not shown in stage or may be followed by stage and additionally or alternatively stage of method .

Stage is followed by stage of converting the encoded random tokens to case sensitive random tokens by using the case letter information.

It is noted that either one of the symbol based encryption methods and can be executed in addition to other encryption methods. Accordingly each method can be preceded or may include a stage of selecting which encryption scheme to select. illustrates a security module that can elect between different types of encryption such as symbol based encryption such as sort and search enabled encryption and search enabled encryption as well as standard encryption using NIST standard algorithms file encryption using AES in CBC mode and format preserving encryption and other encryption engines.

Security module may have the functionality of security module . It may perform either one of the encryptions method illustrated above. The administration policy management may determine when to apply each encryption method.

A corporate facility may host multiple applications such as web browsers and SaaS integration platform mail transfer agent all of which should access the Internet via a first firewall .

A SaaS application facility may include a SaaS application server that is coupled to the Internet via a second firewall .

The GUI displays multiple fields and of a form that may be displayed or filled in by a SaaS application. The content of some of the fields should be encrypted and these fields can be marked by using the GUI . These fields can include for example an address billing field a shipping address field an account name field a phone number fax number and website fields. Other fields should not be encrypted they may include a total won opportunities field a satisfaction indicator field and the like. The GUI can also allow to define which type of encryption should be applied and additionally or alternatively which type of encoding if applied should be applied. The random tokens are denoted RT RT . A non limiting example of a random token can be NSPREF1abhaglemkncaiiehNSSUF1.

GUI displays the same fields but fields are random tokens that replace fields . Thus address billing field a shipping address field an account name field a phone number fax number and website fields are filled with random tokens. Other fields such as a total won opportunities field and a satisfaction indicator field include plaintext symbols.

Either one of the mentioned above methods can be executed by a processor that may executed instructions code stored in non transitory computer readable medium.

A non transitory computer readable medium can be provided that stores instructions for generating a random value for each plaintext symbol of multiple plaintext symbols and calculating using a monotonic function a random token for each plaintext symbol based on a random value of the plaintext symbol and on random values of other plaintext symbols that have a lower lexicographic value than the plaintext symbol wherein the encryption dictionary comprises a mapping between the multiple plaintext symbols and random values of the multiple plaintext symbols.

The non transitory computer readable medium can store instructions for calculating the random token of plaintext symbol by summing the random values of other plaintext symbols that have a lower lexicographic value than the plaintext symbol.

The non transitory computer readable medium can store instructions for calculating the random token of the plaintext symbol by applying a weighted sum of the random values of other plaintext symbols that have a lower lexicographic value than the plaintext symbol.

The non transitory computer readable medium can store instructions for calculating multiple random tokens for a single plaintext symbol.

The non transitory computer readable medium can store instructions for calculating multiple random tokens for a single plaintext symbol that has a popularity level that exceeds a predefined popularity level.

The non transitory computer readable medium can store instructions for calculating multiple random tokens for the single plaintext symbol so that values of random tokens of other plaintext symbols are outside a range that is span by values of the multiple random tokens of the single plaintext symbol.

The non transitory computer readable medium can store instructions for receiving a new plaintext symbol that is not included in the encryption dictionary finding a first plaintext symbol that belongs to the encryption dictionary and has a nearest smaller lexicographic value to a lexicographic value of the new plaintext symbol finding a second plaintext symbol that belongs to the encryption dictionary and has a nearest larger lexicographic value to the lexicographic value of the new plaintext symbol and assigning to the new plaintext symbol a new random token that has a new value that is between values of the random tokens of the first and second plaintext symbols.

The non transitory computer readable medium can store instructions for randomly selecting the new value of the random token within a range of numbers that is limited by values of the random tokens of the first and second plaintext symbols.

The non transitory computer readable medium can store instructions for assigning the new random token by adding a suffix to the random token of first plaintext symbol.

The non transitory computer readable medium can store instructions for selecting the multiple plaintext symbols.

The non transitory computer readable medium can store instructions for encoding a numerical value of each random token to an alphabetic value.

The non transitory computer readable medium can store instructions for encoding the numerical value of each random token to a sequence of small case letters.

The non transitory computer readable medium can store instructions for encoding the numerical value of each random token to a sequence of Armenian letters.

The non transitory computer readable medium can store instructions for receiving a group of plaintext symbols to be encrypted 

encrypting by a second computerized entity plaintext symbols of the group of plaintext symbols by using the encryption dictionary to provide a group of random tokens and

providing the group of random tokens to a first computerized entity that differs from the second computerized entity.

selecting at least one plaintext symbols to be provided to the first computerized entity without being encrypted.

The non transitory computer readable medium can store instructions for performing sorting and search operations by the first computerized entity on the group of random tokens.

The non transitory computer readable medium can store instructions for detecting an email address that comprises two plaintext strings that are separated by an at sign and generating an encrypted email address that comprises two random tokens that are separated by an at sign.

The non transitory computer readable medium can store instructions for detecting an email address that comprises two plaintext strings that are separated by an at sign and generating an encrypted email address that comprises two random tokens that are followed by an at sign wherein the at sign is followed by a predefined domain name that identifies a computerized entity that is arranged to assist in decrypting the encrypted email address.

The non transitory computer readable medium can store instructions for decrypting the encrypted email address and sending an email message that comprises the email address to a destination defined by the email address.

The non transitory computer readable medium can store instructions for generating letter case information relating to the group of plaintext symbols to be encrypted.

The non transitory computer readable medium can store instructions for comprising converting each upper case letter of the group of plaintext symbols to be encrypted to a lower case letter to provide lower case plaintext symbols and calculating the random value for each lower case plaintext symbol.

The non transitory computer readable medium can store instructions for converting each lower case letter of the group of plaintext symbols to be encrypted to an upper case letter to provide upper case plaintext symbols and calculating the random value for each upper case plaintext symbol.

The non transitory computer readable medium can store instructions for generating random tokens in response to the letter case information.

The non transitory computer readable medium can store instructions for generating at least one additional dictionary for at least one other set of plaintext symbols.

The non transitory computer readable medium can store instructions for generating at least one additional dictionary for at least one other set of plaintext symbols 

receiving by a first computerized entity and over a communication network text that comprises multiple random tokens and a plurality of plaintext symbols wherein the multiple random tokens are generated by a second computerized entity wherein a value of each random token that represents a plaintext symbol is responsive to values of random tokens that represents plaintext symbols that have a lower lexicographic value than the plaintext symbol and processing the text by the first computerized entity.

While certain features of the invention have been illustrated and described herein many modifications substitutions changes and equivalents will now occur to those of ordinary skill in the art. It is therefore to be understood that the appended claims are intended to cover all such modifications and changes as fall within the true spirit of the invention.

