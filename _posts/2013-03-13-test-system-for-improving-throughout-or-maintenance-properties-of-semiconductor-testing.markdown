---

title: Test system for improving throughout or maintenance properties of semiconductor testing
abstract: A semiconductor test system includes test head pins; per-pin resources which are connectable to the test head pins on a one-to-one basis; shared resources, each of which is connectable to one of the test head pins; a tester controller for controlling the per-pin resources and the shared resources; and a tabular-form test plan including: a first column for specifying a measurement function that uses at least one of the per-pin resources and the shared resources; and at least one second column for specifying input and output parameters of the measurement function, the tabular-form test plan further including program rows, the tabular-form test plan being executed by the tester controller, the tabular-form test plan further including a third column for specifying how rows that are executed by asynchronous parallel execution are to be grouped.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09400307&OS=09400307&RS=09400307
owner: Keysight Technologies, Inc.
number: 09400307
owner_city: Santa Rosa
owner_country: US
publication_date: 20130313
---
The invention relates to semiconductor test systems and methods and more particularly to semiconductor test systems and methods with improved maintenance properties and throughput.

Various semiconductor testing technologies have been developed in order to improve the throughput of a test of semiconductor devices. Semiconductor test systems have been developed using test beds on which multiple devices can be connected and tested in parallel. The devices under test DUTs are provided with test pads at which a signal may be output or from which a signal level may be input. The systems may execute test plans that program the signals to be applied to the devices and the signals that are to be read from the devices.

In an example of a semiconductor parametric test system that has been developed for use in process management of yield and transistors electrical properties in the manufacture of integrated circuits a test environment is included for improving software productivity. The test environment uses a tabular form test plan and program code provided as functions written in a general purpose programming language or the like. The system executes test plans that are prepared by users and provided to the system in a table. The test plans are executed row by row where each row defines a function to be performed and information used by the function. The functions and information used by the functions are indicated as entries in the row according to the columns that define the function and associated information.

The semiconductor parametric test system enables the testing of devices in groups. A test element group TEG is defined as the measurement object of the test plan. Devices that belong to the TEG are setup for testing in a test environment that provides access to the test pads on the devices. The test determiners how the test pads are to be connected to a source measurement unit SMU which is controlled under program control by a processor. The connection from the test pad to the SMU is typically made by probing the device using a wafer prober. Each SMU is a measuring instrument capable of voltage application and current measurement or of current output and voltage measurement. SMUs may be programmed to function by limiting current during voltage application as well as of limiting voltage during current output.

An example of a test plan based on the test environment of the semiconductor parametric test system that enables testing of devices in groups is illustrated in . The test plan shown in is an example test plan for testing a TEG depicted as the measurement object in the measurement block diagram in .

Referring to the TEG includes a first pad a second pad a third pad and a fourth pad . The TEG also includes a transistor TR4 which is an FET having a gate terminal g connected to the first pad on the TEG . The first pad is connected to an SMU2 which has a port labeled G. The transistor TR4 has a drain terminal d connected to the second pad on the TEG . The second pad is connected to an SMU1 which has a port labeled D. The transistor TR4 has a source terminal s connected to the third pad on the TEG . The third pad is connected to an SMU3 which has a port labeled S. The transistor TR4 has a substrate bulk terminal sub connected to the fourth pad on the TEG . The fourth pad is connected to an SMU4 which has a port labeled Sub. The respective physical connections from the SMUs to the pads are established by probing with the use of a wafer prober or the like.

The semiconductor parametric test system performs tests according to test plans prepared by users. The test plans have columns defining parameters and functions to be performed in a step of the test plan. For example a column is included for identifying a module name for a grouping of circuits or devices that have pads to be probed together in one touchdown. Another column defines a function or measurement function to be executed during a particular step in the test plan. The row determines the step in the test plan and the measurement function entry in the measurement function column identifies the particular program unit or units that are called for execution. The measurement functions are typically provided in a function library that is part of the software operating on the system. The measurement functions are typically written in a compiled programming language such as the c programming language. An example of how the rows and columns in a test plan table are used to execute the test plan is described with reference to .

Referring to a test plan input window has a test plan input area where each row includes one measurement function and the input and output parameter settings to be used with the function. The test plan of is configured as a program in the form of a table that executes an aggregation of one or more rows as steps in the program. The first column of the test plan in is indicated as being a column. The column allows a user to comment out a row by entering an in the column for the selected row. When an is entered in the column that row is not executed. The second and third columns collectively indicated by are used for symbol information used to identify location information of a measurement object on a semiconductor wafer. In the example illustrated in a module name Module B is an entry used to identify the TEG of . The example illustrated in has the module name Module A which refers to another TEG not shown as an entry in the second column which is a module name column at . The test plan table also has a device name TR4 which refers to the transistor TR4 entered in the device name column under the module name Module B of the TEG of . Device names TR1 TR2 and TR3 are entered in the device name column under the module name Module A. 

The test plan may include other columns such as columns for providing input and output parameters which are provided as arguments for function calls that invoke the measurement function identified in the measurement function column. Examples of the type of information that may be provided as input or output parameters include values of electrical settings such as voltage or current values of settings with terminal connection information and pointers or memory storage indicators for storing data generated as output by the measurement function. The electrical settings provide the voltage and current values to be applied to the test pads in functional terms. For example if the device tested is a transistor the electrical settings would state values for the gate and the drain or source. The terminal information that may be provided as input parameters defines pads to be used for connections having a specific function. For example a pad may be connected to the gate of a transistor being tested or to the drain or source of the transistor.

The test plan in illustrates how measurement functions and their arguments are specified. The name of a measurement function or function may be entered in the function column . The measurement function entered in column identifies a function for measuring a desired parameter of a measurement object that is specified in the column . In this example function name IOFF at is entered in the measurement function column as a measurement function name. The function IOFF is as described later with reference to a measurement function for measuring a current that flows into a drain terminal of an FET device when specified voltages are applied to a gate terminal and a drain terminal of the FET device and 0 zero V. is applied to a source terminal and a substrate terminal of the FET device. According to the measurement function entered in the measurement function column of this test plan one FET identified in the device name column of the test plan connected to a terminal specified in the pad number column in of the test plan is measured by calling the measurement function IOFF once.

The fifth sixth and seventh columns which are collectively indicated by reference number in are used to specify input and output parameters for each measurement function specified in the measurement function column . The specified input and output parameters are arguments of the measurement function and the data specified in the arguments is used in function calls of the measurement function. In the example depicted in the fifth column is an input column used for entering a list of values of mainly electrical settings information such as voltage and current that does not include terminal connection information. The sixth column is a pad number column used for entering a list of values of settings information about terminal connection of a measurement object. The seventh column is an output column used for entering the label of a memory area for storing output data.

A tabular form test plan of the type described above provides an environment that enables a user to program a test easily and intuitively. The user configures a test plan in a programming environment that consists of two layers in the form of a tabular form test plan and a measurement function written in a general purpose programming language. The test environment which allows programming in a general purpose programming language also provides an environment compatible with any kind of programming. This type of test environment uses simple functions but is limited in the tests that can be performed. This test environment is also not suitable for intricate and sophisticated program flow control that relies heavily on the use of conditional branching and repetition nor for the programming of a function for a test that is more sophisticated than one prepared as a standard specification or the like.

Another example of a semiconductor test system partially parallelizes a semiconductor parametric test. A test plan with parallel test attributes would include a parallel test attribute column in which labels are provided for specifying the start and end of parallelization. With the range of parallelization specified a tester interprets the specified range and generates threads so that tests are executed in a plurality of specified ranges in parallel to one another. The threads are each a series of steps in the test plan within the specified parallelization range performed for indicated devices in the TEG. An example of a test plan that performs parallelization is shown in . The test plan in includes a parallel test attribute column for entering labels such as PT SCHED BEGIN and PT SCHED END that define the start and end of parallelization. Two ranges of parallelization are shown in . The first range of parallelization identifies a range of test steps for testing devices TR1 and TR2. A second range of parallelization identifies a second range of test steps for testing devices TR2 and TR4.

However this method too requires advanced knowledge and programming skill for semiconductor testing and test programs. This method also requires knowledge and performance of debugging.

Another example of a testing environment that uses a tabular form test plan includes conditional branching processing using an IF statement and repetition processing using a REPEAT statement. A LET statement may be included to assign a value to a parameter. Statements for invoking conditional processing may be added for example in the measurement function column described above.

An example of a test plan that uses conditional processing statements is illustrated in . The test plan follows a format similar to the test plan data entry area illustrated in . The conditional processing statements are entered in the measurement function column. shows a REPEAT statement at to indicate that the rows that follow up until an UNTIL statement at are to be repeated until the condition for terminating the repetition specified in the input column for the UNTIL statement at is met. One of the statements in the range between REPEAT at and UNTIL at is the IOFF function at . The argument data at specified in the input column pad number column and the output column is provided in the repetition. The use of an IF statement at is provided in rows following the UNTIL statement at . The condition for processing the rows that follow the IF statement at is indicated in the input column at . The processing to be performed when the IF condition is met is provided in the next row at with corresponding arguments at . An ELSEIF statement at is in the following row with data defining the ELSEIF condition at . An ELSE statement at is shown around statements that set flags. An ENDIFF statement at defines the end of the IF ELSEIF ELSE blocks.

Test plans that include conditional processing statements have the effect of lengthening the test plan by the addition of rows that have a conditional processing statement in the measurement function column. The lengthening of the test plan and the addition of more rows makes a test plan less readable and more difficult to understand. In some test plans numerous measurements are often repeated for statistical processing of measured values at different measurement conditions. Numerous measurements also make test plans more difficult to read or understand. Some test plans for certain types of TEGs also require steps for pre processing and post processing for a given measurement function. For example a test plan may perform a measurement function for measuring the current output at a drain terminal of an FET device when specified voltages are applied to a gate terminal and a drain terminal of the FET device while 0 zero V. is applied to a source terminal and a substrate terminal of the FET device. Before the measurement function is called a function that sets the address of a desired TEG may be executed as pre processing for a hundred TEGs. A function for resetting the voltage Vat the drain terminal may also be called after the measurement function as post processing. Such pre and post processing steps further lengthen and complicate the display of test plans making them more difficult to read and understand. Test plans that are difficult to read or understand have the effect of complicating the tasks of debugging and correcting the test plan.

Test plans of the type described above also execute using an interpreter to call a measurement function in the measurement function column and to execute a command. Interpreted programs tend to execute slower in speed than compiled programs. The slower speed compared to the execution of a compiled program is particularly noticeable when repetition and conditional branching are repeated.

The execution speed could be improved by including branching repetition and other similar functions in a compiled measurement function. However this would make such test plans inflexible since changes cannot be made after the program is completed. Another problem is that the maintenance of such test plans would have to be performed by a semiconductor engineer with a certain degree of advanced programming skill capable of comprehending the details of a measurement function. This requirement adds to the burden of test plan maintenance.

As has been described the miniaturization and high degree of integration achieved in the semiconductor manufacturing process in recent years has resulted in the need to test an ever increasing number of devices the need for improvement in the throughput of the testing and the need for an accompanying improvement in the maintenance properties of the test.

In view of the above a semiconductor test system is provided the semiconductor test system including a plurality of test head pins a plurality of per pin resources connectable to the plurality of test head pins on a one to one basis a plurality of shared resources each of which is connectable to one of the plurality of test head pins and a tester controller for controlling the plurality of per pin resources and the plurality of shared resources. The tester controller is configured to execute machine executable instructions in accordance with a user generated tabular form test plan. The user generated tabular form test plan comprises a plurality of program rows each row defining a test plan step and a plurality of columns defining information for performing the test plan step. The plurality of columns includes a measurement function column for specifying a measurement function that uses at least one of the plurality of per pin resources and the plurality of shared resources at least one input and output column for specifying input and output parameters of the measurement function and an asynchronous parallel grouping column for specifying how rows that are executed by asynchronous parallel execution are to be grouped. The tester controller is configured so that groups of program rows different from one another according to entries in the asynchronous parallel grouping column are executed so as to start asynchronous parallel execution concurrently.

In another embodiment the semiconductor test system includes a plurality of test head pins a plurality of per pin resources connectable to the plurality of test head pins on a one to one basis a plurality of shared resources each of which is connectable to one of the plurality of test head pins and a tester controller for controlling the plurality of per pin resources and the plurality of shared resources. The tester controller is configured to execute machine executable instructions in accordance with a user generated tabular form test plan. The user generated tabular form test plan comprises a plurality of program rows each row defining a test plan step and a plurality of columns defining information for performing the test plan step. The plurality of columns includes a measurement function column for specifying a measurement function that uses at least one of the plurality of per pin resources and the plurality of shared resources at least one input and output column for specifying input and output parameters of the measurement function and a synchronous parallel grouping column for specifying how rows that are executed by synchronous parallel execution are to be grouped where each of a plurality of groups grouped as specified in the synchronous parallel grouping column comprise only rows that have the same measurement function to be executed by synchronous parallel execution.

In another embodiment the semiconductor test system includes a plurality of test head pins a plurality of per pin resources connectable to the plurality of test head pins on a one to one basis a plurality of shared resources each of which is connectable to one of the plurality of test head pins and a tester controller for controlling the plurality of per pin resources and the plurality of shared resources. The tester controller is configured to execute machine executable instructions in accordance with a user generated tabular form test plan. The user generated tabular form test plan comprises a plurality of program rows each row defining a test plan step and a plurality of columns defining information for performing the test plan step. The plurality of columns includes a measurement function column for specifying a measurement function that uses at least one of the plurality of per pin resources and the plurality of shared resources at least one input and output column for specifying input and output parameters of the measurement function and a first dispatch column configured to perform program flow control with respect to the measurement function of the first column and at least one dispatch input output parameter column for specifying input and output parameters of the first dispatch function.

Other devices apparatus systems methods features and advantages of the invention will be or will become apparent to one with skill in the art upon examination of the following figures and detailed description. It is intended that all such additional systems methods features and advantages be included within this description be within the scope of the invention and be protected by the accompanying claims.

The test head includes a plurality of test head pins a per pin SMU module a relay matrix and a test head controller . The test head pins shown in are identified as Pin1 Pin2 and Pin3 . Additional test head pins up to a suitable number for system requirements are not shown but indicated by ellipses. The plurality of test head pins is used to make connections to DUTs.

The test head controller is configured to control operation of the relay matrix and the per pin SMU module . The per pin SMU module includes a plurality of per pin resources each configured to be capable of connecting to a corresponding one of the test head pins. The test head controller controls the relay matrix to establish connections between the shared resource block and the respective per pin resources in the per pin SMU module . The relay matrix uses a plurality of signal lines from the plurality of SMUs a signal line from the CMU and a signal line from the DVM from the shared resource block to connect to a plurality of signal lines that connect to the respective per pin resources in the per pin SMU module . Each per pin resource includes a per pin SMU PSMU . Each per pin resource is controlled by the test head controller to trigger a relay to connect a test head pin Pin1 in this example of to either a signal line of the PSMU or a signal line from the relay matrix .

The tester controller is connected to the test head controller and to the resources within the shared resource block . The tester controller includes a computer connected to a display a keyboard and a pointing device for example a mouse . The computer includes a memory and a central processing unit CPU to execute various types of computing processing. The memory includes one or more storage devices such as a read only memory ROM a random access memory RAM a flash memory a hard disk drive HDD a CD and DVD drive a floppy drive and various memory card drives. Data and programs used in the processing of the CPU are stored in the memory . The tester controller can be configured with network connectivity resources to connect to a network such as the Internet.

The test plan is implemented in tabular form with rows representing steps to be performed and columns defining information used to perform the steps. The measurement function and dispatch function code is implemented as a compiled system of functions to be called during execution of the rows in the test plan . The measurement function and dispatch function code includes an interface to a library API capable of handling parallel execution requests. A library API indicates a set of functions accessible using an Application Programming Interface API which is well known to those of ordinary skill in the art.

The test plan control unit is configured to use parallel execution. The measurement function and dispatch function control units and the library API control units are configured to perform synchronous parallel execution. Parallel execution is performed when specified by entries in the test plan . It is noted that the expression parallel execution as used herein refers to both a synchronous parallel execution function and an asynchronous parallel execution which are described below unless otherwise stated.

The test plan control unit includes a test plan interpreting unit which interprets each row in the test plan . Based on the result of the interpretation the test plan control unit may generate multiple test plan execution units shown in as to . Each test plan execution unit to forms an execution thread and the number n is a thread count or the number of threads to be executed in parallel asynchronously. Each of the test plan execution units to is a series of program steps capable of synchronous execution. Each test plan execution unit executes a test plan allocated on a thread by thread basis one row at a time. The test plan execution units to are generated by the test plan interpreting unit according to entries in the test plan . During execution of a row the test plan execution unit transfers control to one of the measurement function and dispatch function control units in order to call a measurement function or dispatch function specified in the row and to receive a result from the function.

The measurement function and dispatch function control units are provided on a thread by thread basis. The number of the measurement function and dispatch function control units shown in as to generated is equal to the thread count n which is the number of threads to be executed in parallel asynchronously. In each measurement function and dispatch function control unit to a call from the test plan execution unit that is associated with one of the threads is first received by a measurement function and dispatch function executing unit . The variable x represents one of the threads from among the n threads executed in parallel. The measurement function and dispatch function code in the memory is referred to and control is transferred to a dispatch function library API calling unit when the received call relates to a dispatch function. Control is transferred to a measurement function library API calling unit when the received call relates to a measurement function. The measurement function library API calling unit provides an interface capable of handling synchronous parallel execution requests.

The dispatch function library API calling unit returns control to the test plan execution unit in order to execute a library for a relevant dispatch function and to execute a measurement function to be executed with the dispatch function. The measurement function library API calling unit transfers control to the associated library API control unit for the x th thread in order to execute a library for a relevant measurement function. The library API control unit is a control unit capable of handling synchronous parallel execution requests. In the library API control unit a call from the measurement function library API calling unit is received by a library API executing unit and control is transferred next to hardware control firmware in the tester via a hardware control firmware calling unit . The hardware control firmware controls measurement resource hardware to supply given signals to a DUT or to measure the DUT . The library API executing unit is an executing unit capable of handling synchronous parallel execution requests. The hardware control firmware calling unit is a calling unit capable of synchronous parallel execution. The hardware control firmware is firmware capable of synchronous parallel execution.

An output value indicating the result of executing signal supply to or measurement of the DUT is provided to a row of the test plan that is being executed when control is returned to the test plan execution unit which is associated with the x thread following the opposite route. In the case of asynchronous parallel execution described later as many threads as the number of procedures to be executed in the asynchronous parallel execution are generated and executed in parallel and output values are provided to the test plan as a result.

In contrast synchronous parallel execution described below with reference to does not involve generating threads that are to be executed in parallel. Instead blocks capable of synchronous parallel execution are allocated a plurality of measurement resources for synchronous parallel execution. For example synchronous parallel execution to be performed among a plurality of per pin resources or among a plurality of pieces of hardware capable of parallel execution in the shared resource. The blocks capable of synchronous parallel execution are controlled via the test head controller and the per pin SMU module so as to operate in parallel concurrently. The result thereof is provided to the test plan as output values.

The test plan is thus executed one row at a time and the test system is controlled so that an output value indicating the result of the execution of the row is brought to a parameter area specified by the row.

The tabular form used to generate a test plan in the test system described above with reference to and is an expression form used in a domain specific language DSL . DSL is an expression form in a programming language designed for specific processing or a specification description language. DSL includes a simple form input format enabling a user to input entries into the table as well as a language for a specific purpose. The tabular form described herein is also known as a spreadsheet format a ledger sheet input format and a table input format.

The test plan input window includes an asynchronous parallel execution block a synchronous parallel execution block and a dispatch function operation block . The asynchronous parallel execution block includes a column for specifying information used to control asynchronous parallel execution. The synchronous parallel execution block includes a column for specifying information used to control synchronous parallel execution. The dispatch function operation block includes a column for specifying information used to control dispatch operation.

The test plan input window includes a module name column in the first column block to identify a grouping of circuits or devices that can be measured in parallel at once.

Asynchronous parallel execution is understood herein to refer to a process of generating a plurality of threads for execution in parallel and of executing the threads in parallel. The threads are executed independently of one another. That which is being executed in one thread may be completely different from that which is being executed in another thread. In principle asynchronous parallel execution does not involve timing or synchronizing the execution of a step in one thread with the execution of a step in another thread. Asynchronous parallel execution defined as an execution format for executing heterogeneous execution objects in parallel. For example asynchronous parallel execution may be used to execute a thread for operating a DUT with a PSMU and then measuring the DUT with a CMU and another thread for processing another DUT only with an SMU which is a shared resource where the threads execute in parallel.

Providing information in the asynchronous parallel execution block as entries in the column for specifying information used to control the asynchronous parallel execution described above provides the user with control over asynchronous parallel execution. In addition the task of debugging a test plan may be simplified by including entries specifying asynchronous parallel execution in the test plan.

Synchronous parallel execution is understood herein to refer to a parallel execution format for homogeneous execution objects. A synchronous parallel execution format is suitable for cases involving the use of measurement resources having the same function and cases in which the operation sequence among measurement resources operating in parallel is the same. Synchronous parallel execution is a parallel execution mode where the control involves setting a plurality of pieces of hardware to execute in parallel from one thread letting the pieces of hardware start operating concurrently and waiting for the pieces of hardware to stop operating. This mode of parallel execution is synchronous in that measurement resources are executed basically at the same timing.

Dispatch operation control is understood herein to refer to a control structure that eliminates aspects of tabular form test plans that make test plans less readable and improves maintenance properties of the test plan. Dispatch operation control avoids the need for descriptions about program flow control which maintains the readability of the test plan. Dispatch operation control improves maintenance properties by allowing the addition of a new layer that defines program flow control to the software structure on top of a measurement function layer.

A test plan may be composed by a user in which information is entered in the dispatch function operation block in the column specifying information for the dispatch operation control. A dispatch function written in a general purpose programming language is also provided. Intricate program flow control may thus be absorbed by entering a parameter related to the specified dispatch function in the dispatch function operation block . This further causes the test system to operate so that a parameter related to a measurement function that is written in the relevant row of the test plan is called in accordance with processing inside the dispatch function that has been called.

The format for a test plan shown in provides a user with ways to include processing for program flow control in the test plan without disrupting the readability of the test plan. The processing for program flow control may include for example subsidiary processing for measurement operation such as conditional branching processing repetition processing and calling processing for various types of pre processing or post processing. For each measurement function a parameter related to a dispatch function that is associated with the description of a parameter related to the measurement function may be entered in a test plan by adding a corresponding column to the dispatch function operation block . This avoids the need to add rows to the test plan that would otherwise disrupt the readability of the test plan.

In addition the dispatch operation control described above which uses the dispatch function operation block may be combined with both the asynchronous parallel execution described above which uses the asynchronous parallel execution block and the synchronous parallel execution described above which uses the synchronous parallel execution block .

The asynchronous parallel execution block the synchronous parallel execution block and the dispatch function operation block and functions implemented using the asynchronous parallel execution block the synchronous parallel execution block and the dispatch function operation block are described below in the following order 

In examples of test plans used in the description that follows only columns necessary for a description of the function in question are displayed out of the columns illustrated in . It is to be understood that the columns that are not displayed are blank or contain given values depending on the context of the description being given.

Test plan rows to be executed concurrently in synchronous parallel execution have the same module name the same measurement function name and are grouped together for synchronous parallel execution processing. In one example implementation the term error may be displayed when the execution of rows having the same sequence label but different module names and different measurement function names is attempted. In another example such rows are treated as rows for which parallel execution is conducted separately even though the rows have the same sequence label. Rows that have the same measurement function and the same sequence label and that differ from one another only in module name may be treated as different groups in parallel execution.

In the test plan illustrated in a measurement function IOFF2 is entered in the first to third rows with the same sequence label 1 . The measurement function IOFF2 is specified for execution by synchronous parallel execution for the devices TR1 to TR3 with the use of input and output parameters defined in the respective rows in a block .

The operation of the test plan illustrated in is described with reference to the flow chart in which describes the operation of the test plan interpreting unit of . As illustrated in when processing is started in Step the test plan interpreting unit reads all rows of the test plan from the top downward as indicated in Step .

The test plan interpreting unit next groups the rows by module name. Rows are then grouped by measurement function name and then by sequence label. The test plan interpreting unit stores in memory various types of information relating to the groups such as test plan row numbers device names and input and output parameters as indicated in Step .

It should be noted that when test plan rows are grouped by sequence label rows that have no sequence label are grouped together as one group. Test plan rows that have no sequence label and test plan rows having a module name a measurement function name or a sequence label that are found as a result of grouping to be shared by no other rows are recognized as rows that are targets of sequential execution. Test plan rows having a module name a measurement function name or a sequence label that are found as a result of grouping to be shared by two or more rows are recognized as rows that are targets of synchronous parallel execution.

The test plan interpreting unit finishes the processing and passes the result of the processing to a test plan executing unit as indicated in Step . Processing of the test plan interpreting unit in is ended as indicated in Step . It is noted that the processing of which is related to synchronous parallel execution does not involve generating threads to be executed in parallel asynchronously. The test plan executing unit in Step is therefore essentially the test plan execution unit of .

In an example implementation the order of calling measurement functions for the test plan illustrated in may be as follows. First the rows in the test plan are executed in the order that the rows are written from top downward. If the target row during this execution is a sequential execution row only that one test plan row is executed. If the target row during this execution is a synchronous parallel execution row and is at the top among rows that have the same sequence label as the target row each of the synchronous parallel execution rows having the same sequence label are executed in parallel synchronously. That is when executing test plan rows from top downward in the order that the rows are presented rows that have already been executed by synchronous parallel execution because of their sequence labels are skipped over and not executed. This measurement function calling order enables the user to control the execution order so that rows in a test plan are executed in the order the rows appear on the test plan.

In another example implementation the execution order of a test plan may be based on what is entered in the sequence label for the rows and rows having no sequence label or rows whose sequence labels contain a null are executed from top downward by sequential execution. Next rows having sequence labels that do not have reserved words or rows that have non reserved word sequence labels are executed by synchronous parallel execution on a group by group basis in ascending order for example. Next rows having reserved word sequence labels are executed by synchronous parallel execution in a predetermined order. This measurement function calling order enables the user to uniquely control the execution order based on what is entered in the sequence label for the rows.

In still another example implementation the test system is configured to determine the execution order using the entries in the sequence label as a reference. This measurement function calling order allows the test system to control the execution order to suit the convenience of the test system. Therefore an execution order suited to required performance such as test time optimization or noise characteristics optimization is obtained by executing test plan rows in an order optimized by the test system.

The following describes how various types of information such as input and output parameters are passed as arguments to a measurement function in sequential execution and in synchronous parallel execution when the test plan executing unit calls measurement functions in a given order and passes various types of information such as input and output parameters to the measurement function called. is an example of source code for an example of a measurement function that may be used in the test plan in . The function in uses a variable length array parameter as an argument of a measurement function. The variable length array parameter is defined as having the vector type in the C language. In other example implementations a measurement function may be written in other programming languages that support variable length array parameters.

In an example in which a test plan row in the test plan in that contains values Module B TR4 and IOFF2 is executed with the source code of the example of the measurement function IOFF2 of is called once. In addition the arguments expressed in a source code format in Table 1 below may be passed to the measurement function. In the case of an input parameter a parameter having an array count of 1 which points to the parameter contents indicating the row for vd in Table 1 is passed to the measurement function. In the case in which the measurement function receives an output parameter a single parameter having an array count of 1 which points to the line for Id in Table 1 is received by pass by reference.

If execution involves parallel execution such as for example parallel execution for the devices TR1 TR2 and TR3 as illustrated in block of the measurement function IOFF2 is called only once. In addition individual parameters are vectorized or organized in a matrix as shown in Table 2 to compress three instances of passing input and output parameters and arguments into one instance. In the row for parameter vd in Table 2 vd is defined as being a vector type double type double precision floating point parameter of the C language whose value is an array having three values 0.90 0.45 0.05.

As described above the test plan executing unit assembles the arguments of the measurement functions that have been grouped by module name measurement function name and sequence label for parallel execution into a variable length array. The test plan executing unit then generates the arguments as vectorized arguments and passes the vectorized arguments as arguments of the measurement function being executed to one of the measurement function and dispatch function control units . It is noted that the test plan executing unit in calls a measurement function only once for all of a plurality of devices.

The function control unit uses the measurement function executing unit to execute the measurement function based on the received vectorized arguments. In the case in which measurement function calls a measurement library function which may be an API that is provided by the tester the function control unit passes relevant arguments which may include some of the previously received vectorized arguments. The function control unit then calls the library function and transfers control to its own library API calling unit .

The library API calling unit receives the library function call and the vectorized arguments. The library API calling unit organizes the arguments into those that are suitable for the library function to be called. The library in question is called and control is transferred to one of the library API control units .

The library API control unit transfers control to the library API executing unit and based on the passed arguments the library API executing unit operates according to the flowchart in . Referring to when the processing is started in Step the library API executing unit checks the arguments of the libraries to be executed in parallel out of the library arguments passed to the library API executing unit as indicated in Step . The library API executing unit next checks whether or not there are arguments that specify the same pin number as indicated at Step . If the check finds no arguments with the same pin number the library API executing unit proceeds to Step where elements given by the arguments to a tester control unit are passed. Processing of flowchart then ends at Step .

If the check at step finds arguments that specify the same pin number the library API executing unit proceeds to Step to check whether or not other elements of the found arguments besides the pin number such as applied voltage and voltage and current limit values share the same value. In Step the library API executing unit determines whether or not the other elements of the found arguments than the pin number are the same. When the other elements are not the same the library API executing unit proceeds to Step to process the arguments as an error and ends the processing Step . When it is determined in Step that the other elements of the found arguments other than the pin number are the same as well the library API executing unit proceeds to Step to pass a plurality of execution control requests for the same pin as a single control execution request to the tester control unit. The processing of flowchart is then ended at Step .

In an example implementation when a measurement function that is not optimized in terms of processing of shared pads is used in the process shown in on a TEG having shared pads as shown in the library API executing unit may detect an argument that calls for repeating the step of setting the same application voltage or some other parameter to the same pad. The library API executing unit detects for example that the same pin has been passed and executes a library API function omitting redundant processing so that the same process is executed only once. Accordingly redundant processing for a shared pad may be optimized using synchronous parallel execution processing as long as settings are the same.

The library API executing unit performs the process illustrated in the flowchart of and transfers control to its associated hardware control firmware calling unit . The hardware control firmware calling unit responds to a received control request converts the control request relating to sequential execution and parallel execution into a call for the hardware control firmware in the tester and outputs the call to the tester .

Based on the command from the relevant library API control unit the tester executes the measurement resource hardware by sequential execution or parallel execution via the hardware control firmware to thereby conduct a desired test on one or more DUTs .

The types of argument in libraries APIs that may be used by the tester in are described next. Table 3 is c code that defines a parameter type VecDblOrDbl that may be used for the second argument of the library function force v used for applying voltages in .

The test system is able to receive arguments as vector type double as well as a scalar type double. In addition a program may be written as a conventional scalar type which is the case for the second argument 0.0 of the third and fourth force v functions of . The test system spares the user the task of modifying a part of a description in a conventional measurement function in which an argument is passed by value and allows the user to reuse the measurement function.

By providing a test plan written in a tabular form with a sequence label column to specify test plan rows to be executed in parallel synchronously selected parts of a test plan can easily be specified or unspecified for execution by synchronous parallel execution. No recompilation in a test plan programming environment is needed for test plans having a tabular form and are therefore easy to program. Implementation of synchronous parallel execution and the debugging of test plans that use synchronous parallel execution is facilitated.

Table 4 illustrates a comparison between the example of a conventional measurement function described above and an example of a measurement function according to a test system capable of scalable synchronous parallel execution. In Table 4 the first to fourth rows show parameters of arguments the fifth to eighth rows show test specifications and the ninth to twenty seventh rows show source codes of the measurement functions. The sixth seventh and eighth rows are executed in sequential order whereas the sixth to eighth rows are executed concurrently using scalable synchronous parallel execution. In the twenty fourth to twenty sixth rows of the scalable function a resistance R is calculated for each device with the use of measurement results of the respective devices shown in the sixth to eighth rows. A function R.size in the twenty fourth row is a function for returning the array count with respect to the parameter R.

The unit of parallel execution performed by specifying a sequence label is one row of a test plan at a time. This hardly changes test plan readability and makes it easier to understand which equals less chance for errors. The row by row basis also facilitates the automatic generation of a test plan that includes parallelization and helps to increase productivity.

Asynchronous parallel execution allows for parallel execution without requiring that the module name and measurement function be the same. is a test plan input window in a tabular form that incorporates asynchronous parallel execution. The test plan window includes a module name column and a device name column in block similar to block in . Block includes a measurement function column and block includes an input column a terminal column and an output column similar to blocks and in . Block is the sequence column for specifying synchronous parallel execution described with reference to . The use of the sequence column block for asynchronous parallel execution is described below.

The test plan window in includes an asynchronous parallel execution block which corresponds to the asynchronous parallel execution block of . The asynchronous parallel execution block is used to specify execution by asynchronous parallel execution and information relating to asynchronous parallel execution. Asynchronous parallel execution block includes an index column a flow column a sync column and an atomic column.

The operation of the flow column is described with reference to Table 5 below. It is noted that the tables below may only have values in columns that are relevant to the description or may only show have columns that are relevant to the description.

The flow column in the test plan shown in Table 5 contains a flow label that may be used to specify the grouping of rows that are to be executed in parallel asynchronously. The test plan interpreting unit of interprets all rows of the test plan and groups together rows that have the same flow label. Rows that have no flow label may all be grouped into one group.

The module name column the device name column the flow column and the terminal column can hold values for specifying measurements that are executed in parallel asynchronously and concurrently. Execution may be on a module by module basis as described above on a device by device basis as described above in different measurement test units as in concurrent testing for example testing in which a digital test and an analog test constitute separate flows on a package device by package device basis as in multi site testing or on any other suitable basis.

Execution of the test plan illustrated in Table 5 may result in interference between different flows. For example it is assumed for purposes of illustration that the measurement object for Flow 1 and the measurement object for Flow 2 are FETs of different types. Because Flow 1 and Flow 2 are executed completely asynchronously the second IOFF testing in Flow 2 may coincide with the first or second VTH testing of Flow 1 depending on the execution times of the respective rows. This results in interference from the VTH testing in the form of noise or other effects. Such interference may impair the accuracy of the small current measurement performed in the IOFF measurement function. The sync column in block in may be used in cases that involve potential interference. The use of the sync column is described with reference to the test plan shown in Table 6.

The sync column in the test plan in Table 6 includes a sync label in selected columns. During asynchronous parallel execution functions having the same sync label are executed in parallel synchronously even when the functions are executed in different flows. For example while functions in the test plan in Table 6 are divided into Flow 1 and Flow 2 for execution in parallel as shown in Table 7 the third row is an exception. For the third row the measurement function IOFF of Flow 1 which has a sync label A and the measurement function IOFF of Flow 2 which also has the sync label A are executed in sync with each other. The plurality of functions executed in parallel synchronously using the sync column need not be the same functions. The functions that have the same sync label and are executed in parallel synchronously are in sync with each other only in terms of when the functions are started in their respective threads. These functions do not use the mechanism of synchronous parallel execution described above.

In the test plan in Table 7 if the function IOFF of Flow 1 executes for a length of time that differs from the length of time it takes for the function IOFF of Flow 2 to execute for example the function IOFF of one of the flows may still be in the process of executing when the function VTH of the other flow is started. This may adversely affect the IOFF measurement. The test plan in Table 8 illustrates a mechanism for avoiding this scenario.

In the test plan in Table 8 rows having the same sync label are started in sync with one another and executed as shown in Table 9.

The test plan in Table 10 is similar to the test plan in Table 8 but modified to include an atomic column which may be used to obtain similar results in IOFF tests.

The atomic column in the test plan in Table 10 may contain an atomic flag to indicate exclusive execution. The atomic flag is shown in Table 10 as an entry v. In executing the test plan the execution of functions that do not have an atomic flag is suspended while functions in rows that contain the atomic flag v are executed. Functions in rows that contain the atomic flag are executed exclusively. The user may enter an atomic flag in an atomic column for functions when the execution of the test plan may result in an interference due to the execution of another flow.

An atomic label may be defined for the atomic column so that interference between flows is avoided by grouping together rows that have the same atomic label and executing functions on an atomic label group by atomic label group basis.

Table 12 is a test plan in which the advantages of synchronous parallel execution described above are introduced in addition to those of asynchronous parallel execution. The test plan in Table 12 combines the sequence column described above with the flow column. With respect to the flow label values and sequence label values entered in Table 12 a label value that starts with creates a no label state by commenting out the label. During execution when the is encountered the execution for the label that follows is not executed. The label prefix for commenting out labels facilitates debugging by easily singling out rows suspected of causing problems due to asynchronous parallel execution operation or synchronous parallel execution operation. The label prefix prevents execution of the row or function commented out and the debugger determines how execution is affected.

The test plan of Table 12 is executed as illustrated in . In each function name has a parenthesized number to its right indicating how many tests are executed in parallel synchronously. Rows in a block which hold functions E and F and have no flow label are executed first. Functions in block of Flow 1 and functions in block of Flow 2 are executed by asynchronous parallel execution. Functions in block are executed by sequential execution. The functions in block have a 1 as a parallel execution test count because the values associated with the functions in the sequence column are commented out.

The sequence label and the flow label to be employed may be determined as follows. For the parallel measurement of a plurality of devices of the same type measurement by synchronous parallel execution with only the sequence label specified is chosen for execution. For parallel measurement of a plurality of modules measurement by asynchronous parallel execution with only the flow label specified is chosen for execution. For parallel measurement of a plurality of devices of the same type in a plurality of modules measurement by asynchronous parallel execution and synchronous parallel execution with both the flow label and the sequence label specified is chosen for execution. For measurement of all devices by sequential execution or to obtain results of sequential execution measurement for a comparison against results of parallel measurement sequential execution that specifies neither the flow label nor the sequence label is chosen.

A choice between synchronous parallel execution and asynchronous parallel execution when the sequence label or the flow label is commented out may be made as follows. For the most efficient measurement measurement that enables both asynchronous parallel execution and synchronous parallel execution is conducted. In the case in which a problem such as interference due to synchronous parallel execution is suspected measurement that enables asynchronous parallel execution alone is conducted. In the case in which a problem such as interference due to asynchronous parallel execution is suspected measurement that enables synchronous parallel execution alone is conducted. When a problem such as both interference due to asynchronous parallel execution and synchronous parallel execution is suspected or to obtain measurement data by sequential execution as comparison data or when high quality measurement data is requested measurement that disables both asynchronous parallel execution and synchronous parallel execution is conducted.

An index column may be added to the test plan to facilitate debugging by identifying problems during the debugging of asynchronous parallel execution. The use of an index column is described with reference to Table 13.

Table 13 is a test plan that uses the flow column and the sync column. is a diagram illustrating operation of an example of the test plan shown in Table 13. shows Flow 1 of block and Flow 2 of block executed first in parallel asynchronously. Thereafter Flow 1 of block Flow 2 of block and Flow 3 of block are executed in parallel asynchronously.

If the sync label is deleted from one of the fifth seventh and ninth rows of Table 13 in order to identify a problem the structure of the blocks to of is lost which makes it difficult to debug the test plan of Table 13. In order to avoid an influence from the mutual relation of the flow column the sync column and the atomic column an index column which is a host column to these three columns is provided to remove the sync column. The index column is added to the test plan as shown in Table 14.

The index column as configured in Table 14 forces the blocks and in to execute first by asynchronous parallel execution followed by the asynchronous parallel execution of blocks to . The problem described above with the removal of the sync label in Table 13 does not occur. In general the index column may be used to specify the order of function groups that are executed in parallel asynchronously in the respective flows. The index column may also be viewed as a way of indicating the relative priority of the rows in the table.

Columns in a test plan related to asynchronous parallel execution described above may be used to detect a deadlock in asynchronous parallel execution. A deadlock may occur when for example a test plan is programmed so that while one thread of the first parallel processing waits to start until a thread of the second parallel processing is finished another thread of the second parallel processing does not start unless another thread of the first parallel processing is finished. In an example implementation the semiconductor parametric test system may be configured to issue an alert about a test plan that is predicted to incur a deadlock before the test plan is executed. The semiconductor parametric test system may read all rows of the test plan and execute a deadlock detecting method an example of which is illustrated in with the test plan interpreting unit of .

The test plan interpreting unit reads all rows of a test plan interprets how sync labels are assigned to the respective flows and determines by analysis that sync labels are assigned as shown in Table 15.

The test plan interpreting unit then executes a deadlock detecting program according to the flowchart in . The test plan interpreting unit starts the program at Step and puts sync labels of the respective flows into a FIFO buffer hereinafter referred to as FIFO in the order of appearance at Step . As a result a part of Table 15 where sync labels are null is omitted from the contents of the FIFO and sync values are accumulated in the FIFO as shown in Table 16. The FIFO is provided in the memory of .

In Step the test plan interpreting unit counts for each sync label the appearance frequency throughout the entire FIFO and saves the appearance frequency. For example a sync label 2 has an appearance frequency of 3. In Step the test plan interpreting unit obtains the highest appearance frequency in the head entries of the respective flows in the FIFO. In the case of Table 16 a sync label 1 has the highest appearance frequency at . In Step the highest sync label appearance frequency obtained in Step is compared against the appearance frequency of the corresponding sync label which has been obtained in Step . If the two match entries of the sync label in this example four 1 s of Flow 1 Sync to Flow 4 Sync in the first row of Table 16 are deleted from the head row of the FIFO. If the entries above those of the respective flows in the FIFO include blank entries and entries below those of the flows include non blank entries the non blank entries are shifted upward. Step determines whether or not an entry has been deleted from the head row of the FIFO in Step . When Step determines that yes an entry has been deleted the test plan interpreting unit returns to Step . Step proceeds to Step when the answer is no. Step determines whether or not a non blank entry remains in the FIFO. The test plan interpreting unit proceeds to Step when the answer to Step is yes and to Step when the answer is no. In Step the test plan interpreting unit determines that a dead lock does not occur in the current test plan and proceeds to Step to end this program. In Step the test plan interpreting unit determines that a deadlock is going to occur in the current test plan displays an alert or error and proceeds to Step to end this program.

In asynchronous parallel execution the test plan execution units are generated in the test plan control unit of which is capable of parallel execution in association with respective threads that are executed by asynchronous parallel execution. Blocks are executed accordingly to control the tester . The columns illustrated in are provided as columns for asynchronous parallel execution. The asynchronous parallel execution can also be combined with the synchronous parallel execution described above. The asynchronous parallel execution may be used to specify parallel execution as well as overlapping parallel measurements switching between parallel and serial avoiding interference in measurement performing explicit parallel execution order control and detecting a deadlock prior to parallel execution.

The information relating to the first dispatch function is specified for a test plan by entering the information in the relevant columns. A dispatch label may be entered in the dispatch label column . The dispatch label may be entered as numbers letters or a combination thereof. If a row contains a null as a dispatch label value the row is interpreted as a row that performs its own dispatch operation. Rows that do not have null as a dispatch label and have a dispatch label in common are grouped together and interpreted as code in which several case analysis dispatch operations are entered in an integrated manner.

A dispatch function name may be entered in the dispatcher column . The dispatcher input column in block is used for entering an input parameter. The dispatcher terminal column in block is used for entering terminal information. The dispatcher output column in block is used for entering information about an output parameter.

The information relating to the second dispatch function may be specified for a test plan by entering the information in the dispatch label 2 column the dispatcher 2 column and the columns in block . These columns and the columns in block are similar to the columns in the columns and the columns in block and may be used for information entry as described for the first dispatch function.

The For Loop function repetitively executes a function Execute 0 the number of times indicated by an argument Loop which is included in the input parameters defined in . The particular example shown at is ten times. The Execute function is provided by a dispatch function library API to execute the second dispatch function. The Execute function is called with a parenthesized integer value equal to or greater than 0 as an index. The Execute function may also execute a measurement function in a row that is reached by shifting downward from a test plan row that is being executed by the number of rows indicated by the index. In the illustrated example the function Execute 0 executes an IOFF2 function of the same row based on the input and output parameters of the IOFF2 function . The function to be executed is determined by the test plan execution units of .

Table 18 contains an example of source code for a dispatch function If Branch which is an example of conditional branching processing.

The functions IF Branch in the third to fifth rows of the test plan share the same dispatch label D1. The If Branch function processes these three rows as one group. When the value of leak passed as an input parameter is greater than twice the parameter n a measurement function VTH entered in the third row is executed based on input and output parameters of the measurement function VTH2 . When the value of leak is greater than the parameter n and is equal to or less than twice the parameter n a function LET of the fourth row is executed based on input and output parameters . When the value of leak is equal to or less than the parameter n a function LET of the fifth row is executed based on input and output parameters .

The dispatch function control allows a user to configure a test plan with only one row for repetition processing and only three rows for branching processing involving three branches. In addition the part of the test plan that corresponds to the conditional branching processing and repetition processing is executed using the compiled code of the dispatch function resulting in faster execution of the code.

In another example implementation the dispatch function may also be used to reduce the length of test plans involving a large number of measurements as shown in Table 19.

A test plan for an array TEG may also be written in as shown in Table 20 by using a dispatch function Arry ctl which controls addressing of array devices as shown in Table 21. The dispatch function may be used to reduce the size of test plans involving similar processes that are constantly and frequently executing and classified as routine processing.

An example implementation of a simple adaptive test may be performed using a test plan configured to use dispatch operation control. An adaptive test may be implemented with a test plan without impairing the test plan s readability by entering for example a function Sampling which is listed in Table 23. The function Sampling is used for reducing the tests in the dispatcher column as shown in Table 22. The function Sampling is a function that calls a measurement function by moving a die to be tested to a particular site based on a label key which is entered in the dispatcher input column. This function allows for a selection of only critical dies for testing instead of testing all dies on a wafer.

Referring to the dispatch operation control may be executed as follows. The test plan interpreting unit reads all rows of the test plan . If a specification of the first dispatch function is detected the rows are grouped by dispatch label and executed in a manner determined by the result of the grouping. Execution is performed by the dispatch function library API calling unit via the relevant test plan execution unit and further via the measurement function and dispatch function control unit which is capable of parallel execution of dispatch functions. The processing returns to the test plan execution unit in order to refer to the specification about the second dispatch function or a description about a measurement function. The processing is executed in accordance with the specification about the second dispatch function or the description about a measurement function.

The asynchronous parallel execution synchronous parallel execution and dispatch operation control described above can be freely combined in any test plan.

The description given above on asynchronous parallel execution uses implementation by multi threads that share a memory space. Alternatively the asynchronous parallel execution may be implemented by multi processing or multi tasking. In such implementations even when one flow goes down in a user code another flow is operating in another process and can therefore detect an anomaly in the other process. This enables the test system to end all processing procedures after executing safe post processing.

It is noted that the columns in the example test plans described above are illustrated in certain positions on the tabular form test plans. The columns are not limited to the locations illustrated in their respective tables. The columns may be located at any suitable location on the table. Columns may be added or subtracted as desired for specific implementations.

A multi stage test plan may also be configured in which dispatch operation control is extended to three stages or more. For example the two stage test plan of may be extended into a three stage test plan with the use of another dispatch function that handles program flow control of repetition. A multi stage test plan with even more stages may also be created by using dispatch functions that handle various types of program flow control.

The semiconductor parametric test system described above may be scaled up to a semiconductor test system.

It will be understood that various aspects or details of the invention may be changed without departing from the scope of the invention. Furthermore the foregoing description is for the purpose of illustration only and not for the purpose of limitation the invention being defined by the claims.

