---

title: Dynamically retraining a prediction model based on real time transaction data
abstract: Various embodiments of systems and methods to dynamically retrain prediction models based on real time transaction data are described herein. In one aspect, real time application data and status data associated with an entity are obtained. The obtained application data is inputted to a prediction model to produce an assessment of a risk. The obtained status data with the assessed risk are compared. When the obtained payment status data does not match the determined risk, the prediction model is retrained.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09449344&OS=09449344&RS=09449344
owner: SAP SE
number: 09449344
owner_city: Walldorf
owner_country: DE
publication_date: 20131223
---
Prediction models are applied to predict future trends or behavior patterns e.g. a risk of default from given input data. Typically a prediction model is trained with transaction data associated with entities for achieving better operational efficiencies reducing fraudulent transactions and the like. Often the amount of transactional data is significantly large e.g. in terabytes and gigabytes and changes frequently e.g. daily . Therefore the process of training the prediction model could be time consuming and it may be difficult to regularly check the accuracy of the prediction model. Further training the prediction model periodically e.g. monthly may not be accurate since the transaction data used to train the prediction model may become old e.g. by a month and relying on old transaction data might be risky.

Embodiments of techniques to dynamically retrain a prediction model based on real time transaction data are described herein. Prediction models are mathematical models that establish co relations between parameters that affect an outcome. According to various embodiments the prediction models are built by analyzing transaction data e.g. historical transaction data and the relationships between the influencing parameters and the output is derived to predict future trends or behavior patterns. Further the transaction data e.g. input data can be referred as training data associated with entities. An entity can be an individual a group of people a company group of companies etc. Further the prediction model can then be used to predict the output for any new set of influencing parameters e.g. the parameters for a new customer .

Initially the prediction model is trained using training data e.g. historical transaction data associated with the entities. Training the prediction model involves scrutinizing the historical transaction data and establishing a relationship between the influencing parameters and the output. In one exemplary embodiment transaction data includes application data consisting of parameters influencing a risk and status data defining status of deferral of payment. Subsequently in one embodiment when real time transaction data e.g. application data and status data associated with an entity is received the risk outcome as outputted by the prediction model corresponding to the received application data is checked. Further when the risk outcome as output by the prediction model does not match with the received payment status data the prediction model is dynamically retrained using the received real time transaction data. The real time transaction data can be a new transaction data or a change in the existing transaction data associated with the entity. In other words when the relationship between the influencing parameters and the output does not match due to a change in a pattern of the transactional data then the prediction model is retrained. Retraining can be defined as re establishing the relationship between the influencing parameters and the output to account for the new pattern of changed transaction data.

Reference throughout this specification to one embodiment this embodiment and similar phrases means that a particular feature structure or characteristic described in connection with the embodiment is included in at least one of the one or more embodiments. Thus the appearances of these phrases in various places throughout this specification are not necessarily all referring to the same embodiment. Furthermore the particular features structures or characteristics may be combined in any suitable manner in one or more embodiments.

Data repository stores historical transaction data and real time transaction data associated with entities providing insights about trends and behavior of the entities. The real time transaction data and or the historical transaction data is used to train and or retrain the prediction model . In one exemplary embodiment the data repository is an in memory computer system. The transaction data includes application data and status data of different entities involved in business transactions. For example the application data may include risk related parameters such as but not limited to income level number of existing loans number of early payoffs done by an entity payment plan change skip of payments pertaining to existing loan extension of a loan and age of an entity. The status data may define whether an entity has defaulted loan.

Initially the prediction model may be trained with the historical transaction data stored in the data repository . Future behavior patterns can be predicted by the prediction model for various purposes such as launch a new product service on the market understanding and anticipating trends of the market better operational efficiencies reducing operational risks and fraudulent transactions predicting a risk of default etc.

The transaction data associated with the entities can change over time. Therefore it is advantageous to retrain the prediction model using real time transaction data. Accordingly in one embodiment the model retraining module retrains the prediction model based on the real time transaction data to keep the prediction model updated.

Process can be implemented in other models such as but not limited to prediction model built using classification tree regression model economic model econometric model forecasting model decision support model estimation model and projection model. Also the process can be applied to other scenarios such as but not limited to share market and pattern recognition.

At real time application data and status data e.g. real time transaction data associated with an entity are obtained. In one embodiment the application data includes a number of parameters or factors affecting a risk as shown in Table 1 

In one embodiment the parameters are interdependent. For example the income level and the age of the customer can be interdependent as the income level may increase with the age. Further the status data defines any payment deferral or overdue or delinquency of a loan.

At the obtained application data is inputted to a prediction model to produce an assessment of a risk. In one embodiment obtained application data is transformed into binary for simplicity. For example an entity having a high or medium income is given value 1 and an entity having a low income is given value 0 . Similarly binary values are assigned to each parameter as specified in Table 1. Further the application data e.g. parameters are inputted to the prediction model.

Exemplary prediction model built using ANN is depicted in . The ANN is used to solve a class of problems that involve a plurality of input parameters and interdependency between them. The ANN consists of multiple layers. A first layer is an input layer e.g. and a last layer is an output layer e.g. . In between the first layer and the last layer there can be one or more hidden layers. One hidden layer for instance is depicted in . The number of hidden layers required depends on the complexity of the problem solved using ANN and also on the nature of the output. The number of nodes in a hidden layer is equal to or more than the arithmetic mean of the number of nodes on either side of the layer. In the number of hidden nodes is equal to or more than 10 2 2 6 e.g. XH to XH .

The application data e.g. parameters depicted in Table 1 are inputted to the prediction model through input nodes e.g. X to X . The connections between the input nodes e.g. X to X to hidden nodes e.g. XH to XH of hidden layer are referred as hidden nodes weights WH . Further the connections between the hidden nodes e.g. XH to XH and output nodes e.g. XO and XO of the output layer are referred as output node weights WO . Initially while training the prediction model the WH and WO are calculated based on the transaction data e.g. historical transaction data including application data and loan default data of customers . In one exemplary embodiment the hidden nodes e.g. XH to XH and the output nodes XO and XO are computed using below Equations 1A 1B 2A and 2B e.g. sigmoid function . Further the values of WH and WO may be adjusted by a trial and error method till the values of the output nodes e.g. XO and XO match with the historical transaction data.

For example calculating the hidden nodes e.g. XH to XH and the output nodes e.g. XO and XO using the Equations 1A 1B 2A and 2B are depicted in Tables 2 6. Table 2 depicts number of input nodes and corresponding values. Table 3 depicts the hidden nodes weights WH . Table 4 depicts number of hidden nodes and corresponding values. Table 5 depicts the output node weights WO . Table 6 depicts the number of output nodes and corresponding values.

In the example if the output node is more than numeric value of 1 then a first output node fires otherwise the second output node fires. Firing of the first output node is interpreted as a non risky prediction while the firing of the second output node is interpreted as a risky prediction. The prediction model may be used to assess the risk of default based on the inputted real time application data. In the example upon determining that the first output node fires for the real time application data the assessed risk is returned as a non risky prediction.

At the obtained status data is compared with the assessed risk. For example consider the obtained payment status data indicate that the customer has defaulted the loan. The assessed risk of default as outputted by the prediction model indicates non risky prediction for the application data. Therefore the obtained payment status data and the assessed risk of default do not match.

At the prediction model is retrained upon determining that the obtained status data does not match the determined risk. When the obtained status data match with the determined risk the prediction model is retained. In the example the prediction model may be retrained based on the obtained real time application data and the payment status data. The pre condition for retraining the prediction model may be a change in transaction data that has resulted in defaulting of a loan though the prediction is positive also vice versa . Thus the risks are predicted for real time transaction data and corrective actions can be timely taken before the risk increases or becomes an issue.

At a check is performed whether the output nodes match the real time status data. When the output nodes do not match the status data hidden node weights WH and output node weights WO are again adjusted to new values and the hidden nodes and the output nodes are computed. The adjusting the hidden node weights WH and the output node weights WO is performed until the output nodes match the status data and thus the prediction model is retrained. The hidden node weights WH and the output node weights WO may be adjusted based on calculated error between the output nodes and the status data.

Whenever real time transaction data is received at a data repository a check of the prediction model may be triggered. When the prediction does not match with the real time transaction data e.g. a customer may have defaulted despite being predicted as low risk or vice versa then the prediction model requires re training to account for this change of behavior. Thus the prediction model may be kept current with respect to transactional data asynchronously and no manual intervention may be necessary.

Some embodiments may include the above described methods being written as one or more software components. These components and the functionality associated with each may be used by client server distributed or peer computer systems. These components may be written in a computer language corresponding to one or more programming languages such as functional declarative procedural object oriented lower level languages and the like. They may be linked to other components via various application programming interfaces and then compiled into one complete application for a server or a client. Alternatively the components may be implemented in server and client applications. Further these components may be linked together via various distributed programming protocols. Some example embodiments may include remote procedure calls being used to implement one or more of these components across a distributed programming environment. For example a logic level may reside on a first computer system that is remotely located from a second computer system containing an interface level e.g. a graphical user interface . These first and second computer systems can be configured in a server client peer to peer or some other configuration. The clients can vary in complexity from mobile and handheld devices to thin clients and on to thick clients or even other servers.

The above illustrated software components are tangibly stored on a computer readable storage medium as instructions. The term computer readable storage medium should be taken to include a single medium or multiple media that stores one or more sets of instructions. The term computer readable storage medium should be taken to include any physical article that is capable of undergoing a set of physical changes to physically store encode or otherwise carry a set of instructions for execution by a computer system which causes the computer system to perform any of the methods or process steps described represented or illustrated herein. A computer readable storage medium may be a non transitory computer readable storage medium. Examples of a non transitory computer readable storage media include but are not limited to magnetic media such as hard disks floppy disks and magnetic tape optical media such as CD ROMs DVDs and holographic devices magneto optical media and hardware devices that are specially configured to store and execute such as application specific integrated circuits ASICs programmable logic devices PLDs and ROM and RAM devices. Examples of computer readable instructions include machine code such as produced by a compiler and files containing higher level code that are executed by a computer using an interpreter. For example an embodiment may be implemented using Java C or other object oriented programming language and development tools. Another embodiment may be implemented in hard wired circuitry in place of or in combination with machine readable software instructions.

A data source is an information resource. Data sources include sources of data that enable data storage and retrieval. Data sources may include databases such as relational transactional hierarchical multi dimensional e.g. OLAP object oriented databases and the like. Further data sources include tabular data e.g. spreadsheets delimited text files data tagged with a markup language e.g. XML data transactional data unstructured data e.g. text files screen scrapings hierarchical data e.g. data in a file system XML data files a plurality of reports and any other data source accessible through an established protocol such as Open Data Base Connectivity ODBC produced by an underlying software system e.g. ERP system and the like. Data sources may also include a data source where the data is not tangibly stored or otherwise ephemeral such as data streams broadcast data and the like. These data sources can include associated data foundations semantic layers management systems security systems and so on.

In the above description numerous specific details are set forth to provide a thorough understanding of embodiments. One skilled in the relevant art will recognize however that the embodiments can be practiced without one or more of the specific details or with other methods components techniques etc. In other instances well known operations or structures are not shown or described in details.

Although the processes illustrated and described herein include series of steps it will be appreciated that the different embodiments are not limited by the illustrated ordering of steps as some steps may occur in different orders some concurrently with other steps apart from that shown and described herein. In addition not all illustrated steps may be required to implement a methodology in accordance with the one or more embodiments. Moreover it will be appreciated that the processes may be implemented in association with the apparatus and systems illustrated and described herein as well as in association with other systems not illustrated.

The above descriptions and illustrations of embodiments including what is described in the Abstract is not intended to be exhaustive or to limit the one or more embodiments to the precise forms disclosed. While specific embodiments of and examples for the embodiments are described herein for illustrative purposes various equivalent modifications are possible within the scope of the embodiments as those skilled in the relevant art will recognize. These modifications can be made in light of the above detailed description. Rather the scope is to be determined by the following claims which are to be interpreted in accordance with established doctrines of claim construction.

