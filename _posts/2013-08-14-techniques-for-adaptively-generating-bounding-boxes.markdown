---

title: Techniques for adaptively generating bounding boxes
abstract: One embodiment of the present invention includes a method for generating accumulated bounding boxes for graphics primitives. The method includes generating a first bounding box associated with a first graphics primitive. The method further includes, for each graphics primitive included in a first set of one or more additional graphics primitives, determining that the graphics primitive is within a threshold distance of the first bounding box, and adding the graphics primitive to the first bounding box. The method further includes determining not to add a second graphics primitive to the first bounding box. The method further includes generating a second bounding box associated with the second graphics primitive. Finally, the method includes transmitting the first bounding box to a tiling unit via a crossbar. One advantage of the disclosed embodiments is that multiple bounding boxes are combined to generate an accumulated bounding box that is then transferred across the crossbar.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09342311&OS=09342311&RS=09342311
owner: NVIDIA Corporation
number: 09342311
owner_city: Santa Clara
owner_country: US
publication_date: 20130814
---
This application claims benefit of U.S. provisional patent application Ser. No. 61 719 271 filed Oct. 26 2012 and titled An Approach for Tiled Caching. The subject matter of this related application is hereby incorporated herein by reference.

Embodiments of the present invention relate generally to graphics processing and more specifically to techniques for adaptively generating bounding boxes.

Various graphics systems implement a tiling architecture that divides the screen space into tiles and processes data associated with each tile in a particular order. That is data associated with a first tile is processed first data associated with a second tile is processed second and so on. In such graphics systems a highly parallel architecture may be implemented such that the work associated with one or more tiles is distributed to a plurality of processing units.

In one approach to distributing work in a highly parallel architecture data is transferred from at least one world space pipeline to multiple tiling units via a crossbar where each tiling unit may be associated with a different screen space pipeline. Although crossbars provide a high degree of flexibility when routing data one drawback to implementing a crossbar is that overhead can be substantially increased and overall performance reduced if too much data is transmitted across the crossbar.

In addition in many conventional tiled rendering systems all geometry is typically tested against each tile to determine what if any geometry intersects the different tiles. One drawback to such an approach is that such testing is superfluous in cases where particular geometry does not intersect a given tile or when no geometry intersects a given tile. Consequently conventional approaches to tiling may increase overhead and reduce overall performance too.

As the foregoing illustrates what is needed in the art are ways to reduce the amount of data transmitted over a crossbar and increase the efficiency of tiling operations in a parallel tile based architecture.

One embodiment of the present invention sets forth a method for generating accumulated bounding boxes for graphics primitives. The method includes generating a first bounding box associated with a first graphics primitive. The method further includes for each graphics primitive included in a first set of one or more additional graphics primitives determining that the graphics primitive is within a threshold distance of the first bounding box and adding the graphics primitive to the first bounding box. The method further includes determining not to add a second graphics primitive to the first bounding box. The method further includes generating a second bounding box associated with the second graphics primitive. Finally the method includes transmitting the first bounding box to a tiling unit via a crossbar.

One advantage of the disclosed technique is that multiple bounding boxes are combined to generate an accumulated bounding box. The accumulated bounding box is then transferred across the crossbar. Accordingly the number of bounding boxes transferred across the crossbar is reduced decreasing processing overhead.

In the following description numerous specific details are set forth to provide a more thorough understanding of the present invention. However it will be apparent to one of skill in the art that the present invention may be practiced without one or more of these specific details.

In operation I O bridge is configured to receive user input information from input devices such as a keyboard or a mouse and forward the input information to CPU for processing via communication path and memory bridge . Switch is configured to provide connections between I O bridge and other components of the computer system such as a network adapter and various add in cards and .

As also shown I O bridge is coupled to a system disk that may be configured to store content and applications and data for use by CPU and parallel processing subsystem . As a general matter system disk provides non volatile storage for applications and data and may include fixed or removable hard disk drives flash memory devices and CD ROM compact disc read only memory DVD ROM digital versatile disc ROM Blu ray HD DVD high definition DVD or other magnetic optical or solid state storage devices. Finally although not explicitly shown other components such as universal serial bus or other port connections compact disc drives digital versatile disc drives film recording devices and the like may be connected to I O bridge as well.

In various embodiments memory bridge may be a Northbridge chip and I O bridge may be a Southbrige chip. In addition communication paths and as well as other communication paths within computer system may be implemented using any technically suitable protocols including without limitation AGP Accelerated Graphics Port HyperTransport or any other bus or point to point communication protocol known in the art.

In some embodiments parallel processing subsystem comprises a graphics subsystem that delivers pixels to a display device that may be any conventional cathode ray tube liquid crystal display light emitting diode display or the like. In such embodiments the parallel processing subsystem incorporates circuitry optimized for graphics and video processing including for example video output circuitry. As described in greater detail below in such circuitry may be incorporated across one or more parallel processing units PPUs included within parallel processing subsystem . In other embodiments the parallel processing subsystem incorporates circuitry optimized for general purpose and or compute processing. Again such circuitry may be incorporated across one or more PPUs included within parallel processing subsystem that are configured to perform such general purpose and or compute operations. In yet other embodiments the one or more PPUs included within parallel processing subsystem may be configured to perform graphics processing general purpose processing and compute processing operations. System memory includes at least one device driver configured to manage the processing operations of the one or more PPUs within parallel processing subsystem .

In various embodiments parallel processing subsystem may be integrated with one or more other the other elements of to form a single system. For example parallel processing subsystem may be integrated with CPU and other connection circuitry on a single chip to form a system on chip SoC .

It will be appreciated that the system shown herein is illustrative and that variations and modifications are possible. The connection topology including the number and arrangement of bridges the number of CPUs and the number of parallel processing subsystems may be modified as desired. For example in some embodiments system memory could be connected to CPU directly rather than through memory bridge and other devices would communicate with system memory via memory bridge and CPU . In other alternative topologies parallel processing subsystem may be connected to I O bridge or directly to CPU rather than to memory bridge . In still other embodiments I O bridge and memory bridge may be integrated into a single chip instead of existing as one or more discrete devices. Lastly in certain embodiments one or more components shown in may not be present. For example switch could be eliminated and network adapter and add in cards would connect directly to I O bridge .

In some embodiments PPU comprises a graphics processing unit GPU that may be configured to implement a graphics rendering pipeline to perform various operations related to generating pixel data based on graphics data supplied by CPU and or system memory . When processing graphics data PP memory can be used as graphics memory that stores one or more conventional frame buffers and if needed one or more other render targets as well. Among other things PP memory may be used to store and update pixel data and deliver final pixel data or display frames to display device for display. In some embodiments PPU also may be configured for general purpose processing and compute operations.

In operation CPU is the master processor of computer system controlling and coordinating operations of other system components. In particular CPU issues commands that control the operation of PPU . In some embodiments CPU writes a stream of commands for PPU to a data structure not explicitly shown in either or that may be located in system memory PP memory or another storage location accessible to both CPU and PPU . A pointer to the data structure is written to a pushbuffer to initiate processing of the stream of commands in the data structure. The PPU reads command streams from the pushbuffer and then executes commands asynchronously relative to the operation of CPU . In embodiments where multiple pushbuffers are generated execution priorities may be specified for each pushbuffer by an application program via device driver to control scheduling of the different pushbuffers.

As also shown PPU includes an I O input output unit that communicates with the rest of computer system via the communication path and memory bridge . I O unit generates packets or other signals for transmission on communication path and also receives all incoming packets or other signals from communication path directing the incoming packets to appropriate components of PPU . For example commands related to processing tasks may be directed to a host interface while commands related to memory operations e.g. reading from or writing to PP memory may be directed to a crossbar unit . Host interface reads each pushbuffer and transmits the command stream stored in the pushbuffer to a front end .

As mentioned above in conjunction with the connection of PPU to the rest of computer system may be varied. In some embodiments parallel processing subsystem which includes at least one PPU is implemented as an add in card that can be inserted into an expansion slot of computer system . In other embodiments PPU can be integrated on a single chip with a bus bridge such as memory bridge or I O bridge . Again in still other embodiments some or all of the elements of PPU may be included along with CPU in a single integrated circuit or system of chip SoC .

In operation front end transmits processing tasks received from host interface to a work distribution unit not shown within task work unit . The work distribution unit receives pointers to processing tasks that are encoded as task metadata TMD and stored in memory. The pointers to TMDs are included in a command stream that is stored as a pushbuffer and received by the front end unit from the host interface . Processing tasks that may be encoded as TMDs include indices associated with the data to be processed as well as state parameters and commands that define how the data is to be processed. For example the state parameters and commands could define the program to be executed on the data. The task work unit receives tasks from the front end and ensures that GPCs are configured to a valid state before the processing task specified by each one of the TMDs is initiated. A priority may be specified for each TMD that is used to schedule the execution of the processing task. Processing tasks also may be received from the processing cluster array . Optionally the TMD may include a parameter that controls whether the TMD is added to the head or the tail of a list of processing tasks or to a list of pointers to the processing tasks thereby providing another level of control over execution priority.

PPU advantageously implements a highly parallel processing architecture based on a processing cluster array that includes a set of C general processing clusters GPCs where C 1. Each GPC is capable of executing a large number e.g. hundreds or thousands of threads concurrently where each thread is an instance of a program. In various applications different GPCs may be allocated for processing different types of programs or for performing different types of computations. The allocation of GPCs may vary depending on the workload arising for each type of program or computation.

Memory interface includes a set of D of partition units where D 1. Each partition unit is coupled to one or more dynamic random access memories DRAMs residing within PPM memory . In one embodiment the number of partition units equals the number of DRAMs and each partition unit is coupled to a different DRAM . In other embodiments the number of partition units may be different than the number of DRAMs . Persons of ordinary skill in the art will appreciate that a DRAM may be replaced with any other technically suitable storage device. In operation various render targets such as texture maps and frame buffers may be stored across DRAMs allowing partition units to write portions of each render target in parallel to efficiently use the available bandwidth of PP memory .

A given GPCs may process data to be written to any of the DRAMs within PP memory . Crossbar unit is configured to route the output of each GPC to the input of any partition unit or to any other GPC for further processing. GPCs communicate with memory interface via crossbar unit to read from or write to various DRAMs . In one embodiment crossbar unit has a connection to I O unit in addition to a connection to PP memory via memory interface thereby enabling the processing cores within the different GPCs to communicate with system memory or other memory not local to PPU . In the embodiment of crossbar unit is directly connected with I O unit . In various embodiments crossbar unit may use virtual channels to separate traffic streams between the GPCs and partition units .

Again GPCs can be programmed to execute processing tasks relating to a wide variety of applications including without limitation linear and nonlinear data transforms filtering of video and or audio data modeling operations e.g. applying laws of physics to determine position velocity and other attributes of objects image rendering operations e.g. tessellation shader vertex shader geometry shader and or pixel fragment shader programs general compute operations etc. In operation PPU is configured to transfer data from system memory and or PP memory to one or more on chip memory units process the data and write result data back to system memory and or PP memory . The result data may then be accessed by other system components including CPU another PPU within parallel processing subsystem or another parallel processing subsystem within computer system .

As noted above any number of PPUs may be included in a parallel processing subsystem . For example multiple PPUs may be provided on a single add in card or multiple add in cards may be connected to communication path or one or more of PPUs may be integrated into a bridge chip. PPUs in a multi PPU system may be identical to or different from one another. For example different PPUs might have different numbers of processing cores and or different amounts of PP memory . In implementations where multiple PPUs are present those PPUs may be operated in parallel to process data at a higher throughput than is possible with a single PPU . Systems incorporating one or more PPUs may be implemented in a variety of configurations and form factors including without limitation desktops laptops handheld personal computers or other handheld devices servers workstations game consoles embedded systems and the like.

Operation of GPC is controlled via a pipeline manager that distributes processing tasks received from a work distribution unit not shown within task work unit to one or more streaming multiprocessors SMs . Pipeline manager may also be configured to control a work distribution crossbar by specifying destinations for processed data output by SMs .

In one embodiment GPC includes a set of M of SMs where M 1. Also each SM includes a set of functional execution units not shown such as execution units and load store units. Processing operations specific to any of the functional execution units may be pipelined which enables a new instruction to be issued for execution before a previous instruction has completed execution. Any combination of functional execution units within a given SM may be provided. In various embodiments the functional execution units may be configured to support a variety of different operations including integer and floating point arithmetic e.g. addition and multiplication comparison operations Boolean operations AND OR XOR bit shifting and computation of various algebraic functions e.g. planar interpolation and trigonometric exponential and logarithmic functions etc. . Advantageously the same functional execution unit can be configured to perform different operations.

In operation each SM is configured to process one or more thread groups. As used herein a thread group or warp refers to a group of threads concurrently executing the same program on different input data with one thread of the group being assigned to a different execution unit within an SM . A thread group may include fewer threads than the number of execution units within the SM in which case some of the execution may be idle during cycles when that thread group is being processed. A thread group may also include more threads than the number of execution units within the SM in which case processing may occur over consecutive clock cycles. Since each SM can support up to G thread groups concurrently it follows that up to G M thread groups can be executing in GPC at any given time.

Additionally a plurality of related thread groups may be active in different phases of execution at the same time within an SM . This collection of thread groups is referred to herein as a cooperative thread array CTA or thread array. The size of a particular CTA is equal to m k where k is the number of concurrently executing threads in a thread group which is typically an integer multiple of the number of execution units within the SM and m is the number of thread groups simultaneously active within the SM .

Although not shown in each SM contains a level one L1 cache or uses space in a corresponding L1 cache outside of the SM to support among other things load and store operations performed by the execution units. Each SM also has access to level two L2 caches not shown that are shared among all GPCs in PPU . The L2 caches may be used to transfer data between threads. Finally SMs also have access to off chip global memory which may include PP memory and or system memory . It is to be understood that any memory external to PPU may be used as global memory. Additionally as shown in a level one point five L1.5 cache may be included within GPC and configured to receive and hold data requested from memory via memory interface by SM . Such data may include without limitation instructions uniform data and constant data. In embodiments having multiple SMs within GPC the SMs may beneficially share common instructions and data cached in L1.5 cache .

Each GPC may have an associated memory management unit MMU that is configured to map virtual addresses into physical addresses. In various embodiments MMU may reside either within GPC or within the memory interface . The MMU includes a set of page table entries PTEs used to map a virtual address to a physical address of a tile or memory page and optionally a cache line index. The MMU may include address translation lookaside buffers TLB or caches that may reside within SMs within one or more L1 caches or within GPC .

In graphics and compute applications GPC may be configured such that each SM is coupled to a texture unit for performing texture mapping operations such as determining texture sample positions reading texture data and filtering texture data.

In operation each SM transmits a processed task to work distribution crossbar in order to provide the processed task to another GPC for further processing or to store the processed task in an L2 cache not shown parallel processing memory or system memory via crossbar unit . In addition a pre raster operations preROP unit is configured to receive data from SM direct data to one or more raster operations ROP units within partition units perform optimizations for color blending organize pixel color data and perform address translations.

It will be appreciated that the core architecture described herein is illustrative and that variations and modifications are possible. Among other things any number of processing units such as SMs texture units or preROP units may be included within GPC . Further as described above in conjunction with PPU may include any number of GPCs that are configured to be functionally similar to one another so that execution behavior does not depend on which GPC receives a particular processing task. Further each GPC operates independently of the other GPCs in PPU to execute tasks for one or more application programs. In view of the foregoing persons of ordinary skill in the art will appreciate that the architecture described in in no way limits the scope of the present invention.

The PD collects vertex data associated with high order surfaces graphics primitives and the like from the front end and transmits the vertex data to the VAF .

The VAF retrieves vertex attributes associated with each of the incoming vertices from shared memory and stores the vertex data along with the associated vertex attributes into shared memory.

The VTG is a programmable execution unit that is configured to execute vertex shader programs tessellation programs and geometry programs. These programs process the vertex data and vertex attributes received from the VAF and produce graphics primitives as well as color values surface normal vectors and transparency values at each vertex for the graphics primitives for further processing within the graphics processing pipeline . Although not explicitly shown the VTG may include in some embodiments one or more of a vertex processing unit a tessellation initialization processing unit a task generation unit a task distributor a topology generation unit a tessellation processing unit and a geometry processing unit.

The vertex processing unit is a programmable execution unit that is configured to execute vertex shader programs lighting and transforming vertex data as specified by the vertex shader programs. For example the vertex processing unit may be programmed to transform the vertex data from an object based coordinate representation object space to an alternatively based coordinate system such as world space or normalized device coordinates NDC space. The vertex processing unit may read vertex data and vertex attributes that is stored in shared memory by the VAF and may process the vertex data and vertex attributes. The vertex processing unit stores processed vertices in shared memory.

The tessellation initialization processing unit is a programmable execution unit that is configured to execute tessellation initialization shader programs. The tessellation initialization processing unit processes vertices produced by the vertex processing unit and generates graphics primitives known as patches. The tessellation initialization processing unit also generates various patch attributes. The tessellation initialization processing unit then stores the patch data and patch attributes in shared memory. In some embodiments the tessellation initialization shader program may be called a hull shader or a tessellation control shader.

The task generation unit retrieves data and attributes for vertices and patches from shared memory. The task generation unit generates tasks for processing the vertices and patches for processing by later stages in the graphics processing pipeline .

The task distributor redistributes the tasks produced by the task generation unit. The tasks produced by the various instances of the vertex shader program and the tessellation initialization program may vary significantly between one graphics processing pipeline and another. The task distributor redistributes these tasks such that each graphics processing pipeline has approximately the same workload during later pipeline stages.

The topology generation unit retrieves tasks distributed by the task distributor. The topology generation unit indexes the vertices including vertices associated with patches and computes U V coordinates for tessellation vertices and the indices that connect the tessellated vertices to form graphics primitives. The topology generation unit then stores the indexed vertices in shared memory.

The tessellation processing unit is a programmable execution unit that is configured to execute tessellation shader programs. The tessellation processing unit reads input data from and writes output data to shared memory. This output data in shared memory is passed to the next shader stage the geometry processing unit as input data. In some embodiments the tessellation shader program may be called a domain shader or a tessellation evaluation shader.

The geometry processing unit is a programmable execution unit that is configured to execute geometry shader programs thereby transforming graphics primitives. Vertices are grouped to construct graphics primitives for processing where graphics primitives include triangles line segments points and the like. For example the geometry processing unit may be programmed to subdivide the graphics primitives into one or more new graphics primitives and calculate parameters such as plane equation coefficients that are used to rasterize the new graphics primitives.

The geometry processing unit transmits the parameters and vertices specifying new graphics primitives to the VPC . The geometry processing unit may read data that is stored in shared memory for use in processing the geometry data. The VPC performs clipping culling and viewport transform to determine which graphics primitives are potentially viewable in the final rendered image and which graphics primitives are not potentially viewable. The VPC then transmits processed graphics primitives and their associated bounding boxes to a bounding box BB unit . The bounding box unit combines the bounding boxes to generate one or more accumulated bounding boxes. The accumulated bounding boxes and graphics primitives are then transmitted to the tiling unit .

The tiling unit is a graphics primitive sorting engine that resides between a world space pipeline and a screen space pipeline as further described herein. Graphics primitives are processed in the world space pipeline and then transmitted to the tiling unit . The screen space is divided into cache tiles where each cache tile is associated with a portion of the screen space. For each graphics primitive the tiling unit identifies the set of cache tiles that intersect with the graphics primitive a process referred to herein as tiling. In order to determine the set of cache tiles that intersect a particular graphics primitive the tiling unit may use the associated bounding box and or accumulated bounding box received from the bounding box unit . After tiling a certain number of graphics primitives the tiling unit processes the graphics primitives on a cache tile basis where graphics primitives associated with a particular cache tile are transmitted to the setup unit . The tiling unit transmits graphics primitives to the setup unit one cache tile at a time. Graphics primitives that intersect with multiple cache tiles are typically processed once in the world space pipeline but are then transmitted multiple times to the screen space pipeline .

Such a technique improves cache memory locality during processing in the screen space pipeline where multiple memory operations associated with a first cache tile access a region of the L2 caches or any other technically feasible cache memory that may stay resident during screen space processing of the first cache tile. Once the graphics primitives associated with the first cache tile are processed by the screen space pipeline the portion of the L2 caches associated with the first cache tile may be flushed and the tiling unit may transmit graphics primitives associated with a second cache tile. Multiple memory operations associated with a second cache tile may then access the region of the L2 caches that may stay resident during screen space processing of the second cache tile. Accordingly the overall memory traffic to the L2 caches and to the render targets may be reduced. In some embodiments the world space computation is performed once for a given graphics primitive irrespective of the number of cache tiles in screen space that intersects with the graphics primitive.

The setup unit receives vertex data from the VPC via the tiling unit and calculates parameters associated with the graphics primitives including without limitation the color values surface normal vectors and transparency values at each vertex of the graphics primitive. The setup unit then transmits processed graphics primitives to rasterizer .

The rasterizer scan converts the new graphics primitives and transmits fragments and coverage data to the pixel shading unit . Additionally the rasterizer may be configured to perform z culling and other z based optimizations.

The pixel shading unit is a programmable execution unit that is configured to execute fragment shader programs transforming fragments received from the rasterizer as specified by the fragment shader programs. Fragment shader programs may shade fragments at pixel level granularity where such shader programs may be called pixel shader programs. Alternatively fragment shader programs may shade fragments at sample level granularity where each pixel includes multiple samples and each sample represents a portion of a pixel. Alternatively fragment shader programs may shade fragments at any other technically feasible granularity depending on the programmed sampling rate.

In various embodiments the fragment processing unit may be programmed to perform operations such as perspective correction texture mapping shading blending and the like to produce shaded fragments that are transmitted to the ROP . The pixel shading unit may read data that is stored in shared memory.

The ROP is a processing unit that performs raster operations such as stencil z test blending and the like and transmits pixel data as processed graphics data for storage in graphics memory via the memory interface where graphics memory is typically structured as one or more render targets. The processed graphics data may be stored in graphics memory parallel processing memory or system memory for display on display device or for further processing by CPU or parallel processing subsystem . In some embodiments the ROP is configured to compress z or color data that is written to memory and decompress z or color data that is read from memory. In various embodiments the ROP may be located in the memory interface in the GPCs in the processing cluster array outside of the GPCs or in a separate unit not shown within the PPUs .

The graphics processing pipeline may be implemented by any one or more processing elements within PPU . For example one of the SMs of could be configured to perform the functions of one or more of the VTG and the pixel shading unit . The functions of the PD the VAF the VPC the tiling unit the setup unit the rasterizer and the ROP may also be performed by processing elements within a particular GPC in conjunction with a corresponding partition unit . Alternatively graphics processing pipeline may be implemented using dedicated fixed function processing elements for one or more of the functions listed above. In various embodiments PPU may be configured to implement one or more graphics processing pipelines .

In some embodiments the graphics processing pipeline may be divided into a world space pipeline and a screen space pipeline . The world space pipeline processes graphics objects in 3D space where the position of each graphics object is known relative to other graphics objects and relative to a 3D coordinate system. The screen space pipeline processes graphics objects that have been projected from the 3D coordinate system onto a 2D planar surface representing the surface of the display device . For example the world space pipeline could include pipeline stages in the graphics processing pipeline from the PD through the VPC . The screen space pipeline could include pipeline stages in the graphics processing pipeline from the setup unit through the ROP . The tiling unit would follow the last stage of the world space pipeline namely the VPC . The tiling unit would precede the first stage of the screen space pipeline namely the setup unit .

In some embodiments the world space pipeline may be further divided into an alpha phase pipeline and a beta phase pipeline. For example the alpha phase pipeline could include pipeline stages in the graphics processing pipeline from the PD through the task generation unit. The beta phase pipeline could include pipeline stages in the graphics processing pipeline from the topology generation unit through the VPC . The graphics processing pipeline performs a first set of operations during processing in the alpha phase pipeline and a second set of operations during processing in the beta phase pipeline. As used herein a set of operations is defined as one or more instructions executed by a single thread by a thread group or by multiple thread groups acting in unison.

In a system with multiple graphics processing pipelines the vertex data and vertex attributes associated with a set of graphics objects may be divided so that each graphics processing pipeline has approximately the same amount of workload through the alpha phase. Alpha phase processing may significantly expand the amount of vertex data and vertex attributes such that the amount of vertex data and vertex attributes produced by the task generation unit is significantly larger than the amount of vertex data and vertex attributes processed by the PD and VAF . Further the task generation unit associated with one graphics processing pipeline may produce a significantly greater quantity of vertex data and vertex attributes than the task generation unit associated with another graphics processing pipeline even in cases where the two graphics processing pipelines process the same quantity of attributes at the beginning of the alpha phase pipeline. In such cases the task distributor redistributes the attributes produced by the alpha phase pipeline such that each graphics processing pipeline has approximately the same workload at the beginning of the beta phase pipeline.

Please note as used herein references to shared memory may include any one or more technically feasible memories including without limitation a local memory shared by one or more SMs or a memory accessible via the memory interface such as a cache memory parallel processing memory or system memory . Please also note as used herein references to cache memory may include any one or more technically feasible memories including without limitation an L1 cache an L1.5 cache and the L2 caches.

The screen space represents one or more memory buffers configured to store rendered image data and other data transmitted by functional units within the graphics processing pipeline . In some embodiments the one or more memory buffers may be configured as one or more render targets. The screen space represents a memory buffer configured to store the image rendered by the graphics processing pipeline. The screen space may be associated with any number of render targets where each render target may be configured independently of other render targets to include any number of fields. Each field within a render target may be configured independently of other fields to include any number of bits. Each render target may include multiple picture elements pixels and each pixel may in turn include multiple samples. In some embodiments the size of each cache tile may be based on the size and configuration of the render targets associated with the screen space. In operation once rendering completes the pixels in the one or more render targets may be transmitted to a display device in order to display the rendered image.

By way of example a set of render targets for the screen space could include eight render targets. The first render target could include four fields representing color including red green and blue component colors and transparency information associated with a corresponding fragment. The second render target could include two fields representing depth and stencil information associated with the corresponding fragment. The third render target could include three fields representing surface normal vector information including an x axis normal vector a y axis normal vector and a z axis normal vector associated with the corresponding fragment. The remaining five render targets could be configured to store additional information associated with the corresponding fragment. Such configurations could include storage for various information including without limitation 3D positional data diffuse lighting information and specular lighting information.

Each cache tile represents a portion of the screen space . For clarity only five cache tiles are shown in . In some embodiments cache tiles may have an arbitrary size in X and Y screen space. For example if a cache tile were to reside in a cache memory that also is used to store other data then the cache tile could be sized to consume only a specific portion of the cache memory. The size of a cache tile may be based on a number of factors including the quantity and configuration of the render targets associated with the screen space the quantity of samples per pixel and whether the data stored in the cache tile is compressed. As a general matter a cache tile is sized to increase the likelihood that the cache tile data remains resident in the cache memory until all graphics primitives associated with the cache tile are fully processed.

The raster tiles represent a portion of the cache tile . As shown the cache tile includes sixteen raster tiles arranged in an array that is four raster tiles wide and four raster tiles high. In systems that include multiple GPCs processing associated with a given cache tile may be divided among the available GPCs . In the example shown if the sixteen raster tiles of cache tile were processed by four different GPCs then each GPC could be assigned to process four of the sixteen raster tiles in the cache tile . Specifically the first GPC could be assigned to process raster tiles and . The second GPC could be assigned to process raster tiles and . The third GPC could be assigned to process raster tiles and . The fourth GPC would then be assigned to process raster tiles and . In other embodiments the processing of the different raster tiles within a given cache tile may be distributed among GPCs or any other processing entities included within computer system in any technically feasible manner.

During tiled rendering the tiling unit transmits graphics primitives associated with each cache tile to the setup unit for processing in the screen space pipeline . In order to determine whether a particular graphics primitive intersects a particular cache tile the tiling unit performs an intersection test between the cache tile and a bounding box associated with the graphics primitive. If the bounding box intersects the cache tile then the graphics primitive may intersect the cache tile and the graphics primitive is transmitted to the screen space pipeline for further processing. If the bounding box does not intersect the cache tile then the graphics primitive does not intersect the cache tile and the graphics primitive is not transmitted to the screen space pipeline .

The VPC generates a bounding box for each graphics primitive near the end of the world space pipeline . Accordingly instead of re computing a bounding box for each graphics primitive during tiled rendering bounding boxes generated in the world space pipeline may be transmitted from the VPC to the tiling unit via crossbar unit .

Each bounding box includes a substantial number of bits that specify the x y coordinates of the upper left corner upper right corner lower left corner and lower right corner of the bounding box. Consequently transmitting a bounding box through the crossbar unit for each graphics primitive sent to the screen space pipeline would significantly increase processing overhead. Additionally when processing associated with a given cache tile is divided among multiple GPCs each bounding box that intersects more than one raster tile may be transmitted over the crossbar unit multiple times further increasing processing overhead. As such when the bounding boxes are transmitted from the world space pipeline to the tiling unit a bounding box BB unit may generate one or more accumulated bounding boxes each of which is associated multiple graphics primitives. The accumulated bounding boxes are then transmitted to the tiling unit reducing the processing overhead associated with transmitting bounding boxes through the crossbar unit .

Determining whether to add a particular bounding box to an accumulated bounding box may be based on a variety of criteria. In one implementation determining whether to add a bounding box to an accumulated bounding box is based on whether the bounding box or the graphics primitive associated with bounding box is within a threshold distance of the accumulated bounding box. One such proximity based technique for generating accumulated bounding boxes is described below in conjunction with .

As shown a method begins at step where the bounding box unit receives a graphics primitive and or a bounding box associated with the graphics primitive from the VPC . At step the bounding box unit determines whether the graphics primitive is the first graphics primitive that has been received by the bounding box unit for the current tiled rendering pass. If the graphics primitive is the first graphics primitives received by the bounding box unit then at step a new accumulated bounding box is generated based on the bounding box associated with the graphics primitive. The method then proceeds to step where the bounding box unit determines whether additional graphics primitives and or bounding boxes are to be received. If additional graphics primitives and or bounding boxes are to be received then the method returns to step and the new accumulated bounding box is designated as the current accumulated bounding box.

If the graphics primitive is not the first graphics primitives received by the bounding box unit for the current set of graphics primitives then at step the bounding box unit next determines whether the current accumulated bounding box includes a maximum number of graphics primitives. The maximum number of graphics primitives included in a single accumulated bounding box can be any number. In one example the maximum number of graphics primitives included in a single accumulated bounding box is 8 graphics primitives. In other examples the maximum number of graphics primitives included in a single accumulated bounding box may be 16 or 32 graphics primitives. In general if too few graphics primitives are added to each accumulated bounding box then a greater number of bounding boxes are transferred through the crossbar unit thereby increasing processing overhead. However if too many graphics primitives are added to each accumulated bounding box then the accumulated bounding box may provide too coarse an estimation of which cache tiles are intersected by the graphics primitives included in the accumulated bounding box. In the latter case if the accumulated bounding box does not provide an accurate estimation of which cache tiles are intersected by the associated graphics primitives then the tiling unit may process the accumulated bounding box with respect to cache tiles that are not intersected by the graphics primitives thereby decreasing processing efficiency.

If the current accumulated bounding box includes the maximum number of graphics primitives then at step the bounding box unit transmits the current accumulated bounding box to the tiling unit via the crossbar unit . At step the bounding box unit generates a new accumulated bounding box based on the bounding box associated with the graphics primitive. However if the current accumulated bounding box does not include the maximum number of graphics primitives then at step the bounding box unit next determines whether the graphics primitive is within a threshold distance of the accumulated bounding box.

Turning now to an exemplary technique for determining whether a graphics primitive is within a threshold distance of an accumulated bounding box is provided. These figures are conceptual illustrations showing how an accumulated bounding box is generated according to one embodiment of the present invention. As shown in to determine whether graphics primitive is within a threshold distance of an accumulated bounding box the bounding box unit may increase one or more dimensions of the accumulated bounding box to generate an expanded bounding box . The bounding box unit then determines whether the graphics primitive or the bounding box associated with the graphics primitive intersects the expanded bounding box .

Expanding the accumulated bounding box to generate an expanded bounding box may include increasing one or more dimensions of the accumulated bounding box by a number of pixels. The one or more dimensions may be increased by any number of pixels. In one example the one or more dimensions may be increased by approximately 5 to 10 pixels. In another embodiment the accumulated bounding box may be expanded by increasing a dimension of the accumulated bounding box by a percentage. For example the width and or height of the accumulated bounding box may be expanded by 10 to generate the expanded bounding box .

If the graphics primitive is within the threshold distance of the accumulated bounding box e.g. by intersecting the expanded bounding box then contingent upon step the graphics primitive may be added to the accumulated bounding box at step to generate accumulated bounding box . For example as shown in the bounding box unit may perform additional expansion iterations to determine that graphics primitives and are within a threshold distance of the accumulated bounding box . If the graphics primitive was not within the threshold distance of the accumulated bounding box e.g. did not intersect the expanded bounding box then at step the bounding box unit would transmit the current accumulated bounding box to the tiling unit via the crossbar unit and at step would add the graphics primitive to a new accumulated bounding box.

In one implementation graphics primitives are added to each accumulated bounding box in an application programming interface API order. For example with reference to the API order of the graphics primitives may be and .

In other embodiments instead of determining whether a particular graphics primitive intersects an expanded bounding box the bounding box unit determines whether a distance between the accumulated bounding box and the graphics primitive s e.g. is less than a threshold value. Alternatively the bounding box unit may determine whether a distance between the accumulated bounding box and a bounding box associated with the graphics primitive e.g. is less than a threshold distance. In yet another embodiment the bounding box unit may determine whether the distance between two graphics primitives for example the distance between graphics primitive and graphics primitive is less than a threshold distance.

Returning now to the method of if the graphics primitive is within the threshold distance of the accumulated bounding box then at step optional the bounding box unit next determines whether the graphics primitive is included in the same cache tile s as the previous graphics primitive added to the current accumulated bounding box. If the graphics primitive is included in the same cache tile s as the previous graphics primitive then at step the bounding box unit adds the graphics primitive to the accumulated bounding box. If the graphics primitive is not included in the same cache tile s as the previous graphics primitive then at step the bounding box unit transmits the current accumulated bounding box to the tiling unit via the crossbar unit and at step adds the graphics primitive to a new accumulated bounding box. At step the bounding box unit determines whether additional graphics primitives are to be received. If additional graphics primitives are to be received by the bounding box unit then the method returns to step as previously described herein. If no additional graphics primitives are to be received by the bounding box unit then at step the bounding box unit transmits the current accumulated bounding box to the tiling unit via the crossbar unit and the method ends.

Determining whether a particular graphics primitive intersects the same cache tile s as the other graphics primitives included in an accumulated bounding box increases the likelihood that all graphics primitives included in an accumulated bounding box will be located in a similar region of the screen space . Consequently during tiled rendering of a particular cache each accumulated bounding box transmitted to the screen space pipeline is less likely to contain graphics primitives that do not intersect the cache tile thereby increasing processing efficiency. Further by performing step the bounding box unit may more effectively divide strips of closely spaced graphics primitives that may span multiple cache tiles between multiple accumulated bounding boxes such that the graphics primitives included in each accumulated bounding box are more closely associated with a single cache tile .

One example of the above technique is shown in which illustrate accumulated bounding boxes generated for a plurality of graphics primitives included in two cache tiles according to one embodiment of the present invention. As shown in a first plurality of graphics primitives have been added to a first accumulated bounding box a second plurality of graphics primitives have been added to a second accumulated bounding box and a third plurality of graphics primitives have been added to a third accumulated bounding box . As such the first plurality of graphics primitives are transmitted to the setup unit only when tiled rendering is performed with respect to cache tile and the third plurality of graphics primitives are transmitted to the setup unit only when tiled rendering is performed with respect to cache tile . Moreover the second plurality of graphics primitives are transmitted to the setup unit when tiled rendering is performed with respect to cache tile and cache tile . However none of the graphics primitives included in the third plurality of graphics primitives are transmitted to the setup unit when tiled rendering is performed with respect to cache tile and none of the graphics primitives included in the first plurality of graphics primitives are transmitted to the setup unit when tiled rendering is performed with respect to cache tile . Accordingly by determining whether each graphics primitive intersects the same cache tile s as the previous graphics primitive at step the efficiency with which each cache tile is processed may be increased.

After accumulated bounding boxes are generated by the bounding box unit each accumulated bounding box and the associated graphics primitives are transmitted to the tiling unit and stored in a buffer memory. Upon receiving each accumulated bounding box the tiling unit tracks which cache tile s are intersected by the accumulated bounding box and stores the result s in an array. The array is then referenced during tiled rendering of each cache tile enabling the tiling unit to quickly determine whether a particular cache tile is intersected by any of the accumulated bounding boxes and or graphics primitives currently stored in the buffer memory. If the array indicates that none of the accumulated bounding boxes stored in the buffer memory intersect a particular cache tile then none of the graphics primitives stored in the buffer memory intersect the cache tile i.e. the cache tile is empty and the cache tile can be skipped with respect to the current tiled rendering pass. Thus by skipping empty cache tiles during tiled rendering the processing overhead associated with determining whether each accumulated bounding box intersects the empty cache tiles is reduced. Various implementations of this technique are described below in further detail in conjunction with .

As shown a method begins at step where the tiling unit receives an accumulated bounding box from the bounding box unit . At step the tiling unit determines which cache tile s are intersected by the accumulated bounding box. The tiling unit then stores a result in an array based on each cache tile intersected by the accumulated bounding box. For example the tiling unit may determine that an accumulated bounding box intersects a plurality of cache tiles as shown in which is a conceptual illustration showing how to determine whether an accumulated bounding box intersects a cache tile according to one embodiment of the present invention. The tiling unit then stores one or more results in the array that indicate the 15 cache tiles intersected by the accumulated bounding box . Please note that in the sizes of the accumulated bounding boxes and the sizes of the graphics primitives relative to the size the cache tiles have been exaggerated for clarity of explanation.

The tiling unit may store results that indicate which cache tiles are intersected by accumulated bounding boxes in variety of ways. In one implementation each location in the array is associated with a single cache tile . In this implementation the tiling unit sets a bit in the array for each cache tile that is intersected by an accumulated bounding box stored in the buffer memory.

One potential obstacle to mapping each cache tile to a different location in the array is that if the screen space is divided into a large number of cache tiles such as at high display resolutions mapping each cache tile to a different location would require a prohibitively large array. To address this issue a single bit in the array may serve as an alias for more than one cache tile . For example if the screen space is divided into 128 72 cache tiles and the dimensions of the array are set at 64 32 bits then the tiling unit would store a result for the 65th cache tile in the same location in the array at which a result for the 1st cache tile would be stored. That is starting at the 65th tile the tiling unit would wrap around the array and start again at the first bit location. To further illustrate this technique the tiling unit would store a result for the 66th cache tile in the same location in the array at which a result for the 2nd cache tile would be stored store a result for the 67th cache tile in the same location in the array at which a result for the 3rd cache tile would be stored and so on. Additionally although each example provided above includes two cache tiles aliased to a single bit in the array three of more cache tiles may be aliased to a single bit. For example three cache tiles may be aliased to a single bit in the array such that a particular number of cache tiles is disposed between the first cache tile and the second cache tile and that particular number of cache tiles is disposed between the second cache tile and the third cache tile . Further the number of cache tiles disposed between the aliased cache tiles may be based on a dimension of the array.

The same wrapping technique may be applied when traversing the cache tiles in the vertical direction. For example starting at the 2049th cache tile i.e. the cache tile in the 33rd row 1st column the tiling unit would wrap around the array and start again at the first bit location. Thus the tiling unit would store a result for the 2049th cache tile in the same location in the array at which a result for the 1st cache tile would be stored. Although an array having 64 32 bits was used in the examples described above the tiling unit may use an array having any size and dimensions. Additionally the array may be implemented with or without cache tile aliasing.

One consequence of aliasing multiple cache tiles to a single location in the array is that when at least one but not all of the multiple cache tiles is intersected by an accumulated bounding box stored in the buffer memory then the tiling unit cannot determine which cache tiles are empty by referencing the array. Accordingly at step after storing a result for each cache tile intersected by the accumulated bounding box the tiling unit adds the accumulated bounding box to a global bounding box .

Turning now to an exemplary global bounding box is provided. is a conceptual illustration showing how a global bounding box is generated from the accumulated bounding boxes of according to one embodiment of the present invention. During tiled rendering if the array indicates that one or more accumulated bounding boxes stored in the buffer memory intersect a particular cache tile the tiling unit then further determines whether the global bounding box intersects the cache tile . As shown in if the global bounding box does not intersect the cache tile then the cache tile is empty. If the global bounding box intersects the cache tile then one or more accumulated bounding boxes stored in the buffer memory may or may not intersect the cache tile .

At step the tiling unit determines whether an additional accumulated bounding box has been received from the world space pipeline . If an additional accumulated bounding box has been received then steps and are repeated. If an additional accumulated bounding box is not received then the tiling unit begins the process of tiled rendering at step by identifying a cache tile for which the accumulated bounding boxes and graphics primitives currently stored in the buffer memory are to be processed.

Next at step the tiling unit determines whether a result is stored in the array indicating that the cache tile is intersected by an accumulated bounding box stored in the buffer memory. If the tiling unit determines that a result is not stored for the cache tile then the cache tile is empty and the cache tile is skipped with respect to the current tiled rendering pass. The tiling unit then proceeds to step and determines whether to identify an additional cache tile . If the tiling unit determines that a result is stored for the cache tile then if the array implements cache tile aliasing then at step the tiling unit further determines whether the global bounding box intersects the cache tile . If the global bounding box does not intersect the cache tile then the cache tile is empty and the cache tile is skipped with respect to the current tiled rendering pass. If the global bounding box intersects the cache tile then at step the tiling unit processes the cache tile . During processing of the cache tile the tiling unit may determine whether each accumulated bounding box stored in the buffer memory intersects the cache tile . The tiling unit may then send one or more graphics primitives associated with the accumulated bounding boxes that intersect the cache tile to the screen space pipeline as described below in further detail with respect to .

Finally at step the tiling unit determines whether to identify an additional cache tile . If an additional cache tile is to be identified then the tiling unit returns to step . If no additional cache tiles are to be identified then the method ends. Additionally after each cache tile has been processed with respect to the current tiled rendering pass the results stored in the array may be cleared and at step the next batch of accumulated bounding boxes and graphics primitives may be received by the tiling unit and stored in the buffer memory.

During tiled rendering the tiling unit determines whether each accumulated bounding box stored in the buffer memory intersects a particular cache tile . If the accumulated bounding box intersects the cache tile then the graphics primitives associated with the accumulated bounding box are transmitted to the screen space pipeline for further processing. However since the buffer memory may store a large number of accumulated bounding boxes determining whether each accumulated bounding box stored in the buffer memory intersects each cache tile may significantly increase processing overhead. Accordingly upon receiving accumulated bounding boxes from the world space pipeline e.g. at step in the method of the the tiling unit may combine the accumulated bounding boxes to generate one or more coarse bounding boxes. Then during tiled rendering instead of determining whether each accumulated bounding box stored in the buffer memory intersects a particular cache tile the tiling unit first determines whether each coarse bounding box intersects the cache tile . That is if the tiling unit determines that a coarse bounding box intersects the cache tile then tiling unit further determines whether the accumulated bounding boxes associated with the coarse bounding box intersect the cache tile . On the other hand if the tiling unit determines that a coarse bounding box does not intersect the cache tile then the accumulated bounding boxes associated with the coarse bounding box are skipped as described below in further detail in conjunction with .

As shown a method begins at step where the tiling unit combines multiple accumulated bounding boxes to generate one or more coarse bounding boxes. Each coarse bounding box may include bounding box coordinates one or more indices to the accumulated bounding boxes and or graphics primitives associated with the coarse bounding box a count of the number of accumulated bounding boxes associated with the coarse bounding box and or a count of the number of graphics primitives associated with the coarse bounding box. Accumulated bounding boxes may be combined in the order that they are received from the bounding box unit . Additionally when the bounding box unit adds graphics primitives to each accumulated bounding box according to an API order the coarse bounding box generated from the accumulated bounding boxes also may include graphics primitives stored in the API order.

In general any number of accumulated bounding boxes may be combined to generate each coarse bounding box. In one implementation each coarse bounding box may include approximately 128 graphics primitives. Thus if it is assumed that each accumulated bounding box includes approximately eight graphics primitives then approximately 16 accumulated bounding boxes would be combined to generate each coarse bounding box. One example of this type of bounding box hierarchy is shown in which is a conceptual illustration showing the relationship between a coarse bounding box and multiple accumulated bounding boxes according to one embodiment of the present invention.

Coarse bounding boxes may be generated by combining accumulated bounding boxes until the coarse bounding box includes a threshold number of graphics primitives e.g. 128 graphics primitives . In another implementation accumulated bounding boxes are combined until the resulting coarse bounding box includes a threshold number of accumulated bounding boxes e.g. 16 accumulated bounding boxes . In still other implementations coarse bounding boxes may be generated by combining accumulated bounding boxes based on a heuristic or algorithm.

After generating one or more coarse bounding boxes at step the tiling unit identifies a cache tile at step . At step the tiling unit then determines whether a coarse bounding box intersects the cache tile . If the coarse bounding box does not intersect the cache tile then none of the accumulated bounding boxes associated with the coarse bounding box intersects the cache tile . As a result no further processing of the accumulated bounding boxes is performed with respect to the cache tile . At step the tiling unit then determines whether to process an additional coarse bounding box.

If the coarse bounding box intersects the cache tile then at step the tiling unit further determines whether each accumulated bounding box associated with the coarse bounding box intersects the cache tile . In order to determine which accumulated bounding boxes are associated with the coarse bounding box the tiling unit may reference an index stored in the coarse bounding box. Coarse bounding boxes and accumulated bounding boxes may be evaluated to determine whether the bounding boxes intersect the current cache tile using a brute force method. For example the tiling unit may evaluate four coarse bounding boxes per cycle and or four accumulated bounding boxes per cycle. If none of the accumulated bounding boxes intersects the cache tile then at step the tiling unit determines whether to process an additional coarse bounding box.

If one or more accumulated bounding boxes included in the coarse bounding box intersect the cache tile then at step the tiling unit generates a scissor rectangle. At step the tiling unit determines whether each graphics primitive associated with the one or more accumulated bounding boxes i.e. the accumulated bounding boxes that intersect the cache tile intersect the scissor rectangle. In order to determine which graphics primitives are associated with a particular accumulated bounding box the tiling unit may retrieve the index and the count stored in the accumulated bounding box and or coarse bounding box. The tiling unit may then retrieve the count of consecutive graphics primitives from the buffer memory starting at the index. Any graphics primitives that intersect the scissor rectangle are then transmitted to the screen space pipeline for further processing at step . If none of the graphics primitives intersect the scissor rectangle then at step the tiling unit next determines whether to process an additional coarse bounding box.

Next at step the tiling unit determines whether to process an additional cache tile . If an additional cache tile is to be processed then the method returns to step . If no additional cache tiles are to be processed then at step the tiling unit determines whether additional coarse bounding boxes are to be generated. If additional coarse bounding boxes are to be generated then the method returns to step . If no additional coarse bounding boxes are to be generated then the method ends.

In sum various techniques are disclosed for generating bounding boxes and performing tiling in a graphics processing system. In a technique for reducing the amount of data transmitted across the crossbar a bounding box unit receives graphics primitives and determines whether to add each graphics primitive to an accumulated bounding box based on whether the graphics primitive is within a threshold distance of the accumulated bounding box. If the graphics primitive is not within a threshold distance of the accumulated bounding box then the graphics primitive is added to a new accumulated bounding box and the accumulated bounding box is transmitted across the crossbar. Further if the graphics primitive is included in one or more different cache tiles than the previous graphics primitive then the graphics primitive may be added to a new accumulated bounding box and the accumulated bounding box may be transmitted across the crossbar.

Further in a technique for tracking whether a particular cache tile likely includes graphics primitives an accumulated bounding box is received from the world space pipeline and the tiling unit determines which cache tiles are intersected by the accumulated bounding box and stores the results in an array. By tracking which cache tiles are intersected by each incoming accumulated bounding box cache tiles that do not include any graphics primitives may be skipped during subsequent rendering. The tiling unit may further combine the accumulated bounding boxes currently stored in the buffer memory to generate a global bounding box that may be referenced to verify whether any graphics primitives likely intersect the cache tile.

Finally in a technique for reducing the number of intersection tests performed for a particular cache tile accumulated bounding boxes received by the tiling unit are combined to generate coarse bounding boxes. During tiled rendering the tiling unit then determines whether each coarse bounding box intersects the current cache tile. If a coarse bounding box intersects the current cache tile then the tiling unit determines whether each accumulated bounding box included in the coarse bounding box intersects the cache tile. If an accumulated bounding box intersects the current cache tile then the graphics primitives associated with the accumulated bounding box are transmitted for further processing.

One advantage of the disclosed technique is that the number of bounding boxes transferred across the crossbar is reduced decreasing processing overhead. Additionally bounding boxes may be accumulated such that the graphics primitives assigned to each bounding box are associated with the same cache tiles enabling the bounding boxes to be more efficiently processed in the screen space pipeline s .

One embodiment of the invention may be implemented as a program product for use with a computer system. The program s of the program product define functions of the embodiments including the methods described herein and can be contained on a variety of computer readable storage media. Illustrative computer readable storage media include but are not limited to i non writable storage media e.g. read only memory devices within a computer such as compact disc read only memory CD ROM disks readable by a CD ROM drive flash memory read only memory ROM chips or any type of solid state non volatile semiconductor memory on which information is permanently stored and ii writable storage media e.g. floppy disks within a diskette drive or hard disk drive or any type of solid state random access semiconductor memory on which alterable information is stored.

The invention has been described above with reference to specific embodiments. Persons of ordinary skill in the art however will understand that various modifications and changes may be made thereto without departing from the broader spirit and scope of the invention as set forth in the appended claims. The foregoing description and drawings are accordingly to be regarded in an illustrative rather than a restrictive sense.

