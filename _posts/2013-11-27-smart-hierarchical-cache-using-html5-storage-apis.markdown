---

title: Smart hierarchical cache using HTML5 storage APIs
abstract: A method of caching resources corresponding to a webpage on a client is disclosed. A hierarchy of a plurality of storage mechanisms available on the client is determined based at least in part on performance of the plurality of storage mechanisms. The hierarchy comprises a plurality of levels to which each storage mechanism may be assigned. A request to cache a first resource corresponding to a webpage is received. One of the plurality of storage mechanisms for caching the first resource is selected based at least in part on the hierarchy. The first resource is stored in the selected storage mechanism of the hierarchy.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09531829&OS=09531829&RS=09531829
owner: Instart Logic, Inc.
number: 09531829
owner_city: Palo Alto
owner_country: US
publication_date: 20131127
---
This application claims priority to U.S. Provisional Patent Application No. 61 898 766 entitled HCACHE A SMART HIERARCHICAL CACHE USING HTML5 STORAGE APIS filed Nov. 1 2013 which is incorporated herein by reference for all purposes.

Typically a web browser needs to receive dependent resources associated with different links and URLs Uniform Resource Locators before it can complete the rendering of a webpage. Efficient delivery of these dependent resources can significantly improve the end user experience. Therefore improved techniques for delivering different types of resources corresponding to a webpage would be desirable.

The invention can be implemented in numerous ways including as a process an apparatus a system a composition of matter a computer program product embodied on a computer readable storage medium and or a processor such as a processor configured to execute instructions stored on and or provided by a memory coupled to the processor. In this specification these implementations or any other form that the invention may take may be referred to as techniques. In general the order of the steps of disclosed processes may be altered within the scope of the invention. Unless stated otherwise a component such as a processor or a memory described as being configured to perform a task may be implemented as a general component that is temporarily configured to perform the task at a given time or a specific component that is manufactured to perform the task. As used herein the term processor refers to one or more devices circuits and or processing cores configured to process data such as computer program instructions.

A detailed description of one or more embodiments of the invention is provided below along with accompanying figures that illustrate the principles of the invention. The invention is described in connection with such embodiments but the invention is not limited to any embodiment. The scope of the invention is limited only by the claims and the invention encompasses numerous alternatives modifications and equivalents. Numerous specific details are set forth in the following description in order to provide a thorough understanding of the invention. These details are provided for the purpose of example and the invention may be practiced according to the claims without some or all of these specific details. For the purpose of clarity technical material that is known in the technical fields related to the invention has not been described in detail so that the invention is not unnecessarily obscured.

When a web browser starts loading an HTML HyperText Markup Language webpage the web browser parses the webpage and discovers dependent resources e.g. JavaScript files images videos audio clips and CSS Cascading Style Sheets files that need to be separately downloaded and processed. For each resource the web browser contacts a server downloads the content over the network and processes it locally on the client side.

Typically a user may visit the same webpage at different times or visit a sequence of pages that share one or more resources. A caching mechanism can temporarily store some of these resources and reduce the bandwidth usage server load and user perceived delay. The cache may be located anywhere between the origin server and the target client. For example a cache on the web server can reduce the computation overhead for generating the same webpage for multiple users. A cache on a Content Delivery Network CDN node can cache the resources as close as possible to the users and thus reduces the origin server load as well as the round trip delay for receiving each resource on the client. A client side cache e.g. a browser cache can store a resource on the client and avoid downloading the resource if the resource is still valid.

However client side caching using a browser cache has a number of drawbacks. A browser cache was designed to optimize network bandwidth rather than latency. Bandwidth optimization is suitable for fairly static webpages because the goal is to show all of the content of a webpage as soon as possible. However as the amount of content in webpages increases and as interactivity becomes more important in modern web applications latency optimization becomes more important.

The cache performance for some types of resources may impact the overall performance more than for other types of resources and thus the cache performance for some resources might be more important than for others. For example their respective importance may depend on the composition of the webpages. However existing browser caches may offer suboptimal performance and no application control. In addition existing cache control mechanisms offer little to no flexibility in cache usage.

Browser caches are not the most efficient storage mechanisms to handle certain workloads on certain user clients e.g. browsers and devices . When handling different workloads on different user clients various alternative storage mechanisms e.g. localStorage sessionStorage and indexDB available in HTML5 have wide ranges of storage access time and performance. Some of the alternative storage mechanisms e.g. localStorage and sessionStorage can be shown to be consistently and significantly one to two orders of magnitude faster than browser caches. In addition unlike the browser cache which is shared across domains some of the storage mechanisms are per domain thus improving both the performance and security of the web applications. Accordingly a hierarchical client side cache referred to as the HCache can be used to leverage the different alternative storage mechanisms as backends to replace or augment the browser caches in a hierarchical fashion such that the webpage load latency can be reduced significantly. In some embodiments the HCache can be accessed via a set of APIs Application Programming Interfaces . The APIs allow web application developers to intelligently control how the alternative storage mechanisms are used.

Current browser and browser cache implementations also have many limitations that impact the cache hit ratio for critical resources. Cache hit ratio is affected by the eviction policy. After downloading a particular resource the web browser needs to decide whether to cache the resource or not and whether some other resources need to be evicted from the cache. In current cache implementations the browser and the server negotiate caching capability and content validity without providing any control to the applications and yet the impact of resource caching on the user experience is dependent on how the application uses the resource. In addition the applications have no control over the cache load store and network requests. Therefore the applications cannot guide the browser cache behavior in order to reduce latency and improve user experience. Cache hits are also reduced when the browser cache is shared across domains especially when some applications store undue amounts of data. The HCache provides the applications the necessary control over the cache behavior in order to reduce application load latency including enabling the applications to make tailored choices about the importance of resources e.g. those retrieved from third party servers relative to application owned resources in relation to page load performance.

The HCache determines the performance of different storage mechanisms. In some embodiments the performance results are used to determine how the alternative storage mechanisms are utilized to replace or augment the browser caches under different conditions including the types of storage mechanisms used for storing different types of resource the order hierarchy in which the different types of storage mechanisms are filled given the type of browser and the type of device that the browser is running on and the like.

As an illustrative example the performance of the storage mechanisms available in HTML5 are determined below. However the performance of other storage mechanisms may be determined and other embodiments for determining the performance data may be used as well.

Table 1 illustrates the attributes of a plurality of HTML5 storage mechanisms for storing data on the client. Unlike the browser cache which is shared across domains the alternative storage mechanisms in Table 1 are separated from each other based on the domain name of the web application. In other words the alternative storage mechanisms in Table 1 are private storages that are not shared between different web applications. Therefore the web application need not handle the side effects of other applications on these storages.

With reference to Table 1 localStorage has a size limit of 5 megabytes per domain. It stores the data with no expiration date the data will not be deleted when the browser is closed. The APIs of localStorage are synchronous thus the calling thread for retrieving and returning the data is blocked in the browser until the data is ready. The data is stored in key value pairs. SessionStorage is identical to localStorage except that it stores the data for only one browsing session i.e. when an user opens a website and visits one or more pages in that website. The data is deleted when the user closes the browser window.

Unlike localStorage and sessionStorage indexDB fileSystem and browser cache do not have a size limit of 5 megabytes per domain. The symbol in the capacity column of Table 1 denotes that the capacity depends on the device capacity. The APIs for indexDB fileSystem and browser cache are asynchronous the calling thread for retrieving and returning the data is not blocked in the browser until the data is ready instead a callback function is called when the data is ready.

The storage mechanisms in Table 1 are supported by most web browsers including Chrome Firefox and Safari. Currently fileSystem storage is only supported by Chrome.

As compared to the alternative storage mechanisms in Table 1 the browser cache is not the most reliable storage for web applications. The browser cache is a transparent storage that may be used when a resource is requested via an URL. The persistence of the data is non deterministic and depends on the user activity and the amount of cachable content that other web sites and web applications may download.

With the exception of the browser cache all of the alternative storage mechanisms in Table 1 offer full control over the content of the storage including support for operations such as adding removing enumerating and the like.

In some embodiments the performance of various storage mechanisms is determined by measuring the load store time for different object sizes on different browsers devices and operating systems OSs . Table 2 illustrates a plurality of combinations of browsers devices and operating systems that can be used for determining the performance of the various storage mechanisms.

As described above the APIs for indexDB fileSystem and browser cache are asynchronous. Since the implementation of asynchronous API calls may pipeline the operations for better performance the performance of the storage mechanisms is measured when 1 the APIs are called asynchronously and 2 when the API calls are serialized. In the asynchronous case when the load store operation is issued the callback function is received independently. In the serialized case each load store operation is serialized after the callback function of the previous load store operation is received. In both cases i.e. the asynchronous case and the serialized case a timer is started when the load store request is issued and the time elapsed since the last callback function is called is measured. In the asynchronous case the requests are issued together and the callbacks may be called at any time afterwards. In the serialized case the requests and callbacks are interleaved.

The performance of the browser cache may be measured using two different approaches. The performance is evaluated indirectly because the browser cache does not offer any direct API calls see Table 1 . In the first approach an XMLHttpRequest XHR object is used to repeatedly fetch a cacheable object of a given size. After the object has been fetched once subsequent requests will obtain the object from the browser cache. In the second approach image objects IMGs are used to download images. The image requests are sent to the browser cache first and upon a cache miss the requests are sent out to the network. The source attribute of an image object is set to an URL. Identical to the first approach after an image object has been fetched once subsequent requests will obtain the image object from the browser cache.

The performance of each of the storage mechanisms in Table 1 may be measured by loading a test webpage. The test webpage includes a simple JavaScript program that first fetches N objects e.g. N 100 of the same size and stores them using a given HTML5 storage. The JavaScript program then loads the objects back. Both the load and the store time are measured using different combinations of browsers devices and operating systems as shown in Table 2. The object sizes may range from 100 bytes to 1 megabytes.

With reference to localStorage and sessionStorage perform significantly e.g. 10 100 orders of magnitude better than other storage mechanisms on all devices and platforms even though the performance gap for the storage mechanisms narrows for larger objects. In addition the asynchronous versions of the APIs perform better than their serialized versions. IndexDB performs two times better than XHR using Chrome on an Android smartphone. However the two perform similarly using Chrome on a laptop computer. FileSystem performs worse than other storage mechanisms but it is likely to outperform network access in most cases. As shown in the above figures the performance of different storage mechanisms may vary over time as the web browsers the devices and the operating systems continue to evolve and as new platforms become available. Accordingly the HCache may continuously determine the performance of different storage mechanisms on different platforms and under different conditions such that the HCache can leverage the various storage mechanisms more effectively.

In some embodiments the HCache is implemented as a JavaScript object and the HCache JavaScript object is instantiated at the beginning of a webpage load. The instantiation of the HCache includes determining the types of storage mechanisms available. The instantiation further includes using the performance and capacity information of different storage mechanisms to determine how the storage mechanisms are utilized to replace or augment the browser caches under different conditions including the types of storage mechanisms used for storing different types of resource the order hierarchy in which the different types of storage mechanisms are filled given the type of browser and the type of device that the browser is running on and the like.

For example the performance data as shown in may be used to determine the cache hierarchy when the platform is a Chrome browser running on a laptop computer as follows. For object sizes less than 100 kB the cache hierarchy from highest priority most preferred to lowest priority least preferred may be set as localStorage sessionStorage indexDB and fileSystem. For object sizes of 1000 kB fileSystem performs better than indexDB. Thus the hierarchy may be set as localStorage sessionStorage fileSystem and indexDB.

In another example the performance data as shown in may be used to determine the cache hierarchy when the platform is a Chrome browser running on an Android smartphone. Since fileSystem performs better than indexDB for all object sizes the cache hierarchy from highest priority most preferred to lowest priority least preferred may be set as localStorage sessionStorage fileSystem and indexDB.

As shown in the HCache includes a number of modules. Module is a module for storing the cached resources and their corresponding metadata. This module maps opaque keys to JavaScript objects for storing the cached value. Each of the cached object is associated with a corresponding set of metadata for managing cache expiry validation and eviction. Module is a policy module for determining the storage hierarchy and object eviction policies. Module is a storage backends module. This module encapsulates the different types of storage mechanisms available to a web application and handles the serialization and deserialization of the cached value into a format that is suitable for a given storage mechanism. The module further includes an in memory cache above the storage backends. The in memory cache is used to store cached values that are most frequently used.

A cached resource is stored as an object in the HCache. Each object is a tuple of metadata with a value. The metadata includes three sets of properties. One set of properties includes application dependent properties such as the priority which is used by the eviction algorithm to determine which object to evict when the storage backends are full. Another set of properties includes content dependent properties such as the size of the object e.g. in bytes and MIME types internet media types . Another set of properties includes server dependent properties such as expiry and validity. The expiry and validity fields may be used to implement HTTP Hypertext Transfer Protocol expiry and revalidation semantics.

The HCache includes a number of APIs. Table 3 illustrates three APIs provided by the HCache. The new API instantiates and initiates the HCache. The get API is used to load objects from the cache. The put API is used to store objects into the cache. The put API may also evict objects from a storage mechanism when the capacity of that storage mechanism has reached its limit. In some embodiments the put operations may be queued until the webpage is loaded i.e. after the window.onload event has fired . Both the get and the put APIs may be implemented as asynchronous JavaScript functions such that the result of each operation is passed to a callback rather than being returned at function exit.

The HCache can be used directly by a web developer of a web application. The HCache can be used to load resources explicitly and asynchronously. The HCache can also be used to load images dynamically.

The HCache may be used to load resources explicitly and asynchronously. For example the HCache APIs may be used to replace the functionalities related to a XHR request. XMLHttpRequest XHR is an API available to web browser scripting languages such as JavaScript. It is used to send HTTP or HTTPS Hypertext Transfer Procotol Secure requests to a web server and asynchronously load the server response data back into the script. In one example a web developer may continue to use most of the methods of the XHR request but replace the methods of the window.XMLHttpRequest object with a set of methods that first call the HCache get API. If the requested resource is not stored in the HCache the get API may sequentially pass the request onto the browser cache network stack. If an object is fetched from the browser cache or through the network the callback response may be intercepted by the HCache such that the fetched object may be stored into the HCache via the put API. The intercepted response may also be used to set the expiry information included in the metadata associated with the cached object. For example XHRresponseHeader may be used to retrieve the Cache Control and Expires headers from the response and they can be used to set the metadata of the cached object.

The HCache can also be used to load images dynamically. illustrates an embodiment of a piece of JavaScript code that has been modified to use the HCache to load images dynamically. In the absence of the HCache when the DOM Document Object Model property is set img.src img.jpg the web browser schedules a network request for the image resource and the image resource is fetched asynchronously in the background. With the HCache employed the code img.src img.jpg is commented out and replaced by calling the HCache get API. As shown in a small stub function is used to set the appropriate DOM element when the object is loaded by the HCache.

The HCache can also be used by a proxy server e.g. an Instart edge server that serves webpages and other resources to a web browser. The proxy server injects code also referred to as a nanovisor that virtualizes the Document Object Model DOM tree. DOM is a standardized model supported by different web browsers e.g. Internet Explorer Firefox and Google Chrome to represent the various components of a webpage. The DOM is a cross platform and language independent convention for representing and interacting with objects in HTML documents as well as XHTML and XML documents. Objects in a DOM tree may be addressed and manipulated using methods on the objects. The public interface of a DOM is specified in its application programming interfaces APIs . Because the DOM objects are virtualized access to the objects may be intercepted by the nanovisor which in turn may access the objects via HCache.

The HCache may also include configurable parameters and policy. For example these configurable parameters and policy may be specified by the developer.

The in memory cache may be specified as a storage for certain cached objects. The in memory cache is used to store cached values that are most frequently used. Therefore if a webpage refers to certain objects multiple times the developer may specify that these objects be written to in memory cache only.

In some embodiments the put operations are queued and delayed until the performance critical portion of the load operation has been completed i.e. after the window.onload event has fired . The order in which the queued objects are stored into the HCache may be determined by a policy e.g. based on the size of the objects configured by the developer. In one example the policy specifies that the objects are written to the HCache in the order that they are loaded in the webpage. In another example the policy specifies that the objects are sorted by size in descending order and that higher priority is given to larger objects the rationale is that larger objects may impact the onload time more thus fast loading of these objects can lead to improvement in onload time. By specifying higher priority for larger objects the HCache stores the larger objects using faster storage mechanisms. In another example the policy specifies that the objects are sorted by size in ascending order and that higher priority is given to smaller objects. In this instance the rationale is that smaller objects are likely to be present across related webpages and that by ensuring that these objects get served from HCache the developer can optimize across multiple webpages.

In some embodiments the loading priority assigned to different objects is configurable. When a webpage is visited again the objects are loaded from the HCache. By assigning appropriate priority values to various objects the developers can control the order in which objects are loaded.

In some embodiments the HCache is configurable to store multiple versions of a cached object and the different versions of the cached object may be loaded at different times. For example before the onload event the HCache can be used to load lower resolution images for faster loading while after the onload event is fired high resolution images can be loaded.

In some embodiments the HCache further includes enhanced cache control mechanisms that improve the performance of HTTP liveness determination. A cached HTTP object can be in one of two liveness states fresh or stale. A fresh object can be used immediately without contacting the remote server. A stale object requires a revalidation round trip before the object can be used. The stale object latency penalty can be further compounded by dependencies between objects e.g. objects that are dynamically loaded via JavaScript. The HCache may provide prefetch revalidation lazy revalidation and aggregate revalidation.

In prefetch revalidation upon the initial load of the webpage the server may send validation information for objects that are likely to be in the client HCache. This technique can reduce the number of subsequent revalidation messages.

In lazy revalidation the HCache shifts the liveness determination from the critical path to the background i.e. objects in the HCache are not validated during webpage load. Instead objects in the HCache that are not yet stale can be revalidated after the initial load of the objects without impacting the performance of the page. Further these objects can be revalidated only when they are close to expiry deadline.

In aggregate revalidation revalidation request messages for objects stored in the HCache are batched together and sent as a single message to the server thus saving round trip time between the client and the server.

Although the foregoing embodiments have been described in some detail for purposes of clarity of understanding the invention is not limited to the details provided. There are many alternative ways of implementing the invention. The disclosed embodiments are illustrative and not restrictive.

