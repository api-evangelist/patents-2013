---

title: Identifying implicit assumptions associated with a software product
abstract: A framework is described herein for identifying implicit assumptions associated with an SDK and its accompanying documentation (e.g., dev guide). An implicit assumption is information that is not expressly stated in the documentation, but which would be useful in assisting an application developer in building an application. The framework also describes a systematic approach for identifying one or more vulnerability patterns based on the identified implicit assumptions. An application developer may run a test on an application that is being developed to ensure that it does not have any deficiency which matches a vulnerability pattern.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09372785&OS=09372785&RS=09372785
owner: Microsoft Technology Licensing, LLC
number: 09372785
owner_city: Redmond
owner_country: US
publication_date: 20130307
---
An application developer may build an application that relies on a software development kit SDK . The application developer may also consult a developer guide simply guide herein in building the application. The guide provides information regarding the recommended use of the SDK. The guide is typically produced in an ad hoc manner e.g. based on an informal assessment of the informational needs of the application developer.

An application developer may produce a faulty application when he or she fails to follow the instructions provided in the guide. This is to be expected. In other cases a developer may precisely follow the instructions of the guide yet still produce a faulty application.

A software development environment is described herein which includes an analysis module and a test suite production module. The analysis module analyzes a software product e.g. an SDK in conjunction with documentation e.g. a dev guide that describes a recommended use of the software product. This analysis can be used to identify at least one implicit assumption associated with the software product and the documentation. An implicit assumption corresponds to information that a would be useful to the application developer in building an application that satisfies a stated objective and b is not explicitly stated in the documentation. In one case the stated objective is a security related objective associated with a software product that performs an authentication and or authorization operation.

The test suit production module produces a test suite that is made up of one or more vulnerability patterns. Each vulnerability pattern corresponds to an implied assumption identified by the analysis module. The application developer can test his or her application against each vulnerability pattern. This will reveal whether the application suffers from a vulnerability that is associated with the vulnerability pattern. The application developer can then modify the application in an appropriate manner to remove the vulnerability if deemed appropriate.

Overall the functionality described herein provides a reasoned and structured way of identifying useful information that is missing from a dev guide and or an SDK s implementation. This facilitates the design process and yields more robust applications.

The above approach can be manifested in various types of systems components methods computer readable storage media data structures articles of manufacture and so on.

This Summary is provided to introduce a selection of concepts in a simplified form these concepts are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used to limit the scope of the claimed subject matter.

The same numbers are used throughout the disclosure and figures to reference like components and features. Series numbers refer to features originally found in series numbers refer to features originally found in series numbers refer to features originally found in and so on.

This disclosure is organized as follows. Section A provides an overview of functionality for identifying and acting on implicit assumptions associated with a software development kit SDK . The functionality includes an SDK development environment and an application development environment. Section B provides additional details regarding the SDK development environment. Section C provides additional details regarding the application development environment. Section D describes illustrative computing functionality that can be used to implement any aspect of the features described in the foregoing sections.

Some of the figures describe concepts in the context of one or more physical components variously referred to as components functionality modules features elements mechanisms etc. An actual implementation may organize the physical components shown in the figures in any manner. For example in one case there may be a one to one correspondence between a component shown in the figures and an actual physical mechanism. Alternatively or in addition any single component illustrated in the figures may be implemented by plural physical mechanisms. Alternatively or in addition any two or more separate components in the figures may reflect different functions performed by a single actual physical mechanism.

Other figures describe the concepts in flowchart form. In this form certain operations are described as constituting distinct blocks performed in a certain order. Such implementations are illustrative and non limiting. Certain blocks described herein can be grouped together and performed in a single operation certain blocks can be broken apart into plural component blocks and certain blocks can be performed in an order that differs from that which is illustrated herein including a parallel manner of performing the blocks .

The various components and flowchart blocks can be implemented in any manner by any physical and tangible mechanisms for instance by physical mechanisms running and or storing any kind of software instructions by hardware components e.g. chip implemented logic functionality etc. and or any combination thereof. to be described in turn provides additional details regarding one illustrative physical implementation of the components shown in the figures.

As to terminology the phrase configured to encompasses any way that any kind of physical and tangible functionality can be constructed to perform an identified operation. The term logic encompasses any physical and tangible functionality for performing a task. For instance each operation illustrated in the flowcharts corresponds to a logic component for performing that operation. When implemented by a computing system a logic component represents an electrical component that is a physical part of the computing system however implemented.

The phrase means for in the claims if used is intended to invoke the provisions of 35 U.S.C. 112 sixth paragraph. No other language other than this specific phrase is intended to invoke the provisions of that portion of the statute.

The following explanation may identify one or more features as optional. This type of statement is not to be interpreted as an exhaustive indication of features that may be considered optional that is other features can be considered as optional although not expressly identified in the text. Finally the terms exemplary or illustrative refer to one implementation among potentially many implementations.

An application developer may build an application that relies on the SDK in any way. For instance without limitation the application can use the SDK to provide one or more functions of any nature. In a more specific case the application can use the SDK to interact with an independent system which provides one or more functions. In that non limiting scenario the SDK may correspond to one or more application programming interfaces APIs for instance .

The application developer may receive the SDK together with documentation referred to as a dev guide herein or simply guide for brevity . The guide provides information that assists an application developer in using the SDK. For example the guide may include instructions expressed in a natural language that explain the operations performed by the SDK and the manner in which an application developer may integrate the SDK into an application under development. Alternatively or in addition the guide may include code examples which explain the operation and use of the SDK. In one case the entity which produces the SDK referred to herein as the SDK developer also produces the guide. The SDK developer can express the guide in any form or combination of forms such as printed material electronic content and so on.

The guide may be conceptualized as containing explicitly stated information . Further the SDK and the guide may be associated with zero one or more implied assumptions . As the name suggests the explicitly stated information provides instructions that are clear and explicit on their face. By contrast each implied assumption corresponds to information that a is not explicitly stated in the guide and b is useful or necessary to an application developer in properly using the SDK. In some cases an application developer is given no clear statement or instruction by the guide as to the existence of the implied assumptions . This may cause many application developers to miss the implied assumptions. In other cases a skilled application developer may be able to infer an implied assumption based on information that is provided in the guide together with his or her prior experience and knowledge. But nevertheless it cannot be expected that all application developers will make these kinds of sophisticated inferences.

More formally stated an implied assumption is not just any missing or hidden information but information that an application developer relies on to achieve one or more objectives. A stated object may entail the production of an application that has certain characteristics. For example the application developer may wish to use the SDK to perform an authentication operation and or authorization operation. Here the application developer will wish to gain knowledge of the implied assumption in order to produce a secure application. Otherwise the application that is produced may be subject to attacks from malicious entities to be described in greater below .

The presence of implied assumptions in the guide if any may ensue from one or more factors. For example the SDK developer may fully intend to put certain details into the guide but may forget to do so. Alternatively or in addition the SDK developer may misjudge the target audience of the SDK resulting in a failure to put sufficient detail into the guide and or a failure to express the detail in a form that is appropriate for the target audience. Alternatively or addition the SDK developer may not fully take into consideration the contextual setting in which an application developer intends to use an application. As will be described at length below a contextual setting raises a host of issues which impacts the integrity of the application that is constructed using the SDK. More generally stated the SDK developer may fail to produce a sufficiently detailed guide because he or she relies on an informal and ad hoc approach to developing the guide.

Whatever the cause a guide that fails to explicitly set forth the implied assumptions is not a good thing it handicaps the application developer who relies on the guide in building his or her application and may lead to the production of a faulty application. This problem is particularly pernicious with respect to SDKs since many applications are constructed based on the SDKs not just a single application.

To address this problem a framework is described herein for determining if the SDK and guide are associated with any implied assumptions . The framework also incorporates various tools and tactics for addressing the presence of any detected implied assumptions . The goal of these tools and tactics is to a eliminate or reduce the presence of the implied assumptions and or b detect the presence of vulnerabilities in applications which ensue from the implied assumptions .

This section provides an overview of the framework while later sections provide additional details on individual parts of the framework.

To begin with sets forth an environment having different entities. These entities play a role in a running illustrative example set forth herein in that example the application under consideration uses an SDK to perform an authentication operation and or an authorization operation. In an authentication operation the application establishes the identity of a user or other entity. In an authorization operation the application is granted permissions on behalf of the user or other entity. The permissions are granted by an ID provider to be described below .

The entities shown in are coupled together using a communication mechanism e.g. a wide area network such as the Internet . The entities include a representative client device together with one or more other client devices . Each client device can be constructed in any manner such as a personal computer a lap top computer a game console device a set top box device a tablet type computer a smartphone an electronic media consumption device and so on. The entities also include a representative server together with one or more other servers . Each server can be constructed in any manner e.g. by a server type computer in optional conjunction with one or more data stores. The entities also include an identification ID provider . The ID provider provides authentication and or authorization related services to applications. The ID provider can be implemented in any manner such as by one or more servers together with one or more data stores.

Each client device may store one or more applications. For example the representative client device stores a collection of applications . Each of these applications may perform its functions using a client runtime provided by the client device . For example the client runtime may correspond to HyperText Markup Language HTML renderer functionality and a JavaScript engine.

Each server may host one or more services. For example the server hosts a collection of services . Each of these services may perform its functions using a server runtime . For example the server runtime may correspond to PHP functionality or ASP.NET functionality.

Any application running on any client device may rely on the functionality provided by a service running on any server. Hence the functionality associated with this application may be split between the client device and the associated server. To cite merely one example an application may rely on a remote service to provide image analysis functions that are too computationally intensive to perform on the client device. These kinds of applications are referred to herein as service reliant applications. In other cases some applications running on a client device may not rely on any services provided by any remote server.

At least some of the applications in the environment may rely on one or more SDKs. For example an application that runs on the client device may rely on client SDK . Further assume that this application also relies on a service provided by the server . That service in turn may rely on a service SDK to perform its operations. The service SDK may be viewed as the server side counterpart of the client SDK .

In the running example set forth herein at least one application relies on SDK functionality to interact with the ID provider . That is the application interacts with the ID provider to authenticate a user or other entity and or to gain authorization to perform a particular task. This kind of application may also interact with one or more remote services in the manner described above. Or this application may not interact with any remote services.

An application developer may produce any application shown in in the manner described above e.g. by making reference to a guide. If the SDK and guide are subject to one or more implicit assumptions then the developer may produce an application having substandard performance. As noted above in an authentication authorization context substandard performance may expose the application to attack by one or more malicious entities.

To illustrate the above point consider the scenario shown in . Here a victim s client device includes a malicious application App Bad . In a first operation 1 the application may interact with the ID provider by sending a login request. By virtue of that request the application asks the ID provider for a token that will grant the application limited authorization to access certain information. To be concrete assume that the token grants the application the right to view a user profile associated with a particular person such as the victim herself. And further assume that the victim has previously authorized the ID provider to provide this limited information to any recipient. In response in operation 2 the ID provider returns the requested token to the application .

Next in operation 3 assume that the application sends the token to a service implemented by a remote server . Further assume that the application attempts to trick the service by asserting or implying that the application which is sending the token is the same entity that is identified by the token which is not true . In operation 4 the service can use the token to ask the ID provider to send basic information that is associated with the entity identified by the token. In operation 5 the ID provider provides the basic information. In operation 6 the service notes that the entity identified by the basic information is the victim and incorrectly assumes that the sender of the token is the victim. As a consequence of this mistaken association the malicious application may achieve the ability to interact with the service as if it was the victim himself or herself. In actuality the token was intended to only grant the application limited authorization to view certain information not to establish the identity of any entity.

The above problem may ensue from a poorly constructed application which in turn may be the result of one or more hidden assumptions in the SDK s guide. The hidden assumption in this case may be a stipulation that the operations shown in are to be performed by a single entity rather than two or more entities in the manner shown in .

More generally SDKs for service reliant applications may be particularly prone to implicit assumptions. This is because it may be difficult for an SDK developer to take into account of all the actors involved in the execution of a service reliant application. The actors include but are not limited to application functionality that runs on both the client device and server SDK functionality that runs on both the client device and the server runtime functionality that runs on both the client device and the server and so on. For example the SDK developer may be focusing his or her attention on the integrity of the SDK functionality itself but the underlying runtime system s can also affect the security of the application that is being built based on the SDK.

The SDK development environment provides an SDK which may be stored in a data store and a guide which may be stored in a data store . The SDK development environment may also identify other information that pertains to the target environment in which the SDK is expected to be used to be described below. An analysis module may analyze the SDK and the guide to provide an output result. The output result can be used to determine whether there are any implicit assumptions associated with the SDK and guide . As will be described in greater detail below the analysis module may operate by performing static analysis on a model. The model represents the SDK and the target environment in which the SDK is expected to be used. The static analysis in turn operates by determining whether various assertions associated with the model are violated.

In response to the identified implicit assumptions an SDK developer may decide to modify the SDK. If successful this will have the effect of eliminating the vulnerabilities associated with the identified implicit assumptions and thus eliminating the existence of the implicit assumptions themselves. Alternatively or in addition a guide producer who may be the same person as the SDK developer may decide to modify the guide. This will have the effect of providing explicit instructions pertaining to the implicit assumptions thus removing the implicit assumptions.

Alternatively or in addition the SDK developer can use the test suite production module to produce a test suite. The test suite includes one or more vulnerability patterns. Each vulnerability pattern is associated with a particular implicit assumption identified by the analysis module . More specifically a vulnerability pattern may represent the negative expression of an assumption. For example a hidden assumption may indicate that the production of a secure application depends on operations X Y and Z being performed by a single entity. A corresponding vulnerability pattern may provide information which describes the situation in which these operations are not performed by the same entity. A vulnerability pattern may also specify externally observable evidence of any nature that will be produced when a hidden assumption is violated.

A data store can store a final SDK a final guide and a test suite. This comprises a package of information. A publication module may make any part of the package available to an application developer in any manner. For example the publication module may post the package to a web page. An application developer may visit that page to select and download any part of the package. In one scenario it is expected that the application developer will wish to download the entire package.

Now referring to the application development environment an application developer may use one more application tools to produce an application. In doing so the application developer may rely on information provided in the guide. A data store may store the application.

In addition the application developer may optionally test the application using a testing tool . The testing tool determines whether the application that has been produced has any vulnerability which matches a vulnerability pattern identified by the test suite. If so the application developer may choose to modify the application and repeat the test. The application developer may repeat these operations until he or she produces an application that is free of bugs. 

In block an application developer can receive the SDK the guide and the test suite. In block the application developer can produce an application using the SDK based on information provided in the guide. In block the application developer can optionally test the application that has been produced using the test suite.

Further the analysis module performs its security analysis by examining individual sessions between a client device and a server rather than associations between a user and a client device or a user and a service. That is the end result of authentication authorization between a client device and a server is to know whom the session represents and what the session is permitted to do. This determination will not affect the status of any other session between the same client device and server.

The analysis module operates on a model . The model represents information pertaining to the SDK and the context in which an application which uses the SDK under consideration is expected to be deployed. The analysis module also includes a static analysis tool for symbolically investigating the model . This yields an output result which in turn may indicate the presence of zero one or more implicit assumptions.

The model expresses the context in which an application which uses the SDK is deployed by taking into account different actors that may play a role in interacting with the application when the application is deployed in its intended target environment. shows one such illustrative target environment . The environment is framed from the perspective of a particular client device which may be the subject to attack from other entities. That client device is referred to herein as client victim device . A person identified as a victim interacts with this device. The client victim device runs a non malicious client application App Good that is assumed to be constructed in accordance with the guide and which is purposely installed by the victim. In one case the non malicious client application App Good relies on a client SDK and a client runtime to perform its functions.

The non malicious client application App Good also relies on a counterpart non malicious service application App Good provided by an illustrative server . The non malicious service application App Good in turn relies on a service SDK and a server runtime to perform its functions. Finally the client SDK and the service SDK may interact with ID provider functionality on behalf of the non malicious client application App Good but the non malicious client application App Good does not directly interact with the ID provider functionality .

The environment may also represent one or more attacking entities also referred to herein as malicious entities which present a potential threat to the victim. For example the client victim device may include at least one malicious client application App Bad having an unknown origin and construction and which is therefore considered as potentially malicious. As noted above the non malicious client application App Good is assumed to have been constructed in accordance with the instructions provided in the guide. In contrast the malicious client application App Bad can be produced in an arbitrary manner without reference to the guide. Nevertheless the malicious client application App Bad can be expected to conform to whatever constraints are imposed by the client runtime .

The environment may also include separate attacker functionality that is deployed on some client device other than the client victim device . More specifically the separate attacker functionality may collectively represent the other client device in conjunction with any services with which that client device interacts.

The construction of certain modules shown in is known at the time that the SDK is being analyzed. These already constructed modules are referred to as concrete modules and include the client SDK the service SDK the client runtime the server runtime and the ID provider functionality . More specifically the client runtime the server runtime and the ID provider functionality are complex hence although these modules are concrete the functionality associated with these modules may not be fully known by the SDK developer. In contrast the client SDK and the service SDK are typically relatively small programs that are publically available hence the functionality associated with these modules may be considered fully known by the SDK developer.

The remaining modules are considered abstract because their constitution is not yet determined. These modules include the non malicious client application App Good the non malicious server application App Good the malicious client application App Bad and the separate attacker functionality . For example at the time that the SDK is analyzed the SDK developer has no knowledge about the applications that an application developer will build based on the SDK. And at the time that the SDK is analyzed the SDK developer has no knowledge about what malicious entities may pose a threat to the non malicious client application even those these malicious entities may already physical exist.

Returning now to the model may express the following information regarding the components shown in or a subset thereof or any variation thereof.

The model may represent various functions performed by the client SDK and the service SDK . In addition the model may represent various functions associated with the underlying system environment in which an application will be executed. The system environment includes the client runtime employed on the client victim device and the server runtime employed by the server . The underlying system environment may also encompass aspects of the ID provider functionality .

As noted above the client SDK and service SDK are typically small programs. Hence the model can exhaustively express all of the functions associated with these modules. On the other hand the underlying system environment is typically complex and encompasses a wide range of functions. The model may therefore selectively capture those aspects of the system environment that are pertinent to the objective of analysis. In the running example of this section the objective of analysis pertains to authentication and or authorization. The model will therefore focus on those aspects of the system environment which have a bearing on the security of an application which uses the SDK.

For example the model can capture that manner in which the ID functionality interacts with the non malicious client application App Good as controlled by various application settings. For instance a particular ID provider may provide an interface that allows an application developer to enter various application settings such as application ID application secret service website domains return URL etc. The model can capture the manner in which these settings affect the behavior of the ID provider functionality . As another example the model can capture the same origin policy of the client runtime . A same origin policy defines a manner in which the client runtime distinguishes between content originating from different sources. As another example the model can capture the manner in which the server runtime manages sessions. These features are cited by way of example not limitation in other implementations the model can express other aspects of the underlying system environment.

As noted above the non malicious application modules App Good and App Good are abstract modules because they have a not yet determined construction. Hence the model cannot represent these components in the same manner as the concrete modules. Nevertheless the model can express certain constraints specified by the guide insofar as they affect the construction of the non malicious client application App Good and the non malicious service application App Good . That is the guide governs which functions these modules can call and what values they can pass when making a call. The guide further expresses the expected order of function calls and the manner in which their argument values and return values are related. A call that does not follow the ordering and argument rules in the guide is considered a non conforming call. In a sense the guide constitutes a skeleton that all conformant applications are expected to incorporate an application can add functions to this skeleton but it cannot modify the skeleton.

The malicious client application App Bad and the separate attacker functionality are also abstract meaning that their constructions are not known at the time of analysis. Further these entities are not expected to conform to any aspect of the guide. But the model can indicate that either of the malicious entities will store a security sensitive SS item in a knowledge pool when they receive the SS item as a result of a function call. Hence the knowledge pool will reflect a history of the SS items acquired by these entities. The model further specifies that either of these malicious entities is capable of retrieving any SS item from the knowledge pool and using it any manner that is permitted by any environment specific constraints that may apply to the malicious entities .

The model can also define the circumstances which constitute a violation of whatever objective that is being sought. In the running security related example the model can express the events that constitute a security violation.

One violation pertains to authentication. Assume that some knowledge k is about to be added to the knowledge pool by the malicious client application App Bad or the separate attacker functionality . Further assume that k is sufficient to convince the authentication logic of the non malicious service application App Good that the knowledge holder is the victim. This implies that either the malicious client application App Bad or the separate attacker functionality can authenticate as the victim which constitutes an authentication violation.

Another violation pertains to authorization. In one case assume that k represents some SS item associated with the victim such as the victim s access token session ID for the session between App Goodand App Good etc. This implies that an attacking entity has acquired the permission to perform any operations that the session is authorized to perform. In other cases the attacking entity may acquire the permission to interact with the ID provider functionality in the same manner as the victim.

Another violation pertains to association. A correct association is established when three pieces of data are correctly bound together a user s identity representing the outcome of authentication the user s permissions representing the outcome of authorization and the session s identity usually referred as session ID . A binding violation occurs when a malicious entity is bound to a victim in any way e.g. by binding a malicious entity with the victim s permissions or by binding a malicious entity s session to the victim s identity and so on.

More specifically the model can express the security related goals of its analysis as a set of assertions. Each assertion expresses a property that is expected to be met when an application which uses the SDK runs on a runtime system. The model can add those assertions at appropriate junctures in the model . For example the model can add an assertion whenever a malicious entity attempts to add an SS item to the knowledge pool. That assertion may stipulate that the knowledge k being added to the knowledge pool is not a secret associated with the victim or the non malicious application. In addition or alternatively an assertion may stipulate that the knowledge k cannot contain any field that indicates the identity of the victim e.g. in the case in which the knowledge k is a piece of signed data provided by the ID provider functionality . In addition or alternatively an assertion may stipulate that no API on the ID provider functionality takes k as an input and sends back the victim s identity in response. These kinds of assertions are cited way of example not limitation.

The model can also add an assertion for every binding operation in which an association is made between a user identity a permission and a session ID or any pair of these data items. For example the assertion may stipulate that if the user ID or permission represents the victim the session is likewise expected to be associated with the victim. Another assertion may stipulate that if an operation binds a user ID and a permission either both of them or neither of them are expected to represent the victim.

In terms of physical implementation the model can be formed as a program expressed in any language. The assertions may be added to particular statements in the program at junctures in the program that have a bearing on the objective that is being sought.

The static analysis tool analyzes the above described model to provide an output result which may indicate the presence of implied assumptions if any. The static analysis tool can use any static analysis technique to perform this task. In general static analysis involves analyzing the execution paths of a program in the symbolic domain as opposed to dynamically executing the program.

In one implementation the test harness operates by non deterministically invoking its abstract modules. The act of calling an abstract module may eventually result in a call being made to the system being tested. The test harness can store knowledge k in a knowledge pool whenever the malicious client application App Bad is called or whenever the separate attacker functionality is called. The static analysis tool can then determine whether this event will violate any stated assertions. In addition the static analysis tool can determine whether any invoked function will violate any binding related assertion. The SDK developer can examine the violations if any are detected to determine whether there are any implied assumptions associated with the SDK.

Each of the above noted functions can once called non deterministically select a child function. indicates that the child functions include a App Goodcalls SDK function which indicates that the client SDK is called a Calls App Good function which indicates that the non malicious service application App Good is called an App BadCalls IDP function which indicates that the ID provider functionality is called an App BadCalls Runtime function which indicates that the client runtime is called and an Attacker Calls IDP function which indicates that the ID provider functionality is called.

Each of these child functions when it is called can then non deterministically invoke a function in the underlying system layer shown in . Block indicates that the concrete module s in that system layer perform appropriate functions when they are called. Because these modules are concrete the operations within block correspond to deterministic computations.

More specifically for each depth increment the analysis module explores all paths through the non deterministic switches described above e.g. based on its execution of the model in the symbolic domain. This may result in the storage of knowledge in the knowledge pool data store . In block the analysis module increments the depth counter and repeats the above described analysis e.g. by again exploring all paths through the non deterministic switches and adding any additional knowledge to the knowledge pool data store . The analysis module repeats this operation until it reaches a final depth threshold such as without limitation 5 iterations. This procedure therefore defines a bounded search. Alternatively the analysis module can perform analysis in a non bounded manner using a theorem prover such as the Z3 theorem provider provided by Microsoft Corporation of Redmond Wash.

An SDK developer based on the results of the analysis module can identify different types of implicit assumptions depending on the nature of the SDK under consideration its corresponding guide and the underlying system environment. To cite merely one example the analysis module can analyze an application which relies on a service where that service runs in a subdomain provided by a particular server. Assume that a malicious entity interacts with another subdomain on the same server. In view of certain same origin policies that may apply within the system environment this scenario may provide an attack path through which the malicious entity can assign a victim s identity to a session ID of its choosing. A relevant assumption for this scenario specifies that no subdomain can be owned by a malicious entity.

In closing the running example presented in this section corresponds to the case in which the objective of analysis is to identify security related implicit assumptions. But more generally the analysis module can analyze an SDK with respect to any objective or combination of objectives. For example the analysis module can rely on a model that has embedded assertions that pertain to resource utilization rather than security. The SDK developer can use the analysis module to determine whether the SDK is associated with any consumption related implicit assumptions. For example a particular assumption may indicate that a particular module is expected to be employed on a particular server in order to avoid high memory usage.

In the illustrated example the testing tool performs dynamic analysis on the applications based the vulnerability patterns. Alternatively or in addition the testing tool can perform static analysis of the applications.

The testing tool can include functionality that is spread among a client side tester device a proxy mechanism and a server . The tester device assumes the role of a client device running the application under consideration. The server plays the roles of a server that runs a service with which the application may interact. The proxy mechanism can simulate message exchanges that would be produced in an actual execution environment. The proxy mechanism also simulates the operation of the separate attack functionality .

In operation client side tester functionality first launches a client application App representing a non malicious application that is constructed in accordance with a guide. This may or may not entail interaction with a corresponding server application App being tested. Server side tester functionality may correspond to testing related APIs or the like which allow the client application App to interact with the server application App . The client application App may also interact with an ID provider via SDK functionality not shown . After simulating the operation of the client application App the client side tester functionality can behave as the malicious client application App Bad of .

The computing functionality can include volatile and non volatile memory such as RAM and ROM as well as one or more processing devices e.g. one or more CPUs and or one or more GPUs etc. . The computing functionality also optionally includes various media devices such as a hard disk module an optical disk module and so forth. The computing functionality can perform various operations identified above when the processing device s executes instructions that are maintained by memory e.g. RAM ROM or elsewhere .

More generally instructions and other information can be stored on any computer readable medium including but not limited to static memory storage devices magnetic storage devices optical storage devices and so on. The term computer readable medium also encompasses plural storage devices. In many cases the computer readable medium represents some form of physical and tangible entity. The term computer readable medium also encompasses propagated signals e.g. transmitted or received via physical conduit and or air or other wireless medium etc. However the specific terms computer readable storage medium and computer readable medium device expressly exclude propagated signals per se while including all other forms of computer readable media.

The computing functionality also includes an input output module for receiving various inputs via input devices and for providing various outputs via output devices . Illustrative input devices include a keyboard device a mouse input device a touchscreen input device a gesture input device a voice recognition mechanism tabletop or wall projection input mechanisms and so on. One particular output mechanism may include a presentation device and an associated graphical user interface GUI . The computing functionality can also include one or more network interfaces for exchanging data with other devices via one or more communication conduits . One or more communication buses communicatively couple the above described components together.

The communication conduit s can be implemented in any manner e.g. by a local area network a wide area network e.g. the Internet etc. or any combination thereof. The communication conduit s can include any combination of hardwired links wireless links routers gateway functionality name servers etc. governed by any protocol or combination of protocols.

Alternatively or in addition any of the functions described in the preceding sections can be performed at least in part by one or more hardware logic components. For example without limitation the computing functionality can be implemented using one or more of Field programmable Gate Arrays FPGAs Application specific Integrated Circuits ASICs Application specific Standard Products ASSPs System on a chip systems SOCs Complex Programmable Logic Devices CPLDs etc.

In closing the description may have described various concepts in the context of illustrative challenges or problems. This manner of explanation does not constitute an admission that others have appreciated and or articulated the challenges or problems in the manner specified herein. Further the claimed subject matter is not limited to implementations that solve any or all of the noted challenges problems.

Although the subject matter has been described in language specific to structural features and or methodological acts it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the specific features or acts described above. Rather the specific features and acts described above are disclosed as example forms of implementing the claims.

