---

title: Techniques for power saving on graphics-related workloads
abstract: Various embodiments are generally directed to an apparatus, method and other techniques for monitoring a task of a graphics processing unit (GPU) by a graphics driver, determining if the task is complete, determining an average task completion time for the task if the task is not complete and enabling a sleep state for a processing circuit for a sleep state time if the average task completion time is greater than the sleep state time.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09563253&OS=09563253&RS=09563253
owner: INTEL CORPORATION
number: 09563253
owner_city: Santa Clara
owner_country: US
publication_date: 20130312
---
Embodiments described herein generally relate to graphics processing on a computing device. In particular embodiments relate to enabling sleep state periods during processing of graphics related operations processes or tasks.

Many applications require graphics intensive processes or operations to be processed by a graphics processing unit GPU in a computer system. A GPU is generally any processing unit optimized to perform graphics related operations as well as the video decoder engines and the frame correlation engines. Applications may send these graphics related operations and wait for the completion and the results of these graphics related operations. Applications may send the graphics related operations to the GPU and then check the status of the graphics related operations through an application programming interface API function call. The application may check the status in a loop until the graphics related operations are complete. Having the applications check the completion status of graphics related operations in a loop consumes a significant amount of power and also affects performance due to power throttling between a processing circuit and the GPU. It is with respect to these and other considerations that the embodiments described herein.

In various embodiments one or more applications may send a graphics related operation or task to a GPU for processing. The graphics related operation or task may be sent to the GPU through an API and monitored by a graphics driver. The one or more applications may wait for completion of processing and may request a completion status of the task while the task is waiting to be processed or is being processed by the GPU. In various embodiments the one or more applications may request the completion status of the task in a loop or spin loop from the graphics driver via the API to determine if a particular task has been completed. The one or more applications may use this technique to determine the completion status of any graphics related operations or tasks sent to the GPU for processing. For example an application may use this technique to determine if a particular draw call is completely occluded in a 3 dimensional 3D scene or if the GPU has finished processing a 3D operation such as an event query. The embodiments are not limited in this manner and any graphics related operations that may be processed by the GPU are contemplated in this disclosure.

As previously discussed having the applications check the completion status of graphics related operations in a loop consumes a significant amount of power because the device and or processing circuit cannot enter a sleep state and are always processing at full processing power. Moreover having the applications check the completion status in a loop also affects performance due to power throttling between a processing circuit and the GPU. Various implementations are directed to solving these and other problems.

In various implementations the graphics driver may be instructed to monitor the completion time for each graphics related operation or task and add a sleep time for a processing circuit based on an average completion time. For example if the graphics related operation or task takes on average 10 milliseconds to complete by the GPU the graphics driver may provide instructions to put the processing circuit to sleep at 1 millisecond intervals until the graphics related operation or task is completed. By putting the processing circuit into a sleep state at 1 millisecond intervals the processing circuit may be in a sleep state for a maximum amount of time without degrading performance. In addition the application may continue to process other tasks or work in parallel. Enabling the sleep state for the processing circuit saves power by not processing operations while in the sleep state. In various embodiments the processing circuit may only be put into a sleep state during a long spin loop e.g. when the processing circuit power is wasting more on executing the spin loop. This ensures that a maximum amount of power may be saved without effecting performance of the application.

In various embodiments the graphics driver may be proactively notified that the graphics related operation or task is complete. For example a kernel mode driver may proactively notify the user mode driver when the task is complete via an operating system event notification. This added feature has the benefit of reducing any performance loss incurred when the task completes in the middle of the sleep state by waking the user mode driver and processing circuit before completion of the sleep cycle. Various embodiments and implementations are discussed in further detail herein.

With general reference to notations and nomenclature used herein the detailed description that follows may be presented in terms of program procedures executed on a computer or network of computers. These procedural descriptions and representations are used by those skilled in the art to most effectively convey the substance of their work to others skilled in the art.

A procedure is here and is generally conceived to be a self consistent sequence of operations leading to a desired result. These operations are those requiring physical manipulations of physical quantities. Usually though not necessarily these quantities take the form of electrical magnetic or optical signals capable of being stored transferred combined compared and otherwise manipulated. It proves convenient at times principally for reasons of common usage to refer to these signals as bits values elements symbols characters terms numbers or the like. It should be noted however that all of these and similar terms are to be associated with the appropriate physical quantities and are merely convenient labels applied to those quantities.

Further the manipulations performed are often referred to in terms such as adding or comparing which are commonly associated with mental operations performed by a human operator. No such capability of a human operator is necessary or desirable in most cases in any of the operations described herein that form part of one or more embodiments. Rather the operations are machine operations. Useful machines for performing operations of various embodiments include general purpose digital computers or similar devices.

Various embodiments also relate to apparatus or systems for performing these operations. This apparatus may be specially constructed for the required purpose or it may comprise a general purpose computer as selectively activated or reconfigured by a computer program stored in the computer. The procedures presented herein are not inherently related to a particular computer or other apparatus. Various general purpose machines may be used with programs written in accordance with the teachings herein or it may prove convenient to construct more specialized apparatus to perform the required method steps. The required structure for a variety of these machines will appear from the description given.

Reference is now made to the drawings wherein like reference numerals are used to refer to like elements throughout. In the following description for purposes of explanation numerous specific details are set forth in order to provide a thorough understanding thereof. It may be evident however that the novel embodiments can be practiced without these specific details. In other instances well known structures and devices are shown in block diagram form in order to facilitate a description thereof. The intention is to cover all modifications equivalents and alternatives consistent with the claimed subject matter.

As shown in computing system may include multiple elements. One or more elements may be implemented using one or more circuits components registers processors software subroutines modules or any combination thereof as desired for a given set of design or performance constraints. Although shows a limited number of elements in a certain topology by way of example it can be appreciated that more or less elements in any suitable topology may be used in computing system as desired for a given implementation. The embodiments are not limited in this context.

In various embodiments computing system may include a processing circuit . Processing circuit may be one or more of any type of computational element such as but not limited to a microprocessor a processor central processing unit digital signal processing unit dual core processor mobile device processor desktop processor single core processor a system on chip SoC device complex instruction set computing CISC microprocessor a reduced instruction set RISC microprocessor a very long instruction word VLIW microprocessor or any other type of processor or processing circuit on a single chip or integrated circuit. The processing circuit may be connected to and communicate with the other elements of the computing system via an interconnect such as one or more buses control lines and data lines.

In one embodiment computing system may include a memory unit to couple to processing circuit . Memory unit may be coupled to processing circuit via interconnect or by a dedicated communications bus between processing circuit and memory unit as desired for a given implementation. Memory unit may be implemented using any machine readable or computer readable media capable of storing data including both volatile and non volatile memory. In some embodiments the machine readable or computer readable medium may include a non transitory medium. The embodiments are not limited in this context.

The memory unit can store data momentarily temporarily or permanently. The memory unit stores instructions and data for computing system . The memory unit may also store temporary variables or other intermediate information while the processing circuit is executing instructions. The memory unit is not limited to storing the above discussed data the memory unit may store any type of data.

In various embodiments computing system may include a display unit . Display unit may constitute any display device capable of displaying information received from processing circuit . The display unit may include at least one of a Liquid Crystal Display LCD a Thin Film Transistor LCD TFT LCD an Organic Light Emitting Diode OLED a flexible display a three dimensional 3D display and a projector for example. The display unit may display a User interface UI or a Graphical User Interface GUI associated with controlling functionality of the computing system . The computer device may include two or more display units according to various embodiments. For example in one embodiment the computing device may include two LCD displays.

In various implementations computing system may include a battery . The battery may be any type of battery to store power for the computing system including but not limited to a lithium ion battery a nickel cadmium battery zinc chloride battery or the like. The battery may be rechargeable. In some embodiments the computing system may have more than one battery. In some embodiments the battery may be removable. In other embodiments the battery may be fixed.

In various embodiments computing system may include storage . Storage may be implemented as a non volatile storage device such as but not limited to a magnetic disk drive optical disk drive tape drive an internal storage device an attached storage device flash memory battery backed up SDRAM synchronous DRAM and or a network accessible storage device. In embodiments storage may include technology to increase the storage performance enhanced protection for valuable digital media when multiple hard drives are included for example. Further examples of storage may include a hard disk floppy disk Compact Disk Read Only Memory CD ROM Compact Disk Recordable CD R Compact Disk Rewriteable CD RW optical disk magnetic media magneto optical media removable memory cards or disks various types of DVD devices a tape device a cassette device or the like. The embodiments are not limited in this context.

Computing system may include one or more I O adapters in some embodiments. Examples of I O adapters may include Universal Serial Bus USB ports adapters IEEE 1394 Firewire ports adapters and so forth. The embodiments are not limited in this context.

In various embodiments computing system may include a transceiver . Transceiver may include one or more radios capable of transmitting and receiving signals and information using various suitable wireless communications techniques. Such techniques may involve communications across one or more wireless networks. Exemplary wireless networks include but are not limited to wireless local area networks WLANs wireless personal area networks WPANs wireless metropolitan area network WMANs cellular networks and satellite networks. In communicating across such networks transceiver may operate in accordance with one or more applicable standards in any version. The embodiments are not limited in this context.

Computing system may include a graphics processing unit GPU in various embodiments. The GPU may include any processing unit logic or circuitry optimized to perform graphics related operations as well as the video decoder engines and the frame correlation engines. The GPU may be used to render 2 dimensional 2 D and or 3 dimensional 3 D images for various applications such as video games graphics computer aided design CAD simulation and visualization tools imaging etc. Various embodiments are not limited in this manner GPU may process any type of graphics data such as pictures videos programs animation 3D 2D and so forth.

System may not be limited to these specific modules and elements shown in . For example system may include any number of modules and elements to process graphics and graphics related operations. In various embodiments certain modules and elements of system may operate on or in conjunction with computing system . For example the modules and elements of system may be stored in memory and processed by processing circuit .

Application may be any type of application or software. In various embodiments application may be enterprise software accounting software office suites graphics software gaming software media software web based application computer system software educational software simulation software content access software media development software product engineering software and so forth. Application is not limited in this manner application may be any type of application or software for processing data on a computing system.

Application programming interface API module may be any type of API for processing graphic information between the modules and elements of system . For example in various embodiments API module provides an abstraction layer between the application and a graphics driver module such that the application and graphics driver module may communicate between each other. API module may enable communication between the modules and elements of system through various messages or calls such as a function call. In various embodiments API module may be a graphics API such as such as Direct3D or OpenGL .

Graphics driver module may be any type of graphics driver software that that provides and interface between graphics hardware and software operating on system . For example graphics driver module may provide an interface for and enable communication between the graphics processing unit and the other modules and elements of system . However graphics driver module is not limited in this manner. For example graphic driver module may enable communication between the graphics processing unit and an operating system not shown operating on system . In various embodiments graphics driver module may receive function calls from application executing on the computing system . The graphics driver module may also route the function calls to the GPU so that graphics may be rendered by the GPU . In various embodiments the graphics driver module may be stored in memory and processed by processing circuit . However the graphics driver module is not limited in this manner. The graphics driver module may be stored in any type storage device and may be processed by any type of processing device.

In various embodiments the graphics drive module may be a user mode driver. A user mode driver runs in the non privileged processor mode in which other application code including protected subsystem code executes. A user mode driver cannot gain access to system data except by calling an API such as API . The API then calls system services. However various embodiments are not limited in this manner graphics driver module may be a conjunction of a user mode driver and a kernel mode driver working together. A kernel mode driver runs as part of the operating system s executive the underlying operating system component that supports one or more protected subsystems.

Graphics processing unit GPU may be any type of processing circuit for processing graphics. GPU may contain multiple processing units that concurrently perform independent operations. GPU may implement a number of graphics primitive operations for processing tasks received from an application. In various embodiments the GPU may process any type of graphics task including but not limited to drawing texturing rendering 3 dimensional 3 D graphics rendering 2 dimensional 2 D graphics matrix computations and vector computations.

In various embodiments GPU may render frame data. For example GPU may receive frame data from one or more applications such as application . GPU receives frame data e.g. all or in part generated by an application running on the processing circuit . GPU may then render the frame data to generate rendered frames e.g. files of digital pixel information corresponding to all or part of a video frame or graphic that can be provided to a display device such as display unit . However GPU is not limited in this manner. GPU may process any type of graphical information received from an application or the operating system.

GPU work queue may be any type of buffer or memory to store tasks to be completed by the GPU . In some embodiments GPU work queue may be any kind of data structure to store tasks such as a ring buffer bit array dynamic array hash table hash array tree sparse array etc. GPU work queue may be any portion of memory unit set aside by the processing circuit to store tasks to be completed by the GPU . In other embodiments GPU work queue may be separate memory not shown to store GPU tasks. In some instances GPU work queue may be more than one memory or buffer.

GPU work queue may store tasks to be retrieved by the GPU . Typically the graphics driver module inserts tasks into the work queue . However various embodiments are not limited in this manner. Tasks may be inserted into the GPU work queue via other elements of the computing system such as the operating system.

In various embodiments GPU may asynchronously retrieve the tasks to be processed next from the GPU work queue . The selection of the task to be processed next may be based on a priority ordering specified by the processing circuit . In some instances the processing circuit may specify priority on a per task basis. In other instances the processing circuit may specify a priority associated with a memory and any task queued in the memory will have the priority associated with that memory.

Task may be any type of task to be completed by the GPU . In various embodiments task may be any type of graphics related task including but not limited to a drawing task a texturing task a rasterization task pixel processing task a shading task rendering 3 dimensional 3 D images or graphics rendering 2 dimensional 2 D images and graphics matrix computations vector computations etc.

In various embodiments task may be received from application for processing by the GPU . The task may be received by the GPU via API . The task may be assigned a priority for processing and inserted in the GPU work queue to be processed. For example task may be inserted into GPU work queue such that five other task s must be processed before task is processed. In other embodiments task may be immediately processed.

Various modules and elements may communicate with each other via interconnects . For example in various embodiments application may send a function call to API to determine a completion status of the task processed by GPU . The API may then communicate with the graphics driver via another function call to retrieve the completion status for the particular task . The graphics driver module may determine the status of the task and return the completion status to the API which in turn returns the completion status to the application . The application may continuously or at a specific interval request the completion status in a loop until the status indicates the task is complete. The specific interval may be any interval defined by the application and or the graphics processing module . This and other embodiments will be discussed in more detail below with respect to .

At block the graphics driver module determines if the task is complete. The graphics driver module may communicate with the GPU via the interconnect to determine if the GPU has processed the task . The graphics driver module may communicate with the GPU in any manner such as through a function call or a low level instruction. In addition graphics driver module may communicate with GPU directly or via an operating system not shown . The graphics driver module is not limited in this manner. Graphics driver module may communicate with GPU in any manner through any number of interconnects to receive the completion status of the task . The graphics driver module may receive information indicating a result of complete or not complete for the task from the GPU . The result of complete or not complete may then be sent to API and the application based on the information received from the GPU .

If the task is complete a task completion time and average task completion time are determined at block . In various embodiments the graphics driver module may calculate the task completion time and the average task completion. However in other embodiments the determination may be made by a processing circuit a controller a different module. For example in various embodiments task completion time and average task completion may be determined or calculated by the GPU . Various embodiments are not limited in this manner.

The task completion time may be calculated based on a determined task start time. As further discussed below with respect to block a task start time may be saved the first time the graphics driver module determines the task is not complete. In addition to determining the task start time a task finish time may be determined by the graphics driver module and or the GPU . The task completion time may be calculated by determining the difference between the task start time and the task finish time. In various embodiments the task completion time may then be saved in memory or storage and used for future processing. The task completion time may also be used to determine the average task completion time.

The average task completion time may be a running average of task completion times for all the tasks processed by the GPU . For example the graphics driver module may determine and maintain the average task completion time for all of the tasks completed by the GPU . In some embodiments completion times for different types of tasks may take different amounts of time. Therefore an average task completion time may also be determined and maintained for each of similar tasks or task types. For example the graphics driver modules may determine and maintain the average task completion times for the different tasks or types of tasks the GPU processes such as a drawing task a texturing task a rasterization task pixel processing task a shading task rendering 3 dimensional 3 D images or graphics rendering 2 dimensional 2 D images and graphics matrix computations vector computations. Various embodiments are not limited in this manner. The graphics driver modules and or GPU may determine and maintain any number of average tasks completion times.

If the task is not complete at block the graphics driver module determines if this is the first instance the task has been determined not complete at block . As previously discussed the completion status may be requested one or more times and the graphics driver module may determine or query the GPU to determine if the task is complete. If the graphics driver module determines that this is the first instance the task has been determined not complete the graphics driver module saves a task start time in memory or storage at block .

If graphics driver module determines this is the not the first instance that the task has been determined not complete the graphics driver module determines if the average task completion time for the task is greater than a sleep state time at block . In various embodiments the average task completion time may be the average task completion time for all the previous tasks completed. However in other embodiments or the same embodiment the average task completion time may be the average task completion time for a task or a particular task type such as a drawing task a texturing task a rasterization task pixel processing task a shading task rendering 3 dimensional 3 D images or graphics rendering 2 dimensional 2 D images and graphics matrix computations vector computations etc. The graphics driver module may determine the task type being processed and use the average task completion time for that particular type of task for the comparison for example.

In some instances the sleep state time may be predetermined. The sleep state time may be based on a fraction of the average task completion time for a particular task. For example if the average task completion time is 10 milliseconds ms the sleep state time may be set at 1 ms or 10 percent. The sleep state time may be set such that it benefits the system by saving processing circuit power without effecting system performance. In various embodiments the sleep state time may be set on the order of milliseconds. However in various embodiments the sleep state time is limited in this manner. The sleep state time may be set at any time such that it benefits the system by saving the processing circuit power without effecting system performance.

If at block the graphics driver module determines that the average task completion time is greater than the sleep state time the graphics driver module may instruct or enable the processing circuit to sleep for the sleep state time at block . During the sleep state time the processing circuit may go into a sleep or low power state. While the processing circuit is in the sleep state the processing circuit may put to sleep various threads being processed by the processing circuit . For example the processing circuit may put to sleep the graphics driver module thread for monitoring or determining the completion status of the task .

In various embodiments the system may put the processing circuit into one of the sleep states defined by the advanced configuration and power interface ACPI specification. For example the processing circuit may be put into one of the power states C1 C6. The ACPI defines C1 as a state where the processing circuit is not executing instructions but can return to an executing state essentially instantaneously C2 as a state where the processing circuit maintains all software visible state but may take longer to wake up and C3 as a state where the processing circuit does not need to keep its cache coherent but maintains other state information. C4 C6 power states put the processing circuit into an even deeper power state. In some embodiments C4 C6 progressively reduce a voltage power applied to the processing circuit. The voltage power may be lowered to 0 volts in the C6 power state. Various embodiments are not limited C state sleep states. For example the processing circuit may be put into any sleep state such that it benefits the system by saving processing circuit power without effecting system performance.

If the graphics driver module determines that the average task completion time is not greater than the sleep state time the graphics driver module may not put the processing circuit into a sleep state and may return the completion status at block . The completion status may be returned to the application via the API . In various embodiments the graphics driver module may return the completion status for a query object. For example the graphics driver module will determine the completion status of the query object created for a task and return the completion status to the application. The graphics driver module will return a completion status of complete or not complete based on the determination made by the graphics driver module . In various embodiments the application and API may continue to request a completion status until the returned completion status indicates the task is complete. The processes as described in blocks to may be repeated until the task is complete and the processing circuit may be put into a sleep state for the predetermined sleep state time multiple times.

The graphics driver module may create a notification for the completion status of the task at block . The notification may be an event notification created in response to receiving the request for monitoring. In various embodiments the event notification may be associated with the task for processing by the GPU . The notification may be created by the graphics driver module through an operating system for a computing system. As will be discussed in further detail below the event notification may indicate when the task is completed and may be sent to the graphics driver module by a kernel mode driver of the operating system.

At block an application initiates a request for completion status for the first time. For example application may send a request for completion status of the task to the graphics driver module . This request may be similar to the request discussed in block . In various embodiments the request may be a query object submitted in a dynamic memory address DMA buffer to the graphics driver module . The DMA buffer containing the query object may be sent to the graphics driver module . The graphics driver module may receive the request for completion status and at block the notification may be associated with the task . For example the graphics driver module may associate the event notification with the task or query object and submit a request to the kernel mode driver for notification upon completion of the task . As previously discussed the kernel mode driver may send the notification to the graphics driver module indicating completion of the task .

At block the task may be sent to the GPU for processing. In various embodiments the task may be sent to the GPU in the DMA buffer as a set of query operations to be performed by the GPU . The GPU may receive the task and process the task or set of query operations at block . If the GPU has multiple tasks for completion the task may be put into the GPU work queue as discussed above with respect to . The GPU work queue may be a ring buffer and the GPU may process the task on a first come first serve basis or first in first out FIFO . In other embodiments the task may have a priority level and the GPU may process the task based on the priority level. Tasks with high priorities will be processed before tasks with lower priorities. For example the task may be inserted into the GPU work queue to be processed next if the task has a high or highest priority.

At block the task is processed by the GPU and the GPU sends an interrupt to indicate completion of the task . In various embodiments the interrupt may be sent to a kernel mode driver indicating completion of the task in the DMA buffer. The task may be processed by the GPU asynchronously while the processing circuit is in a sleep state. In various embodiments the GPU may finish processing the task before the processing circuit comes out of the sleep state.

At block a notification is sent to the operating system indicating the processing of the task is complete. If the processing circuit is still in a sleep state the operating system may wake the processing circuit . For example the event notification associated with the task may be sent to the operating system by the kernel mode driver and the operating system may wake the processing circuit from the sleep state. The kernel mode driver sends the event notification upon receiving the interrupt indicating completion of the task . In this respect the processing circuit does not complete a sleep cycle but is awaken before the sleep state time expires. The processing circuit may then process information sooner instead of waiting for the sleep state time to expire and the sleep cycle to complete.

In various instances the operating system may wake one or more threads put to sleep while the task is waiting to be processed or during processing by the GPU . While not limited in this respect the one or more threads may include a graphics driver module thread monitoring the task . The one or more threads may also include any other threads that may be put to sleep while the task is waiting to be processed or is being processed by the GPU .

At block task results are returned to the application. In various embodiments the graphics driver module sends an indication that the task is complete and returns the results of the task to the application via API . The task results may be any information processed by the GPU including but not limited to the results of a graphics task a drawing task a texturing task a rasterization task pixel processing task a shading task rendering 3 dimensional 3 D images or graphics rendering 2 dimensional 2 D images and graphics matrix computations vector computations etc. Once the application receives the results the application may continue processing information with the results at block .

The application may continue to request a completion status for the task in a loop and the processing circuit may be put into a sleep state for a sleep time as similarly discussed above with respect to . At block the application may send a request for completion status of a task . In various embodiments the API may receive the request for completion status of the task from the application . The task may be any graphics related task sent to the GPU for processing from an application. The API may receive the request for completion status from application through a function call. The API may communicate the request to the graphics driver module to determine the completion status of the task .

At decision block the graphics driver module determines if the application is requesting the completion status in a loop. For example the application may continuously or at a specific interval request the completion status for the task until the completion status indicates that the task is complete and or the results are returned to the application. If at decision block the graphics driver module does not detect a loop the graphics driver module returns a completion status of not complete to the application at block . As previously discussed the graphics driver module may return the completion status to the application via the API .

If at decision block the graphics driver module does detect a loop the graphics driver module determines if a delay time is greater than or equal to the average task completion time for the task at block . In various embodiments the delay time may be 1 ms or time remaining till average completion time. As previously discussed the average task completion time may be a running average of task completion times for all the tasks processed by the GPU . For example the graphics driver module may determine and maintain the average task completion time for all of the tasks completed by the GPU . In some embodiments completion times for different tasks or types of tasks may take different amounts of time. Therefore an average task completion time may also be determined and maintained for each of similar tasks or task types. For example the graphics driver modules may determine and maintain the average task completion times for the different types of tasks the GPU processes such as a drawing task a texturing task a rasterization task pixel processing task a shading task rendering 3 dimensional 3 D images or graphics rendering 2 dimensional 2 D images and graphics matrix computations vector computations etc.

If at decision block the graphics driver module determines that the delay is greater than or equal to the average task completion time the graphics driver module returns the completion status of not complete to the application at block . In this example the processing circuit is not put into a sleep state because the GPU is expected to finish processing the task imminently. By enabling a sleep state for the processing circuit the system avoids the case where the task may finish before the expiration of the sleep state time. However if the processing circuit is in a sleep state while the task is completed the processing circuit may be wakened as discussed above with respect to blocks .

If at decision block the graphics driver module determines that the delay is not greater than the average task completion time the graphics driver module may instruct the processing circuit to sleep for a sleep state time at block . As previously discussed the sleep state time may be set such that it benefits the system by saving processing circuit power without effecting system performance and the sleep state time may be set on the order of milliseconds. During the sleep state time the processing circuit may go into a low power state. While the processing circuit is in the sleep state the processing circuit may put to sleep various threads being processed by the processing circuit . For example the processing circuit may put to sleep the graphics driver module thread being processed for the task . In various embodiments the system may put the processing circuit into one of the sleep states defined by the advanced configuration and power interface ACPI specification as previously discussed.

Upon completion of the sleep state for the sleep state time the graphics driver module determines if the task is complete or not complete at block . The graphics driver module may communicate with the GPU via interconnect to determine if the GPU has processed the task . As previous discussed graphics driver module may communicate with GPU in any manner through any number of interconnects to receive the completion status of the task . The graphics driver module may receive information indicating a result of complete or not complete for the task . The result of complete or not complete may then be sent to API and the application based on the information received from the GPU .

If the graphics driver module determines the task is not complete at block the graphics driver module returns a completion status of not complete to the application at block .

If the graphics driver module determines the task is complete at block the graphics driver module returns a completion status of complete to the application at block . The process then proceeds to block and task results are returned to the application . In various embodiments the graphics driver module sends an indication that the task is complete and returns the results of the task to the application via API . The task results may be any information processed by the GPU including but not limited to the results of a graphics task a drawing task a texturing task a rasterization task pixel processing task a shading task rendering 3 dimensional 3 D images or graphics rendering 2 dimensional 2 D images and graphics matrix computations vector computations etc. Once the application receives the results the application may continue processing information with the results at block .

At line the application sends a first request for a completion status for the task to the graphics driver module . The application may send the first request via the API as previously discussed. The graphics driver module receives the request and may save a task start time for the task . In various embodiments the graphics driver module may not save the task start time for the task when it receives the first request for completion status. In other embodiments the graphics driver module may save the task start time for the task when the graphics driver module receives the task at line .

At line the graphics processing module sends a request to the GPU to determine the completion status of the task . At line the GPU returns the completion status for the task . In this example the GPU returns a completion status of not complete to the graphics driver module at line . The graphics processing module receives the completion status from the GPU and sends the completion status to the application though the API at line .

Lines are similar to lines . The application sends a second request for completion status of the task to the graphics driver module at line . However once the graphics driver module receives the second request for completion status the graphics driver module may put the processing circuit into a sleep state for a sleep state time at line . The processing circuit may sleep for the sleep state time as previously discussed above with respect to . Various instances are not limited in this manner. The graphics driver module may put the processing circuit into a sleep state for a sleep state time when it receives the first request for completion status at line for example.

At line the graphics processing module sends a request to the GPU to determine the completion status of the task . At line the GPU returns the completion status for the task of not complete in this example. The graphics processing module receives the completion status from the GPU and sends the completion status to the application though the API at line . In this example the processing of the task is not complete during the completion status loop for the second request. However various embodiments are not limited in this manner. For example the processing of the task may be completed and a completion status of complete may be returned to the application at any time.

For example lines are similar to lines . However the GPU has finished processing the task and a completion status of complete is returned to the application at line . In addition to returning a completion status of complete the GPU sends the results of the task to the graphics driver module at line . The results may be sent at the same time the completion status is sent to the graphics driver module . For example the GPU may send the results in the same message as the completion status to the graphics driver module so that there is no delay in the graphics module and application in receiving the results of the task . However in various embodiments the results may be sent to the graphics module in a different message at a different time than the completion status.

The graphics driver module receives the results of the task and sends the results to the application at line . The results may be sent to the application through the API . The application may then proceed with processing with the results of the task completed by the GPU .

In the above recited example the application sends three requests for completion status of the task before a result of complete is returned along with the results of the task . In addition the graphics driver module put the processing circuit into a sleep state for a sleep state time twice. However various embodiments are not limited in this manner. In some instances the task may be completed by the GPU sooner or later than the above recited example. Moreover any number of requests may be sent and sleep states may be entered. In various embodiments the graphics driver module may not put the processing circuit into a sleep state. For example the graphics driver module may determine that the average task completion time is not greater than the sleep state time as discussed above with respect to block and the graphics driver module may not put the processing circuit into a sleep state. Other embodiments are discussed and described herein.

In the illustrated embodiment shown in the logic flow may include monitoring a task of a graphics processing unit GPU by a graphics driver at block . The task may be any task for processing by the GPU including but not limited to a graphics task a drawing task a texturing task a rasterization task pixel processing task a shading task rendering 3 dimensional 3 D images or graphics rendering 2 dimensional 2 D images and graphics matrix computations vector computations etc. At block one or more elements circuits software modules etc. may determine if the task is complete.

At block an average task completion time for the task is determined if the task is not complete. The average task completion time may be a running average of task completion times for all the tasks processed by the GPU. For example one or more elements circuits modules etc. may determine and maintain the average task completion time for all of the tasks completed by the GPU. In some embodiments completion times for different tasks or types of tasks may take different amounts of time. Therefore an average task completion time may also be determined and maintained for each of similar tasks or task types as previously discussed.

At block a sleep state for a processing circuit for a sleep state time is enabled if the average task completion time is greater than the sleep state time. The sleep state time may be predetermined and may be based on a fraction of the average task completion time for a particular task. For example if the average task completion time is 10 milliseconds ms the sleep state time may be set at 1 ms or 10 percent. The sleep state time may be set such that it benefits the system by saving processing circuit power without effecting system performance.

As used in this application the terms system and component are intended to refer to a computer related entity either hardware a combination of hardware and software software or software in execution examples of which are provided by the exemplary computing architecture . For example a component can be but is not limited to being a process running on a processor a processor a hard disk drive multiple storage drives of optical and or magnetic storage medium an object an executable a thread of execution a program and or a computer. By way of illustration both an application running on a server and the server can be a component. One or more components can reside within a process and or thread of execution and a component can be localized on one computer and or distributed between two or more computers. Further components may be communicatively coupled to each other by various types of communications media to coordinate operations. The coordination may involve the uni directional or bi directional exchange of information. For instance the components may communicate information in the form of signals communicated over the communications media. The information can be implemented as signals allocated to various signal lines. In such allocations each message is a signal. Further embodiments however may alternatively employ data messages. Such data messages may be sent across various connections. Exemplary connections include parallel interfaces serial interfaces and bus interfaces.

The computing architecture includes various common computing elements such as one or more processors multi core processors co processors memory units chipsets controllers peripherals interfaces oscillators timing devices video cards audio cards multimedia input output I O components power supplies and so forth. The embodiments however are not limited to implementation by the computing architecture .

As shown in the computing architecture comprises a processing unit a system memory and a system bus . The processing unit can be any of various commercially available processors such as those described with reference to the processor shown in .

The system bus provides an interface for system components including but not limited to the system memory to the processing unit . The system bus can be any of several types of bus structure that may further interconnect to a memory bus with or without a memory controller a peripheral bus and a local bus using any of a variety of commercially available bus architectures. Interface adapters may connect to the system bus via slot architecture. Example slot architectures may include without limitation Accelerated Graphics Port AGP Card Bus Extended Industry Standard Architecture E ISA Micro Channel Architecture MCA NuBus Peripheral Component Interconnect Extended PCI X PCI Express Personal Computer Memory Card International Association PCMCIA and the like.

The computing architecture may comprise or implement various articles of manufacture. An article of manufacture may comprise a computer readable storage medium to store logic. Examples of a computer readable storage medium may include any tangible media capable of storing electronic data including volatile memory or non volatile memory removable or non removable memory erasable or non erasable memory writeable or re writeable memory and so forth. Examples of logic may include executable computer program instructions implemented using any suitable type of code such as source code compiled code interpreted code executable code static code dynamic code object oriented code visual code and the like. Embodiments may also be at least partly implemented as instructions contained in or on a non transitory computer readable medium which may be read and executed by one or more processors to enable performance of the operations described herein.

The system memory may include various types of computer readable storage media in the form of one or more higher speed memory units such as read only memory ROM random access memory RAM dynamic RAM DRAM Double Data Rate DRAM DDRAM synchronous DRAM SDRAM static RAM SRAM programmable ROM PROM erasable programmable ROM EPROM electrically erasable programmable ROM EEPROM flash memory polymer memory such as ferroelectric polymer memory ovonic memory phase change or ferroelectric memory silicon oxide nitride oxide silicon SONOS memory magnetic or optical cards an array of devices such as Redundant Array of Independent Disks RAID drives solid state memory devices e.g. USB memory solid state drives SSD and any other type of storage media suitable for storing information. In the illustrated embodiment shown in the system memory can include non volatile memory and or volatile memory . A basic input output system BIOS can be stored in the non volatile memory .

The computer may include various types of computer readable storage media in the form of one or more lower speed memory units including an internal or external hard disk drive HDD a magnetic floppy disk drive FDD to read from or write to a removable magnetic disk and an optical disk drive to read from or write to a removable optical disk e.g. a CD ROM or DVD . The HDD FDD and optical disk drive can be connected to the system bus by a HDD interface an FDD interface and an optical drive interface respectively. The HDD interface for external drive implementations can include at least one or both of Universal Serial Bus USB and IEEE 1394 interface technologies.

The drives and associated computer readable media provide volatile and or nonvolatile storage of data data structures computer executable instructions and so forth. For example a number of program modules can be stored in the drives and memory units including an operating system one or more application programs other program modules and program data . In one embodiment the one or more application programs other program modules and program data can include for example the various applications and or components of the system .

A user can enter commands and information into the computer through one or more wire wireless input devices for example a keyboard and a pointing device such as a mouse . Other input devices may include microphones infra red IR remote controls radio frequency RF remote controls game pads stylus pens card readers dongles finger print readers gloves graphics tablets joysticks keyboards retina readers touch screens e.g. capacitive resistive etc. trackballs trackpads sensors styluses and the like. These and other input devices are often connected to the processing unit through an input device interface that is coupled to the system bus but can be connected by other interfaces such as a parallel port IEEE 1394 serial port a game port a USB port an IR interface and so forth.

A monitor or other type of display device is also connected to the system bus via an interface such as a video adaptor . The monitor may be internal or external to the computer . In addition to the monitor a computer typically includes other peripheral output devices such as speakers printers and so forth.

The computer may operate in a networked environment using logical connections via wire and or wireless communications to one or more remote computers such as a remote computer . The remote computer can be a workstation a server computer a router a personal computer portable computer microprocessor based entertainment appliance a peer device or other common network node and typically includes many or all of the elements described relative to the computer although for purposes of brevity only a memory storage device is illustrated. The logical connections depicted include wire wireless connectivity to a local area network LAN and or larger networks for example a wide area network WAN . Such LAN and WAN networking environments are commonplace in offices and companies and facilitate enterprise wide computer networks such as intranets all of which may connect to a global communications network for example the Internet.

When used in a LAN networking environment the computer is connected to the LAN through a wire and or wireless communication network interface or adaptor . The adaptor can facilitate wire and or wireless communications to the LAN which may also include a wireless access point disposed thereon for communicating with the wireless functionality of the adaptor .

When used in a WAN networking environment the computer can include a modem or is connected to a communications server on the WAN or has other means for establishing communications over the WAN such as by way of the Internet. The modem which can be internal or external and a wire and or wireless device connects to the system bus via the input device interface . In a networked environment program modules depicted relative to the computer or portions thereof can be stored in the remote memory storage device . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers can be used.

The computer is operable to communicate with wire and wireless devices or entities using the IEEE 802 family of standards such as wireless devices operatively disposed in wireless communication e.g. IEEE 802.11 over the air modulation techniques . This includes at least Wi Fi or Wireless Fidelity WiMax and Bluetooth wireless technologies among others. Thus the communication can be a predefined structure as with a conventional network or simply an ad hoc communication between at least two devices. Wi Fi networks use radio technologies called IEEE 802.11x a b g n etc. to provide secure reliable fast wireless connectivity. A Wi Fi network can be used to connect computers to each other to the Internet and to wire networks which use IEEE 802.3 related media and functions .

The various elements of the touch gesture recognition system as previously described with reference to may comprise various hardware elements software elements or a combination of both. Examples of hardware elements may include devices logic devices components processors microprocessors circuits processors circuit elements e.g. transistors resistors capacitors inductors and so forth integrated circuits application specific integrated circuits ASIC programmable logic devices PLD digital signal processors DSP field programmable gate array FPGA memory units logic gates registers semiconductor device chips microchips chip sets and so forth. Examples of software elements may include software components programs applications computer programs application programs system programs software development programs machine programs operating system software middleware firmware software modules routines subroutines functions methods procedures software interfaces application program interfaces API instruction sets computing code computer code code segments computer code segments words values symbols or any combination thereof. However determining whether an embodiment is implemented using hardware elements and or software elements may vary in accordance with any number of factors such as desired computational rate power levels heat tolerances processing cycle budget input data rates output data rates memory resources data bus speeds and other design or performance constraints as desired for a given implementation.

The detailed disclosure now turns to providing examples that pertain to further embodiments. Examples one through forty six 1 46 provided below are intended to be exemplary and non limiting.

In a first example an apparatus may include a memory a processing circuit coupled to the memory and a graphics processing unit GPU coupled to the processing circuit and the memory to process graphics related tasks. The apparatus may also include a graphics driver module to monitor a task of the GPU determine when the task is complete determine an average task completion time for the task when the task is not complete and enable a sleep state for a processing circuit for a sleep state time when the average task completion time is greater than the sleep state time.

In a second example an apparatus may include a graphics driver module to disable the sleep state for the processing circuit upon expiration of the sleep state time or upon completion of the task.

In a third example an apparatus may include a graphics driver module to store a task start time when the task is not complete.

In a fourth example an apparatus may include a graphics driver module to determine a task completion time for the task based on the task start time when the task is complete.

In a fifth example an apparatus may include a graphics driver module to determine an average task completion based upon an average of one or more task completion times for one or more tasks.

In a sixth example an apparatus may include a graphics driver module to receive a request from an application for a completion status of the task and send a response to the application indicating whether the task is complete or not complete based upon the completion status.

In a seventh example an apparatus may include a graphics driver module to generate an event notification for the task receive the event notification indicating completion of the task and disable the sleep state for the processing circuit upon receiving the event notification.

In an eighth example an apparatus may include a graphics driver module to generate an event notification for the task receive the event notification indicating completion of the task and disable the sleep state for the processing circuit upon receiving the event notification wherein the event notification is generated by the graphics driver and is based upon a received interrupt.

In a ninth example an apparatus may include an application and a graphics driver module to return a task result to the processing circuit for the application upon completion of the task.

In a tenth example an apparatus may include a graphics driver module to receive a request for creation of a query object for the task and create the query object for monitoring the task on the GPU.

In an eleventh example an apparatus may include a graphics driver module to determine when the query object for the task is complete indicating completion of the task on the GPU.

In a twelfth example wherein a task is at least one of a computer graphics task a 3 dimensional 3D graphics task and a 2 dimensional 2D graphics task.

In a thirteenth example a computer implemented method may include monitoring a task of a graphics processing unit GPU by a graphics driver determining when the task is complete determining an average task completion time for the task when the task is not complete and enabling a sleep state for a processing circuit for a sleep state time when the average task completion time is greater than the sleep state time.

In a fourteenth example a computer implemented method may include disabling the sleep state for the processing circuit upon expiration of the sleep state time or upon completion of the task.

In a fifteenth example a computer implemented method may include storing a task start time when the task is not complete.

In a sixteenth example a computer implemented method may include determining a task completion time for the task based on the task start time when the task is complete.

In a seventeenth example a computer implemented method may include determining an average task completion based upon an average of one or more task completion times for one or more tasks.

In a eighteenth example a computer implemented method may include receiving a request from an application for a completion status of the task and sending a response to the application indicating whether the task is complete or not complete based upon the completion status.

In a nineteenth example a computer implemented method may include generating an event notification for the task receiving the event notification indicating completion of the task and disabling the sleep state for the processing circuit upon receiving the event notification.

In a twentieth example a computer implemented method may include generating an event notification for the task receiving the event notification indicating completion of the task and disabling the sleep state for the processing circuit upon receiving the event notification wherein the event notification is generated by the graphics driver and is based upon a received interrupt.

In a twenty first example a computer implemented method may include returning a task result to the processing circuit upon completion of the task.

In a twenty second example a computer implemented method may include receiving a request for creation of a query object for the task and creating the query object for monitoring the task on the GPU.

In a twenty third example a computer implemented method may include determining when a query object for the task is complete indicating completion of the task on the GPU.

In a twenty fourth example a computer implemented method may include a task that is at least one of a computer graphics task a 3 dimensional 3D graphics task and a 2 dimensional 2D graphics task.

In a twenty fifth example an article may include a computer readable storage medium containing a plurality of instructions that when executed enable a processing circuit to monitor a task of a graphics processing unit GPU by a graphics driver determine when the task is complete determine an average task completion time for the task when the task is not complete and enable a sleep state for a processing circuit for a sleep state time when the average task completion time is greater than the sleep state time.

In a twenty sixth example an article may include a computer readable storage medium containing a plurality of instructions that when executed enable a processing circuit to disable the sleep state for the processing circuit upon expiration of the sleep state time or upon completion of the task.

In a twenty seventh example an article may include a computer readable storage medium containing a plurality of instructions that when executed enable a processing circuit to receive a request from an application for a completion status of the task and send a response to the application indicating whether the task is complete or not complete based upon the completion status.

In a twenty eighth example an article may include a computer readable storage medium containing a plurality of instructions that when executed enable a processing circuit to generate an event notification for the task receive the event notification indicating completion of the task and disable the sleep state for the processing circuit upon receiving the event notification.

In a twenty ninth example an article may include a computer readable storage medium containing a plurality of instructions that when executed enable a processing circuit to generate an event notification for the task receive the event notification indicating completion of the task and disable the sleep state for the processing circuit upon receiving the event notification wherein the event notification is generated by the graphics driver and is based upon a received interrupt.

In a thirtieth example an article may include a computer readable storage medium containing a plurality of instructions that when executed enable a processing circuit to return a task result to the processing circuit upon completion of the task.

In a thirty first example an article may include a computer readable storage medium containing a plurality of instructions that when executed enable a processing circuit to store a task start time when the task is not complete.

In a thirty second example an article may include a computer readable storage medium containing a plurality of instructions that when executed enable a processing circuit to determine a task completion time for the task based on the task start time when the task is complete.

In a thirty third example an article may include a computer readable storage medium containing a plurality of instructions that when executed enable a processing circuit to determine an average task completion based upon an average of one or more task completion times for one or more tasks.

In a thirty fourth example an article may include a computer readable storage medium containing a plurality of instructions that when executed enable a processing circuit to receive a request for creation of a query object for the task and creating the query object for monitoring the task on the GPU.

In a thirty fifth example an article may include a computer readable storage medium containing a plurality of instructions that when executed enable a processing circuit to determine when a query object for the task is complete indicating completion of the task on the GPU.

In a thirty sixth example wherein the task is at least one of a computer graphics task a 3 dimensional 3D graphics task and a 2 dimensional 2D graphics task.

In an thirty seventh example an apparatus may include means for monitoring a task of a graphics processing unit GPU means for determining when the task is complete means for determining an average task completion time for the task when the task is not complete and means for enabling a sleep state for a processing circuit for a sleep state time when the average task completion time is greater than the sleep state time.

In a thirty eighth example an apparatus may include means for disabling the sleep state for the processing circuit upon expiration of the sleep state time or upon completion of the task.

In a thirty ninth example an apparatus may include means for storing a task start time when the task is not complete.

In a fortieth example an apparatus may include means for determining a task completion time for the task based on the task start time when the task is complete.

In a forty first example an apparatus may include means for determining an average task completion based upon an average of one or more task completion times for one or more tasks.

In a forty second example an apparatus may include means for receiving a request from an application for a completion status of the task and means for sending a response to the application indicating whether the task is complete or not complete based upon the completion status.

In a forty third example an apparatus may include means for generating an event notification for the task means for receiving the event notification indicating completion of the task and means for disabling the sleep state for the processing circuit upon receiving the event notification.

In a forty fourth example an apparatus may include means for generating an event notification for the task means for receiving the event notification indicating completion of the task and means for disabling the sleep state for the processing circuit upon receiving the event notification wherein the event notification is generated by the graphics driver and is based upon a received interrupt.

In a forty fifth example an apparatus may include means for returning a task result to the processing circuit upon completion of the task.

In a forty sixth example an apparatus may include means for determining when the query object for the task is complete indicating completion of the task on the GPU.

Some embodiments may be described using the expression one embodiment or an embodiment along with their derivatives. These terms mean that a particular feature structure or characteristic described in connection with the embodiment is included in at least one embodiment. The appearances of the phrase in one embodiment in various places in the specification are not necessarily all referring to the same embodiment. Further some embodiments may be described using the expression coupled and connected along with their derivatives. These terms are not necessarily intended as synonyms for each other. For example some embodiments may be described using the terms connected and or coupled to indicate that two or more elements are in direct physical or electrical contact with each other. The term coupled however may also mean that two or more elements are not in direct contact with each other but yet still co operate or interact with each other.

It is emphasized that the Abstract of the Disclosure is provided to allow a reader to quickly ascertain the nature of the technical disclosure. It is submitted with the understanding that it will not be used to interpret or limit the scope or meaning of the claims. In addition in the foregoing Detailed Description it can be seen that various features are grouped together in a single embodiment for the purpose of streamlining the disclosure. This method of disclosure is not to be interpreted as reflecting an intention that the claimed embodiments require more features than are expressly recited in each claim. Rather as the following claims reflect inventive subject matter lies in less than all features of a single disclosed embodiment. Thus the following claims are hereby incorporated into the Detailed Description with each claim standing on its own as a separate embodiment. In the appended claims the terms including and in which are used as the plain English equivalents of the respective terms comprising and wherein respectively. Moreover the terms first second third and so forth are used merely as labels and are not intended to impose numerical requirements on their objects.

What has been described above includes examples of the disclosed architecture. It is of course not possible to describe every conceivable combination of components and or methodologies but one of ordinary skill in the art may recognize that many further combinations and permutations are possible. Accordingly the novel architecture is intended to embrace all such alterations modifications and variations that fall within the spirit and scope of the appended claims.

