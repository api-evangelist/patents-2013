---

title: Transactional memory system with efficient cache support
abstract: Embodiments related to a transaction program. An aspect includes, based on determining that one instruction is part of an active atomic instruction group (AIG), determining whether a private-to-transaction (PTRAN) bit associated with an address of the one instruction in a main memory is set, the PTRAN bit being located in a main memory comprising a plurality of memory increments each having a respective directly addressable PTRAN bit in the main memory. Another aspect includes, based on determining that the PTRAN bit is not set: setting the PTRAN bit; adding a new entry to a cache structure and a transaction table including an old data state of the address of the one instruction stored in the cache structure and control information stored in the transaction table; and completing the one instruction as part of the active AIG.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08738862&OS=08738862&RS=08738862
owner: International Business Machines Corporation
number: 08738862
owner_city: Armonk
owner_country: US
publication_date: 20131023
---
The present application is a continuation of U.S. patent application Ser. No. 13 656 778 filed Oct. 22 2012 which is a continuation of U.S. patent application Ser. No. 12 550 844 filed Aug. 31 2009 which is now U.S. Pat. No. 8 566 524 Issued Oct. 22 2013 the content of which is incorporated by reference herein in its entirety.

This invention relates generally to processing within a computing environment and more particularly to a computing system with optimized support for transactional memory.

Current multiprocessor and multithreaded computing systems allow the performance of a single software application to be scaled to many times the possible performance of a single threaded application. Current software and hardware systems provide for the parallel processing of multiple threads of execution. Software applications can use existing thread libraries such as the POSIX pthread library to control the creation of multiple threads of parallel execution. The use of multiple threads works well for applications that operate on easily partitioned tasks and data course grain locks can be used to control access to the few shared data structures to prevent rare conflicts between the data updates of multiple threads.

Many software applications contain data structures that must be shared among multiple threads and have frequent concurrent inspections and updates of the shared data structures. These applications require additional modifications in order to obtain good scaling when using large numbers of threads. Applications which use multiple threads of execution that access shared data structures concurrently require the use of specialized data locking routines in order to produce a reliable outcome that is free from deadlocks and corrupted data. The majority of existing multithreaded applications in this category use fine grained software locks to achieve good performance and correct operation. Writing high performance multithreaded programs which use fine grained software locks is extremely difficult and requires expert programming skills. The lack of these skills in the software industry may limit the production of multithreaded applications which require the use of shared data structures and therefore the usefulness of multithreaded and multiprocessor computing systems for certain application classes including many forms of transaction processing.

Various transactional memory systems have been proposed and built to provide a simpler programming model for constructing multithreaded applications that need to control access to shared data structures. These systems allow software running on one thread of execution to optimistically assume that shared data structures can be updated without conflict with the accesses and updates of other threads of execution. The speculative updates to memory are kept pending until the transactional memory system confirms that no conflicts with storage accesses of other threads have occurred. The transactional memory system must be able to discard the pending speculative updates when conflicts between the stored accesses of multiple threads are detected.

A computer program product and computer system for a transaction program for managing memory access to a shared memory location for transaction data of a first thread the shared memory location being accessible by the first thread and a second thread are provided. An aspect includes executing a string of instructions to complete a transaction of the first thread beginning with one instruction of the string of instructions. Another aspect includes determining whether the one instruction is part of an active atomic instruction group AIG of instructions associated with the transaction of the first thread. Another aspect includes based on determining that the one instruction is part of the active AIG determining whether a private to transaction PTRAN bit associated with an address of the one instruction in a main memory of a computing system is set the PTRAN bit being located in the main memory the main memory comprising a plurality of memory increments and each of the plurality of memory increments having a respective directly addressable PTRAN bit in the main memory. Another aspect includes based on determining that the PTRAN bit associated with the address of the one instruction in the main memory is not set setting the PTRAN bit of the address associated with the one instruction in the main memory adding a new entry to a cache structure and a transaction table which together provide for entries in an active mode for the AIG for the one instruction the new entry including an old data state of the address of the one instruction stored in the cache structure and control information stored in the transaction table wherein all addresses inspected or modified by instructions of the active AIG remain pending until the computing system indicates that the storage locations should be committed and completing the one instruction as part of the active AIG. Another aspect includes executing the one instruction under a normal execution mode based on determining that the one instruction is not part of an active AIG.

Additional features and advantages are realized through the techniques of the present invention. Other embodiments and aspects of the invention are described in detail herein and are considered a part of the claimed invention. For a better understanding of the invention with advantages and features refer to the description and to the drawings.

An exemplary embodiment of the present invention is directed to a transactional memory system that combines a data cache structure e.g. a hardware buffer with a log based structure e.g. a software table to hold speculative transaction data. An exemplary embodiment provides for old data states to be stored in cache and eliminates the need to move old data states into the log based structure. However in the event that the data cache structure cannot store the old data states e.g. it becomes full an exemplary embodiment provides for storing the old data states in the log based structure.

Exemplary embodiments provide a computing system which uses a combination of a private to transaction PTRAN tag attached to each increment of real system memory a log of speculative loads and stores and a data cache structure storing old data states associated with the speculative loads and stores to provide an improved implementation of a transactional memory system. An exemplary embodiment uses a log with the added mark bit employed as a PTRAN tag and associated with every increment of real system memory. Hardware is provided to quickly detect conflicts between the storage accesses of transactions running on multiple threads of execution. The use of the tag in memory and associated conflict detection hardware included in an exemplary embodiment of the present invention provides a much faster transactional memory system with much less overhead when compared to existing systems. The complexity of an exemplary embodiment is lower than prior attempts at using additional cache coherency states for conflict detection especially for systems with large numbers of processors and associated interconnections.

An exemplary embodiment of the present invention uses a combination of the cache and the main memory array of the computing system to hold the speculative data including both an old data state and control information and can support very long transactions. An exemplary embodiment utilizes the cache to store old data states and the main memory array also referred to herein as main storage or main memory to store transaction and address information e.g. control information associated with the speculative loads and stores. In addition the main memory array is utilized to store any overflow old data states that do not fit into the portion of the cache e.g. a buffer reserved for the old data states. As used herein the term old data state refers to the original non speculative data at storage locations that are the targets of the store instructions inside of a transaction. An exemplary embodiment provides the ability to check the address of a new memory access without a long search process for common cases. Likewise it is an improvement over software only transactional memory systems since the conflict detection and use of the tag in memory eliminates some of the software overhead associated with tracking the speculative state of transactions. It also provides the ability to detect storage conflicts at a very fine level down to a single byte as opposed to prior art software systems that track updates to entire software objects which may be hundreds or thousands of bytes. Existing software systems will either give frequent over indication of potential data conflicts or incur very large software path length penalties when attempting to track the updates to individual components of software objects. A further advantage of eliminating the bandwidth required to do reading and writing to the main memory is realized by providing a cache location for storing old data states.

Transactional memory systems have been proposed as illustrated by U.S. Pat. No. 7 536 517 hereinafter the 517 patent which teaches the use of software enlistment records associated with memory locations that have been accessed by transactions. The system described in the 517 patent also uses a version value in the enlistment record . FIG. 3 of the 517 patent includes an operation locate enlistment record of memory location. The text describing gives the example of the enlistment record being part of a software object at the referenced memory address and being created with the use of a software transactional memory interface. The 517 patent uses version numbers associated with each enlistment record and needs to deal with cases where the version number exceeds the maximum number supported by the enlistment record. In hindsight after learning of the details of an exemplary embodiment of the present invention it will be recognized that these features of the recent developments in transaction memory systems are not needed and can be improved upon.

Earlier and now long ago as pointed out in the development of fast paced computing systems developments summarized by David A. Wood in his article entitled An Overview of Hardware Alternatives Transactional Memory Workshop Apr. 8 2005 it was Chang and Mergen of IBM described in 801 Storage Architecture and Programming who proposed using a lock bit associated with each segment of virtual memory. Their system provided an ability to detect concurrent accesses of storage locations by multiple threads but restricted the total number of concurrent threads that could operate on any single virtual memory segment when the transaction locking mechanism becomes active. Large virtual memory page tables which are required by Chang and Mergen to execute concurrent threads impose a performance penalty on all threads of execution that use virtual memory not just those that execute transactions so the Chang and Mergen suggestions became an anecdote in the prior art as Woods said No one seems to be looking at what they learned. An exemplary embodiment of the present invention uses a transaction table that is distinct from the virtual memory page tables of the system in combination with a data cache structure to store information associated with the speculative loads and stores.

Unknown to Woods in the Chang and Mergen IBM Yorktown facility there had been ongoing laboratory developments relating to transactional memory systems including the memory system described in U.S. Pat. No. 7 350 034 hereinafter the 034 patent filed Jun. 20 2005 and entitled Architecture Support of Best Effort Atomic Transactions for Multiprocessor Systems .

The 034 patent describes a transactional memory system which focuses on using caches as buffers for data accessed by atomic transactions . The 034 patent teaches forcing the failure of a transaction when the system detects a buffer overflow and does not propose dealing with the case of speculative data being evicted from the cache. A buffer overflow will result if too many transactional loads or stores target the same cache congruence class. The percentage of transactions which overflow the cache and fail will be proportional to the number of loads and stores contained in a transaction. Long transactions will fail more often.

Other systems have been proposed which use a cache to implement a conflict detection scheme and to capture speculative data which overflows the cache. An exemplary embodiment of the present invention does not rely primarily on data cache states for conflict detection. The required specialized cache states cause an undesired increase in complexity and also make it difficult to add the required detection and isolation mechanisms to existing multiprocessor cache coherency designs. Nevertheless there are numerous attempts to exploit the cache which have been tried besides the approach described in the 034 patent. One approach is to use a before image log and a cache coherency states to implement a conflict detection scheme. Another approach is described by Ananian et al. in their paper entitled Unbounded Transactional Memory Research Abstracts 2006 CSAIL Publications and Digital Archive which describes a transactional memory system which uses a single unsorted linear array data structure to capture speculative data which overflows data caches. They use an extra bit per cache set the 0 bit to indicate if that set has overflowed and another bit per cache entry the T bit to indicate that the entry holds speculative data. The linear array data structure does provide the ability to support longer transactions but it does not provide the fast detection capability of exemplary embodiments of the present invention. The linear array in Ananian needs to be searched for any cache access that targets the set that overflowed . This can be a long process for transactions that cause many overflows. Rajwar Herlihy and Lai take a similar approach as Ananian in their paper entitled Virtualizing Transactional Memory 2005 IEEE . Rajwar et al. also use a data cache as the primary mechanism to track the speculative state associated with transactions. Speculative data which is forced out of the caches is moved to the transaction address data table XADT overflow area in virtual memory. The detection of a possible conflict with an address that is part of the XADT requires a slow linear search of the XADT. Rajwar describes the use of filters to eliminate some of these searches but there are many cases where the searches will still need to be done.

In addition to the above summarized developments in the field many software interfaces and instruction set modifications have been proposed for the support of transactional memory. The paper Architectural Semantics for Practical Transactional Memory McDonald et al Computer Systems Laboratory Stanford University 2006 compares some of the proposals and provides references for many others and is incorporated herein by reference in its entirety.

Many software interfaces and instruction set modifications have been proposed for the support of transactional memory. Exemplary embodiments of the present invention may be used in combination with any of them in order to provide high performance transactional memory operations without incurring a large increase in hardware or software complexity. An exemplary embodiment is described for the IBM PowerPC architecture but anyone skilled in the art could apply the same approach to any other architecture such as IBM s zSeries IBM s pSeries with the P3 P4 P5 processors and even IBM s System 38 and its AS 400 can utilize the support of an exemplary embodiment of the present invention as well as other computer systems such as Sun Microsystems SPARC and the Intel IA 32 etc. Anyone skilled in the art could extend an exemplary embodiment for use with other application programming interfaces APIs that may be created for other specialized versions of transactional memory implementations.

An exemplary embodiment of the present invention uses a hardware bit or bits associated with all memory locations not just those that are currently part of an active transaction. An exemplary embodiment uses the added hardware bit or bits to provide much faster execution of transactions than that which can be obtained using the process described n the 517 patent. An exemplary embodiment uses a data cache structure to hold old data states in conjunction with an improved transaction table as a log to optimize the memory usage and provides a system which uses less memory than would be used by other systems like that described in the 517 patent yet an exemplary embodiment can execute applications developed for these other systems. An exemplary embodiment provides one or more PTRAN bits for every storage increment. There is no need in the current embodiment for an indirect method of locating the PTRAN bit. An exemplary embodiment provides a much faster indication of potential conflicts since the PTRAN bit is a directly addressable part of the memory location to be marked. An exemplary does not need an interface such as that described in the 517 patent and achieves its benefit using hardware and firmware to update and reset the PTRAN bit. An exemplary embodiment does not require application software to be aware of the state of the PTRAN bit or bits although one may provide a direct interface if desired. An exemplary embodiment is also optimized for a short commit processing time. An exemplary embodiment does not require the use of a version number for each storage location.

An advantage of an exemplary embodiment is that it uses a transaction table that is distinct from the virtual memory page tables of the system. This enables very large transactions to be processed and provides conflict detection down to a single byte. An exemplary embodiment has no limit on the number of concurrent threads that can simultaneously access memory locations in the same virtual memory segment. An exemplary embodiment performs conflict detection on physical memory addresses or real addresses and only restricts simultaneous access at the granularity of this conflict detection. This granularity can differ for various implementations of exemplary embodiments but will typically be on the order of bytes. If the Chang and Mergen system tries to use large numbers of concurrent threads that system could not provide similar benefits without using extremely large virtual page table formats and consequently incurring a performance penalty. An exemplary embodiment of the present invention does not impose this performance penalty. Another advantage of an exemplary embodiment is that old data states associated with speculative loads and stores is stored in a data cache structure located in cache thus saving on any bandwidth and clock cycles required to move the old data states into the transaction table. If the data cache structure becomes full the old data states are stored in the transaction table as a backup to the data cache structure.

Turning now to the drawings in greater detail it will be seen that in there is a computing system illustrating an exemplary embodiment of the present invention which has one or more microprocessors coupled to a physical memory array via an interconnection element . The microprocessors include a cache also referred to herein as a cache storage and the caches include a cache structure for storing old data states associated with the transactions. In an exemplary embodiment the cache structure is a hardware buffer containing 32 cache lines. Other cache structures and number of cache lines may be implemented by exemplary embodiments and may be selected based on criteria such as application and system requirements. The physical memory array stores transaction data and PTRAN tags which are associated with every increment of real system memory. The interconnection element can be implemented as a shared bus or crossbar switch. An exemplary embodiment applies to systems which use any other scheme of interconnecting physical memory to a multiprocessor system which may be implemented in one or more chips. The memory could be broken down into smaller portions and distributed across private connections to each of the central processing unit CPU chips as done for some IBM systems using the POWER4 microprocessor or for Amdahl s AMD Opteron based servers. The microprocessors and memory controllers may be located together on a single silicon chip or they may be spread across multiple chips.

The physical memory of the computing system is divided into n increments. One or more PTRAN bits associated with every increment of real system memory are provided for each of the n increments. An exemplary embodiment allows for the choice of any memory increment size and the best choice will depend on workload characteristics hardware costs and data caching structure used in the target system. An increment of 16 bytes is used in the illustrated embodiment. The PTRAN bit s are used to indicate whether or not a data entry in memory is part of the speculative memory state of an uncommitted transaction that is currently active in the system.

Special new instructions BEGIN AIG END AIG in a nested AIG code sequence are used to mark the beginning and end of a group of instructions. The instructions which execute between the special new instructions are referred to as an atomic instruction group AIG illustrated by AIG instructions Instruction A0 Instruction A1 Instruction A2 . Additional storage access rules are used when a processor is executing instructions which are part of an AIG. All of the storage locations modified by the AIG group of instructions are updated in memory in an atomic fashion. The updates to the storage locations are kept pending until the processor and or software application indicates that they should be committed . All of the updates are either committed to normal memory at once or they are discarded. The results are discarded when hardware and or software detects a conflict between the storage accesses of multiple AIGs that are executing concurrently in the multiprocessor system. An exemplary embodiment provides a way for hardware to quickly detect potential conflicts between the storage accesses of multiple AIGs. Although an exemplary embodiment uses special new instructions to mark the boundaries of a transaction any other method could be used to identify a group of memory locations that are to be updated in an atomic fashion. An exemplary embodiment is compatible with any number of software interfaces that may be used to implement a transactional memory system. An exemplary embodiment can provide the same fast conflict detection for any system which is attempting to provide an atomic update of multiple storage locations. An exemplary embodiment also applies to systems which mark the boundaries of an instruction group in any other ways including compiler generated hints attached to other instructions internal microprocessor commands generated by internal microcode or millicode.

A PTRAN tag is one or more bits associated with an increment in memory which is set for all memory accesses generated by instructions that are part of an AIG. A processor inspects the bit before attempting to set it this enables the quick detection of potential conflicts with other AIGs that are concurrently executing on other threads. The setting of the bit may be accomplished by a test and set TS operation of the IBM z Architecture or any other equivalent operation that enables an atomic update in a multithreaded or multiprocessor system.

Turning now to it will be seen that transaction tables are created as part of the real system memory also referred to herein as main storage which is illustrated here as physical memory . The transaction tables could also created in logical or virtual memory. Any system to map the logical system memory to the physical system memory can be used and there are numerous examples known in the art which can be used such as those in the IBM zSeries IBM pSeries Sun Microsystems SPARC Intel s IA 32 etc. A transaction table entry is made when instructions that are part of an AIG cause a memory location to be inspected or updated. A thread identifier is associated with each transaction table . A next entry register is used as an index into the transaction table and indicates which entry should be written next. A table origin indicates the address of the first entry of the transaction table for its thread . The transaction table is used to hold additional information beyond the simple information that is associated with the PTRAN tag bit or bits that are associated with the memory location that has been inspected or updated. This additional information is related to the speculative state associated with an AIG. In an illustrated IBM zSeries or pSeries CPU embodiment which is described herein a single PTRAN bit is utilized. In this case the combination of the transaction table and the cache structure will contain all additional information about the speculative state e.g. the combination will contain entries in an active mode for the AIG therefore the PTRAN bit will only indicate that a physical address is involved in an AIG. This is illustrated for transaction table A as the address the transaction information identifier and old or new data . As described herein transaction table A only contains the old data if the cache structure cannot store the old data. This may occur when the cache structure becomes full. In this manner the transaction table A is used as a backup to the cache structure for storing the old data states. Other embodiments may use additional PTRAN bits which can be used by hardware or software to speed the processing of certain events involved in the processing of AIGs or the speculative states of any other transactional memory system. The combination of using just a single bit in memory and associating that bit with a more complete description of the transactional state in the transaction tables combined with the cache structure provides a transactional memory system which requires very little hardware overhead without incurring the performance penalty seen in prior art software transactional memory systems.

Turning again to it will be seen that an entry in the transaction table A for example includes the address that has been inspected or updated inside of an AIG a transaction information field and a data field . A store instruction that is part of an AIG will cause the system to copy the old data value the old data state from the original storage location to the cache structure for that address and the new speculative data is placed in the main storage location e.g. the physical memory . If the cache structure cannot store the old data state then it is stored in the transaction table in the data field .

An exemplary embodiment can be made to work with the new values held in the cache structure if desired. Placing the old data value in the cache structure allows the system to be optimized for the case where most transactions are successful. The old data can be discarded quickly when it is no longer needed when a transaction is committed permanently to memory by changing the pointer to the cache structure or by clearing the contents of the cache structure . The transaction information field of a transaction table entry includes any transaction information that is needed to make detailed decisions about the need to cause a transaction failure. It also has provisions for additional information to allow efficient support of nested transactions virtualized transactions or other extensions of the transactional memory architecture. In an exemplary embodiment the transaction information field includes an indication of whether the storage access of the associated address was a load type access or a store type access. The transaction information field can also indicate whether the address is shared among multiple AIGs in the system.

An override of this AIG active mode may be provided. The override could be associated with the logical memory segment or logical memory page which contains the target address. An override forces the system to treat the storage request as normal in spite of the fact that the request is part of an AIG. If the override is active then the result of the decision will cause normal processing to take place. Assuming that an AIG is active and the override is not then the associated PTRAN bit is inspected at an inspection step . A load instruction inside of an AIG detects upon inspection the state of the PTRAN bit. When the PTRAN bit is already set it is due possibly to the actions of another thread executing on the same processor or on another processor. If at the inspection step it is found that the PTRAN bit is not set then the processor sets the PTRAN bit and make a record of the access in the transaction table for the active AIG by adding to the transaction table at the set PTRAN block and then the complete load can continue . If the PTRAN bit is already set the address which caused this potential conflict is compared with the addresses already entered in the processor s transaction table. If the PTRAN bit was set when tested at the inspection block by another load earlier in the same AIG it is already part of the AIG as tested and determined and then the complete load may continue . Each transaction table contains the addresses for a particular AIG. Similarly in an exemplary embodiment each cache structure contains old data states for a particular AIG. In an exemplary embodiment each cache structure corresponds to a transaction table and the same index is used for storing the old data states and the control information associated with each instruction being tracked in the AIG. Accordingly if the address was not already part of the AIG as tested and determined then the address for the load is not found in the processor s transaction table and then the processor checks whether the address is enabled for sharing among AIGs in a determination step for AIG sharing . If the address is not currently enabled for sharing among multiple AIGs the processor may signal other processors in the system to request a shared AIG access for this address during the determination step whether sharing is allowed among AIGs . A shared access can be granted if no other AIG in the system has speculatively written the storage location. If the shared access is not granted then the AIG fails otherwise the load address is added to the transaction table and the transaction information field is updated to indicate that the address is a load access that is shared among multiple AIGs in the system.

The store processing flowchart shows the actions for processing a store that is part of an AIG. When a processor attempts a store type access initially a store decision is made to determine whether the access is part of an AIG and whether the special storage access rules for AIG accesses apply. The mode of the processor is checked in a similar method as previously described for load accesses. If the special mode of operation under which the special access rules for AIG accesses apply is not active then the store is treated as a normal store . Assuming that an AIG is active the associated PTRAN bit is inspected at the store process inspection block . If the PTRAN bit is not already set then the PTRAN bit is set at the store transaction step and a new entry is added to the transaction table . The old data is moved to the cache structure the address is written to the new entry and the transaction information field is updated. As described below in reference to if the cache structure is unable to store the old data state then the old data state is stored in the data field of the transaction table. The transaction information field is marked to indicate that the access associated with this entry was a store type access. The new store data is written to memory after the setting of the PTRAN bit is completed. If the inspection of the PTRAN bit indicates that the bit was already set then a decision is made based on whether the current store address is already part of an AIG which is active on the processor. The transaction table for the processor is examined if it is determined that the address is present in the transaction table then the transaction information field for the entry is checked and a decision as to shared access entry is made. If the transaction information field indicates that the entry is a load type access entry that is shared among multiple AIGs the transaction fails otherwise the transaction information field for the associated entry is updated to indicate a store type access and the store is processed .

Turning now to the commit processing flowchart of it will be seen that an exemplary embodiment includes a set of actions completed when the last instruction in an AIG has been processed and the entire group is ready to be committed permanently to memory as determined initially at a test step . If not the processing continues in AIG mode . An AIG is committed to memory when the processing of the loads and stores of the AIG according to flowcharts from and does not result in a transaction failure. In the case of AIG success then testing determines the last instruction in an AIG has been processed and the entire group is ready to be committed permanently to memory. Then the transaction table is examined and each entry for the AIG to be committed is read and its associated PTRAN bit is reset in memory at the transaction table commit step determination.

A specialized hardware engine may be used to complete the performance of this commit operation. A combination of processor caches multiprocessor coherency actions and an exemplary embodiment can be used to provide software with the illusion that all of the memory updates for a single AIG occur simultaneously even though the main memory storage arrays are not updated simultaneously. During the commit processing the resetting of the PTRAN bits continues until the last valid entry in the transaction table has been determined to be reached . At this point the AIG is considered to be committed and the performance by the engine therefore completes .

Some conditions prevent the completion of an AIG. These conditions may be detected during load processing while executing an AIG or during store processing while executing an AIG . There are many other possible processor conditions that may cause the need to abort the processing of an AIG. These include error conditions detected in the system as well as other conditions that would require significant additional hardware support to enable the processor to handle them correctly. Many prior art transactional memory architectures include provisions for the abort of transactions and for a subsequent retry. Prior art software constructs can be used together with an exemplary embodiment to eliminate the need to provide hardware to deal with all possible special cases. A simple example is the case of a timer interrupt in the middle of processing an AIG. The interrupt may cause the processor to spend a large amount of time running code that is not part of the partially completed AIG. It may not be desirable for the processor to keep the AIG active during this time. The system can force a transaction failure for any AIG that is currently executing when a timer interrupt occurs. A similar approach can be used for any other special case events occurring in the processor.

Transaction failures or forced retries are handled according to the process of the rollback processing flowchart for rollback processing shown in . Turning now to it will be seen that the lack of a transaction failure condition allows the processor to continue in the AIG active mode . An exemplary embodiment uses an eager policy with respect to detecting transaction failures and causing transaction rollback. Also an exemplary embodiment may be used in systems that wait until the end of a transaction to take the actions required for a rollback. The memory updates executed as part of an AIG are either committed to normal main storage at the same time or they are discarded with a rollback operation .

Upon finding a transaction failure condition failure several additional steps are required . Rollback transaction table processing entry steps provide that the transaction table and the cache structure for the AIG are inspected and any old data or old data states is written back to the main memory address indicated in the entry. The PTRAN bit for the associated address is reset. The rollback processing continues until the last valid entry in the table has been processed . After the last valid entry has been processed the rollback is complete . The actions taken by the processor at this point will differ based upon various software architectures for transactional memory. Any transactional memory architectures described in the background may be used. In some cases the AIG will be retried from the beginning. In other cases special software handlers will be invoked to deal with the transaction failure. An exemplary embodiment may be used with any of these different architectures.

An exemplary embodiment supports the execution of nested transactions. A second AIG may be included within the scope of the first AIG. Each BEGIN AIG special instruction statement causes the system to create a transaction table and to associate the table with the AIG. Decisions about whether or not a storage address belongs to an AIG may include the inner AIG A or the combination of the inner and outer AIGs A B . The END AIG special instruction statement ends the transaction sequence but as shown a sequence for a specific transaction transaction B may be nested within another sequence transaction A . The use of multiple transaction tables may be used to support many nesting architectures for transactional memory. Multiple versions of the old data or the old data state may be stored in any number of cache structures or transaction tables at any nesting depth. Prior art transactional memory systems that rely on data caches to hold speculative states are unable to provide similar support for nested transactions without adding additional state information to cache directories and adding additional complexity to the cache coherency protocol. Nesting support on prior art systems would impose a large hardware complexity penalty on those designs. An exemplary embodiment can also be extended to include a combined transaction table cache structure that includes entries from both the inner AIG Instruction B0 Instruction B1 and the outer AIG Instruction A0 Instruction A1 Instruction A2 . This combined transaction table cache structure may be used in place of the individual transaction tables and cache structures or in addition to the individual transaction tables and cache structures.

There are many additional hardware features that can be added to exemplary embodiments to speed the processing of the transaction table manipulations and the setting and resetting of the PTRAN bit s . Since the PTRAN bit is part of the main storage data it can be cached in the normal data caches of the system. The transaction tables are also part of main storage and can also be cached. As used herein the term main storage refers to an array of DRAM memory chips. Additional control information can be added to the data caches to indicate whether a specific address has been enabled for shared AIG access and therefore eliminate the need to search the transaction table for some cases.

The capabilities of exemplary embodiments of the present invention as described above can be implemented in software firmware hardware along with some combination of software and firmware.

An exemplary embodiment identifies the beginning of an AIG after decoding of an instruction . If it is determined that a BEGIN AIG instruction has been decoded the processor enters a new mode of execution AIG MODE otherwise the instruction is executed as usual and processing continues with the next instruction .

Prior to entering AIG MODE the architected state of the processor is saved in the same manner that a traditional program call is handled in the IBM Z Series architecture. Any similar state saving mechanism may be used on any other processor architecture. The processor may return directly to this saved state if the AIG fails or may return to this state after a series of other error handling routines have been invoked. While in AIG MODE decoding of instructions continues . If a load or store is decoded then special handling of these loads and stores is required . The steps required for the processing of a load inside of an AIG are described in those for a store inside of an AIG are described in . After loads and stores in an AIG are processed it is determined whether there has been an AIG failure as described in the descriptions of and . If there is a failure then special handlers are invoked . The actions of the special handlers for transaction failure may vary depending on the architecture of the system using the exemplary embodiment. Many methods of dealing with transaction failures have been described in the prior art any of them could be used for this purpose. The possible methods include retrying the transaction from the beginning for a set number of attempts waiting for the condition that caused the failure to change calling specialized software routines to resolve conflicts among threads etc. These possible failure handlers may require the rollback of the AIG which caused the failure . If no failure was detected then it is determined whether the load or store was the last instruction of the AIG . If the instruction is the last instruction in the AIG then the AIG is committed using the process described in . The processor then exits the AIG Mode and continues with the next sequential instruction after the AIG .

The decoding of instruction other than loads and stores inside of an AIG does not necessarily require special processing . If the instruction is not a load or store type instruction then it is determined whether the instruction is another BEGIN AIG . Nested AIG instructions require special handling . The prior art contains many different ways of handling nested transactions. An exemplary embodiment can be used to support any of them. The nested AIG handler for an exemplary embodiment adds the instructions of the inner AIG to the outer AIG creating a single larger AIG. Other embodiments of the invention may provide different rules of processing for loads and stores that are part an inner nested transaction as well as special rules for the commitment and failure handling of inner nested transactions. If it is determined that the instruction is not a BEGIN AIG then the instruction is executed and it is next determined whether the instruction is the last instruction of the AIG. The preferred embodiment uses the decoding of an END AIG instruction to indicate that the last instruction of an AIG has been reached. If the last instruction of the AIG has been reached then the AIG is committed to memory and the processor exits the AIG MODE of operation .

As described previously the cache structure is located in cache storage this provides for fast data access when writing and reading the old data states. In an exemplary embodiment the cache structure is a hardware buffer however other software and or hardware implementations may be implemented by exemplary embodiments. In an exemplary embodiment a hardware buffer corresponds to a transaction table and there is one buffer logical or physical implemented for each transaction table . In this embodiment the next entry register for the transaction table may be utilized by the corresponding buffer for storing and retrieving the old data states. In an other exemplary embodiment one buffer is utilized by multiple transaction tables to store the old data states. In this embodiment a separate index is maintained for the buffer and a correlation between old data states and addresses in a transaction table is maintained.

At block it is determined if the old data state can be stored in the buffer. In the embodiment depicted in the old data state cannot be stored in the buffer if the buffer is full. In an exemplary embodiment a bit in the control structure of the cache is utilized to indicate that the buffer is full. If the buffer is full then block is performed and the old data state is written to the transaction table at the location indicated by the next entry register i.e. same row in the transaction table as the corresponding address . A bit is set in the header of the transaction table to indicate that the old data state is located in the transaction table.

If the buffer is not full as determined at block then processing continues at block . At block the old data state is written to the buffer.

In the embodiment depicted in each transaction table has a corresponding buffer and the old data state is written to the buffer at the location indicated by the next entry register . A bit is set in the transaction table to indicate whether the old data state is located in the buffer or the data field of the transaction table.

Technical effects and benefits include a high speed transactional memory system with much less overhead when compared to existing systems. In addition bandwidth requirements and processing time are reduced by providing a cache location for storing old data states associated with speculative load and store instructions. Further system reliability and availability is improved by using a transaction table in main storage as a back up to the cache when the cache structure becomes full.

The terminology used herein is for the purpose of describing particular embodiments only and is not intended to be limiting of the invention. As used herein the singular forms a an and the are intended to include the plural forms as well unless the context clearly indicates otherwise. It will be further understood that the terms comprises and or comprising when used in this specification specify the presence of stated features integers steps operations elements and or components but do not preclude the presence or addition of one or more other features integers steps operations elements components and or groups thereof.

The corresponding structures materials acts and equivalents of all means or step plus function elements in the claims below are intended to include any structure material or act for performing the function in combination with other claimed elements as specifically claimed. The description of the present invention has been presented for purposes of illustration and description but is not intended to be exhaustive or limited to the invention in the form disclosed. Many modifications and variations will be apparent to those of ordinary skill in the art without departing from the scope and spirit of the invention. The embodiment was chosen and described in order to best explain the principles of the invention and the practical application and to enable others of ordinary skill in the art to understand the invention for various embodiments with various modifications as are suited to the particular use contemplated.

As will be appreciated by one skilled in the art aspects of the present invention may be embodied as a system method or computer program product. Accordingly aspects of the present invention may take the form of an entirely hardware embodiment an entirely software embodiment including firmware resident software micro code etc. or an embodiment combining software and hardware aspects that may all generally be referred to herein as a circuit module or system. Furthermore aspects of the present invention may take the form of a computer program product embodied in one or more computer readable medium s having computer readable program code embodied thereon.

Any combination of one or more computer readable medium s may be utilized. The computer readable medium may be a computer readable signal medium or a computer readable storage medium. A computer readable storage medium may be for example but not limited to an electronic magnetic optical electromagnetic infrared or semiconductor system apparatus or device or any suitable combination of the foregoing. More specific examples a non exhaustive list of the computer readable storage medium would include the following an electrical connection having one or more wires a portable computer diskette a hard disk a random access memory RAM a read only memory ROM an erasable programmable read only memory EPROM or Flash memory an optical fiber a portable compact disc read only memory CD ROM an optical storage device a magnetic storage device or any suitable combination of the foregoing. In the context of this document a computer readable storage medium may be any tangible medium that can contain or store a program for use by or in connection with an instruction execution system apparatus or device.

A computer readable signal medium may include a propagated data signal with computer readable program code embodied therein for example in baseband or as part of a carrier wave. Such a propagated signal may take any of a variety of forms including but not limited to electro magnetic optical or any suitable combination thereof. A computer readable signal medium may be any computer readable medium that is not a computer readable storage medium and that can communicate propagate or transport a program for use by or in connection with an instruction execution system apparatus or device.

Program code embodied on a computer readable medium may be transmitted using any appropriate medium including but not limited to wireless wireline optical fiber cable RF etc. or any suitable combination of the foregoing.

Computer program code for carrying out operations for aspects of the present invention may be written in any combination of one or more programming languages including an object oriented programming language such as Java Smalltalk C or the like and conventional procedural programming languages such as the C programming language or similar programming languages. The program code may execute entirely on the user s computer partly on the user s computer as a stand alone software package partly on the user s computer and partly on a remote computer or entirely on the remote computer or server. In the latter scenario the remote computer may be connected to the user s computer through any type of network including a local area network LAN or a wide area network WAN or the connection may be made to an external computer for example through the Internet using an Internet Service Provider .

Aspects of the present invention are described below with reference to flowchart illustrations and or block diagrams of methods apparatus systems and computer program products according to embodiments of the invention. It will be understood that each block of the flowchart illustrations and or block diagrams and combinations of blocks in the flowchart illustrations and or block diagrams can be implemented by computer program instructions. These computer program instructions may be provided to a processor of a general purpose computer special purpose computer or other programmable data processing apparatus to produce a machine such that the instructions which execute via the processor of the computer or other programmable data processing apparatus create means for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

These computer program instructions may also be stored in a computer readable medium that can direct a computer other programmable data processing apparatus or other devices to function in a particular manner such that the instructions stored in the computer readable medium produce an article of manufacture including instructions which implement the function act specified in the flowchart and or block diagram block or blocks.

The computer program instructions may also be loaded onto a computer other programmable data processing apparatus or other devices to cause a series of operational steps to be performed on the computer other programmable apparatus or other devices to produce a computer implemented process such that the instructions which execute on the computer or other programmable apparatus provide processes for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

As described above embodiments can be embodied in the form of computer implemented processes and apparatuses for practicing those processes. In exemplary embodiments the invention is embodied in computer program code executed by one or more network elements. Embodiments include a computer program product as depicted in on a computer usable medium with computer program code logic containing instructions embodied in tangible media as an article of manufacture. Exemplary articles of manufacture for computer usable medium may include floppy diskettes CD ROMs hard drives universal serial bus USB flash drives or any other computer readable storage medium wherein when the computer program code logic is loaded into and executed by a computer the computer becomes an apparatus for practicing the invention. Embodiments include computer program code logic for example whether stored in a storage medium loaded into and or executed by a computer or transmitted over some transmission medium such as over electrical wiring or cabling through fiber optics or via electromagnetic radiation wherein when the computer program code logic is loaded into and executed by a computer the computer becomes an apparatus for practicing the invention. When implemented on a general purpose microprocessor the computer program code logic segments configure the microprocessor to create specific logic circuits.

The flowchart and block diagrams in the Figures illustrate the architecture functionality and operation of possible implementations of systems methods and computer program products according to various embodiments of the present invention. In this regard each block in the flowchart or block diagrams may represent a module segment or portion of code which comprises one or more executable instructions for implementing the specified logical function s . It should also be noted that in some alternative implementations the functions noted in the block may occur out of the order noted in the figures. For example two blocks shown in succession may in fact be executed substantially concurrently or the blocks may sometimes be executed in the reverse order depending upon the functionality involved. It will also be noted that each block of the block diagrams and or flowchart illustration and combinations of blocks in the block diagrams and or flowchart illustration can be implemented by special purpose hardware based systems that perform the specified functions or acts or combinations of special purpose hardware and computer instructions.

