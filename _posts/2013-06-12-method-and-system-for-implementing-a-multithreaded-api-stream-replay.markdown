---

title: Method and system for implementing a multi-threaded API stream replay
abstract: A method for debugging and includes receiving a request for capturing a frame generated by a graphics application implementing application threads executing function calls. The function calls are associated with one or more thread specific resources used at the beginning of the capturing process. For each application thread, a corresponding state is determined for each thread specific resource utilized, and a corresponding capture stream is established. For each application thread, executed function calls are captured into the corresponding capture stream. A plurality of captured function calls is arranged in the order they were executed by the graphics application. For each capture stream, a corresponding replay thread is established. Application threads, capture streams, and replay threads exist in a one-to-one-to-one relationship. Captured function calls are replayed in order, wherein each captured function call is executed in a corresponding replay thread based on which application thread executed the captured function call.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09477575&OS=09477575&RS=09477575
owner: NVIDIA CORPORATION
number: 09477575
owner_city: Santa Clara
owner_country: US
publication_date: 20130612
---
This application is related to U.S. patent application Ser. No. 12 709 380 entitled DEBUGGING AND PERFORMANCE ANALYSIS OF APPLICATIONS having a filing date of Feb. 19 2010 which is herein incorporated by reference in its entirety.

The content of a single frame in a modern graphics application continues to expand as graphics processing units GPUs increase in capability. This can lead to errors and performance problems that are difficult to analyze in real time while the application renders the final image. The use of multiple rendering targets composited to construct the final image only contributes to the difficulty of debugging and performance tuning.

A previous frame capture system describes a system for multi threaded application programming interface API stream capture and single threaded API stream replay. During API stream capture each thread is given an object into which it can store a tokenized API stream. Each tokenized function or method is executed in a single thread.

This system is sufficient for capturing and replaying APIs where the API operates to process global data that are explicitly specified either as function or method parameters or using a method call. In the latter case the object invoking the method is explicit. However the system is insufficient particularly from a performance perspective when data have thread affinity or when the API makes use of data that is implicitly tied to a thread. In the worst case scenario the single threaded replay mechanism might need to set thread specific state for each function or method that is executed. This would lead to very poor replay performance.

In embodiments of the present invention a computer implemented method for debugging and performance analysis is described. The method includes receiving a request for capturing a frame generated by a graphics application wherein the graphics application implements a plurality of application threads for executing a plurality of function calls generating the frame. The plurality of function calls is associated with one or more thread specific resources used at an entry point of the capturing process. The method includes for each application thread determining a corresponding state for each corresponding thread specific resource utilized. The method includes for each application thread establishing a corresponding capture stream wherein application threads and capture streams exist in a one to one relationship. The method includes for each application thread capturing executed function calls into the corresponding capture stream. The method includes ordering a plurality of captured function calls captured across the plurality of application threads in the order they were executed by the graphics application. The method includes for each capture stream establishing a corresponding replay thread wherein capture streams and replay threads exist in a one to one relationship. The method also includes replaying a plurality of captured function calls in the order they were captured wherein a captured function call is executed in a corresponding replay thread based on which application thread executed the captured function call.

In other embodiments of the present invention a non transitory computer readable medium is disclosed having computer executable instructions for causing a computer system to perform a method for debugging and performance analysis. The method includes receiving a request for capturing a frame generated by a graphics application wherein the graphics application implements a plurality of application threads for executing a plurality of function calls generating the frame. The plurality of function calls is associated with one or more thread specific resources used at an entry point of the capturing process. The method includes for each application thread determining a corresponding state for each corresponding thread specific resource utilized. The method includes for each application thread establishing a corresponding capture stream wherein application threads and capture streams exist in a one to one relationship. The method includes for each application thread capturing executed function calls into the corresponding capture stream. The method includes ordering a plurality of captured function calls captured across the plurality of application threads in the order they were executed by the graphics application. The method includes for each capture stream establishing a corresponding replay thread wherein capture streams and replay threads exist in a one to one relationship. The method also includes replaying a plurality of captured function calls in the order they were captured wherein a captured function call is executed in a corresponding replay thread based on which application thread executed the captured function call.

In still other embodiments of the present invention a computer system is disclosed comprising a processor and memory coupled to the processor and having stored therein instructions that if executed by the computer system cause the computer system to execute a method for debugging and performance analysis. The method includes receiving a request for capturing a frame generated by a graphics application wherein the graphics application implements a plurality of application threads for executing a plurality of function calls generating the frame. The plurality of function calls is associated with one or more thread specific resources used at an entry point of the capturing process. The method includes for each application thread determining a corresponding state for each corresponding thread specific resource utilized. The method includes for each application thread establishing a corresponding capture stream wherein application threads and capture streams exist in a one to one relationship. The method includes for each application thread capturing executed function calls into the corresponding capture stream. The method includes ordering a plurality of captured function calls captured across the plurality of application threads in the order they were executed by the graphics application. The method includes for each capture stream establishing a corresponding replay thread wherein capture streams and replay threads exist in a one to one relationship. The method also includes replaying a plurality of captured function calls in the order they were captured wherein a captured function call is executed in a corresponding replay thread based on which application thread executed the captured function call.

In another embodiment a system for debugging and performance analysis is disclosed and includes a multi threaded processor graphics application programming interface an interception layer capture streams replay threads and an arbiter. The multi threaded processor is configured for executing a plurality of function calls generated by a graphics application in association with a frame. The graphics API is configured to execute the plurality of function calls in order generate the frame suitable for display. The plurality of function calls is associated with one or more thread specific resources used at an entry point of capturing the frame. The interception layer is configured to intercept the plurality of function calls between the graphics application and the graphics API in response to a request for capturing the frame. The interception layer is configured to capture for each thread a corresponding state for each corresponding thread specific resource utilized at the entry point. A plurality of capture streams is included in the system wherein each capture stream is configured to capture executed function calls from a corresponding application thread. Application threads and capture streams exist in a one to one relationship. The system includes a plurality of replay threads wherein each replay thread is configured to replay corresponding captured function calls originally executed on a corresponding application thread. Capture streams and replay threads exist in a one to one relationship. The arbiter is configured for ordering a plurality of captured function calls captured across the plurality of application threads in the order they were executed by the graphics application such that the arbiter replays a plurality of captured function calls in the order they were captured.

These and other objects and advantages of the various embodiments of the present disclosure will be recognized by those of ordinary skill in the art after reading the following detailed description of the embodiments that are illustrated in the various drawing figures.

Reference will now be made in detail to the various embodiments of the present disclosure examples of which are illustrated in the accompanying drawings. While described in conjunction with these embodiments it will be understood that they are not intended to limit the disclosure to these embodiments. On the contrary the disclosure is intended to cover alternatives modifications and equivalents which may be included within the spirit and scope of the disclosure as defined by the appended claims. Furthermore in the following detailed description of the present disclosure numerous specific details are set forth in order to provide a thorough understanding of the present disclosure. However it will be understood that the present disclosure may be practiced without these specific details. In other instances well known methods procedures components and circuits have not been described in detail so as not to unnecessarily obscure aspects of the present disclosure.

Some portions of the detailed descriptions that follow are presented in terms of procedures logic blocks processing and other symbolic representations of operations on data bits within a computer memory. These descriptions and representations are the means used by those skilled in the data processing arts to most effectively convey the substance of their work to others skilled in the art. In the present application a procedure logic block process or the like is conceived to be a self consistent sequence of steps or instructions leading to a desired result. The steps are those utilizing physical manipulations of physical quantities. Usually although not necessarily these quantities take the form of electrical or magnetic signals capable of being stored transferred combined compared and otherwise manipulated in a computer system. It has proven convenient at times principally for reasons of common usage to refer to these signals as transactions bits values elements symbols characters samples pixels or the like.

It should be borne in mind however that all of these and similar terms are to be associated with the appropriate physical quantities and are merely convenient labels applied to these quantities. Unless specifically stated otherwise as apparent from the following discussions it is appreciated that throughout the present disclosure discussions utilizing terms such as capturing detecting establishing ordering replaying or the like refer to actions and processes e.g. flowchart of of a computer system or similar electronic computing device or processor e.g. system . The computer system or similar electronic computing device manipulates and transforms data represented as physical electronic quantities within the computer system memories registers or other such information storage transmission or display devices.

Other embodiments described herein may be discussed in the general context of computer executable instructions residing on some form of computer readable storage medium such as program modules executed by one or more computers or other devices. By way of example and not limitation computer readable storage media may comprise non transitory computer storage media and communication media. Generally program modules include routines programs objects components data structures etc. that perform particular tasks or implement particular abstract data types. The functionality of the program modules may be combined or distributed as desired in various embodiments.

Computer storage media includes volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Computer storage media includes but is not limited to random access memory RAM read only memory ROM electrically erasable programmable ROM EEPROM flash memory or other memory technology compact disk ROM CD ROM digital versatile disks DVDs or other optical storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium that can be used to store the desired information and that can accessed to retrieve that information.

Communication media can embody computer executable instructions data structures and program modules and includes any information delivery media. By way of example and not limitation communication media includes wired media such as a wired network or direct wired connection and wireless media such as acoustic radio frequency RF infrared and other wireless media. Combinations of any of the above can also be included within the scope of computer readable media.

Both the central processing unit CPU and the graphics processing unit GPU are coupled to memory . System memory generally represents any type or form of volatile or non volatile storage device or medium capable of storing data and or other computer readable instructions. Examples of system memory include without limitation RAM ROM flash memory or any other suitable memory device. In the example of memory is a shared memory whereby the memory stores instructions and data for both the CPU and the GPU . Alternatively there may be separate memories dedicated to the CPU and the GPU respectively. The memory can include a frame buffer for storing pixel data drives a display screen .

The system includes a user interface that in one implementation includes an on screen cursor control device. The user interface may include a keyboard a mouse and or a touch screen device a touchpad . System also includes a performance analysis system that is configured for multi threaded stream capture and replay. Analysis system is further described in below.

CPU and or GPU generally represent any type or form of processing unit capable of processing data or interpreting and executing instructions. In certain embodiments processors and or may receive instructions from a software application or hardware module. These instructions may cause processors and or to perform the functions of one or more of the example embodiments described and or illustrated herein. For example processors and or may perform and or be a means for performing either alone or in combination with other elements one or more of the monitoring determining gating and detecting or the like described herein. Processors and or may also perform and or be a means for performing any other steps methods or processes described and or illustrated herein.

In some embodiments the computer readable medium containing a computer program may be loaded into computing system . All or a portion of the computer program stored on the computer readable medium may then be stored in system memory and or various portions of storage devices. When executed by processors and or a computer program loaded into computing system may cause processor and or to perform and or be a means for performing the functions of the example embodiments described and or illustrated herein. Additionally or alternatively the example embodiments described and or illustrated herein may be implemented in firmware and or hardware.

The graphics application includes a collection of programs enabling the generation and manipulation of images. For instance the programs include shaders that are configured to perform different types of tasks and or operations for purposes of graphics rendering. For instance in some GPUs geometry data e.g. primitives for vertices of polygons is input into the graphics application and subjected to the various tasks and or operations before rendering e.g. a frame of data . These tasks include pixel shading vertex shading geometry shading etc.

The graphics application may utilize different API function calls such as the draw call or the swap buffers call to perform the different types of tasks. The API function calls initiate the tasks performed within the graphics API to render a frame of data. That is the graphics API is configured to execute a plurality of function calls to generate or render the frame of data suitable for display. For instance before executing a task the graphics application may transmit a function call to the graphics API to set or change a setting for a render state. The API then passes the setting to a driver not shown which makes the appropriate changes to the GPU or CPU.

As previously described the performance analysis system is located between the graphics application and the graphics API and is configured to capture and replay API function calls such as in a loop formation for purposes of debugging and analysis of the graphics application . For instance the GPU may include a multi threaded processor configured to execute a plurality of function calls generated by a graphics application in association with a frame of data. As an advantage implementation of the performance analysis system avoids the problem of having to set thread specific state for each API function call delivered by the graphics application as experienced by previous debugging solutions.

In particular the performance analysis system includes an interception layer that is configured to capture the API function calls. The interception layer includes a stream capture module configured for capturing the plurality of API function calls e.g. in response to a request for capturing a frame of data wherein the plurality of function calls is associated with one or more thread specific resources used at an entry point of the capturing process. For instance the captured API function calls are assigned to a capture stream wherein each application thread e.g. T T . . . T is assigned an API capture stream S S . . . S wherein application threads and capture streams exist in a one to one relationship. As such a plurality of capture streams is established wherein each stream captures executed function calls for a corresponding application thread.

The interception layer also includes a state capture module for capturing thread specific state of one or more thread specific resources. That is at the time the first function method is captured for a given application thread the state capture module captures and tracks a corresponding state for each corresponding thread specific resource utilized by the application thread.

The performance analysis system also includes a replay stream module that is configured to replay the captured API function calls for example in continuous loop. For instance when the replay process begins a pool of replay threads e.g. R R . . . R is created. Thread specific resources are returned to their corresponding state existing at the entry point of the capture process and starting point of the replay process. Each replay thread is configured to replay corresponding captured function calls originally executed on a corresponding application thread wherein capture streams and replay threads exist in a one to one relationship. As such there is a direct correspondence between T S and R.

Further the replay stream module includes an arbiter configured for ordering the plurality of function calls captured across the plurality of application threads in the order they were executed by the graphics application. During replay the arbiter arbitrates the replay of the plurality of captured function calls in the order they were captured across the plurality or pool of replay threads.

At the method includes receiving a request for capturing a frame or frame data that is generated by a graphics application. A plurality of application threads is implemented by the graphics application and is configured for executing a plurality of function calls generating the frame that is provided by the graphics application. The plurality of function calls is associated with one or more thread specific resources used at an entry point of capturing operation or capturing process.

For instance a user may observe how an application is executed by the CPU and GPU. The user may be interested in reviewing the rendering of a particular frame or a sequence of frames because the rendered frame on a display is incorrect. As such the user is able to initiate e.g. actuator button etc. the request for capture and or replay of the operations e.g. method and or function calls used to render the frame.

At the method includes determining states for each thread specific resource utilized at the entry point of the capture and replay process. Specifically for each application thread a corresponding state for each corresponding thread specific resource utilized by that thread is determined and captured. In particular at the entry point of the capture process for a given application thread the beginning state of any thread specific resource utilized by the application thread is determined and stored. Put another way a context is captured for each application thread wherein the context is utilized for executing the corresponding first or beginning function call. In that manner replay of the captured function calls is readily implemented by returning the thread specific resources to their corresponding state.

At the method includes for each application thread establishing a corresponding capture stream. Application threads and capture streams exist in a one to one relationship. For instance the captured API function calls are assigned to a capture stream wherein each application thread e.g. T T . . . T is assigned an API capture stream S S . . . S in a one to one relationship.

At the method includes for each application thread capturing executed method and or function calls into a corresponding capture stream. As such a plurality of capture streams is established wherein each stream captures executed function calls for a corresponding application thread. That is function calls as executed by a particular application thread are captured and collected into a corresponding API capture stream e.g. function calls for application thread Tare captured and collected in capture stream S .

At the method includes ordering a plurality of captured function calls collected or captured across the plurality of application threads in the order they were executed by the graphics application. By ordering the captured function calls during replay the function calls are again executed in order so that the performances of the CPU and GPU when executing the graphics application are reproducible. As examples of ordering in one implementation a time stamp is associated with each captured function call. In another implementation a sequence number is determined and or assigned for each captured function call wherein no two captured function calls have the same sequence number.

Other means and or methods for ordering the plurality of captured function calls are also supported. For instance in one embodiment for systems that do not require an exact duplicate replay each time a performance improvement includes performing resource dependency analysis to detect read write hazards across the threads. In such a system replay threads are allowed to execute simultaneously. Serialization is performed as necessary to avoid any hazards.

At the method includes establishing a corresponding replay thread R R . . . R for each capture stream S S . . . S wherein capture streams and replay threads exist in a one to one relationship e.g. Sand R . Correspondingly application threads capture streams and replay threads are related in one to one to one associations e.g. T S and R .

At the method includes replaying a plurality of captured function calls in the order they were captured and or originally executed wherein a captured function call is executed in a corresponding replay thread based on which application thread executed the captured function call. More particularly during replay any thread specific resources associated with a corresponding application thread Tare cloned for the associated replay thread R. At the beginning of each replay of the of the API capture stream Sby replay thread R the thread specific state associated with the corresponding application thread Tis restored for replay thread Rusing the corresponding thread specific state associated with T. For instance the thread specific state associated with Tis stored in the corresponding API capture stream Sat the time the first function and or method was captured from Tduring the capture process.

In this manner thread specific state for each and every API method and or function call prior to execution need not be restored. Instead just the initial thread specific state for each corresponding application thread is required for the replay process. Subsequent thread specific state for function calls to be executed are inherently established and known through the execution of previous function calls.

As shown the graphics application establishes multiple application threads T T . . . Tin order to graphically render one or more frames configurable for display. Each of the application threads delivers function calls to a graphics API to perform tasks capable of rendering the frame of data in a manner suitable for display. For instance a thread Tis shown as originating in the graphics application e.g. Ton up to T and passing function calls through the performance analysis system to the graphics API for execution e.g. thread Tpasses function calls over path A for execution by the graphics API and thread Tpasses function calls over path B to the graphics API .

Additionally related information associated with the function call is captured. In one embodiment that related information is captured regardless of whether the function calls are captured during a capture process. For instance when frame capture is not being performed the performance analysis system passes function calls to the graphics API for execution but also captures state of the API e.g. settings selected objects etc. . In that manner performance analysis system including the interception layer is transparent to the graphics application and the graphics API .

As previously described the performance analysis system is configured to capture function calls between a graphics application and a graphics API while operating on a frame of interest. As such function calls for each thread are recorded to corresponding and individual capture streams. For instance function calls in representative application thread Tare captured in corresponding capture stream S. In embodiments of the present invention the capture process includes any suitable means for capturing function calls and ordering the function calls as they are being captured in association with their order of execution. In one embodiment the arbiter coordinates the capture and ordering of function calls across all of the capture streams S S . . . S.

The performance analysis system is configured to create maintain coordinate perform and or manage the replaying of the captured function calls. For instance a representative replay thread Ris spawned in association with a corresponding capture stream S. At replay initialization thread specific resources in states associated with the beginning of the capture process are cloned and or made available for the corresponding replay thread to use. As such at the beginning of each replay loop the thread specific resources are restored to their original state e.g. the state they were in at the beginning of capture . In one embodiment any state used by the graphics API that is implicitly accessed through thread local storage is restored.

In one embodiment the arbiter coordinates the replay of the function calls captured across the multiple application threads. In one implementation replay occurs when an end of frame maker is detected during the capture process. The function calls are replayed across multiple replay threads R R . . . Rin order from earliest to latest based on their original execution ordering and correspondingly their capture ordering. In particular arbiter determines the ordering e.g. time stamp sequence number of the function call that should be executed next across the multiple replay threads R R . . . R.

Each replay thread replays directly from the associated capture stream as directed by the arbiter . For instance capture stream Sprovides the function calls for execution by the corresponding replay thread R. As shown replay thread Rrequests and receives the next function call for execution from capture stream Sover path A and replay thread Rrequests and receives the next function for execution from capture stream Sover path N. In general representative replay thread Rreplays function calls provided by a corresponding capture stream S.

More particularly the replay threads wait on the arbiter to allow them to execute a function call when appropriate. That is information is received from each capture stream replay thread combination related to the next captured function call in a position for execution. For example in one embodiment arbiter receives information e.g. function calls and ordering information from the capture streams S . . . S e.g. arbiter receives information from capture stream Sover path A and arbiter receives information from capture stream Sover path N. In another embodiment arbiter receives information relating to the next function call ready for execution from each of the replay threads Ron up to R e.g. arbiter receives information relating to its next function call from replay thread Rover path A and arbiter receives information relating to its next function call from replay thread R. As such the arbiter at any point in time has a pool of function calls ready for execution by each of the replay threads. By comparing the ordering of the function calls in that pool the arbiter is able to determine the smallest ordered captured function call in a position for execution and then direct the corresponding replay thread to execute that function call over path B.

During the capture process capture and execution of the captured function calls is performed within and or within the control of the performance analysis system . For instance each of the replay threads R R. . . R created by and maintained by the performance analysis system calls into the graphics API for execution of corresponding function calls e.g. replay thread Rmakes calls into the graphics API over path A and replay thread Rmakes calls into the graphics API over path N . As such the captured function calls are capable of being replayed by replay threads R R . . . Rin a loop as controlled by the arbiter until the proper analysis is completed.

When the capture and replay process is released the execution of function calls are returned back within the control of their corresponding application threads. This is shown by the return paths A and N. For example arbiter returns control of function call execution back to application thread Ton path A . . . and returns control back to application thread Ton path N.

As shown in two application threads Tand Tare established by a graphics application. At the beginning of the capture process thread specific resources are captured and tracked. More particularly state is captured for thread specific resources. For example the state for resources specific to thread Tis captured along path . Also the state for resources specific to thread Tis captured along path .

Also function calls are captured for each thread. For instance capture stream Scaptures function calls related to thread T. In addition ordering information is also captured. As such capture stream Sincludes function call Foo with order number 0 function call Bar with order number 3 and function call Foo with order number 4. In addition capture stream Sincludes function call Bar with order number 1 and function call Foo with order number 2.

Each capture stream is associated with a corresponding replay thread. At replay initialization thread specific resources are cloned or made available for the replay thread to use as previously described. For instance capture stream Sis associated with replay thread R and capture stream Sis associated with replay thread R.

As shown in the arbiter controls the execution order of the captured function calls. This is accomplished by the ordering of the captured function calls e.g. by sequence number time stamp etc. . In one implementation the replay threads inform the arbiter which function call is next in line within their respective threads for execution based on corresponding ordering. By comparing the ordering within the sample pool the arbiter is able to determine which function call should be next executed. As such the replay threads wait on the arbiter to allow them to execute a function when it is appropriate.

For instance at the beginning of the replay process replay thread Tinforms arbiter that the smallest ordered function call is Foo with order number 0 and replay thread Tinforms arbiter that its smallest ordered function call is Bar with order number 1. By comparison of order numbers e.g. original execution order of function calls the arbiter is able to determine that Foo with order number 0 should be executed before Bar with order number 1. As such arbiter is configured to direct replay thread Tto execute its next in line function call e.g. Foo at order number 0 .

After selection of Foo with order number 0 for execution replay thread Tsends to the arbiter its next smallest ordered function call Bar with order number 3. As such the arbiter knows that replay thread Thas a smallest ordered function call ready for execution called Bar with order number 3. By comparison of order numbers the arbiter is able to determine that Bar with order number 1 is next in line since it is smaller in order than Bar with order number 3 from thread T.

The same process is completed until all the function calls have been executed in their corresponding replay threads. In the example shown in each replay loop begins with order number 0. Replay thread Rwould wait while replay thread Rexecutes the function call with order number 0. Once execution is complete replay thread Rwill wait and replay thread Ris allowed to execute the function call with order number 1 and then with order number 2. Then replay thread Rwaits while replay thread Ris allowed to execution the function call with order number 3 and subsequently order number 4. As such the order of executed function calls in the replay process is as follows Foo with order number 0 executed by thread T Bar with order number 1 executed by thread T Foo with order number 2 executed by thread T Foo with order number 2 executed by thread T Bar with order number 3 executed by thread T and Foo with order number 4 executed by thread T. The captured function calls may be executed continuously in a loop or released so that the application is able to continue execution of subsequent function calls.

Thus according to embodiments of the present disclosure systems and methods are described providing for multi threaded API stream capture and replay.

While the foregoing disclosure sets forth various embodiments using specific block diagrams flowcharts and examples each block diagram component flowchart step operation and or component described and or illustrated herein may be implemented individually and or collectively using a wide range of hardware software or firmware or any combination thereof configurations. In addition any disclosure of components contained within other components should be considered as examples because many other architectures can be implemented to achieve the same functionality.

The process parameters and sequence of steps described and or illustrated herein are given by way of example only and can be varied as desired. For example while the steps illustrated and or described herein may be shown or discussed in a particular order these steps do not necessarily need to be performed in the order illustrated or discussed. The various example methods described and or illustrated herein may also omit one or more of the steps described or illustrated herein or include additional steps in addition to those disclosed.

While various embodiments have been described and or illustrated herein in the context of fully functional computing systems one or more of these example embodiments may be distributed as a program product in a variety of forms regardless of the particular type of computer readable media used to actually carry out the distribution. The embodiments disclosed herein may also be implemented using software modules that perform certain tasks. These software modules may include script batch or other executable files that may be stored on a computer readable storage medium or in a computing system. These software modules may configure a computing system to perform one or more of the example embodiments disclosed herein. One or more of the software modules disclosed herein may be implemented in a cloud computing environment. Cloud computing environments may provide various services and applications via the Internet. These cloud based services e.g. software as a service platform as a service infrastructure as a service etc. may be accessible through a Web browser or other remote interface. Various functions described herein may be provided through a remote desktop environment or any other cloud based computing environment.

The foregoing description for purpose of explanation has been described with reference to specific embodiments. However the illustrative discussions above are not intended to be exhaustive or to limit the invention to the precise forms disclosed. Many modifications and variations are possible in view of the above teachings. The embodiments were chosen and described in order to best explain the principles of the invention and its practical applications to thereby enable others skilled in the art to best utilize the invention and various embodiments with various modifications as may be suited to the particular use contemplated.

Embodiments according to the present disclosure are thus described. While the present disclosure has been described in particular embodiments it should be appreciated that the disclosure should not be construed as limited by such embodiments but rather construed according to the below claims.

