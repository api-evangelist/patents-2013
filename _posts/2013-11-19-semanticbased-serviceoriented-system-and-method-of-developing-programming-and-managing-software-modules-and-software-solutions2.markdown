---

title: Semantic-based, service-oriented system and method of developing, programming and managing software modules and software solutions
abstract: Methods, systems, frameworks, and software products for building well-defined software modules through aggregation of other similar modules at any depth. The system can provide visual methods of aggregation and nesting of software interfaces within composite software services with an automated runtime platform. Other aspects can include innovative methods for routing the flow of invocation, inter-service communication, and exception handling. Industry standards are leveraged to integrate the methods to any computer system, programming language or software platform. The semantic-based and visual nature of the methods can significantly reduce the complexity of building, maintaining and deploying computer systems and software products.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09588743&OS=09588743&RS=09588743
owner: NEXTAXIOM TECHNOLOGY, INC.
number: 09588743
owner_city: San Francisco
owner_country: US
publication_date: 20131119
---
This application is a continuation application of U.S. application Ser. No. 13 399 980 filed on Feb. 17 2012 and subsequently issued as U.S. Pat. No. 8 621 428 which is a continuation application of U.S. application Ser. No. 10 904 744 filed on Nov. 24 2004 and subsequently issued as U.S. Pat. No. 8 225 282 which is a non provisional patent application claiming the priority benefit of U.S. Provisional Application Ser. No. 60 481 702 filed on Nov. 25 2003 which applications are incorporated herein by reference in their entirety.

The present invention relates to the field of computer programming software development and management and in particular to the design service oriented programming implementation integration deployment control and maintenance of software modules services and software applications.

There are many computer programming languages software design and development and integration tools in existence today.

The current state for programming languages and software design tools is based on the well known object oriented development paradigm. Object oriented programming languages inherit the complexity of the object oriented paradigm. The current programming languages require an unnatural syntax based coding or scripting approach that does not directly correspond to the way that non technical people functional experts and business analysts think. Furthermore these languages often pivot around class definitions class inheritance and polymorphism. These complex concepts require steep learning curves and can be only understood and utilized by highly technical programmers or computer scientists. Most people with functional know how and understanding of business and application requirements are not technical enough to directly utilize the current programming languages and software development tools. As a result of this complexity software development projects take too long to complete and are too expensive and non flexible when it comes to the inevitable need for enhancements and maintenance.

Furthermore the current integration tools are based on a message oriented paradigm and only accommodate the communication and translation between different software layers. These tools are also too complex and are either not sufficient for general purpose programming or utilize the complex object oriented paradigm to accommodate programming capabilities.

It takes too long to develop customize and integrate enterprise software solutions and the end result is too rigid. Today s approach to building software is very much like pouring concrete. Like developing software solutions pouring concrete requires heavy lifting while the concrete is fluid. After the concrete sets it is inflexible as is the case with the current approach to developing and delivering software solutions. A significantly less complex approach to software development can dramatically decrease the time to deliver software solutions. A dramatic decrease in the time to deliver will often correlate to a proportional decrease in cost. Time and cost are two main components of agility. Therefore a significantly less complex approach to developing and delivering software solutions will increase the agility of an organization. If it took three weeks instead of nine months to deliver or modify a software solution to support a business activity organizations could optimize their operations in response to change and become significantly more agile. They could undertake less costly projects that would not be possible to undertake with an otherwise longer timescale.

Service Oriented Architecture has been gaining popularity among software vendors and Information Technology users in the recent years. In a Service Oriented Architecture SOA a service interface is used as a logical unit of communication between different software layers. SOA addresses the interoperability issue between different software systems through industry standards. Most software vendors have incorporated standards based software services as the means of interfacing with other software applications and tools. Web services standards such as Web Service Definition Language WSDL and Universal Description Discovery and Integration UDDI make the traditional three tier architecture interoperable. Each tier can provide or consume easily deployable black boxes of software functionality through standard based service interfaces. However service oriented standards based communication does not make the application logic in the middle tier more adaptable or easier to program.

A software service has a well defined interface and performs a well defined software task. The interface represents the inputs and outputs of a black boxed software service as well as the properties of that service such as service name and location. The interface acts as a contract between the consumer of the software service and the producer of the service.

The main object of the present invention is to introduce a general purpose service oriented programming method that takes the idea of service orientation beyond standards based communication. The method of the present invention aims to provide a pure service oriented approach for programming software logic and organizing the program into software modules as services that eliminates the need for coding or scripting while operating within a service oriented paradigm. This makes the application business and integration logic in the middle tier of software architecture ten times faster to develop maintain and customize. Due to unique innovations all application logic that utilizes this approach is adaptable and can be created and modified on the fly.

The programming method of the present invention enforces a new means of decoupling and organizing a computer program that is fundamentally simpler than object oriented programming and significantly more flexible than any of its predecessors. This simple yet powerful approach provides the base required to truly enable a one hundred percent code free script free metadata driven software development platform.

An object of Service Oriented Programming SOP as defined by the method of the present invention is to provide a revolutionary technique for developing software that uses a service interface as the pivot point for developing computer program modules as services and furthermore to natively support services as its fundamental unit of work at both development and execution time. Unlike a function or object oriented method interface a service interface supports rich integrity rules and allows for multiple order independent complex types on both the inputs and outputs of a software task. The runtime kernel called for by the method of the present invention provides native support for this rich service interface it enforces integrity rules in real time handles complex inputs and outputs and uses flexible specifications to direct runtime behavior and to dispatch internal as well as remote software tasks. Here the interface of the service accommodates private properties not exposed to the consumer used as a contract between the service and the runtime environment. These properties address technical properties such as service timeout all the way to sophisticated behavior such as synchronization of service instances cache keys logging and metering behavior.

A software service can be either implemented by coding in an object oriented or functional environment bridged to the method of the present invention or it can be implemented in a semantic based programming environment based on the method of the present invention.

The present invention aims to provide a collection of methods to accomplish its objectives. An object of the present invention is to provide a method for building well defined software modules as software services including but not limited to Web services through the optionally nested aggregation of other likewise modules at any depth.

A further object of the present invention is to provide visual methods and systems of aggregation and nesting of software interfaces within composite service definitions with an automated runtime.

A further object of the present invention is to provide visualization methods for nested composite services.

A further object of this invention is to provide mechanisms for organizing and discovering software services.

A further object of the present invention is to provide a method to correctly refactor a set of contained services within a composite service as a new composite service encapsulating those contained services.

A further object of the present invention is to provide a method to correctly unfactor services inside a parent composite service within another parent composite service.

A further object of the present invention is to allow context sensitive configuration of the behavior for software services contained in a composite service.

A further object of the present invention is to provide programming capabilities in a graphical environment that requires no coding where those capabilities are based on service interfaces and a set of innovative constructs.

Another object of the present invention is to provide a method and mechanism for defining and controlling the flow of execution within a composite service.

A further object of the present invention is to provide a technique for configuring a software interface and providing automatic implementation for the configured interface.

Another object of the present invention is to provide means for mapping data and data transformations between connected services contained in a composite service.

A further object of the present invention is to provide a context based mechanism for inter service communication through shared memory.

A further object of the present invention is to provide a mechanism for exception handling within a composite service definition.

Another object of the present invention is to provide visual means for inspection and debugging of nested composite services.

Yet another object of the present invention is to provide a method of provisioning for software services based on their interfaces.

Other objects and advantages of this invention will be set in part in the description and in the drawings which follow and in part will be obvious from the description or may be learned by practice of the invention. Accordingly the drawings and description are to be regarded as illustrative in nature and not as restrictive.

To achieve the forgoing objectives and in accordance with the purpose of the invention as broadly described herein the present invention provides methods frameworks and systems for building a software system for the management implementation and assembly of service oriented software modules. In preferred embodiments this technique comprises a visualization technique for assembling nested composite services with a semantic based ability to add programming logic without syntax based coding. Built in service flow behavior and semantic based branching and looping constructs are provided to enable the systematic and programmatic control over the flow of service invocation. Semantic based constructs are provided to accommodate service oriented exception handling. Means for mapping data and data transformations are integrated in the visual assembly environment with automated runtime. Methods for organizing software services and composite definitions and discovery of services are integrated in the visual environment. Techniques for context based configuration of services within the context of a parent composite service are provided. Furthermore account based provisioning of services is accommodated by creating a reference mechanism to software interfaces corresponding to the services under provisioning.

The method further comprises a mechanism for inner process communication through a variety of shared memory structures. An innovative framework together with a set of access and modification methods are used to enable composite services to share data within different instances of the same composite service definition or across the instances of different composite service definitions. The shared memory mechanisms and methods leverage the configurable construct invention together with data synchronization and persistent mechanisms to accommodate inner service communication through shared data storage.

The present invention will now be described with reference to the following drawings in which like reference numbers denote the same element throughout. It is intended that any other advantages and objects of the present invention that become apparent or obvious from the detailed description or illustrations contained herein are within the scope of the present invention.

The present invention is a collection of many related innovative techniques methods and systems for building well defined software modules including but not limited to Web services through the optionally nested aggregation of other likewise modules at any depth. There are two distinct aspects of a software module i.e. software service . The first is the interface of the service. The interface of the service defines the inputs outputs and the properties of the service. The second aspect of a software service is the implementation of the service. The method of the present invention defines a pure service oriented approach in implementing software modules by strictly separating these two aspects and providing an implementation paradigm based on the interface of software services. The reader may refer to www.nextaxiom.com for obtaining a downloadable version of the Hyperservice Business Platform that is an example implementation of the methods techniques and the systems discussed in the present invention while identifying her his request for download in the context of this patent application.

One aspect of the present service oriented invention is in its hierarchical nested approach to the organization of a software module i.e. software services . Based on this approach as depicted in a software service can be composed of other services which in turn may be composed of other services and so on without a preset limit on the depth of composition. Each level of composition i.e. implementation is encapsulated from the containing parent level through its interface definition. The platform for the service oriented paradigm of the present invention further distinguishes a software service implemented through this composition paradigm herein referred to as a composite service or a Hyperservice from one implemented through any other programming paradigm or with a distributed implementation i.e. computer address space other than the instance of the executing platform as an atomic or raw material service.

Another aspect of the present invention is in the method of composition used in assembling software services for the purpose of defining the implementation of a composite service. A set of semantic based programming constructs control the flow of execution of child services that exist within the definition of a composite service wherein connecting either the success or the failure port of a contained service to the activation port of another service establishes a dependence between the invocation of the two services whereby the latter service is automatically invoked after the former service. If the failure port was connected the latter service is only invoked if the former service fails as a result of its execution. But if the success port was connected the latter service is only invoked if the former service succeeds as a result of its execution. Either the simultaneous connection of both failure and success ports can be disallowed or it can be interpreted as a positive activation signal for executing the latter service. Referring to an example depicted in an activation port is associated with the input side and a success and a failure port is associated with the output side of each presentation of a contained service. The automatic runtime system implementing the methods of the present invention provides the built in behavior with respect to these ports. Again referring to Service A begins execution when the execution of the parent containing service begins. Service B and Service C are only executed if Service A s invocation was successful since they are attached to the success port of Service A. Otherwise if Service A fails upon execution Service D is invoked by the automatic runtime platform since it is connected to the failure port of Service A.

Among other benefits the failure port provides a built in flow mechanism for exception handling that is service oriented i.e. implemented through services . For example Service F is only activated when Service D fails to handle the failure i.e. exception handling . Again referring to Service E is activated upon the success of Service B AND Service C since its activation port is connected to the success ports of Service B and Service C. A set of logical activation constructs are introduced based on the method of the present invention to give those implementing a composite service control to change the default AND logic such as that mentioned in the case of Service E from . are an example metadata representation of .

The method of the present invention provides the ability to connect the failure or success port of any service as well as any of the other constructs to any of a set of logical flow constructs including but not limited to AND OR and NOT constructs. Each of the logical constructs can operate on the flow signals of failure and success ports as well as signals generated by other constructs. Flow signals from many services can be connected to an AND construct and the output signal generated by the AND construct is only an activation signal if all signals flowing into it indicate activation. The OR construct generates an activation signal if at least one signal flowing into it indicates activation. The NOT construct takes a flow signal as input and generates the negation of that signal on the output side. Now referring to for an example the success ports of Service A and Service B are connected to an AND construct and an output signal from the AND construct is mapped to the activation port of Service E whereby Service E will be only invoked if both Service A and Service B execute successfully. Again referring to the failure ports of Service C and Service D are connected to an OR construct and the output signal of the OR construct Service F. Here Service F is activated if either Service C or Service D fails upon execution. The output signal of the OR construct is also connected to a NOT construct and the NOT construct is connected to the activation port of Service G. Here the NOT construct generates an activation signal that results in the activation of Service G only if the OR construct outputs a deactivation signal which only happens if either Service C or Service D fail to execute successfully . are an example metadata representation of .

The method of service composition outlined by the present invention provides a Decision construct for controlling the flow of invocation through branching based on the actual data carried by service inputs outputs at runtime. The method of the present invention provides the graphical ability to associate data elements from the inputs of the parent service or the outputs of any contained service to a branch of a decision construct. This association automatically defines the left hand side of a logical operator. The user then selects a logical operator from a list those available to all databases query languages and higher level programming languages . The user then associates data from the inputs of the parent service or the outputs of any contained service to automatically define the right hand side of the logical operator. The method also provides the ability to add as many such branches to a decision construct to create the logical equivalent of an IF ELSE IF ELSE IF ELSE statement similar to those of general purpose programming languages. Furthermore the method of the present invention provides for the association of a True port and False port with each decision branch. These ports are mutually exclusive during runtime only one of these ports will generate an activation signal. The True port of a decision branch generates an activation signal if the condition represented by that branch is True. The False port of a decision branch generates an activation signal if the condition represented by that branch is False. Each decision branch is chained to the next through the False port of the previous branch. During runtime the evaluation of the next decision branch is only activated if the False branch of the previous branch is activated. If the evaluation of all branches result in a False value the False port of the last decision branch is activated. Referring to for an example you can see the composite implementation of an ExpediteItem service used in a hypothetical manufacturing environment. Inside the ExpediteItem service i.e. its composite definition is a Get Qty on Hand service where the success port of the Get Qty On Hand service is connected to a decision construct with two branches. The figure shows a data mapping tool that is used to express the mapping between data from the outputs of the Get Qty On Hand service and the decision construct as well as data from the inputs of the ExpediteItem composite service and the decision construct. On the top portion of the left side of the mapper tool the inputs itemID and requestedQty are displayed and on the bottom portion of the left side of the mapper tool the outputs onHandQty and itemLocation of the Get Qty On Hand service are displayed. On the right portion of the mapper tool the two branches of the decision construct of this example are displayed. During runtime the True port of the first branch produces an activation signal if the requestedQty of the ExpediteItem service is less than or equal to the onHandQty of the Get Qty On Hand service. If this condition is not true the second branch is evaluated. The True port of the second branch produces an activation signal if the onHandQty of the Get Qty On Hand service is greater than zero a constant value of zero is attached to the right hand side of the second branch . Based on the logic implemented in the composite ExpediteItem service at runtime if either the condition in the first branch or the second branch evaluates to true Service A is invoked. However Service B is invoked only if the condition in the second branch i.e. onHandQty being greater than zero evaluates to true. If the condition in neither of the branches evaluates to true the composite Service C will be invoked since it is connected to the False port at the bottom of the decision construct. This False port is equivalent to an else statement of programming languages. are an example metadata representation of .

Another method of the present invention that controls the flow of execution within a composite implementation of a software service is introduced through exit and continue graphical flow constructs. These constructs have well defined built in behavior at runtime. Furthermore these constructs are part of the exception handling mechanisms provided by the method of the present invention. The method of the present invention supports an Exit with success and an Exit with failure construct that if reached at runtime based on the flow of invocation rules results in the termination of the containing parent composite service with success or failure respectively. Furthermore the method of the present invention supports a Continue construct that if reached at runtime based on the flow of invocation results in the continuation to the next flow point HYPERCYCLE . For example if the failure port of a child service is connected to a Continue construct then during runtime if that child service fails the parent service will continue execution. Now referring to an Exit with success construct is connected to Service A s success port. As a result of this connection at runtime if Service A executes successfully the execution of the composite service containing Service A will terminate with a status of success. Based on the example in if Service A fails Service B is executed however if Service B fails since a Continue construct is attached to the failure port of Service B the runtime instance of the composite model i.e. graphical implementation will not terminate and the execution will flow to the next service Service C . Following the model in if Service C fails to execute successfully due to a Remote Connection Failure or an Invalid Request the runtime instance of the model will exit with a status of failure however if it fails due to a logical Failure Service D will be invoked. Therefore based on the method of the present invention the construct or service connected to the failure port of a service can be activated upon specific failure types based on the application designer s selection. are an example metadata representation of .

Another aspect of the present invention is the association of an attribute with the composite service implementation that indicates whether to repeat the execution of the implementation. There is a second related attribute that indicates whether to stop repeating once a configurable number of repetitions is reached or to continue repeating until an Exit construct is reached. A third attribute indicates the amount of time to pause between repeats. This method of repeating or looping further comprises the optional ability to provide data feedback from any data element of the composite service outputs to the inputs of that service. Referring to for an example the implementation of the composite service containing a child Get List item construct introduced later in this document and a service named Service A is demonstrated. Here based on the model property the implementation is marked as a repeating implementation with no preset maximum number of iterations. Additionally feedback from the outputs to inputs is enabled where a data mapping tool allows the user to specify feedback data mappings from the outputs of the parent service to its inputs upon each iteration at runtime. are an example metadata representation of .

Based on the method of the present invention graphical means for mapping data between the outputs and inputs of contained child services within a composite service are provided wherein the outputs of one or more child services can be mapped to the inputs of one or more child services. Furthermore the inputs of the containing i.e. parent composite service can be mapped to the inputs of any of its contained services i.e. its children and the outputs of many contained services can be mapped to the outputs of the containing parent composite service. Referring to as an example the data mapping tool on the left side of the figure holds a representation of the inputs of the parent service on the left side of the mapping tool and the inputs of Service A Service B and Service C on the right side of the mapping tool. You can see how the user can express the data relation mapping of parent input 1 to service A input and the mapping of parent input 2 to both service B input and service C input elements. The expression of the mapping is stored as part of the implementation of the ParentService model based on which actual data are transferred between the instances of the services at runtime. show one metadata expression of the mapping relationships of ParentModel to Service A Service B and Service C described in . Continuing with the explanation of the example in the mapping tool on the right side of the figure shows the expression of data mapping based on the method of the present invention between the outputs of three services Service E F G and the outputs of the ParentService in a similar fashion. In this way at runtime data is transferred to the inside of the composite implementation through its inputs and to the outside the composite implementation through its outputs. Referring to the example of you can see the outputs of three services Service A B C being mapped to the inputs of Service D and the outputs of Service D being mapped to the inputs of three services Service E F G in a similar fashion. are an example metadata representation of the visual mapping demonstrated in .

The implementation method of the present invention includes the ability to express the mapping of complex input output data structures with plurality between the input output of services. Referring to as an example you can see the outputs of Service A that include a plural data container List AAA within another plural data container List AA that is itself embedded within another plural data container List A . In this example each plural data container contains some atomic data element. Similarly on the input side of Service B data plurality is represented. As the mapping tool in the suggests the method of the present invention provides for the expression of the mapping of the data elements within these containers. provide an example metadata representation of . demonstrates an example of automatic data transfer at runtime based on the expression of mapping defined at design time. Furthermore based on the method of the present invention data is automatically converted if needed based on the actual data types on the two sides of the mapping. For example a date of one format will be converted to another based on the defined format of the date type to which it is connected. As another example if a Boolean type is connected to an integer type then during runtime if the value of Boolean is true it will be converted to an integer value of 1 upon transfer. At runtime the actual conversion takes place based on the types as indicated as part of the definition of the service interfaces.

Based on the method of the present invention the flow of execution upon the invocation of a composite service automatically starts by transferring data from the inputs of the parent composite service to those child services directly connected to the input port of that service. These and all connections are based on the expression of mapping defined at design time and stored as part of the implementation of the composite service. Furthermore the invocation of a composite service may end with the transfer of data from the outputs of the contained child services that have already been executed and are directly connected to the outputs of the parent service. Certain events may terminate the invocation of a composite service prematurely. For example the invocation of a composite service may terminate prematurely when a child service fails upon invocation without a routing defined for its failure port or if an Exit construct was activated.

To determine the dependency order of invocation execution of the contained services we construct an execution graph a directed graph for each composite service. Based on the connectivity of the contained services we determine the order of invocation and the end life cycle of each child service at runtime. Refer to which demonstrate the EXECUTION GRAPH of the models represented by respectively.

The created execution graph captures the dependencies of all the child services and construct nodes based on their connectivity to the success failure ports of other child services constructs or to the parent service s input node. To construct the EXECUTION GRAPH for a composite service tree nodes are created corresponding to each service and graphical construct such as a logical construct within a composite service model. The created nodes are sorted based on the direct and indirect dependency of each node to the inputs node of the parent composite service. The maximum distance that must be traversed from one node through other incoming nodes to reach the inputs of the parent composite service is one way to compare two nodes in determining the order of sorting. Note that upon the definition of a composite service based on the method of the present invention all graphical nodes inserted within the definition and their immediate dependency i.e. incoming nodes are stored as part of the definition of a composite service. Refer to which demonstrate this dependency in example metadata form.

At runtime and upon the invocation of a composite service instance a context herein referred to as the INVOCATION MAP is created for a composite service based on the EXECUTION GRAPH associated with the definition of the composite service. Upon the invocation of a composite service the automation platform instantiates an INVOCATION MAP corresponding to the EXECUTION GRAPH that is created based on the dependency of contained services. The INVOCATION MAP determines the set of services that can be invoked by traversing the EXECUTION GRAPH in the order of node dependencies. The nodes with no dependencies or only dependencies to the input data of the composite service are the first set of nodes in the EXECUTION GRAPH and the nodes with dependencies to those nodes are the second set of nodes in the EXECUTION GRAPH and so on. The automation platform of the present invention creates service instances corresponding to the service interfaces inserted in the definition of the composite and identified by the next set of non dependent nodes of the EXECUTION GRAPH. After preparing the input data for those service instances based on the expression of mapping stored within the composite service implementations the automation platform stores the corresponding service instances in the INVOCATION MAP to be used when preparing the inputs of the next set of nodes. The automation platform then invokes the prepared services using a unique key associated with the invocation of each service for the purpose of recovery from an unknown state. Herein we will refer to the invocation of each set of prepared services as a HYPERCYCLE. Referring to as an example the method of the present invention accommodates the automatic multi threaded invocation of contained services that have no unresolved dependencies to each other. As depicted in Services A B C have no dependencies to each other and only depend on the inputs of the parent composite service. Therefore after the transfer of data from the inputs of the parent service based on the mapping expression stored at the design time all three services may be invoked in parallel and in separate threads of execution. However Service D belonging to the next HYPERCYCLE due its dependencies can only start executing when all three services from the previous HYPERCYCLE have finished execution. Similarly Services E F G can only start execution as part of the third HYPERCYCLE after Service D has finished execution and the automation platform has transferred data if any from Service D s outputs to the inputs of the Services E F G. is an example metadata representation of the EXECUTION GRAPH and HYPERCYCLES of .

After processing each set of services optionally in parallel and using separate threads of execution the inputs of those services can be garbage collected i.e. eliminated from the memory . Furthermore each service whose end life cycle is reached determined by the EXECUTION GRAPH based on a state of no remaining dependencies can be eliminated from the INVOCATION MAP and garbage collected.

To accommodate the transparent distribution of an INVOCATION MAP object methods are added to the INVOCATION MAP for serialization and de serialization of its entire state after or between each discrete step of execution that involves the invocation of the next set of non dependent services. The serialized state contains the complete state of each executed service that has not been garbage collected including the state of execution such as the last executed HYPERCYCLE the last iteration in case looping was enabled a cursor to the next set of services the success and failure of service execution and other information concerning the exact state of execution. One benefit of transparent distribution of the INVOCATION MAP is in the ability to construct a remote debugger for composite services implemented based on the method of the present invention.

Based on the method of the present invention a visual semantic based debugger is provided for the interactive and step by step invocation of a composite service and the child services within the composite service whereby the semantic equivalent of all functionality usual to debugging tools for programming languages including but not limited to insertion deletion of break points inspection of the data values contained in variables stepping into functions stepping out of functions running to the end of a function and other such functionality is provided. Furthermore through the nesting of INVOCATION MAPs related to each contained composite service the method of the present invention accommodates the ability to step into any nested composite service contained within another composite service from within the semantic based debugger. Referring to as an example a composite service is running within a semantic based debugger. The first HYPERCYCLE containing the service GetFiles and a decision construct with four branches has already executed. The visual debugger in shows that the GetFiles service executed successfully and the inputs passed to the service are being modified evaluated by the user. attempts to document some of the functionality provided by the semantic based debugger that can be constructed based on the method of the present invention. The ability to inspect view and modify the inputs outputs of the invoked services to reinvoke from the point of modification and to transfer data to the inputs of a child service without invoking that service are other functions that are easily incorporated within the present invention. Furthermore the ability to set a break point to stop the execution in a batch execution mode of a composite service based on the integer position of an input component the nth input component is incorporated within the visual debugger. For example if a CreateSalesOrder service is invoked with four Sales Order components as its input the debugger can be used to set a break point on the third component stop at the beginning of that component and then execute the component when the user selects the appropriate debugger method step over step into .

The method of the present invention provides a way for synchronizing the execution of multiple instances of a composite service. The method of synchronization involves the association of an attribute to a composite service interface definition indicating whether simultaneous requests for the service should or should not be serialized i.e. synchronized . At runtime the system uses the unique object associated with the definition of the composite service whose instances are to be synchronized as the basis to serialize the execution of all of the concurrent requests for running the instances of that composite service. Referring to as an example an IncrementCounter service is depicted that contains two child services and is declared to serialize simultaneous instances of the parent service. The first service gets the value of the counter and the second service adds one to the output value of the first service and sets the incremented value as the new value of the counter. In this way the increment counter operation becomes an atomic operation whose correctness is guaranteed through the method of the present invention. Furthermore a method is provided for the granular synchronization of services in order to preserve the scalability of the applications built using the method of the present invention. According to this method at design time the user can graphically select one or more data paths from the inputs of the composite service that needs to be synchronized. Also the user can specify whether the synchronization should span instances of more than one composite definition by selecting a common resource such as a shared memory structure for synchronization. At runtime the automated runtime platform of this invention creates a string object that is a concatenation of the actual data values sterestored on the input data paths and either the unique id associated with the composite interface definition if no shared resource was selected or a unique id associated with any resource such as any shared memory structure. This string object is used to synchronize all the service instances that result in the same string object.

One embodiment of the method of the present invention is the visual assembly of software services and the defining building of a composite service implementation as depicted in . The picture demonstrates a service oriented integrated development environment referred to as the Hyperservice Studio used for building composite software services from other services through a semantic based graphical visual environment without requiring the writing of code. The top left pane holds all of the service interfaces and composite definitions organized within packages folders . Icons in a project pane optionally organized under nested folders packages are each associated with a software service that is identified by a unique identifier as well as a name in the context of the containing folder. The present invention provides a method of linking services across projects and packages through simple references established using service identifiers. Furthermore the project pane provides a visual mechanism for viewing the inputs outputs and the definition of a service in a tree like structure and under the containing project folder nodes of the tree as depicted in .

Again referring to the FindFiles service the parent composite is explored in the project pane. In the right desktop pane the definition of a composite implementation which is generally referred to as a Hyperservice model is opened. Based on one embodiment of the method of the present invention the Hyperservice model s input port corresponds to the input interface of the FindFiles service and is located on the left side of the visual representation of the composite definition. The execution of an instance of the FindFiles composite service starts by flowing data from the input port of the composite definition to the connected service in the first HYPERCYCLE as discussed earlier. The model s output port corresponds to the output interface of the FindFiles service and is located at the right side of the visual representation of the composite definition. On the top part of the Hyperservice model editor a set of toolbar items provide access to modeling constructs such as the Exit Continue constructs logical constructs AND OR NOT the decision construct and an extensible set of CONFIGURABLE CONSTRUCTs inventions discussed later in this document . The FindFiles service was defined by dragging and dropping service interfaces such as GetFiles from the project pane into the Hyperservice model editor and by adding decision logical and CONFIGURABLE CONSTRUCT instances from the tool bar. Lines can be connected between the success failure activation ports of services constructs and the inputs outputs of the composite model to indicate dependencies and the order of execution between services constructs. Through the connecting lines data mapping tools can be launched to express data mapping relationships between one to many and many to one services constructs inputs and outputs. Furthermore the present invention provides for an extensible framework for adding built in functions to the design tools and the runtime platform with the ability to insert the available built in functions between the data mappings by connecting the data types on the from side i.e. source to the inputs of the built in function and the outputs of the built in function to the to side of the target service. Refer to for a documented example of inserting a built in function between the mapping of two data elements within the mapping tool.

The definition of a composite service i.e. Hyperservice model may be stored as XML in a persistent repository. Each service within the Studio is assigned a universally unique identifier. A unique identifier is assigned to each service interface. The composite definition refers to each service that is inserted i.e. dragged and dropped into it using the unique identifier of its service interface. In this way if the name or the packaging of a service is changed its references within any composite definition in which it was placed remains the same.

The present invention provides a method for configuring defining the input output data structures used within a software service referred to as CONFIGURABLE CONSTRUCTs . Furthermore an extensible framework for the automatic runtime implementation of a CONFIGURABLE CONSTRUCT is provided. Once a CONFIGURABLE CONSTRUCT is added to the framework it will automatically appear on the constructs toolbar of the composite service designer i.e. Hyperservice model designer . Referring to an instance of Get List Item CONFIGURABLE CONSTRUCT is dropped into the implementation of the GetWantedRecord model and a dependency line is connected between the child service GetWantedRecord and the Get List Item CONFIGURABLE CONSTRUCT. At first when a mapping tool is used to define the data mapping between the outputs of GetWantedRecord and the inputs of Get List Item in the right pane of the mapping tool you can see that one of the inputs to Get List Item named anyList is of configurable type. This means that the input anyList can be configured to become any plural data structure. Again referring to the mapping tool provides one method of configuring the anyList configurable type based on the outputs of the service in the left pane of the mapper which is the WantedRecords data container list of the GetWantedRecords service. The user simply connects the WantedRecords data container list to the anyList input field of the CONFIGURABLE CONSTRUCT and agrees to proceed with the configuration. As a result the anyList configurable type takes the shape of the WantedRecords data container as shown in . Furthermore the outputs of the Get List Item are automatically configured based on the inputs and the specific function of the construct which in this case is to extract a WantedRecords item from the WantedRecords list with an index identified by the itemNumber input of Get List Item . As you can see in the output of the Get List Item configurable service is a non plural structure otherwise corresponding to the WantedRecords data structure.

In general the CONFIGURABLE CONSTRUCTs framework of the present invention uses a plug in architecture based on an application programming interface for introducing new CONFIGURABLE CONSTRUCTs and automating the configuration of those constructs inputs and outputs based on arbitrary connectivity of other data structures that may be optionally restricted by datatype. Furthermore the plug in architecture uses programming interfaces for providing the automatic implementation of the configured constructs at runtime. For example in the plug in defining the behavior of Get List Item service at runtime extracts the wanted record whose index is identified by the itemNumber input and adds the identified wanted record to its output data buffers. The design time portion of a CONFIGURABLE CONSTRUCT service can store information on the composite definition that can be later referenced by the runtime portion of the construct. Each CONFIGURABLE CONSTRUCT as part of an extensible tool bar can be placed in the workspace representing the definition of a composite service and can be connected to the inputs of the parent service or to the outputs of any child service for the purpose of configuration and mapping. Referring to as an example other configurable data list manipulation constructs are provided such as but not limited to extracting an item by index from a list of items appending items to a list consolidating two different data lists into one as well as getting the number of items in a list sorting a list of data based on user defined keys and filtering a list of data based on user defined criteria. respectively represent example metadata for the three list constructs depicted in .

The present invention provides a set of configurable services as CONFIGURABLE CONSTRUCTs such as a calculator data sorting data list manipulation text manipulation and filtration constructs. Referring to as an example the calculator construct provides the ability to perform mathematical and scientific operations on numerical data elements connected and flowed from parent service inputs or other child service outputs. Referring to as an example the text manipulation construct provides the ability to combine static text with the dynamic construction and formatting of text based on its configured service inputs. Similarly the sort CONFIGURABLE CONSTRUCT provides the ability to sort arbitrary plural data elements transferred from inputs of the parent service or outputs of other child services.

The present invention provides a method of inter service communication based on shared memory wherein the shared memory storage requirements and structural identity are represented by data structures similar to those used to describe service interface inputs outputs. An extensible framework through programming interfaces with a plug in architecture is used in one embodiment of the present invention to define four types of shared memory Shared Containers Shared Arrays Shared Vaults and Shared Dictionaries. Each shared memory type comes with a set of access services for getting and setting data values within the corresponding shared memory instances. The extensible framework of shared memory for the present invention can be used to introduce new specialized types of shared memory. Referring to as an example the application developer defines a shared memory structure of type Shared Container called the PartCounter . PartCounter contains an integer field lastPartCounter and a date field creation Date . The shared memory mechanism for Shared Containers provides two services for each Shared Container that is defined Set Data and Get Data . Set Data takes a PartCounter data structure as input and Get Data takes no input and returns a PartCounter structure as output. shows a composite service used for incrementing the lastPartCounter field of the PartCounter shared memory through its Get Data and Set Data services. The framework for shared memory services uses a mechanism that is a specialization i.e. subclass of the CONFIGURABLE CONSTRUCT framework to create the data access services such as Set Data and Get Data services of the Shared Container for each type of shared memory. When a shared memory structure of any type is added specialized and predefined configurable services are automatically configured through the framework to take the shape of the shared memory structure on either the inputs or outputs. The shared memory mechanism provides optional persistence for shared memory data. Referring to as another embodiment of the shared memory mechanism a Color Shared Vault is defined by the user containing fields for RGB values and the corresponding color name. Here the shared memory mechanism adds predefined data access services of Shared Vault including Set Data With Key Get Data With Key Get All Data Remove Data With Key Remove All Data and Wait for Data services. The Wait construct notifies the consuming composite service when the data belonging to the specific shared memory structure has been modified update set delete . In this way the WAIT method provides a means for asynchronous communication across different instances of composite services wherein one service may be blocked until another service sets or modifies the data associated with a shared memory. In this case these services are all configured automatically by the shared memory mechanism to take the Color structure as input or outputs. shows some of these services contained in a composite service with their inputs or outputs. In a similar fashion depicts an example of another type of shared memory called a Shared Array. A Shared Array structure provides predefined data access services that allow order dependent list manipulation such as AddItemFirst AddItemLast GetFirstItem GetNthItem GetLastItem GetAllItems RemoveFirstItem RemoveLastItem RemoveAllltems and GetArraySize . presents an example of a more specialized shared memory referred to as Shared Dictionary that provides methods for one to many and many to one translation of data in different forms or locales . In this example a Shared Dictionary named Month is defined. The standard word for each month of the year is added. In this case the standard word is always the 2 digit representation of the Month. For each standard word any number of alternate terms can be added where the alternate term is identified by a unique locale for that word. In this example 01 is a standard word for the Shared Dictionary named Month . Several alternate or Native forms for this standard word exist such as January which is identified by the fullname locale and Jan which is identified by the 3 letter locale. Shared Dictionary provides predefined data access services such as Translate to Standard which translates a native form of a word given the locale to the standard form and Translate to Native which translates a standard form of a word to the native form. Other data access services provide means to add delete or get words from the dictionary.

As mentioned earlier the present invention provides a method of synchronization based on synchronized execution of a composite service instance. This method as depicted in can be used to synchronize access to shared memory structures while providing inter service communication. Furthermore a built in context mechanism is provided for the shared memory that allows transactional behavior with respect to the shared memory accommodating rollback and commit behavior in the context of nested composite services. All modifications to shared memory data through the composite service are accommodated in the context of the composite service. In the case where a composite service contains another service for each composite service a new context is created that is nested within the parent context. In this way the modifications to the shared memory can be roll backed or committed at the end of the execution of each composite service.

An access control mechanism for granting access of a shared memory service to some composite services and restricting access from the others is devised as part of the present invention. Here the get set access to shared memory services methods is granted or restricted based on containment in a project or a package or directly based on a composite service by name. Referring to for an example a Shared Array structure named FilesSortedBySize is shown and access to the services that act on this Shared Array is granted to only some of the models i.e. composite service definitions within the containing project. Some Hyperservice models within some packages are only granted access to services for getting the shared data some are granted access to services that set the shared data and some are granted access to all of the FilesSortedBySize services.

Based on the method of the present invention composite services are implemented defined by connecting interfaces of other software services that may be composite services to each other and optionally to a set of constructs. Furthermore data mapping is defined based on the inputs and outputs of the interfaces. Also the order of execution and opportunities for concurrent execution of services contained within a composite definition is automatically inferred based on the connectivity i.e. from a dependency perspective of services and constructs. The runtime platform of the present invention automatically instantiates actual service objects corresponding to the interfaces used within a composite definition i.e. Hyperservice model and as explained earlier based on the EXECUTION GRAPH and an INVOCATION MAP object conducts the automatic execution of a composite service. The innovative methods of the present invention provide a new paradigm for building composite software modules.

Given the hierarchical means of organizing the implementing services the system of the present invention provides methods for visualizing the hierarchy of service composition. Referring to on the top left portion of the figure the implementation of a composite service is depicted. This service is implemented with four other composite services i.e. it contains four other composite services CreateDirectory GetPackageToSave GetNthSubPackage and SaveServiceDoc. On the center and bottom right portion of a flattened version of the composition is depicted. Here the implementation of CreateDirectory GetPackageToSave and GetNthSubpackage composite services are selectively flattened to a single level of depth. Similarly and based on this hierarchical flattening method of the present invention the depth of flattening of composite services contained within a parent composite service can be selectively controlled by the application developer. Furthermore based on the method of the present invention the flattened view of a composite service s implementation can be abstracted or unflattened . Abstracting a flattened view hides the details of the composition by replacing the details i.e. the implementation of a composite service with its interface.

A second method for visualizing the hierarchy of service composition is to use a hierarchical tree structure of contained i.e. child services where the leaf nodes of the tree correspond to non composite child services and the non leaf nodes correspond to composite child services. One embodiment for this second method of visualizing the hierarchy of the composition of a composite service is depicted in . On the top left pane of the composition tool for composite services the user selects to explore the implementation of a composite service i.e. Hyperservice model named SavePackageDocs. This results in a hierarchical visualization of the service shown in the bottom left pane of the composition tool. The right pane i.e. the desktop area of the tool shows the direct implementation of the selected service. The hierarchical visualization of the service depicted in the bottom left pane demonstrates the composition of the service from the perspective of service containment in a tree structure. This method of visualization demonstrates to the application developer all the services contained within the selected service as well as all the services contained in those services and so on all the way to the raw material services non composite services. This concept is analogous to the concept of a bill of materials for products in manufacturing applications.

An embodiment of a method of the present invention for encapsulating a portion of the implementation of a composite service is depicted through an example in . As presented in the top portion of the figure the user selects an area of the implementation of a CompositeService 1A that includes two services named AtomicService a and AtomicService b and a chain of conditionals with two branches. After encapsulation as depicted in the bottom portion of the above elements in the selected area are contained in an automatically created composite service CompositeService 2A and removed from the implementation of CompositeService 1A while the interface of CompositeService 2A is inserted inside the implementation of the CompositeService 1A instead of the removed elements. Here an interface for the new composite service CompositeService 2A is automatically created based on the unique aggregation of all the interfaces of the given subset of the services in the selected area that are to be encapsulated. Furthermore an implementation for CompositeService 2A is automatically created containing the selected subset of the contained services. All service interface connectivity and data mapping associated with the subset of selected services is automatically remapped and correctly re associated based on the insertion of the subset in the new automatically generated composite service i.e. CompositeService 2A in the example .

Based on the composition method of the present invention some of the behavior of the software services contained within a composite service implementation can be configured in the context of the containing i.e. parent composite service. As an example of such a context sensitive behavior consider . displays an implementation for the parent service GetGlobalStockQuote where the execution results of one of its contained services ConvertToNum is configured to be cached in the context of GetGlobalStockQuote and automatically purged every 5 minutes from the cache. The cached behavior of ConvertToNum only applies to its usage within the context of GetGlobalStockQuote . Unless otherwise specified the results of executing the ConvertToNum service outside the context of GetGlobalStockQuote will not come from the cache. Other attributes related to the invocation of contained services can be configured in the context of a containing i.e. parent composite service. For example whether to log the service invoked in a context of a composite can be configured in the same context based fashion. How to automate the methods of context sensitive configuration at runtime are obvious to a person expert in the art of software implementation.

Another aspect of the present invention is the ability to load balance the execution of composite services across a cluster of automation runtime platforms instances without requiring the metadata associated with the interface and the definition of composition to be available at every server node of the cluster. To accommodate this all methods for storing and retrieving metadata associated with the definition of interface and implementation of services are themselves implemented as services. Given this the instance of the platform which requests the invocation of a service by the other instances within the cluster provides a callback address to the other instances of the platform within the cluster as part of the request. Other instances use the callback address to dynamically and on demand gather the required metadata while the invocation of the requested service is in progress.

Another aspect of the present invention provides an automatic trigger mechanism whereby the invocation of one service automatically results in the invocation of one or more other composite services herein referred to as TRIGGER MODELS. This mechanism provides a non intrusive way for adding management logic without the need to modify the implementation of the services that define the application logic. In one embodiment of the present invention referring to a user can graphically declare a service to trigger the invocation of one or more TRIGGER MODELS. TRIGGER MODELS are specialized forms of composite definitions strictly used in association with the triggering services. The user can declare a TRIGGER MODEL to be automatically invoked a at the same time the associated i.e. triggering service is invoked b after the completion of the associated service c only after the successful completion of the associated service or d only after the failure of the associated service. An interface for each TRIGGER MODEL is automatically created based on the interface of the associated service wherein the input definition of the TRIGGER MODEL includes all the inputs of the associated service when the trigger is declared to be invoked at the same time as the associated service or upon the failure of the associated service. When the TRIGGER MODEL is invoked upon the completion or successful completion of the associated service the inputs of the TRIGGER MODEL are automatically configured to include all the inputs and outputs of the associated service. Furthermore the method of the present invention provides for the automatic instantiation and invocation of instances of the TRIGGER MODELs upon the invocation of the corresponding associated service.

Another aspect of the present invention provides a system for service oriented asynchronous notification of service invocation within a composite service. Referring to the user can graphically declare a REQUEST EVENT for any software service. Each REQUEST EVENT provides a WAIT construct that is configured to provide as its outputs the input data of the software service associated with the REQUEST EVENT. The WAIT construct also takes a timeout value as an input and a set of request keys that correlate selected inputs of the software service with a REQUEST EVENT. The WAIT construct can be dropped into any composite definition. At runtime all instances of the composite service associated with the composite definition that contains a WAIT construct will block as the execution of each instance reaches the WAIT construct. The blocking continues until either the timeout is reached or the software service associated with the event is invoked with the specified key values. This mechanism combines the power of publish subscribe of the messaging paradigm in a unique service centric fashion to provide an asynchronous mechanism for service notification. Here the execution of any service can be viewed as an implicit publication of an event where the invocation of a service is the event itself. The associated WAIT construct acts as a notification blocking mechanism and the request keys that are the inputs to the event service provide a correlation mechanism. The correlation mechanism issues notification based on correlating some actual key values from the inputs of a service with the key value that was set on the input of the WAIT construct.

A software service or service for short including but not limited to a Web service is a discrete software task that has a well defined interface and may be accessible over the local and or public computer networks or may be only available on a single machine. Web services can be published discovered described and accessed using standard based protocols such as UDDI WSDL Simple Object Access Protocol SOAP and HyperText Markup Language HTML .

A software service interface in concept represents the inputs and outputs of a black boxed software service as well as the properties of that service such as name and location. Take for example the interface of a simple software service named GetStockQuote which retrieves simple stock quote information . This service takes a ticker symbol input and returns the last trade price amount as well as some additional stock quote details such as the day high and day low. Note that in order to use or consume a service only knowledge of its interface is required. This means that as long as the interface of a service remains the same different implementations of the service can be swapped in and out without affecting its consumers. This as well as the fact that a service is a language and platform neutral concept is one of the keys to the flexibility of service oriented architectures.

An atomic service is a software service that is implemented directly by a segment of software code. In the existing NextAxiom HyperService Platform atomic Web services are dispatched via a library. A library is a light language and platform neutral wrapper that is linked to one or more atomic Web service implementations. Atomic Web services are logically indivisible Web services that represent raw materials to the HyperService platform.

A composite service is a software service that consumes any number of other atomic or composite services. In the HyperService platform a composite Web service is implemented with a metadata driven model that is automatically interpreted by a high performance runtime engine.

Visual metadata models which represent composite software services implementations to the HyperService system are created in a graphical design time environment and stored as XML models. This environment offers a new and powerful visual modeling paradigm that can be leveraged to enable the visual modeling of transactional behavior. This environment was specifically designed to enable collaborative on the fly creation of software services by business process analysts or functional experts who understand the business logic and application required to implement real world business processes and applications but have no knowledge of programming paradigms or Web service protocols. captures the implementation of a composite software service named Expedite 3000 Series . This service is used by a master planner to expedite 3000 series inventory items when they fall short on the shop floor. This service was developed collaboratively and reuses services that were selectively exposed by the Inventory and Purchasing departments to the developers of this service.

Any software service that is consumed by a composite service model is said to be nested or embedded within that composite service. depicts a hypothetical composite service that resides in Chicago. This software service is composed of other composite services that are distributed across the country.

