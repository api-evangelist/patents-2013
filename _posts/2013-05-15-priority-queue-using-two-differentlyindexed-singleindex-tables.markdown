---

title: Priority queue using two differently-indexed single-index tables
abstract: Methods and apparatus for efficient priority queues using single-index tables are disclosed. In response to a request to generate an instance of a priority queue using a database that permits no more than one index per table, an identifier-indexed table and a priority-indexed table are set up. In response to a request to insert a queue entry with a given identifier and a given priority, one tuple is inserted into each table. In response to a request to remove an entry with a specified identifier, a tuple with the specified identifier is removed from the identifier-indexed table, while the removal of the corresponding tuple from the priority-indexed table may be deferred.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09514170&OS=09514170&RS=09514170
owner: Amazon Technologies, Inc.
number: 09514170
owner_city: Reno
owner_country: US
publication_date: 20130515
---
Priority queues are utilized for a number of important computer based applications. For example worker threads of a large scale distributed computation may be configured to periodically retrieve the highest priority task among the tasks currently placed in a prioritized work queue remove the highest priority task from the queue and perform the corresponding work operations. The tasks may be prioritized and placed into the work queues as needed by schedulers or task generators that operate independently of and asynchronously with respect to the worker threads. Such operational models may be used at various task granularities from long lasting data transfer jobs to medium scale software development deployment tasks to relatively short computations or analysis tasks.

The types of operations typically supported for priority queues may include for example queue creation and deletion insertion of a new queue entry with a corresponding entry identifier and priority value removal of an entry with a specified identifier removal of an entry based on a priority criterion e.g. an entry with the currently highest priority or with a specified priority and retrieval of entries based on various criteria for identifiers and or priorities. Some queue based applications may have additional requirements such as cost constraints consistency integrity requirements and the like.

A number of different underlying techniques may be used to implement priority queue mechanisms depending for example on the infrastructure technologies e.g. the various types of storage systems or database systems available and the costs involved. In some na ve implementations of priority queues the costs of doing some of the types of common queue operations e.g. the number of reads and writes required for a given operation which may translate directly or indirectly into client costs may be dependent on the number of entries in the queue. For many applications however the number of entries that a given priority queue may have to hold is not easily predictable and queue sizes may in some cases be expected to grow over time. In such scenarios therefore clients interested in priority queue services may wish to utilize implementations in which the costs of doing typical queue operations are low and as far as possible independent of the number of queue entries.

While embodiments are described herein by way of example for several embodiments and illustrative drawings those skilled in the art will recognize that embodiments are not limited to the embodiments or drawings described. It should be understood that the drawings and detailed description thereto are not intended to limit embodiments to the particular form disclosed but on the contrary the intention is to cover all modifications equivalents and alternatives falling within the spirit and scope as defined by the appended claims. The headings used herein are for organizational purposes only and are not meant to be used to limit the scope of the description or the claims. As used throughout this application the word may is used in a permissive sense i.e. meaning having the potential to rather than the mandatory sense i.e. meaning must . Similarly the words include including and includes mean including but not limited to.

Various embodiments of methods and apparatus for implementing efficient priority queues using single index tables are described. The term priority queue or priority queue instance may be used herein to refer to a logical entity that includes one more entries where each entry has at least a respective identifier and a respective priority relative to other entries and where the queue supports at least the following types of operations a insertion of an entry with a specified identifier and a specified priority b removal of an entry with a specified identifier and c retrieval of the identifier of the entry with the highest priority in the queue. These three operation types may be referred to herein as INSERT REMOVE BY ID and RETRIEVE HIGHEST PRIORITY operations. Priority queue instances may offered as part of a network accessible service such a multi tenant or a single tenant service in some embodiments and clients of the priority queue service may be enabled to customize their queue instances e.g. by selecting among various implementation choices that provide different tradeoffs between storage and computation costs as described below . The term priority queue mechanism as used herein may refer to the underlying algorithmic design and infrastructure used for a given implementation each priority queue mechanism may be used to create numerous priority queue instances at client request. One or more priority queue mechanisms may be supported in a given embodiment.

In at least some embodiments the contents of a given entry in a priority queue may include more than just a priority and identifier. For example in one embodiment in which clients use priority queues for managing work tasks a data object representing details of the work to be performed for a given task may be included in the corresponding queue entry. Furthermore in some embodiments in addition to the INSERT REMOVE BY ID and RETRIEVE HIGHEST PRIORITY operation types other operation types may be supported as well such as operations to remove an entry in accordance with a priority criterion e.g. to remove an entry with the highest priority or to remove an entry with a specified priority or to retrieve the identifier of an entry based on a priority criterion. In one embodiment respective programmatic interfaces e.g. application programming interfaces or APIs may be implemented to support each of the operation types. Programmatic interfaces that combine some set of simpler operation interfaces into a single interface invocation may be supported in some implementations as well e.g. an operation to change the priority of a given entry with a specified identifier may be supported by an API call that performs a REMOVE BY ID operation followed by an INSERT operation for an entry with the same identifier and a changed priority value.

In at least some embodiments a priority queue mechanism may utilize a database system to store contents of the queue entries. In some embodiments a database system that supports no more than one index per table may be used that is while a given tuple or row in a table may comprise a plurality of fields columns only one of the fields may be used as the key for an index on the table. Such a database system may be referred to herein as a single index per table database and the tables in such a database system may be referred to herein as single index tables. Single index per table databases may be especially prevalent in scenarios in which it is permissible for different tuples of a table to include different sets of fields. For example in one non relational database system a given tuple T1 of a table Table 1 may include values for fields userid name address while another tuple T2 of the same table may include values for a different set of fields userid name address phone and yet another tuple T3 may only include a userid value. In this example scenario only the userid field may be required for a tuple to be valid and the only index allowed or supported may be an index on userid.

A category of database systems called provisioned input output or provisioned I O databases may be used for priority queues in some embodiments. In a provisioned I O database as the term is used herein an operation supported by the database may be characterized by the number of reads and writes i.e. I Os that have to be performed on the underlying persistent storage device s being used for the database. Thus for example a given logical operation O1 may be characterized as requiring two reads and two writes some of which may be directed to different tables while a different logical operation O2 may be described as requiring one read and one write. In at least some embodiments the financial cost to a client of a provisioned I O database may be proportional to the number of reads and or writes performed on behalf of the client. In some embodiments the costs of reads may in general differ from the costs of writes while in other embodiments reads and writes may have equal costs. In at least one embodiment in which indexes are used reads and writes on index entries may not be included when computing or estimating the total number of reads or writes for a given operation since indexes are generally cached in memory and thus index I O operations often do not involve I O to persistent storage. In some embodiments priority queue entries may be implemented using a single index per table database that is also a provisioned I O database. In other embodiments priority queues may be implemented using either a single index per table database that is not a provisioned I O database a provisioned I O database that is not a single index per table database or using a database that is neither a provisioned I O database nor restricted to one index per table.

According to one embodiment in response to a request to generate an instance of a priority queue using a provisioned I O database that permits no more than one index per database table a queue management system of one or more computing devices may configure two tables in the database an identifier indexed table i.e. a table whose only permitted index uses queue entry identifiers as keys and a priority indexed table i.e. a table whose only permitted index uses priority values as keys . Identifier indexed tables may be referred to herein as I I tables and priority indexed tables may be referred to as P I tables. Each queue entry of the instance may be represented by a pair of tuples in such an embodiment comprising a tuple in the I I table and a tuple in the P I table. In response to a request to insert a queue entry into the instance e.g. a request for an INSERT operation as described above one tuple which includes at least an identifier field may be inserted into the I I table and one tuple which includes at least a priority field and an identifier field may be inserted into the P I table. The indexes for both tables may also be updated accordingly e.g. the identifier based index on the I I table and the priority based index on the P I table may be updated to reflect the new entry.

In response to a request to remove an entry with the specified identifier e.g. a request for a REMOVE BY ID operation as described above specifying the identifier ID k the system may thus need to eventually remove a respective entry from both tables the I I table and the P I table being used for the instance in such embodiments. The manner in which REMOVE BY ID operations are implemented may differ in different implementations depending for example on the contents of the tuples in the I I table. In one space efficient approach referred to herein as technique S for space efficient a tuple in the I I table may be considered valid if it contains only the identifier of the corresponding queue entry thus there may be no requirement for the I I table to contain any other fields than the identifier field. In another approach which may utilize more storage space for the I I table but may simplify and or reduce the number of operations and hence the time required for some queue operations relative to technique S as described below each row in the I I table may be required to include both an identifier field and a priority field. The latter approach in which tuples of the I I table include identifier fields as well as priority fields may be referred to herein as technique T for time efficient . In some embodiments a given priority queue system may implement both technique S and technique T e.g. some queue instances may use technique S while others may use technique T or a decision may be made at run time as to whether to use technique S or technique T for a given queue instance. In one embodiment the choice of technique may be based on client preferences or client specifications e.g. if a particular client C1 wishes to minimize latency and is willing to pay for more storage technique T may be used for a queue instance for C1 while if a client C2 is less willing to pay for storage and is willing to accept slightly longer latencies for some operations technique S may be used . It is noted that the names technique S and technique T are used herein primarily to help with the ease of presentation and that either technique may be sufficiently space efficient and time efficient for the vast majority of clients in at least some embodiments e.g. the differences in space usage and or operation costs associated with queue operations may be very small compared to the other tasks being performed using the queues.

If technique T is being used for a given priority queue instance in one embodiment and a REMOVE BY ID request is received the tuple T1 corresponding to the specified identifier ID k in the I I table may contain a priority value P k that can be used to identify using an index lookup the tuple T2 to be removed from the P I table. Accordingly an index lookup into the I I table may result in a straightforward identification of both tuples to be deleted and both tuples T1 and T2 thus identified may be removed from their respective tables in such an embodiment.

If technique S is being used tuple T1 may be identified using key ID k and the identifier based index of the I I table but the identification of tuple T2 may not be so straightforward. As the only available index on the P I table uses priority rather than the identifier as the key and the priority value P k is not available from T1 in technique S index based lookups cannot be used to efficiently identify T2. Accordingly in some embodiments in response to a REMOVE BY ID request the queue management system may be configured to a perform the removal of the T1 tuple from the I I table and b defer the removal of the T2 tuple from the P I table. In one embodiment the removal of T2 may be deferred until a a RETRIEVE HIGHEST PRIORITY request leads to the identification of T2 as the tuple with the highest priority in the P I table and b a check to determine whether the I I table contains a corresponding entry to T2 i.e. T1 with the same identifier ID k that the identifier field of T2 contains reveals that T1 was already removed. If the prior removal of T1 is thus deduced T2 may be removed from the P I table and the entry T3 with identifier ID 1 in the P I table that now i.e. after T2 s removal has the highest priority may in turn be a candidate for the response to the RETRIEVE HIGHEST PRIORITY request. Just as the I I table was checked to validate that T1 had not been removed the I I table may now be checked again to validate that the tuple with identifier ID 1 was not removed previously. If the I I table does not contain an entry with identifier ID 1 this may constitute evidence that T3 should also be removed as its counterpart tuple in the I I table no longer exists and T3 may be removed accordingly in such an embodiment. This process of identifying the tuple corresponding to an apparent highest priority entry and checking for previous removals in the I I table may be repeated until a tuple is found in the I I table for the current apparent highest priority entry as indicated by the P I table. Only after the queue management system validates that a corresponding tuple exists in the I I table would the corresponding identifier be provided to the requesting client in such an embodiment. Thus the deferring of the removal of tuples from the P I table may impact the apparent cost in reads and writes of the RETRIEVE HIGHEST PRIORITY operations in embodiments in which technique S is used. Further details regarding cost analysis for various types of queue operations is provided below in the context of the description of .

In at least some embodiments as mentioned above both techniques S and T may be used or a hybrid technique encompassing aspects of both approaches may be used. In one such embodiment for example when a REMOVE BY ID request for a queue entry with identifier ID k is received the contents of the T1 tuple with identifier ID k in the I I table may be examined to determine whether T1 contains information such as a priority field that can be used to access using an index lookup or less than a threshold number of reads the tuple T2 to be deleted from the P I table. The threshold number may be some small number N of reads that is not directly proportional to the total number of tuples in the P I table for example an index based lookup may be expected to require substantially fewer reads than a table scan may require. If T1 does contain such information e.g. if an approach similar to technique T is employed for at least T1 in that T1 includes a priority value or some other pointer to efficiently access T2 then T1 and T2 may be removed from the I I table and the P I table respectively. If T1 does not contain such information usable to identify or access T2 T1 may be removed from the I I table but the removal of T2 may be deferred in such an embodiment e.g. until as described above a RETRIEVE HIGHEST PRIORITY request leads to the identification of T2 s entry as the apparent highest priority entry but a check of the I I table indicates that T1 was removed earlier and consequently T2 is removed .

In some embodiments the check as to whether a corresponding I I table tuple was removed may also or instead be performed in response to other types of requests than RETRIEVE HIGHEST PRIORITY requests. For example in one embodiment a RETRIEVE BY PRIORITY request may be supported in which the identifier of a queue entry based on a specific priority value e.g. rather than the highest priority may be retrieved at client request. In response to a RETRIEVE BY PRIORITY request that specifies a particular priority value the queue management system may look up a tuple in the P I table with the specified priority and validate that a corresponding tuple in the I I table exists with the same identifier before returning the identifier to the requesting client. If no corresponding tuple exists in the I I table the entry in the P I table may be removed. Deferred removals of the tuples from the P I table similar to those described above may be performed in response to RETRIEVE BY PRIORITY requests e.g. in addition to RETRIEVE HIGHEST PRIORITY requests in some embodiments.

The queue management system may in some embodiments be configured to ensure that each priority value assigned to a tuple in either the P I table or the I I table is unique with respect to the priority values of other tuples. For example from the clients point of view in some embodiments the queue entries may at least initially be given priorities from among a discrete set of priority levels such as priority levels 1 2 3 4 and 5 with level 1 being the lowest priority and level 5 being the highest priority. The queue management system may in such an embodiment concatenate a unique timestamp value or a sequence number that is incremented upon each use with the priority level to obtain a unique priority value to be used in the database tables. Thus in one scenario a priority field may be configured to be 32 bits wide with the first 8 bits used for a priority level encoding and the remaining 24 bits used for a unique sequence number or timestamp. Other data may be encoded within the priority field as well in some embodiments such as portions or all of the identifier of the queue entry a client identifier and so on. In some embodiments a unique string not necessarily based on a timestamp or a sequence number may be generated for use as part of the priority value to be stored internally by the priority queue service.

At a given point in time a given queue instance may comprise some number of queue entries . For example queue instance A is shown with two entries A and B while queue instance B is shown with three entries K L and M. The entries may represent logical entities backed by physical data stored in the tuples of the corresponding table pairs . Conceptually each entry may comprise an associated unique identifier an associated priority value and zero or more additional attributes or fields such as details on the nature of the work to be performed in scenarios in which the entries represent units of work to be performed . One or more physical representations of the identifier and or the priority value may be stored in tuples of the I I table and the P I table in the depicted embodiment. For example in one implementation corresponding to technique S as described above each tuple of a P I table may comprise at least a priority value for a corresponding entry and an identifier for the entry while each tuple of an I I table may comprise at least the identifier for the entry . In a different implementation corresponding to technique T as described above the P I tables may be configured in the same way as in technique S while tuples of I I tables may include both the identifier and the priority value of the corresponding entry . In some embodiments the priority queue manager may be configured to implement a combination of these two approaches in which for example some queue instances may use I I tables that include priority values while other queue instances may use I I tables that do not include priority values.

When a client request to perform a queue operation on a given instance is received e.g. as part of a queue operation interaction the priority queue manager may translate the request into one or more underlying read and or write operations on one or both tables of the table pair corresponding to the instance . The specific reads and or writes performed for various types of operation are described below for several implementation techniques and the number of reads and writes needed for the operation types are shown in . In general less storage may be used for technique S implementations than for technique T implementations because priority values may not be stored in the I I tables in technique S The smaller storage cost may however be accompanied by slightly higher average costs for some operations such as REMOVE BY ID or RETRIEVE HIGHEST PRIORITY in technique S than technique T. Thus storage costs for queue management may be traded off against operation costs in at least some embodiments. In addition factors related to data consistency and or normalization may come into play when deciding between technique S and technique T for example some implementations of technique T may require that the queue manager ensures that the priority value from the P I table tuple is replicated in a consistent manner in a corresponding tuple of the I I table. Ensuring such consistency may involve additional costs e.g. imposition of some approximation of commit semantics or transaction boundaries that may offset the savings for REMOVE BY ID and RETRIEVE HIGHEST PRIORITY queue operations.

As also shown in according to I I table layout A only an ID field may be required for I I tables in technique S although additional fields may be included optionally e.g. to represent some subset or all of the attributes . IDs may serve as keys for index in the depicted embodiment. In some embodiments when a client submits an INSERT request for an entry the ID may not necessarily be unique relative to the other IDs already included in the entries of the queue instance. In such a scenario the queue manager may be responsible for converting the ID value supplied by the client to a unique ID value for storage in the database. Techniques similar to those used for ensuring that priority values are unique may be employed e.g. the ID supplied by the client may be concatenated with unique random strings timestamps or sequence numbers to arrive at the ID values and .

In technique T as shown in the layout B of the P I table may be similar to the P I table layout of technique S e.g. each tuple in the P I table may have a priority value used as a key for priority based index an ID field and zero or more optional fields . However the I I table layout B may differ from the I I table layout of in that in addition to an ID field that servers as a key for ID based index a priority value may also be required. As in the case of the I I table layout for technique S zero or more optional fields may also be stored in the I I table tuples. The presence of the priority values may be helpful in simplifying the REMOVE BY ID operations of technique T relative to technique S as described below. It is noted that at least in some embodiments not all the tuples of a given table in either technique S technique T or both may have the same set of fields e.g. some tuples within an I I table may have more optional fields than other tuples in the same I I table and similarly some tuples within a given P I table may contain different fields than other tuples within that same P I table.

For INSERT operations in which clients request an insertion of an entry with a specified ID and priority value element the queue manager performs one write to each of the tables the P I table and the I I table regardless of whether technique S is being used element or technique T is being used element . Note however that the amount of data written may be large in technique T than in technique S since the priority value has to be written to the I I table in technique T but not in technique S . In many database systems however the additional costs of adding the priority values may typically be quite small. Thus the I O costs of INSERTs do not differ substantially for the two techniques S and T in the depicted embodiment.

For REMOVE BY ID operations element the computation of the number of I Os performed is relatively straightforward for technique T element . Using the specified ID the queue manager identifies and reads the tuple T1 of the I I table that is to be removed deleted and using the priority value stored in T1 the queue manager can use P I s index to identify the tuple T2 of the P I table that is to be deleted. Thus both of the tuples to be deleted can be identified using a respective index no table scans or other potentially long operations are required . Accordingly the REMOVE BY ID operation translates to one read from the I I table followed by one write i.e. a delete to each table.

However in technique S element an index lookup of tuple P2 may not be feasible in response to a REMOVE BY ID request as the I I table does not include priority values. Accordingly in technique S in the depicted embodiment while the write delete to the I I table to remove tuple T1 may be immediate the delete of tuple T2 from the P I table may be deferred element e.g. until a RETRIEVE HIGHEST PRIORITY request is received that results in the determination of T2 as the highest priority entry s tuple. At the time that such a RETRIEVE HIGHEST PRIORITY request is received the queue manager may check the I I table to validate that a tuple with the same ID as T2 is present. Since T1 was the only entry that had the same ID as T2 and T1 was removed in the immediate part of the response to the REMOVE BY ID operation no such tuple may be found. This absence of a matching tuple in the I I table may indicate that the deferred part of the REMOVE BY ID operation is now to be completed and accordingly T2 may be deleted from the P I table. In the depicted embodiment an amortization analysis using the accounting method is used to assign some of the costs of the eventual RETRIEVE HIGHEST PRIORITY operation that leads to T2 s deletion to the REMOVE BY ID operation that was partially deferred. The I O operation costs of the additional checking required during the eventual RETRIEVE HIGHEST PRIORITY operation are thus represented in by one read each to the P I table and the I I table in the deferred operations corresponding to element for REMOVE BY ID . The fourth operation listed in element a write to the P I table corresponds to the actual deferred deletion of T2 from the P I table. Thus the total cost including the amortized or deferred components for REMOVE BY ID is four I Os in the depicted embodiment. It is noted that the extra read and write operations for the deferred portion of REMOVE BY ID processing would happen no more than once for a given queue entry because for a given ID only one corresponding tuple is inserted into the P I table and so no more than one deferred removal would be required which is why the extra cost of the deferred removal is captured by a single read to each of the two tables.

In the embodiment shown in for a RETRIEVE HIGHEST PRIORITY operations element of in technique S one read operation on the P I table to access the highest priority tuple using the priority based index would be required followed by one read operation on the I I table to verify that the highest priority tuple of the P I table still has a corresponding tuple with the same ID in the I I table element . Of course in case the entry in the I I table was removed previously as part of the immediate operations performed for a REMOVE BY ID request the deferred removal of the P I table tuple would be performed and the process of reading and verifying would be repeated. However the costs of such deferred removals have already been accounted for in element as described above and as noted above the deferred removal costs would be incurred only once per queue entry hence costs associated with deferred removals do not need to be represented in element . In technique T there would be no need to verify the existence of tuples in the I I table since there are no deferred operations in technique T and so a RETRIEVE HIGHEST PRIORITY entry would take only one read to the P I table as shown in element . It is noted that the costs in I O operations of the RETRIEVE HIGHEST PRIORITY operation would be the same as the costs of a more general RETRIEVE BY PRIORITY operation in which a client requests the ID of the entry with a specified not necessarily the highest priority. Thus for the general RETRIEVE BY PRIORITY operation in technique S the same kind of check would have to be performed on the I I table to check for a previous REMOVE BY ID as was described above for a RETRIEVE HIGHEST PRIORITY operation.

In some embodiments a REMOVE HIGHEST PRIORITY operation element may also be supported in which a client requests the removal from the queue instance of an entry with the highest priority. The cost of such an operation can be computed as indicated in element by combining the costs of the RETRIEVE HIGHEST PRIORITY operation to obtain the ID of the highest priority entry and the REMOVE BY ID operation to remove the tuples with the obtained ID from both tables . Thus for technique S the cost of REMOVE HIGHEST PRIORITY would be 4 reads and 2 writes the sum of the costs in elements and and for technique T the cost of REMOVE HIGHEST PRIORITY would be one read and two writes the sum of the costs shown in elements and . In at least some embodiments in which a REMOVE BY PRIORITY operation is supported its costs would also be the same as the REMOVE HIGHEST PRIORITY costs.

It is noted that from the client perspective the precise number of writes or reads required for a given operation may not matter very much in at least some embodiments as long as the number of operations is small and does not increase linearly with the total number of queue entries. In such embodiments clients may wish to avoid full table scans whose costs in operations may increase linearly with queue entry counts in favor of index based lookups and both techniques S and T utilize index based lookups and avoid full table scans. The selection of technique S versus technique T may thus be based on considerations other than performance e.g. on whether a given client considers the extra storage space required for technique T a sufficient deterrent to prefer the slightly higher operation counts encountered when using technique S. In at least some embodiments the queue management system e.g. the queue manager may provide e.g. at client request or during initial configuration of a queue instance an explanation or enumeration of the I O operation counts expected to be incurred for the various queue operations supported in a given implementation.

It is noted that the details of how reads and writes are performed may vary in different databases in some embodiments for example some databases may be implemented as write once systems in which a given tuple is never overwritten in place while other databases may allow overwriting of a given tuple. In one embodiment multiple replicas may be maintained of each table which may result in a different number of operations than illustrated in for at least some queue operations although the fact that both techniques S and T avoid the use of table scans may still hold .

In some embodiments the queue manager may optionally provide I O operation cost estimates such as those illustrated in for various queue operations and or storage cost estimates e.g. indicating how much total database storage space is likely to be used for the queue instance assuming some maximum number of entries for a proposed implementation to the client element . If the client wishes to change the proposed implementation based on the cost estimates or the storage estimates the client may provide an indication accordingly. After a decision regarding the specific technique is reached or if there is only one technique supported in the depicted embodiment the queue manager may set up or configure the two tables in the database element accordingly the I I table and the P I table. In one embodiment the information about operation costs may be provided or confirmed to the client after the particular implementation e.g. technique S or technique T that is to be used is determined. Having set up the table pair to be used for the instance the queue manager may provide a reference to the instantiated queue instance such as an instance name to the requesting client element enabling the client to proceed with further queue operations.

It is noted that the client may not be provided details regarding the database tables e.g. the table names or layouts or the specific technique being used in at least some embodiments and may not even be made aware that database tables are being used for implementing the queue mechanism. From the perspective of the client an instance of a priority queue with a specified name and a set of supported operations supported via one or more client interfaces may be made accessible and the details of how those operations are implemented may not be of much interest.

In the embodiment depicted in after ensuring the uniqueness of the priority value one tuple each may be inserted into the P I and the I I tables element . The contents of the I I table tuple may depend on the specific implementation e.g. for technique T a priority value may be stored in the I I tuple while for technique S priority values need not be stored in the I I tuple. After the insertion of the tuples succeeds a response indicating successful insertion of the queue entry may be provided to the client in some embodiments element . It is noted that in some embodiments the two tuple insertions may comprise part of a single atomic operation e.g. transaction semantics may be used to ensure that either both tuples are successfully inserted or neither tuple is inserted while in other embodiments such atomicity may not be required.

If tuple T1 is identified as also determined in element in the depicted embodiment the subsequent operations may depend on whether technique S or technique T is being implemented. If T1 contains information e.g. a priority value for the entry that can be used for an index lookup on the P I table that can be used to efficiently identify the tuple T2 of the P I table that is to be deleted as determined in element e.g. if technique T is being used then both T1 and T2 may be deleted respectively from the I I table and the P I table immediately element .

If however T2 cannot be efficiently found e.g. if a table scan could be required on the P I table which would mean that the number of operations required to find and delete T2 may be proportional to the size of the P I table as would be the case if technique S is in use only T1 may be deleted from the database immediately and the removal of T2 may be deferred element . In one embodiment for example the deletion of T2 would be deferred until a a RETRIEVE HIGHEST PRIORITY request is received and T2 is found as the tuple with the highest priority in the P I table and b a check of the I I table reveals that T1 the tuple with the same ID as T2 was previously removed thus indicating that T2 s deferred removal is required. In another embodiment in which RETRIEVE BY PRIORITY or other retrieval operations based on priority criteria e.g. retrieval operations in which priority ranges are specified are supported a request to retrieve the ID of a queue entry with T2 s priority may similarly lead to the discovery during a verification step involving checking to see that the I I table contains an entry corresponding to T2 that T1 has already been deleted and thus would also result in T2 being deleted.

In the embodiment depicted in the client may be notified that the REMOVE BY ID operation succeeded element whether part of the corresponding set of operations were deferred or not. The client may be so notified even if the T2 deletion was deferred because the deferral of the physical deletion from the P I table does not affect the logical consequences of the REMOVE BY ID request from the client s perspective e.g. after a REMOVE BY ID operation is declared successful the corresponding queue entry can no longer be accessed by clients using the programmatic interfaces .

In one embodiment another approach to deferred deletions from the P I table may be taken. A cleanup thread or process may be implemented responsible for periodically examining some subset e.g. the highest 10 of the P I table tuples ranked by priority or all of the P I table in such an embodiment and verifying that corresponding tuples exist in the I I table. If such a cleanup thread process finds a tuple Tk in the P I table with ID Ik while no entry for Ik can be found in the I I table then Tk may be removed from the P I table.

Subsequent operations may depend on the implementation in use e.g. on whether technique S or technique T is being employed. If technique T is in use or if tuples in the I I table contain priority value fields usable to immediately remove corresponding tuples of the P I table in response to REMOVE BY ID requests as detected in element ID1 may be immediately returned to the requesting client element as there would be no need to check for any deferred removals. If technique S is in use e.g. if deferred removals from the P I table as described above are being implemented as also detected in element the I I table may be checked to determine whether a tuple with ID equal to ID1 exists in the I I table. If such a tuple exists as detected in element this may confirm that the apparent highest priority tuple T1 is valid and does not require a deferred removal and its ID ID1 may be returned to the requesting client element .

If however the check of the I I table reveals that no corresponding tuple exists in the I I table as also determined in element this means that a REMOVE BY ID specifying ID1 was received earlier. Accordingly T1 may be removed from the P I table as part of a deferred portion of the earlier removal element . At this point the next highest priority tuple in the P I table may be processed in the same way as T1 was processed earlier e.g. the operations corresponding to elements onwards may be repeated for the tuple that now has the highest priority in the P I table. This processing loop may be repeated e.g. if there happen to be several deferred removals required for successive tuples found with the highest priority in the P I table until the currently highest priority tuple of the P I table is found to have a corresponding tuple in the I I table in which case the ID of the that tuple would be returned to the requesting client element .

In some embodiments in addition to retrieval requests for the highest priority entries requests to retrieve the IDs of queue entries based on other priority criteria may be supported. is a flow diagram illustrating aspects of operations that may be performed to retrieve the identifier of the queue entry with a specified priority P e.g. not necessarily the highest priority as in the case of among the entries in a priority queue instance according to at least some embodiments. As shown in element such a request which may be termed a RETRIEVE BY PRIORITY request may be received e.g. by the priority manager via one of the programmatic interfaces . As shown in element the queue manager may determine whether the P I table contains a tuple with priority P. If such a tuple is found its ID value ID1 may be obtained. If no such tuple is found an optional error message may be returned to the requesting client element .

As in the case of subsequent operations may depend on the implementation in use e.g. on whether technique S or technique T is being employed. If technique T is in use or if tuples in the I I table contain priority value fields usable to immediately remove corresponding tuples of the P I table in response to REMOVE BY ID requests as detected in element ID1 may be immediately returned to the requesting client element as there would be no need to check for any deferred removals. If technique S is in use e.g. if deferred removals from the P I table as described above are being implemented as also detected in element the I I table may be checked to determine whether a tuple with ID equal to ID1 exists in the I I table. If such a tuple exists as detected in element this may confirm that the tuple T1 does not require a deferred removal and its ID ID1 may be returned to the requesting client element .

If however the check of the I I table reveals that no corresponding tuple exists in the I I table as also determined in element this means that a REMOVE BY ID specifying ID1 was received earlier. Accordingly T1 may be removed from the P I table as part of a deferred portion of the earlier removal element . In some embodiments an error message may be provided to the client indicating for example that the entry with the specified priority does not exist in the queue instance element .

It is noted that in various embodiments the operations illustrated in the flow diagrams of may be performed in a different order than that shown or some operations may be performed in parallel. In some embodiments some of the operations illustrated in may be omitted. For example in embodiments in which only technique S is implemented the operations corresponding to determining whether technique S or technique T is in use may be omitted and the operations corresponding to the implementation of technique T alone may also be omitted. Similarly in embodiments in which only technique T is implemented the operations corresponding to determining whether technique S or technique T is in use may be omitted and the operations corresponding to the implementation of technique S alone may be omitted. In some embodiments in which the priority queue management system changes the priority values from those initially indicated by the clients e.g. in order to ensure that each queue entry has a unique priority value as mentioned earlier and the clients are not aware of the priority value assigned by the system clients may not be able to submit requests based on specific priority values. Similarly clients may not specify priority values at all in some embodiments and the system may assign priorities to queue entries based on factors such as entry insertion request time e.g. in one implementation if an insertion request for an entry E1 is received at time T1 while an insertion request for an entry E2 is received at time T2 later than T1 if the requests do not indicate priorities for the entries the system may be configured to automatically assign E1 a higher priority than E2 . In at least some such embodiments in which clients may not know specific priority values operations corresponding to may not be implemented.

The techniques described above of providing support for efficient priority queues using single index tables may be useful in a variety of different scenarios. For example in some provider networks configured to support a variety of network accessible services one of the services already being provided may comprise an efficient I O provisioned single index per table database. In such an environment a priority queue mechanism of the type described above may be built and tested with relatively low cost using the preexisting database service. The mechanism may be used for a variety of applications including for example work distribution applications in which tasks are generated prioritized and placed on a queue instance for consumption by worker threads or for large scale data analysis or scientific computations that can be broken down into smaller prioritized tasks.

In at least some embodiments a server that implements a portion or all of one or more of the technologies described herein including the techniques to implement the various components of priority queue management system such as the queue manager and the database may include a general purpose computer system that includes or is configured to access one or more computer accessible media. illustrates such a general purpose computing device . In the illustrated embodiment computing device includes one or more processors coupled to a system memory via an input output I O interface . Computing device further includes a network interface coupled to I O interface .

In various embodiments computing device may be a uniprocessor system including one processor or a multiprocessor system including several processors e.g. two four eight or another suitable number . Processors may be any suitable processors capable of executing instructions. For example in various embodiments processors may be general purpose or embedded processors implementing any of a variety of instruction set architectures ISAs such as the x86 PowerPC SPARC or MIPS ISAs or any other suitable ISA. In multiprocessor systems each of processors may commonly but not necessarily implement the same ISA.

System memory may be configured to store instructions and data accessible by processor s . In various embodiments system memory may be implemented using any suitable memory technology such as static random access memory SRAM synchronous dynamic RAM SDRAM nonvolatile Flash type memory or any other type of memory. In the illustrated embodiment program instructions and data implementing one or more desired functions such as those methods techniques and data described above are shown stored within system memory as code and data .

In one embodiment I O interface may be configured to coordinate I O traffic between processor system memory and any peripheral devices in the device including network interface or other peripheral interfaces. In some embodiments I O interface may perform any necessary protocol timing or other data transformations to convert data signals from one component e.g. system memory into a format suitable for use by another component e.g. processor . In some embodiments I O interface may include support for devices attached through various types of peripheral buses such as a variant of the Peripheral Component Interconnect PCI bus standard or the Universal Serial Bus USB standard for example. In some embodiments the function of I O interface may be split into two or more separate components such as a north bridge and a south bridge for example. Also in some embodiments some or all of the functionality of I O interface such as an interface to system memory may be incorporated directly into processor .

Network interface may be configured to allow data to be exchanged between computing device and other devices attached to a network or networks such as other computer systems or devices as illustrated in through including various devices serving as clients for example. In various embodiments network interface may support communication via any suitable wired or wireless general data networks such as types of Ethernet network for example. Additionally network interface may support communication via telecommunications telephony networks such as analog voice networks or digital fiber communications networks via storage area networks such as Fibre Channel SANs or via any other suitable type of network and or protocol.

In some embodiments system memory may be one embodiment of a computer accessible medium configured to store program instructions and data as described above for through for implementing embodiments of the corresponding methods and apparatus. However in other embodiments program instructions and or data may be received sent or stored upon different types of computer accessible media. Generally speaking a computer accessible medium may include non transitory storage media or memory media such as magnetic or optical media e.g. disk or DVD CD coupled to computing device via I O interface . A non transitory computer accessible storage medium may also include any volatile or non volatile media such as RAM e.g. SDRAM DDR SDRAM RDRAM SRAM etc. ROM etc. that may be included in some embodiments of computing device as system memory or another type of memory. Further a computer accessible medium may include transmission media or signals such as electrical electromagnetic or digital signals conveyed via a communication medium such as a network and or a wireless link such as may be implemented via network interface . Portions or all of multiple computing devices such as that illustrated in may be used to implement the described functionality in various embodiments for example software components running on a variety of different devices and servers may collaborate to provide the functionality. In some embodiments portions of the described functionality may be implemented using storage devices network devices or special purpose computer systems in addition to or instead of being implemented using general purpose computer systems. The term computing device as used herein refers to at least all these types of devices and is not limited to these types of devices.

Various embodiments may further include receiving sending or storing instructions and or data implemented in accordance with the foregoing description upon a computer accessible medium. Generally speaking a computer accessible medium may include storage media or memory media such as magnetic or optical media e.g. disk or DVD CD ROM volatile or non volatile media such as RAM e.g. SDRAM DDR RDRAM SRAM etc. ROM etc. as well as transmission media or signals such as electrical electromagnetic or digital signals conveyed via a communication medium such as network and or a wireless link.

The various methods as illustrated in the Figures and described herein represent exemplary embodiments of methods. The methods may be implemented in software hardware or a combination thereof. The order of method may be changed and various elements may be added reordered combined omitted modified etc.

Various modifications and changes may be made as would be obvious to a person skilled in the art having the benefit of this disclosure. It is intended to embrace all such modifications and changes and accordingly the above description to be regarded in an illustrative rather than a restrictive sense.

