---

title: Generic model for customizing protocol behavior through javascript
abstract: The present invention provides a system and method for real-time communication signaling between HTML5 endpoints and between HTML5 endpoints and the IMS Core of a telecommunication network. In an embodiment the system includes a WebRTC Session Controller (WSC) communicating over an Internet domain protocol with a client-side controller. The client-side controller provides an extensible JavaScript API. The extensible JavaScript API encapsulates the signaling aspect of a communication session of the HTML5 application, including gathering media description, establishing signaling channels, and exchanging media descriptions with the WSC, populating the relevant WebRTC objects, managing the call after it has been established. The extensible JavaScript API which provides for extending the JavaScript API to facilitate development of new types of HTML5 applications without changing the code of the existing JavaScript API.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09307031&OS=09307031&RS=09307031
owner: ORACLE INTERNATIONAL CORPORATION
number: 09307031
owner_city: Redwood Shores
owner_country: US
publication_date: 20131031
---
This patent application is a continuation in part continuation of U.S. patent application Ser. No. 13 758 768 entitled Real Time Communication Signaling Gateway filed Feb. 4 2013 Inventors Honggang frank Zhu Boris Selitser and Karthic Loganathan which application is incorporated herein by reference in its entirety.

A portion of the disclosure of this patent document contains material which is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure as it appears in the Patent and Trademark Office patent file or records but otherwise reserves all copyright rights whatsoever.

This patent application is related to the following patent applications which are hereby incorporated by reference in their entirety 

The present invention relates to a system and method for real time communication signaling in a telecommunications network and more particularly to a method of enhancing an existing JavaScript API to develop new types of HTML5 applications by customizing the protocol behavior using JavaScript.

With the explosive proliferation of IP enabled mobile and fixed devices capable of offering Web telecom and entertainment services such as 3G 4G enabled smart phones TVs home appliances gaming consoles and automobiles among others operators of mobile broadband and fixed networks are faced with the operational and business challenges of delivering innovative IP based communication services with maximum profitability. In order to achieve this goal customers are increasingly migrating away from expensive closed proprietary and application specific legacy platforms and towards low cost open standards based unified converged application platforms which dramatically lower the time and cost of adding new features and extensions to existing IP based communication services.

Session Initiation Protocol SIP is a control signaling protocol developed to manage interactive multimedia IP sessions including IP telephony presence and instant messaging. SIP is widely used in telecommunication networks. SIP and other communications centric protocols are complex and their implementation requires significant domain expertise. However SIP is not readily compatible with HTTP and use in the Internet domain.

The IP Multimedia Subsystem IMS is an architecture for an integrated network of telecommunications carriers that would facilitate the use of IP Internet Protocol for packet communications in all known forms over wireless or landline. Examples of such packet communications include traditional telephony fax e mail Voice over IP VoIP instant messaging IM videoconference sessions and video on demand VoD . IMS uses a Voice over IP VoIP and runs over the standard Internet Protocol IP . IMS gives network operators and service providers the ability to control and charge for each service. IMS architecture has the capability to support existing phone systems both packet switched and circuit switched . Thus IMS provides the interoperability security session management and QoS capabilities that telecommunications providers lack and desire. IMS is the de facto standard for next generation networks.

HyperText Markup Language HTML is the main markup language for creating Web pages and other information that can be displayed in a Web browser. HTML is written in the form of HTML elements consisting of tags. HTML elements form the building blocks of all websites. HTML allows images and objects to be embedded and can be used to create interactive forms. It provides a means to create structured documents by denoting structural semantics for text such as headings paragraphs lists links quotes and other items. It can embed scripts written in languages such as JavaScript which affect the behavior of HTML web pages. The purpose of a web browser is to read HTML documents and compose them into visible or audible web pages. The HTML environment has a well known behavior according to standards established by the World Wide Web Consortium W3C which is the main international standards organization for the World Wide Web abbreviated WWW or W3 .

HTML5 introduced WebRTC application programming interfaces APIs that make it possible for applications that use JavaScript in an HTML5 environment to take part in real time communications. To make use of this capability applications that reside in the browser environment of one user need to exchange messages with another application to establish media connections. However the signaling process of exchanging and negotiating session information is not specified by W3C and is left to the application to implement. After obtaining the local media streams the applications therefore need to use their own logic to exchange the session description protocol SDP information between two HTML5 enabled environments. Once the SDP information is exchanged the applications then use their own logic to pass each other media descriptions to the respective PeerConnection objects so that the media channel can be established. For non media communication that does not need to use media channels the application also requires custom logic. Accordingly when using the available WebRTC APIs application developers are required to write significant boilerplate logic to establish and implement real time communication. The problem is more complicated if it is desired to make a connection with a non browser media endpoint like a traditional telephony equipment.

It would be desirable to access the network services available in the IP Multimedia Subsystem IMS from the HTML environment and in particular the HTML environments capable of real time communication for example HTML5. However extending IMS architecture to the HTML environment is difficult owing to incompatibility of SIP with HTTP over TCP IP and the requirement for domain expertise to overcome such incompatibility. There is presently no simple way to extend the network services of the IP Multimedia Subsystem IMS to HTML5 applications without radical changes to the IMS model and custom extensions to the HTML platform to permit a browser to be used as an endpoint for IMS services. Thus despite the desire to extend the enhanced capabilities that IMS provides to the HTML environment such integration has not been readily feasible.

It would therefore be desirable to provide a system and method for extending IMS architecture to the HTML environment which is effective and simple to implement.

It would further be desirable to provide a system and method for extending IMS architecture to the HTML environment without radical changes to the IMS model or custom extensions to the HTML platform.

It would further be desirable to provide a system and method for extending IMS architecture to the HTML environment which can be implemented without domain expertise.

It would further be desirable to provide extensible functionality to simplify implementation of the real time communication in Web applications.

The present invention provides a system and method for extending IMS architecture to the HTML environment which overcomes the limitations of the state of the art.

The present invention provides a system and method for extending IMS architecture to the HTML environment which is effective and simple to implement.

The present invention provides a system and method for extending IMS architecture to the HTML environment without radical changes to the IMS model or custom extensions to the HTML platform.

The present invention provides a system and method for extending IMS architecture to the HTML environment which can be implemented without domain expertise.

The present invention provides extensible functionality to simplify implementation of real time communication is Web applications by providing an extensible JavaScript Application Programming Interface API .

In an embodiment the system and method of the present invention provide a communication channel between an HTML capable application or operating system and the IMS core of a telecommunications network. The system and method overcome the need for domain expertise of complex SIP and other communications centric protocols. The system and method provide a mechanism to combine complex signaling in the IMS telecommunications network into simple operations towards the Web. The present invention thereby provides a platform which enables telecommunications providers to provide a better end to end customer experience accessible from a wide variety of HTML capable consumer devices.

In an embodiment the system and method of the present invention comprise a client side controller a WebRTC Session Controller e.g. Oracle Communications WebRTC Session Controller and a communications protocol for communicating between the client side controller and the WebRTC Session Controller WSC . The client side controller provides client side native operating system application programming interfaces API and an extensible JavaScript API to interface with the HTML capable application or operating system and encapsulate the HTTP signaling layer. The WSC terminates the communications with the client side and parses and normalizes the communications into an internal protocol suitable for communication with IMS within legacy telecommunications network systems for example XMPP SIP and the like . The communications protocol provides a communication channel which is compatible with transmission over the Internet domain. The system and method thereby provides a dedicated signaling channel for all the applications on the client to interact with the IMS of telecommunications network services.

The JavaScript API for WebRTC signaling enables HTML5 applications to exchange signaling messages with a WebRTC Session Controller. These messages include attributes specific to the client application where the client application could be a Call a MessageAlert or a Conferencing etc. The JavaScript API provides methods to handle various client application requirements like making a call or subscribing to message alerts etc. Typically an API provides methods specific to the client applications that the customers are expected to deploy. The problem with exposing application specific API is that if the customer wants to add a new kind of application then the API needs to be enhanced to support this new application.

However embodiments of the present invention provide an extensible JavaScript API for WebRTC signaling which provides for extending a JavaScript API for developing new types of HTML5 applications without changing the code of the existing JavaScript API. In an embodiment of the invention the JavaScript API can establish a session layer with a signaling server between the HTML5 application and a signaling server and the HTML5 application can register itself with the session layer as a handler for application specific messages from the signaling server.

In an embodiment of the present invention the JavaScript API provides a mechanism that allows the HTML5 application to add customized information to the extension headers of signaling messages as defined by as defined by a proprietary JSON based protocol. Both the signaling server and the HTML5 applications contain logic to process the customized information and act accordingly. In an embodiment of the invention the existing JavaScript API can also be extended by creating a customized JSON RTC protocol message to customize behaviors of HTML5 applications. In an embodiment of the invention new JavaScript objects can also be created and registered with a session layer and start to send and receive messages to the WSC.

Other objects and advantages of the present invention will become apparent to those skilled in the art from the following detailed description of the various embodiments when read in light of the accompanying drawings.

In the following description the invention will be illustrated by way of example and not by way of limitation in the figures of the accompanying drawings. References to various embodiments in this disclosure are not necessarily to the same embodiment and such references mean at least one. While specific implementations are discussed it is understood that this is provided for illustrative purposes only. A person skilled in the relevant art will recognize that other components and configurations may be used without departing from the scope and spirit of the invention.

Furthermore in certain instances numerous specific details will be set forth to provide a thorough description of the invention. However it will be apparent to those skilled in the art that the invention may be practiced without these specific details. In other instances well known features have not been described in as much detail so as not to obscure the invention.

Common reference numerals are used to indicate like elements throughout the drawings and detailed description therefore reference numerals used in a figure may or may not be referenced in the detailed description specific to such figure if the element is described elsewhere. The first digit in a three digit reference numeral indicates the series of figures in which the element first appears.

JavaScript API enables an HTML5 application to create a Session object as a browser side representation of the communication. From the Session object the HTML5 application can create different communication objects like Call Subscription etc and listen on the callbacks of the objects to receive incoming calls notifications media of the calls and state changes etc. The JavaScript API can encapsulate the signaling aspect of a communication session between HTML5 applications including gathering media description establishing signaling channels and exchanging media descriptions with the WSC populating the relevant WebRTC objects managing the call after it has been established. The JavaScript API also includes objects that can establish data channels for non media data transfer and transfer the non media data. The JavaScript API can also handle reliability issues such as reliable message delivery and session resynchronization on a failure as well as browser incompatibility. Thus with the JavaScript API the development of an HTML5 application can be reduced to implementation of the business logic without writing boilerplate code thereby simplifying development and implementation of real time communication in Web applications .

The JavaScript API and protocol provide extensibility mechanisms that allow the HTML5 application to add customized information to the extension headers of signaling messages as defined by as defined by a proprietary JSON based protocol. Both the WSC and the HTML5 applications contain logic to process the customized information and act accordingly. In an embodiment of the invention the existing JavaScript API can also be extended by creating a customized JSONrtc protocol message to customize behaviors of HTML5 applications. In an embodiment of the invention new JavaScript objects can also be created and registered with a session layer and start to send and receive messages to the WSC.

The advantage of the extensible JavaScript API solution is that the JavaScript library supports the extensibility requirement that a customer typically needs. This means that the JavaScript library need not be updated or customized when there is a new kind of application comes in to play which results in increased productivity for service providers. This extensibility mechanism gives the power to the customers to add creative innovative applications that uses JSONrtc protocol with a short time to market and less cost of development. This provides a competitive advantage for service providers as alternative solutions may require application specific development and therefore and need more time to adapt to any new application types that the customer may come up with in the future.

In an embodiment of the invention the JavaScript API can support three levels of extension 1 Package extensibility 2 Object extensibility and 3 Message header extensibility. At the package level application developers can create new packages implementing new functionalities register the new packages with a JSON RTC session layer created using the session of the JavaScript API and start to send receive application specific messages. At the object level an existing object can be extended by using a programming design pattern. One example would be to create a new object by calling the constructor of the super class the object to be extended overwriting some methods inherited from the super class and adding some new methods to the extending object new object . At the header level the client application can add extension headers to the JSONrtc message using the JavaScript API which provides an extension message object that can be sent between the client application and the WSC. Transmitted messages then includes the extension header section where additional information can be added. These additional headers are used on the server side to make routing decisions or implementing new functionalities e.g. transferring a call or starting a chat session while the call is ongoing. Further details of JavaScript API and JSON protocol are shown in described below.

User equipment represents any HTML capable device including for example computing devices such as personal computers laptops desktops notebooks netbooks tablets mobile phones and e book readers. Moreover HTML capabilities are being added to consumer devices such as appliances automobiles set top boxes amplifiers audio visual components televisions projectors and the like. HTML capabilities may be provided by a browser for example Safari Firefox Chrome Browser and Internet Explorer. Alternatively HTML capabilities may be a core component of the operating system for example Chrome OS.

IMS Core IP Multimedia Subsystem or IP Multimedia Core Network Subsystem is an architectural framework for delivering IP multimedia services. As shown in IMS Core comprises S CSCF P CSCF gateway controller function MGCF HSS Application Server and Media Server . These elements are shown as an example of conventional IMS architecture. IMS Core may contain additional and or different elements depending upon the implementation of a particular network. The present invention is not limited to any particular implementation of IMS Core . Indeed it is a feature of the present invention that it extends whatever features are present in IMS Core to the Internet domain.

To ease the integration with the Internet IMS uses IETF protocols wherever possible e.g. Session Initiation Protocol SIP . IMS Core includes network elements designed to interact with SIP User Agents and PSTN . As used herein a user agent is an SIP endpoint that can be considered anything that either originates or terminates a SIP session e.g. SIP Phones Soft Phones and the like. Typically such devices must be specifically designed to implement SIP in order to function as SIP User Agents . In addition the IMS Core can exchange signaling and media messages with a public switched telephone network PSTN . IMS Core facilitates access to multimedia and voice applications from wireless and wireline terminals to create a form of fixed mobile convergence FMC . This is done by having a horizontal control layer that isolates the access network from the service layer. From a logical architecture perspective services need not have their own control functions as the control layer is a common horizontal layer.

Referring again to the IMS Core shown in P CSCF represents the proxy call session control function which is an entry point for a SIP user agent and authenticates users and establishes IP security integration with the SIP user agent . Media gateway controller function MGCF is the entry point for signaling and media messages transmitted via public switched telephone network PSTN . MGCF and P CSCF are used to process ingoing and outgoing SIP signaling packets in the IMS Core . On the network side MGCF and P CSCF interact with S CSCF using Session Initiation Protocol SIP .

S CSCF is the central node of the signaling plane. It is a SIP server but also performs session control. S CSCF is located in the home network. It uses Diameter Cx and Dx interfaces to the Home Subscriber Server HSS to download user profiles and upload user to S CSCF associations. All necessary subscriber profile information is loaded from the HSS . S CSCF inspects every message from the SIP user agent and or other network elements and decides where the SIP message should be forwarded for service provision. An Application Server AS hosts and executes services and interfaces with the S CSCF using SIP. Additionally a media server provides media related functions such as media manipulation e.g. voice stream mixing and interfaces with the S CSCF using SIP. S S CSCF may also allow for provisioning of services and or media services from an external server .

As described above the elements of IMS Core communicate with the central node of the signaling plane S CSCF using Session Initiation Protocol SIP alternative session oriented protocols may also be used including for example XMPP . However SIP is not easily compatible with conventional protocols for transmission over the Web . Integration of IMS Core is therefore difficult owing to incompatibility of protocols used in the two different environments and the requirement for domain expertise to overcome such incompatibility. The present invention provides a solution to such problems and therefore allows for extending the IMS Core to the Web .

WSC is an entry point for HTTP traffic from Web . WSC terminates Internet domain communications with the client side and parses and normalizes the Internet domain communications into an internal protocol suitable for communicating with elements of the IMS Core e.g. S CSCF within legacy telecommunications network systems for example XMPP SIP and the like . WSC communicates with client side controller using a protocol adapted to meet the real time signally requirements of SIP while remaining compatible with transmission over Web . The client side controller operating on User equipment provides client side native operating system application programming interfaces API and JavaScript API to interface with HTML capable applications operating systems and encapsulate the HTTP signaling layer. The system and method thereby provides a dedicated signaling channel for all the HTML capable applications OS on the User Equipment to interact with the IMS Core of the telecommunications network.

From an IMS network perspective WSC sits in the edge of IMS core and is architecturally parallel to a P CSCF. While P CSCF is the entry point many times along with a Session Border Controller for the SIP endpoints WSC serves as the entry point for HTML5 endpoints. Thus WSC has the ability to leverage applications in the IMS application server instead of hosting a separate custom business application on its own thus greatly simplifying integration with IMS Core . For example for a conference server the WSC would intelligently hand the requests to a backend IMS application server . The conference application would then route the requests to an appropriate media mixer and run the conference.

The session object acts as the browser side representation of the communication session. Session can also be used by the HTML5 application as a basis for creating other objects to support the establishment of a media call. From session the application can create different communication objects like call subscription etc. All these objects support an asynchronous programming model using callback functions. The HTML5 application can listen on the callbacks to receive incoming calls notifications media in the call and state changes etc. In addition the session object can encapsulate the connectivity to the WSC and hide the complexity about reconnect from the user developer. In an embodiment of the invention the HTML5 application can create only one session towards the WSC for each user identity and a plurality of sub sessions within the session.

The following example pseudo code illustrate the process of creating a call using the JavaScript API . Out the outset application utilizes Session to create a session object by specifying the identity of the user and the WebSocket URL. When the WebSocket session is established an appropriate callback function is invoked so that the call can be started.

After a session is created the HTML5 application can invoke AuthHandler to create an AuthHandler object registered to the session. AuthHandler can get authentication information from the HTML5 application return service authentication information or TURN server authentication information based on the parameter authType . The HTML5 application may need to provide authentication information when the WSC cannot meet an authentication challenge for a request from the HTML5 application . When the request is sent to the WSC the request can get an authentication challenge response e.g. unauthorized proxy authentication required . If the WSC by itself cannot provide authentication information to meet the challenge the WSC can forward the authentication challenge to the HTML5 application and call AuthHandler to get the authentication information from the HTML5 application.

On any incoming message from the WSC the session created using the Session object can determine the package handler for the message based on the package name contained in the message and delegate the message to the appropriate package handler for processing the message. A package handler is created from an object specific to the package type e.g. CallPackage DataTransferPackage and MessageAlertPackage . The package handlers can use the session to create a new subsession and use the subsession to exchange messages with the WSC . For example the CallPackage can create a new subsession for each new Call. All the messages that belong to a particular call use the same subsession ID. Session can store key values for each package and provide an API to get set these values. The packages can use this API to store fetch the necessary data from the session object.

The CallPackage object can encapsulate call associated operations and provide utility functions that be used for setting up the call. In addition the CallPackage object can be used to create the Call object as follows 

In an embodiment of the invention the Call object can be configured using the CallConfig object which can set the direction of the media call e.g. receive send or received and send.

A number of callback functions can be set by the HTML5 application on the Call object . For example some callback functions can be set on the Call object to notify the HTML5 application of the state changes to the call and the HTML5 can use the state changes to modify the Web user interface. For example the onCallStateChange callback function can be invoked whenever the state of the call is changed by the other party via signaling. This can include re starting the call disconnecting the call etc. The onCallStateChange callback takes a CallState object as a parameter. The onMediaStatechange callback function on the Call object can be used to notify the HTML5 application of changes to a media state e.g. change to the SDP information on either the local side or the remote side. The notification provides the HTML5 application with an opportunity to modify the SDP using the API provided by the Session object pro actively before applying the SDP to the browser .

A DataTransferPackage can enable data channel connection and manage the DataTransfer object to create a data channel and expose the data channel capability to the HTML5 application . The DataTransfer object can also be used to create a DataSender object and DataReceiver via calling getReceiver and getSender method respectively to transfer and receive raw data through the data channel set up by the DataTransfer object .

The JavaScript API also includes objects that manages subscriptions including creating new subscriptions managing existing active subscriptions and delivering the received messages to a corresponding subscription object to process them. In an embodiment of the invention the JavaScript API includes an OAuth object that handles Facebook authentication login process.

The JavaScript API can be downloaded to the client browser as part of a client software development kit SDK which can provide functionalities for the JavaScript API to handle reliability issues such as reliable message delivery and session resynchronization. In an embodiment of the invention the client SDK stores the client side session data to the local session storage of the browser . After a browser reloads if the HTML5 application has saved the session Id the client SDK can create a session using the saved session Id rehydrate the session using the data stored in the session storage and send a data re connect frame to the WSC server. If the re connect succeeds the client SDK can call the onRehydration method of each package to create related objects.

For example the SDK can call the onRehydration method of the CallPackage with call data from the session storage to create an instance of the Call object and then call the onRehydratedCall method of a call handler created from the CallPackage to notify the HTML5 application that the call has been rehydrated. The HTML5 application can call the resume method on the Call object instance to continue the call.

In accordance with an embodiment of this invention a mechanism is provided such that any new kind of application can be enabled without the requirement of changing the existing JavaScript API . In addition this mechanism also provides ways to customize or override the default message handling behavior of the JavaScript API . The JSONrtc session layer is designed and implemented such that any new kind of application can register itself against the session layer and start using the session layer to send and receive application specific messages. The session layer implementation is independent of any particular application. The protocol and API are designed and implemented such that a developer can add additional header information in the JSONrtc messages see . These additional headers are used in the server side to make routing decisions etc. Where extension headers are included the API allows an application to intercept messages from the server and handle any special cases if the message warrants the same. If not the message handling is delegated to the default package handling mechanism provided in the JavaScript API . The developer application can create customized JSONrtc protocol messages and send them to the WSC utilizing the established session. The customized message confirms to the standard message format but it can have application specific message attributes see .

As described above the JavaScript API can support three levels of extension 1 Package extensibility 2 Object extensibility and 3 Message header extensibility. At the package level application developers can create new packages implementing new functionalities register the new packages with a JSON RTC session layer created using the session of the JavaScript API and start to send receive application specific messages. The JavaScript API allows the developer to create new package handlers or to extend existing package handlers. The following example illustrates use of the JavaScript API to create a new package handler.

At the object level an existing object can be extended by using a programming design pattern. One example would be to create a new object by calling the constructor of the super class the object to be extended overwriting some methods inherited from the super class and adding some new methods to the extending object new object . The JavaScript API provides an Extend function wse.extend child parent that enables JavaScript object extension. The following example illustrates use of the Extend function of JavaScript API to extend an existing object.

At the header level the client application can add extension headers to the JSON RTC message using the JavaScript API which provides an extension message object that can be sent between the client application and the WSC. Transmitted messages then includes the extension header section where additional information can be added. These additional headers are used on the server side to make routing decisions or implementing new functionalities e.g. transferring a call or starting a chat session while the call is ongoing. The API make it is easy to add new a package handler or extend an existed package handler without affecting the existing package implementations.

The JavaScript API provides a way to permit the developer to add developer defined information into signaling messages as follows. First in order to add customer defined information into the signal message from HTML5 browser to WSC the developer needs to pass a JSON object extend information to the JavaScript API as the last parameter. For example the start API only defines one parameter as call.start localMediaStreams . If the developer invokes the API as following the start signal message will be added the extend information.

In response if the API handler receives a signal message containing some information beyond the protocol defined content e.g. the extendheader parameter the extended information will be packaged as a JSON object and passed to the API user s callback function as the last parameter. Thereby allowing use of the extended parameter by the developer.

The protocol and message format are friendly for conversion to other protocols used by non HTML5 environments thus enabling the WSC to mediate between an HTML5 application e.g. Browser and a non HTML5 endpoint e.g. traditional telephony equipment IMS Core . Thus the WSC can receive a JSON message in the protocol parse the SDP information and map it to other protocols SIP XMPP supported by the IMS Core of traditional telephony equipment. The WSC can maintain a data definition for the format to parse to.

As illustrated in a frame or message in the protocol can contain a headers section and a payload section . The headers section includes a control headers section and a general headers section . The message can include one or additional extension headers to implement new functionality shown in as extension headers .

The payload section is specific to the package being used. A package is the type of service or functionality that the message handles. The defined packages for this protocol are call presence and message notification. For example the payload for the call package will be an SDP offer or answer and the payload for the message notification package can be a JSON data with exact message alerts. Similarly a presence package would expect the payload to be the presence information.

The control headers section contains the information related to the semantics of the protocol e.g. information required for WebSocket re connect reliability timeouts error etc. It also contains the state of the message type of the message etc. In an embodiment of the invention the control headers section can include the following fields control type session Id sequence number acknowledge sequence message state a package type a subsession Id version and correlation id . The fields comprise attribute value pairs information related to the semantics of the protocol. TABLE I shows the control headers of the protocol.

The control type defines the types of the message which can be request response message acknowledgement or error. A request control type indicates that the message requires a response and a response control type indicates the message is a response to a request. In an embodiment of the invention the control types of request response and message can include a payload .

Requests responses and messages can carry a payload between the client and a server. An advantage of messages is that they do necessitate a response. The protocol has its own reliability model to ensure message delivery as explained below. Thus messages can be used to avoid request response overhead. This simplifies coding of the communication for the Web developer because the developer does not need to code the request response functionality but can instead rely on the reliability model to ensure message delivery.

In an embodiment of the invention a message state field specifies if a message is Initial Subsequent or Final. For example an answer can be an initial answer subsequent answer or a final answer. The state of Initial is implied for any message and the state for a subsequent or final message needs to be explicitly specified.

Package type indicates the type of service or functionality that the message handles e.g. call and presence. If no package type is specified a call package is assumed for all messages except messages with a CONNECT action.

The protocol provides for both a Session ID and a Subsession ID. Session ID identifies a WebSocket session that the client establishes with the server. The Session ID is unique across time and space. This helps Session ID to remain unique across geographically redundant clusters and also withstand node geography failures. A subsession ID can be used to identify a particular subsession within a WebSocket session. In an embodiment of the invention the Subsession ID is the sequence number of the message that establishes the subsession with a prefix c or s denoting the direction of the referenced message where c indicates that the referenced message is originated from the client and s indicates that the referenced message is originated from the server WSC .

The protocol provides for a unique sequence number for each message of a session WebSocket connection . The sequence number is a serial message number that starts with 1 at the beginning of the session and increments with each message. Each side of the WebSocket connection has their own series of sequence numbers. A sequence number uniquely identifies each message within a session. An acknowledge sequence number acknowledges receipt of all messages up to and including the specified sequence number within the session. This header can appear in both client and sever messages.

Correlation ID can be used to associate a message with a prior message. For example a correlation ID can associate a response message with the related request message. The sequence numbers provide a protocol reliability model. The correlation id is a number prefixed with c or s denoting the direction of the referenced message c indicating that the reference message originated from the client and s indicating that the reference message originated from the server.

The sequence number along with acknowledgement sequence numbers error messages and retransmission ensure that messages are reliably exchanged between HTML5 applications and the WSC or HTML5 endpoints . The acknowledgement messages and error messages are applicable to requests responses and messages. An acknowledgement message can be identified by the message acknowledgement control type in the control headers section. It is an acknowledgement that a message and all the messages with a lower sequence number have been successfully delivered. In an embodiment of the invention the protocol allows an HTML5 application to be configured to send an acknowledgement message for every message. If one side receives an acknowledgement message with a sequence number higher than that of a particular sent message and does not receive an error message for the particular message it can be assumed that the particular message has been successfully delivered. In an embodiment of the invention an error message indicates that a message with the specified sequence number has encountered an error.

The protocol utilizes a WebSocket connection and retransmissions of messages are not required except when the connections are broken and need to be re synched. The connection recovery can follow the semantics explained in the MBWS specification. The protocol also depends on the WebSocket ping pong to support keepalive and the failure of one side to receive the keepalive would result in timeout of the last request response message. In a scenario where the WebSocket ping pong is not supported by the browser the client side controller can initiate a custom ping pong with the WSC. When the browser client side controller determines that it is not receiving pong from the server any more it continues to send the ping messages for a stipulated period of time at intervals which double at each attempt.

The general headers section contains information related to the specific action involved in the message. For example for a START request the general headers section can identify who has initiated the request for whom the request is intended etc. In an embodiment of the invention the general headers include the following fields action an initiator a target error code and message notification header . Note that as previously described the protocol permits for the creation of one or additional extension headers to implement new functionality shown in as extension headers . The fields comprise attribute value pairs information related to the semantics of the protocol. An HTML5 application can also add additional headers to this section in the form of additional AVPs attribute value pairs . Such additional AVPs may be mapped by a gateway server e.g. WSC to a SIP header or a parameter. TABLE II shows the general headers of the protocol.

The action field indicates an action which the message is used for. For example the action CONNECT establishes a protocol level session with the server the action START indicates that the message is used for starting a session with a particular package. The optional initiator indicates the user e.g. alice example.com who initiated a request. In an embodiment of the invention while the client can set this value this value may come from the HTTP session. In certain cases such a value may not even exist. For example when a random user clicks on the web page to talk with a customer service representative. The optional target field can be used to indicate a remote peer. The optional error code field can be used to transmit an error code.

A client requests a connection reconnect by sending a Connect frame containing the session id of the connection to be reconnected followed by a list of three message sequence numbers. The first sequence number CSLR is that of the last message the client has received. The second CSLW and third CSUW sequence numbers define the respective lower and upper bounds of the sequence numbers of the messages in the client s retained message window. Upon receipt of this Connect frame the server determines if it can reconnect based on the following criteria The session id must match the client s current session id CSLR 1 must be the sequence number of a message the server can reinitiate sending with i.e. either the message with this sequence number is in the connection s retained message window or it is the sequence number of the next unsent message and the message sequence number of the message the server last received SSLR is in the range of CSLW 1 to CSUW. If all three criteria are met the reconnect succeeds and the server responds with a Connect frame containing the reconnected session id and one sequence number SSLR which is that of the last message received by the server. Message transport then resumes with the client sending the SSLR 1 message and the server sending the CSLR 1 message. If the criteria are not met the reconnect request fails and the server treats it as though it were a connect request and responds with a connect response. The client recognizes that its reconnect request has been converted into a connect request because the response contains a session id that does not match the session id in the client s reconnect request.

In an embodiment of the invention the general headers section can include more optional fields such as action specific fields and package specific fields. An example of an action specific field can be a field used when a CONNECT message is sent with an existing session ID to re establish the session. The value of this field can be the sequence number of the last received message at the client. An example of the package specific headers can be a header that represents expiry time of the subscription for message summary notifications.

The WSC can provide the ability to extend the protocol by adding depth and applicability to a set of existing methods. New headers e.g. security header and capabilities header can be added to the control headers section and the general headers section of a message. New control types and message types can also be added e.g. UPDATE and the protocol extensions shall follow the semantics of the core protocol control and general headers .

In order to facilitate extensibility JSON templates can be provided to facilitate the protocol extension. For example JSON templates can allow a client to program towards abstract data and service models rather than directly to JSON specified structure definitions. In an embodiment of the invention templates can be provided for message types CONNECT START NOTIFY and create a new message type by providing a message name and the required header parameters in the templates. The template can create a new message type based on the parameters passed. The templates may be provided for example by the WSC.

At Step a session can be created between the client and a WSC . The CallExtensionPackage can be registered as handler with the session create a subsession for a call and create a second subsession for sending INFO messages as part of the ongoing call. At Step subsessions can be created between the client and WSC for the Call Messages and INFO messages within the session. At step messages are received that are associated with CallExtensionPackage. At step the Session function will detect any messages related to the CallExtensionPackage and delegate the messages to the CallExtensionPackage hander which further invoke the CallExtension to process the messages. If the messages are INFO messages process them using the CallExtension object if they are Call messages delegate the handling to the base class the Call object .

Further details of one possible implementation of the system and method of the present invention are described below with respect to in which Client side controller is implemented as RTC Client Signaling Controller and protocol is implemented in JavaScript Object Notation JSON .

RTC Controller provides scalable signaling over HTTP Web centric protocols for communicating over Web with RTC Client Signaling Controller . RTC Controller communicates with RTC Client Signaling Controller via WebSocket interface . RTC Controller provides a highly available encapsulated front end interface to the Web developer. The RTC Controller terminates the Internet domain communications with the client side by managing the WebSocket connections. The RTC Controller also parses and processes the Internet domain communications. The RTC Controller normalizes the Internet domain communications into an internal SIP for communication within Gateway . Thus RTC Controller communicates internally with Service Composition Controller using a binary SIP.

Service Composition Controller provides for service composition and orchestration across domains and different providers. The Service Composition Controller also provides a unified layer to inject charging and policy control for differentiated service offerings. In an embodiment the functionality of Service Composition Controller can be integrated into a converged application server for example Oracle Communications Converged Application Server OCCAS . Alternatively the functionality of Service Composition Controller can be integrated into a service controller for example Oracle Communications Service Controller OCSC .

Service Composition Controller adopts and reuses existing internal communication services with support for different signaling protocols. Thus for example Service Composition Controller can mediate Internal Services providing network telephony signaling using the SS7 protocol and Internal Services providing services using internet protocol .

Service Composition Controller can also mediate the provision of external services provided by an external service provider . Communication with external provider can be conducted using a selected signaling protocol SIP XMPP etc as required by the external provider . Services provided by external provider can include web services provided over Web to a browser client on user equipment . Service Composition Controller thus enables external providers of over the top OTT services to provide OTT services to users clients. The gateway system enables the external providers to make use of the real time communication signaling over IMS. The users clients can then access web applications provided by external providers from a browser on the user equipment.

The gateway system acts as the IMS proxy for both HTML5 and external providers by taking advantage of WebSocket technology to enable and expedite the IMS deployment. The WebSocket Protocol defines a mechanism for fast secure two way communication between a client and a server over the Web. Data is transferred over a full duplex single socket connection allowing messages to be sent and received from both endpoints in real time. To establish a WebSocket connection a specific HTTP based handshake is exchanged between the client and the server. If successful the application layer protocol is upgraded from HTTP to WebSocket using the previously established TCP transport layer connection. After the handshake HTTP is no longer used and data can be sent or received using the WebSocket protocol by both endpoints until the WebSocket connection is closed.

RTC Client Signaling Controller is resident on user equipment and manages multiplexing of signaling request response for all client side applications mediating communication with RTC Controller over HTTP web centric protocols. The particular HTTP protocol used can be defined as required by the particular native or external service for example JSON XML XMPP Skype protocol etc. A client side library of available protocols is provided as part of an SDK in order to extend the services to the client. Ina preferred embodiment a JSONrtc protocol is utilized and RTC Client Signaling Controller includes a JavaScript API which encapsulates the signaling layer to facilitate implementation by applications running in web applications running on User Equipment .

For telephony applications low power consumption by user equipment is desirable. Accordingly RTC Client Signaling Controller can be placed in standby operation when not involved in signaling. Moreover WebSocket protocol must be initiated from the client side and is also responsible for keeping the connection alive. Thus the RTC Client Signaling Controller will shut down the WebSocket Connection when there is no traffic. In an embodiment of the invention RTC Push Notification Controller can be used by RTC Controller to wake up RTC Client Signaling Controller from the standby state in order to resume communication. The RTC Push Notification Controller may in some embodiments also be used for other notifications such as call notifications message notifications and the like. In an alternative embodiment the keepalive and pingpong capabilities of the WebSocket protocol may be used to maintain WebSocket connection without requiring a separate RTC Push Notification Controller .

In an embodiment of the invention RTC Push Notification Controller includes a server side HTTP connection based Push Notification to wake up the client side signaling process. RTC Client Signaling Controller can utilize any push notification mechanism and protocol effective for user equipment . For example RTC Push Notification Controller can utilize the SMS message system to activate RTC Client Signaling Controller thereby causing RTC Client Signaling Controller to reactivate the WebSocket connection with the RTC Controller .

WSC including a WSC runtime module supports multiple signaling protocols and ensures correct mapping of the signaling message using parameter transformation module and correct routing of the messages based on routing profiles using routing manager . Parameter transformation routing and JSON templating are all configurable using a configuration file .

WSC performs protocol mapping between the selected client side protocol and the network side protocol SIP . For example WSC is adapted to receive a JSON message parse the SDP information and map it to other supported protocols SIP XMPP . WSC maintains a data definition for the format to parse to. When the JSON request is received at WSC the transformation between the data definition and the JSON message structure must be implemented.

WSC acts as a cross protocol signaling engine. WSC handles the protocol associated state as demanded by the protocol. When WSC is acting as a cross protocol gateway for example JSON WebSocket to SIP the SIP side of WSC maintains the transaction and dialog state. WSC includes a protocol state management module which manages the protocol state and ensures state replication for reliability of message exchange. WSC has the ability to manage enormous amounts of concurrent client connections in order to be able to scale to the applications and users on the Web.

For developers the key is to leverage existing knowledge and skill sets to minimize additional time and resources required by security features implementation. WSC comes with APIs that support multiple platforms running under multiple protocols and a set of client libraries to facilitate smooth development process. WSC thus additionally provides an extensibility framework to extend the capabilities via protocol adaptors and APIs for the Web developers to call the WSC functions from their applications.

WSC provides signaling adaption such that WSC handles all the signaling between the browser client and the network end point SIP Proxy PSTN Gateway for example . WSC is adapted to handle the message exchange using several protocols over WebSocket RFC 6455 including for example JSON based protocol via JSON Stack XMPP sub protocol via XMPP Stack SIP sub via SIP Stack BOSH XEP 0124 and COMET Bayeux protocol not shown . On the network carrier side the WSC supports translation into a suitable communication protocol or protocols e.g. XMPP SIP and the like . Thus for example on the network carrier side WSC supports SIP RFC 3261 .

Security for real time communication over the Web requires that the communicating endpoints be able to authenticate each other. While these end points are making calls through the signaling services their identities are authenticated via an Identity Provider Management Module IDP that supports OAuth Facebook Connect FBC and other Identity Protocols using extensions e.g. OpenID connect . IDP Management modules interact with internal and or external user database and identity servers .

WSC thereby acts as an identity service that can attest the identity of the caller of the received request and map it to the from identity of the outbound call. For example WSC includes OAUTH module which introduces security functions that authenticate and authorize the browser based applications to interact with the network services. WSC thereby provides service providers with the ability to control any third party partner s access and usage of its network capabilities.

Establishing real time communication over the Web also utilizes verification of service level agreements SLA for the user and application. SLA Management module includes an authentication module as well as an application SLA module and network SLA module which communicate with internal and or external databases to verify that the communications are provided in conformance with the relevant service level agreements for the user and application.

In a particular embodiment WSC defines a JavaScript Object Notation JSON protocol that is used for exchanging information and to control the set up of media between a browser client and WSC . JSON is a lightweight data interchange format however other data interchange formats may be used in alternative embodiments. The JSON protocol can be used on multiple transports COMET BOSH and WebSocket . When used on WebSocket transport the protocol is defined as a sub protocol of the WebSocket protocol.

The JSON protocol or alternative data interchange format defines the basic structure for the information transfer between the browser client and WSC . The JSON protocol defines the minimum set of messages and state machinery necessary to implement the offer answer model. The JSON protocol defines the message structure that accounts for the reliability reconnect retransmissions timeouts etc of the message. The JSON protocol also handles the necessary headers to function in multilevel secure environment security headers .

WSC also provides an internal routing manager for the routing of the requests to the appropriate end nodes based on variety of parameters. There are multiple WSC instances see and each instance is connected to the network node serving the functionality. The incoming requests JSON messages for example have to be routed to the right application and instance. WSC uses routing manger to route incoming requests based on their origination and destination. WSC provides functionality including performing look ups and route requests for JSON to SIP JSON to XMPP SIP to XMPP XMPP to SIP. Each route in the WSC routing manager has a routing profile. WSC provides a default routing profile and additional routing profiles are configurable as needed or desired.

WSC ensures reconnection of clients due to failover or loss of connectivity. Clients and servers use an implicit sequence numbering protocol for the message transported by the connection. Clients and the servers each maintain their own sequence number. Both client and server acknowledge their receipt of messages by sending acknowledgement ack messages. As per the protocol an ack message indicates that the message has reached the destination as well as all the messages lower than that sequence . Similarly an error message shall be defined as in the JSON protocol section to indicate that the message with a sequence number has met with an error. Retransmission Queue A B allows for retransmission of messages for which there is an error or lack of acknowledgement.

One way in which WSC maintains reliability is to keep the relevant conversation state redundant across different servers A B having instances of WSC . WSC provides for state maintenance and session state mapping across protocols. The relevant conversation state includes a Web Side State Machine and SIP Side State Machine for each In Flight Transaction . WSC maintains the session states both client and server side state in the cache. In order to ensure reliability the cached copy of the state machines is duplicated on several servers. Additionally retransmission queue A B is duplicated across servers A B. WSC uses coherence for state storage and management. If a server for example server A cannot be contacted due to a network failure WSC ensures that the state is retrieved from another active server B as shown by the dashed arrows .

In an embodiment application is a JavaScript Application. Application operates at a high level without having to deal with peer connection directly. The browser client is stateless and contains as little of the implementation of the transport establishment code as possible. Browser client identifies the capabilities of the browser client and user equipment for streaming media. The capabilities are provided to the SDP adapter of the application . SDP adapter provides a description of streaming media initialization parameters a session profile suitable for streaming media to the browser client running on user equipment .

A client side library of available protocols is provided as part of a Client SDK in order to extend the services to the browser client . The particular HTTP protocol used can be defined as required by the particular native or external service for example JSON XML XMPP Skype protocol etc. In a preferred embodiment a JSON protocol is used for communication between client side RTC signaling controller and WSC as described above.

Protocol serialization interacts with protocol state view and connection manger to communicate with WSC over Web . Session Control establishes reliable connection with WSC . This session can be used by the application to create or invoke other objects.

RTC signaling controller comprises a JavaScript SDK which provides the functions necessary for application to manage server connections connection establishment teardown via WebSocket . The JavaScript SDK provides functions necessary to handle the state machine and functions to deal with interoperability issues. For example the JavaScript SDK of application provides functions to create messages or insert messages into the state machine. The JavaScript SDK also provides functions for the client to monitor connection health including the ability to reconnect in case of stale connections and the ability to synchronize state from the server and add modified state back to the server.

JavaScript SDK also provides a JavaScript API which can modify and optimize media parameters session description protocol SDP etc. The JavaScript API abstracts out complex functionality and provides an application programming interface to deal with the real time communication session Call etc. The JavaScript API provides the ability to handle call states media states subscriptions and notifications.

In operation HTML5 applications access the JavaScript API to get access to various communication objects defined in the JavaScript API and described above. An HTML5 application will create a session object . The session object acts as browser side representation of the communication. From session object application can create different communication objects like Call Subscription etc. The HTML5 application can listen on the callbacks from the objects to receive incoming calls notifications media in the call state changes etc.

The Interactive Connectivity Establishment ICE draft developed by the IETF s MMUSIC working group provides a framework to unify the various NAT traversal techniques. ICE defines a standardized method for clients to determine what type of firewall s exist between clients and determine a set of IP addresses by which clients can establish contact. When an ICE enabled client the initiator wishes to communicate with another device the responder it first collects information on addresses where the client can receive IP traffic. A key benefit that ICE provides is the ability to unify the information provided by these various sources of IP address information to create as many paths as possible by which the endpoints can be reached.

For real time communication over the Web the ICE state machine is maintained by the browser client . When the browser client reloads the application has no knowledge of the ICE Candidates and is forced to perform ICE restart. In order to avoid this application can save this information in WSC . When the initial ICE negotiation finishes the browser client sends the nominated ICE candidate pair of IP addresses to the application which saves this information in WSC . When the browser client reloads the application will fetch the nominated ICE candidate information from the server and then send it to the browser client . This will tell the browser client to use these candidates for media transfer. Since the browser client has kept the local nominated ICE candidate alive all the time as long as the remote side has not released the call the transfer will succeed.

Although the invention has been described above with respect to communication services in a telecommunications network the invention also finds application in any situation where it is necessary or desirable to provide real time communication signaling.

The present invention may be conveniently implemented using one or more conventional general purpose or specialized digital computer computing device machine or microprocessor and or network of same programmed according to the teachings of the present disclosure.

Appropriate software coding can readily be prepared by skilled programmers based on the teachings of the present disclosure as will be apparent to those skilled in the software art. The invention may also be implemented by the preparation of application specific integrated circuits or by interconnecting an appropriate network of conventional component circuits as will be readily apparent to those skilled in the art.

The various embodiments include a computer program product which is a storage medium media having instructions stored thereon in which can be used to program a general purpose or specialized computing processor s device s to perform any of the features presented herein. The storage medium can include but is not limited to one or more of the following any type of physical media including floppy disks optical discs DVDs CD ROMs microdrives magneto optical disks holographic storage ROMs RAMs PRAMS EPROMs EEPROMs DRAMs VRAMs flash memory devices magnetic or optical cards nanosystems including molecular memory ICs paper or paper based media and any type of media or device suitable for storing instructions and or information. The computer program product can be transmitted in whole or in parts and over one or more public and or private networks wherein the transmission includes instructions which can be used by one or more processors to perform any of the features presented herein. The transmission may include a plurality of separate transmissions. In accordance with certain embodiments however the computer storage medium containing the instructions is non transitory i.e. not in the process of being transmitted but rather is persisted on a physical device.

The foregoing description of the preferred embodiments of the present invention has been provided for purposes of illustration and description. It is not intended to be exhaustive or to limit the invention to the precise forms disclosed. Many modifications and variations can be apparent to the practitioner skilled in the art. Embodiments were chosen and described in order to best explain the principles of the invention and its practical application thereby enabling others skilled in the relevant art to understand the invention. It is intended that the scope of the invention be defined by the following claims and their equivalents.

