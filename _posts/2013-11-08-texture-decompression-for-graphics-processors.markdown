---

title: Texture decompression for graphics processors
abstract: Various apparatuses and methods are disclosed for processing texture data compressed with a first compression algorithm and texture data compressed with a second compression algorithm. A processing system may be used to determine whether the compressed texture data is compressed with the first or second compression algorithm, and process the compressed texture data using a decompression algorithm corresponding to the compression algorithm used to compress the texture date.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09159114&OS=09159114&RS=09159114
owner: QUALCOMM Incorporated
number: 09159114
owner_city: San Diego
owner_country: US
publication_date: 20131108
---
The present disclosure relates generally to graphics processors and more particularly to texture decompression for graphics processors.

Graphics processors are commonly used to generate three dimensional 3D graphic images for a variety of multimedia devices. These processors often include dedicated circuitry configured to process graphics data stored in memory to create 3D images in a frame buffer for presentation to a display. The 3D images created by the graphics processor generally comprise a geometric object or polygon with a texture applied to the surface. The graphics processor may also perform other functions such as translation and rotation of vertices into different coordinate systems and shading to produce the appropriate levels of light and colors within an image.

Today there is an ever increasing demand for more textures with higher resolution to improve the aesthetics of graphic imagery. This demand has grown in step with advancements in processor technology. However memory technology has grown at a slower rate. As a result graphic designers are constantly challenged to provide enough memory bandwidth to exploit the full processing capabilities of modern processors.

Texture compression techniques are widely used by graphics processors to meet these challenges. Texture compression involves the storing texture data in a compressed format in memory. Decompression of the texture data is done by a processor before the texture is applied to the surface of an object. Today there are various compression formats that are supported by graphics processors for texture compression. Block compression is one such technique. There are seven standard block compression algorithms for 3D graphics which are referred to as BC1 through BC7. Currently different hardware configurations are required to support different compression algorithms. Accordingly there is a need in the art for a single hardware solution capable of decompressing texture compressed with different algorithms.

Aspects of an apparatus for processing texture data compressed with a first compression algorithm and texture data compressed with a second compression algorithm different from the first compression algorithm are disclosed. The apparatus includes a processing system configured to determine whether the compressed texture data is compressed with the first or second compression algorithm and process the compressed texture data using a decompression algorithm corresponding to the compression algorithm used to compress the texture date.

Aspects of an apparatus for processing texture data compressed with a first compression algorithm and texture data compressed with a second compression algorithm different from the first compression algorithm are disclosed. The apparatus includes means for determining whether the compressed texture data is compressed with the first or second compression algorithm and means for processing the compressed texture data using a decompression algorithm corresponding to the compression algorithm used to compress the texture date.

Aspects of a method for processing texture data compressed with a first compression algorithm or second compression algorithm different from the first compression algorithm are disclosed. The method comprises determining whether the compressed texture data is compressed with the first or second compression algorithm and processing the compressed texture data using a decompression algorithm corresponding to the compression algorithm used to compress the texture date.

It is understood that other aspects of apparatus and methods will become readily apparent to those skilled in the art from the following detailed description wherein various aspects of apparatuses methods and articles of manufacture are shown and described by way of illustration. As will be realized these aspects may be implemented in other and different forms and its several details are capable of modification in various other respects. Accordingly the drawings and detailed description are to be regarded as illustrative in nature and not as restrictive.

In accordance with common practice some of the drawings may be simplified for clarity. Thus well known structures and components may be shown in block diagram form or omitted entirely in order to avoid obscuring the various concepts presented throughout this disclosure.

Various aspects of the apparatuses and methods will be described more fully hereinafter with reference to the accompanying drawings. These apparatuses and methods may however be embodied in many different forms by those skilled in the art and should not be construed as limited to any specific apparatus or method presented herein. Rather these aspects are provided so that this disclosure will be thorough and complete and will fully convey the scope of the invention to those skilled in the art. Based on the teachings herein one skilled in the art should appreciate that the scope of the invention is intended to cover any aspect presented in this disclosure whether implemented independently of or combined with any other aspect presented in this disclosure. For example an apparatus may be implemented or a method may be practiced using any number of aspects set forth herein. In addition an apparatus or method may be implemented using other structure and or functionality in addition to or instead of other aspects presented in this disclosure. Accordingly the claims should not be limited to the various aspects of the apparatuses and methods presented throughout this disclosure but should be accorded the full scope consistent with the language of claims.

The term apparatus shall be construed to include any integrated circuit or system or any portion of an integrated circuit or system e.g. blocks modules components circuits elements or the like . By way of example the term apparatus may be used to refer to a graphics processor or any portion of a graphics processor e.g. a processing system for decompressing compressed texture data . The term apparatus shall also be construed to include any intermediate product where an integrated circuit or system is combined with other integrated circuits or systems e.g. a video card a motherboard etc. or any end product e.g. mobile phone personal digital assistant PDA desktop computer laptop computer palm sized computer tablet computer work station game console media player computer based simulators or the like . The term method shall similarly be construed to include the operation of any integrated circuit or system or any portion of an integrated circuit or system or any intermediate product or end product or any step process algorithm or the like or any combination thereof performed by such integrated circuit or system or portion thereof intermediate product or end product.

The word exemplary is used herein to mean serving as an example instance or illustration. Any embodiment described herein as exemplary is not necessarily to be construed as preferred or advantageous over other embodiments. Likewise the term embodiment of an apparatus or method does not require that all embodiments of the invention include the described components structure features functionality processes advantages benefits or modes of operation.

The terms connected coupled or any variant thereof mean any connection or coupling either direct or indirect between two or more elements and can encompass the presence of one or more intermediate elements between two elements that are connected or coupled together. The coupling or connection between the elements can be physical logical or a combination thereof. As used herein two elements can be considered to be connected or coupled together by the use of one or more wires cables and or printed electrical connections as well as by the use of electromagnetic energy such as electromagnetic energy having wavelengths in the radio frequency region the microwave region and the optical both visible and invisible region as several non limiting and non exhaustive examples.

Any reference to an element herein using a designation such as first second and so forth does not generally limit the quantity or order of those elements. Rather these designations are used herein as a convenient method of distinguishing between two or more elements or instances of an element. Thus a reference to first and second elements does not mean that only two elements can be employed or that the first element must precede the second element. Also unless stated otherwise a set of elements can comprise one or more elements. In addition terminology of the form at least one of A B or C used in the description or the claims means A or B or C or any combination of these elements. 

As used herein the singular forms a an and the are intended to include the plural forms as well unless the context clearly indicates otherwise. It will be further understood that the terms comprises comprising includes and or including when used herein specify the presence of the stated features integers steps operations elements and or components but do not preclude the presence or addition of one or more other features integers steps operations elements components and or groups thereof.

Various aspects of graphics processing presented throughout this disclosure may be implemented in various forms of hardware. By way of example such aspects may be implemented either alone or in combination as an integrated circuit or as part of an integrated circuit. The integrated circuit may be a graphics processing unit GPU a microprocessor a digital signal processor DSP an application specific integrated circuit ASIC or any other suitable integrated circuit. The integrated circuit may be integrated with other chips discrete circuit elements and or other components as part of either an intermediate product e.g. a video card motherboard etc. or an end product. The end product can be any suitable product that performs graphics processing including by way of example mobile phones personal digital assistants PDAs desktop computers laptop computers palm sized computers tablet computers work stations game consoles media players computer based simulators and the like.

Several aspects of graphics processing will be presented in the context of an embedded system within a larger apparatus. However as those skilled in the art will readily appreciate such aspects of graphics processing may be embedded in other apparatuses not presented in this disclosure or may be implemented as a stand alone apparatus. According any reference to a specific apparatus with embedded graphics processing is intended only to illustrate exemplary applications of graphics processing with the understanding that various aspects of graphics processing presented throughout this disclosure have a wide range of applications.

The host system may include a central processing unit CPU not shown that executes software programs stored in system memory not shown to manage the general operation of the apparatus . The host system may include other modules or units that are likewise not shown to provide additional functionality. By way of example the host system may include a transceiver to allow wireless or wired communication with another apparatus or a remote network and a user interface to enable user control of the apparatus .

The host system may provide an interface between the GPU and various graphics software programs supported by the host system . The GPU may be configured to fetch program instructions from the host system and load those instructions into local memory for execution by the graphics processor . The GPU may be further configured to fetch data from the host system . The data may be processed by a graphics pipeline within the graphics processor or written to local memory . In some embodiments the host system may compress the texture data. Storing the texture data in a compressed format reduces the bandwidth required to retrieve the texture data from memory.

In a manner to be described in greater detail later the graphics processor may be used to perform various graphics processing functions that processes the data stored in local memory to create graphic images in a frame buffer . The frame buffer may then provide the rendered images to a display . Alternatively or in addition to the processed data from the graphics processor may be output to a recording device written to a peripheral device e.g. disk drive tape compact disk or the like or transmitted to a remote apparatus via the host system .

The graphics processor may be implemented with one or more processors. A processor as used throughout this disclosure shall be construed broadly to include general purpose and special purpose processors e.g. microprocessors microcontrollers DSP processors and other circuitry that can execute software or dedicated hardware e.g. FPGAs PLDs controllers state machines gated logic discrete hardware components etc. or any combination thereof.

Software shall be construed broadly to mean instructions data or any combination thereof whether referred to as software firmware middleware microcode hardware description language or otherwise. The software may be stored or transmitted over as one or more instructions or code on a machine readable medium. Machine readable media include both computer storage media and communication media including any medium that facilitates transfer of a computer program from one place to another. A storage medium may be any available medium that can be accessed by a processor. By way of example and not limitation such machine readable media can comprise RAM SRAM DRAM SDRAM ROM PROM EPROM EEPROM CD ROM or other optical disk storage magnetic disk storage or other magnetic storage devices or any other medium that can be used to carry or store desired program code in the form of instructions or data structures and that can be accessed by a processor. Also any connection is properly termed a machine readable medium. For example if the software is transmitted from a website server or other remote source using a coaxial cable fiber optic cable twisted pair digital subscriber line DSL or wireless technologies such as infrared IR radio and microwave then the coaxial cable fiber optic cable twisted pair DSL or wireless technologies such as infrared radio and microwave are included in the definition of medium. Disk and disc as used herein include compact disc CD laser disc optical disc digital versatile disc DVD floppy disk and Bluray disc where disks usually reproduce data magnetically while discs reproduce data optically with lasers. Thus in some aspects machine readable media may comprise non transitory machine readable media e.g. tangible media . In addition for other aspects machine readable media may comprise transitory machine readable media e.g. a signal . Combinations of the above should also be included within the scope of machine readable media.

In the described embodiment the GPU is shown as part of the apparatus separate from the host system . However as those skilled in the art will readily appreciate the GPU or any portion thereof may be external to the apparatus . Alternatively or in addition to the GPU or any portion thereof may be integrated into the host system . The local memory is shown as part of the GPU separate from the graphics processor . However as those skilled in the art will readily appreciate the local memory or any portion thereof may be external to the GPU . By way of example the local memory or any portion thereof may be integrated into the host system or located elsewhere in the apparatus or reside outside the apparatus or be distributed across various entities in and or outside the apparatus . Alternatively or in addition to the local memory or any portion thereof may be integrated into the graphics processor such as the case may be with cache and or general register files.

The graphics pipeline begins with primitive processing . Modern graphics processors operate with primitives which are geometric shapes e.g. points lines triangles polygons etc. that can be combined to render a three dimensional 3D image. Primitive processing is the process of producing vertices for the primitives making up the 3D object. The vertices may then be transformed from a 3D virtual space coordinate system to a two dimensional 2D display coordinate system by a vertex shading process. In some embodiments of a graphics pipeline the vertex shading process may also be used to manipulate other properties of the vertices including by way of example lighting color and texture coordinates. The vertices may then be assembled into individual primitives by a primitive assembly process. Next a geometry shading process may be performed by the graphics pipeline to change some of the geometries of the primitives. The primitives may then be converted to a raster image i.e. pixels by a rasterization process. A fragment shading process may be used to provide texture mapping perspective correction color lighting shadows shading and the like to the pixels. Various other raster operations may be performed by the graphics pipeline including by way of example depth blending and dither processing. The processed pixel images or rendered images may then be output from the graphics pipeline and stored in the frame buffer for presentation to the display see . Alternatively or in addition to the rendered images may be output to a recording device written to a peripheral device e.g. disk drive tape compact disk or the like or transmitted to a remote apparatus via the host system see .

As discussed above the fragment shading function may include the process of texture mapping to the surface of graphics objects. However this process or any portion thereof may be implemented elsewhere in the graphics pipeline or elsewhere in or external to the apparatus. Alternatively the texture mapping process or any portion thereof may be a stand alone circuit that is used by the graphics pipeline. Those skilled in the art will be best equipped to determine the most suitable implementation of the texture mapping process depending on the particular application and overall design constraints imposed on the overall system.

The texture data may be stored in local memory or elsewhere in a compressed format to provide sufficient memory bandwidth to take advantage of the full processing capabilities of the graphics processor see . Decompression of the texture data may be done inside the graphics pipeline before mapping to the surface of the object. As discussed earlier in the background portion of the disclosure there are various compression algorithms that are supported by graphics processors for texture compression. One family of compression algorithms that are commonly used are known as Block Compression BC algorithms. There are currently seven block compression algorithm that are commonly used today for graphics processing which are referred to as BC1 through BC7.

Block compression utilizes various compression algorithms that operate on blocks of texture elements. The size of the blocks are very small e.g. 4 4 blocks of elements to limit the color variation within each block. By limiting the color variation within a block the texture elements can be represented by a small color palette. The palette may be further compressed by assuming that all colors in the palette are evenly spaced along a line segment in RGB space. Each block can then be represented by the endpoints of that line segment with each texture element being assigned an index that may be used to interpolate between the two endpoints to reconstruct the color for that texture element.

BC6 and BC7 are two new compression algorithms introduced by Microsoft in its DirectX DX application programming interface API . These compression algorithms support a number of different modes. Each mode may have a different format in terms of palette size and endpoint precision. This makes these compression algorithms more adaptable to the content of the image. By way of example low precision endpoints with large color palettes may be more suitable for some blocks while higher precision endpoints with smaller color palettes may be more suitable for others.

The endpoints may also be compressed. By way of example BC6 uses a transform function where the endpoints are derived from a reference endpoint. BC7 on the other hand uses a compression technique known as a P bit operation where the P bit represents a shared least significant bit for the endpoints.

BC6 and BC7 may also utilize the concept of partitioning to allow multiple line segments to be used with each block. Each texture element within a block may be assigned a different line segment. The index for that texture element may then be used to interpolate between the endpoints for the assigned line segment to reproduce the color. This approach can improve image quality in cases where the colors within a block do not track well with a single line in RGB space.

Finally BC7 provides two distinct line segments for different channels one line segment for color i.e. RGB and another line segment for alpha. This approach is well equipped to deal with the different spatial distributions of the channels. In addition BC7 provides the ability to swap channels or rotate by allowing the alpha channel to be swapped with the red green or blue channel. This effectively allows any of the four channels to use a distinct line segment from the rest.

The decompression engine may use various processing modules to decompress compressed texture data stored in local memory see or elsewhere. These modules or any portions thereof may be implemented with the same processor used to implement the graphics pipeline. Alternatively these modules or any portions thereof may be implemented in a processor separate from the graphics pipeline. Those skilled in the art will be best suited to implement the described functionality based on the particular application and design constraints imposed on the overall apparatus.

The decompression engine is shown with a data extraction module and a processing module . The data extraction module provides a means for determining whether the compressed texture data is compressed with a first or second compression algorithm and the processing module provides a means for processing the compressed texture data using a decompression algorithm corresponding to the compression algorithm used to compress the texture date. The processing module may be implemented with several sub modules including an endpoint processing module an endpoint index selection module and a interpolation and post processing module . The endpoint processing module provides a means for obtaining one or more endpoint pairs from the compressed texture data. The endpoint index selection module provides a means for selecting one of the one or more endpoint pairs for each texture element and a means for selecting a corresponding index. The interpolation and post processing module provides a means for obtaining decompressed texture data for each texture element from the selected endpoint pair and the index.

The data extraction module may be configured to retrieve compressed texture data from local memory see or elsewhere in the form of block data. Each block of compressed texture data may include mode bits compressed endpoint pairs compressed indices and partition bits. Texture data compressed with a BC algorithm may also include a P bit and rotation bits in the case where separate color and alpha channels are provided.

The data extraction module may be configured to determine the compression algorithm was to compress the texture data by examining the format of the block or certain portions thereof. By way of example the format for each compression algorithm may have different modes and may have a different number of bits representing the compressed endpoints compressed indices and partition bits. The sequence of the bits representing the mode compressed endpoints compressed indices and partition bits may also be different. The presence of a P bit or rotation bits would indicate that the compressed texture data is compressed with a BC7 compression algorithm. The differences in modes and format may be used by the data extraction module to determine the compression algorithm used to compress the block of texture data retrieved from local memory or elsewhere.

Once the data extraction module determines the compression algorithm it can extract various types of texture data contained in the block e.g. compressed endpoint pairs compressed indices partition bits and to the extent provided a P bit and rotation bits . The texture data extracted from the block may be provided by the data extraction module to the processing module along with an indicator signal which indicates the compression algorithm used to compress the block of texture data.

As explained earlier the processing module may include an endpoint processing module . The compressed endpoint pairs along with the indicator signal may be provided to the endpoint processing module . The endpoint processing module may be used to demultiplex the compressed endpoint pairs between two different decompression paths depending on the state of the indicator bit. When the state of the indicator bit indicates texture data compressed with a BC6 compression algorithm the compressed endpoints may be provided to an inverse transform module for decompression. When the state of the indicator bit indicates texture data compressed with of a BC7 compression algorithm the compressed endpoint pairs may be provided to a P bit operation module along with the P bit for decompression.

The inverse transform module may be used to decompress the endpoint pairs that were stored using a BC6 compression algorithm. As discussed earlier in the disclosure BC6 uses a transform function where each end point pair is derived from a reference endpoint. The inverse transform module may use the reference endpoints to recover the endpoint pairs. Depending on the mode a sign extension operation may also be required.

The P bit operation module may be used to decompress the endpoint pairs that were stored using a BC7 compression algorithm. The P bit operation may be performed by appending a P bit to each of the compressed endpoint pairs to recover the endpoint pairs.

The endpoint processing module further provides a multiplexing function by switching the output connection from the two different decompression paths to the input of an unquantization module . As discussed earlier in the disclosure the precision of the endpoints may vary depending on the mode. The unquantization module may be used to estimate the original endpoint pairs to full precision.

The processing module may also include an endpoint index selection module . The endpoint index selection module may be used to select the endpoint pair and the corresponding index for each texture element in the block based on the partition bits. The endpoint index selection module may be implemented with a look up table not shown or by any other suitable means. The look up table may be implemented with a PROM or some other memory device. In at least one embodiment the look up table may store various spatial partitioning patters for a block of texture data. The look up table may be addressed by the partition bits. The spatial partitioning pattern for any given set of partition bits assigns an endpoint pair to each texture element in the block. As discussed earlier each endpoint pair represents a line segment palette. The palette index for each texture element may be determined from the compressed indices provided by the data extraction module .

The processing module may also include an interpolation and post processing module . The interpolation and post processing module may include an interpolator module . The interpolator module may be used to determine the texture data for each texture element from the assigned line segment s palette and the palette index. This may be achieved by interpolating the endpoint pairs with their corresponding palette index for each texture element in the block to produce a series of interpolation values representing the texture data for the block. In some embodiments a linear interpolation may be used but a more complex interpolation may be used in other embodiments.

The interpolation values from the interpolator module may be demultiplexed between two different decompression paths depending on the state of the indicator bit. When the state of the indicator bit indicates texture data compressed with a BC7 compression algorithm the interpolation values may be provided to a rotation module . The rotation module may be used to swap channels based on the rotation bits provided by the data extraction module . As discussed earlier in the disclosure the alpha channel may be swapped with the red green or blue channel. When the state of the indicator bit indicates texture data compressed with of a BC6 compression algorithm the interpolation values may be provided to a final unquantization module . The final unquantization module provides a scaling function to provide a full RGB output range that extends from a negative value to a positive value that is centered at zero.

In block compressed texture data is retrieved from local memory see or elsewhere in the form of block data. As explained earlier in the disclosure each block of compressed texture data may include mode bits compressed endpoint pairs compressed indices and partition bits. Texture data compressed with a BC algorithm may include a P bit and rotation bits in the case where separate color and alpha channels are provided.

In block the compression algorithm used to compress the texture data is determined by examining the format of the compressed texture data or certain portions thereof. In this example the compressed endpoint pairs may be provided to block if a BC6 compression was used to compress the texture data. Otherwise in the case where a BC7 compression algorithm was used to compress the texture data the compressed endpoint pairs may be provided to block .

In block an inverse transform function may be applied to the compressed endpoint pairs. As discussed earlier in the disclosure BC6 uses a transform function where each end point pair is derived from a reference endpoint. The inverse transform may use the reference endpoints to recover an end point pair for each line segment in the block. Depending on the mode a sign extension operation may also be applied in block .

In block a P bit operation may be applied to the compressed endpoint pairs. As explained earlier in the disclosure the P bit operation may be performed by appending a P bit to each of the compressed endpoint pairs to recover an end point pair for each line segment used in the block.

In block the endpoint pairs may be unquantized. As discussed earlier in the disclosure the precision of the endpoints may vary depending on the mode. The unquantization process may be used to estimate the original endpoint pairs to full precision.

In block the endpoint pair and the corresponding index for each texture element in the block may be selected based on the partition bits. As discussed earlier each endpoint pair represents a different line segment palette. The palette index for each texture element may be determined from the compressed indices.

In block the endpoint pair for each texture element in the block may be interpolated with its corresponding palette index to produce an interpolation value representing the texture data for that element. In some embodiments a linear interpolation may be used but a more complex interpolation may be used in other embodiments. The interpolation values for the texture elements in the block may be provided to block if the texture data was originally compressed with a BC6 compression algorithm. Otherwise in the case of texture data compressed with a BC7 compression algorithm the interpolation values may be provided to block .

In block the interpolation values are unquantized. The unquantization of the interpolation values provide a scaling function that results in a full RGB output range that extends from a negative value to a positive value that is centered at zero. The output from block is the uncompressed texture data for a block of texture elements.

In block the interpolation values may be rotated or the channels swapped based on the rotation bits. As discussed earlier in the disclosure the alpha channel may be swapped with the red green or blue channel. The output from block is the uncompressed texture data for a block of texture elements.

It is understood that any specific order or hierarchy of blocks described in the context of testing an integrated circuit is being presented to provide an example of a method for testing an integrated circuit. Based upon design preferences it is understood that the specific order or hierarchy of blocks may be rearranged while remaining within the scope of the invention.

The previous description is provided to enable any person skilled in the art to fully understand the full scope of the disclosure. Modifications to the various exemplary embodiments disclosed herein will be readily apparent to those skilled in the art. Thus the claims should not be limited to the various aspects of the disclosure described herein but shall be accorded the full scope consistent with the language of claims. All structural and functional equivalents to the elements of the various aspects described throughout this disclosure that are known or later come to be known to those of ordinary skill in the art are expressly incorporated herein by reference and are intended to be encompassed by the claims. Moreover nothing disclosed herein is intended to be dedicated to the public regardless of whether such disclosure is explicitly recited in the claims. No claim element is to be construed under the provisions of 35 U.S.C. 112 f unless the element is expressly recited using the phrase means for or in the case of a method claim the element is recited using the phrase step for. 

