---

title: Method and system for the normalization, filtering and securing of associated metadata information on file objects deposited into an object store
abstract: A system and method to prioritize, filter, and normalize metadata from files being transferred from a file system to an object store repository. The metadata is associated with the file (object) when saved to the object store repository.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09619487&OS=09619487&RS=09619487
owner: INTERNATIONAL BUSINESS MACHINES CORPORATION
number: 09619487
owner_city: Armonk
owner_country: US
publication_date: 20130618
---
This application claims priority from U.S. Provisional Patent Application No. 61 661 075 filed on Jun. 18 2012 which is relied upon and incorporated herein in its entirety by reference.

This invention relates to file metadata and data storage systems more specifically the automated creation of metatags associated with objects in an object storage system.

There are a variety of generally known data storage systems including object based storage systems commonly referred to as an object stores. Object stores are massively scalable well beyond traditional file system storage devices in both raw capacity and the number of storable items objects . Object stores include redundancy and scalability mechanisms that are entirely software based which allows object stores to run on commodity non specialized hardware with high reliability and consistent performance. Further object stores allow each object to contain both the data sequence of bytes representing the object contents and metadata set of attributes describing the data making objects easier to search and locate specific contents than traditional file systems. These properties make object stores highly flexible and desirable platforms for a variety of needs where storage requirements are largely unbounded or unstructured data is collected and may later be accessed for arbitrary purposes.

A large amount of useful metadata is automatically generated and exists within files for numerous content types. For example standard office documents frequently contain properties such as Title Subject Author Company etc. and JPEG images contain information on the capturing apparatus and image properties e.g. JPEGs frequently contain both EXIF and XMP metadata information . There are systems both proprietary and open source for extracting known metadata information from numerous content types. These systems are designed to parse files for known metadata locations and values and output the raw metadata from each file.

Applying metatags a metadata key paired with a value key value or key value or name value to objects greatly increases the ability to search and use the content in the object store. However in all but the smallest of cases manually applying metatag information to each object passed into the storage repository is infeasible. Under most circumstances a manual process would be prohibitively time consuming and highly susceptible to error.

Since there is no overarching standard for metadata naming conventions the raw output of metadata extraction from a plurality of content types often contains keys for related information under different key names. For example one file type may designate an Author while another may designate a Creator even though the values contain the same information. Similarly the same file may contain more than one metadata key with the same or similar and potentially conflicting values ex JPEGs frequently contain 3 different metadata keys to convey the F Stop with different formatting of the value for each key .

Compounding these problems are restrictions imposed by the object store on the allowable number value and size constraints for metatags which vary between the object store technologies. Therefore there is a need for methods and systems that can overcome the challenges of associating useful metadata in a normalized fashion to large and varying collections of unstructured data with a plurality of content types as they are deposited into an object store.

A processing system is disclosed that takes metadata extracted from files being transferred from a file system to an object store and prioritizes filters and normalizes the metadata into a collection of metatags that are then associated with the file object when saved to the object store repository. The processing system is capable of receiving raw output from a metadata parser on a file object or digital asset identifying relevant metadata keys and values in addition to potential user configured metadata key values prioritizing the list of relevant metadata keys associating the prioritized list of relevant metadata key values to normalized metatag keys filtering the candidate list of normalized metatag keys and remaining unassociated metadata keys optionally encrypting the filtered list and associating the finalized list of metatags with either an encrypted or unencrypted instance of the original file in the object store.

These and other objects and advantages of the invention will become apparent from the following detailed description of the preferred embodiment of the invention. Both the foregoing general description and the following detailed description are exemplary and explanatory only and are intended to provide further explanation of the invention as claimed. The accompanying drawings are included to provide a further understanding of the invention and are incorporated in and constitute part of this specification illustrate several embodiments of the invention and together with the description serve to explain the principles of the invention.

In the following detailed description of the preferred embodiments reference is made to the accompanying drawings which form a part hereof and within which are shown by way of illustration specific embodiments by which the invention may be practiced. It is to be understood that other embodiments may be utilized and structural changes may be made without departing from the scope of the invention.

As used in the specification and the appended claims the singular forms a an and the include plural referents unless the context clearly dictates otherwise. Ranges may be expressed herein as from about one particular value and or to about another particular value. When such a range is expressed another embodiment includes from the one particular value and or to the other particular value. Similarly when values are expressed as approximations by use of the antecedent about it will be understood that the particular value forms another embodiment. It will be further understood that the endpoints of each of the ranges are significant both in relation to the other endpoint and independently of the other endpoint.

 Optional or optionally means that the subsequently described event or circumstance may or may not occur and that the description includes instances where said event or circumstance occurs and instances where it does not.

Throughout the description and claims of this specification the word comprise and variations of the word such as comprising and comprises means including but not limited to and is not intended to exclude for example other additives components integers or steps. Exemplary means an example of and is not intended to convey an indication of a preferred or ideal embodiment. Such as is not used in a restrictive sense but for explanatory purposes.

Disclosed are components that can be used to perform the disclosed methods and systems. These and other components are disclosed herein and it is understood that when combinations subsets interactions groups etc. of these components are disclosed that while specific reference of each various individual and collective combinations and permutation of these may not be explicitly disclosed each is specifically contemplated and described herein for all methods and systems. This applies to all aspects of this application including but not limited to steps in disclosed methods. Thus if there are a variety of additional steps that can be performed it is understood that each of these additional steps can be performed with any specific embodiment or combination of embodiments of the disclosed methods.

As will be appreciated by one skilled in the art the methods and systems may take the form of an entirely hardware embodiment an entirely software embodiment or an embodiment combining software and hardware aspects. Furthermore the methods and systems may take the form of a computer program product on a computer readable storage medium having computer readable program instructions e.g. computer software embodied in the storage medium. Any suitable computer readable storage medium may be utilized including hard disks CD ROMs optical storage devices or magnetic storage devices.

Further the program environment in which a present embodiment of the invention is executed may incorporate a general purpose computer or a special purpose device such as a hardware appliance virtual server cloud services compute node hand held computer or coexist within the object storage system. In addition the techniques of the components described herein can be implemented using a variety of technologies known in the art. For example the methods may be implemented in software executing on a computer system or implemented in hardware utilizing either a combination of microprocessors or other specially designed application specific integrated circuits programmable logic devices or various combinations thereof. More specifically the methods may be implemented by a series of computer executable instructions residing on a storage medium such as a carrier wave disk drive or computer readable medium. Exemplary forms of carrier waves may take the form of electrical electromagnetic or optical signals conveying digital data streams along a local network or a publicly accessible network such as the Internet.

Embodiments of the methods and systems are described below with reference to block diagrams and flowchart illustrations of methods systems apparatuses and computer program products. It will be understood that each block of the block diagrams and flowchart illustrations and combinations of blocks in the block diagrams and flowchart illustrations respectively can be implemented by computer program instructions. These computer program instructions may be loaded onto a general purpose computer special purpose computer or other programmable data processing apparatus to produce a machine such that the instructions which execute on the computer or other programmable data processing apparatus create a means for implementing the functions specified in the flowchart block or blocks.

These computer program instructions may also be stored in a computer readable memory that can direct a computer or other programmable data processing apparatus to function in a particular manner such that the instructions stored in the computer readable memory produce an article of manufacture including computer readable instructions for implementing the function specified in the flowchart block or blocks. The computer program instructions may also be loaded onto a computer or other programmable data processing apparatus to cause a series of operational steps to be performed on the computer or other programmable apparatus to produce a computer implemented process such that the instructions that execute on the computer or other programmable apparatus provide steps for implementing the functions specified in the flowchart block or blocks.

Accordingly blocks of the block diagrams and flowchart illustrations support combinations of means for performing the specified functions combinations of steps for performing the specified functions and program instruction means for performing the specified functions. It will also be understood that each block of the block diagrams and flowchart illustrations and combinations of blocks in the block diagrams and flowchart illustrations can be implemented by special purpose hardware based computer systems that perform the specified functions or steps or combinations of special purpose hardware and computer instructions.

The present methods and systems can be operational with numerous other general purpose or special purpose computing system environments or configurations. Examples of well known computing systems environments and or configurations that can be suitable for use with the systems and methods comprise but are not limited to personal computers server computers laptop devices and multiprocessor systems. Additional examples comprise set top boxes programmable consumer electronics network PCs minicomputers mainframe computers distributed computing environments that comprise any of the above systems or devices and the like.

The processing of the disclosed methods and systems can be performed by software components. The disclosed systems and methods can be described in the general context of computer executable instructions such as program modules being executed by one or more computers or other devices. Generally program modules comprise computer code routines programs objects components data structures etc. that perform particular tasks or implement particular abstract data types. The disclosed methods can also be practiced in grid based and distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment program modules can be located in both local and remote computer storage media including memory storage devices.

Further one skilled in the art will appreciate that the systems and methods disclosed herein can be implemented via a general purpose computing device in the form of a computer . The components of the computer can comprise but are not limited to one or more processors or processing units a system memory and a system bus that couples various system components including the processor to the system memory . In the case of multiple processing units the system can utilize parallel computing.

The system bus represents one or more of several possible types of bus structures including a memory bus or memory controller a peripheral bus an accelerated graphics port and a processor or local bus using any of a variety of bus architectures. By way of example such architectures can comprise an Industry Standard Architecture ISA bus a Micro Channel Architecture MCA bus an Enhanced ISA EISA bus a Video Electronics Standards Association VESA local bus an Accelerated Graphics Port AGP bus and a Peripheral Component Interconnects PCI a PCI Express bus a Personal Computer Memory Card Industry Association PCMCIA Universal Serial Bus USB and the like. The bus and all buses specified in this description can also be implemented over a wired or wireless network connection and each of the subsystems including the processor a mass storage device an operating system metadata software metadata data a network adapter system memory an Input Output Interface a display adapter a display device and a human machine interface can be contained within one or more remote computing devices at physically separate locations connected through buses of this form in effect implementing a fully distributed system.

The computer typically comprises a variety of computer readable media. Exemplary readable media can be any available media that is accessible by the computer and comprises for example and not meant to be limiting both volatile and non volatile media removable and non removable media. The system memory comprises computer readable media in the form of volatile memory such as random access memory RAM and or non volatile memory such as read only memory ROM . The system memory typically contains data such as metadata and or program modules such as operating system and metadata software discussed below that are immediately accessible to and or are presently operated on by the processing unit .

In another aspect the computer can also comprise other removable non removable volatile non volatile computer storage media. By way of example illustrates a mass storage device which can provide non volatile storage of computer code computer readable instructions data structures program modules and other data for the computer . For example and not meant to be limiting a mass storage device can be a hard disk a removable magnetic disk a removable optical disk magnetic cassettes or other magnetic storage devices flash memory cards CD ROM digital versatile disks DVD or other optical storage random access memories RAM read only memories ROM electrically erasable programmable read only memory EEPROM and the like.

Optionally any number of program modules can be stored on the mass storage device including by way of example an operating system and metadata software . Each of the operating system and metadata software or some combination thereof can comprise elements of the metadata software . Metadata can also be stored on the mass storage device . Metadata can be stored in any of one or more databases known in the art. Examples of such databases include DB2 Microsoft Access Microsoft SQL Server Oracle mySQL PostgreSQL and the like. The databases can be centralized or distributed across multiple systems.

In another aspect the user can enter commands and information into the computer via an input device not shown . Examples of such input devices comprise but are not limited to a keyboard pointing device e.g. a mouse a microphone a joystick a scanner tactile input devices such as gloves and other body coverings and the like. These and other input devices can be connected to the processing unit via a human machine interface that is coupled to the system bus but can be connected by other interface and bus structures such as a parallel port game port an IEEE 1394 Port also known as a Firewire port a serial port or a universal serial bus USB .

In yet another aspect a display device can also be connected to the system bus via an interface such as a display adapter . It is contemplated that the computer can have more than one display adapter and the computer can have more than one display device . For example a display device can be a monitor an LCD Liquid Crystal Display or a projector. In addition to the display device other output peripheral devices can comprise components such as speakers not shown and a printer not shown which can be connected to the computer via Input Output Interface . Any step and or result of the methods can be output in any form to an output device. Such output can be any form of visual representation including but not limited to textual graphical animation audio tactile and the like.

The computer can operate in a networked environment using logical connections to one or more remote computing devices . By way of example a remote computing device can be a personal computer a laptop computer portable computer a server a router a network computer a peer device or other common network node and so on. Logical connections between the computer and a remote computing device can be made via a local area network LAN and a general wide area network WAN . Such network connections can be through a network adapter . A network adapter can be implemented in both wired and wireless environments. Such networking environments are conventional and commonplace in offices enterprise wide computer networks intranets and the Internet .

For purposes of illustration application programs and other executable program components such as the operating system are illustrated herein as discrete blocks although it is recognized that such programs and components reside at various times in different storage components of the computing device and are executed by the data processor s of the computer. An implementation of metadata software can be stored on or transmitted across some form of computer readable media. Any of the disclosed methods can be performed by computer readable instructions embodied on computer readable media. Computer readable media can be any available media that can be accessed by a computer. By way of example and not meant to be limiting computer readable media can comprise computer storage media and communications media. Computer storage media comprise volatile and non volatile removable and non removable media implemented in any methods or technology for storage of information such as computer readable instructions data structures program modules or other data. Exemplary computer storage media comprises but is not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can be accessed by a computer.

The methods and systems can employ Artificial Intelligence techniques such as machine learning and iterative learning. Examples of such techniques include but are not limited to expert systems case based reasoning Bayesian networks behavior based AI neural networks fuzzy systems evolutionary computation e.g. genetic algorithms swarm intelligence e.g. ant algorithms and hybrid intelligent systems e.g. Expert inference rules generated through a neural network or production rules from statistical learning .

An embodiment of the present invention as illustrated in provides a metadata extraction and normalization MEN system to extract prioritize normalize and associate file metadata from files found on a traditional file system as metatags in an object store repository .

In some embodiments the system may reside on any modern computing device such as a general purpose server computer as discussed above and shown in . For example a CPU e.g. of for the MEN system may be a recent model such as an Intel Xeon E7 or equivalent. In an embodiment of the present invention multicore or parallel processors may be utilized to improve code execution time of the MEN system . In an aspect memory e.g. of should be sufficient to load and hold the system data structures from the file system . For example in such an aspect the memory can be generally configured in excess of 2 GB of RAM in the current embodiment. Persistent storage such as local hard disk NAS or block devices accessible by the metadata extraction and normalization system should be sufficient to hold files from the file system while being processed. In an embodiment persistent storage in excess of 50 GB can be used. Other embodiments of the MEN system may incorporate other processors e.g. in or low power CPUs commonly used on mobile devices lower or higher amounts of system memory or less or more persistent storage space .

The files can come from a number of file systems on a number of devices. For example the files can be transferred from a common general purpose computer or data storage system or from a specific device including but not limited to a digital camera mobile phones tablets digital audio recorders and or the like.

The object store repository can be any of a collection of object storage platforms such as OpenStack Object Storage EMC Atmos Amazon S3 Amplidata AmpliStor Caringo CASTor Ceph Nirvanix Microsoft Azure Blob Storage and Scality Ring and the like. The object store repository may be centrally located or distributed remotely including between multiple geographic regions. In either case the multiple servers can be accessed via a uniform API.

As illustrated in the MEN system receives a file from a file system that is sent to the object repository . The MEN system illustrated in accepts a file transfer request and the corresponding file from the originating file system device . In an aspect the MEN system can accept files transferred over SMB or NFS protocols. In other aspects the MEN system can use other file transfer methods such as FTP WebDAV HTTP HTTPS or SCP. Transfers of files can occur over various networks e.g. of and can occur on any number of common computer network technologies such as Ethernet fiber channel or wireless systems.

In another aspect the various applications of the MEN system discussed in more detail below can run against an existing file system without requiring the file to be initially copied to the MEN system . In another aspect the various applications of the MEN system can run against an existing object store different from the destination object store . The file can be transferred to a file system in user space system FUSE file system . The FUSE file system can register the file in an object cache . The MEN system can assign a permanent identifier to locate the file given that files saved in the object cache are transient by nature. The FUSE file system can also store the file to persistent storage . In an aspect as discussed above the persistent storage can include but is not limited to a local storage device ephemeral storage memory storage and the like. In another aspect of the MEN system can use another user programmable file system or a kernel module file system. In another embodiment the MEN system can include a crypto system that can encrypt a file when passed to the object store repository and will create an encrypted copy of the file . Any number of encryption ciphers known in the art may be employed to encrypt the file.

Once the file has been transferred from the file system to the MEN system and registered with the object cache a translation application layer can queue and issue calls to the object store repository to transfer the files either to or from the MEN system based on the transfer request using an object storage application programming interface API .

A configuration and monitoring application can issue configuration options to the object cache . In an aspect the configuration and monitoring application can provide for a number of configuration options. In an aspect the configuration options of the configuration and monitoring application can include enabling and defining the encryption application layer and enabling and defining the metadata extraction and normalization application discussed below. The configuration and monitoring application can also define how objects files should be manipulated and persistently stored in the object cache the persistent storage as well as the object store repository . The configurations can be user defined and stored in a configuration database . For example the user can configure settings including but not limited to which object store API to use which object store location to use how metadata is extracted what metadata is extracted and how the extracted metadata will be tagged in the object store repository .

In an aspect the MEN system can be monitored by a health monitor application . The health monitor application is responsible for ensuring processes are running and properly operational. The primary function of the health monitor application is to monitor processes that the MEN system launches and detect if the processes launched are executed and carried out. Depending on configuration settings the health monitor application can restart an exited process collect system information at the time of the exit and package this information into a bundle of files that can be analyzed. The health monitor application can also dispatch log messages that may be observed by operators users located in an event logger application . The event logger application can take log messages for a variety of processes running on the MEN system and log the messages both to a user interface Web UI or CLI and to the local persistent storage . The event logger application can also ensure that log messages do not overrun the allocated disk space for the logs.

In an aspect as shown in the MEN system can utilize the FUSE file system to work with a file system call translator a collection of memory objects a cloud work scanner a queue discipline module a thread pool module cloud talkers an object locator and the object store repository all described in more detail below.

In an embodiment the FUSE file system provides a file system interface where files objects may be copied onto or off of the MEN system . The file system call translator is a subsystem that ensures the desired call semantics of the FUSE file system are executed as intended. The FUSE file system utilizes the file system call translator to call the appropriate functional call on the object . The file system call translator is activated to apply a function on an object once the object locator confirms that the object file exists with the object locator looking towards the object cache persistent storage and or the collection .

The memory object collection includes a local representation of a file which can be stored on the object cache and or persistent storage for certain operations to enhance read getattr readdir and or write performance by having localized versions of the data of the files objects to be stored in the object store repository . The reads and writes executed by the file system call translator can be done on the local versions of the file object found in the object collection to optimize the read and write performance. In an aspect the optimization occurs by working on local file object versions asynchronously from objects being transferred to the object store repository which avoids object store interaction time. The MEN system via the cloud work scanner ensures that modifications made to the files objects stored in the memory object collection are later synchronized with the file objects transferred and stored on the object store repository .

The cloud work scanner scans the objects files of the memory object collection to look for modified objects to determine what cloud operation is required which will be carried out by the API associated with the object store repository . Cloud operations carried out by the object store API include loading an object to the object store repository by copying the contents of the local file which can be found on the object cache or object collection updating object metatags deleting objects modified and unmodified from the object store repository and downloading object data from the object store repository .

In an aspect the cloud work scanner can also work with the discipline module to transfer the objects and metatags to the object store repository . The discipline module can define the operations carried out by the MEN system . Various disciplines discussed below can control the operations performed by the thread pool could talkers on the objects that are stored on the object store repository .

In an aspect the discipline module includes various disciplines. The disciplines can include but are not limited to a sync discipline a fetch discipline a delete discipline a meta directory discipline and a meta object discipline . The sync discipline can be used to copy files from the local system to the object store repository and verify the transfer. The fetch discipline can be used to retrieve files from the object store repository to the local system and verify the transfer. In an aspect the verification for the sync discipline and fetch discipline can be performed by comparing a hash signature of the object data carried out by the MEN system against the hash signature carried out by object store repository . The delete discipline can delete files from the object store repository . The meta directory discipline can create an object of information in a directory on the object store repository . The object file created by the meta directory discipline can represent a directory of objects that can have metadata for each object on the object store repository or the created object can contain similar metadata that is stored in the original object . The meta object discipline can create additional information for a single object that is be stored on the object store repository . For example the additional information can include ownership and group permissions. In other embodiments these and other disciplines known in the art can be used to facilitate the transfer of files to object store repositories.

The disciplines can define the operations performed by the thread pool cloud talkers . The cloud talkers based on the message commands received will perform the requested unit of work as it pertains to interfacing with the object store. The cloud talkers can perform units of work required by the MEN system . The cloud talkers threads can perform be executed in parallel with one another.

A file that has locally modified data i.e. found on the memory object collection on the object cache will for example issue a sync message discipline to ensure the modified data is written to the cloud object store repository . The sync discipline will bring the file in sync with the local object found in the object memory collection . The various disciplines of the discipline module are configured so that the thread pools cloud talkers can call on any discipline to operate on any object .

The thread pools cloud talkers can interface with a multitude of cloud APIs by calling upon the storage API establishing a communication path to the object store repository hence the name cloud talkers. Each thread 1 2 . . . m can accept workloads on a single object and or local object whether stored on the object cache directly from the file system or the persistent storage of any discipline. Each thread constantly awaits a workload message discipline from the cloud work scanner . A thread can do a unit of work defined by the various disciplines as defined by the discipline module . A thread continually waits for disciplines e.g. sync to be available and reads off a single message discipline available to all worker threads . Language locking semantics ensure that a message discipline is delivered to exactly one thread . For example the queue functionality available in Python ver. 2.7 provides this type of message synchronization. When the worker thread reads the message it contains the unit of work as determined requested by the discipline module and the object from the memory object collection on which to operate. The worker thread proceeds until completion of the unit of work and removes the message from the queue to ensure no other thread will attempt the same.

For example a pool thread cloud talker is assigned a sync workload discipline . The pool thread begins by taking a snapshot of the local representation of the file found in the memory object collection . After this snapshot the MEN system clears the modified object to reset the condition of the object to its unmodified state.

The object locator is responsible for finding a localized object or stored on the object store repository . The FUSE file system calls or generally references a file on the file system by a path. A path is a unique location within a single file system that describes either a directory of files or an individual file . The FUSE file system maps these file system objects to in memory representations by performing a lookup of the path and returning an object potentially creating it . The object is identified to the FUSE file system by calculating a persistent identifier which is performed by the object locator .

Prior to initiating communication with the object store repository a complete description of the work required to sync the object data is persisted to the persistent storage on the MEN system . If operations are interrupted the complete work description stored on the persistent storage can be used to restart the exact same transaction. In fact the originating sync discipline is initiated from this set of saved instructions which can also be stored on the persistent storage . Prior to commencement of the transaction the locally modified object found in the object memory collection is checked. If modifications are indicated the current sync operation discipline is aborted and the cloud work scanner will reschedule the new sync .

In an aspect the MEN system through the use of the metadata extraction and normalization application has the ability to normalize metatags across all content types of files from any file system by mapping extracted metadata keys to a common metatag key that is used in the object store repository . The mapping capability is provided per content type to give fine grain control over the keys used. To accommodate redundant or conflicting metadata information the MEN system allows a user to specify a list of extracted metadata keys in prioritized order to map to the metatag key. Metadata values from the highest priority key are used as the value assigned to the metatag key.

In an aspect as illustrated in the metadata extraction and normalization MEN application is utilized to extract and normalize the metadata contained in the files to create metatags for the object store repository . The MEN application can include a metadata extractor module and a metadata normalization module

When the MEN application is enabled files from the file system that are passed through the MEN system are sent to a metadata extractor module of the MEN application that pulls metadata information from the files . In an aspect the MEN application and more specifically the metadata extractor module is able to identify the file type of the file in order to extract the metadata . In an aspect the extractor will determine the file type by the extension of the file or by looking for a known sequence of bytes that start the file content types e.g. magic numbers . The metadata extractor module accepts a plurality of file types and outputs metadata information that is embedded in the file . In an aspect embodiments the metadata extractor module can be commonly available metadata extraction tools such as but not limited to Tika Open source Apache project and the like.

In other embodiments the MEN system via the MEN application and metadata extractor module may accept external sources of metadata information to associate with the file . Examples of external metadata sources include database repositories content management systems and object storage devices among other systems. Examples of metadata include but are not limited to Author Last Author Title and document statistics from Office document types Artist Album Genre from Audio files and F Stop Exposure Flash from Images.

The metadata extraction module takes as input a file of any content type and outputs extracted metadata either extracted by the metadata extraction module or supplied by external sources in a dictionary form . The metadata dictionary can be a collection of pairs of key names and matching values . The metadata dictionary allows for a name found in the extracted metadata to be looked up to see if a key of the same name exists. Using the matching of the name of the metadata to the key a value associated with the found key can be changed. In addition the MEN application can create new and delete key value pairs .

In an aspect the metadata dictionary can employ a JSON JavaScript Object Notation format comprising a collection of name value pairs as indicated by the Name1 Value1 . The metadata dictionary can be modified and updated by the MEN system throughout the synch process as described above. Additional embodiments may use other structured formats for the metadata dictionary including but not limited to XML Python dictionaries python ordered collections or a database. The metadata extraction module may determine the content type of the input file . In an embodiment the thread pool can be configured to provide the content type of the file . As discussed above the content type of the file can be used by a metadata key mapping module to find a certain configuration state corresponding to a configuration file .

The metadata key mapping module provides a user the ability to create a user defined key name friendly name that can be consistently applied across a plurality of content types for specific information and associate the values from specific automatically extracted keys to the user defined key name friendly name . Additionally the metadata key mapping module allows a user to specify a hierarchy of extracted key values to a user defined key name. This enables the user to create rules to resolve conflicts in metadata values within specific content types.

For example of operation of the metadata key mapping module a user may start by identifying the metadata keys that are contained in the selected content types . After assembling the list of metadata keys for content types the user may identify if there are keys in different content types that expose the same information but use different names Author and Creator are commonly used interchangeably between different content types . If so the user can then determine the key name to use friendly key name for organizing metadata keys and determine which extracted key names should be associated with the friendly key name

Utilizing the metadata key mapping module the user can then determine if there are extracted keys within the same content type that provides similar information as shown in the configuration file created and configured by the configuration and monitoring application from input provided by the user and its friendly key list . The configuration file represents the rules to map extracted metadata keys to friendly key names and prioritize extracted keys that contain redundant information. For example JPEG image contain Aperture Value F Number and exif FNumber with the same information different formatting . The user is then to use the mapping configuration to prioritize which value is used when creating the metadata tag in the storage repository.

After the user has created the mapping list comprised of the configuration file and friendly key list the user may either enter the list directly into the MEN system through CLI commands or create a specially formatted file to import a large list of mapping rules at one time. In some embodiments of the system the user can use a web interface to set up and import the mapping list. In an aspect the user can call upon the configuration and monitoring application to create the configuration file and friendly key list which can be stored in the configuration database .

In an aspect the metadata key mapping module is configured to scan metatags of the files and replace the first encountered tag metadata with a configured user defined name or friendly key contained within the configured metadata mappings with the value of the matched tag . In other words the name of the original metadata pairs is replaced by the friendly key . The content type of the file either determined by the metadata extractor or passed in by the cloud talker is used to determine what if any configured friendly key list should be employed. For each content type the MEN system allows for a user defined name friendly key to be used in place of the key name from the extracted or externally defined metadata information . The key value will then be matched with the friendly key

In an aspect with each friendly key name the MEN system maintains a user defined priority ordered list of the friendly key names to replace the metadata key names . The metadata key mapping module discards and removes from the dictionary any subsequent keys names and values encountered in the remaining key list of lower priority during the scan. If a higher priority key name is found that matches a friendly key name the metadata key mapping module shall update the friendly key value with the metadata key value of higher priority. The metadata key mapping module is capable of discarding other tags specified in the list if a match is made. More specifically the metadata key mapping module considers each key name in the ordered list . If the metadata key mapping module fails to make a match to friendly keys being used that is there is no corresponding friendly key matching a key name any of the remaining key names encountered are deleted along with their values . Once completed mapping the metadata key mapping module will then modify the metadata dictionary to a normalized or modified metadata dictionary that is used as input for later modules in the pipeline.

After the metadata key mapping module completes its mapping the normalized modified metadata dictionary now contains condensed metatags from the friendly key name replacement and discard . This condensed normalized modified dictionary is now input to a metadata key filter module .

The metadata key filter module takes the modified condensed dictionary the configuration file and key friendly list . The metadata key filter module is configured by a filter configuration file . The filter configuration file contains a user defined list of metadata key names that should be included whitelisted and or excluded blacklisted of each content type identified by the user to be included in the object store repository . If the metadata information in the modified condensed dictionary contains a content type that matches a content type found in the filter configuration file the metadata key filter module is applied. The metadata key filter module may either be classified as a white list defined by the filter configuration where only keys in this list are included or a black list where matching keys are discarded . In an aspect the MEN system can filter based on the entire key name key names filter or the first set of characters in a key name key prefixes filter . The metadata key filter module is useful for including or removing a set of key names. For example creating a whitelist filter configuration file for image jpeg with the key prefixes filter GPS will include all of the GPS related key names GPS Latitude GPS Longitude GPS Altitude etc. . Another embodiment of the MEN system allows for other partial key name matches such as allowing wildcards or regular expressions in the key name filter. In another aspect the MEN system can define reserved key names for its own internal operation that if encountered shall be discarded or renamed.

The user may construct a filter configuration file comprised of lists of specific metadata that he wishes to include or exclude. For example if the user desires to ensure that all GPS related metadata is included as metatags in the object store repository he may define a whitelist filter configuration file that contains a key prefix for GPS . Similarly if the user wishes to exclude all EXIF data from images he may create a blacklist filter configuration file for the key prefix EXIF .

As with the friendly name list after the user has created the filter configuration file the user may either enter the file directly into the system through CLI commands or create a specially formatted file to import a large list of mapping rules at one time. In some embodiments of the MEN system the user can use a web interface to set up and import the mapping list.

In addition to the metadata extracted from the file the MEN system allows for users to supply its own metadata in the form of user defined metadata key value pairs or metatags that are associated with all objects passed to the object store repository . These user defined metatags may be used to associate system information with the objects such as the version of the system that processed the object or the location the system processed the object or other user defined information that the operator wishes to associate with all of the files processed by the MEN system .

After the metatagging is completed the MEN application can call upon the metadata size enforcing module which trims the normalized metadata dictionary according to configured size constraints . The length restrictions can be defined by the object store repository and or HTTP header restrictions. The metadata size enforcing module can call on parameters size parameters to ensure the length restrictions. These parameters may be provided by the MEN system or supplied by the user. Further in some embodiments of the present invention the MEN system must be configured to operate within the limitations of the object store repository . For example the object store repository may only accept metadata with ASCII strings for keys and values . Characters outside of this range must be omitted or represented with a placeholder ACSCII character such as . For example when image file types are transferred other binary data such as thumbnail images may not be associated with the file using the object store s metatag capabilities. The object store repository may also limit the length of each metatag key names associated with an object . For example the friendly key names may be limited to 128 characters. In such instances the MEN system via the metadata size enforcing module may be configured to handle extracted keys with key names longer than this limit by omission or truncation to conform to the character limit. Similarly the metatag value may be limited by the object store repository . For example the length of each metatag combined friendly name and value may be limited at 255 characters. Metadata keys with values longer than this limit will be omitted or truncated based on the configuration of the MEN system and carried out by the metadata size enforcing module .

In another embodiment the size constraints can include both key value pair counts and total size of the normalized metadata dictionary due to limitations of the object store repository on the number of metatags that may be associated with each object . For example the object store repository may limit each object to a maximum of 90 metatags. However the number of metatags per object varies significantly between content types. For example jpeg image files frequently contain over 100 extractible metadata key value pairs. As such the MEN system allows configuration of the maximum number of metatags that shall be associated with any specific object in the object store repository . Further the MEN system may limit total size of all metadata per object . This may be required due to either or both HTTP Hypertext Transfer Protocol limitations as well as object store repository limitations. In such instances the MEN system may be configured to omit or truncate keys as needed to obey this limit. Any key names or values exceeding these restrictions are discarded and logged. The MEN system reserves space for any configured system keys and reserved keys for operation. The MEN system via the metadata size enforcing module first trims to the maximum allowed pair count and then discard key value pairs until the maximum allowable size is not exceeded. The determination of which key value pairs to remove will give mapped friendly keys and whitelist keys from the filter configuration file priority. Only after all non friendly keys are discarded are the friendly keys considered for removal.

Prior to queuing the metatags to be transferred with the objects to the storage repository through an Object Storage API the MEN system may optionally encrypt the metadata. Different embodiments allow for encrypting either or both of the metadata keys and values using any number of encryption ciphers . Whether or not the metadata is encrypted a final metadata dictionary is created from the normalized metadata dictionary .

The configured system key values and final metadata dictionary must be incorporated into the cloud object representation the in memory object collection prior to uploading to the object store repository using the object storage API . Any previously associated metadata state in the in memory object is purged and the final metadata dictionary is written into the object . At this point the in memory object is synchronized to the object store repository by selecting a cloud talker from the thread pool and transferring the object using the selected the appropriate API from the Object storage API for the selected object store .

Any errors detected during the sync discipline are logged and the sync is retried until a successful indication is received from the object store repository that the file and metadata final metadata dictionary have been accepted.

While the system is configured to assign metatags to the object files themselves the raw extracted metadata may be passed directly to the object store repository as metadata tags using the appropriate API from the object storage API .

In an aspect the MEN system can allow for metadata information that cannot be associated directly with the object as a metatag to be stored as a separate object in the object store repository and referenced using a metatag that is directly associated with the object. For example certain object storage repositories do not allow non ASCII information such as thumbnail images to be included as metadata. Under this circumstance the MEN system shall create a separate object for the thumbnail and reference the location of the thumbnail object in the original object metadata . In this embodiment the extracted key name or friendly name as described above will contain a location reference for the metadata content object. In this aspect the metadata normalization module is fed a friendly key list to indicate which metadata key values to store as objects in the object store . When matching keys are found during the scan the values of the keys are stored as files in persistent storage and the value of the key is replaced with the location of the value file object. When a matching metadata key is found in the condensed dictionary the metadata value file is transferred in addition to the original file to the object store repository via the object storage API . This method may be employed to circumvent any of the object storage constraints described above.

While the foregoing written description of the invention enables one of ordinary skill to make and use what is considered presently to be the best mode thereof those of ordinary skill will understand and appreciate the existence of variations combinations and equivalents of the specific embodiment method and examples herein. The invention should therefore not be limited by the above described embodiment method and examples but by all embodiments and methods within the scope and spirit of the invention. To the extent necessary to understand or complete the disclosure of the present invention all publications patents and patent applications mentioned herein are expressly incorporated by reference therein to the same extent as though each were individually so incorporated.

Having thus described exemplary embodiments of the present invention those skilled in the art will appreciate that the within disclosures are exemplary only and that various other alternatives adaptations and modifications may be made within the scope of the present invention. Accordingly the present invention is not limited to the specific embodiments as illustrated herein but is only limited by the following claims.

