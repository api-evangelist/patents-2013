---

title: System, method, and computer program product for implementing multi-cycle register file bypass
abstract: A system, method, and computer program product are provided for implementing a multi-cycle register file bypass mechanism. The method includes the steps of receiving a set of control bits, combining the set of control bits with a set of valid bits associated with previously issued instructions, and enabling a bypass path for each thread based on the set of control bits and the set of valid bits. Each valid bit in the set of valid bits indicates whether execution of an instruction of the previously issued instructions was enabled for a thread in a thread block.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09477482&OS=09477482&RS=09477482
owner: NVIDIA Corporation
number: 09477482
owner_city: Santa Clara
owner_country: US
publication_date: 20130926
---
The present invention relates to processor architectures and more particularly to processors that enable a multi cycle register file bypass path.

Modern graphics processing units GPUs include highly parallel architectures capable of executing hundreds and even thousands of threads in parallel substantially simultaneously. In such architectures bypass circuits have been implemented in order to enable data scheduled for storage in the register file to be routed during the same clock cycle to the input of a data path to be reused. However typically such bypass mechanisms are implemented in logic located in the register file of an integrated circuit. When groups of related threads are executed within these processors multiple copies of the logic perform essentially the same operation thereby creating redundant logic that increases the complexity of the integrated circuit. Thus there is a need for addressing this issue and or other issues associated with the prior art.

A system method and computer program product are provided for implementing a multi cycle register file bypass mechanism. The method includes the steps of receiving a set of control bits combining the set of control bits with a set of valid bits associated with previously issued instructions and enabling a bypass path for each thread based on the set of control bits and the set of valid bits. Each valid bit in the set of valid bits indicates whether execution of an instruction of the previously issued instructions was enabled for a thread in a thread block.

A processor includes a scheduler unit that is configured to generate control bits associated with an instruction issued to a plurality of execution pipelines. The control bits represent a set of bypass enable signals for a plurality of threads being executed by the execution pipelines. A thread block or warp comprises a number e.g. 32 of threads executing in parallel. Each thread in the thread block executes the same instruction on different data during a particular clock cycle. Threads may be allowed to diverge thereby allowing some threads to execute the instruction while other threads are idle. Because each thread is executing the same instruction the bypass enable signals generated by the scheduler unit are the same for every thread. However because threads are allowed to diverge data accessible via a particular bypass path for one thread may be valid while data accessible via the particular bypass path for another thread may be invalid. Therefore logic associated with each thread combines the control bits with thread specific valid bits to enable or disable various bypass paths of the register file. By moving the comparison logic for generating the control bits to a central location and broadcasting the control bits to a plurality of execution pipelines which then combine the control bits with the thread specific valid bits processor complexity can be reduced and bypass logic need not be replicated for each execution pipeline thereby saving power and making the processor more efficient as well as reducing routing complexity.

More illustrative information will now be set forth regarding various optional architectures and features with which the foregoing framework may or may not be implemented per the desires of the user. It should be strongly noted that the following information is set forth for illustrative purposes and should not be construed as limiting in any manner. Any of the following features may be optionally incorporated with or without the exclusion of other features described.

In one embodiment the PPU includes an input output I O unit configured to transmit and receive communications i.e. commands data etc. from a central processing unit CPU not shown over the system bus . The I O unit may implement a Peripheral Component Interconnect Express PCIe interface for communications over a PCIe bus. In alternative embodiments the I O unit may implement other types of well known bus interfaces.

The PPU also includes a host interface unit that decodes the commands and transmits the commands to the task management unit or other units of the PPU e.g. memory interface as the commands may specify. The host interface unit is configured to route communications between and among the various logical units of the PPU .

In one embodiment a program encoded as a command stream is written to a buffer by the CPU. The buffer is a region in memory e.g. memory or system memory that is accessible i.e. read write by both the CPU and the PPU . The CPU writes the command stream to the buffer and then transmits a pointer to the start of the command stream to the PPU . The host interface unit provides the task management unit TMU with pointers to one or more streams. The TMU selects one or more streams and is configured to organize the selected streams as a pool of pending grids. The pool of pending grids may include new grids that have not yet been selected for execution and grids that have been partially executed and have been suspended.

A work distribution unit that is coupled between the TMU and the SMs manages a pool of active grids selecting and dispatching active grids for execution by the SMs . Pending grids are transferred to the active grid pool by the TMU when a pending grid is eligible to execute i.e. has no unresolved data dependencies. An active grid is transferred to the pending pool when execution of the active grid is blocked by a dependency. When execution of a grid is completed the grid is removed from the active grid pool by the work distribution unit . In addition to receiving grids from the host interface unit and the work distribution unit the TMU also receives grids that are dynamically generated by the SMs during execution of a grid. These dynamically generated grids join the other pending grids in the pending grid pool.

In one embodiment the CPU executes a driver kernel that implements an application programming interface API that enables one or more applications executing on the CPU to schedule operations for execution on the PPU . An application may include instructions i.e. API calls that cause the driver kernel to generate one or more grids for execution. In one embodiment the PPU implements a SIMD Single Instruction Multiple Data architecture where each thread block i.e. warp in a grid is concurrently executed on a different data set by different threads in the thread block. The driver kernel defines thread blocks that are comprised of k related threads such that threads in the same thread block may exchange data through shared memory. In one embodiment a thread block comprises 32 related threads and a grid is an array of one or more thread blocks that execute the same stream and the different thread blocks may exchange data through global memory.

In one embodiment the PPU comprises X SMs X . For example the PPU may include 15 distinct SMs . Each SM is multi threaded and configured to execute a plurality of threads e.g. 32 threads from a particular thread block concurrently. Each of the SMs is connected to a level two L2 cache via a crossbar or other type of interconnect network . The L2 cache is connected to one or more memory interfaces . Memory interfaces implement 16 32 64 128 bit data buses or the like for high speed data transfer. In one embodiment the PPU comprises U memory interfaces U where each memory interface U is connected to a corresponding memory device U . For example PPU may be connected to up to 6 memory devices such as graphics double data rate version 5 synchronous dynamic random access memory GDDR5 SDRAM .

In one embodiment the PPU implements a multi level memory hierarchy. The memory is located off chip in SDRAM coupled to the PPU . Data from the memory may be fetched and stored in the L2 cache which is located on chip and is shared between the various SMs . In one embodiment each of the SMs also implements an L1 cache. The L1 cache is private memory that is dedicated to a particular SM . Each of the L1 caches is coupled to the shared L2 cache . Data from the L2 cache may be fetched and stored in each of the L1 caches for processing in the functional units of the SMs .

In one embodiment the PPU comprises a graphics processing unit GPU . The PPU is configured to receive commands that specify shader programs for processing graphics data. Graphics data may be defined as a set of primitives such as points lines triangles quads triangle strips and the like. Typically a primitive includes data that specifies a number of vertices for the primitive e.g. in a model space coordinate system as well as attributes associated with each vertex of the primitive. The PPU can be configured to process the graphics primitives to generate a frame buffer i.e. pixel data for each of the pixels of the display . The driver kernel implements a graphics processing pipeline such as the graphics processing pipeline defined by the OpenGL API.

An application writes model data for a scene i.e. a collection of vertices and attributes to memory. The model data defines each of the objects that may be visible on a display. The application then makes an API call to the driver kernel that requests the model data to be rendered and displayed. The driver kernel reads the model data and writes commands to the buffer to perform one or more operations to process the model data. The commands may encode different shader programs including one or more of a vertex shader hull shader geometry shader pixel shader etc. For example the TMU may configure one or more SMs to execute a vertex shader program that processes a number of vertices defined by the model data. In one embodiment the TMU may configure different SMs to execute different shader programs concurrently. For example a first subset of SMs may be configured to execute a vertex shader program while a second subset of SMs may be configured to execute a pixel shader program. The first subset of SMs processes vertex data to produce processed vertex data and writes the processed vertex data to the L2 cache and or the memory . After the processed vertex data is rasterized i.e. transformed from three dimensional data into two dimensional data in screen space to produce fragment data the second subset of SMs executes a pixel shader to produce processed fragment data which is then blended with other processed fragment data and written to the frame buffer in memory . The vertex shader program and pixel shader program may execute concurrently processing different data from the same scene in a pipelined fashion until all of the model data for the scene has been rendered to the frame buffer. Then the contents of the frame buffer are transmitted to a display controller for display on a display device.

The PPU may be included in a desktop computer a laptop computer a tablet computer a smart phone e.g. a wireless hand held device personal digital assistant PDA a digital camera a hand held electronic device and the like. In one embodiment the PPU is embodied on a single semiconductor substrate. In another embodiment the PPU is included in a system on a chip SoC along with one or more other logic units such as a reduced instruction set computer RISC CPU a memory management unit MMU a digital to analog converter DAC and the like.

In one embodiment the PPU may be included on a graphics card that includes one or more memory devices such as GDDR5 SDRAM. The graphics card may be configured to interface with a PCIe slot on a motherboard of a desktop computer that includes e.g. a northbridge chipset and a southbridge chipset. In yet another embodiment the PPU may be an integrated graphics processing unit iGPU included in the chipset i.e. Northbridge of the motherboard.

As described above the work distribution unit dispatches active grids for execution on one or more SMs of the PPU . The scheduler unit receives the grids from the work distribution unit and manages instruction scheduling for one or more thread blocks of each active grid. The scheduler unit schedules threads for execution in groups of parallel threads where each group is called a warp. In one embodiment each warp includes 32 threads. The scheduler unit may manage a plurality of different thread blocks allocating the thread blocks to warps for execution and then scheduling instructions from the plurality of different warps on the various functional units i.e. cores DPUs SFUs and LSUs during each clock cycle.

In one embodiment each scheduler unit includes one or more instruction dispatch units . Each dispatch unit is configured to transmit instructions to one or more of the functional units. In the embodiment shown in the scheduler unit includes two dispatch units that enable two different instructions from the same warp to be dispatched during each clock cycle. In alternative embodiments each scheduler unit may include a single dispatch unit or additional dispatch units .

Each SM includes a register file that provides a set of registers for the functional units of the SM . In one embodiment the register file is divided between each of the functional units such that each functional unit is allocated a dedicated portion of the register file . In another embodiment the register file is divided between the different warps being executed by the SM . The register file provides temporary storage for operands connected to the data paths of the functional units.

Each SM comprises L processing cores . In one embodiment the SM includes a large number e.g. etc. of distinct processing cores . Each core is a fully pipelined single precision processing unit that includes a floating point arithmetic logic unit and an integer arithmetic logic unit. In one embodiment the floating point arithmetic logic units implement the IEEE 754 2008 standard for floating point arithmetic. Each SM also comprises M DPUs that implement double precision floating point arithmetic N SFUs that perform special functions e.g. copy rectangle pixel blending operations and the like and P LSUs that implement load and store operations between the shared memory L1 cache and the register file . In one embodiment the SM includes 64 DPUs 32 SFUs and 32 LSUs .

Each SM includes an interconnect network that connects each of the functional units to the register file and the shared memory L1 cache . In one embodiment the interconnect network is a crossbar that can be configured to connect any of the functional units to any of the registers in the register file or the memory locations in shared memory L1 cache .

In one embodiment the SM is implemented within a GPU. In such an embodiment the SM comprises J texture units . The texture units are configured to load texture maps i.e. a 2D array of texels from the memory and sample the texture maps to produce sampled texture values for use in shader programs. The texture units implement texture operations such as anti aliasing operations using mip maps i.e. texture maps of varying levels of detail . In one embodiment the SM includes 16 texture units .

The PPU described above may be configured to perform highly parallel computations much faster than conventional CPUs. Parallel computing has advantages in graphics processing data compression biometrics stream processing algorithms and the like.

In one embodiment an input of each execution pipeline is coupled to a lane in the register file . Each lane may include a plurality of random access memory RAM cells arranged as one or more registers for storing instructions and data to be processed by the execution pipelines . An output of each execution pipeline is coupled to the interconnect network which is used to route output data from the execution pipeline back to the register file . In one embodiment each SM may be partitioned such that M execution pipelines are coupled to a partition of the register file . For example each portion of the register file may include registers for four lanes coupled to four execution pipelines to form a partition. Each SM may include a number of these partitions such that a plurality of threads is executed simultaneously across a number of partitions of the register file . In one embodiment the plurality of threads is executed in a single instruction multiple data SIMD architecture i.e. each thread executes the same instruction . In yet another embodiment the plurality of threads is executed in a single instruction multiple thread SIMT architecture i.e. each active thread executes the same instruction but threads are allowed to diverge such that some threads execute the current instruction while other threads are idle .

In conventional processors the processor may enable a bypass mechanism in order to execute instructions more efficiently. Conventionally the scheduler unit transmits a read address and a write address to the register file . Each lane of the register file receives the same read address and the same write address. During a first clock cycle the output of the execution pipeline is stored in a register specified by the write address. Then during a subsequent clock cycle an input for the execution pipeline is read from a register specified by the read address. In order to enable bypass for a particular instruction the register file includes logic that compares the read address with the write address. It will be appreciated that writing the data to the lane and reading data from the lane using different registers requires two clock cycles to complete. However if the read address matches the write address then the register file in a single cycle can store data in the register specified by the write address and output the data to the execution pipeline for processing. In such cases reading the data from the register in the lane is not required saving one cycle of execution.

In the above case the logic implemented to compare the read address and the write address is implemented for each and every partition of the register file . If an SM includes eight partitions in order to execute simultaneous threads then such logic may be replicated eight times. It will be appreciated that in SIMT architecture processors each and every execution pipeline is executing the same instruction during a given cycle such that the result of each of the eight comparisons will be the same. Copying the logic in each and every partition of the register file therefore is not an efficient way to determine whether the bypass mechanism should be enabled for a particular lane .

The output of the first flip flop is connected to the input of the second flip flop . The output of the second flip flop is then connected to a first input of a third multiplexor . This input is essentially the output of the execution pipeline delayed by one clock cycle. The second input of the third multiplexor is coupled to the registers of the lane implemented as a plurality of RAM cells . The third multiplexor receives an input control bit Bypass Bit from the scheduler unit . The Bypass Bit is set if the output of the second flip flop should be selected as the output of the third multiplexor and cleared if the output of the third multiplexor is read from the RAM cells . The output of the third multiplexor is coupled to the second input of the second multiplexor along with the output of the first flip flop . The second multiplexor receives another input control bit Bypass Bit from the scheduler unit . The Bypass Bit is set if the output of the first flip flop should be selected as the output of the second multiplexor and cleared if the output of the third multiplexor is selected as the output of the second multiplexor . The output of the second multiplexor is connected to the input of a third flip flop . The third flip flop transmits the output of the second multiplexor to the second input of the first multiplexor thereby delaying the output of the second multiplexor by one clock cycle. If the output of the second multiplexor is connected to the output of the second flip flop through the multiplexors and then the output of the second multiplexor is the output of the execution pipeline delayed by two clock cycles. The first multiplexor receives an input control bit Bypass Bit from the scheduler unit . The Bypass Bit is set if the output of the first flip flop should be selected as the output of the first multiplexor and cleared if the output of the third flip flop should be selected as the output of the first multiplexor .

At a first clock edge the output of the last stage of the execution pipeline is transitioned from the input of the first flip flop to the output of the first flip flop . If the Bypass Bit is set the output of the first flip flop is coupled to the input of the first stage of the execution pipeline. However if the Bypass Bit is not set then the output of the second multiplexor is coupled to the input of the first stage of the execution pipeline although delayed by one clock cycle due to the third flip flop . If the Bypass Bit is set then the output of the second multiplexor is the output of the first flip flop . In other words if the Bypass Bit is not set and the Bypass Bit is set then the input to the first stage is the output of the execution pipeline during the previous clock cycle. Similarly if the Bypass Bit and the Bypass Bit are not set but the Bypass Bit is set then the input of the first stage is the output of the execution pipeline delayed by two clock cycles due to the second flip flop and the third flip flop . In other words the control bits for the multiplexors can select one of the output of the execution pipeline Bypass Bit the output of the execution pipeline during the previous clock cycle Bypass Bit the output of the execution pipeline from two clock cycles prior to the current clock cycle Bypass Bit and the data specified by the read address in the RAM cells .

It will be appreciated that if Bypass Bit is set then the output of the execution pipeline during the current clock cycle is selected regardless of the state of the other control bits. Similarly if Bypass Bit is set and Bypass Bit is cleared then the output of the execution pipeline during the previous clock cycle is selected regardless of the state of the Bypass Bit . Thus only the most significant bit that is set where Bypass Bit is the most significant bit determines which bypass path is enabled.

In one embodiment the read of the RAM cells based on the read address received by the lane may be disabled if any of the control bits are set. In other words if one of the bypass paths is enabled the lane may include logic that disables the register access request because the data stored in the register will not be connected to the execution pipeline . Disabling the register access request saves power.

In the SIMT architecture each thread in the 32 threads may be configured as active or inactive using an active mask. The active mask enables thread divergence to be implemented for the different threads. Active threads execute the instruction and inactive threads do not execute the instruction. More specifically in one embodiment each stage of the execution pipeline may be clock gated when an instruction being executed by that stage is associated with an inactive thread. In one embodiment each instruction in the execution pipeline is associated with a valid bit and the valid bit associated with an instruction is cleared when the instruction is executed by an inactive thread. The valid bit may be transmitted from stage to stage within the execution pipeline along with the instruction. In one embodiment the control bits for the multiplexors e.g. Bypass Bit Bypass Bit and Bypass Bit are combined with a valid bit for a corresponding instruction in order to control the multiplexor. In other words an AND gate may be configured to receive the control bit for a corresponding multiplexor along with a valid bit associated with the first input of the multiplexor during that clock cycle. The output of the AND gate is then connected to the control of the multiplexor. Thus even when the Bypass Bits indicate that the destination address of one of the three previously completed instructions matches the read address for an operand of the present instruction the bypass mechanism will only be used if the valid bit is set for one of the three previous instructions corresponding to a set control bit.

The scheduler unit may track the instructions that are issued to the execution pipelines . In one embodiment the scheduler unit includes a FIFO that tracks which instructions are in flight. The FIFO may have a number of slots equal to or greater than the number of stages in the execution pipelines . In other words the FIFO may be sized such that during each clock cycle an entry is pushed into the FIFO at the head of the FIFO and an entry is popped from the FIFO at the tail of the FIFO. If no instruction is issued during a particular clock cycle then an empty entry may be pushed into the FIFO to represent a NOP no operation . For example if the execution pipelines include 8 stages then the FIFO may include 10 entries which hold the 8 instructions currently being processed by the execution pipelines plus the two previous instructions the execution pipeline has finished processing.

For each instruction scheduled by the scheduler unit the logic can compare one or more operands for the instruction to one or more entries in the FIFO to determine if a destination address in any of the selected entries of the FIFO matches the read address for an operand of the current instruction. In one embodiment as shown in the logic compares the read address to the destination of the last three entries of the FIFO. The control bit for the first multiplexor Bypass Bit is generated by comparing the destination address for the instruction in the second to last entry in the FIFO with the read address of the current instruction. If the addresses match then the Bypass Bit is set and the first multiplexor selects the output of the first flip flop as the input to the first stage of the execution pipelines . However if the addresses do not match then the Bypass Bit is cleared. Similarly the control bit for the second multiplexor Bypass Bit is generated by comparing the destination address for the instruction in the next to last entry in the FIFO with the read address of the current instruction and the control bit for the third multiplexor Bypass Bit is generated by comparing the destination address for the instruction in the last entry in the FIFO with the read address of the current instruction. If none of the destination addresses match the read address of the current instruction then all control bits are cleared and the data read from the RAM cells is transferred to the input of the execution pipelines .

At step one or more bypass paths for a lane are enabled or disabled based on the set of control bits and the set of valid bits. In other words the output of the various AND logic gates enable and disable the multiplexors e.g. multiplexors and which enables or disables the bypass paths. At step if any of the bypass paths for a lane are enabled a read access of the register file i.e. RAM cells is disabled. It will be appreciated that utilizing any of the bypass paths makes reading data from the RAM cells redundant.

The system also includes input devices a graphics processor and a display i.e. a conventional CRT cathode ray tube LCD liquid crystal display LED light emitting diode plasma display or the like. User input may be received from the input devices e.g. keyboard mouse touchpad microphone and the like. In one embodiment the graphics processor may include a plurality of shader modules a rasterization module etc. Each of the foregoing modules may even be situated on a single semiconductor platform to form a graphics processing unit GPU .

In the present description a single semiconductor platform may refer to a sole unitary semiconductor based integrated circuit or chip. It should be noted that the term single semiconductor platform may also refer to multi chip modules with increased connectivity which simulate on chip operation and make substantial improvements over utilizing a conventional central processing unit CPU and bus implementation. Of course the various modules may also be situated separately or in various combinations of semiconductor platforms per the desires of the user.

The system may also include a secondary storage . The secondary storage includes for example a hard disk drive and or a removable storage drive representing a floppy disk drive a magnetic tape drive a compact disk drive digital versatile disk DVD drive recording device universal serial bus USB flash memory. The removable storage drive reads from and or writes to a removable storage unit in a well known manner.

Computer programs or computer control logic algorithms may be stored in the main memory and or the secondary storage . Such computer programs when executed enable the system to perform various functions. The memory the storage and or any other storage are possible examples of computer readable media.

In one embodiment the architecture and or functionality of the various previous figures may be implemented in the context of the central processor the graphics processor an integrated circuit not shown that is capable of at least a portion of the capabilities of both the central processor and the graphics processor a chipset i.e. a group of integrated circuits designed to work and sold as a unit for performing related functions etc. and or any other integrated circuit for that matter.

Still yet the architecture and or functionality of the various previous figures may be implemented in the context of a general computer system a circuit board system a game console system dedicated for entertainment purposes an application specific system and or any other desired system. For example the system may take the form of a desktop computer laptop computer server workstation game consoles embedded system and or any other type of logic. Still yet the system may take the form of various other devices including but not limited to a personal digital assistant PDA device a mobile phone device a television etc.

Further while not shown the system may be coupled to a network e.g. a telecommunications network local area network LAN wireless network wide area network WAN such as the Internet peer to peer network cable network or the like for communication purposes.

While various embodiments have been described above it should be understood that they have been presented by way of example only and not limitation. Thus the breadth and scope of a preferred embodiment should not be limited by any of the above described exemplary embodiments but should be defined only in accordance with the following claims and their equivalents.

