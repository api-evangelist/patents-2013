---

title: Recommending improvements to and detecting defects within applications
abstract: In various embodiments, static, dynamic, and behavioral analyzes may be performed on an application. A set of software libraries employed by the application may be determined. A set of device resources employed by the application may be determined. An application fingerprint is generated for the application. The application fingerprint encodes identifiers for the set of software libraries and identifiers for the set of device resources. Improvements can be recommended based upon an analysis of the application fingerprint.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09449042&OS=09449042&RS=09449042
owner: Amazon Technologies, Inc.
number: 09449042
owner_city: Seattle
owner_country: US
publication_date: 20130625
---
An application marketplace may offer a multitude of different applications such as mobile applications. For example the applications may include games email applications social networking applications mapping applications imaging applications music playing applications shopping applications and so on. Various applications offered by various developers may fiercely compete for sales advertising revenue market share etc. Developers are often seeking ways to improve their offerings to broaden the appeal of an application improve sales etc. Some applications may have defects that result in crashes poor rendering performance high resource consumption and or other problems which developers may wish to address to improve the performance of an application in the marketplace.

The present disclosure relates to generating profiles of applications referred to herein as application fingerprinting. An application fingerprint uniquely identifies an application based on for example what application programming interfaces API it uses what software libraries or code fragments it uses what hardware devices it accesses what device resources it employs typical resource consumption patterns and or other characteristics. In some embodiments the application fingerprint may also identify typical user behavior relative to the application. The application fingerprints may have many uses including application search application categorization defect detection and so on. Accordingly in an application marketplace the application fingerprint of many applications that are potentially related to one another in some way can be generated. Additionally recommendations for improvements to application are generated based at least in part upon an analysis of the application fingerprints of applications that are related to one another as well as usage data associated with these applications.

The present disclosure also relates to detecting and correcting defects in applications through the use of profiles of applications referred to herein as application fingerprinting. An application fingerprint uniquely identifies an application based on for example what application programming interfaces API it uses what software libraries it uses what hardware devices it accesses typical resource consumption patterns and or other characteristics. In some embodiments the application fingerprint may also identify typical user behavior relative to the application. The application fingerprints may have many uses including application search application categorization defect detection and so on.

With reference to illustrated is an application fingerprinting scenario . More specifically the application fingerprinting scenario illustrates two applications and for which corresponding application fingerprints and have been generated. The applications are representative of the multitude of applications that may be offered by an application marketplace. In this non limiting example the application corresponds to a music player and the application corresponds to another music player that may have varying and or additional features relative to the application . Each of the applications has its own respective application fingerprint that can function to distinguish one application from another and or to identify similarities between applications . Accordingly in the non limiting example of each of the application fingerprints identifies characteristics relating to device hardware used software libraries or code fragments used and resource consumption. In other examples additional or different characteristics may be represented by the application fingerprints . Here the application fingerprint indicates that the application uses the accelerometer and touchscreen of the device and the software libraries or recognizable code fragments named Graphics Effects 1.3b and LibAudioDecode 2.0. Also the application is associated with high processor and battery usage. The application fingerprint indicates that the application uses a sound device the touchscreen of the device as well as radio and network capabilities of the device. The application fingerprint also indicates that the application uses the software libraries named GraphicsEffects 1.3b and LibAudioDecode 2.0 and SocialConnect 0.1a. The application is associated with medium processor and battery usage.

Accordingly embodiments of the disclosure can generate a recommendation associated with an application that identifies one or more features that may be added to the application to improve the performance of the application with respect to various performance metrics. Such a recommendation can be generated by identifying other applications that may share a common feature and or capability based at least in part upon an analysis of respective application fingerprints of the application and identifying features and or capabilities of the other applications that can be incorporated into the application. In the following discussion a general description of the system and its components is provided followed by a discussion of the operation of the same.

Turning now to shown is a networked environment according to various embodiments. The networked environment includes a computing environment and one or more clients in data communication via a network . The network includes for example the Internet intranets extranets wide area networks WANs local area networks LANs wired networks wireless networks or other suitable networks etc. or any combination of two or more such networks.

The computing environment may comprise for example a server computer or any other system providing computing capability. Alternatively the computing environment may employ a plurality of computing devices that may be arranged for example in one or more server banks or computer banks or other arrangements. Such computing devices may be located in a single installation or may be distributed among many different geographical locations. For example the computing environment may include a plurality of computing devices that together may comprise a cloud computing resource a grid computing resource and or any other distributed computing arrangement. In some cases the computing environment may correspond to an elastic computing resource where the allotted capacity of processing network storage or other computing related resources may vary over time.

Various applications and or other functionality may be executed in the computing environment according to various embodiments. Also various data is stored in a data store that is accessible to the computing environment . The data store may be representative of a plurality of data stores as can be appreciated. The data stored in the data store for example is associated with the operation of the various applications and or functional entities described below.

The components executed on the computing environment for example include a fingerprint generation service a defect detection service a defect correction service a metric collection service a hosted environment an application improvement service an application marketplace system and other applications services processes systems engines or functionality not discussed in detail herein. The fingerprint generation service is executed to generate application fingerprints for applications .

Various techniques relating to application fingerprinting are described in U.S. Patent Application entitled APPLICATION FINGERPRINTING filed Jun. 25 2013 under Ser. No. 13 926 607 U.S. Patent Application entitled APPLICATION MONETIZATION BASED ON APPLICATION AND LIFESTYLE FINGERPRINTING filed Jun. 25 2013 under Ser. No. 13 926 656 U.S. Patent Application entitled DEVELOPING VERSIONS OF APPLICATIONS BASED ON APPLICATION FINGERPRINTING filed Jun. 25 2013 under Ser. No. 13 926 683 U.S. Patent Application entitled APPLICATION RECOMMENDATIONS BASED ON APPLICATION AND LIFESTYLE FINGERPRINTING filed Jun. 25 2013 under Ser. No. 13 926 574 U.S. Patent Application entitled IDENTIFYING RELATIONSHIPS BETWEEN APPLICATIONS filed Jun. 25 2013 under Ser. No. 13 926 215 and U.S. Patent Application entitled ANALYZING SECURITY OF APPLICATIONS filed Jun. 25 2013 under Ser. No. 13 926 211 all of which are incorporated herein by reference in their entirety.

The defect detection service is executed to detect defects in applications . Such defects may correspond to defects within the code of the application itself or defects within software libraries that are included by or otherwise used by the application . Such defects may include memory leaks infinite loops malware viruses and or other misuses of client resources or security vulnerabilities.

In one example the defect detection service may detect defects associated with an application based at least in part on external reports of the defects. In another example the defect detection service may detect defects as part of the application fingerprint generation process namely during the course of static analysis dynamic analysis or behavior analysis. The defect detection service may determine that multiple applications include the defect based at least in part on the application fingerprints where applications that are similar to a known defective application may be ascertained. The defect detection service may send a notification of the defect to a party associated with the application and or initiate an automated correction of the defect via the defect correction service .

The defect correction service is employed to correct defects that have been identified for an application . To this end the defect correction service may patch code associated with the application to resolve defective code within the application . In some cases the defect correction service may replace a defective software library employed by the application with an alternative software library that does not include the defect.

The metric collection service is executed to obtain various metrics as for use by the fingerprint generation service in generating application fingerprints . Such metrics may include resource consumption metrics usage data and or other types of metrics. Additionally the metric collection service can also obtain usage data associated with a particular application by users of the application marketplace who have installed the application . Such usage data can include crash data or information related to the unexpected termination of an application . Usage data can also comprise information about various aspects features levels of an application that users of the application marketplace utilize during usage of the application . For example the usage data can include usage time of a user within different levels of a game application the amount of time a user spends in a particular section of an application relative to other applications or an amount of network traffic originating from the application. Usage data can also include an amount of usage time within a particular difficulty setting of an application various maps or worlds of a game application or any other usage metric associated with an application or any other usage metric associated with an application .

The hosted environment is configured to execute an application instance for use in dynamic analysis and resource consumption profiling by the fingerprint generation service . To this end the hosted environment may comprise an emulator or other virtualized environment for executing the application instance .

In one embodiment an application can be instrumented to report usage data to the metric collection service . The usage data and or resource consumption metrics can be stored in the data store and associated with a user account of a user. In other embodiments the metric collection service is configured to store the usage data and or resource consumption metrics on an aggregate non user identifiable basis. In either scenario the stored data can be analyzed with respect to various attributes of users such as demographic categories.

The application marketplace system is executed to provide functionality relating to an application marketplace in which a multitude of applications may be submitted by developers and made available for purchase and or download by users. The application marketplace system may include functionality relating to electronic commerce e.g. shopping cart ordering and payment systems. The application marketplace system may support searching and categorization functionality so that users may easily locate applications that are of interest. The application marketplace system may include functionality relating to verification of compatibility of applications with various clients .

The data stored in the data store includes for example applications application fingerprints identified code fragments identified device resources resource consumption profiles defect detection data defect correction data behavioral usage profiles user lifestyle fingerprints data relating to an application marketplace and potentially other data. The applications correspond to those applications that have been submitted by developers and or others for example for inclusion in the application marketplace . The applications may correspond to game applications email applications social network applications mapping applications and or any other type of application . In one embodiment the applications correspond to mobile applications for use on mobile devices such as for example smartphones tablets electronic book readers and or other devices.

The identified code fragments correspond to various code libraries and application programming interface API calls that are used by various applications . Unlike custom code that is specific to an application the identified code fragments include functionality that may be employed and reused by many different applications in either an exact or substantially similar form. As an example a code fragment may correspond to a software library. As another example a code fragment may correspond to open source reference code for performing some function. Each of the identified code fragments may have a corresponding version and multiple different versions of the software library may be employed by the applications . Unique identifiers may be associated with each identified code fragment and or various API calls within each identified code fragment . Some of the identified code fragments may be binary compatible alternatives to others of the identified code fragments . Some of the identified code fragments may be non binary compatible alternatives to others of the identified code fragments . Various data may be stored indicating how the various code fragments are employed e.g. to render specific user interface elements to obtain a specific user gesture and so on.

The identified device resources correspond to the various hardware and or software requirements of the applications . For example various applications may require or request access to hardware devices on clients such as accelerometers touchscreens having a certain resolution size GPS devices network devices storage devices and so on. Additionally various applications may access application resources on clients . Such application resources may include sound files graphical assets graphical textures images buttons user interface layouts and so on. Such application resources may include data items on clients e.g. contact lists text messages browsing history etc. Identifiers for such application resources may be included in a generated application fingerprint . It is noted that the identified device resources may include static resources and runtime resources.

The resource consumption profiles correspond to profiles of resource consumption for applications that are generated from resource consumption metrics collected by the metric collection service . The resource consumption profiles may indicate processor usage memory usage battery usage network usage and or other resources that are consumed. The resource consumption profiles may indicate maximum consumption average consumption median consumption minimum consumption and or other statistics for a particular application .

The defect detection data may include various data that facilitates recognition of defects in applications . Such data may include code patterns signatures hashes and so on that indicate defects to facilitate defect recognition via static analysis. As a non limiting example the defect detection data may include a code pattern that is associated with buffer overflow vulnerabilities.

The defect detection data may specify resource consumption profiles that may indicate defects via dynamic analysis. As a non limiting example the defect detection data may define a threshold for processor usage that may indicate an infinite loop or other misuse of processor resources. As another non limiting example the defect detection data may define a threshold for battery usage that may indicate a misuse of hardware resources. The defect detection data may record associations between applications and or portions of applications with defects. The defect detection data may also record associations between identified code fragments and or identified device resources and defects.

The defect correction data facilitates correction of defects by the defect correction service . To this end the defect correction data may specify suitable replacement software libraries for defective libraries code patches to correct defects in object code code patches to correct defects in source code fixes to correct issues with metadata and so on. In one embodiment portions of the defect correction data may be ascertained automatically from similar applications that do not include the defect. Such similar applications may be determined according to the application fingerprints . In another embodiment external data may be obtained to populate the defect correction data . In some cases the defect correction data may be manually configured.

The behavioral usage profiles correspond to profiles of behavioral usage for applications that are generated from behavioral usage metrics collected by the metric collection service . The behavioral usage profiles may indicate average duration that the application instances execute times of day and or locations where the application instances are executed privacy related behaviors of the application instances e.g. whether contact lists are accessed whether browsing history is accessed and so forth circumstances under which the application instances crash e.g. types of clients types of wireless carriers etc. user demographics and so on. The behavioral usage profiles may incorporate synchronization history from a synchronization service. Metrics related to synchronization may be obtained from the client and or from the synchronization service.

The user lifestyle fingerprints include data profiling various characteristics of particular users of the applications based for example on data that the particular users have elected to share. The user lifestyle fingerprints may record time periods e.g. hours of the day days of the week etc. during which the particular user typically uses certain types of applications . The user lifestyle fingerprints may also record locations where the user typically users certain types of applications . As a non limiting example a user may employ a certain type of application while at the office weekdays from 8 a.m. to 5 p.m. another type of application while commuting weekdays from 7 30 a.m. to 8 a.m. and 5 p.m. to 5 30 p.m. and yet another type of application while at home on weekdays from 5 30 p.m. to 8 p.m. and on weekends. To this end the user lifestyle fingerprints may be developed based at least in part on the behavioral usage metrics received from clients associated with the particular users.

Beyond merely the types of applications that are preferred the user lifestyle fingerprints may also record specific components or libraries of applications that are frequently used. Such a determination may be made through comparison with the application fingerprints . For example a user may prefer applications that use social networking functionality global positioning system GPS functionality or a flashlight functionality.

Additionally the user lifestyle fingerprints may also profile user specific purchasing behavior via the application marketplace system . For example a user lifestyle fingerprint for a given user may indicate whether the user is a frequent purchaser regardless of cost a reluctant cost conscious purchaser or a frequent purchaser from within an application . This information may be employed by the application marketplace system to target specific versions of applications e.g. low cost versions high cost versions freemium versions etc. and to market effectively to specific categories of users.

Various techniques relating to collecting behavioral usage metrics from applications are described in U.S. patent application Ser. No. 13 215 972 entitled COLLECTING APPLICATION USAGE METRICS and filed on Aug. 23 2011 which is incorporated herein by reference in its entirety. Various techniques relating to profiling user behavior are described in U.S. patent application Ser. No. 13 555 724 entitled BEHAVIOR BASED IDENTITY SYSTEM and filed on Jul. 23 2012 which is incorporated herein by reference in its entirety.

The data associated with the application marketplace includes for example download information categories application usage data and or other data. The download information indicates the popularity either in terms of absolute number of downloads or in terms of relative popularity of the applications offered by the application marketplace . The download information can also identify users either individually by a user account and or on an aggregate basis according to demographic category that have downloaded a particular application . The categories correspond to groupings of applications that may indicate similar applications and may be employed by users to more easily navigate the offerings of the application marketplace . Non limiting examples of categories may include social networking applications mapping applications movie information applications shopping applications music recognition applications and so on.

The client is representative of a plurality of client devices that may be coupled to the network . The client may comprise for example a processor based system such as a computer system. Such a computer system may be embodied in the form of a desktop computer a laptop computer personal digital assistants cellular telephones smartphones set top boxes music players web pads tablet computer systems game consoles electronic book readers or other devices with like capability. The client may include a display comprising for example one or more devices such as liquid crystal display LCD displays gas plasma based flat panel displays organic light emitting diode OLED displays LCD projectors or other types of display devices etc.

The client may be configured to execute various applications such as an application instance a metric generation service and or other applications. The application instance corresponds to an instance of an application that has been downloaded to the client from the application marketplace system . The application instance may correspond to actual use by an end user or test use on a test client . The metric generation service is configured to monitor the application instance and report data that the user of the client has elected to share with the metric collection service . Such data may include resource consumption metrics behavioral usage metrics and or other data. The client may be configured to execute applications beyond the application instance and the metric generation service such as for example browsers mobile applications email applications social networking applications and or other applications.

Next a general description of the operation of the various components of the networked environment is provided. To begin an application is received by the computing environment . The fingerprint generation service then begins processing the application to generate an application fingerprint . Such initial processing may comprise a static analysis which may compare the object code and or the source code against identified software libraries or recognizable code fragments in either an exact or substantially similar form. As an example a code fragment may correspond to a software library. As another example a code fragment may correspond to open source reference code for performing some function. The fingerprint generation service may also perform a dynamic analysis of the application which may include executing an application instance for the application in a hosted environment and determining which code paths are taken by the object code .

The application fingerprint may indicate which of the identified software libraries code fragments and or identified hardware resources are actually used by the application instance . Resource consumption metrics and or usage data may be generated by a metric generation service executed in a client . The resource consumption metrics and or usage data then may be reported back from the client to the metric collection service by way of the network which can analyzed and incorporated into an application fingerprint as well as application usage data . An application fingerprint can also take into account resources used by an application such as include sound files graphical assets graphical textures images buttons user interface layouts and so on. Such application resources may include data items on clients e.g. contact lists text messages browsing history etc. Identifiers for such application resources may be included in a generated application fingerprint . It is noted that the identified device resources may include static resources and runtime resources.

Accordingly an application fingerprint that has been generated may be used in many different ways. As one example the application improvement service can analyze an application fingerprint as well as application usage data to generate recommendations regarding improvements that can be made to an application that is distributed via the application marketplace . Recommendations can be generated based upon an analysis of other applications that are also distributed via the application marketplace as well as their respective application fingerprints .

In one embodiment the application improvement service obtains a particular application for the purposes of generating a recommendation regarding improvements that can be made to the application . The application improvement service can identify features employed by the application based upon an analysis of the application fingerprint of the application . As one example the application improvement service can identify another application based upon an analysis of its respective application fingerprint that shares a common feature relative to the application . The application improvement service also identify from among other applications that share a feature with the application those that have features that are not common to the application . In other words the application improvement service identifies other applications that are similar to the application .

For example referring back to the example depicted in the application improvement service can determine based upon an analysis of the application fingerprint that the application possesses at least one common feature relative to the application . In the depicted example the application and both employ a common software library or code fragment which may be an indication that they share a common feature. Both applications and also employ a common device capability which can also indicate a common feature. As another example both applications and may result in a similar resource consumption profile with respect to one or more device resources which can similarly indicate a common feature between the applications and . Additionally both applications and may be categorized in the same category within an application marketplace which may be an indication that the applications and share a common feature.

In the example of application incorporates social networking features that are not employed by the application or a feature that is not common to both applications. Accordingly the application improvement service can also determine whether the application having a feature that incorporates a feature not employed by the application performs better than the application with respect to one or more performance metrics. Performance metrics may be related to download usage profitability revenue ratings popularity controversy speed utilization difficulty resource consumption and the like. For example the application improvement service may determine that application is more popular within the application marketplace than application . As another example the application improvement service may determine that application garners more usage than application according to application usage data collected by the metric collection service for both applications. As yet another example the application may generate more revenue per user or total revenue e.g. advertising revenue application sales etc. than the application . Another example of a performance metric is usage time of an application . For example if another application is associated with a higher level of usage time by users such a scenario can be deemed as more desirable than less usage time.

Accordingly the application improvement service can generate a recommendation that can be transmitted to a developer of the application to suggest that the application be augmented to incorporate a feature that is present within application that is identified from the analysis of their respective application fingerprints and . In the example shown in the application improvement service can recommend that the application be augmented to incorporate social networking features based upon the use of the SocialConnect 0.1a software library by the application and that is not employed by the application . Additionally the application improvement service can also recommend that the application be augmented to incorporate content streaming or networking capabilities based upon the use of the radio and network capabilities by the application that is not employed by the application . In these scenarios the application improvement service can make a determination as to what feature is associated with a particular software library or code fragment based upon the name of the software library code fragment or device capability. In other scenarios the application improvement service can make such a determination based upon a user curated source that associates the use of one or more software library or code fragment device capability or any combination thereof to an application feature.

As another example the application improvement service can generate a recommendation for an improvement to the application based on aspects of application that can be determined based upon an analysis of its respective application fingerprint . For example the application improvement service can determine an average median and or mean frame rate of content rendered by the application based upon usage data obtained from clients executing the application . If the frame rate of content rendered by the application is higher than that of the application the application improvement service can generate a recommendation that the application improve its frame rate.

As yet another example the application improvement service can determine a metric associated with user perceivable lag of an application based upon usage data obtained from clients executing the application . If the user perceivable lab metric is better than that of the application the application improvement service can generate a recommendation that the application improve its user perceivable lag metric.

As another example the application improvement service can also identify crash data within usage data obtained from clients executing the application . The application improvement service can also analyze a code fragment and or device capability that causes a threshold percentage of crashes from the crash data. If a related application does not exhibit similar crash behavior and employs a different but analogous software library or code fragment e.g. a different version an alternative library with a similar name an alternative library providing an analogous function the application improvement service can generate a recommendation that the application employ the different but analogous software library or code fragment. In some embodiments the application improvement service can simply identify the software library or code fragment associated with the threshold percentage of crashes and recommend that the application employ any other software library or code fragment.

Additionally because an initial user experience is often important for improving user engagement sales downloads etc. the application improvement service can determine from application usage data whether an application crashes upon initial execution in more than a threshold percentage of cases. If so then the application improvement service can identify another application that shares a common feature but that does not crash upon initial execution in more than a threshold percentage of cases and generate a recommendation that the application employ software libraries and or features associated with the other application.

When generating a recommendation for improvements that can be made to an application the application improvement service can also determine whether a related application is associated with a performance metric in which the related application performs better than the application . The application improvement service can also determine whether a specific feature of the other application can be attributable to the other application s better performance with respect to the performance metric and generate a recommendation for the application that includes the specific feature. For example if the other application performs better than the application with respect to the application according to a usage time performance metric the application improvement service can identify a feature that is associated with a high degree of usage time within the other application . The usage time performance metric can relate to an average mean and or median usage time and or any other metric with respect to the usage time of an application by a population of users.

If the feature associated with a high degree of usage time in the other application is not present in the application the application improvement service can generate a recommendation that recommends the feature as an improvement. The application improvement service can perform a similar analysis with respect to other performance metrics other than usage time in order to generate recommendations for improvements or additional features that can be added to an application .

Referring next to shown is a flowchart that provides one example of the operation of a portion of the fingerprint generation service according to various embodiments. It is understood that the flowchart of provides merely an example of the many different types of functional arrangements that may be employed to implement the operation of the portion of the application improvement service as described herein. As an alternative the flowchart of may be viewed as depicting an example of steps of a method implemented in the computing environment according to one or more embodiments.

Beginning with box the application improvement service receives an application . For example the application may be uploaded or downloaded from a developer to the computing environment . In box the application improvement service can obtain an application fingerprint corresponding to the application . In box the application improvement service can identify other applications that are related to the application . For example the application improvement service can identify other applications that share a common feature with the application or that are categorized within the same category in an application marketplace . In box the application improvement service can determine whether a performance with respect to a performance metric of one of the other application exceeds performance with respect to the performance metric of the application . If the performance of one of the other applications does not exceed that of the application the process can proceed to box .

In box if the performance metric of the other application exceeds that of the application the application improvement service can identify a feature of the other application that is not common to the application . In other words the application improvement service can identify features from the other application that are not present in the application based upon an analysis of their respective application fingerprints and or application usage data . In box the application improvement service determines whether there are additional applications with a common feature with the application and progresses to similarly identify features within each of the additional applications that are not present in the application .

At box the application improvement service can determine whether any and or each of the features present within the other applications that are not common to the application are attributable to the better performance with respect to a performance metric of the other applications . If so then at box the application improvement service generates a recommendation that includes the features that are attributable to an improved performance with respect to the performance metric. Thereafter the process shown in proceeds to completion.

Turning now to shown is a flowchart that provides one example of the operation of a portion of the defect detection service according to various embodiments. It is understood that the flowchart of provides merely an example of the many different types of functional arrangements that may be employed to implement the operation of the portion of the defect detection service as described herein. As an alternative the flowchart of may be viewed as depicting an example of steps of a method implemented in the computing environment according to one or more embodiments.

Beginning with box the defect detection service determines an application defect based at least in part on the defect detection data . In one embodiment the defect detection service may receive external data indicating that a particular application and or identified code fragment includes a defect. In another embodiment the defect detection service may receive information based on a static analysis performed by the static analysis service that an application or identified code fragment includes a defect. In another embodiment the defect detection service may receive information based on a dynamic analysis performed by the dynamic analysis service that an application or identified code fragment includes a defect. In another embodiment the defect detection service may receive information based at least in part on usage data such as resource consumption metrics based on actual use of the application at clients .

Such analyses may be performed as part of generating the application fingerprint for the application . In one embodiment where multiple applications are determined to include a defect the application fingerprints of the defective applications may be analyzed to determine identified code fragments or other functionality in common that may be the source of the defect. The source e.g. specific identified code fragment code pattern etc. may then be associated with the defect in the defect detection data .

It is noted that defects may occur in applications that are device specific. For example an application may execute normally on one particular client having one configuration but may crash or otherwise present a defect on a different client having a different configuration. Such device specific problems may still be regarded as defects in various embodiments. Some defects may be associated with the use of specific application resources such as graphical assets media files and so on. For example a specific media file may be created in such a way that causes a defect to be expressed by an application .

In box the defect detection service determines one or more applications that include the defect based at least in part on the application fingerprints of the applications . For example where a particular identified code fragment includes the defect the defect detection service may perform a search upon the application fingerprints to determine which applications also use the identified code fragment . As another example where a particular identified device resource e.g. an application resource is associated with the defect the defect detection service may perform a search upon the application fingerprints to determine which applications also use the identified device resource . Alternatively where a particular application includes a defect the defect detection service may determine applications that have similar resource consumption profiles or other characteristics similar to the particular application based at least in part on the corresponding application fingerprints . Such applications may also have the same defect as the particular application . In response to detecting the defect the defect detection service may implement various actions as will be described. In some cases the application may be submitted for testing to confirm and or isolate the defect.

In box the defect detection service may send a notification of the detected defect to a party associated with the application determined to include the defect. As a non limiting example the party may correspond to a developer of the application . Alternatively the party may correspond to a developer of a particular identified code fragment that is defective. The notification may take the form of a notification in a web page an email message a text message a phone call or other form of notification.

In box the defect detection service determines whether the defect of the application can be automatically corrected via a modification to the application . If the defect cannot be automatically corrected the defect detection service proceeds to box and configures the application marketplace system to refrain from offering the application in the application marketplace or to flag the application as including a potential defect by associating the application with a defect indicator. Thereafter the portion of the defect detection service ends.

If instead the defect can be automatically corrected the defect detection service may continue from box to box and determine whether approval to modify the application has been received from the notified party. If approval is necessary and has not been received the defect detection service moves from box to box and configures the application marketplace system to refrain from offering the application in the application marketplace or to flag the application as including a potential defect. Thereafter the portion of the defect detection service ends.

If instead approval to modify the application is received or if approval is not necessary the defect detection service transitions from box to box and modifies the application to correct the defect. To this end the defect detection service may invoke the defect correction service to perform the defect correction. The defect correction service may replace a code fragment with an alternative code fragment replace a defective version of a code fragment with a non defective version of the code fragment which may be an updated version or an older version as the case may be modify object code of the application modify source code and recompile the application modify metadata of the application or perform other modification tasks.

Fixes such as alternative code fragments may be determined based at least in part on application fingerprints . For example where a global positioning service GPS library is defective the defect correction service may search for applications using GPS functionality and then determine different libraries or updated versions of the defective library that do not include the defect. In one embodiment perhaps either in conjunction with correcting the defect or not correcting the defect the defect correction service may instrument the application to include logging functionality relative to the detected defect. For example the application may be instrumented to collect information relative to a particular call such as a system call method call library call procedure call or other call. Information collected via such logging functionality may be employed to manually or automatically correct the defect.

In box the defect detection service configures the application marketplace system to offer or continue offering the application in the application marketplace. Where an application previously had been flagged as including the defect such a flag may be removed. In some cases customers or potential customers may be notified of the corrected defect and availability of the updated version of the application . Thereafter the portion of the defect detection service ends.

With reference to shown is a schematic block diagram of the computing environment according to an embodiment of the present disclosure. The computing environment includes one or more computing devices . Each computing device includes at least one processor circuit for example having a processor and a memory both of which are coupled to a local interface . To this end each computing device may comprise for example at least one server computer or like device. The local interface may comprise for example a data bus with an accompanying address control bus or other bus structure as can be appreciated.

Stored in the memory are both data and several components that are executable by the processor . In particular stored in the memory and executable by the processor are the fingerprint generation service the defect detection service the defect correction service the metric collection service the hosted environment application improvement service the application marketplace system and potentially other applications. Also stored in the memory may be a data store and other data. In addition an operating system may be stored in the memory and executable by the processor .

It is understood that there may be other applications that are stored in the memory and are executable by the processor as can be appreciated. Where any component discussed herein is implemented in the form of software any one of a number of programming languages may be employed such as for example C C C Objective C Java JavaScript Perl PHP Visual Basic Python Ruby Flash or other programming languages.

A number of software components are stored in the memory and are executable by the processor . In this respect the term executable means a program file that is in a form that can ultimately be run by the processor . Examples of executable programs may be for example a compiled program that can be translated into machine code in a format that can be loaded into a random access portion of the memory and run by the processor source code that may be expressed in proper format such as object code that is capable of being loaded into a random access portion of the memory and executed by the processor or source code that may be interpreted by another executable program to generate instructions in a random access portion of the memory to be executed by the processor etc. An executable program may be stored in any portion or component of the memory including for example random access memory RAM read only memory ROM hard drive solid state drive USB flash drive memory card optical disc such as compact disc CD or digital versatile disc DVD floppy disk magnetic tape or other memory components.

The memory is defined herein as including both volatile and nonvolatile memory and data storage components. Volatile components are those that do not retain data values upon loss of power. Nonvolatile components are those that retain data upon a loss of power. Thus the memory may comprise for example random access memory RAM read only memory ROM hard disk drives solid state drives USB flash drives memory cards accessed via a memory card reader floppy disks accessed via an associated floppy disk drive optical discs accessed via an optical disc drive magnetic tapes accessed via an appropriate tape drive and or other memory components or a combination of any two or more of these memory components. In addition the RAM may comprise for example static random access memory SRAM dynamic random access memory DRAM or magnetic random access memory MRAM and other such devices. The ROM may comprise for example a programmable read only memory PROM an erasable programmable read only memory EPROM an electrically erasable programmable read only memory EEPROM or other like memory device.

Also the processor may represent multiple processors and or multiple processor cores and the memory may represent multiple memories that operate in parallel processing circuits respectively. In such a case the local interface may be an appropriate network that facilitates communication between any two of the multiple processors between any processor and any of the memories or between any two of the memories etc. The local interface may comprise additional systems designed to coordinate this communication including for example performing load balancing. The processor may be of electrical or of some other available construction.

Although the fingerprint generation service the defect detection service the defect correction service the metric collection service the hosted environment application improvement service the application marketplace system and other various systems described herein may be embodied in software or code executed by general purpose hardware as discussed above as an alternative the same may also be embodied in dedicated hardware or a combination of software general purpose hardware and dedicated hardware. If embodied in dedicated hardware each can be implemented as a circuit or state machine that employs any one of or a combination of a number of technologies. These technologies may include but are not limited to discrete logic circuits having logic gates for implementing various logic functions upon an application of one or more data signals application specific integrated circuits ASICs having appropriate logic gates field programmable gate arrays FPGAs or other components etc. Such technologies are generally well known by those skilled in the art and consequently are not described in detail herein.

The flowcharts of show the functionality and operation of an implementation of portions of the fingerprint generation service and the defect detection service . If embodied in software each block may represent a module segment or portion of code that comprises program instructions to implement the specified logical function s . The program instructions may be embodied in the form of source code that comprises human readable statements written in a programming language or machine code that comprises numerical instructions recognizable by a suitable execution system such as a processor in a computer system or other system. The machine code may be converted from the source code etc. If embodied in hardware each block may represent a circuit or a number of interconnected circuits to implement the specified logical function s .

Although the flowcharts of show a specific order of execution it is understood that the order of execution may differ from that which is depicted. For example the order of execution of two or more blocks may be scrambled relative to the order shown. Also two or more blocks shown in succession in may be executed concurrently or with partial concurrence. Further in some embodiments one or more of the blocks shown in may be skipped or omitted. In addition any number of counters state variables warning semaphores or messages might be added to the logical flow described herein for purposes of enhanced utility accounting performance measurement or providing troubleshooting aids etc. It is understood that all such variations are within the scope of the present disclosure.

Also any logic or application described herein including the fingerprint generation service the defect detection service the defect correction service the metric collection service the hosted environment application improvement service and the application marketplace system that comprises software or code can be embodied in any non transitory computer readable medium for use by or in connection with an instruction execution system such as for example a processor in a computer system or other system. In this sense the logic may comprise for example statements including instructions and declarations that can be fetched from the computer readable medium and executed by the instruction execution system. In the context of the present disclosure a computer readable medium can be any medium that can contain store or maintain the logic or application described herein for use by or in connection with the instruction execution system.

The computer readable medium can comprise any one of many physical media such as for example magnetic optical or semiconductor media. More specific examples of a suitable computer readable medium would include but are not limited to magnetic tapes magnetic floppy diskettes magnetic hard drives memory cards solid state drives USB flash drives or optical discs. Also the computer readable medium may be a random access memory RAM including for example static random access memory SRAM and dynamic random access memory DRAM or magnetic random access memory MRAM . In addition the computer readable medium may be a read only memory ROM a programmable read only memory PROM an erasable programmable read only memory EPROM an electrically erasable programmable read only memory EEPROM or other type of memory device.

It should be emphasized that the above described embodiments of the present disclosure are merely possible examples of implementations set forth for a clear understanding of the principles of the disclosure. Many variations and modifications may be made to the above described embodiment s without departing substantially from the spirit and principles of the disclosure. All such modifications and variations are intended to be included herein within the scope of this disclosure and protected by the following claims.

