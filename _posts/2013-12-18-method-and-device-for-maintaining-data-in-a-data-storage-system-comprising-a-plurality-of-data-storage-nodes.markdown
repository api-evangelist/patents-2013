---

title: Method and device for maintaining data in a data storage system comprising a plurality of data storage nodes
abstract: A method and device for maintaining data in a data storage system, comprising a plurality of data storage nodes, the method being employed in a storage node in the data storage system and comprising: monitoring and detecting, conditions in the data storage system that imply the need for replication of data between the nodes in the data storage system; initiating replication processes in case such a condition is detected, wherein the replication processes include sending multicast and unicast requests to other storage nodes, said requests including priority flags, receiving multicast and unicast requests from other storage nodes, wherein the received requests include priority flags, ordering the received requests in different queues depending on their priority flags, and dealing with requests in higher priority queues with higher frequency than requests in lower priority queues.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08843710&OS=08843710&RS=08843710
owner: Compuverde AB
number: 08843710
owner_city: 
owner_country: SE
publication_date: 20131218
---
This application is a continuation of U.S. patent application Ser. No. 13 224 393 filed Sep. 2 2011 the contents of which are hereby incorporated by reference herein.

This application includes subject matter that may be related to subject matter included in the following applications U.S. patent application Ser. No. 13 224 404 entitled Method And Device For Writing Data To A Data Storage System Comprising A Plurality Of Data Storage Nodes filed Sep. 2 2011 U.S. patent application Ser. No. 13 224 415 entitled Method For Data Maintenance filed Sep. 2 2011 U.S. patent application Ser. No. 13 224 424 entitled Method For Handling Reguests In A Storage System And A Storage Node For A Storage System filed Sep. 2 2011 U.S. patent application Ser. No. 13 224 433 entitled Method For Data Retrieval From A Distributed Data Storage System filed Sep. 2 2011 and U.S. patent application Ser. No. 13 224 446 entitled Method For Updating Data In A Distributed Data Storage System filed Sep. 2 2011.

The present disclosure relates to a method and device for maintaining data in a data storage system comprising a plurality of data storage nodes the method being employed in a storage node in the data storage system.

Such a method is disclosed e.g. in U.S. Patent Publication 2005 0246393 A1. This method is disclosed for a system that uses a plurality of storage centres at geographically disparate locations. Distributed object storage managers are included to maintain information regarding stored data.

One problem associated with such a system is how to accomplish simple and yet robust and reliable maintenance of data.

Therefore the present disclosure relates to a method for maintaining data in a data storage system comprising a plurality of data storage nodes the method being employed in a storage node in the data storage system and comprising monitoring and detecting conditions in the data storage system that imply the need for replication of data between the nodes in the data storage system initiating replication processes in case such a condition is detected wherein the replication processes include sending multicast and unicast requests to other storage nodes said requests including priority flags receiving multicast and unicast requests from other storage nodes wherein the received requests include priority flags ordering the received requests in different queues depending on their priority flags and dealing with requests in higher priority queues with higher frequency than requests in lower priority queues. This ensures that requests in the maintenance process with relatively high priority are dealt with first.

Queues with higher priorities may have a longer length than queues with lower priorities and when a queue becomes full and a further request relating to that queue is received from an originating node a busy message may be sent back to that originating node. The received request may then be discarded.

Further a device for maintaining data in a data storage system is considered comprising a plurality of data storage nodes the device being included in a storage node in the data storage system and comprising a monitoring and detecting unit monitoring and detecting conditions in the data storage system that imply the need for replication of data between the nodes in the data storage system a replication unit initiating replication processes in case such a condition is detected wherein the replication processes include sending multicast and unicast requests to other storage nodes said requests including priority flags a receiver receiving multicast and unicast requests from other storage nodes wherein the received requests include priority flags a queue unit ordering the received requests in different queues depending on their priority flags and a processor dealing with requests in higher priority queues with higher frequency than requests in lower priority queues.

The present disclosure is related to a distributed data storage system comprising a plurality of storage nodes. The structure of the system and the context in which it is used is outlined in .

A user computer may access via the Internet an application running on a server . The user context as illustrated here may therefore be a regular client server configuration which is well known per se. However it should be noted that the data storage system to be disclosed may be useful also in other configurations.

In the illustrated case two applications run on the server . Of course however this number of applications may be different. Each application has an API Application Programming Interface which provides an interface in relation to the distributed data storage system and supports requests typically write and read requests from the applications running on the server. From an application s point of view reading or writing information from to the data storage system need not appear different from using any other type of storage solution for instance a file server or simply a hard drive.

Each API may communicate with storage nodes in the data storage system and the storage nodes may communicate with each other. These communications may be based on TCP Transmission Control Protocol and UDP User Datagram Protocol . These concepts are well known to the skilled person and are not explained further.

It should be noted that different APIs on the same server may access different sets of storage nodes . It should further be noted that there may exist more than one server which accesses each storage node . This however does not to any greater extent affect the way in which the storage nodes operate as will be described later.

The components of the distributed data storage system are the storage nodes and the APIs in the server which access the storage nodes . The present disclosure therefore relates to methods carried out in the server and in the storage nodes . Those methods will primarily be embodied as combinations of software and hardware implementations which are implemented on the server and the storage nodes respectively and are together determining for the operation and the properties of the overall distributed data storage system.

The storage node may typically be embodied by a file server which is provided with a number of functional blocks. The storage node may thus comprise a storage medium which typically comprises of a number of hard drives optionally configured as a RAID Redundant Array of Independent Disk system. Other types of storage media are however conceivable as well.

The storage node may further include a directory which comprises lists of data entity storage node relations as a host list as will be discussed later.

In addition to the host list each storage node may further contain a node list including the IP addresses of all storage nodes in its set or group of storage nodes. The number of storage nodes in a group may vary from a few to hundreds or thousands of storage nodes. The node list may further have a version number.

Additionally the storage node may include a replication block and a cluster monitor block . The replication block may include a storage node API and may be configured to execute functions for identifying the need for and carrying out a replication process as will be described in detail later. The storage node API of the replication block may contain code that to a great extent corresponds to the code of the server s storage node API as the replication process comprises actions that correspond to a great extent to the actions carried out by the server during reading and writing operations to be described. For instance the writing operation carried out during replication may correspond to a great extent to the writing operation carried out by the server . The cluster monitor block may be configured to carry out monitoring of other storage nodes in the data storage system as will be described in more detail later.

The storage nodes of the distributed data storage system can be considered to exist in the same hierarchical level. There is no need to appoint any master storage node that is responsible for maintaining a directory of stored data entities and monitoring data consistency etc. Instead all storage nodes can be considered equal and may at times carry out data management operations vis vis other storage nodes in the system. This equality ensures that the system is robust. In case of a storage node malfunction other nodes in the system will cover up the malfunctioning node and ensure reliable data storage.

The operation of the system will be described in the following order reading of data writing of data and data maintenance. Even though these methods work very well together it should be noted that they may in principle also be carried out independently of each other. That is for instance the data reading method may provide excellent properties even if the data writing method of the present disclosure is not used and vice versa.

The reading method may be described with reference to and is a flowchart illustrating an example method.

The reading as well as other functions in the system may utilise multicast communication to communicate simultaneously with a plurality of storage nodes. By a multicast or IP multicast is here meant a point to multipoint communication which may be accomplished by sending a message to an IP address which is reserved for multicast applications.

For example a message typically a request is sent to such an IP address e.g. 244.0.0.1 and a number of recipient servers are registered as subscribers to that IP address. Each of the recipient servers has its own IP address. When a switch in the network receives the message directed to 244.0.0.1 the switch forwards the message to the IP addresses of each server registered as a subscriber.

In principle a single server may be registered as a subscriber to a multicast address in which case a point to point communication is achieved. However in the context of this disclosure such a communication may nevertheless be considered a multicast communication since a multicast scheme is employed.

With reference to and the method for retrieving data from a data storage system may comprise the sending of a multicast query to a plurality of storage nodes . In the illustrated case there are five storage nodes each having an IP Internet Protocol address 192.168.1.1 192.168.1.2 etc. The number of storage nodes is needless to say just an example. The query contains a data identifier 2B9B4A97 76E5 499E A21A6D7932DD7927 which may for instance be a Universally Unique Identifier UUID or other identification.

The storage nodes scan themselves for data corresponding to the identifier. If such data is found a storage node sends a response which is received by the server cf. . As illustrated the response may optionally contain further information in addition to an indication that the storage node has a copy of the relevant data. Specifically the response may contain information from the storage node directory about other storage nodes containing the data information regarding which version of the data is contained in the storage node and information regarding which load the storage node at present is exposed to.

Based on the responses the server selects one or more storage nodes from which data is to be retrieved and may send a unicast request for data to that those storage nodes cf. .

In response to the request for data the storage node nodes may send the relevant data by unicast to the server which receives the data. In the illustrated case a single storage node is selected. While this is sufficient it is possible to select more than one storage node in order to receive two sets of data which makes a consistency check possible. If the transfer of data fails the server may select another storage node for retrieval.

The selection of storage nodes may be based on an algorithm that take several factors into account in order to achieve a good overall system performance. Typically the storage node having the latest data version and the lowest load will be selected although other concepts are fully conceivable.

Optionally the operation may be concluded by server sending a list to all storage nodes involved indicating which nodes contains the data and with which version. Based on this information the storage nodes may themselves maintain the data properly by the replication process to be described.

With reference to and the method may comprise a server sending a multicast storage query to a plurality of storage nodes. The storage query may comprise a data identifier and includes a request to the receiving storage nodes can asking the storage nodes if they can store the file. Optionally the storage nodes may check with their internal directories whether they already have a file with this name and may notify the server in the unlikely event that this is the case such that the server may rename the file.

In any case at least one or a subset of the storage nodes may provide responses by unicast transmission to the server . For example storage nodes having a predetermined minimum free disk space may answer to the query. The server may receive the responses which may include geographic data relating to the geographic position of each server. For instance as indicated in the geographic data may include the latitude the longitude and the altitude of each server. Other types of geographic data may however also be conceivable such as a ZIP code or the like.

In addition to the geographic data further information may be provided that serves as an input to a storage node selection process. In the illustrated example the amount of free space in each storage node is provided together with an indication of the storage node s system age and an indication of the load that the storage node currently experiences.

Based on the received responses the server selects at least two in a typical embodiment three storage nodes in the subset for storing the data. The selection of storage nodes is carried out by means of an algorithm that takes different data into account. The selection may be carried out in order to achieve some kind of geographical diversity. In an example the selection is performed such that selection of file servers in the same rack are not chosen as the selected storage nodes. Typically a great geographical diversity may be achieved even selecting storage nodes on different continents. In addition to the geographical diversity other parameters may be included in the selection algorithm. In an example geographical diversity may be the primary selection criteria. In this example as long as a minimum geographic diversity is achieved free space system age and current load may also be taken into account.

When the storage nodes have been selected the data to be stored and a corresponding data identifier may be sent to each selected node typically using a unicast transmission.

Optionally the operation may be concluded by each storage node which has successfully carried out the writing operation sending an acknowledgement to the server. The server may then send a list to all storage nodes involved indicating which nodes have successfully written the data and which have not. Based on this information the storage nodes may themselves maintain the data properly by the replication process to be described. For instance if one storage node s writing failed there exists a need to replicate the file to one more storage node in order to achieve the desired number of storing storage nodes for that file.

The data writing method in itself allows an API in a server to store data in a very robust way as excellent geographic diversity may be provided.

In addition to the writing and reading operations the API in the server may carry out operations that delete files and update files. These processes will be described in connection with the data maintenance process below.

The aim of the data maintenance process is to make sure that a reasonable number of non malfunctioning storage nodes each store the latest version of each file. Additionally it may provide the function that no deleted files are stored at any storage node. The maintenance is carried out by the storage nodes themselves. There is thus no need for a dedicated master that takes responsibility for the maintenance of the data storage. This ensures improved reliability as the master would otherwise be a weak spot in the system.

With reference to the method for maintaining data comprises the detecting conditions in the data storage system that imply the need for replication of data between the nodes in the data storage system and a replication process . The result of the detection process is a list of files for which the need for replication has been identified. The list may further include data regarding the priority of the different needs for replication. Based on this list the replication process is carried out.

The robustness of the distributed storage relies on that a reasonable number of copies of each file correct versions are stored in the system. In the illustrated case three copies of each file is stored. However should for instance the storage node with the address 192.168.1.5 fail the desired number of stored copies for files B and C will be fallen short of.

One event that results in a condition for triggering replication may be the malfunctioning of a storage node in the system.

Each storage node in the system may monitor the status of other storage nodes in the system. This may be carried out by letting each storage node emit a so called heartbeat signal at regular intervals as illustrated in . In the illustrated case the storage node with address 192.168.1.7 emits a multicast signal to the other storage nodes in the system indicating that it is working correctly. This signal may be received by all other functioning storage nodes or a subset of the functioning storage nodes in the system for example nodes carrying out heartbeat monitoring cf. . In the case with the storage node with address 192.168.1.5 however this node is malfunctioning and does not emit any heartbeat signal. Therefore the other storage nodes may notice that no heartbeat signal has been emitted by this node in a long time which may indicate that the storage node in question is down.

The heartbeat signal may in addition to the storage node s address include its node list version number. Another storage node listening to the heartbeat signal and finding out that the transmitting storage node has a later version node list may then request that transmitting storage node to transfer its node list. This means that addition and removal of storage nodes can be obtained simply by adding or removing a storage node and sending a new node list version to one single storage node. This node list will then spread to all other storage nodes in the system.

Again with reference to each storage node may search its internal directory for files that are stored by the malfunctioning storage node. Storage nodes which themselves store files B and C will find the malfunctioning storage node and can therefore add the corresponding file on their lists .

The detection process may however also reveal other conditions that imply the need for replicating a file. Typically such conditions may be inconsistencies e.g. one or more storage nodes has an obsolete version of the file. A delete operation may also imply a replication process as this process may carry out the actual physical deletion of the file. The server s delete operation may ensure that the storage nodes set a deletion flag for the file in question. Each node may therefore monitor reading and writing operations carried out in the data storage system. Information provided by the server at the conclusion of reading and writing operations respectively may indicate that one storage node contains an obsolete version of a file in the case of a reading operation or that a storage node did not successfully carry out a writing operation. In both cases there exists a need for maintaining data by replication such that the overall objects of the maintenance process are fulfilled.

In addition to the basic reading and writing operations at least two additional processes may provide indications that a need for replication exists namely the deleting and updating processes that are now given a brief explanation.

The deleting process may be initiated by the server cf. . Similar to the reading process the server may send a query by multicasting to all storage nodes in order to find out which storage nodes has data with a specific data identifier. The storage nodes scan themselves for data with the relevant identifier and may respond by a unicast transmission if they have the data in question. The response may include a list from the storage node directory of other storage nodes containing the data. The server then sends a unicast request to the storage nodes that are considered to store the file that the file is to be deleted. Each storage node may set a flag relating to the file and indicating that it should be deleted. The file may then be added to the replication list and an acknowledgement is sent to the server. The replication process may then physically deletes the file as will be described.

The updating process has a search function similar to the one of the deleting process and a writing function similar to the one carried out in the writing process. The server may send a query by multicasting to all storage nodes in order to find out which storage nodes has data with a specific data identifier. The storage nodes scan themselves for data with the relevant identifier and may respond by a unicast transmission if they have the data in question. The response may include a list from the storage node directory of other storage nodes containing the data. The server may then send a unicast request telling the storage nodes to update the data. The request may contain the updated data. The storage nodes updating the data may send an acknowledgement to the server which responds by sending a unicast transmission containing a list with the storage nodes that successfully updated the data and the storage nodes which did not. Again this list can be used by the maintenance process.

Again with reference to the read write delete and update operations may all indicate that a need for replication exists. The same applies for the heartbeat monitoring . The overall detection process thus generates data regarding which files need be replicated. For instance a reading or updating operation may reveal that a specific storage node contains an obsolete version of a file. A deletion process may set a deletion flag for a specific file. The heartbeat monitoring may reveal that a number of files stored on a malfunctioning storage node may need be replicated to a new storage node.

Each storage node may monitors the need for replication for all the files it stores for example by maintaining a replication list . The replication list thus may contain a number of files to be replicated. The files may be ordered in correspondence with the priority for each replication. Typically there may be three different priority levels. The highest level may be reserved for files which the storage node holds the last online copy of Such a file may be higher priority and may be quickly replicated to other storage nodes such that a reasonable level of redundancy may be achieved. A medium level of priority may relate to files where the versions are inconsistent among the storage nodes. A lower level of priority may relate to files which are stored on a storage node that is malfunctioning. An even lower level may be introduced that deals with files for which too many copies are stored the replication list thus having four levels.

The storage node deals with the files on the replication list in accordance with their level of priority. The replication process is now described for a storage node which is here called the operating storage node although all storage nodes may operate in this way.

The replication part of the maintaining process may start with the operating storage node attempting to become the master for the file it intends to replicate. The operating storage nodes may send a unicast request to become master to other storage nodes that are known store the file in question. The directory cf. may provide a host list comprising information regarding which storage nodes to ask. In the event for instance in case of a colliding request that one of the storage nodes does not respond affirmatively the file may be moved back to the list for the time being and an attempt is instead made with the next file on the list. Otherwise the operating storage node may be considered to be the master of this file and the other storage nodes may set a flag indicating that the operating storage node is master for the file in question.

At all copies of the file in question in the distributed storage system may be located. This may be carried out by the operating storage node sending a multicast query to all storage nodes asking which ones of them have the file. The storage nodes having the file may submit responses to the query which may contain the version of the file they keep as well as their host lists e.g. the list of storage nodes containing the relevant file that is kept in the directory of each storage node. These host lists may then be merged by the operating storage node such that a master host list is formed corresponding to the union of all retrieved host lists. If additional storage nodes are found which were not asked when the operating storage node attempted to become master that step may now be repeated for the additional storage nodes. The master host list may contain information regarding which versions of the file the different storage nodes keep and may illustrate the status of the file within the entire storage system.

Should the operating storage node not have the latest version of the file in question this file may then be retrieved from one of the storage nodes that do have the latest version.

The operating storage node may decide whether the host list should be changed typically if additional storage nodes should be added. If so the operating storage node may carry out a process very similar to the writing process as carried out by the server and as described in connection with and . The result of this process is that the file is written to a new storage node.

In case of version inconsistencies the operating storage node may update copies of the file that are stored on other storage nodes such that all files stored have the correct version.

Superfluous copies of the stored file may be deleted . If the replication process is initiated by a delete operation the process may jump directly to this step. Then once all storage nodes that store the file have accepted the deletion of the file the operating storage node may request for example using unicast all storage nodes to physically delete the file in question. The storage nodes may acknowledge that the file is deleted.

Further the status e.g. the master host list of the file may be updated. It is then optionally possible to repeat steps for example to ensure that the need for replication no longer exists. This repetition should result in a consistent master host list that need not be updated in step .

Thereafter the replication process for that file is concluded and the operating storage node may release the status as master of the file by sending a corresponding message to all other storage nodes on the host list.

As previously mentioned a storage node may have a replication list with different levels of priority where the priority levels decide the order in which files are replicated among the storage nodes. It is also useful to define a mechanism that deals with priorities of the tasks of non master nodes in the replication process. More specifically a storage node which is appointed as master for the replication of a file may generate work that is to be carried out on other storage nodes in the cluster for example requests that need be answered to.

The storage nodes act fairly independently in the replication process as there will usually be no hierarchically higher entity that co ordinates activities and makes sure that the most important ones are carried out first. For example a specific storage node with low priority level tasks on its replication list may carry out those tasks without knowing that those tasks may in the cluster slow down other tasks that have higher priorities since those more important tasks may for instance relate to files that the specific storage node does not store.

In some cases a storage node may be jammed by a number of requests from a number of other storage nodes each trying to replicate a file. This may be the case for instance with a storage node that comes online after being offline for a considerable time. In such a case a number of other storage nodes may notice from the reappearing storage node s heartbeat that some of their files are stored by too many storage nodes since the previously absent node s files may have already been replicated. There may also be version inconsistencies. Usually a lot of traffic will in such cases be directed towards the reappearing storage node. This traffic may involve requests to read and write data on the reappearing storage node s disks and may take a considerable time. In some cases this may even slow down reading and writing processes carried out by external clients i.e. from the server .

In an example the work queue list with the highest priority may deal with requests from an external client e.g. an application running on a server and utilizing the cluster. This allows requests from applications for example read and write operations as discussed initially to be dealt with first at all times.

Further there may exist a number of work queue lists intended for replication requests initiated by another storage node as a replication master. The priorities of those work queue lists may be mapped with a one to one relationship to the priorities of the replication list cf. of that another storage node such that the requests resulting from replications with the highest priorities may end up in the work list queue with the second highest priority etc. even though other possibilities exist such as using fewer or more levels of priorities at the work queue lists etc.

In order allow the receiving storage node to sort incoming requests properly such requests may be provided with a tag including the priority in question.

The work queue lists may have predefined sizes particularly the ones with the lowest priorities. For example the higher the priority the greater the corresponding work queue size. The sizes may be predefined or may be altered dynamically depending on system performance over a time window such that a maximum response time may be provided.

The storage node may sort incoming requests into the work queue lists in accordance with the respective tagged priorities and may deal with the requests in the lists relatively in their order of priority.

For instance twice as many requests may be dealt with in the list with the highest priority as compared with in the list with the second highest priority. The same relationship may exist between the second and third list etc. Thus for four lists the relationship between the frequency which the node deals with request in queues may be 8 4 2 1 although this is only one conceivable example.

While the storage node works on the requests in the lists new requests may continue to pour into the lists and at some point it may be the case that a list typically the one with the lowest priority becomes full and is unable to receive further requests. If further requests with that level of priority are received or optionally a request with an even lower level of priority the storage node may respond by sending a BUSY message to the storage node from which the request in question originated.

This BUSY message may inform the originating storage node that the storage node to which it sent a request is busy with more important replication processes at this instant. In response the originating storage node may halt the replication process during a predetermined time period to avoid disturbing hot spots in the storage cluster. When this period has lapsed the originating storage node may make a new attempt to send its request. Optionally the originating storage node may during this period work with other replications on its replication list for which the busy storage node may be uninvolved.

It is thereby accomplished a mechanism that ensures that the storage system is focusing on the most important tasks without any centralized control. Additionally it is ensured that a request is accepted at a receiving storage node if it is likely that this request can be dealt with within a reasonable time frame.

This system where each storage node takes responsibility for maintaining all the files it stores throughout the set of storage nodes provides a self repairing in case of a storage node malfunction self cleaning in case of file inconsistencies or files to be deleted system with excellent reliability. It is easily scalable and can store files for a great number of different applications simultaneously.

The invention is not restricted to the specific disclosed examples and may be varied and altered in different ways within the scope of the appended claims.

