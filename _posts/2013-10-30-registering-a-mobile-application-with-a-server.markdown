---

title: Registering a mobile application with a server
abstract: In an example embodiment, a test request is sent to a server configured to provide data to the mobile device application. Then a response to the test request is received from the server. The response is analyzed to identify a pattern in the response indicative of a communication sent via a particular communication path. An available communication path between the mobile device application and the server corresponding to the pattern is identified. Then, a mobile device application is registered with the server via the identified communication path.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09258669&OS=09258669&RS=09258669
owner: SAP SE
number: 09258669
owner_city: Walldorf
owner_country: DE
publication_date: 20131030
---
This application claims priority to U.S. Provisional Patent Application No. 61 860 703 filed on Jul. 31 2013 entitled MOBILE APPLICATION FRAMEWORK EXTENSIBILITY and U.S. Provisional Patent Application No. 61 860 716 filed on Jul. 31 2013 entitled LOGON MANAGER both of which are hereby incorporated by reference in their entirety.

The subject matter disclosed herein generally relates to the processing of data and for example to managing communications between devices.

Mobile applications also known as apps have dramatically increased in popularity with the rise of smartphones and tablets. It is common for these applications to be downloaded by end users from a central repository sometimes referred to as an app store or other location where digital files can be downloaded to user devices. App developers typically design the application test the code compile the code and then upload the compiled code representing the app to the app store. Updates to the app even for minor changes such as user interface changes e.g. logo changes font changes color changes and so on still may require that the application be recompiled and uploaded to the app store where a user may need to download the latest version.

Systems and methods for registering mobile applications in an enterprise environment are described. In some example embodiments the systems and methods send a test request to a server configured to provide data to the mobile device application receive a response to the test request from the server identify an available communication path e.g. gateway or mobile platform between the mobile device application and the server based on content within the response to the test request and register the mobile device application with the server via the identified communication path.

In the following description for purposes of explanation numerous specific details are set forth to provide a thorough understanding of example embodiments. It will be evident to one skilled in the art however that the present subject matter may be practiced without these specific details.

A mobile application framework MAF enables a powerful and flexible platform to be used to create and distribute mobile applications. The framework allows designers to build and run customizable native mobile applications. In some example embodiments the mobile application framework provides customization changeability and extensibility dynamic configuration reusable components and a standardized look and feel. The mobile application framework may also provide the ability to build native enterprise ready mobile applications that are customizable and extensible. In some example embodiments this may be accomplished through configuration rather than by coding changes which may assist maximizing developer productivity.

In operation an application developer may create an application using a mobile application framework provider . This process will be described in more detail below but generally the application developer may include one or more configuration files in the application. At operation the mobile application framework provider may upload the created application to an app store . Subsequently at operation an end user may download the application from the app store .

Later when the application developer wishes to make a change to a portion of the application such as altering user interface elements the application developer may at operation change one or more configuration files and upload the altered configuration files to a mobile platform server . At operation the mobile platform server may provision the new configuration files to the end user .

The mobile application framework extensibility framework may include a number of components including a core component . The core component may expose application program interfaces APIs that initialize the framework and access additional functionality provided by internal components. A user interface component may encapsulate a metadata driven view controller and data binding generation functionalities. A logic component may create controllers associated with the metadata and maintain responsibility for the behavior of the application including business logic. A data component may provide a unified fa ade to the underlying data access technology. A configuration component may read and parse all the metadata needed by the application such as user interface definitions data bindings user interface elements and controls events and actions built in and custom . The configuration component may also transform metadata to native constructs using wrapper classes dedicated parsers and validators.

Mobile platform client libraries may store metadata in the form of configuration files. In an example embodiment user interface elements may be included in the mobile platform client libraries in the form of tiles. A tile is a user interface elements or screen which can be primitive or can embed further tiles. Theoretically tiles can be nested to an unlimited level.

When a deployable unit is compiled uploaded to an app store downloaded by an end user and executed the deployable unit may simply execute as an ordinary application would running various functions from the custom code . When a call to a mobile application framework re use component is encountered in the custom code then control may pass one or more functions defined within the mobile application framework re use component . The mobile application framework re use component may then be executed using functionality within the mobile application framework extensibility framework which may retrieve one or more tiles from the configuration files in the mobile platform client libraries .

When an application developer wishes to update one or more user interface elements or other metadata of the application the application developer may update one or more configuration files within the mobile platform client libraries by updating a mobile platform server that can deploy the updates to these mobile platform client libraries to the end user device. Since modification of these mobile platform client libraries does not directly alter the functionality of the code such as custom code of the application there is no need to recompile the application in order to benefit from the updates.

In some example embodiments each application ships with a predefined set of default configuration data which is added to the project as a resource bundle. External configuration files can override the defaults. These external configuration files allow an application developer to modify and enhance the look and feel of the application add or remove user interface elements and screens modify data bindings and so on. This may all be accomplished without having to recompile the application. In some example embodiments the configuration files are distributed from a mobile platform server in compressed form which may be called the application configuration profile ACP .

In some example embodiments there are several different types of configuration files stored in the application configuration profile. The first called META INF may contain versioning related metadata. This may include a file called MANIFEST.MF which is a manifest file used by the mobile platform server.

The second type of configuration files are tiles. In some example embodiments tiles may be expressed in extensible markup document XML form. Files may include layout phone.xml which provides an extensibility configuration file for phone or phone like devices such as MP3 players and layout tablet.xml which provides an extensibility configuration file for tablet devices.

The third type of configuration files are styles which may include style.xml a styling configuration file.

The fourth type of configuration files are image files. These contain the static images used by the application organized by platform. Thus image files for multiple different platforms can all be stored in the library and the device may simply just use the files corresponding to its platform. For example a platform called IOS may contain images specific to the iOS platform. Subfolders may contain images specific to specific devices within that platform such as for example iPhone and iPad. In some example embodiments native naming conventions may apply. For example .png may be used for low resolution images in the iOS platform and 2x.png may be used for hi resolution images in the iOS platform. For android devices subfolders within an android image folder may contain images specific to the density of the android device. For example LDPI may contain images specific to low density android devices. MDPI may contain images specific to medium density android devices and so on.

The fifth type of configuration files are strings. Strings may contain localized text strings one file per locale. In some example embodiments filenames may follow this format localization..xml.

The sixth type of configuration files may be called ext. This may include configuration files needed by the application. The entry names may be defined by the application. The developer can place any kinds of files in this directory. Although the framework does not process files in the ext folder it exposes the APIs needed to retrieve their content.

The seventh type of configuration files may be demos. These may contain off line data used by the application in demo mode.

These types of configuration files may represent only a small portion of the possible types of configuration files available to the system and are only intended as examples. Other embodiments may be possible where some but not all of the above types of configuration files are used either in lieu of or in conjunction with other types of configuration files not listed here.

The mobile application framework enables rapid development of mobile applications using a common set of services and a consistent approach. It also allows for sustainable development of packaged applications by providing developer extensibility in a declarative manner via configuration such as without the need for access to source code in turn allowing for easy upgrades of the application.

Much of this disclosure will focus on the client side of the extensibility. It may be assumed that a valid consistent and correct configuration is available on the client device and can be accessed by the client on occasion. Further it is assumed that all relevant libraries are bound to the application and that the functionality is available. While this disclosure makes these assumptions these assumptions are not intended to be limiting and in fact it is possible that in some implementations one or more of these assumptions may not be correct.

The mobile application framework supports a scenario in which an application developer is implementing a concrete application that performs a particular business process. The mobile application framework also supports a scenario in which a developer or partner applies specific extensions to a mobile application. In the first scenario the application development team may have access to the framework API and is even able to add specific classes which implement the application and its specified behavior. Hence the application can provide its own custom implementation to override certain default framework functionality. The application then may keep the control and responsibility as desired. In the second scenario developers may be supported to enhance the application in a structural way. This means that developers can change the layout of the screen add new fields or entire screens plus add the specified navigation to the new screens. However the framework may not support the definition of new behavior logic also known as behavior extensibility. In some embodiments however such behavior extensibility may be supported.

When building an application using the mobile application framework there are many different development possibilities. A developer can choose to build an application fully using metadata definition. A developer can choose to build an application partially using metadata definition and partially using custom code. A developer can choose to build a fully custom application that uses the configuration extensions provided in the mobile application framework and provisioning infrastructure.

As described herein the mobile application framework allows developers to configure the application without access to code or the need to recompile. The application developer can integrate the framework to make use of the extensibility capabilities.

As described herein the mobile application framework MAF includes a variety of tools and components including re usable components e.g. the logon manager structural extensibility and other tools. The MAF provides customizable prepackaged building blocks for mobile applications designed to assist in the development of mobile applications. For example a developer may utilize MAF to build new applications to upgrade and customize MAF based standard mobile applications to a company s needs without modifying the source code by setting the branding logos and terminology and or adding or deleting screen sections by configuring the application and not by coding the application .

In some example embodiments the logon manager manages common logon related tasks such as registering and deleting users updating configuration locking and unlocking applications changing application passcodes and securely handling passwords. The logon manager may be based on re usable controls including a default UI that is skinnable for different applications.

MAF reusable controls enable developers to utilize native iOS UI controls such as buttons and labels that display a default style taken from a prebuilt library. The developers may skin these components at runtime to match developer branding without recompiling the source code. The MAF also contains a set of complex controls such as a calendar a tree view and locale aware controls. These complex controls which provide additional runtime skinning capabilities may be built from the simple MAF controls.

As described herein in some example embodiments the logon manager includes and or performs various functions including facilitating and completing user initiated registration requests to specified security infrastructures and or via specified communication scenarios the locking and un locking of applications to protect credentials and other sensitive information the changing of application back end passwords to enhance security within an enterprise environment the customization of user interfaces and other components and so on.

For example the logon manager or MAFLogonUING provides an out of the box logon user interface that uses the default implementation of the MAFLogonUIViewManager . This class handles navigation between various logon screens using a MAFLogonUIContextViewManager which builds dynamic screen content from Context objects such as MAFLogonUIContext objects that describe general screen data such as header footer groups fields and action items. The information about the screen is delivered in an array of objects. A MAFLogonMutableArrayHelper handles arrays without a type as typed objects or NSMutableArray objects.

The MAFLogonMediator creates the content of this array. The logon manager via the MAFLogonManagerNG provisions the logon UI to present all the necessary information to execute the next step of a selected process. The logon process may receive challenges such as an authentication challenge from the server. In some example embodiments the MAFLogonMediator may need additional information from the application. To get the information the MAFLogonMediator issues a new UIContext object and passes it to the logon UI. The logon UI may then present it to the device end user who provides the missing information. The input provided by an end user is handled in other context objects such as the MAFLogonOperationContext the MAFLogonChallengeContext and so on.

The logon manager presents logon screens on a device providing easy integration for applications that use default logon UI behavior. While the logon manager e.g. via the MAFLogonUING constructs a dynamic UI from context elements the MAFLogonManagerNG executes operations and constructs UI contexts to be presented by the MAFLogonUING. Thus in some example embodiments the MAFLogonManagerNG handles all UI related configurations. The MAFLogonManagerNG also handles various communications with client devices such as IMO communications with a SMPProxyClient HTTPRest Cloud communications with a SMPRestClient and or Gateway ping communications with a SDM Connectivity client .

To begin a developer can create a new Xcode project. is an example screen shot of a project selection page of a mobile application development tutorial in accordance with an example embodiment. From the project selection page the developer selects a new project by selecting File menu New Project and a Choose a template for your new project modal view appears. The developer selects the Single View Application template and clicks Next . The developer specifies the project details on the project selection page clicks Next specifies a place to which the starter application will be saved and clicks Create which can open a new project.

The developer now adds MAF libraries to the starter application a view based application project. The MAF may be provided in the form of statically linked libraries accompanied by resource bundles. The libraries are located in the installation folder created by a mobile platform software development kit SDK installer. is an example screen shot of project libraries for a mobile application development tutorial in accordance with an example embodiment. The developer can add all libraries from the libs folder to the project. In this example there are four distinct versions of the libraries because they are built for two platforms e.g. iphoneos and iphonesimulator and both for Debug and Release. The developer may add one set of these libraries and xcode can search the correct version for the current build setup. For example the developer may select the Debug iphoneos version . The developer then can copy all of the client side mobile platform libraries into a folder called dependencies in the root of the project. In order to add the libraries the developer may drag and drop them into the xcode windows of the Project Navigator view of the project resulting in a similar folder structure in the Project Navigator view. is an example screen shot of a folder hierarchy for a mobile application development tutorial in accordance with an example embodiment.

At this point the developer may repeat the above to add various dependencies. The developer may adjust the Library and Header search paths by selecting the project in the Project Navigator view selecting the build settings tab in the main area of xcode ensuring that All settings is selected and not filtered to Basic settings only and searching for Search Paths in the search field.

For example the developer may specify the following string as the Header search path PROJECT DIR dependencies headers BUILD STYLE PLATFORM NAME and specify the following string as the Library search path PROJECT DIR dependencies libs BUILD STYLE PLATFORM NAME Thus the xcode is able to select the correct library for the current build setup. The developer may set other linker flags to all load ObjC which is located in the build settings of the project.

In order to build the project the developer adds the following ObjC frameworks MessagUI.framework SystemConfiguration.framework Security.framework QuartzCore.framework MobileCoreServices.framework Libz.dylib Libstdc .dylib CFNetwork.framework UIKit.framework Foundation.framework and CoreGraphics.framework.

In some example embodiments the view controller MainViewController.m is responsible for setting the self reference as the partenViewController property of the MAFLogonUIViewManager . The Logon UI is presented using the parntViewController reference whenever needed among other things. The project may be run to see the default MAF logon UI which is presented because the logon selector on the Logon Manager is called from the appdelegate when the application became active.

For example is an example screen shot of a login entry screen for a mobile application is an example screen shot of a login credential input screen for a mobile application and is an example screen shot of a passcode setting screen for a mobile application in accordance with an example embodiment. These screen shots depict for example the default MAF logon user interfaces.

Once the MAFLogonUIViewManager is initialized the MAFLogonUIViewManager presents the MAF logon UI screens. The View Manager maintains a reference to the MAFLogonMediator which in the code examples may also be called a logon manager . To present a particular screen it calls the corresponding operation on the MAFLogonMediator which notifies the View Manager of the MAFLogonUING that the action calls for input. The View Manager generates and presents the input screen. The View Manager then calls back the MAFLogonMediator in the MAFLogonManagerNG and executes the next step of the requested operation.

This call presents the default logon screen shown in . For example depicts an example logon screen and depicts a more detailed logon screen in accordance with an example embodiment.

A user may enter input that corresponds to a selected onboarding scenario such as a scenario facilitated by screen or . The user taps or selects the Log In button to trigger the registration process with the following outcomes the request fails with an error message the registration succeeds and the success delegate is called on MAFLogonNGDelegate and or the registration succeeds and the App Passcode screen is presented.

As described herein the The MAFLogonManagerNG provides a build time configuration of the structure and content of the MAF logon UI. For example it may facilitate hiding the advanced registration section hiding each field individually setting a default value for each field individually and so on. Users cannot change the default values of hidden fields but the onboarding process uses these values.

Upon a successful registration in one of the scenarios the device user sees a Set Passcode screen or as shown in or B. In some example embodiments this is the second screen of the logon process unless the configuration prohibits the usage of app passcodes or if the password policy is disabled on a Mobile Platform . The password policy may be set for the application connection template on the Mobile Platform server by the IT administrator. The confirmation may match the app passcode and the app passcode may match the password policy. The screens or appear when the password policy is enabled. For example the MAFLogonUING checks the password policy and presents the screen as appropriate.

In order to delete registration information from the device the deleteUser operation is called as follows 

For example when the logon manager s deleteUser method is called the Delete Registration Confirmation UIAlertView is presented.

To close the secure store and present an App Passcode Unlock screen lockSecureStore is called from the application as follows 

To review registration information the Login Data screen is presented by executing the Login Data operation as follows 

After registration is completed and a secure data store is initialized the application may request data from the back end.

In some example embodiments registration data is fetched from MAFLogonManagerNG rather than getting username password and enpointurl directly from the Secure Store mobile platform data vault . This may be done by implementing a call to the logonManager class referenced by the MAFLogonHandler object.

Once the MAFLogonRegistrationData object is obtained the application may use its content to construct various types of SDM requests and set their properties before triggering them. The applicationConnectionId property can be used to set the SDM request type according to the type of the registration.

Once set up correctly the SDMRequestBuilder may be used as usual to create a request object. The application may set the request object s properties based on the content of MAFLogonRegistrationData.

In some example embodiments the MAF supports mutual certificate based data requests. In order to execute requests with certificates the application may set an identity into the mobile platform RequestManager and gets an identity from the MAF Logon after the registration has been finished 

Once an identity from MAF Logon Manger is received the application may set it to each Request before starting it as follows 

Once completed and providing that all the configuration prerequisites are met the request can execute and authenticate with the certificate based on the following prerequisites the user creation policy is set to certificate and the mobile platform server side security configuration used during registration is set to support Mutual Certificate Handling.

In some example embodiments the MAFLogonUING notifies applications about the result of each MAFLogonManagerNG operation it executes. The MAFLogonNGDelegate protocol may be implemented by an application s View Controller.

In some example embodiments the MAFLogonManagerNG communicates errors using iOS standard NSError objects. If the passed NSError object is not nil an error is generated. The MAF provides an error handling method for these the NSError instance contains the localized error description the error domain and the error code.

In some example embodiments to customize header and footer views for any MAF logon UI screens the MAFLogonUING is used. is a screen shot of a customized login screen for a mobile application with a custom header and footer in accordance with an example embodiment.

In some example embodiments the MAFLogonUING calls the willRenderHeaderFooterFromCustomContext method when it presents the screen allowing the developer to set any UIView content in these properties.

In some example embodiments to change the behavior of the MAFLogonManagerNG the feature and default values configuration files may be adjusted at build time. The plist format configuration files are located in the MAFLogonManagerNG.bundle folder where plist is an XML format that can be adjusted in Xcode or in any text editor among other things.

As described herein the MAFLogonManagerNG supports multiple onboarding scenarios based on the most common infrastructure setups supported by enterprise mobile applications among other things. For example a company IT of a developer may have a Mobile Platform installed and use a relay server to route Internet requests to intranet hosted Gateway systems. As another example the developer uses the Mobile Platform but replaces the relay server with IIS or Apache which is a reverse proxy server. The logon manager via the MAFLogonManagerNG enables the onboarding of an enterprise mobile application to these and other communication paths or scenarios among other things.

In some example embodiments the logon manager includes and or performs various functions including facilitating and completing user initiated registration requests to specified security infrastructures and or via specified communication scenarios among other things. is a block diagram illustrating a logon manager in accordance with an example embodiment.

The logon manager may include one or more modules and or components to perform one or more operations of the logon manager . The modules may be hardware software or a combination of hardware and software and may be executed by one or more processors. For example the logon manager may include a test request module a server response module a path identification module and a registration module .

In some example embodiments the test request module is configured and or programmed to send a test request to a server configured to provide data to the mobile device application.

In some example embodiments the server response module is configured and or programmed to receive and or access a response to the test request from the server.

In some example embodiments the path identification module is configured and or programmed to identify an available connection path between the mobile device application and the server based on content within the response to the test request.

In some example embodiments the registration module is configured and or programmed to register the mobile device application with the server via the identified connection path.

As described herein the MAFLogonManagerNG may determine a target infrastructure or communication path with which to onboard a mobile application. is a flow diagram illustrating a method in accordance with an example embodiment of onboarding a mobile application. The method may be performed by the logon manager or and accordingly is described herein merely by way of reference thereto. It will be appreciated that the method may be performed on any suitable hardware.

In operation the logon manager sends a test request to a server configured to provide data to the mobile device application. For example the test request module sends a test request to the server that includes information from a plist file and or a farmID for a known platform e.g. a company or provider intranet platform in order to identify the server as a Mobile Platform or Gateway among other things.

In some example embodiments an operation context object which contains all information entered by the end user e.g. plist information farmID and so on passes the information to MAFLogonManagerNG to initiate the request. Based on the information the MAFLogonManagerNG determines whether the device user wants to use a Mobile Platform server. For example if the user provides a farmID the logon manager constructs and sends a Mobile Platform server communicator based test request.

In operation the logon manager receives a response to the test request from the server. For example the server response module receives and or accesses a response to the test request from the server that includes various types of information including header information code cookies and so on.

In operation the logon manager identifies an available communication or connection path between the mobile device application and the server based on content within the response to the test request. For example the path identification module identifies whether the available communication path or scenario is between the mobile device application and a Direct Gateway a Direct Mobile Platform server Mobile Platform server with relay server a Mobile Platform server with third party reverse proxy and so on.

In some example embodiments if the logon manager may not identify the communication path e.g. the MAFLogonManagerNG cannot identify the communicator or server the logon manager generates an error. Additionally MAFLogonManagerNG may search for any information in the context and select a method based on some or all of this information. The context may have default values that are configured by the application developer among other things.

In operation the logon manager registers the mobile device application with the server via the identified communication path. For example the registration module registers the mobile device application with the server via the identified connection path.

In operation the logon manager build a test request or ping url which may include protocol information host information port information path information and so on. In operation the logon manager calls a target server with the request. In operation the server responds and sends a response to the logon manager . In operation the logon manager analyzes the response such as by identifying and or determining patterns or characteristics within the headers cookies status messages authentication realms or other portions of the response.

In operation the logon manager determines if the response includes patterns associated with a gateway. If the patterns are associated with a gateway the logon manager in operation assigns communicatorID a gateway value e.g. GW and the communicatorDetected a yes value and proceeds to operation . If the patterns are not associated with a gateway the logon manager proceeds to operation and determines if the response includes patterns associated with a Mobile Platform. If the patterns are mobile platform patterns the logon manager in operation assigns communicatorID a mobile platform value e.g. SMP and the communicatorDetected a yes value and proceeds to operation . If the patterns are not mobile platform patterns the logon manager may still proceed to operation without assigning values for communicatorID or communicatorDetected.

In operation the logon manager determines if the response includes patterns associated with an Internet Information Services IIS server. If the patterns are IIS patterns the logon manager in operation assigns serverType an IIS value e.g. IIS and proceeds to operation else the logon manager proceeds to operation . In operation the logon manager determines if the response includes patterns associated with an Apache server. If the patterns are Apache patterns the logon manager in operation assigns serverType an Apache value e.g. Apache else the logon manager proceeds to operation . In operation the logon manager determines whether a communicatorID is determined.

If no communicatorID is determined e.g. no patterns are identified the logon manager in operation returns an error message. If there is a communicatorID the logon manager in operation creates a communicator or communication path between the mobile application and the server identified by the communicatorID value and or the serverType value.

For example if the communicatorID GW which is indicative of a gateway communication path the logon manager in operation sends a request that includes protocol host port and or path information and creates the communication path with the gateway server.

If the communicatorID SMP which is indicative of a known platform communication path the logon manager in operation determines whether there is a value for communicatorDetected. In operation the logon manager clears a farmID and in operation determines whether a farmID is known. If there is a farmID the logon manager in operation generates a direct mobile platform communication path and in operation builds a URL protocol via the communication path.

When no farmID is determined in operation the logon manager in operation determines if a relay server path exists. If the relay server path exists the logon manager generates a mobile platform relay server communication path and in operation builds a URL protocol via the communication path.

In operation when no relay server path exists the logon manager determines if the serverType value is IIS. If the serverType value is IIS indicative of an IIS reverse proxy server the logon manager in operation generates a mobile platform IIS reverse proxy server communication path and in operation builds a URL protocol via the communication path. If the serverType value is Apache indicative of an Apache reverse proxy server the logon manager in operation generates a mobile platform Apache reverse proxy server communication path and in operation builds a URL protocol via the communication path.

Of course the logon manager may perform the operations depicted in in a variety of different orders or sequences when determining a suitable onboarding scenario and or communication path via which a mobile application onboards to a communicator.

As described herein the MAF logon manager supports multiple onboarding scenarios based on the common infrastructure setups supported by enterprise mobile applications. Example scenarios include 

Scenario 1 The Direct Mobile Platform as depicted in . is a diagram illustrating a system in accordance with an example embodiment of an onboarding scenario . For example the direct Mobile Platform landscape contains a Gateway server a device and a firewall . The Mobile Platform server is installed and configured to connect to the Gateway server . Connections are accepted from the company intranet.

Scenario 2 The Cloud Based Mobile Platform as depicted in . is a diagram illustrating a system in accordance with an example embodiment of an onboarding scenario . The cloud based Mobile Platform landscape is similar to the direct Mobile Platform scenario however the Mobile Platform server is installed in the cloud. For example the scenario includes a gateway and a platform separated by a firewall which is accessed by a device via the Internet .

Scenario 3 The Mobile Platform with Relay Server as depicted in . is a diagram illustrating a system in accordance with an example embodiment of an onboarding scenario . The Mobile Platform with relay server landscape is similar to the direct Mobile Platform scenario but an application may access the Mobile Platform server from both the Internet and intranet. For example a relay server in communication with a gateway and a platform via a firewall enables a mobile device to access the landscape from the Internet via a firewall .

In this scenario an IT administrator may assign a Farm ID value to each user. The value of this field may match the relay server configuration which enables the relay server to route requests from the mobile device to the platform configured to work with the particular mobile application.

By default and for example the secured connection HTTPS is ON and is set to port . When the secured connection is off the default port is 80. The relay server path may depend on how it is installed and configured.

Scenario 4 Mobile Platform with Third Party Proxy as depicted in . is a diagram illustrating a system in accordance with an example embodiment of an onboarding scenario . A Mobile Platform with third party proxy landscape is similar to a Mobile Platform with relay server however it uses a third party proxy server instead of the relay server. For example a device connects via the internet to a platform and gateway via the proxy server which is between a firewall and a firewall .

Scenario 5 The Direct Gateway as depicted in . is a diagram illustrating a system in accordance with an example embodiment of an onboarding scenario . The direct Gateway landscape contains only the Gateway system and restricts access to the intranet. A mobile device connects to a gateway within an intranet via internal Wi Fi or through VPN or otherwise within a firewall .

Scenario 6 The Gateway with Third Party Proxy as depicted in . is a diagram illustrating a system in accordance with an example embodiment of an onboarding scenario . The Gateway with third party proxy landscape contains a Gateway server that resides inside the company intranet within firewall and a third party reverse proxy server within a firewall that enables a mobile device to access the Gateway server from the Internet .

In some example embodiments the Gateway system is customized such that the MAF logon UI component e.g. the logon manager detects the direct Gateway setup. Also back end users may have authorization to access the Gateway systems ping URL and the is HTTP show server header property may be enabled in SMICM transaction ICM SAPNetweaver .

As described herein onboarding may include two processes or operations including a registration process where the MAFLogonManagerNG uses input from the device user to contact a server and register with the server. For example if registration is successful the mobile application may send requests to the gateway server and obtain data.

In some example embodiments onboarding includes the creation of a data vault on the user device in which user credentials and other sensitive information or app data is securely stored. The logon manager may secure data within the data vault with a passcode such as a passcode that satisfies the requirements of a password policy.

Both of these steps may generate success and failure messages. Error messages are identified by an error code and an error domain which fits into the iOS error message handling method.

If the Mobile Platform server is used an Mobile Platform administrator may enable the password policy. If enabled the user may satisfy each rule. If Allow Default Password is enabled in the password policy the Set Passcode screen does not appear but the user may enable the app passcode using the Change Passcode option as described herein.

If the password policy is disabled or if communication is not through the Mobile Platform the MAFLogonManagerNG applies the default password policy.

As described herein in some example embodiments a data vault is created after a successful registration. Device users may disable the data vault passcode and may specify a passcode or may use a default passcode. is a block diagram illustrating system in accordance with an example embodiment. A data vault may be stored in memory of a mobile device.

The data vault securely stores various data or information such as application data and credential data using the passcodes described herein to prevent unauthorized access to the data or contained with the data vault . The data vault may be specific to a single mobile application both data for the mobile application as well as user credential data that enables a user to access services provided by the mobile application e.g. services or data provided by a server in communication with the mobile application . Therefore in some example embodiments the data vault provides a secure location within a mobile device in which to store mobile application data and corresponding credential information that is used to access the mobile application among other things.

In operation the logon manager registers a mobile device application to a server. In operation the logon manager generates a data vault in memory of a mobile device. In operation the logon manager stores application data and user registration credentials in the data vault. In operation the logon manager applies a passcode to the data vault.

For example during a successful registration of a mobile application to a platform such as via one of the scenarios described herein the logon manager accesses authorization credentials for a user of a mobile application supported by a mobile device the authorization credentials used to register the user with a service provided via the mobile application and stores the mobile application and the authorization credentials in a password protected location e.g. the data vault supported by the mobile device. The logon manager may assign a passcode to the mobile application having a syntax that follows password policy rules applied to the mobile application among other things.

In some example embodiments if the data vault is locked with a custom passcode the logon UI is presented with an Unlock screen. Users may unlock the data vault with the passcode they have set. If the user provides a wrong passcode multiple times the data vault deletes itself. The user may determine the maximum number of tries by a data vault property which may be set in the password policy. Additionally the user may set the data vault timeout in the password policy. For example the MAFLogonManagerNG downloads the timeout value from the Mobile Platform server during registration.

When device users forget their passcodes they may tap a Forgot passcode button on the Unlock screen which erases all client side data. If there is an Mobile Platform server in the landscape tapping the Forgot passcode button deletes both the client and server side registrations. This occurs when the device is connected to a network where the Mobile Platform server is reachable. Otherwise an administrator may manually remove the server side registration.

An automatic data vault timeout the Mobile Platform data vault has a built in timeout that is handled by the data vault itself. This is managed by the Mobile Platform server password policy see the PasswordPolicyLockTimeout key and set when the data vault is created. The timeout property determines the length of time a successfully unlocked data vault remains open. When the timeout value elapses the vault is locked and the device user has to reenter the vault passcode to resume using the application.

A background stay timeout because of the way iOS systems work and to keep the dependency between the components manageable MAFLogonManagerNG and MAFLogonUING implement a mechanism that tracks the amount of time the application spends in the background. The data vault can lock itself only when the application is in the foreground. That is a passcode should expire only while the device user is actually using the application. Different events such as an incoming phone call may move the application to the background. To support the locking of data vault in such cases MAFLogonManagerNG may subscribe to the iOS applicationWillResignBeingActive UIApplication Notification to save a timestamp. When the application again becomes active the MAFLogonUING is notified that a Resume event has occurred. The MAFLogonUING then checks whether the time elapsed since the timestamp is greater than the timeout value and if it is calls the MAFLogonManagerNG to close the data vault. A user may change the lock timeout for the application in the Apple Settings among other things.

In some example embodiments the logon manager provides client side credentials and a connection settings sharing mechanism for the MAF Logon based iOS applications. In order to use the features of Client Hub a Client Hub iOS application should be installed on a device and a Client Hub may be initialized with an SSO password. Once the Client Hub iOS application is installed and initialized MAF Logon supports credential and connection sharing across applications.

In some example embodiments in order to prepare an application to register it for Client Hub a signing certificate that was used to sign the application to the Client Hub application should be present. This is needed because the applications use shared Keychain. The Keychain may only be shared between applications that are signed by the same certificate. Also an entitlements file in the xcode project should be present.

These actions facilitate the sharing of a common Keychain across the two applications. In order to register an application to Client HUB another descriptor file should be present.

Once these configuration files are provided in the project and both the project and mobile platform Client Hub are deployed on the device both signed with the same key the testing of mobile platform Client Hub based credentials and connection sharing may begin.

The MAF Logon can first check to see if the application has the mobile platform Client Hub installed on the device. If it finds the application it can check if it is properly initialized or not e.g. whether the SSO Password was specified by the user or not . Once the MAF Logon sees that it is initialized it can display the mobile platform Client Hub Logon UI screen and can ask the user to input the mobile platform Client Hub password. The user can choose to tap Skip . This means that the user does not want to couple this particular application with the mobile platform Client Hub application. Once the user taps Skip the next time he starts the application it cannot present the SSO Passcode UI.

If the user fills in an SSO passcode and taps Next bar button item then MAF Logon can check if it can open the mobile platform Client Hub with the provided password if it can it can store the password in its own Secure Store for later use. Once the MAF Logon can open the mobile platform Client Hub it can ask credentials and connection data from the mobile platform Client Hub libraries. If the mobile platform Server does not provide particular connectivity information for this application the Client Hub libraries can ask the application for default values. These are read up from the clienthub.plist file. If there are no shared credentials the MAF Logon can present the Logon UI with two fields to provide backend username and backend password. Once the registration succeeds with these new credentials and the connection data provided either by the mobile platform Server or the default clienthub.plist the MAF Logon stores the credentials into mobile platform Client Hub.

Once an application that was registered with Client Hub is re launched the MAF Logon can check certain things. First of all it can check if the Client Hub is still present on the device. If not then it can de couple from the Client Hub application. This means that this application cannot check again for Client Hub. Neither can it share credentials or connection information with any future application installation through a new Client Hub install. To achieve this the application would need to be deleted from the device and then re installed again.

If the Client Hub application is still available then MAF Logon checks if the SSO Passcode is still valid. If the SSO Passcode is not valid then the MAF Logon UI can be presented to get the new SSP Passcode from the end user. Once the Client Hub has successfully opened MAF Logon can fetch the credentials stored in the Client Hub. The MAF Logon then compares the backend user and backend password with the variant stored in the Secure Store of the application to see if they are still identical. If the Client Hub application does not contain any credentials or the credentials stored in the Secure Store of the application are newer then MAF Logon can write the credentials into Client Hub application. If the credentials stored in the Secure Store of the application are older than the Client Hub version then it can write the newer credentials into the Secure Store of the application. After this the usual application process is launched.

From time to time the backend password may be updated. When this happens the MAF Logon can present the Backend Password screen to get the new password. Once the new password is verified the MAF Logon can share the new password with other applications through the Client Hub. In order to do so it first can check if the Client Hub application is still present on the device. If the Client Hub application is still available then the MAF Logon checks if the SSO Passcode is still valid. If the SSO Passcode is not valid then the MAF Logon UI can be presented to get the new SSP Passcode from the end user. Once the Client Hub has successfully opened MAF Logon can fetch the credentials stored in the Client Hub. It then compares the backend user and backend password with the variant stored in the Secure Store of the application to see if they are still identical. If the Client Hub application does not contain any credentials or the credentials stored in the Secure Store of the application are newer then MAF Logon can write the credentials into Client Hub application. If the credentials stored in the Secure Store of the application are older than the Client Hub version then MAF Logon can write the newer credentials into the Secure Store of the application. After this the usual application process is launched.

In some example embodiments the MAF 1.2 is optimized for a particular mobile platform. While working with the latest communication protocols and features of the mobile platform it provides backward compatibility for earlier mobile platform servers. In the past a mobile platform might have provided its own proprietary protocol called iMO. This protocol is still supported by MAF Logon. In order to use this protocol the iMO libraries may be added to the project libMo.a libSupProxyClient.a and libsupClientUtil.a.

Once these libraries are provided to the project MAF Logon can use them and offer iMO protocol. If these libraries are not present on the project the MAF Logon can offer the new HTTP REST protocol. Even though iMO libraries are provided in the project there might be some cases when HTTP REST protocol can be used instead. If the mobile platform supports both iMO and HTTP REST protocols on the same communication port the MAF Logon may prefer HTTP REST protocol. iMO may be used in cases where the mobile platform server does not support HTTP REST protocol.

The machine includes a processor e.g. a central processing unit CPU a graphics processing unit GPU a digital signal processor DSP an application specific integrated circuit ASIC a radio frequency integrated circuit RFIC or any suitable combination thereof a main memory and a static memory which are configured to communicate with each other via a bus . The machine may further include a graphics display e.g. a plasma display panel PDP a light emitting diode LED display a liquid crystal display LCD a projector or a cathode ray tube CRT . The machine may also include an alphanumeric input device e.g. a keyboard a cursor control device e.g. a mouse a touchpad a trackball a joystick a motion sensor or other pointing instrument a storage unit a signal generation device e.g. a speaker and a network interface device .

The storage unit includes a machine readable medium on which is stored the instructions embodying any one or more of the methodologies or functions described herein. The instructions may also reside completely or at least partially within the main memory within the processor e.g. within the processor s cache memory or both during execution thereof by the machine . Accordingly the main memory and the processor may be considered as machine readable media. The instructions may be transmitted or received over a network via the network interface device .

As used herein the term memory refers to a machine readable medium able to store data temporarily or permanently and may be taken to include but not be limited to random access memory RAM read only memory ROM buffer memory flash memory and cache memory. While the machine readable medium or computer readable medium is shown in an example embodiment to be a single medium the term machine readable medium or computer readable medium should be taken to include a single medium or multiple media e.g. a centralized or distributed database or associated caches and servers able to store instructions . The term machine readable medium or computer readable medium shall also be taken to include any medium or combination of multiple media that is capable of storing instructions e.g. instructions for execution by a machine or computer e.g. machine such that the instructions when executed by one or more processors of the machine or computer e.g. processor cause the machine or computer to perform any one or more of the methodologies described herein. Accordingly a machine readable medium refers to a single storage apparatus or device as well as cloud based storage systems or storage networks that include multiple storage apparatuses or devices. The term machine readable medium shall accordingly be taken to include but not be limited to one or more data repositories in the form of a solid state memory an optical medium a magnetic medium or any suitable combination thereof.

Throughout this specification plural instances may implement components operations or structures described as a single instance. Although individual operations of one or more methods are illustrated and described as separate operations one or more of the individual operations may be performed concurrently and nothing requires that the operations be performed in the order illustrated. Structures and functionality presented as separate components in example configurations may be implemented as a combined structure or component. Similarly structures and functionality presented as a single component may be implemented as separate components. These and other variations modifications additions and improvements fall within the scope of the subject matter herein.

Certain embodiments are described herein as including logic or a number of components modules or mechanisms. Modules may constitute either software modules e.g. code embodied on a machine readable medium or in a transmission signal or hardware modules. A hardware module is a tangible unit capable of performing certain operations and may be configured or arranged in a certain physical manner. In various example embodiments one or more computer systems e.g. a standalone computer system a client computer system or a server computer system or one or more hardware modules of a computer system e.g. a processor or a group of processors may be configured by software e.g. an application or application portion as a hardware module that operates to perform certain operations as described herein.

In some example embodiments a hardware module may be implemented mechanically electronically or any suitable combination thereof. For example a hardware module may include dedicated circuitry or logic that is permanently configured to perform certain operations. For example a hardware module may be a special purpose processor such as a field programmable gate array FPGA or an ASIC. A hardware module may also include programmable logic or circuitry that is temporarily configured by software to perform certain operations. For example a hardware module may include software encompassed within a general purpose processor or other programmable processor. It will be appreciated that the decision to implement a hardware module mechanically in dedicated and permanently configured circuitry or in temporarily configured circuitry e.g. configured by software may be driven by cost and time considerations.

Accordingly the phrase hardware module should be understood to encompass a tangible entity be that an entity that is physically constructed permanently configured e.g. hardwired or temporarily configured e.g. programmed to operate in a certain manner or to perform certain operations described herein. As used herein hardware implemented module refers to a hardware module. Considering embodiments in which hardware modules are temporarily configured e.g. programmed each of the hardware modules need not be configured or instantiated at any one instance in time. For example where a hardware module comprises a general purpose processor configured by software to become a special purpose processor the general purpose processor may be configured as respectively different special purpose processors e.g. comprising different hardware modules at different times. Software may accordingly configure a processor for example to constitute a particular hardware module at one instance of time and to constitute a different hardware module at a different instance of time.

Hardware modules can provide information to and receive information from other hardware modules. Accordingly the described hardware modules may be regarded as being communicatively coupled. Where multiple hardware modules exist contemporaneously communications may be achieved through signal transmission e.g. over appropriate circuits and buses between or among two or more of the hardware modules. In embodiments in which multiple hardware modules are configured or instantiated at different times communications between such hardware modules may be achieved for example through the storage and retrieval of information in memory structures to which the multiple hardware modules have access. For example one hardware module may perform an operation and store the output of that operation in a memory device to which it is communicatively coupled. A further hardware module may then at a later time access the memory device to retrieve and process the stored output. Hardware modules may also initiate communications with input or output devices and can operate on a resource e.g. a collection of information .

The various operations of example methods described herein may be performed at least partially by one or more processors that are temporarily configured e.g. by software or permanently configured to perform the relevant operations. Whether temporarily or permanently configured such processors may constitute processor implemented modules that operate to perform one or more operations or functions described herein. As used herein processor implemented module refers to a hardware module implemented using one or more processors.

Similarly the methods described herein may be at least partially processor implemented with a processor being an example of hardware. For example at least some of the operations of a method may be performed by one or more processors or processor implemented modules. Moreover the one or more processors may also operate to support performance of the relevant operations in a cloud computing environment or as a software as a service SaaS . For example at least some of the operations may be performed by a group of computers as examples of machines including processors with these operations being accessible via a network e.g. the Internet and via one or more appropriate interfaces e.g. an API .

The performance of certain of the operations may be distributed among the one or more processors not only residing within a single machine but deployed across a number of machines. In some example embodiments the one or more processors or processor implemented modules may be located in a single geographic location e.g. within a home environment an office environment or a server farm . In other example embodiments the one or more processors or processor implemented modules may be distributed across a number of geographic locations.

Some portions of the subject matter discussed herein may be presented in terms of algorithms or symbolic representations of operations on data stored as bits or binary digital signals within a machine memory e.g. a computer memory . Such algorithms or symbolic representations are examples of techniques used by those of ordinary skill in the data processing arts to convey the substance of their work to others skilled in the art. As used herein an algorithm is a self consistent sequence of operations or similar processing leading to a desired result. In this context algorithms and operations involve physical manipulation of physical quantities. Typically but not necessarily such quantities may take the form of electrical magnetic or optical signals capable of being stored accessed transferred combined compared or otherwise manipulated by a machine. It is convenient at times principally for reasons of common usage to refer to such signals using words such as data content bits values elements symbols characters terms numbers numerals or the like. These words however are merely convenient labels and are to be associated with appropriate physical quantities.

Unless specifically stated otherwise discussions herein using words such as processing computing calculating determining presenting displaying or the like may refer to actions or processes of a machine e.g. a computer that manipulates or transforms data represented as physical e.g. electronic magnetic or optical quantities within one or more memories e.g. volatile memory non volatile memory or any suitable combination thereof registers or other machine components that receive store transmit or display information. Furthermore unless specifically stated otherwise the terms a or an are herein used as is common in patent documents to include one or more than one instance. Finally as used herein the conjunction or refers to a non exclusive or unless specifically stated otherwise.

