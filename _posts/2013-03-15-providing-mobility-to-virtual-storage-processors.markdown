---

title: Providing mobility to virtual storage processors
abstract: A technique provides mobility to VSPs. The technique involves receiving, by processing circuitry, a VSP move command from a user. The VSP move command specifies a source VSP and a destination. The technique further involves identifying, by the processing circuitry and in response to the VSP move command, multiple source data objects which are configured to store data from the context of the source VSP. The multiple source data objects reside in a source storage pool. The technique further involves, after the multiple source data objects are identified, transforming the multiple source data objects into multiple destination data objects which are configured to store data from the context of a destination VSP at the destination. The multiple destination data objects reside in a destination storage pool which is different from the source storage pool. Such operation effectively provides VSP migration from source to destination.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09507787&OS=09507787&RS=09507787
owner: EMC IP Holding Company LLC
number: 09507787
owner_city: Hopkinton
owner_country: US
publication_date: 20130315
---
Data storage systems typically include one or more physical storage processors SPs accessing an array of disk drives and or electronic flash drives. Each SP is connected to a network such as the Internet and or a storage area network SAN and receives transmissions over the network from host computing devices hosts . The transmissions from the hosts include IO requests also called host IOs. Some IO requests direct the SP to read data from an array whereas other IO requests direct the SP to write data to the array. Also some IO requests perform block based data requests where data are specified by LUN Logical Unit Number and offset values whereas others perform file based requests where data are specified using file names and paths. Block based IO requests typically conform to a block based protocol such as Fibre Channel or iSCSI Internet SCSI where SCSI is an acronym for Small Computer System Interface for example. File based IO requests typically conform to a file based protocol such as NFS Network File System CIFS Common Internet File System or SMB Server Message Block for example.

In some data storage systems an SP may operate one or more virtual data movers. As is known a virtual data mover is a logical grouping of file systems and servers that is managed by the SP and provides a separate context for managing host data stored on the array. A single SP may provide multiple virtual data movers for different users or groups. For example a first virtual data mover may organize data for users in a first department of a company whereas a second virtual data mover may organize data for users in a second department of the company. Each virtual data mover may include any number of host file systems for storing user data.

It should be understood that a first set of virtual data movers may utilize a first pool of storage formed by a first set of storage drives e.g. flash drives magnetic disk drives etc. and a second set of virtual data movers may utilize a second pool of storage formed by a second set of storage drives. If storage drives are added to the first pool of storage drives the first set of virtual data movers is able to access more storage. Likewise if storage drives are added to the second pool of storage drives the second set of virtual data movers is able to access more storage.

Unfortunately there are deficiencies to the above described conventional approach to simply adding storage drives to a pool of storage. In particular such an approach is limited in its ability to distribute storage to virtual data movers. For example when storage drives are added to the above described first storage pool only the first set of virtual data movers is able to access the extra storage i.e. the second set of virtual data movers is unable to access the added storage.

Similarly suppose that a substantial amount of storage on the first storage pool is freed e.g. storage becomes available due to data deletion. In this situation only the first set of virtual data movers is able to enjoy the newly reclaimed storage and so on.

In contrast to the above described conventional situation in which virtual data movers are restricted to storage pools improved techniques are directed to providing mobility to virtual storage processors VSPs which define operating environments for file systems accessed by host applications. Such mobility may involve effectively moving VSPs to different storage pools and thus improving flexibility and storage utilization. For example a VSP is capable of effectively being moved from one storage pool to another to take advantage of storage abundance opportunities. Such operation is even capable of providing a perception that a VSP has migrated from a first physical storage processor to a second physical storage processor.

One embodiment is directed to a method of providing mobility to VSPs. The method includes receiving by processing circuitry a VSP move command from a user. The VSP move command specifies a source VSP and a destination e.g. a destination VSP a destination location a destination name etc. . The method further includes identifying by the processing circuitry and in response to the VSP move command multiple source data objects which are configured to store data from the context of the source VSP. The multiple source data objects reside in a source storage pool. The method further includes after the multiple source data objects are identified transforming the multiple source data objects into multiple destination data objects which are configured to store data from the context of a destination VSP at the destination. The multiple destination data objects reside in a destination storage pool which is different from the source storage pool. Such operation effectively provides VSP migration from source to destination.

In some arrangements transforming the multiple source data objects into the multiple destination data objects includes creating a set of replication sessions to replicate the multiple source data objects as the multiple destination data objects. For example a particular source data object may contain a VSP configuration file system having VSP configuration files which store VSP configuration data. Here creating the set of replication sessions may include establishing a VSP configuration file system replication session to replicate the VSP configuration file system to the destination VSP.

Additionally a set of source data objects may contain a set of user files systems having user files which store host data. In such arrangements creating the set of replication sessions may further include establishing a set of user file system replication sessions to replicate the set of user file systems to the destination VSP. In these arrangements each user file system replication session may be a standalone session which is independent of the other user file system replication sessions.

In some arrangements transforming the multiple source data objects into the multiple destination data objects further includes terminating the set of replication sessions and activating the destination VSP. Along these lines the set of replication sessions are deleted the destination VSP is configured to access the multiple destination data objects and the source VSP is deleted.

In some arrangements a configuration database holds multiple VSP records corresponding to multiple VSPs. In these arrangements operations such as creating replication sessions deleting VSPs etc. involve accessing and updating the configuration database.

In some arrangements the method further includes prior to receiving the VSP move command processing host input output I O requests directed to a particular user file system using the source VSP. Additionally the method further includes after transforming the multiple source data objects into the multiple destination data objects processing additional host I O requests directed to the particular user file system using the destination VSP.

In some arrangements the source VSP resides on a first physical storage processor and the destination VSP resides on a second physical storage processor. In these arrangements processing the additional host I O requests directed to the particular user file system using the destination VSP includes providing to the user a perception that the source VSP has migrated from the first physical storage processor to the second physical storage processor.

It should be understood that in the cloud context processing circuitry may be formed by remote computer resources distributed over a network. Such a computing environment is capable of providing certain advantages such as enhanced fault tolerance load balancing processing flexibility etc.

Other embodiments are directed to electronic systems and apparatus processing circuits computer program products and so on. Some embodiments are directed to various methods electronic components and circuitry which are involved in providing mobility to VSPs.

Embodiments of the invention will now be described. It is understood that such embodiments are provided by way of example to illustrate various features and principles of the invention and that the invention hereof is broader than the specific example embodiments disclosed.

An improved technique is directed to providing mobility to virtual storage processors VSPs which define operating environments for file systems accessed by host applications. Such mobility may involve effectively moving VSPs to different storage pools and thus providing flexibility to VSP management and storage utilization. Along these lines a VSP is capable of effectively being moved from one storage pool to another to take advantage of storage abundance opportunities. Such operation is even capable of providing perception to a user that a VSP has migrated from a first physical storage processor to a second physical storage processor.

It should be understood that the operations underlying such a VSP mobility technique are useful for a variety activities. For example such operations are suitable for VSP migration VSP load balancing VSP failover none disruptive upgrades of data storage apparatus having VSPs and so on.

In a typical virtual data mover arrangement the SP has a root file system with mount points to which the host file systems of each virtual data mover are mounted. Thus the SP and all its virtual data movers form a single large directory and all share a common namespace. Hosts can access their virtual data mover managed data by connecting to the SP over the network logging on and specifying paths relative to the SP s root where their data are kept. The typical arrangement thus requires hosts to access data of a virtual data mover using paths that are referenced to and dependent upon the root of the SP.

In addition settings for prescribing virtual data mover operations are conventionally stored in the root file system of the SP. Many of these settings are global to all virtual data movers operating on the SP others may be specific to particular virtual data movers.

Unfortunately the intermingling of virtual data mover content within an SP s root file system impairs the ease of mobility and management of virtual data movers. For example administrators wishing to move a virtual data mover e.g. its file systems settings and servers from one SP to another SP must typically perform many steps on a variety different data objects. File systems server configurations and other settings may need to be moved one at a time. Also as the contents of different virtual data movers are often co located care must be taken to ensure that changes affecting one virtual data mover do not disrupt the operation of other virtual data movers.

In contrast with the conventional approach an improved technique for managing host data in a data storage apparatus provides virtualized storage processors VSPs as substantially self describing and independent entities. Each VSP has its own namespace which is independent of the namespace of any other VSP. Each VSP also has its own network address. Hosts may thus access VSPs directly without having to include path information relative to the SP on which the VSPs are operated. VSPs can thus be moved from one physical SP to another with little or no disruption to hosts which may in many cases continue to access the VSPs on the new SPs using the same paths as were used to access the VSPs on the original SPs.

In some examples each VSP includes within its namespace a configuration file system storing configuration settings for operating the VSP. These configuration settings include for example network interface settings and internal settings that describe the VSPs personality i.e. the manner in which the VSP interacts on the network. By providing these settings as part of the VSP itself e.g. within the file systems of the VSP the VSP can be moved from one physical SP to another substantially as a unit. The increased independence of the VSP from its hosting SP promotes many aspects of VSP management including for example migration replication failover trespass multi tenancy load balancing and gateway support.

In some examples the independence of VSPs is further promoted by storing data objects of VSPs in the form of respective files. These data objects may include for example file systems LUNs virtual storage volumes vVols and virtual machine disks VMDKs . Each such file is part of a set of internal file systems of the data storage apparatus. Providing data objects in the form of files of a set of internal file systems promotes independence of VSPs and unifies management of file based objects and block based objects.

In accordance with improvements hereof certain embodiments are directed to a method of managing host data on a data storage apparatus connected to a network. The method includes storing a network address and a set of host data objects accessible within a namespace of a virtualized storage processor VSP operated by a physical storage processor of the data storage apparatus. The namespace includes only names of objects that are specific to the VSP. The method further includes receiving by the physical storage processor a transmission over the network from a host computing device. The transmission is directed to a network address and includes an IO request designating a pathname to a host data object to be written or read. The method still further includes identifying the host data object designated by the IO request by i matching the network address to which the transmission is directed with the network address stored for the VSP to identify the VSP as the recipient of the IO request and ii locating the host data object within the namespace of the VSP using the pathname. The IO request is then processed to complete the requested read or write operation on the identified host data object.

Other embodiments are directed to computerized apparatus and computer program products. Some embodiments involve activity that is performed at a single location while other embodiments involve activity that is distributed over a computerized environment e.g. over a network .

An improved technique for managing host data in a data storage apparatus provides virtualized storage processors VSPs as substantially self describing and independent constructs.

The network can be any type of network such as for example a storage area network SAN local area network LAN wide area network WAN the Internet some other type of network and or any combination thereof. In an example the hosts N connect to the SP using various technologies such as Fibre Channel iSCSI NFS SMB 3.0 and CIFS for example. Any number of hosts N may be provided using any of the above protocols some subset thereof or other protocols besides those shown. As is known Fibre Channel and iSCSI are block based protocols whereas NFS SMB 3.0 and CIFS are file based protocols. The SP is configured to receive IO requests N in transmissions from the hosts N according to both block based and file based protocols and to respond to such IO requests N by reading or writing the storage .

The SP is seen to include one or more communication interfaces control circuitry e.g. a set of processors and memory . The communication interfaces include for example adapters such as SCSI target adapters and network interface adapters for converting electronic and or optical signals received from the network to electronic form for use by the SP . The set of processors includes one or more processing chips and or assemblies. In a particular example the set of processors includes numerous multi core CPUs. The memory includes both volatile memory e.g. RAM and non volatile memory such as one or more ROMs disk drives solid state drives SSDs and the like. The set of processors and the memory are constructed and arranged to carry out various methods and functions as described herein. Also the memory includes a variety of software constructs realized in the form of executable instructions. When the executable instructions are run by the set of processors the set of processors are caused to carry out the operations of the software constructs. Although certain software constructs are specifically shown and described it is understood that the memory typically includes many other software constructs which are not shown such as various applications processes and daemons.

As shown the memory includes an operating system such as Unix Linux or Windows for example. The operating system includes a kernel . The memory is further seen to include a container . In an example the container is a software process that provides an isolated userspace execution context within the operating system . In various examples the memory may include multiple containers like the container with each container providing its own isolated userspace instance. Although containers provide isolated environments that do not directly interact and thus promote fault containment different containers can be run on the same kernel and can communicate with one another using inter process communication IPC mediated by the kernel . Containers are well known features of Unix Linux and other operating systems.

In the example of only a single container is shown. Running within the container is an IO stack and multiple virtualized storage processors VSPs . The IO stack provides an execution path for host IOs e.g. N and includes a front end and a back end . The VSPs each run within the container and provide a separate context for managing host data. In an example each VSP manages a respective set of host file systems and or other data objects and uses servers and settings for communicating over the network with its own individual network identity. Although three VSPs are shown it is understood that the SP may include as few as one VSP or as many VSPs as the computing resources of the SP and storage resources of the storage allow.

Although the VSPs each present an independent and distinct identity it is evident that the VSPs are not in this example implemented as independent virtual machines. Rather all VSPs operate in userspace and employ the same kernel of the SP . Although it is possible to implement the VSPs as independent virtual machines each including a virtualized kernel it has been observed that VSPs perform faster when the kernel is not virtualized.

Also it is observed that the VSPs all run within the container i.e. within a single userspace instance. Again the arrangement shown reflects a deliberate design choice aimed at optimizing VSP performance. It is understood though that alternative implementations could provide different VSPs in different containers or could be provided without containers at all.

The memory is further seen to store a configuration database . The configuration database stores system configuration information including settings related to the VSPs and their data objects. In other implementations the configuration database is stored elsewhere in the data storage apparatus such as on a disk drive separate from the SP but accessible to the SP e.g. over a backplane or network.

In operation the hosts N issue IO requests N to the data storage apparatus . The IO requests N may include both block based requests and file based requests. The SP receives the IO requests N at the communication interfaces and passes the IO requests to the IO stack for further processing.

At the front end of the IO stack processing includes associating each of the IO requests N with a particular one of the VSPs . In an example each VSP stores a network address e.g. an IP address in a designated location within its file systems. The front end identifies the network address to which each IO request is directed and matches that address with one of the network addresses stored with the VSPs . The front end thus uses the network address to which each IO request is sent to identify the VSP to which the IO request is directed. Further processing of the IO request is then associated e.g. tagged with an identifier of the matching VSP such that the IO request is processed within a particular VSP context. Any data logging metrics collection fault reporting or messages generated while the IO request is being processed are stored with the associated VSP e.g. in a file system dedicated to the VSP . Also any path information provided with the IO request e.g. to a particular directory and file name is interpreted within the namespace of the identified VSP.

Processing within the front end may further include caching data provided with any write IOs and mapping host data objects e.g. host file systems LUNs vVols VMDKs etc. to underlying files stored in a set of internal file systems. Host IO requests received for reading and writing both file systems and LUNs are thus converted to reads and writes of respective files. The IO requests then propagate to the back end where commands are executed for reading and or writing the physical storage .

In an example processing through the IO stack is performed by a set of threads maintained by the SP in a set of thread pools. When an IO request is received a thread is selected from the set of thread pools. The IO request is tagged with a VSP identifier and the selected thread runs with the context of the identified VSP. Typically multiple threads from different thread pools contribute to the processing of each IO request there are many processing layers . Multiple threads from the thread pools can process multiple IO requests simultaneously i.e. in parallel on the data objects of any one VSP or multiple VSPs.

Although shows the front end and the back end together in an integrated form the front end and back end may alternatively be provided on separate SPs. For example the IO stack may be implemented in a modular arrangement with the front end on one SP and the back end on another SP. The IO stack may further be implemented in a gateway arrangement with multiple SPs running respective front ends and with a back end provided within a separate storage array. The back end performs processing that is similar to processing natively included in many block based storage arrays. Multiple front ends can thus connect to such arrays without the need for providing separate back ends. In all arrangements processing through both the front end and back end is preferably tagged with the particular VSP context such that the processing remains VSP aware.

The storage pool organizes elements of the storage in the form of slices. A slice is an increment of storage space such as 256 MB in size which is obtained from the storage . The pool may allocate slices to lower deck file systems for use in storing their files. The pool may also deallocate slices from lower deck file systems if the storage provided by the slices is no longer required. In an example the storage pool creates slices by accessing RAID groups formed from the storage dividing the RAID groups into FLUs Flare LUNs and further dividing the FLU s into slices.

Continuing with reference to the example shown in a user object layer includes a representation of a LUN and of an HFS host file system and a mapping layer includes a LUN to file mapping and an HFS to file mapping . The LUN to file mapping maps the LUN to a first file F and the HFS to file mapping maps the HFS to a second file F . Through the LUN to file mapping any set of blocks identified in the LUN by a host IO request is mapped to a corresponding set of blocks within the first file . Similarly through the HFS to file mapping any file or directory of the HFS is mapped to a corresponding set of blocks within the second file . The HFS is also referred to herein as an upper deck file system which is distinguished from the lower deck file systems which are for internal use.

In this example a first lower deck file system includes the first file and a second lower deck file system includes the second file . Each of the lower deck file systems and includes an inode table and respectively . The inode tables and provide information about files in respective lower deck file systems in the form of inodes. For example the inode table of the first lower deck file system includes an inode which provides file specific information about the first file . Similarly the inode table of the second lower deck file system includes an inode which provides file specific information about the second file . The information stored in each inode includes location information e.g. block locations where the respective file is stored and may thus be accessed as metadata to identify the locations of the files and in the storage .

Although a single file is shown for each of the lower deck file systems and it is understood that each of the lower deck file systems and may include any number of files each with its own entry in the respective inode table. In one example each lower deck file system stores not only the file F or F for the LUN or HFS but also snaps of those objects. For instance the first lower deck file system stores the first file along with a different file for every snap of the LUN . Similarly the second lower deck file system stores the second file along with a different file for every snap of the HFS .

As shown a set of slices is allocated by the storage pool for storing the first file and the second file . In the example shown slices S through S are used for storing the first file and slices S through S are used for storing the second file . The data that make up the LUN are thus stored in the slices S through S whereas the data that make up the HFS are stored in the slices S through S.

In some examples each of the lower deck file systems and is associated with a respective volume such as a sparse LUN. Sparse LUNs provide an additional layer of mapping between the lower deck file systems and the pool and allow the lower deck file systems to operate as file systems normally do by accessing underlying volumes. Additional details about sparse LUNs and their relation to lower deck file systems may be found in U.S. Pat. No. 7 631 155 which is hereby incorporated by reference in its entirety. The incorporated patent uses the term container file system to refer to a construct similar to the lower deck file system disclosed herein.

Although the example of shows storage of a LUN and a host file system in respective lower deck file systems and it is understood that other data objects may be stored in one or more lower deck file systems in a similar manner. These may include for example file based vVols block based vVols and VMDKs.

For example the VSP includes a first lower deck file system and a second lower deck file system . The first lower deck file system includes a file FA which provides a file representation of a first host file system . Similarly the second lower deck file system includes a file FB which provides a file representation of a second host file system . The host file systems and are upper deck file systems which may be made available to hosts N for storing file based host data. HFS to file mappings like the HFS to file mapping are understood to be present although not shown in for expressing the files FA and FB in the form of upper deck file systems. Although only two host file systems and are shown it is understood that the VSP may include any number of host file systems. In an example a different lower deck file system is provided for each host file system. The lower deck file system stores the file representation of the host file system and if snaps are turned on any snaps of the host file system. In a similar manner to that described in connection with each of the lower deck file systems and includes a respective inode table allowing the files FA and FB and their snaps to be indexed within the respective lower deck file systems and accessed within the storage .

In some examples the VSP also includes one or more lower deck file systems for storing file representations of LUNs. For example a lower deck file system stores a file FC which provides a file representation of a LUN . A LUN to file mapping not shown but similar to the mapping expresses the file FC in the form of a LUN which may be made available to hosts N for storing block based host data. In an example the lower deck file system stores not only the file FC but also snaps thereof and includes an inode table in essentially the manner described above.

The VSP further also includes a lower deck file system . In an example the lower deck file system stores file representations FD and FE of two internal file systems of the VSP a root file system and a configuration file system . In an alternative arrangement the files FD and FE are provided in different lower deck file systems. In an example the lower deck file system also stores snaps of the files FD and FE and files are accessed within the lower deck file system via file system to file mappings and using an inode table substantially as described above.

In an example the root file system has a root directory designated with the slash and sub directories as indicated. Any number of sub directories may be provided within the root file system in any suitable arrangement with any suitable file structure the example shown is merely illustrative. As indicated one sub directory Local stores for example within constituent files information about the local environment of the SP such as local IP sub net information geographical location and so forth. Another sub directory Rep stores replication information such as information related to any ongoing replication sessions. Another sub directory Cmd Svc stores command service information and yet another sub directory MPs stores mount points.

In the example shown the directory MPs of the root file system provides mount points e.g. directories on which file systems are mounted. For example the host file systems and are respectively mounted on mount points MP and MP and the configuration file system is mounted on the mount point MP. In an example establishment of the mount points MP MP and execution of the mounting operations for mounting the file systems onto the mount points MP MP are provided in a batch file stored in the configuration file system e.g. in Host Objects . It is understood that additional mount points may be provided for accommodating additional file systems.

The root file system has a namespace which includes the names of the root directory sub directories and files that belong to the root file system . The file systems and also each have respective namespaces. The act of mounting the file systems and onto the mount points MP MP and MP of the root file system serves to join the namespace of each of the file systems and with the namespace of the root file system to form a single namespace that encompasses all the file systems and . This namespace is specific to the VSP and is independent of namespaces of any other VSPs.

Also it is understood that the LUN is also made available to hosts through the VSP . For example hosts can send read and write IO requests to the LUN e.g. via Fibre Channel and or iSCSI commands and the SP services the requests for the VSP e.g. by operating threads tagged with the context of the VSP . Although shows both the LUN and the host file systems and together in a single VSP other examples may provide separate VSPs for LUNs and for file systems.

Although the VSP is seen to include file systems and LUNs other host objects may be included as well. These include for example file based vVols block based vVols and VMDKs. Such host objects may be provided as file representations in lower deck file systems and made available to hosts 

As its name suggests the configuration file system stores configuration settings for the VSP . These settings include settings for establishing the personality of the VSP i.e. the manner in which the VSP interacts over the network . Although the configuration file system is shown with a particular directory structure it is understood that any suitable directory structure can be used. In an example the configuration file system stores the following elements 

IF Config. Interface configuration settings of any network interface used for processing IO requests and tagged with a context of the VSP . IF Config includes the IP address of the VSP as well as related network information such as sub masks and related IP information.

CIFS. Configuration settings and names of one or more CIFS servers used in the context of the VSP . The CIFS servers manage IO requests provided in the CIFS protocol. By including the CIFS configuration within the configuration file system the CIFS configuration becomes part of the VSP itself and remains with the VSP even as the VSP is moved from one SP to another SP. This per VSP configuration of CIFS also permits each VSP to have its own customized CIFS settings which may be different from the settings of CIFS servers used by other VSPs.

NFS. Configuration settings and names of one or more NFS servers used in the context of the VSP . The NFS servers manage IO requests provided in the NFS protocol. By including the NFS configuration within the configuration file system the NFS configuration becomes part of the VSP itself and remains with the VSP even as the VSP is moved from one SP to another SP. This per VSP configuration of NFS also permits each VSP to have its own customized NFS settings which may be different from the settings of NFS servers used by other VSPs.

Exports. NFS exports CIFS shares and the like for all supported protocols. For security and management of host access users are typically given access only to specified resources mounted to the root file system e.g. host file systems sub directories of those file systems and or particular LUNs. Access to these resources is provided by performing explicit export share operations which expose entry points to the resources for host access. In an example these export share operations are included within one or more batch files which may be executed when the VSP is started. Exports are typically VSP specific and depend upon the particular data being hosted and the access required.

CAVA NDMP CAVA Celerra Anti Virus Agent configuration file including location of external server for performing virus checking operations. NDMP Network Data Management Protocol provides backup configuration information. CAVA and NDMP settings are configurable on a per VSP basis.

NIS DNS LDAP Local configurations and locations of external servers for providing resolution of IP addresses. NIS Network Information Service DNS Directory Name System and LDAP Lightweight Directory Access Protocol settings are configurable on a per VSP basis. The DNS configuration stores local host name and domain name of the VSP as well as the location of a DNS server for resolving host names.

Host Objects Identifiers for all host file systems e.g. and LUNs e.g. LUN and other host objects included within the VSP . Host objects may also include batch files and or lists of instructions for establishing mount points in the root file system and for mounting the host file system s and LUN s to the mount points.

Parameters Low level settings e.g. registry settings for configuring VSP . These include cache settings and settings for specifying a maximum number of threads running on the SP that may be used to service IO requests within the context of the VSP . Parameters are configurable on a per VSP basis.

Statistics Metrics log files and other information pertaining to activities within the context of the VSP . Statistics are updated as they accumulate. Many configuration settings are established at startup of the VSP . Some configuration settings are updated as the VSP is operated. The configuration file system preferably does not store host data.

Although has been shown and described with reference to a particular VSP it is understood that all of the VSPs may include a root file system a configuration file system and at least one host file system or LUN substantially as shown. Particular host objects and configuration settings differ however from one VSP to another.

By storing the configuration settings of VSPs within the file systems of the VSPs themselves and providing a unique namespace for each VSP VSPs are made to be highly independent both of other VSPs and of the particular SPs on which they are provided. For example migrating a VSP from a first data storage system to a second data storage system involves copying its lower deck file systems or some subset thereof from a source SP on the first data storage system to a target SP on the second starting the VSP s servers on the target SP in accordance with the configuration settings and resuming operation on the target SP. As the paths for accessing data objects on VSPs are not rooted to the SPs on which they are run hosts may often continue to access migrated VSPs using the same instructions as were used prior to moving the VSPs. Similar benefits can be enjoyed when moving a VSP from one SP to another SP in the same data storage system. To move a VSP from a first SP to a second SP The VSP need merely be shut down i.e. have its servers stopped on the first SP and resumed i.e. have its servers started up again on the second SP.

Although shows only a single record for a single VSP it is understood that the configuration database may store records like the record for any number of VSPs including all VSPs of the data storage apparatus . During start up of the data storage apparatus or at some other time a computing device of the data storage apparatus reads the configuration database and launches a particular VSP or a group of VSPs on the identified SPs. As a VSP is starting the SP that owns the VSP reads the configuration settings of the configuration file system to configure the various servers of the VSP and to initialize its communication protocols. The VSP may then be operated on the identified SP i.e. the SP may then be operated with the particular VSP s context.

It is understood that VSPs operate in connection with the front end of the IO stack . The VSPs thus remain co located with their respective front ends in modular and gateway arrangements.

At step a network address and a set of host data objects are stored in a data storage apparatus. The set of host data objects are accessible within a namespace of a virtualized storage processor VSP operated by a physical storage processor of the data storage apparatus. The namespace includes only names of objects that are specific to the VSP. For example an IP address of the VSP is stored in a file of a directory of the configuration file system . The VSP runs on the SP of the data storage apparatus . A set of host objects including host file systems and and LUN are also stored in the data storage apparatus . These host objects are made accessible within the namespace of the VSP by mounting these data objects to mount points MP MP within the root file system and thus merging their namespaces with that of the root file system . The resulting merged namespace includes only names of objects that are specific to the VSP .

At step a transmission is received by the physical storage processor over the network from a host computing device. The transmission is directed to a network address and includes an IO request designating a pathname to a host data object to be written or read. For example the SP receives a transmission over the network from one of the hosts N . The transmission is directed to a particular IP address and includes an IO request e.g. one of N . The IO request designates a location of a host data object to be written or read e.g. a pathname for a file based object or a block designation for a block based object . The location may point to any of the host file systems or to the LUN or to any file or offset range accessible through the host file systems or or the LUN respectively. The location may also point to a vVol or VMDK for example or to any other object which is part of the namespace of the VSP .

At step the host data object designated by the IO request is identified by i matching the network address to which the transmission is directed with the network address stored for the VSP to identify the VSP as the recipient of the IO request and ii locating the host data object within the namespace of the VSP using the pathname. For example each of the VSPs stores an IP address in its configuration file system . When an IO request is received an interface running within the front end of the IO stack checks the IP address to which the IO request is directed and matches that IP address with one of the IP addresses stored for the VSPs . The VSP whose IP address matches the IP address to which the IO request is directed is identified as the recipient of the IO request. The IO request arrives to the SP with a pathname to the host data object to be accessed. The front end looks up the designated pathname within the identified VSP to identify the particular data object to which the IO request is directed.

At step the IO request is processed to complete the requested read or write operation on the identified host data object. For example the front end and the back end process the IO request to perform an actual read or write to the designated host data object on the storage .

An improved technique has been described for managing host data in a data storage apparatus. The technique provides virtualized storage processors VSPs as substantially self describing and independent entities. Each VSP has its own namespace which is independent of the namespace of any other VSP. Each VSP also has its own network address. Hosts may thus access VSPs directly without having to include path information relative to the SP on which the VSP is operated. VSPs can thus be moved from one physical SP to another with little or no disruption to hosts which may continue to access the VSPs on the new SPs using the same paths as were used when the VSPs were running on the original SPs.

As used throughout this document the words comprising including and having are intended to set forth certain items steps elements or aspects in an open ended fashion. Also and unless explicitly indicated to the contrary the word set as used herein indicates one or more of something. Although certain embodiments are disclosed herein it is understood that these are provided by way of example only and the invention is not limited to these particular embodiments.

Having described certain embodiments numerous alternative embodiments or variations can be made. For example embodiments have been shown and described in which host file systems LUNs vVols VMDKs and the like are provided in the form of files of underlying lower deck file systems. Although this arrangement provides advantages for simplifying management of VSPs and for unifying block based and file based operations the use of lower deck file systems is merely an example. Indeed host file systems LUNs vVols VMDKs and the like may be provided for VSPs in any suitable way.

Also although the VSPs are shown and described as userspace constructs that run within the container this is also merely an example. Alternatively different VSPs may be provided in separate virtual machines running on the SP . For example the SP is equipped with a hypervisor and a virtual memory manager and each VSP runs in a virtual machine having a virtualized operating system.

Also the improvements or portions thereof may be embodied as a non transient computer readable storage medium such as a magnetic disk magnetic tape compact disk DVD optical disk flash memory Application Specific Integrated Circuit ASIC Field Programmable Gate Array FPGA and the like shown by way of example as medium in . Multiple computer readable media may be used. The medium or media may be encoded with instructions which when executed on one or more computers or other processors implement the various methods described herein. Such medium or media may be considered an article of manufacture or a machine and may be transportable from one machine to another.

Initially and by way of example suppose that the configuration database of the source site data storage apparatus A includes a particular database record for a particular VSP also see . The particular VSP defined by the particular database record has a root file system and appropriate mount points on which to mount other file systems.

Further suppose that the particular database record and or other records of the configuration database define other file systems which are mounted to the root file system of the particular VSP. In this example and as shown in see dashed lines a VSP configuration file system VSP Config and two user file systems FS FS are mounted to the root file system of the particular VSP.

As described earlier in connection with the VSP configuration file system VSP Config includes VSP configuration data which defines an operating environment for the particular VSP e.g. a network address CIFS settings NFS settings and so on . Accordingly the personality or identity of the particular VSP is defined by the VSP configuration data in the VSP configuration file system.

The user file systems FS FS include host data provided by host applications. Since the VSP configuration file system VSP Config defines the operating environment for the user file systems FS FS accessibility of any replicas of the user file systems FS FS requires presence of the VSP configuration file system VSP Config .

Now suppose that a user e.g. an administrator of the data storage system wishes to replicate the particular VSP and the file systems which are mounted to the particular VSP to the destination site data storage apparatus B . Prior to starting replication the user may have created an interconnect between the source site data storage apparatus A and the destination site data storage apparatus B i.e. a secure and reliable communications pathway . Additionally the root file system of the particular VSP may have already been created and the user may have already mounted the various files systems to the root file system. Accordingly records in the configuration database have been updated to reflect this activity.

At this point the user is ready to simply enter a single replication command. That is rather than separately enter replication commands to begin replication sessions for each file system as in a conventional approach all the user needs to do is enter one replication command to effectuate such replication. Additionally the entire lifecycle of a replication session i.e. create delete reverse switchover modify failover stop start etc. which otherwise applies at the file system level now applies at the VSP level. Furthermore replication of the internals of the VSP e.g. the root the VSP configuration data etc. are entirely hidden from the end user who simply manages the replication session. A suitable syntax for such a single replication command is 

where nas replicate is the specific instruction create all is an option directing replication of all mounted file systems source src VSP is an option identifying the particular VSP src VSP of the source site data storage apparatus A and destination dest VSP is an option identifying a corresponding VSP dest VSP to be created on the destination site data storage apparatus B . Other options can be included as well such as an option that identifies a particular pre established interconnect by name another option that specifies a maximum time in which the VSPs can be out of sync e.g. 30 seconds one minute etc. and so on.

In response to the single replication command the processing circuitry of the source site data storage apparatus A accesses the configuration database to identify which file systems are mounted to the root file system of the particular VSP. In the context of a set of processors executing software it should be understood that executable code for carrying out automated creation of multiple replication sessions may reside in the front end of the IO stack also see .

In this example the processing circuitry sees that there are at least three files systems i.e. the VSP configuration file system and two user files systems that are mounted to the root file system of the particular VSP which are to be replicated. Accordingly the processing circuitry automatically creates multiple replications sessions to replicate the mounted file systems.

In particular the processing circuitry makes sure that a corresponding root file system exists on the data storage apparatus B at the destination site and if not directs the data storage apparatus B to create a corresponding root file system . The processing circuitry then creates a VSP configuration file system replication session C to replicate the VSP configuration file system. Additionally the processing circuitry creates user file system replication sessions FS FS to replicate the user file systems FS FS. Each replication session properly mounts a respective file system to the root file system of the data storage apparatus B and begins file system replication e.g. synchronous replication asynchronous replication snap etc. . It should be understood that each replication session is independent and independent and operates in a standalone manner with respect to the other replication sessions .

With replication of the VSP configuration file system in place the operating environment at the destination site is now established to enable reliable and robust access to the user files system via the destination data storage apparatus B e.g. read only access while the source data storage apparatus A operates as the source site.

However in response to a failover event in which replication of a user file system is stopped the circuitry of the destination data storage apparatus B transitions that user file system at the destination data storage apparatus B from a host read only state to a host read write state. Such operation enables read write access to continue at the destination data storage apparatus B while other replication sessions of the multiple replication sessions continue to operate in their original states.

At this point it should be understood that various other replication related operations are suitable for use in combination with the above described VSP replication activities. For example the automatically created replication sessions can be stopped started reversed switched over deleted and so on. Furthermore such sessions can be controlled in the aggregate together as a group or individually in response to other user commands.

At in response to the VSP replication command the processing circuitry identifies multiple source data objects which are configured to store data from the context of the source VSP e.g. the source data objects store data using an operating environment which is defined by the source VSP . Along these lines the configuration database stores a set of records which indicates which file systems are mounted to the root file system of the source VSP and among the files systems is a configuration file system storing VSP configuration data i.e. VSP personality information also see . Recall that the data objects may be lower deck files of lower deck file systems containing as the user file systems upper deck file systems formed of upper deck files also see .

At after the multiple source data objects are identified the processing circuitry automatically creates multiple replication sessions to replicate the multiple source data objects as multiple destination data objects which are configured to store data from the context of the destination VSP. During these replication sessions block changes are conveyed from source site to the destination site through the communications medium e.g. a WAN .

As described above improved techniques are directed to automatically creating multiple replication sessions in response to a single replication command from a user. Such a command directs creation of a VSP replication session C to reliably and robustly replicate a file system environment and further directs creation of standalone file system replication sessions FS FS . . . to replicate separate user file systems FS FS . . . . Along these lines the necessary replication information for creating the replication sessions can be derived in an automated manner from records in a configuration database . Accordingly the user is required to simply enter one replication command regardless of the number of user file systems being replicated and the data storage system topology. As a result there is little or no opportunity for error and the work of the user is less tedious and time consuming.

It should be understood that the above described techniques are suitable for complex topologies such as one to many configurations and cascade configurations. For such topologies a single replication command from the user may establish many replications sessions automatically e.g. 10 50 more than 100 etc.

Additionally it should be understood that the above described replication techniques are appropriate for synchronous replication asynchronous replication snapshots copy sessions and so on. Moreover the above described replication techniques do not preclude the data storage system from offering the ability to create sessions individually. Rather such techniques are available to the user when appropriate and may be used in combination with conventional approaches.

Furthermore the above described replication command was described above as being entered by a user by way of example only. In other arrangements the replication command is can be called automatically e.g. via a script from a program as part of an application programming interface API and so on.

Additionally it should be understood that data within a VSP configuration file system of a VSP on the source side may be overwritten at session failover time with data from a VSP configuration file system of a VSP on the destination side. Such an operation may occur for instance when the network configuration on the destination side was not compatible with that of the source side and had to be modified.

As shown in there are two storage pools A B a user interface and a configuration database . Each storage pool is formed from a different set of storage units. That is storage pool A is formed from a first set of storage units. Additionally storage pool B is formed from a second set of storage units that is mutually exclusive with respect to the first set of storage units.

As shown in the storage pool A provides storage for VSPs A A . In particular a lower deck file A contains a VSP configuration file system A which defines a personality for the VSP A also see . Similarly another lower deck file A contains another VSP configuration file system A which defines a personality for the VSP A .

Additionally and as shown in a lower deck file A contains a host file system A for use by a host. Similarly another lower deck file A contains another host file system A for use by a host. Recall that the VSP configuration file systems and host file systems are mounted to the respective root file systems or root structures of the VSPs also see .

Furthermore and as shown in the storage pool B provides storage for a VSP B . In particular a lower deck file B contains a VSP configuration file system B which defines a personality for the VSP B and a lower deck file B contains a host file system B for use by a host. Again the VSP configuration file system B and the host file system B are mounted to the root file system of the VSP B .

During operating time T it should be understood that the processing circuitry of the data storage apparatus processes host input output I O requests directed to the host file system A using the VSP A . Now suppose that a user e.g. a data storage administrator wishes to move the VSP A from the storage pool A to the storage pool B . Along these lines the user may have recently added new storage to the storage pool B . Alternatively the user may have recently deleted a significant amount of data from storage pool B thus enabling a significant amount of unused slices to be reclaimed for reuse. Other situations may exist which give rise to the user wishing to move the VSP A as well.

To move the VSP A from the storage pool A to the storage pool B the user issues a move command . In particular the user enters the move command into the user interface e.g. a command line interface or GUI of the data storage apparatus also see . A suitable syntax may be as follows 

where nas move is the specific instruction name source src VSP is an option identifying the source VSP poolA VSP and destination poolB is an option identifying a destination. A variety of destination types are suitable for use such as simply another storage pool location as shown above a combination of destination VSP pool and a destination VSP name another physical storage processor a new data storage apparatus and so on. Furthermore other options can be included such as an option that identifies a particular pre established interconnect by name another option that specifies a maximum time in which the VSPs can be out of sync during movement e.g. 30 seconds one minute etc. and so on.

In response to the move command the processing circuitry of the data storage apparatus effectively moves the VSP A from storage pool A to storage pool B . In particular the processing circuitry accesses the records of the configuration database also see to identify the VSP root file system and to identify which file systems are mounted to the VSP root file system.

The processing circuitry then effectuates VSP mobility using replication illustrated by the arrow in . In particular a new root file system is created for a new VSP . Additionally replication sessions are created to respectively replicate the VSP configuration file system A contained in the lower deck file A and the host file system A contained in the lower deck file A to the storage pool B .

Once the file systems are fully replicated the processing circuitry terminates the replication sessions and activates or operates using the new VSP. Such activity may involve deleting replication sessions and updating the configuration database to delete the source VSP A and to indicate that the replicated file systems are now mounted to a new VSP . Accordingly the user perceives a source VSP as having moved from the storage pool A to the storage pool B .

It should be understood that the destination storage pool for a VSP may be the same data storage apparatus or a different data storage apparatus . Additionally the physical storage processor that owns the destination VSP may be the same physical storage processor that owned the source VSP a different physical storage processor of the same data storage apparatus or a physical storage processor of another data storage apparatus . Accordingly VSP mobility provides significant flexibility for managing storage.

At in response to the VSP move command the data storage apparatus identifies multiple source data objects which are configured to store data from the context of the source VSP the multiple source data objects residing in a source storage pool. In particular the data storage apparatus identifies from records in the configuration database the file systems contained by lower deck files residing in the source storage pool also see .

At after the multiple source data objects are identified the data storage apparatus transforms the multiple source data objects into multiple destination data objects which are configured to store data from the context of a destination VSP at the destination the multiple destination data objects residing in a destination storage pool which is different from the source storage pool also see the replication sessions in and the resulting operating situation in .

As described above improved techniques are directed providing mobility to VSPs which define operating environments for file systems accessed by host applications. Such mobility may involve effectively moving VSPs to different storage pools and thus improving flexibility and storage utilization. For example a VSP is capable of effectively being moved from one storage pool A to another storage pool B see to take advantage of storage abundance opportunities. Such operation is even capable of providing a perception that a VSP has migrated from a first physical storage processor to a second physical storage processor .

While various embodiments of the present disclosure have been particularly shown and described it will be understood by those skilled in the art that various changes in form and details may be made therein without departing from the spirit and scope of the present disclosure as defined by the appended claims.

For example it should be understood that VSP mobility was described above as utilizing replication as a transport mechanism by way of example only. In other arrangements a different transport mechanism is used or included in combination with replication. In a particular arrangement a transport mechanism such as IMT In band Migration Tool is utilized to translate files systems from one format to another e.g. from UFS32 to UFS 64 as the file systems are copied to a new destination.

Additionally the source VSP was described a being removed and the replication sessions were described above as being deleted by way of example only. In some arrangements it may be worthwhile to leave the source VSP in place and or reverse the replication sessions e.g. for failover in the reverse direction. Other non deletion activities are suitable as well.

Furthermore the above described VSP move command was described above as being entered by a user by way of example only. In other arrangements the VSP move command is can be called automatically e.g. via a script from a program as part of an application programming interface API and so on.

Further although features are shown and described with reference to particular embodiments hereof such features may be included in any of the disclosed embodiments and their variants. Thus it is understood that features disclosed in connection with any embodiment can be included as variants of any other embodiment whether such inclusion is made explicit herein or not. Those skilled in the art will therefore understand that various changes in form and detail may be made to the embodiments disclosed herein without departing from the scope of the disclosure. Such modifications and enhancements are intended to belong to various embodiments of the disclosure.

