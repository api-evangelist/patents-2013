---

title: Methods and systems for machine learning to discover application compatibility status
abstract: A system and method is provided for discovering application compatibility status, the method being performed by one or more processors, the method comprising receiving a request for determining compatibility of a first application with a platform and organizing a plurality of data points associated with the first application into a plurality of elements. The method also comprises comparing the plurality of elements with a plurality of elements associated with one or more analyzed applications, wherein the one or more analyzed applications have been previously analyzed for compatibility with the platform. The method further comprises identifying a compatibility status of the first application with the platform based on the comparison; and providing, for display, the compatibility status of the first application.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09330184&OS=09330184&RS=09330184
owner: Cltirix Systems, Inc.
number: 09330184
owner_city: Fort Lauderdale
owner_country: US
publication_date: 20131202
---
The present disclosure generally relates to application compatibility with different platforms. Exemplary embodiments relate to methods and systems for machine learning to discover application compatibility status for a given platform.

Today s rapidly changing technology requires application users to migrate from one platform to another such as Windows 7 to Windows 8 or changes to runtime environment such as App V every couple of years. For every instance of such migration users have to validate each application to ensure compatibility of the application for the migrated platform. This process might need to be repeated for every major and or minor new release of a given platform. As users demand new and improved features the frequency of updating platforms increases thereby also increasing the importance of the migration from one platform or version to another.

Such migration is critical for enterprise users running thousands of applications for any given project on any given platform. And each such application can be associated with many different algorithms. That is verification of applications and their associated algorithms for any given platform can be very complex and time consuming. Traditionally such migration and verification is implemented manually costing the organization a significant number of man hours or months or years and cost.

While a number of current techniques can be used to perform an accurate analysis to detect compatibility of an application across different platforms the current techniques often involve manual testing of hundreds of applications using diagnostic tools such as process monitoring and debuggers to discover any defects. A disadvantage for such a process is the specialized knowledge required by a person in charge of the testing.

Another drawback with the current techniques is the occasional false positive showing that an application is not compatible with a platform whereas in reality that application is indeed compatible. A reduction in the percentage of false positives is useful for application users especially when migrating between platforms.

Reference will now be made in detail to the exemplary embodiments consistent with the embodiments disclosed herein the examples of which are illustrated in the accompanying drawings. Wherever possible the same reference numbers will be used throughout the drawings to refer to the same or like parts. In this disclosure the phrase platform is used to convey that a platform can be any software platform. For example a software platform can be a Windows based platform e.g. Windows 8 an Apple based platform Mac OS X or a mobile based platform such as Apple iOS . It will be understood in some embodiments that platform can also mean a hardware platform.

The present disclosure generally relates to application compatibility to different platforms. Exemplary embodiments relate to methods and systems for machine learning to discover application compatibility status for a given platform.

One or more client devices A F are devices that can acquire remote services from data center through various means. Client devices A F can communicate with data center either directly e.g. client device E or indirectly through a public network e.g. client devices A D or a private network e.g. client device F . When client device communicates through public network or private network a communication link can be established. For example a communication link can be established by public network thereby providing a client device e.g. client devices A D access to data center . A communication link can also be established by private network thereby providing a client device e.g. client device F access to data center . While client devices A F are portrayed as a computer e.g. client devices A E and F a laptop e.g. client device B a tablet e.g. client device C and a mobile smart phone e.g. client device D it is appreciated that client device could be any type of device that communicates packets to and from data center . For example client devices A F can be referred to as a computing device an electronic device a mobile device a communications device and the like.

Public network and private network can be any type of network such as a wide area network WAN a local area network LAN or a metropolitan area network MAN . As an example a WAN can be the Internet or the World Wide Web and a LAN can be a corporate Intranet. Public network and private network can be a wired network a wireless network or a combination of both.

Data center can be a central repository either physical or virtual for the storage management and dissemination of data and information pertaining to a particular public or private entity. Data center can be used to house computer systems and associated components such as one or physical servers virtual servers and storage systems. Data center can include among other things one or more servers e.g. server a desktop delivery controller a virtual desktop applications and a backend system .

Server can be an entity represented by an IP address and can exist as a single entity or a member of a server farm. Server can be a physical server or a virtual server. In some embodiments server can include a hardware layer an operating system and a hypervisor creating or managing one or more virtual machines. Server can provide one or more services to an endpoint. These services can include providing one or more desktops operating on one or more platforms and one or more applications to one or more endpoints e.g. client devices A F . For example the one or more applications can include Windows or SAP based applications and computing resources. In some embodiments server can provide application compatibility services. For example application compatibility between one platform to another e.g. Window 7 to Windows 8 can be performed at server . Moreover the compatibility services can include application migration services.

Desktop delivery controller can be a device that enables delivery of services such as virtual desktops to client devices e.g. client devices A F . Desktop delivery controller can provide functionality required to manage maintain and optimize all virtual desktop communications. In some embodiments desktop delivery controller can control manage maintain or optimize the provisioning of applications . In some embodiments controlling managing maintaining or optimizing the provisioning of applications can be implemented for one or more platforms. That is desktop delivery controller can enable delivery of application migration and compatibility services for one or more platforms.

In some embodiments one or more virtual desktops can provide one or more applications . Virtual desktops can include hosted shared desktops allowing multiple users to access a single shared remote desktop services desktop virtual desktop infrastructure desktops allowing each user to have their own virtual machine streaming disk images a local virtual machine individual applications e.g. one or more applications or a combination thereof. In some embodiments applications can be associated with one or more platforms. That is one or more virtual desktops can provide one or more applications that can be used to verify application compatibility and application migration corresponding to a platform.

Backend system can be a single or multiple instances of computer networking hardware appliances or servers in a server farm or a bank of servers. Backend system can interface directly or indirectly with server . For example backend system can include Microsoft Active Directory which can provide a number of network services including lightweight directory access protocol LDAP directory services Kerberos based authentication domain name system DNS based naming and other network information and synchronization of directory updates amongst several servers. Backend system can also include among other things an Oracle backend server a SQL Server backend and or a dynamic host configuration protocol DHCP . Backend system can provide data services or a combination of both to data center which can then provide that information via varying forms to client devices or branch office not shown .

As shown in each computing device such as server or a client device interfacing with server includes a central processing unit CPU and a main memory . CPU can be any logic circuitry that responds to and processes instructions fetched from the main memory . CPU can be a single or multiple microprocessors field programmable gate arrays FPGAs or digital signal processors DSPs capable of executing particular sets of instructions stored in a memory e.g. main memory or cache e.g. cache . The memory includes a tangible non transitory computer readable medium such as a flexible disk a hard disk a CD ROM compact disk read only memory MO magneto optical drive a DVD ROM digital versatile disk read only memory a DVD RAM digital versatile disk random access memory or a semiconductor memory. Main memory can be one or more memory chips capable of storing data and allowing any storage location to be directly accessed by CPU . Main memory can be any type of random access memory RAM or any other available memory chip capable of operating as described herein. In the exemplary embodiment shown in CPU communicates with main memory via a system bus . Computing device can also include a visual display device and an input output I O device e.g. a keyboard mouse or pointing device connected through I O controller both of which communicate via system bus . One of ordinary skill in the art would appreciate that CPU can also communicate with memory and other devices in manners other than through system bus such as through serial communication manners or point to point communication manners. Furthermore I O device can also provide storage and or an installation medium for the computing device .

As shown in computing device can support any suitable installation device such as a floppy disk drive for receiving floppy disks such as 3.5 inch 5.25 inch disks or ZIP disks a CD ROM drive a CD R RW drive a DVD ROM drive tape drives of various formats a USB device a hard drive or any other device suitable for installing software and programs such as any client agent or portion thereof. Computing device can further comprise a storage device such as one or more hard disk drives or redundant arrays of independent disks for storing an operating system and other related software and for storing application software programs such as any program related to client agent . Optionally any of the installation devices could also be used as storage device .

Furthermore computing device can include a network interface to interface to a LAN WAN MAN or the Internet through a variety of connections including but not limited to standard telephone lines LAN or WAN links e.g. 802.11 T1 T3 56 kb X.25 broadband connections e.g. ISDN Frame Relay ATM wireless connections or some combination of any or all of the above. Network interface can comprise a built in network adapter network interface card PCMCIA network card card bus network adapter wireless network adapter USB network adapter modem or any other device suitable for interfacing computing device to any type of network capable of communication and performing the operations described herein.

Each application can include a plurality of data points which can be referred to as the application s DNA. In some embodiments the data points of the application s DNA can be based on heuristics. For example each application can include over 68 000 data points. An example of these data points is illustrated in . As shown in these data points can include information associated with an application s static data and also runtime data . Application s static data can include information associated with install logic install conditions and or install actions. Such data can also include information associated with application s files registry settings and or configuration settings. It can further include information associated with API calls API imports and or API exports. Additionally static data can include information associated with relationships and or dependencies within an application. Runtime data of application s DNA can include either runtime internal data regarding performance and resources or runtime external data regarding dependencies between network database etc. These data points can also include an operating system s static data . For example operating system s static data can include information associated with operating system s files registry settings and or configuration settings. It can also include information associated operating system s API calls API imports and or API exports. Additionally operating system s static data can also include information associated with relationships and or dependencies of an operating system. These data points can also include information associated with external context . For example external context can include information associated with users and or machines used by the users. External context can also include information associated with usage and or utilization of application compatibility system resources.

In some exemplary embodiments an application s DNA can be organized into elements which can be referred to as atomic elements. An example of these atomic elements is illustrated in . As shown in in some embodiments atomic elements of an application can comprise at least one of the following API calls between an operating system and the application files that are either installed created or modified by the application or folders that are either installed created or modified by the application . Although not shown in atomic elements of an application can also comprise at least one of the following registry keys that are either installed created or modified by the application registry values that are either installed created or modified by the application API calls between the application and another application meta data information associated with the files of an application or information associated with a system for adding new atomic elements. It will be understood that the above listed atomic elements are merely exemplary and application s DNA can be organized into any number of atomic elements. For example an application can include over 68 000 data points that can comprise its DNA.

In some embodiments an application s DNA can be organized into groups of atomic elements. An example of these groups of atomic elements is illustrated in . In some embodiments two or more atomic elements can be combined to form a group of atomic elements. For example as shown in a group of atomic elements can comprise API calls associated with a plurality of files. Such an exemplary group of atomic elements can comprise a combination of API calls between a first file and a second file of the plurality of files and API calls between one file of the plurality of files and an operating system. In some embodiments groups of atomic elements can comprise information associated with a system for adding new atomic elements or files types associated with one or more files or meta data associated with one or more files . It will be understood that the above listed group of atomic elements are merely exemplary and application s DNA can be organized into any number of groups of atomic elements.

In some embodiments an application s DNA can be organized into containers not shown in and sub containers not shown in . In some embodiments a container can be a group of atomic elements. For example an exemplary group of atomic elements as depicted in can comprise a combination of API calls between a first file and a second file of the plurality of files and API calls between one file of the plurality of files and an operating system. In some embodiments containers can be used for a bulk level compatibility verification which can potentially generate a signature for the whole container or group of atomic elements. This signature can be used to rapidly match against for example Known Good DNA or Known Bad DNA across a larger sample e.g. a container at a time in one comparison that can improve efficiency of the compatibility verification process as opposed to atomic level verification where the compatibility verification proceeds one atomic element at a time. A status of Known Good DNA can signify that all atomic elements associated with an application are known to be compatible with a target platform. A status of Known Bad DNA can signify that at least one atomic element associated with an application is known to be not compatible with a target platform. It will be understood that the exemplary bulk level verification can also be performed with other statuses of atomic elements such as Suspect DNA which is discussed below.

In some embodiments containers can be defined to comprise a collection of files residing in a folder and a sub container could be a sub folder residing in the folder. In some embodiments a similar parallel can exist for registry hives and keys and their sub keys. The installation package for example and Runtime redistributable like the Microsoft Visual C Runtime can form one of these meta groups or atomic elements. It will be understood that the above listed definitions of containers and sub containers are not limiting and merely exemplary.

Referring back to applications imported in importing step can comprise any kind of application including but not limited to desktop applications e.g. MSI applications non MSI applications or web based applications for example web applications . MSI applications can include for example Microsoft Installer or Windows Installer based applications. That is MSI applications can be applications that use a .msi file Microsoft Installer or Windows Installer in the process of installation. Non MSI applications can be applications that use an interface other than Microsoft Installer or Windows Installer interface for installation such as Microsoft App V or a custom developed setup.exe file.

Importing step can be implemented differently between importing desktop applications and web applications. For example Windows desktop applications can be imported using the applications installation packages. These installation packages can include an .msi file or any other type of installation package used in the industry. In some embodiments such installation packages can be App V e.g. .sft or .appv packages. Web applications can be imported into the application compatibility system by using one of the two different exemplary approaches described below or a combination of those approaches. In some embodiments web applications can be imported by a directed web spider or web crawler to crawl over the run time HTML pages and capture them for import into the application compatibility system. In some embodiments importing can be accomplished by importing the web applications source files into a database of application compatibility system.

In some embodiments DNA database can reside within a server e.g. server hosting the application compatibility system. In some embodiments DNA database can reside on a server or on a distributed network of servers remote from a server hosting the application compatibility system. Applications imported in importing step of the application compatibility system can reside in DNA database . Each such application can be associated with one or more compatibility algorithms which can also reside in DNA database . In some embodiments compatibility algorithms are created by a user of the application compatibility system whereas in other embodiments such algorithms can already be created and saved in a universal algorithm library residing in DNA database .

DNA database can also include information associated with operating systems e.g. operating system DNA running on computing device . For example operating systems running on computing device can include Windows 7 Windows Server 2003 Windows XP and Windows Server 2008 R2 . In some embodiments information associated with operating system e.g. operating system image or snapshot can be uploaded by a user of the application compatibility system whereas in other embodiments such information can be extracted by an application compatibility system itself. For example operating system DNA can include information describing a certificate chain on an operating system image. Using the signing certificate authority on the certificate chain an algorithm can simply process the certificate chain until it identifies the certificate as either trusted or untrusted. It will be understood that the application compatibility system can also allow users to load multiple operating system images concurrently to enable the user to execute algorithms for compatibility with all such platforms in a single pass. DNA database can further include information associated with usage and or runtime data . DNA database can further include information associated with auditing performance users groups and or devices as depicted in .

In some embodiments a compatibility status of an application can be determined by verifying a digital signature associated with the application. A digital signature associated with an application can be a generic pattern or a specific pattern. For example an application s digital signature can be a hash value returned by a hash function. It is well understood that a hash function can be any algorithm that maps data of variable length to data of a fixed length. The values returned by a hash function can be called hash values hash codes hash sums checksums or simply hashes. In some embodiments where an application s digital signature is defined as a pre defined hash value of a specific string of data e.g. meta data associated with the application an application compatibility system can determine the application s compatibility with a given platform by comparing the application s hash value for the given platform with that of the pre defined hash value. If the comparison results in a match between the application s hash value for the given platform and the pre defined hash value the application compatibility system can identify the application as being compatible with the given platform. If on the other hand the comparison does not result in a match between the application s hash value for the given platform and the pre defined hash value the application compatibility system can identify the application as being not compatible with the given platform. It will be understood that an application s digital signature can be defined in many ways other than and different from the exemplary hash function described above.

Imported applications can be associated with compatibility algorithms that can be used in the analysis process. In some embodiments each imported application can be associated with one or more compatibility algorithms. Compatibility algorithms can be implemented as heuristic algorithms . In some embodiments compatibility algorithms can relate to information associated with the one or more platforms including internal states dependencies relationship between one application to another relationship between an application and an operating system or external data. Compatibility algorithms can also relate to operating system image dependent algorithms including dependencies on features that are provided by an operating system. When relevant these algorithms can interrogate the operating system image data that has been loaded into the database e.g. DNA database of the application compatibility system. These algorithms can check a variety of operating system image information including APIs registry information file management system for each fixed drive partition the certificate store or some compatibility settings.

The application compatibility system can generate reports e.g. report step as depicted in as an output of analysis step . For example such reports can contain information about a compatibility status of one or more applications that have been analyzed by the application compatibility system to determine whether the one or more applications are compatible to a corresponding platform. In some embodiments reports can include a plurality of icons to indicate the compatibility status of an application. For example icons represented by red R amber A and green G colors or indications can signify different statuses for an application. An icon G can indicate that an application will or is likely to work on a target platform an icon A can indicate either that an application can fail or can have impaired functionality or that whether the application will work is unknown although remediation is possible. An icon R on the other hand can indicate that the application is likely to or certain to fail and that the application may need redevelopment.

In some embodiments a status icon can be unknown for an application for a given platform. For example a status icon can be unknown if the application has not been analyzed for the report and accordingly not enough data is available. In some embodiments desktop applications can have an unknown status for reports associated with web applications and web applications can have an unknown status for reports associated with desktop applications. It will be understood that any kind of status icons can be used to indicate a compatibility status of applications. It will further be understood that a definition of each status icon can be customizable and modified by a user of the application compatibility system.

The application compatibility system can provide information about any compatibility issues that have been detected in applications. For example for applications that are associated with an amber icon application may fail or have impaired functionality remediation may be possible. In the application compatibility system the term remediation can mean the process of resolving compatibility issues by making changes to applications or the environment so that those applications can work on the target platform. The application compatibility system can provide remediation report views which provide information about the steps that can be taken to fix compatibility issues that have been detected where possible. In some embodiments more than one alternative approach can be provided. The remediation report can also provide details of the application components that are affected by each compatibility issue.

Server can host a database e.g. DNA database where a plurality of applications can reside. In some embodiments the plurality of applications residing at server can be organized into atomic elements of the applications. For example atomic elements of an application can comprise at least one of the following API calls between an operating system to the application files that are either installed created or modified by the application or folders that are either installed created or modified by the application. Atomic elements can also comprise at least one of the following registry keys that are either installed created or modified by the application registry values that are either installed created or modified by the application API calls between the application and another application meta data information associated with the files of the application or information associated with a system for adding new atomic elements.

In some embodiments the plurality of applications residing at server can also be organized into groups of atomic elements. For example a group of atomic elements can comprise API calls associated with a plurality of files. Such an exemplary group of atomic elements can comprise a combination of API calls between a first file and a second file of the plurality of files and API calls between one files of the plurality of files and an operating system. In some embodiments groups of atomic elements can comprise information associated with a system for adding new atomic elements or files types associated with one or more files or meta data associated with one or more files. It will be understood that the above listed group of atomic elements are merely exemplary and application s DNA can be organized into any number of groups of atomic elements. In some embodiments the plurality of applications residing at server can also be organized into atomic elements and groups of atomic elements.

In some embodiments the plurality of applications residing at server can also be organized into a plurality of containers and or a plurality of sub containers. In some embodiments a container can be a group of atomic elements and can be defined to comprise a collection of files residing in a folder and a sub container could be a sub folder residing in the folder. In some embodiments a container and or a sub container can comprise API calls associated with a plurality of files. Such an exemplary container and or an exemplary sub container can comprise a combination of API calls between a first file and a second file of the plurality of files and API calls between one files of the plurality of files and an operating system. In some embodiments an exemplary container and or or an exemplary sub container can comprise information associated with a system for adding new atomic elements or files types associated with one or more files or meta data associated with one or more files. It will be understood that the above listed containers and or sub containers are merely exemplary and atomic elements can be organized into any number of containers and or sub containers.

In some embodiments a compatibility status of second application can already be identified with at least one status icon such as works or doesn t work . A works icon can indicate that second application is likely to be compatible with a target platform. In some embodiments a works icon can indicate that all atomic elements associated with second application can be marked as known to be compatible with the target platform. This status can be referred to as Known Good DNA. In some embodiments a works icon can indicate that all groups of atomic elements associated with second application can be marked as known to be compatible with the target platform which can be referred to as Known Good DNA. In some embodiments Known Good DNA can be defined as a status that signifies that all atomic elements and or all groups of atomic elements are more likely or always compatible with the target platform. In some embodiments a works icon can indicate that all containers and or all sub containers associated with second application can be marked as known to be compatible with the target platform which can be referred to as Known Good DNA. In some embodiments Known Good DNA can be defined as a status that signifies that all containers and or all sub containers are more likely or always compatible with the target platform. It will be understood that other definitions of Known Good DNA are possible.

A doesn t work icon can indicate that second application is likely to or certain to fail compatibility and that second application may further need redevelopment to be compatible with the target platform. In some embodiments a doesn t work icon can indicate that all atomic elements associated with second application can be marked as possible suspects to cause compatibility failure of second application . This status can be referred to as Suspect DNA. In some embodiments a doesn t work icon can indicate that all groups of atomic elements associated with second application can be marked as possible suspects to cause compatibility failure of second application which can be referred to as Suspect DNA. In some embodiments a doesn t work icon can indicate that all containers and or all sub containers associated with second application can be marked as possible suspects to cause compatibility failure of second application which can be referred to as Suspect DNA.

As more applications e.g. second application are analyzed and their compatibility statuses are identified a repository of Known Good DNA expands. In some embodiments application status for all applications e.g. second application can be stored in a memory of server that can host application compatibility system . In some embodiments application status for all applications e.g. second application can be stored in a memory external to or remote of server . As more and more applications e.g. second application are tested for compatibility with a platform an increasing number of atomic elements can be marked as Known Good DNA. In some embodiments as more and more applications e.g. second application are tested for compatibility with a platform an increasing number of containers and or sub containers can be marked as Known Good DNA.

In some embodiments a database e.g. DNA database hosted by server can be prepopulated with previously learned status of atomic elements associated with one or more applications e.g. second application . For example a learned status of atomic elements can be known when applications comprising such atomic elements are verified for compatibility with a particular platform and a status is identified for such atomic elements. Such learned status of atomic elements can include for example Known Good DNA Suspect DNA and Known Bad DNA. In some embodiments the database might not be prepopulated with previously learned status of atomic elements associated with one or more applications.

In some embodiments a database e.g. DNA database hosted by server can be prepopulated with previously learned status of containers and or sub containers associated with one or more applications e.g. second application . For example a learned status of containers and or sub containers can be known when applications comprising such containers and or sub containers are verified for compatibility with a particular platform and a status is identified for such containers and or sub containers. Such learned status of containers and or sub containers can include for example Known Good DNA Suspect DNA and Known Bad DNA. In some embodiments the database might not be prepopulated with previously learned status of containers and or sub containers associated with one or more applications.

In some embodiments when an application e.g. second application is tested for compatibility with a platform and a status is identified for the application and its atomic elements previously identified Suspect DNA status can be changed to Known Good DNA. For example an atomic element comprising API calls associated with Microsoft Word 2007 application and an operating system can initially be identified with a Suspect DNA if the Word 2007 application is identified with doesn t work status for a given platform. Later if the compatibility of Microsoft Word 2010 application is tested for the same platform as that of Word 2007 and if Word 2010 application is identified with a works status then all atomic elements associated with Word 2010 application can be identified with a Known Good DNA status. In the above example if the Word 2010 application comprises the same atomic element associated with API calls as that of as the Word 2007 application then the API calls atomic element that was previously identified with Suspect DNA can now be identified with a modified status of Known Good DNA for the Word 2007 application.

In some embodiments when an application e.g. second application is tested for compatibility with a platform and a status is identified for the application and its containers and or sub containers previously identified Suspect DNA status can be changed to Known Good DNA. For example a container and or sub container comprising API calls associated with Microsoft Word 2007 application and an operating system can initially be identified with a Suspect DNA if the Word 2007 application is identified with doesn t work status for a given platform. Later if the compatibility of Microsoft Word 2010 application is tested for the same platform as that of Word 2007 and if Word 2010 application is identified with a works status then all containers and or all sub containers associated with Word 2010 application can be identified with a Known Good DNA status. In the above example if the Word 2010 application comprises the same container and or the sub container associated with API calls as that of as the Word 2007 application then the API calls container and or sub container that was previously identified with Suspect DNA can now be identified with a modified status of Known Good DNA for the Word 2007 application.

With the testing of more and more applications e.g. second application the category of atomic elements identified as Suspect DNA associated with an application can shrink as more and more elements of the category of atomic elements identified as Suspect DNA may be converted to Known Good DNA. In some embodiments the category of atomic elements identified as Suspect DNA associated with an application e.g. second application can shrink to a handful of Suspect DNA elements. In some embodiments the handful of Suspect DNA elements can be handed over to an individual e.g. a specialist who specializes in application compatibility who can analyze the Suspect DNA elements and determine whether the Suspect DNA is in fact good DNA and change the status accordingly. In some embodiments the individual can also analyze the Suspect DNA elements and identify the reasons that can cause the application to not be compatible for a platform. In some embodiments the individual analyzing Suspect DNA elements can identify atomic elements that can cause the application to not be compatible for a platform. The identified atomic elements for example can be referred to as Known Bad DNA. In some embodiments Known Bad DNA can be defined such that an application e.g. second application that contains at least one Known Bad DNA element can fail compatibility for the given platform. It will be understood that other definitions of Known Bad DNA are possible.

With the testing of more and more applications e.g. second application the category of containers and or sub containers identified as Suspect DNA associated with an application can shrink as more and more containers and or sub containers of the category of containers and or sub containers identified as Suspect DNA may be converted to Known Good DNA. In some embodiments the category of containers and or sub containers identified as Suspect DNA associated with an application e.g. second application can shrink to a handful of Suspect DNA containers and or sub containers. In some embodiments the handful of Suspect DNA containers and or sub containers can be handed over to an individual e.g. a specialist who specializes in application compatibility who can analyze the Suspect DNA containers and or sub containers and determine whether the Suspect DNA is in fact good DNA and change the status accordingly. In some embodiments the individual can also analyze the Suspect DNA containers and or sub containers and identify the reasons that can cause the application to not be compatible for a platform. In some embodiments the individual analyzing Suspect DNA containers and or sub containers can identify containers and or sub containers that can cause the application to not be compatible for a platform. The identified containers and or sub containers for example can be referred to as Known Bad DNA. In some embodiments Known Bad DNA can be defined such that an application e.g. second application that contains at least one Known Bad DNA container and or sub container can fail compatibility for the given platform. It will be understood that other definitions of Known Bad DNA are possible.

After most if not all Suspect DNA elements are analyzed applications e.g. second application can then be automatically marked with a status icon signifying a compatibility status. In some embodiments applications can be automatically marked with status icons as follows works or green icon that can signify that an application comprises only Known Good DNA elements doesn t work or red icon that can signify that an application comprises at least one Known Bad DNA element or unknown or amber icon that can signify that an application comprises either Known Good DNA elements or Suspect DNA elements but not Known Bad DNA elements. It will be understood that in some embodiments other definitions of works doesn t work and unknown status can be used.

After most if not all Suspect DNA containers and or sub containers are analyzed applications e.g. second application can then be automatically marked with a status icon signifying a compatibility status. In some embodiments applications can be automatically marked with status icons as follows works or green icon that can signify that an application comprises only Known Good DNA containers and or sub containers doesn t work or red icon that can signify that an application comprises at least one Known Bad DNA container and or sub container or unknown or amber icon that can signify that an application comprises either Known Good DNA containers and or sub containers or Suspect DNA containers and or sub containers but not Known Bad DNA containers and or sub containers. It will be understood that in some embodiments other definitions of works doesn t work and unknown status can be used.

In instances where there can be conflicts between Known Good DNA Known Bad DNA and Suspect DNA the application compatibility system can define a precedence order to resolve such conflicts. For example a precedence order can be defined such that Known Good DNA can take precedence over Suspect DNA whereas Known Bad DNA can take precedence over any other status including Known Good DNA and Suspect DNA. In some embodiments a date related precedence can be defined. For example a precedence order can be defined such that a latest status takes precedence over previous statuses irrespective of whether the latest status is either Known Good DNA or Known Bad DNA. It will be understood that in some embodiments other precedence order definitions are possible.

In some embodiments when an analyzed application comprises a combination of Known Good DNA Known Bad DNA and Suspect DNA heuristics can be employed to help in determining the relative importance that can be associated with each of Known Good DNA Known Bad DNA and Suspect DNA. For example a different weightage factor can be associated for each of the different DNA elements that can help in determining which elements or containers sub containers takes precedence over the other. In some embodiments such determination can be implemented by first detecting dependency trees based off of an executable of an application either by a shortcut or by a trait of being the only executable in the application. After detecting dependency trees application compatibility system can analyze each of the dependencies for example by matching API export and import calls across different assemblies of the application. After such analysis if it is determined that the Known Good DNA is comprised within the primary dependency tree while the Suspect DNA is not comprised within the primary dependency tree application compatibility system can determine that Known Good DNA status has precedence over other statuses. It will be understood that in some embodiments other ways of determining the relative importance between the different statuses can be possible.

Next depicts an application compatibility system organizing at step first application s DNA into atomic elements and or groups of atomic elements. An exemplary organizing step is shown in an organizing block of . The process of organizing first application s DNA into atomic elements and or groups of atomic elements can be the same as that of organizing second application s DNA into atomic elements and or groups of atomic elements as described in s step and s step above. Organizing step can be depicted for example using the same element as depicted in . In some embodiments first application can already be organized into atomic elements and or groups of atomic elements before request is received.

In some embodiments at step application compatibility system organizes first application s DNA into containers and or sub containers. The process of organizing first application s DNA into containers and or sub containers can be the same as that of organizing second application s DNA into containers and or sub containers as described in s step and s step above. In some embodiments first application can already be organized into containers and or sub containers before request is received.

Next depicts a step step of of comparing atomic elements of first application with that of atomic elements of second application . In some embodiments comparing step can be used to identify a compatibility status of first application based on a compatibility status of second application as long as there is at least one atomic element or at least one group of atomic elements in common between first application and second application . In some embodiments when comparing step is being performed a compatibility status of second application is already known identified and stored in application compatibility system . For example second application can be identified with at least one of the following status icons works or a green icon that can signify that second application comprises only Known Good DNA elements for one or more particular platforms doesn t work or red icon that can signify that second application comprises at least one Known Bad DNA element for one or more particular platforms or unknown or amber icon that can signify that second application can only comprise some combination of either Known Good DNA elements or Suspect DNA elements but cannot comprise Known Bad DNA elements.

In some embodiments comparing step compares containers and or sub containers of first application with that of containers and or sub containers of second application . In some embodiments comparing step can be used to identify a compatibility status of first application based on a compatibility status of second application as long as there is at least one container and or one sub container in common between first application and second application . In some embodiments when comparing step is being performed a compatibility status of second application is already known identified and stored in application compatibility system . For example second application can be identified with at least one of the following status icons works or a green icon that can signify that second application comprises only Known Good DNA containers and or sub containers for one or more particular platforms doesn t work or red icon that can signify that second application comprises at least one Known Bad DNA container and or sub container for one or more particular platforms or unknown or amber icon that can signify that second application can only comprise some combination of either Known Good DNA containers and or sub containers or Suspect DNA containers and or sub containers but cannot comprise Known Bad DNA containers and or sub containers.

Next in step an identifying step is described that can comprise identifying a status for first application based on the comparison between atomic elements of first application with that of atomic elements of second application as described in step . For example identifying a compatibility status of first application can be based on an identification status of one or more atomic elements or one or more groups of atomic elements of second application as long as there is at least one atomic element or at least one group of atomic elements common between first application and second application . While this example refers to atomic elements of second application it is appreciated that the atomic elements that are used for comparing with the first application s atomic elements can be from multiple applications regardless of whether those multiple applications are related or not to the first application. For example unrelated applications can use substantially similar or identical modules for making an API call thus in similar situations the atomic elements of an application would correspond with the atomic elements of the unrelated application.

In some embodiments identifying step can comprise identifying a status for first application based on the comparison between containers and or sub containers of first application with that of containers and or sub containers of second application as described in step . For example identifying a compatibility status of first application can be based on an identification status of one or more containers and or one or more sub containers of second application as long as there is at least one container and or sub container common between first application and second application . While this example refers to containers and or sub containers of second application it is appreciated that the containers and or sub containers that are used for comparing with the first application s containers and or sub containers can be from multiple applications regardless of whether those multiple applications are related or not to the first application. For example unrelated applications can use substantially similar or identical modules for making an API call thus in similar situations the containers and or sub containers of an application would correspond with the containers and or sub containers of the unrelated application.

In some embodiments identifying step can comprise a determination whether at least one atomic element of first application is also an atomic element of second application . In some embodiments identifying step can comprise a determination whether at least one group of atomic elements of first application is also a group of atomic elements of second application . If a determination that at least one atomic element or at least one group of atomic elements of first application is also an atomic element or a group of atomic elements of second application or another application then the at least one atomic element or the at least one group of atomic elements of first application is automatically marked with the same compatibility status as that of the corresponding atomic element or a group of atomic elements of second application .

For example an atomic element comprising API calls associated with Microsoft Word 2007 application exemplary second application and an operating system can initially be identified with a Suspect DNA for a given platform. Next if the compatibility of Microsoft PowerPoint 2007 application is tested for the same platform as that of Word 2007 and if PowerPoint 2007 comprises the same atomic element as that of Word 2007 namely API calls associated with the operating system then that atomic element of PowerPoint 2007 application is also identified with the same Suspect DNA status automatically.

In some embodiments identifying step can comprise a determination whether at least one container and or sub container of first application is also a container and or sub container of second application . If a determination that at least one container and or sub container of first application is also an container and or sub container of second application or another application then the at least one container and or sub container of first application is automatically marked with the same compatibility status as that of the corresponding container and or sub container of second application . For example a container and or sub container comprising API calls associated with Microsoft Word 2007 application exemplary second application and an operating system can initially be identified with a Suspect DNA for a given platform. Next if the compatibility of Microsoft PowerPoint 2007 application is tested for the same platform as that of Word 2007 and if PowerPoint 2007 comprises the same container and or sub container as that of Word 2007 namely API calls associated with the operating system then that container and or sub container of PowerPoint 2007 application is also identified with the same Suspect DNA status automatically.

In some embodiments the automatic marking of atomic elements of first application with the same compatibility status as that of the corresponding atomic elements or a group of atomic elements of second application can be performed by server hosting application compatibility system . In some embodiments the automatic marking of containers and or sub containers of first application with the same compatibility status as that of the corresponding containers and or sub containers of second application can be performed by server hosting application compatibility system . In some embodiments such automatic marking can be performed by a client device e.g. client device A F . In some embodiments such marking can be performed manually by a user of application compatibility system .

In some embodiments identifying step can include each atomic element of first application that can be compared with an existing repository of atomic elements with identified statuses and associated with existing applications e.g. second application . Accordingly each atomic element of first application can be marked with at least one status icon such as Known Good DNA Known Bad DNA or Suspect DNA. In some embodiments when most if not all atomic elements of first application are marked with a compatibility status icon a compatibility status of first application as a whole can be identified. In some embodiments a compatibility status of first application can be identified by server hosting application compatibility system . In some embodiments a compatibility status of first application can be identified by client device A F.

In some embodiments identifying step can include each container and or sub container of first application that can be compared with an existing repository of containers and or sub containers with identified statuses and associated with existing applications e.g. second application . Accordingly each container and or sub container of first application can be marked with at least one status icon such as Known Good DNA Known Bad DNA or Suspect DNA. In some embodiments when most if not all containers and or sub containers of first application are marked with a compatibility status icon a compatibility status of first application as a whole can be identified.

Next depicts an application compatibility system displaying at step step of a compatibility status for first application with a platform. An exemplary organizing step is shown in an organizing block of . In some embodiments the compatibility status can be displayed on a graphical user interface e.g. display . For example the compatibility status can be indicated as an element report similar to the exemplary report depicted in . In some embodiments the displayed compatibility status can include displaying at least one status icon for first application . For example a displayed status icon can include one of the following icons red amber and green which can represent different statuses for first application . In some embodiments a green icon can indicate that first application is likely to be compatible with the platform an amber icon can indicate that first application can fail or can have impaired functionality although remediation is possible. In some embodiments a red icon can indicate that first application is likely to or certain to fail and that first application may need redevelopment to be compatible with the platform. In some embodiments a compatibility status of first application on a graphical user interface can be displayed on at least one client device A F. In some embodiments a compatibility status of first application on a graphical user interface can be displayed on a display associated with server hosting application compatibility system .

The methods disclosed herein may be implemented as a computer program product i.e. a computer program tangibly embodied in an information carrier e.g. in a non transitory machine readable storage device or in a propagated signal for execution by or to control the operation of data processing apparatus e.g. a programmable processor a computer or multiple computers. A computer program can be written in any form of programming language including compiled or interpreted languages and it can be deployed in any form including as a stand alone program or as one or more modules one or more components one or more subroutines or one or more other units suitable for use in a computing environment. A computer program can be deployed to be executed on one computer or on multiple computers at one site or distributed across multiple sites and interconnected by a communication network.

In the preceding specification the subject matter has been described with reference to specific exemplary embodiments. It will however be evident that various modifications and changes may be made without departing from the broader spirit and scope of the subject matter as set forth in the claims that follow. The specification and drawings are accordingly to be regarded as illustrative rather than restrictive. Other embodiments may be apparent to those skilled in the art from consideration of the specification and practice of the embodiments disclosed herein.

