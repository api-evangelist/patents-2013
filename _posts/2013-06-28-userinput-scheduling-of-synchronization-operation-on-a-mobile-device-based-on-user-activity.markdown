---

title: User-input scheduling of synchronization operation on a mobile device based on user activity
abstract: Data is synchronized between a mobile device and a computing device over a wireless link. Synchronization operations are scheduled according to a synchronization schedule that is based on a current time of day. In one embodiment, the day can be divided into different time periods by the user. The user can also specify the frequency with which synchronization operations are to be performed during each specified period.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09037173&OS=09037173&RS=09037173
owner: MICROSOFT TECHNOLOGY LICENSING, LLC
number: 09037173
owner_city: Redmond
owner_country: US
publication_date: 20130628
---
The present application is a continuation of U.S. patent application Ser. No. 13 369 725 filed Feb. 9 2012 which is a continuation of U.S. patent application Ser. No. 13 173 242 filed Jun. 30 2011 which is a continuation of U.S. patent application Ser. No. 12 872 579 filed Aug. 31 2010 now U.S. Pat. No. 7 996 028 issued Aug. 9 2011 which is a continuation of U.S. patent application Ser. No. 10 641 380 filed Aug. 14 2003 now U.S. Pat. No. 7 809 384 issued Oct. 5 2010 which is based on and claims the benefit of U.S. Provisional Patent Application No. 60 424 177 filed Nov. 5 2002 the contents of each of which are hereby incorporated by reference in their entireties.

The present invention relates to synchronization of objects between object stores on two different computing devices. More particularly the present invention relates to scheduling of synchronization operations on mobile devices.

Mobile devices include a broad range of computing and communication devices that are small enough to be conveniently carried by a user. Examples of such devices include mobile phones personal digital assistants tablet PCs and lap top PCs.

Generally the mobile device includes a processor random access memory RAM and an input device such as a keyboard touchpad or input buttons and a display. The keyboard can be integrated with the display such as when the keyboard is incorporated as a touch sensitive display. A communication interface is optionally provided and is commonly used to communicate with other computers. A replaceable or rechargeable battery powers the mobile device. Optionally the mobile device can receive power from an external power source that overrides or recharges the built in battery.

While a wide variety of computing tasks and applications can be performed by such mobile devices personal information managers PIMs are particularly well suited to mobile devices. PIMs typically comprise applications which enable the user of the mobile device to better manage scheduling and communications and other such tasks. Some commonly available PIMs include scheduling and calendar programs task lists address books and electronic mail e mail programs. Some commonly commercially available PIMs are sold under the trademarks MICROSOFT SCHEDULE and MICROSOFT OUTLOOK and are commercially available from Microsoft Corporation of Redmond Wash. In addition to PIMs however such mobile devices may also run different types of applications such as word processors spread sheets etc.

To provide users with as much freedom as possible it is desirable to allow the user to access and change their application and PIM information from any device they choose. Thus the user should be able to access their e mail from a network terminal a PDA and a tablet PC for example.

However allowing the user to access and change their information from any desired source means that the devices must be able to communicate with each other to indicate changes to the information. The process of two devices sharing changes in the application and or PIM information is known as synchronization.

In general synchronization is not a continuous process. In other words a mobile device does not continually try to synchronize its data because that would waste limited wireless bandwidth and place an undue drain on the mobile device s battery. Instead synchronization is performed periodically. In addition since the mobile device is not always in use it is wasteful to have a server or desktop computer periodically attempt to establish a connection with the mobile device to perform synchronization. Instead the mobile device is responsible for establishing a connection to perform synchronization.

When scheduling synchronization operations through a wireless connection such as a cellular connection a number of concerns present themselves. First it can be desirable to have data be as up to date as possible. This requires synchronization sync to be performed frequently. However the synchronization process does require a relatively high amount of power and can thus affect the remaining battery life of the mobile device. Similarly cellular connection charges often apply. Since frequent sync operations require frequent cellular connection to a synchronization server the costs associated with these connections can become relatively large. Also cellular connection costs can increase rather significantly when connection is made to a roaming mobile device. Thus frequent sync operations requiring frequent connections during roaming can also undesirably increase the cost of synchronization.

An aspect of the present disclosure is directed to a mobile device having at least one computer storage medium. The mobile device includes a synchronization component retained on the at least one computer storage medium and configured to perform synchronization operations that synchronize data between the mobile device and a computing device over a wireless link. The mobile device also includes a synchronization schedule retained on the at least one computer storage medium the synchronization schedule including a peak time period and a non peak time period for performing the synchronization operations. The mobile device further includes a user interface retained on the at least one computer storage medium where the user interface includes a first input component configured to designate a time period throughout a day as the peak time period or the non peak time period and a second input component configured to set at least one frequency at which the synchronization operations are to be performed during the peak time period during the non peak time period or during both the peak time period and the non peak time period.

Another aspect of the present disclosure is directed to a mobile device having at least one computer storage medium where the mobile device includes a synchronization schedule retained on the at least one computer storage medium. The synchronization schedule includes a peak time period in which synchronization operations that synchronize data between the mobile device and a computing device over a wireless link are performed at a first frequency and a non peak time period in which the synchronization operations are performed at a second frequency. The mobile device also includes a user interface retained on the at least one computer storage medium where the user interface includes a first input component configured to designate a first time period throughout the day as the peak time period in response to a first user input and a second input component configured to set at least one of the first frequency and the second frequency in response to a second user input.

Another aspect of the present disclosure is directed to a method for synchronizing data between a mobile device and a computing device over a wireless link. The method includes accessing a synchronization schedule retained on at least one computer storage medium of at least one of the mobile device and the computing device where the synchronization schedule includes a peak time period and a non peak time period for performing synchronization operations that synchronize data between the mobile device and the computing device. The method also includes designating a time period throughout a day as the peak time period or the non peak time period and setting at least one frequency at which the synchronization operations are to be performed during the peak time period during the non peak time period or during both the peak time period and the non peak time period. The method further includes performing at least one of the synchronization operations.

In one illustrative embodiment of the present invention application programs and are personal information manager PIM programs which support for example electronic mail messaging scheduling calendering etc. Hereinafter programs and will simply be referred to as PIMs and . Of course PIMs and can be configured to support a wide variety of other features such as task lists and personalized address books to name a few.

Object stores and are implemented in memory configured to store a plurality of individual records or objects each comprising a plurality of fields or properties related to PIMs and . In one illustrative embodiment PIMs and are programs such as that available under the commercial designation MICROSOFT OUTLOOK and object stores and are configured to store objects each of which having a plurality of attributes or properties associated with electronic mail messaging such as a sender s name the recipient s name text messages etc. Computing device executes PIM to maintain objects stored in store and mobile device executes program to maintain objects stored in object store . In one illustrative embodiment each object in object store comprises the same set of properties or attributes stored in object store or a subset of those properties or attributes.

Similarly application programs and maintain objects on associated object stores and respectively. In one illustrative embodiment application programs and are file system applications such as those available under the commercial designation MICROSOFT WORD . It should also be noted that any suitable number of other application programs and associated object stores can be provided on mobile device and computing device . However for the sake of simplicity only programs and and their associated object stores are described herein.

In one illustrative embodiment the user desires to synchronize object stores and and object stores and . Thus there are two instances of each object associated with the pair of object stores and one instance in object store and one instance in object store and two instances of each object associated with the pair of object stores and one instance in object store and one instance in object store . When a user changes one instance of the object stored in either object store or the second instance of that object in the other of stores and is out of sync and is desirably updated the next time mobile device has two way communication with computing device so that both instances of the same object contain synchronized data. The same is true for instances of objects stored in object stores and .

In order to accomplish synchronization synchronization components and run on mobile device and computing device respectively. The synchronization components communicate with application programs and or directly with the associated object stores through any well defined interfaces to manage communication and synchronization.

Synchronization components and communicate with each other through communication links and . Communication links and are illustratively commercially available communication links using a suitable communications protocol. For instance in one illustrative embodiment mobile device is connected to computing device with a physical cable which communicates using a serial communications protocol. Other communication mechanisms are also contemplated by the present invention such as infrared IR communication direct modem communication remote dial up networking communication communication through commercially available network cards i.e. using TCP IP remote access services RAS wireless modem wireless cellular digital packet data CDPD short message services or other suitable communication mechanisms. Although the communication links are shown as being internal to mobile device and computing device those skilled in the art will recognize that portions of the communication links exist outside of the devices. For example the communication links can include communication servers located between mobile device and computing device other portions of the network forming the communication link such as the cellular and PSTN networks and adapters such as mobile device cradles.

Prior to discussing the synchronization process and associated mechanisms in greater detail the present discussion proceeds with respect to a more detailed description of the components of mobile device and an example computing device for the sake of clarity.

Computing device is only one example of a suitable computing device and is not intended to suggest any limitation as to the scope of use or functionality of the invention. Neither should computing device be interpreted as having any dependency or requirement relating to any one or combination of components illustrated in the exemplary computing device .

The invention is operational with numerous other general purpose or special purpose computing system environments or configurations. Examples of well known computing systems environments and or configurations that may be suitable for use with the invention include but are not limited to personal computers server computers hand held or laptop devices multiprocessor systems microprocessor based systems set top boxes programmable consumer electronics network PCs minicomputers mainframe computers telephony systems distributed computing environments that include any of the above systems or devices and the like.

The invention may be described in the general context of computer executable instructions such as program modules being executed by a computer. Generally program modules include routines programs objects components data structures etc. that perform particular tasks or implement particular abstract data types. The invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment program modules may be located in both local and remote computer storage media including memory storage devices.

With reference to an exemplary system for implementing the invention includes a general purpose computing device in the form of a computer . Components of computer may include but are not limited to a processing unit a system memory and a system bus that couples various system components including the system memory to the processing unit . The system bus may be any of several types of bus structures including a memory bus or memory controller a peripheral bus and a local bus using any of a variety of bus architectures. By way of example and not limitation such architectures include Industry Standard Architecture ISA bus Micro Channel Architecture MCA bus Enhanced ISA EISA bus Video Electronics Standards Association VESA local bus and Peripheral Component Interconnect PCI bus also known as Mezzanine bus.

Computer typically includes a variety of computer readable media. Computer readable media can be any available media that can be accessed by computer and includes both volatile and nonvolatile media removable and non removable media. By way of example and not limitation computer readable media may comprise computer storage media and communication media. Computer storage media includes both volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Computer storage media includes but is not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical disk storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can be accessed by computer . Communication media typically embodies computer readable instructions data structures program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term modulated data signal means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example and not limitation communication media includes wired media such as a wired network or direct wired connection and wireless media such as acoustic RF infrared and other wireless media. Combinations of any of the above should also be included within the scope of computer readable media.

The system memory includes computer storage media in the form of volatile and or nonvolatile memory such as read only memory ROM and random access memory RAM . A basic input output system BIOS containing the basic routines that help to transfer information between elements within computer such as during start up is typically stored in ROM . RAM typically contains data and or program modules that are immediately accessible to and or presently being operated on by processing unit . By way of example and not limitation illustrates operating system application programs other program modules and program data .

The computer may also include other removable non removable volatile nonvolatile computer storage media. By way of example only illustrates a hard disk drive that reads from or writes to non removable nonvolatile magnetic media a magnetic disk drive that reads from or writes to a removable nonvolatile magnetic disk and an optical disk drive that reads from or writes to a removable nonvolatile optical disk such as a CD ROM or other optical media. Other removable non removable volatile nonvolatile computer storage media that can be used in the exemplary operating environment include but are not limited to magnetic tape cassettes flash memory cards digital versatile disks digital video tape solid state RAM solid state ROM and the like. The hard disk drive is typically connected to the system bus through a non removable memory interface such as interface and magnetic disk drive and optical disk drive are typically connected to the system bus by a removable memory interface such as interface .

The drives and their associated computer storage media discussed above and illustrated in provide storage of computer readable instructions data structures program modules and other data for the computer . In for example hard disk drive is illustrated as storing operating system application programs other program modules and program data . Note that these components can either be the same as or different from operating system application programs other program modules and program data . Operating system application programs other program modules and program data are given different numbers here to illustrate that at a minimum they are different copies.

A user may enter commands and information into the computer through input devices such as a keyboard a microphone and a pointing device such as a mouse trackball or touch pad. Other input devices not shown may include a joystick game pad satellite dish scanner or the like. These and other input devices are often connected to the processing unit through a user input interface that is coupled to the system bus but may be connected by other interface and bus structures such as a parallel port game port or a universal serial bus USB . A monitor or other type of display device is also connected to the system bus via an interface such as a video interface . In addition to the monitor computers may also include other peripheral output devices such as speakers and printer which may be connected through an output peripheral interface .

The computer may operate in a networked environment using logical connections to one or more remote computers such as a remote computer which can include mobile device . The remote computer may be a personal computer a hand held device a server a router a network PC a peer device or other common network node and typically includes many or all of the elements described above relative to the computer . The logical connections depicted in include a local area network LAN and a wide area network WAN but may also include other networks. Such networking environments are commonplace in offices enterprise wide computer networks intranets and the Internet. In addition the network connections between any of the nodes in the network may include direct cable connections or wireless connections and the connection between computer and remote computer may include any number of nodes and or routers.

When used in a LAN networking environment the computer is connected to the LAN through a network interface or adapter . When used in a WAN networking environment the computer typically includes a modem or other means for establishing communications over the WAN such as the Internet. The modem which may be internal or external may be connected to the system bus via the user input interface or other appropriate mechanism. In a networked environment program modules depicted relative to the computer or portions thereof may be stored in the remote memory storage device. By way of example and not limitation illustrates remote application programs as residing on remote computer . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.

Dynamically linked libraries DLLs comprising a plurality of executable functions are associated with PIM and application for execution by processor . Interprocessor and intercomponent calls are facilitated preferably using the component object model COM as is common in programs written for Microsoft WINDOWS brand operating systems. Briefly when using COM a software component such as a DLL has a number of interfaces. Each interface exposes a plurality of methods which can be called individually to utilize different services offered by the software component. In addition interfaces are provided such that methods or functions can be called from other software components which optionally receive and return one or more parameter arguments.

In general the DLLs associated with PIM and program are designed specifically to work in conjunction with PIM and program and to expose desktop synchronization interfaces that function according to a synchronization protocol. The DLLs in turn call interfaces exposed by PIM and program in order to access data representing individual properties of objects maintained in object stores and . Object stores and of course can reside in any one of the suitable memory components described with respect to .

It should be noted that the displays and for the mobile devices shown in can be the same size as one another or different sizes from one another but would typically be much smaller than a conventional display used with a desktop computer. For example displays and shown in may be defined by a matrix of only 240.times.320 coordinates or 160.times.160 coordinates or any other suitable size. When mobile device is a pager the display may be even smaller.

The mobile device shown in also includes a number of user input keys or buttons such as button which allow the user to scroll through menu options or other display options which are displayed on display or which allow the user to change applications or select user input functions without contacting display .

Note that other forms of the mobile device are possible under the present invention. Examples include mobile phones that are capable of performing computing tasks tablet PCs and wireless enabled laptop computers to name a few.

Memory is illustratively implemented as nonvolatile electronic memory such as random access memory RAM with a battery back up module not shown such that information stored in memory is not lost when the general power to mobile device is shut down. A portion of memory is illustratively allocated as addressable memory for program execution while another portion of memory is optionally used for storage such as to simulate storage on a disc drive.

Memory can include operating system one or more application programs such as PIM and file application etc. as well as object stores and and sync engine . During operation operating system is illustratively executed by processor from memory . The operating system implements features which can be utilized by PIM and file application through a set of exposed application programming interfaces and methods. The objects in object stores and are illustratively maintained by PIM file application and operating system at least partially in response to calls to the exposed application programming interfaces and methods.

I O components in one embodiment are provided to facilitate input and output operations from a user of mobile device . I O components for various embodiments of mobile device can include input components such as buttons and touch sensors and output components such as a display a speaker and or a printer port etc.

Communication link is any suitable communication interface. Interface is illustratively used to communicate with computing device as described with respect to . Memory includes a set of communication drivers that interact with communication link and that translate data to and from the appropriate communication protocol necessary to allow for communication across link .

Wireless network port and wireless network driver provide communication to a network over a radio channel. Wireless network port and driver can use any number of wireless network protocols including General Packet Radio Service GPRS and 1Xrtt which are wireless services used to provide cellular access to a network as well as 802.11 and 802.11b Wi Fi protocols and Bluetooth protocol which provide local wireless connections to networks. Of course others can be used as well.

SMS port and SMS driver support one way communication using the Short Message Service protocol. Thus SMS port is able to receive SMS messages that are broadcast using the radio spectrum.

Sync engine on computing device also includes a synchronization manager coupled to an associated reference store and also coupled to application programs including PIM sync provider and file sync provider . PIM sync provider is coupled to PIM object store and file sync provider is coupled to file object store . While providers and are shown coupled directly to associated object stores those providers could also be coupled to the object stores through the application programs and instead. However for the sake of simplicity the present discussion proceeds only with respect to the arrangement shown in .

Sync providers and expose application programming interfaces APIs which can be called by sync manager to read and store objects and object properties on object stores and . The interfaces generally allow the creation of data bases for different types of objects and allow application programs to read and write property names and values to and from respective objects within each data base. A number of exemplary interfaces are now described but form no part of the invention and are discussed for purposes of example and completeness only.

The interfaces are well documented as the IReplStore and IReplObjHandler interfaces. Each of these interfaces exposes a number of well documented methods. For example the IReplStore interface exposes methods which can be generally classified as methods which are used to access and modify the data store methods used for object enumeration methods used to obtain object information methods used to manipulate handles to objects methods used for user interface functions and a number of miscellaneous methods. The IReplObjHandler interface exposes methods which are used to serialize objects by turning an object into a series of bytes and to deserialize objects by turning the series of bytes back into an object. The methods included in the interface are also used to delete an object from the corresponding object store.

Sync manager in turn exposes a well documented interface known as the IReplNotify interface to providers and . This interface exposes four well documented methods which are used to notify sync manager of any change or deletion made to an object in a corresponding object store to set text to be displayed in a status bar where synchronization status can be observed by the user to obtain a window handle which is used as a parent window of any modal dialogue or message box and to obtain information about a mobile device which has been selected or which is connected to the computing device.

Each of the providers and are implemented to specifically work in conjunction with a particular application program or respectively. In general because the application program interface API is standardized it allows synchronization manager to access and synchronize any number of different application programs as long as the required interface methods are implemented for each application by corresponding providers.

On mobile device providers and also provide the well documented IReplObjHandler interface such that objects in the associated object stores and can be serialized and deserialized. Providers and also illustratively implement three additional functions which can be used to initialize and terminate the provider to handle object identification and change detection and to retrieve device information about a particular object type. These functions and interfaces are also well documented.

Synchronization manager manipulates reference store to maintain a mapping between instances of objects stored in object stores and on computing device and instances of the same objects stored in object stores and on mobile device . Objects are identified by handles which are created by providers and . The handles are opaque to synchronization manager in that synchronization manager need not be concerned with the actual composition of the handles although the handles are manipulated and stored by synchronization manager .

Generally in order to maintain the mapping synchronization manager maintains reference store so that it contains handles corresponding respectively to a plurality of objects in the object stores and on computing device which are to be synchronized with instances of the same objects in object stores and on mobile device . The handles in reference store will typically correspond to objects that have been previously synchronized between the various object stores. The handles are updated after their corresponding objects have been synchronized.

The list of handles maintained in reference store is also used to determine which items need to be synchronized to mobile device the next time mobile device is connected to computing device . In making this determination synchronization manager also determines whether objects have been added to or deleted from the object stores so that appropriate additions and deletions can be made.

The handles stored in reference store may be formatted in accordance with the following criteria so that the synchronization providers and can perform the specified functions 

 a Each handle may contain data that uniquely identifies an object such as an object identifier an ID number a full pathname for a file system object etc. This data may be persistent in that it does not change for a particular object and should not be reused for subsequently created objects. This data can be compared to determine whether two handles actually correspond to the same object. As is discussed below this can be problematic for file system information because the object identifier is typically the pathname and can be changed simply by renaming the file.

 c The handle may have some sort of time stamp information or version number. This information can be compared to determine whether an object has changed since the last handle was recorded in reference store .

These handles are provided from providers and to synchronization manager for storage in reference store during an enumeration process which is described below. This enumeration process is used to detect items which need to by synchronized when mobile device is next coupled to computing device .

By comparing the list of handles returned by the current enumeration with the saved list of handles loaded from reference store synchronization manager automatically detects changes and deletions. For example each time a new object is returned during enumeration synchronization manager attempts to find an object in its previously saved list of objects which represents the same object. If no matching handle is found synchronization manager determines that a new object has been created and saved on the object store which enumerated the object under consideration. In order to determine whether matching handles are found as is indicated by block synchronization manager calls the interface method IReplStore CompareItem.

Based on a comparison of the handles synchronization manager creates any necessary handle to object mappings in reference store such that objects in the object stores on computing device can be mapped to corresponding instances of the same object on device . This is indicated by block .

Synchronization manager also determines whether any objects have been added deleted or modified in the particular object store from which they were enumerated. This is indicated by blocks . For example if the list of objects which were previously synchronized contains a handle that is not found in the newly created list based upon a current enumeration of synchronization providers that indicates that the object has been deleted from the corresponding data store . Thus synchronization manager determines that the object must also be deleted from the mobile device during the next synchronization operation.

Similarly if the enumeration of objects produces an object handle which does not occur in the list of objects previously synchronized then synchronization manager determines that an object corresponding to that particular handle has been added to the object store which enumerated the object. Thus during the next synchronization operation the object must be added to mobile device .

Synchronization manager also calls the interface method IReplStore IsItemChanged with matching handles from the first and second lists. Calling this interface causes the appropriate provider or whichever enumerated the matching handle to determine whether the object has changed since its handle was last written to reference store . In one illustrative embodiment the provider examines the time stamp information or version number information associated with the object handle. If that information is not identical that indicates that there has been a change to the object. Thus during the next synchronization process synchronization manager must update the corresponding object on mobile device assuming there is no conflict as discussed below .

Synchronization manager on mobile device also interacts with synchronization providers and to determine whether any objects on object stores and have been added deleted or changed since the last synchronization process. On mobile device the operating system posts a message to synchronization manager every time an object on mobile device which is to be synchronized changes is added or is deleted. Synchronization manager enumerates each object and calls methods in the IreplNotify interface of each provider and . Based on this call the provider determines whether the particular object enumerated is to be synchronized and indicates to synchronization manager how many objects are to be synchronized for example a file system object such as a directory actually contains more than one object which is to be synchronized .

Based on the notifications posted from the operating system synchronization manager maintains a list or array of objects which have changed been deleted or added since the last synchronization process. Upon connection to computing device this list is provided to synchronization manager . Thus synchronization manager contains the lists which have been constructed for both desktop and mobile device which indicate objects which need to be synchronized. This is indicated by block in .

Synchronization manager then determines as indicated at block whether an object has changed only on mobile device only on computing device or on both mobile device and computing device . If the object has changed only on one of the desktop object stores then synchronization manager carries out the necessary activity to update the corresponding object store on the mobile device. This is indicated by block . If the object has changed only on one of the mobile device stores then synchronization manager carries out the necessary activities to update the corresponding object store on the computing device . This is indicated by block .

However if the same object has changed on both mobile device and computing device then a conflict situation arises. In one illustrative embodiment synchronization manager makes a call to the registry in the operating system of computing device to obtain conflict information which instructs synchronization manager how to proceed in the face of a conflict. This is indicated by block . For example the user may have set preferences which indicate that in the case of a conflict either the desktop computer version or the mobile device version should take precedence every time. Similarly the user may have set a preference which indicates that the user is to be notified in the case of a conflict so that the user can actively decide which version will take precedence. In that case synchronization manager generates a user interface allowing the user to resolve the conflict. Synchronization manager then takes the necessary steps to resolve the conflict and update the appropriate object store. This continues until all objects in the lists of objects to be synchronized have been dealt with. This is indicated by block .

In order to exchange objects with mobile device synchronization manager continually calls the method IReplObjHandler GetPacket to have an appropriate provider or obtain a packet of information to be transmitted to mobile device . To handle a packet received from mobile device synchronization manager calls IReplObjHandler SetPacket. This acts to provide a packet of information received from mobile device to a synchronization provider for storage on its associated object store. Similar interfaces are called by synchronization manager on mobile device .

When performing synchronization operations over a wireless link such as a cellular link a number of concerns present themselves. First it is desirable that the user of the mobile device has as up to date information as possible. Therefore frequent sync operations may be desirable. However sync operations require in one embodiment cellular connection to a synchronization server. This can undesirably affect the remaining battery life of the mobile device if it is necessary to connect frequently. Similarly cellular charges can undesirably increase the cost of synchronization especially when the mobile device is roaming relative to the synchronization server.

In one system wireless synchronization operations were simply scheduled to be performed on a regular periodic basis such as every two hours or every one hour etc. However this does not address all of the concerns.

One embodiment of the present invention provides a robust mobile schedule that in various embodiments includes a variety of different features to address the different concerns associated with scheduling synchronization operations. For example in one embodiment a user can select a frequency with which synchronization operations are to be performed during different periods of the day such as peak usage time and off peak usage time . Another feature of the present invention allows the user to invoke a roaming override functionality in which a roaming synchronization schedule is implemented when the mobile device is roaming. Yet another embodiment of the present invention allows the user to configure the mobile device to force a synchronization operation each time one of a predefined subset of operations is performed that triggers a synchronization operation.

In one embodiment the user can select which times of day are peak times and which times are non peak times. For instance it is believed that when a user is working and receiving large numbers of electronic mail messages it is likely that the user may want to have synchronization operations performed frequently to ensure that the information they are viewing and manipulating is up to date. However during non work hours the user may not be as concerned as to whether the data is up to date. However some users desire data that is up to date regardless of whether it is a peak or non peak time.

The user sets peak and non peak times using button . If the user actuates button another user interface appears which allows the user to designate which hours of the day are peak times. The remaining hours can be assumed to be non peak times or non peak times can be designated by the user as well. Once the peak and non peak times have been identified by the user the user can actuate the buttons within fields and to adjust the frequency during peak and non peak times with which synchronization operations are to be performed.

The user may wish to have these schedules overridden when certain criteria are present. For instance by actuating the button in field the user can select a sync schedule that is to be implemented when the mobile device is roaming. For example the user can select a schedule which only synchronizes when the user manually triggers a synchronization process. Alternatively the synchronization operations can be set completely to be completely precluded while the mobile device is roaming or they can be set to a specific frequency chosen by the user.

If at block it is determined that the synchronization process is possible then it is determined whether any override criteria are present in this case whether the mobile device is roaming. This is indicated by block . If the device is roaming then it is determined whether the user has selected one of the roaming override functions in field of the user interface shown in . This is determined by block . If so then synchronization is performed according to the roaming override schedule as indicated by block . For example if synchronization is only to be performed when it is manually initiated then the synchronization operation is not performed until that occurs.

If at block it is determined that the mobile device is not roaming or at block it is determined that the user has not selected a roaming override function then the synchronization operation is performed as indicated by block . If the synchronization is interrupted or fails this is determined at block and another synchronization operation is scheduled based on the re try logic.

The re try logic can be any suitable logic algorithm. For instance one such algorithm will initiate a re try after a minimum desired time lapse such as three minutes and a maximum desired re try time which is equal to the next scheduled sync time . For example assume that the mobile device is operating in non peak time and that it is scheduled to sync every 60 minutes during non peak time. Assume that a sync operation is triggered and that the sync operation fails. One exemplary algorithm retries the sync operation at intervals of three minutes six minutes twelve minutes twenty four minutes forty eight minutes and sixty minutes. The last re try interval is not ninety six minutes because the user has scheduled the sync operations to occur every sixty minutes.

If at block the sync has not failed but is successful then the next sync timer is scheduled in accordance with whether it is currently peak or non peak time and the user s selections as illustrated with respect to . This is indicated by block .

In accordance with one embodiment of the present invention sync timers are triggered based on the starting time of a current sync operation. For example if the present sync operation starts at 10 00 a.m. and sync operations are scheduled to be performed every five minutes then the next sync operation is triggered at 10 05 a.m. regardless of how long the current sync operation took to perform. This can be disadvantageous however. For example if the current sync operation takes 4.5 minutes then the next sync operation will be triggered 30 seconds after the current sync operation concludes. This can have the undesirable results of tying up the mobile device more frequently than necessary draining the battery faster than necessary and consuming synchronization server time.

Therefore in accordance with another embodiment of the present invention the next sync timer is scheduled at block beginning from the end of the current sync operation. Therefore if the current sync operation started at 10 00 a.m. and finished at 10 03 a.m. and the sync timers are scheduled to be set every five minutes then the next sync timer will be scheduled to trigger at 10 08 a.m.

When synchronizing on a mobile schedule where synchronization operations occur at regular time intervals it is possible that a significant amount of time can elapse between synchronization operations. However between synchronization operations a user may well be composing forwarding and replying to electronic mail messages as well as possibly marking some messages or attachments for download and sending and responding to meeting requests. To compensate for the time difference between a current action of the user and the next scheduled meeting request the mobile device can be configured to schedule meeting requests based on actions taken by the user instead of simply based on elapsed time.

In accordance with another embodiment of the present invention the user can configure the mobile device to initiate a sync operation when one of a preselected subset of operations is performed on the mobile device that would otherwise trigger a sync. In other words there are a wide variety of different operations which can be taken on the mobile device and which would normally trigger a sync operation. The user may simply read a message delete a message reply to a message forward a message etc. While all of these operations would normally trigger a sync operation it may not be desirable to initiate an immediate sync operation for all of these. For example it may not be desirable to initiate an immediate remote sync operation simply when the user deletes a message from the In Box of an electronic mail application program. Similarly it may not be desirable to initiate an immediate remote sync simply because the user selects an electronic mail operation to read. However it may be desirable to initiate such a synchronization operation during other actions such as those that send an electronic mail transmission or such as when an attachment or electronic mail message is selected to be downloaded to the mobile device . Such actions can include for example sending a new electronic mail message replying to or forwarding an electronic mail message responding to meeting requests or generating a meeting request requesting more data from an item such as a body of message text or attachments to be down loaded etc.

It is next determined whether the real time response feature that automatically initiates a synchronization operation based on these actions rather than waiting for the next scheduled sync operation is active. This is indicated by block . illustrate different user interfaces which allow the user to select the real time response feature. is similar to except that it also includes a box labeled Sync outgoing items as they are sent . This is designated by number in . If the user checks this box then synchronization operations are initiated when the user takes any of the predetermined subset of actions that trigger a real time response synchronization operation. is simply a different embodiment of a user interface but also contains the check box as does the user interface indicated in .

It should be noted that it may be desirable to schedule real time response synchronization operations based on the user s actions not immediately but after a predetermined relatively short time delay. This time delay can be specified by the user or it can be automatically set by the mobile device . For example the user may be responding to a large number of emails at one time. Therefore the synchronization operation may illustratively be delayed for a short period of time such as five minutes after the user has responded to an electronic mail message. This facilitates batching items which are to be synchronized from the mobile device. This reduces the frequency with which the wireless connection to the synchronization server must be established and torn down.

In any case once the user takes an action which triggers the synchronization operation at block it is determined whether the user has selected the real time response feature on the user interfaces shown in . This is indicated by block . If the user has not selected these features then a full synchronization operation is simply performed on the next scheduled synchronization timer. This is indicated by block .

If however at block it is determined that the user has selected the real time response feature then it is determined whether the next regularly scheduled synchronization operation is scheduled to trigger sooner than the real time response timer. In other words if the delay time between an action triggering a synchronization operation under the real time response feature is longer than the delay to the next regularly schedule synchronization operation this is determined at block . If so that means that the next regularly scheduled synchronization operation will actually take place before the real time response timer would trigger a synchronization operation. Therefore the normal regularly scheduled synchronization operation is simply performed as scheduled at block .

If however the real time response timer would schedule the synchronization operation prior to the next regularly scheduled operation then the real time response synchronization timer is set as indicated by block and synchronization is performed at that time. In one illustrative embodiment the next regularly scheduled synchronization is not altered even if the real time response synchronization timer schedules an earlier synchronization operation. However this could be modified as well so that the next regularly scheduled synchronization operation is delayed for a predetermined delay time after the real time response synchronization timer has triggered a synchronization operation.

It should be noted that in one illustrative embodiment the synchronization operations discussed herein can be background synchronization operations. In that embodiment no user interface items interrupt the user and the synchronization operations are performed purely in the background.

Although the present invention has been described with reference to preferred embodiments workers skilled in the art will recognize that changes may be made in form and detail without departing from the spirit and scope of the invention

