---

title: Pregroomer for storage array
abstract: Techniques are disclosed relating to arranging data on storage media. In one embodiment, a computer system is configured to access a storage array that includes a plurality of storage blocks. The computer system executes a first set of processes and a second set of processes, where the first set of processes operates on selected ones of the plurality of storage blocks to increase a likelihood that the selected storage blocks are operated on by the second set of processes. In some embodiments, the second set of processes determines whether to operate on a storage block based on an amount of invalid data within the storage block. In such an embodiment, the first set of processes increases a likelihood that the storage block is operated on by increasing the amount of invalid data within the storage block.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09489297&OS=09489297&RS=09489297
owner: SANDISK TECHNOLOGIES LLC
number: 09489297
owner_city: Plano
owner_country: US
publication_date: 20130121
---
This disclosure relates generally to data storage and more specifically to arranging data stored on storage media.

A set of data is typically written to solid state storage media by performing an erase operation on a group of memory cells followed by a program operation on those cells. Because of the small size of these cells and the high voltages used to perform these operations the cells can only be erased and programmed a limited number of times before the transistors within the cells begin to degrade.

To improve the longevity of memory cells modern storage systems may implement a log structured storage to ensure that writes to cells are more evenly distributed across the storage to produce better wear leveling as opposed to writing particular cells frequently while other cells go unused . When storing data using a log structure storage data may be written at an append point that starts at an initial portion in the storage and advances forward as writes are performed. Accordingly when portions of data are updated rather than overwriting those portions with the updated data the previously stored portions of the data may instead be invalidated as updated versions of the data are written to the append point in the storage. The memory cells storing the invalid data may eventually be erased in order to permit the cells to be programmed to store subsequent data.

In some instances a storage system may execute a groomer process that is responsible for identifying blocks of memory cells with invalid data and erasing those blocks. This identifying and erasing of blocks for subsequent reuse is sometimes referred to as garbage collection. 

The present disclosure describes embodiments in which a set of one or more processes invalidates data within storage blocks in a storage array. For example the set of processes may select storage blocks in a storage array based on various criteria and operate on the storage blocks to increase a likelihood that the storage blocks are reclaimed. In some instances a storage array may be organized as a log structure such that when data is written to the storage array it is stored at an append point within the array any previous instances of the data within the storage array are invalidated. In one embodiment execution of the set of processes increases the likelihood that a storage block will be reclaimed by invalidating valid data from a selected storage block.

In some embodiments the set of processes may be referred to as a pregroomer which may operate in conjunction with another set of one or more processes called a groomer. The groomer is responsible for reclaiming storage blocks and may identify a storage block as a candidate for garbage collection based on the amount of invalid data present in the storage block. Once identified the groomer may perform a preparation operation on that block e.g. an erase operation . In some instances execution of a pregroomer can improve performance of the groomer. A pregroomer may also facilitate goals other than improved garbage collection. For example some embodiments of the pregroomer may move data within the storage array based on criteria for consolidating metadata in the storage array and improving wear leveling of memory cells.

In one disclosed embodiment a method is performed on a system configured to access a plurality of storage blocks. The method includes executing a first of processes on the system and executing a second set of processes on the system. The first set of processes operates on selected ones of the plurality of storage blocks to increase a likelihood that the selected storage blocks are operated on by the second set of processes.

In some embodiments the second set of processes determines whether to operate on a storage block based on an amount of invalid data within the storage block and or other factors. In one embodiment the first set of processes increases a likelihood that the storage block is operated on by increasing the amount of invalid data within the storage block. In one embodiment the second set of processes operates on ones of the selected storage blocks by erasing the erase blocks. The first set of processes increases the amount of invalid data within the storage block by copying valid data from the storage block to another one of the plurality of storage blocks and marking the valid data within the storage block as invalid data. In one embodiment the first set of processes selects two or more of the plurality of storage blocks having a set of data that is stored in a non contiguous portion of a physical address space. The first set of processes increases the likelihood that the second set of processes operates on the two or more storage blocks by consolidating the set of data to a contiguous portion of the physical address space. In some embodiments the set of data corresponds to a contiguous portion of a logical address space. In such an embodiment consolidating the set of data reduces a number of nodes in a forward mapping data structure usable to map an address from the logical address space to an address in the physical address space. In some embodiments the first set of processes selects the two or more storage blocks based on a rate of change of the set of data. In some embodiments the first set of processes selects the two or more storage block in response to the two or more storage blocks including metadata. In some embodiments the system maintains a current version of a set of metadata in volatile memory and maintains a non current version of the set of metadata in one or more of the plurality of storage blocks. The first set of processes increases a likelihood that the second set of processes operates on the one or more storage blocks by writing the current version of the set of metadata to another one of the plurality of storage blocks.

In another disclosed embodiment a non transitory computer readable medium has program instructions stored thereon. The program instructions are executable by a computer system to cause the computer system to select a first of a plurality of erase blocks in a storage array accessible to the computer system and to invalidate a subset of valid data within the first erase block.

In still another disclosed embodiment an apparatus is configured to manage a plurality of erase blocks in a storage array. The apparatus includes a selection module configured to select a first of the plurality of erase blocks. The apparatus also includes a copy module configured to copy a subset of valid data within the first erase block to a second of the plurality of erase blocks.

The disclosure includes references to one embodiment or an embodiment. The appearances of the phrases in one embodiment or in an embodiment do not necessarily refer to the same embodiment. Particular features structures or characteristics may be combined in any suitable manner consistent with this disclosure.

This disclosure also includes and references the accompanying drawings. In the drawings similar symbols typically identify similar components unless context dictates otherwise. The illustrative embodiments described in the detailed description drawings and claims are not meant to be limiting. Other embodiments may be utilized and other changes may be made to these exemplary embodiments without departing from the scope of the disclosure.

The disclosure initially describes with reference to a computer system that executes a pregroomer process in conjunction with a solid state storage array. To facilitate this description logical and physical address spaces used to facilitate the implementation of a log structure storage array are described with reference to . A driver for the solid state storage array is described with reference to . Examples of the pregroomer process are then described in further detail with reference to .

Turning now to a block diagram of computer system is depicted. Computer system may be any suitable type of computer system such as a server laptop desktop a mobile device etc. In the illustrated embodiment computer system includes a processor unit random access memory RAM and storage coupled together via an interconnect . As shown RAM may include program instructions for one or more applications and an operating system OS executable by processor unit . In the illustrated embodiment OS includes a driver which further includes groomer and pregroomer .

In various embodiments the functionality of groomer and or pregroomer may be implemented in software hardware or a combination thereof. Further groomer and pregroomer need not be located within OS . For example in one embodiment such functionality may be implemented by software outside of OS e.g. as an application . In another embodiment this functionality may be implemented by software stored within a memory of controller and executed by a processor of controller . In still another embodiment controller may include dedicated circuitry to implement functionality of groomer and or pregroomer . In sum the depiction of groomer and pregroomer as being implemented in software within OS should not be seen as limiting but rather as a depiction of an exemplary embodiment.

Storage is representative of any physical medium upon which data can be recorded. As used herein the term recorded refers broadly to the process of an electronic computing device storing writing or otherwise transferring one or more data values on to some physical medium for subsequent use. Accordingly a physical recording medium is used herein to refer to any medium on which data may be recorded by an electronic computing device. Further the terms storage and memory are used herein to be synonymous with physical recording medium. Given this broad definition the designation storage in and elsewhere in this disclosure may refer to volatile and or non volatile media. Such media may also be referred to herein as memory and portions of such media may be referred to as blocks cells storage blocks memory blocks etc. Collectively a group of these blocks may be referred to as a storage array memory array etc.

In some embodiments storage may be implemented such that it includes non volatile memory. Accordingly in such an embodiment storage banks may include non volatile storage devices such as hard disk drives e.g. Integrated Drive Electronics IDE drives Small Computer System Interface SCSI drives Serial Attached SCSI SAS drives Serial AT Attachment SATA drives etc. tape drives writable optical drives e.g. CD drives DVD drives Blu Ray drives etc. etc.

In some embodiments storage may be implemented such that it includes non volatile solid state memory. Accordingly in such an embodiment storage banks may include any suitable type of solid state storage media including but not limited to NAND flash memory NOR flash memory nano RAM NRAM magneto resistive RAM MRAM phase change RAM PRAM Racetrack memory Memristor memory nanocrystal wire based memory silicon oxide based sub 10 nanometer process memory graphene memory Silicon Oxide Nitride Oxide Silicon SONOS Resistive random access memory RRAM programmable metallization cell PMC conductive bridging RAM CBRAM etc. In some embodiments storage banks may include multiple different types of solid state storage media.

In other embodiments storage may be implemented such that it includes volatile memory. Storage banks may thus correspond to any suitable volatile memory including but not limited to such as RAM dynamic RAM DRAM static RAM SRAM synchronous dynamic RAM SDRAM etc. Although shown independently of processor unit in some embodiments storage may correspond to memory within processor unit such as one or more cache levels e.g. L1 L2 L3 etc. within processor unit .

In sum various functionality will be described herein pertaining to storage . Such functionality may be applicable to any suitable form of memory including both non volatile and volatile forms. Thus while particular embodiments of groomer are described herein within the context of non volatile solid state memory arrays groomer may also be applicable to other recording media such as volatile memories and other types of non volatile memories particularly those that include a reclamation process.

References in this disclosure to accessing data in storage refers to any type of transaction including writing data to storage and or reading data from storage as well as TRIM operations maintenance accesses discovery accesses load and store operations under memory semantics and the like. Further given the broad definitions of storage and memory referred to above these accesses may be applicable to a storage device that has non volatile memory and or volatile components.

In the illustrated embodiment storage includes a controller coupled to banks via an interconnect . Controller in one embodiment is a controller configured to manage operation of storage . Accordingly controller may facilitate performance of read operations at specified addresses e.g. physical addresses as discussed below including selecting the appropriate banks and accessing the data within the appropriate cells within those banks. Controller may also facilitate performance of write operations including programming of particular cells as well as erasing blocks of cells for subsequent reuse. The cycle of programming and erasing a block of cells may be referred to as a PE cycle. In some embodiments controller implements separate read and write data pipelines to perform read and write operations in parallel. In one embodiment controller is also configured to communicate with driver discussed below over interconnect . For example in some embodiments controller communicates information for read and write operations via direct memory access DMA transactions coordinated by a DMA controller. Accordingly controller may support any suitable interconnect type such as a peripheral component interconnect PCI PCI express PCI e serial advanced technology attachment serial ATA or SATA parallel ATA PATA small computer system interface SCSI IEEE 1394 FireWire Fiber Channel universal serial bus USB etc. In some embodiments controller may also perform other operations such as error checking data compression encryption and decryption packet assembly and disassembly etc.

In various embodiments storage is organized as a log structured storage. As used herein the term log structure refers to the storing of data at an append point that is advanced sequentially through an address space as data is stored. The use of a log structure also connotes that metadata is stored in conjunction with the data in order to permit the storage to be restored to a previous state i.e. a log checkpoint . Such a restoration may be performed for example to facilitate crash recovery in the event of power loss to recover a last known valid state in the event of data corruption etc. As used herein the term address space refers to a range of addresses that can be used to specify data within the storage array. As will be described below a log structured storage array may have both logical and physical address spaces. As noted above using a log structure can improve the longevity of memory cells by ensuring that write operations are more evenly distributed thus improving wear leveling of the storage array. One embodiment of a log structure is discussed in conjunction with .

In one embodiment applications may operate on data that is written to and or read from storage . In some instances an application may access data within storage by specifying a corresponding file name to OS via an application programming interface API request in other instances an application may access data directly by specifying an address to be read from or written to . OS in turn may implement a file system. In some embodiments this may include maintaining file system information e.g. a set of modes file allocation tables etc. corresponding to directories and files within the file system. In response to the receiving the request OS may access the file system information to determine one or more addresses where data for the file is stored. OS may then convey these addresses to driver .

Driver in one embodiment is executable to permit applications and OS to interact with storage . Accordingly driver may receive requests to perform read and write operations at specified addresses and may issue corresponding commands to controller to implement those operations. To perform these operations in some embodiments driver maps logical addresses corresponding to a logical address space to physical addresses corresponding to a physical address space in other embodiments mapping logical addresses to physical addresses may be performed at any suitable location such as at controller . As noted above using a log structure may permit multiple instances of a set of data to be present in storage as the data is written and rewritten to storage . In some embodiments OS may track these instances so that an application receives the current instance of the data rather than receiving an older invalid instance stored in storage . In other embodiments to simplify the file system driver tracks physical addresses of the instances so that OS can specify the same address i.e. the same logical block address LBA over time and receive the current instance of data corresponding that address. Accordingly as used herein the term logical address space refers to an address space as perceived by higher level processes i.e. process that are above the level at which mapping is performed such as at the driver level in one embodiment such as OS and applications even though this address space may not be representative of how data is actually organized on the physical media of storage . In contrast the term physical address space refers to the address space used by lower level processes such as driver and or other logic executing on controller in one embodiment and is indicative of how data is organized on the physical media of storage . Embodiments of logical and physical address spaces are discussed in further detail in conjunction with respectively.

In some embodiments as part of tracking data in a physical address space driver labels older instances of data in storage i.e. those instances that are not the current instance as invalid. For example in one embodiment when a value is to be updated driver may issue a command to controller to write the value at a storage block specified by the current append point which may be maintained by driver controller etc. . In response to receiving an indication that the write has been successfully performed driver may record for each previously stored instance of that value an indication that that instance is invalid. As used herein the term invalid refers to data that no longer needs to be stored by storage and should not be used or provided to a user application . Similarly the term invalidating refers to the marking of data as invalid e.g. storing a record in a data structure .

In some embodiments driver also labels a current instance of data as invalid in response to receiving a TRIM command. As used herein a TRIM command refers to an indication which may be issued by an operating system file system or other application specifying that a storage array no longer needs to store a particular set of data and thus can mark the data as invalid. A TRIM command may be issued for example in response to the deletion of a file directory etc. for example by a user. In one embodiment in response to receiving a TRIM command driver further writes a note i.e. a TRIM note indicative of the received TRIM command and the invalidated data to storage . In some embodiments the TRIM note is added as metadata to the log structure at an append point of the structure. This may permit in some situations the recovery of the state of valid data.

In some embodiments driver also manages garbage collection for storage to reclaim storage blocks with invalid data. In other embodiments garbage collection may be performed by processes other than those associated with driver for example in one embodiment controller executes instructions stored in a memory of controller to perform garbage collection. In the illustrated embodiment driver performs garbage collection via groomer and pregroomer . As noted above in other embodiments operations described herein as being performed by groomer and or pregroomer may be performed by software located elsewhere in system as well as in firmware and or hardware. 

Groomer in one embodiment is a set of processes executable to identify and reclaim storage blocks so that they can be subsequently programmed to store data. As used herein the phrase set of processes refers to a group of one or more processes accordingly groomer as well pregroomer may comprise single or multiple processes. As used herein the term process refers generally to programs threads interrupt service routines or other executable instances of program instructions. As will be described in further detail below in conjunction with in various embodiments groomer may be invoked when the amount of available space in storage i.e. the number of storage blocks that are able to currently be programmed falls below a threshold. Groomer may then identify candidate storage blocks to be reclaimed e.g. erased in the case of flash media based on the amount of invalid data in those blocks e.g. groomer may identify blocks with the most invalid data . Once groomer has determined to reclaim a candidate block groomer copies any remaining valid data out of the block and writes remaining valid data forward in the log structure i.e. to the append point . Groomer may then initiate reclaiming the block by conveying the appropriate commands to controller .

Pregroomer in one embodiment is another set of processes that are executable to operate on selected storage blocks to adjust attributes of the selected storage blocks such that the selected storage blocks satisfy selection criteria for selection by groomer . Stated another way a given instance of groomer uses a set of criteria to select storage blocks for grooming. This set of criteria may be based on any number of different factors. As noted above for example one selection criteria used by groomer may in one embodiment may be selecting a storage block having the most invalid data. Embodiments of pregroomer may operate on storage blocks to give these blocks attributes that are used as selection criteria by groomer . Accordingly if an embodiment includes a groomer with a selection criteria based on determining a storage block with a greatest amount of invalid data a corresponding pregroomer may operate on selected storage blocks to increase an amount of invalid data in those blocks. In embodiments in which groomer has a plurality of different criteria for selection of blocks pregroomer may operate on selected storage blocks to provide enhance those blocks attributes corresponding to one or more of these different criteria.

Pregroomer may thus be described as increasing a likelihood that storage blocks on which it operates are selected by groomer . As one example consider a groomer that selects blocks for grooming based on an amount of invalid data in a block. A corresponding pregroomer may in one embodiment operate on selected blocks by increasing the amount of invalid data in each of those blocks. For each of these blocks then pregroomer has increased the chance that such block will be selected for processing by groomer . It is noted that in adjusting attributes of storages blocks pregroomer does not necessarily guarantee that storage blocks will be operated on by groomer at a given point in time. Instead the phrase increasing a likelihood connotes that pregroomer has operated on selected storage blocks in an attempt to change characteristics attributes etc. of these blocks in a manner consistent with criteria employed by groomer to selected storage blocks for grooming. In some instances however pregroomer increasing the likelihood of a block s being selected by groomer may include adjusting block attributes in a manner that does guarantee that one or more blocks will be selected by the groomer for reclamation.

As will be described in further detail below in conjunction with in one embodiment pregroomer may select these blocks based on various criteria and increase the likelihood that groomer operates on these blocks by invalidating data within those blocks. In some instances pregroomer may merely mark data as invalid in selected blocks i.e. without moving data to increase their likelihoods of being operated on. In other instances pregroomer may copy selected valid data from those blocks and correspondingly mark the data in those blocks as invalid. Still further in various embodiments the copied valid data may be only a subset of the valid data present in a block accordingly as used herein the term subset of valid data refers to some but not all of the valid data within block . In some instances pregroomer may also copy valid data from multiple selected storage blocks into a single storage block. For example in some embodiments pregroomer may consolidate data having similar characteristics e.g. similar properties similar types of data etc. from multiple storage blocks into a single block or contiguous blocks.

In various embodiments processes of groomer and pregroomer are separately executable. In some embodiments processes of groomer are more invasive than those of pregroomer . Accordingly in one embodiment groomer may be invoked when the number of available storages blocks falls below a first threshold and may continue to execute until the number of available blocks rises above that threshold. Still further in one embodiment processes of groomer may be able to suspend application initiated I O operations with storage if the number of available storage blocks falls below a second threshold. In one embodiment groomer may be invoked in idle times or low usage periods for storage . In some embodiments pregroomer may be invoked more frequently than groomer . For example in one embodiment invocations of pregroomer may occur periodically while invocations of groomer may be primarily I O driven. However in some embodiments pregroomer may be given a shorter execution time slice i.e. the interval in which a process is allowed to execute than groomer . Thus the system resource requirements of pregroomer may in some embodiments be tuned to a fraction of the requirements for groomer .

Turning now to a block diagram of a storage system including computer system is depicted. As discussed above computer system may include one or more applications that operate on data stored in storage . In the illustrated embodiment computer system executes a storage server application to enable client systems A and B to access and store data in solid state storage via network . For example in one embodiment storage system may be associated within an enterprise environment in which server application distributes enterprise data from storage to clients . In some embodiments clients may execute other server applications such as web servers mail servers virtual private network VPN servers etc. to further distribute data to other computer systems. Accordingly in some embodiments storage server application may implement various network attached storage NAS protocols such as the file transfer protocol FTP network file system NFS protocol server message block SMB protocol Apple file protocol AFP etc. In some embodiments computer system may be one of several computer systems configured to implement a storage area network SAN .

Turning now to an exemplary mapping of a logical address space to a physical address space is depicted. In one embodiment logical address space represents the organization of data as perceived by higher level processes such as applications and OS . In one embodiment physical address space represents the organization of data on the physical media.

Logical address space in one embodiment is divided into logical addresses corresponding to respective logical blocks A D also referred to as sectors . In some embodiments the logical addresses are logical block addresses LBAs in other embodiments the logical addresses may correspond to some other form of logical identifiers . In one embodiment sectors blocks represent the smallest block of data associated with a given logical address. As but one example a block may be approximately 512 bytes in size while logical erase blocks and logical pages discussed below may be approximately 40 MB and 8 kB respectively .

Physical address space in one embodiment is divided into physical addresses corresponding to the arrangement of data on the physical recoding media. As will be discussed in further detail with respect to in one embodiment the content of logical blocks may be stored as packets within logical erase blocks .

As shown the contents of logical blocks that are contiguous with within logical address space may be stored as packets that are non contiguous in physical address space . In various embodiments write operations and read operations can be addressed to any portion of logical address space . However physical address space may be organized as a log structure in which write operations may be performed at only one or more append points such as discussed below in conjunction with . Accordingly when a set of logical blocks is initially stored in storage blocks may be stored contiguously within one or more logical erase blocks identified by an append point e.g. append point discussed below . As sectors become modified and rewritten within storage at the append point sectors may become interspersed among multiple logical erase blocks . This interspersion is illustrated in with the contents of logical blocks A D being stored in packets located among logical erase blocks A D. In various embodiments a mapping may be maintained to identify where particular data of logical blocks are stored with physical address space .

Turning now to a block diagram of storage blocks within storage is depicted. In the illustrated embodiment storage is organized into logical erase blocks LEBs that include multiple physical erase blocks PEBs which are located in separate storage banks . A logical erase block is further divided into multiple logical pages that in turn include multiple physical pages . Pages include multiple packets which may be grouped into ECC chunks . Groomer and pregroomer may operate on any suitable storage block including storage blocks at the logical level such as blocks and and or storage blocks at the physical level such as storage blocks and . 

As used herein the term erase block refers broadly to a logical erase block or a physical erase block. In one embodiment a physical erase block represent the smallest storage block with a given bank that can be erased at a given time e.g. due to the wiring of cells on the die . In one embodiment logical erase blocks represent the smallest block erasable by controller in response to receiving an erase command. In such an embodiment when controller receives an erase command specifying a particular logical erase block controller may erase each physical erase block within the block simultaneously. It is noted that physical erase blocks within a given logical erase block e.g. blocks A and B may be considered as contiguous in physical address space even though they reside in separate banks . Thus the term contiguous is applicable not only to data stored within the same physical medium but also to data stored within separate media.

As used herein the term page refers broadly to logical pages or physical pages. In one embodiment a physical page represents the smallest storage block within a given bank that can be written to at a given time. In one embodiment a logical page is the smallest writable storage block supported by controller . In one embodiment controller may include a buffer configured to store up to a logical page size of data upon filling the buffer controller may write the contents of the buffer to a single logical page simultaneously. In some instances dividing a logical page across multiple banks may result in faster access times for a set of data when multiple banks are accessible in parallel.

In one embodiment a packet represents the smallest storage block within a given bank that can be read at a given time. In one embodiment an ECC chunk is the smallest storage block readable by controller . In some embodiments packets may be slightly larger than logical blocks as they may include the contents of a logical block or multiple blocks in some instances as well as a packet header.

In some embodiments driver may associate metadata with one or more of storage blocks . As used herein the term metadata refers to system data usable to facilitate operation of storage metadata stands in contrast to for example data produced by applications i.e. application data or other forms of data would be considered by OS as user data. For example in one embodiment a logical erase block may include metadata specifying without limitation usage statics e.g. the number of program erase cycles performed on that block health statistics e.g. indicative how often corrupted data has been read from that block security or access control parameters sequence information e.g. a sequence indicator a persistent metadata flag e.g. indicating inclusion in an atomic storage operation a transaction identifier or the like. In one embodiment the header within a packet may include packet metadata such as one or more LBAs associated with the contained data the packet size linkages to other packets error correction checksums etc. In various embodiments driver may use this information along with other forms of metadata discussed below to manage operation of storage . For example driver might use this information to facilitate performance of read and write operations recover storage to a previous state including for example reconstruction of various data structures used by driver and or replaying a sequence of storage operations performed on storage etc. As will be discussed below in some embodiments pregroomer may use this information in selecting particular storage blocks.

Turning now to a block diagram of log structure within physical address space is depicted. As shown in various embodiments data is stored sequentially at an append point also referred to as the head that starts an initial logical page . As additional data is stored append point advances to subsequent pages in log structure . Eventually after storing enough data the append point reaches the last page in storage at which point the append point wraps back to the initial page . Thus log structure is depicted as a loop cycle. As more data is stored the number of available pages shown as unshaded pages decreases and the number of used pages shown as shaded pages increases. As discussed above in order to reuse these pages i.e. make them available to receive further writes in one embodiment driver using groomer performs erase operations on logical erase blocks . In one embodiment a tail marker is maintained to identify the oldest page still in use within structure . When the logical erase block with the oldest page is eventually erased tail is advanced forward to the next oldest page in use at the end of the log structure .

In general data that is modified less frequently than other data in storage will migrate towards tail such data may be described as having a colder temperature or simply as cold data . On the other hand data that is modified more frequently described as having a hotter temperature or as hot data will typically be located closer to head . Thus valid data located in LEB A is likely colder than data in LEB B.

Turning now to a block diagram of driver is depicted. As noted above in one embodiment driver is executable to enable applications and OS to interact with storage . In the illustrated embodiment driver includes a management layer and an input output I O layer .

Management layer in one embodiment handles higher level block related operations for driver . Accordingly in various embodiments management layer tracks the mapping of logical addresses to physical address and performs translations for addresses received from higher level processes such as those of applications and OS . In the illustrated embodiment management layer also performs garbage collection via groomer and pregroomer . In some embodiments management layer maintains various forms of metadata in one or more data structures located within RAM such as forward map program erase PE statistics and heath statistics . In other embodiments data structure may be maintained elsewhere in system such as within storage . In one embodiment driver periodically stores snapshots of these data structures to storage so that they can be reconstructed in the event of a crash. As used herein the term snapshot refers to the storing of a copy of at least a portion of a data structure at a given point in time. As will be discussed below groomer and pregroomer may use various ones of data structures .

Forward map in one embodiment is a forward mapping data structure usable to map a logical address space to a physical address. In some embodiments forward map may include metadata in addition to metadata used to facilitate mapping such as invalidity information. Although described as forward map map may also be used to perform a reverse mapping of a physical address to a logical address. As will be described in conjunction with in one embodiment forward map is implemented as an extended range b tree data structure. In other embodiments forward map may be implemented using other data structures such as arrays hash tables other forms of trees etc. In some embodiments forward map may also be implemented as multiple data structures such as a tree with pointers into an array.

PE statistics in one embodiment is a data structure that stores information indicative of how often logical erase blocks or physical erase blocks have been erased and programmed. For example data structure stores for each logical erase block a respective value for the number of program erase cycles a cycle being one program operation and one erase operation performed on that erase block . This information may be indicative of the life expectancy for a given erase block .

Heath statistics in one embodiment is a data structure that stores information indicative of whether logical erase blocks or physical erase blocks are returning corrupted data when read. In various embodiments ECC chunks may be analyzed when they are read to determine whether they include corrupted bits e.g. based on error correction checksums stored in packet headers as noted above . An indication of the number of detected corrupted bits for a given erase block may be maintained in structure . If this number exceeds a threshold that erase block may be removed from service i.e. disabled not used for storing any user data . In some embodiments indications of which erase blocks have been disabled may be stored in health statistics as well.

I O layer in one embodiment handles lower level interfacing operations with controller . Accordingly layer may receive a write request or a read request and the physical address for that request layer may then issue the appropriate commands to controller to cause storage to fulfill that request. In some embodiments I O layer may prepare data for DMA transactions and initialize a DMA controller to conduct the transactions.

Turning now to a block diagram of forward map is depicted. As noted above in the illustrated embodiment forward map is an extended range b tree that includes multiple nodes A C. As shown each node includes a logical address range a physical address mapping one or more points and additional metadata .

Logical address range in one embodiment is the range of logical addresses e.g. LBAs that are mapped using information within a given node . Accordingly logical address range A specifies that physical address mapping A pertains to LBAs 50 100 for example. If a logical address does not hit in a node i.e. does not fall with in range of a node such as range A in root node A then map is traversed to examine ranges in one or more leaf nodes such as nodes B or C. In one embodiment map includes a node for each range of logical addresses that have been mapped to a corresponding range of physical addresses but does not include nodes corresponding to unmapped ranges. Thus in such an embodiment if a given LBA is unused unallocated and or unwritten a corresponding node does not exist for that LBA in map . On the other hand if an LBA has been written to map includes a node specifying range that includes the LBA. As such nodes may be added and or modified when data is written to storage . In such an embodiment map is also a sparse data structure meaning that map does not include mappings for an entire logical address space. Accordingly in some embodiments logical address space may be significantly larger than physical address space .

Physical address mapping in one embodiment is the mapped physical addresses for a given range . In one embodiment a given physical address is a composite a bank identifier for a storage bank a PEB identifier for a PEB a physical page identifier for a page and a packet identifier for a packet however in other embodiments a physical address may be organized differently e.g. a composite of LEB logical page and ECC chuck identifiers . In one embodiment physical address mapping is specified as a range of physical addresses. In another embodiment physical address map is a base address that is combined with an offset determined from the logical address. In other embodiments mapping may be specified differently.

Pointers in one embodiment identify leaf nodes for a given node . In some embodiments map is organized such that a left pointer identifies a node that has a lower address range than the present node and a right pointer may identify a node having a higher address range . For example if node A corresponds to the logical address range 50 100 node B may correspond to the range 0 50 and node C may correspond to the range 100 150. In some embodiments map may also be periodically balanced to give it a logarithmic access time.

Metadata in one embodiment is additional metadata that may not be used in mapping a logical address to physical address such as validity information and packet size. In one embodiment validity information may identify whether particular locations e.g. erase blocks pages or packets store valid or invalid data. In some embodiments metadata may also include TRIM notes indicative of data that was invalidated in response to TRIM commands in other embodiments TRIM notes may be stored in a separate data structure within RAM or on storage . As will be discussed in conjunction with in one embodiment validity information is used by groomer to determine whether to erase a block . In some embodiments storage may support variable packet sizes in such an embodiment metadata may specify the size packets used for a given logical address range . In some embodiments metadata may also include other information such as age information usage information e.g. whether particular logical addresses are associated with hot or cold data etc.

Turning now to an exemplary usage of forward map is depicted. In this example the letters A L represent various sets of data stored within log structure . When data A is initially written to storage it is stored at physical storage location A. To reflect this storage a node is added or in some instances updated in map . As shown this node may identify the physical address of location A and indicate that the data stored within that location is valid. When data A is subsequently updated or merely moved another instance of data A shown as A is stored at a location B identified by the then current append point . A node may then be updated or in some embodiments another node may be added to reflect that the logical address for data A now maps to a physical address for location B location A is then indicated as having invalid data. When data A is again written another instance of data A shown as A is stored at a location C. Again a node may be updated or added that identifies the physical address of location C as mapping to the logical address for data A location B is also indicated as having invalid data. The previous now invalid instances A and A may continue to reside in storage until the corresponding logical erase blocks corresponding to locations A and B are erased i.e. reclaimed .

Turning now to a block diagram of one embodiment of groomer is depicted. As noted above in various embodiments groomer is executable to identify and reclaim storage blocks for garbage collection. In the illustrated embodiment groomer includes a selector process scanner process and reclamation process . In some embodiments these processes are separately executable however in other embodiments they may be implemented by a single process.

Selector process in one embodiment identifies storage blocks that are candidates for reclamation based at least in part on the amount of invalid data stored within those blocks . In one embodiment storage blocks are logical erase blocks in another embodiment storage blocks are physical erase blocks . In the illustrated embodiment process determines the amount of invalid data in storage blocks by accessing validity information in forward map . In some embodiments process selects storage blocks that have the highest amounts of invalid data in storage .

Scanner process in one embodiment also identifies storage blocks that are candidates for reclamation based on the amount of erroneous data detected when data is read from those blocks. In the illustrated embodiment process determines this information based on health statistics discussed above. In some embodiments process may select storage blocks known to be problematic or that have sat idle for an extended period of time e.g. have experienced a retention time that exceeds a threshold associated with data integrity degradation in order to periodically refresh the data in those blocks assuming the erase blocks are not problematic to the point of not being usable . In some embodiments process may select storage blocks in order to remove those blocks from service.

In the illustrated embodiment indications of identified candidate storage blocks are stored in one or more queues until those blocks can be serviced by reclamation process . In some embodiments queues may include queues associated with different priorities e.g. a high priority queue and a low priority queue .

Reclamation process in one embodiment reclaims storage blocks identified by processes and . In some embodiments process may also prepare blocks for reclamation by moving i.e. copying and invalidating remaining valid data from those blocks. In the illustrated embodiments process moves remaining valid data and erases blocks by issuing corresponding commands to controller .

In one embodiment processes may be invoked when the number of available logical erase blocks or physical erase blocks falls below a threshold value indicative of when garbage collection should be performed. In some embodiments processes may be invoked when storage has available bandwidth to handle additional program and erase operations for garbage collection e.g. storage is not fully occupied with performing read and write operations initiated by applications and OS .

Turning now to a block diagram of one embodiment of pregroomer is depicted. As noted above in various embodiments pregroomer is executable to operate on selected storage blocks to adjust attributes of the selected storage blocks such that the selected storage blocks satisfy selection criteria for selection by groomer . For example in some embodiments pregroomer may operate on selected storage blocks by copying and or invalidating data in selected storage blocks e.g. selected logical erase blocks and or physical erase blocks . In the illustrated embodiment pregroomer includes a determination module and a set of analysis criteria . As noted above pregroomer may be implemented using a single or multiple processes. It should be noted that operation of the pregroomer to increase the likelihood a storage block will satisfy selection criteria for selection by groomer may be influenced by policies and or configuration settings for the driver or controller that may shift or balance the emphasis on satisfying groomer selection criteria and minimizing writing of data caused by management and operation of the controller or driver rather than writing of data due to application write requests.

In certain embodiments determination module analyzes metadata from RAM and metadata from storage based on analysis criteria to select storage blocks and perform storage invalidations for data within those selected blocks. In one embodiment metadata may include metadata from data structures as discussed above in conjunction with . In one embodiment metadata may include logical erase block metadata and packet metadata such as discussed above in conjunction with . In one embodiment analysis criteria include various rules that dictate when storage blocks are to be selected e.g. based on the particular data within those blocks and how they are to be operated on e.g. invalidating data copying data consolidating data from a storage block with similar data from other storage blocks etc. . In various embodiments analysis criteria may be specified in a manner that seeks to balance performing write operations to invalidate data and minimizing write amplification i.e. writes to cells caused by management of storage as opposed to user directed writes which can increase wear leveling on cells.

Metadata relocation criteria in one embodiment are criteria that are usable to increase the amount of invalid data within selected storage blocks by relocating metadata in storage . Accordingly in one embodiment criteria include criteria specifying that storage blocks be selected if they include metadata and that the metadata can be consolidated into a single storage block. This metadata may include any of the metadata described above such as logical erase block records TRIM notes atomic notes i.e. a note written to storage to determine whether a block of data has been successfully written to storage this note may be written as part of a write transaction to indicate successful completion of the write etc. In some embodiments criteria specify that similar types of metadata be grouped or consolidated together such as grouping all TRIM notes together within a logical erase block . Consolidating metadata into a smaller set of one or more storage blocks may allow metadata to be stored more efficiently. In one embodiment criteria also include criteria specifying that once consolidated the metadata should be moved together in some instances this may reduce the number of read and write operations performed and thus write amplifications . In some embodiments criteria may also specify that the consolidated metadata be moved at regular intervals for example when the distance between the location of the metadata and append point exceeds a threshold etc. An example of metadata relocation is discussed below with respect to .

Defragmentation criteria in one embodiment are criteria that are usable to increase the amount of invalid data within selected storage blocks by defragmenting data in storage . A set of data may be described herein as fragmented may refer to data that is non contiguous in logical address space or data that is contiguous in logical address space i.e. within a contiguous portion of address space but is stored non contiguously in physical address space e.g. data within separate non sequentially addressed logical pages non adjoining logical erase blocks etc. . As used herein defragmentation refers to moving fragmented data into a contiguous portion of an address space. Accordingly in one embodiment criteria may specify that storage blocks be selected if they include sets of fragmented data and that the data be consolidated into a contiguous portion of physical address space . In some embodiments determination module may identify fragmented data by examining logical address ranges in forward map . For example determination module may determine that storage blocks have fragmented data if physical address ranges associated with the blocks are identified in separate nodes having adjoining logical address ranges . In some embodiments criteria may further specify that nodes with adjoining ranges be consolidated into a single node once the data stored at those ranges has been defragmented thus saving space by storing a single node rather than multiple nodes . An example of data defragmentation is discussed below with respect to .

Cold data criteria in one embodiment are criteria that are usable to increase the amount of invalid data within selected storage blocks by relocating data that is less frequently used i.e. colder data relative to other data in storage . The temperature of data i.e. how frequently data is modified may be identified using multiple techniques. In some embodiment driver or controller may maintain metadata identifying a respective rate of change for sets of data e.g. each sector may store a number of writes and or a number of reads to that section . Thus a given set of data may be identified as cold if its rate falls below a threshold value for identifying cold data. In some embodiments data may be identified based on where valid data is located within storage e.g. as determined by validity information relative to the location of tail e.g. valid data may be classified as cold if it is within a threshold distance of tail . In some embodiments data may be identified as cold based on the sequence number assigned to the logical erase block including the data as used herein a sequence number refers to a number that is assigned to a logical erase block when it is initialized lower numbers may connote older blocks while higher numbers may connote younger blocks . Accordingly in one embodiment criteria may specify that storage blocks be selected if they include data classified as cold according to one or more of these techniques and that cold data be consolidated within one or more storage blocks. In some embodiments criteria may further specify that once consolidated cold data be moved together thus reducing the number of read and write operations performed. An example of cold data relocation is discussed below with respect to .

Metadata removal and update criteria in one embodiment are criteria that are usable to increase the amount of invalid data within selected storage blocks by marking obsolete metadata as invalid or by writing an updated version of metadata to storage and marking older versions as invalid. In various embodiments storage may store metadata that becomes obsolete after particular operations have been performed a particular amount of time has passed etc. In some embodiments this metadata may include TRIM notes which may become obsolete once the data associated with received TRIM commands have been removed from the media atomic notes which may become obsolete once the write operation completes epoch bits temporal indicators that associate certain events or operations with a given period of time this indicator may become obsolete after their associated events or operations have been performed etc. For this type of metadata the metadata can merely be marked as invalid once those conditions have been met no copying forward of the metadata is required. Accordingly in one embodiment criteria may specify how to identify this type of metadata and to mark this metadata as invalid. In various embodiments storage may store data that is periodically updated making the old versions of data obsolete. For example in one embodiment storage may maintain snapshots of one or more data structures to enable recovery of those structures. As these structures are modified in RAM updated snapshots may be written to storage making the older snapshots obsolete. Accordingly in one embodiment criteria may specify when updated metadata should be written to storage from RAM and that any obsolete copies be invalidated and not persisted. An example of metadata removal and updating is discussed below with respect to .

Turning now to a flow diagram of a method is depicted. Method is one embodiment of a method that may be performed by a computer system with a solid state storage array such as computer system . As shown in one embodiment performance of method may begin at system startup. At step a pregroomer e.g. pregroomer may be started i.e. invoked . The pregroomer reads one or more analysis criteria e.g. criteria at step . At step the pregroomer reads metadata e.g. from RAM and or storage as discussed above to determine at step whether data in the storage array can be invalidated. At step data identified in step is invalidated which may include copying sets of data forward in the log structure and marking previous instances of the data as invalid. In one embodiment this newly invalidated data may be identified by a groomer and used to select erase blocks for reclamation. In some embodiments steps may be performed in a different order than shown and or concurrently.

Turning now to a flow diagram of a method is depicted. Method is another embodiment of a method that may be performed by a computer system with a solid state storage array. Method begins in step with a first set of processes e.g. pregroomer being executed that operates on selected ones of storage blocks e.g. logical erase blocks to increase a likelihood that the selected storage blocks are operated on e.g. erased by a second set of processes e.g. groomer . In various embodiments the first set of processes increases a likelihood that a storage block is erased by increasing the amount of invalid data within the storage block. As discussed above in some embodiments the amount of invalid data within a storage block is increased by moving metadata from the storage block by moving fragmented data from the storage block to a contiguous portion of physical address space by moving cold data from the storage block e.g. as identified by a rate of change for the data in the storage block or by removing or updating metadata on the storage array. In step the second set of processes is executed to operate on storage blocks. In some embodiments steps and may be performed in a different order and or concurrently.

Turning now to a flow diagram of a method is depicted. Method is yet another embodiment of a method that may be performed by a computer system with a solid state storage array. Method begins in step with the computer system storing a set of analysis criteria e.g. criteria for a first driver level process e.g. pregroomer for a log structured storage array that includes multiple storage blocks e.g. logical erase blocks . Method further includes in step executing the first driver level process to select one of the storage blocks based on the stored set of analysis criteria and invalidate without erasing data in the selected storage block. In some embodiments method further includes executing a second driver level process e.g. groomer to erase ones of the storage blocks. In one embodiment step includes the first driver level process invalidating data in selected storage blocks increasing the likelihood that the storage blocks are selected for erasure by the second driver level process.

Turning now to a block diagram of an apparatus including modules is depicted. As used herein the term module refers to circuitry configured to perform operations or a memory having program instructions stored therein that are executable by one or more processors to perform operations. Accordingly a module may be implemented as a hardware circuit implemented in a variety of ways. The hardware circuit may include for example custom very large scale integration VLSI circuits or gate arrays off the shelf semiconductors such as logic chips transistors or other discrete components. A module may also be implemented in programmable hardware devices such as field programmable gate arrays programmable array logic programmable logic devices or the like. A module may also be any suitable form of non transitory computer readable media storing program instructions executable to perform specified operations. Apparatus may include modules to implement any of the functionality described herein. For example in the illustrated embodiment apparatus includes a selection module configured to select a first of the plurality of erase blocks and a copy module configured to copy a subset of valid data within the first erase block to a second of the plurality of erase blocks. Modules and may be located within any suitable circuitry. For example in some embodiments the selection module and the copy module are within controller . In another embodiment modules and may be located within a memory such as memory . In sum the modules of apparatus may be implemented in any suitable manner to perform functionality described herein. Apparatus may also correspond to any suitable structure having the functionality of modules and . In one embodiment apparatus is a computer system that includes or is coupled to a storage such as storage . In another embodiment apparatus is a card including a controller such as controller and one or more storage elements such as storage banks . In yet another embodiment apparatus is a computer system including a memory system that stores modules and .

Turning now to a block diagram of an apparatus including a pregrooming means and a grooming means is depicted. Apparatus may correspond to any suitable structure having the functionality of pregrooming means and grooming means . For example apparatus may be any suitable type of computing device such as a server laptop desktop a mobile device etc. In some embodiments apparatus may include multiple computing devices working together. In some embodiments apparatus is a card including a controller such as controller and one or more storage elements such as storage banks .

In various embodiments pregrooming means may implement any of the functionality described herein with respect to pregroomer . Accordingly in one embodiment pregrooming means is for selecting one or more of a plurality of storage blocks within a log structured storage array based on a set of analysis criteria and for copying valid data from the one or more storage blocks to the current location specified by the append point. In some embodiments the pregrooming means is configured to select based on the set of analysis criteria two or more of the plurality of storage blocks that include a set of data and to copy the set of data into a single storage block at the current location specified by the append point. In some embodiments the pregrooming means is configured to select the one or more storage blocks based on how frequently data in the one or more storage blocks is accessed. In some embodiments the pregrooming means is configured to select the one or more storage blocks based on their respective proximities to a current tail location of the log structured storage array. In some embodiments pregrooming means may also implement functionality other than that described in conjunction with pregroomer . For example in some embodiments pregrooming means may implement functionality described with respect to groomer .

Pregrooming means may correspond to any suitable structure. In one embodiment pregrooming means is a hardware circuit configured to perform operations e.g. controller . The hardware circuit may include for example custom very large scale integration VLSI circuits or gate arrays off the shelf semiconductors such as logic chips transistors or other discrete components. Means may also be implemented in programmable hardware devices such as field programmable gate arrays programmable array logic programmable logic devices or the like. In another embodiment pregrooming means includes a memory having program instructions stored therein e.g. RAM that are executable by one or more processors e.g. processor unit to implement an algorithm. In one embodiment pregrooming means implements the algorithm discussed with respect to . In some embodiments pregrooming means corresponds to module selection module and copy module . Accordingly the phrases means for selecting one or more of a plurality of storage blocks within a log structured storage array based on a set of analysis criteria and means for copying valid data from the one or more storage blocks to the current location specified by the append point refer to any of the structures listed above as well as their corresponding equivalents.

In various embodiments grooming means may implement any of the functionality described herein with respect to groomer . Accordingly in one embodiment grooming means is for selecting the one or more storage blocks as candidates for erasure and erasing the one or more storage blocks. In some embodiments grooming means may implement functionality other than that described with respect to groomer . Grooming means may correspond to any suitable structure such as those discussed above with respect to pregrooming means . In one embodiment grooming means implements the algorithm discussed with respect to . Accordingly the phrase means for selecting the one or more storage blocks as candidates for erasure and for erasing the one or more storage blocks refers to any of the structures listed above as well as their corresponding equivalents.

Turning now to a flow diagram illustrating an algorithm is depicted. Algorithm is one embodiment of an algorithm implemented by pregrooming means . In the illustrated embodiment algorithm includes selecting at step one or more of a plurality of storage blocks within a log structured storage array based on a set of analysis criteria such as criteria . In one embodiment the log structured storage array has an append point specifying a current location within the array. In some embodiments the selecting includes selecting based on the set of analysis criteria two or more of the plurality of storage blocks that include a set of data. In some embodiments selecting the one or more storage blocks is based on how frequently data in the one or more storage blocks is accessed. Algorithm further includes at step copying valid data from the one or more storage blocks to the current location specified by the append point. In some embodiments the set of data is copied into a single storage block at the current location specified by the append point.

Turning now to a flow diagram of an algorithm is depicted. Algorithm is one embodiment of an algorithm implemented by grooming means . In the illustrated embodiment algorithm includes at step selecting the one or more storage blocks as candidates for erasure. In some embodiments the selecting may be performed based on the amounts of invalid data found in those blocks. Algorithm further includes at step erasing the one or more storage blocks.

Turning now to an example of metadata relocation is depicted. As shown metadata A C may reside in respective metadata portions A C in multiple logical erase blocks including multiple physical erase blocks . In some embodiments portions may be particular pages of erase blocks that are dedicated for storing metadata. In the example pregroomer consolidates metadata A C into another portion D at append point based for example on criteria . Pregroomer may then indicate e.g. via validity information that the old instances of metadata A C in portions A C are invalid.

Turning now to an example of defragmentation is depicted. As shown in a set of data corresponding to the contiguous range of logical address 0 100 is stored within a non contiguous portion A. In one embodiment forward map represents the mappings for these logical address ranges using two nodes A and C because ranges A and B do not map to adjoining locations in physical address space. As noted above pregroomer may identify that data is fragmented based on existence of these two nodes in forward map . In pregroomer has moved data into a contiguous portion B and has indicated that previous instance of data is invalid. Pregroomer also merges nodes A and C into a single node A and adjusts the logical address to range from 0 to 100.

Turning now to an example of cold data relocation is depicted. As shown logical erase blocks include data A C within portions A C respectively. In one embodiment pregroomer identifies the valid data in these blocks as being cold based one or more of the criteria discussed above. Accordingly pregroomer copies data A C into a consolidated portion D and marks the old instances of data in portions A C as invalid thus making the blocks ready for reclamation presuming that all remaining valid data has been copied from the block .

Turning now to an example of metadata removal and updating is depicted. As shown storage may include snapshot metadata corresponding to one or more data structures such as forward map residing in RAM . Storage may also include metadata that has become obsolete for various reasons e.g. atomic write notes TRIM notes etc. In this example rather than read metadata and and copy that data forward to append point pregroomer writes an updated metadata e.g. for forward map from RAM to a portion D and marks metadata as invalid. Pregroomer may also mark any obsolete metadata as invalid without copying any data to a new location.

In sum pregroomer may identify storage blocks in a storage array to invalidate using any suitable criteria. Such criteria should not be limited to the exemplary embodiments described above.

This disclosure has been made with reference to various exemplary embodiments. However those skilled in the art will recognize that changes and modifications may be made to the exemplary embodiments without departing from the scope of the present disclosure. For example various operational steps as well as components for carrying out operational steps may be implemented in alternate ways depending upon the particular application or in consideration of any number of cost functions associated with the operation of the system e.g. one or more of the steps may be deleted modified or combined with other steps . Therefore this disclosure is to be regarded in an illustrative rather than a restrictive sense and all such modifications are intended to be included within the scope thereof. Likewise benefits other advantages and solutions to problems have been described above with regard to various embodiments. However benefits advantages solutions to problems and any element s that may cause any benefit advantage or solution to occur or become more pronounced are not to be construed as a critical a required or an essential feature or element. As used herein the terms comprises comprising and any other variation thereof are intended to cover a non exclusive inclusion such that a process a method an article or an apparatus that comprises a list of elements does not include only those elements but may include other elements not expressly listed or inherent to such process method system article or apparatus. Also as used herein the terms coupled coupling and any other variation thereof are intended to cover a physical connection an electrical connection a magnetic connection an optical connection a communicative connection a functional connection and or any other connection.

Additionally as will be appreciated by one of ordinary skill in the art principles of the present disclosure may be reflected in a computer program product on a machine readable storage medium having machine readable program code means embodied in the storage medium. Any tangible non transitory machine readable storage medium may be utilized including magnetic storage devices hard disks floppy disks and the like optical storage devices CD ROMs DVDs Blu Ray discs and the like flash memory and or the like. These computer program instructions may be loaded onto a general purpose computer special purpose computer or other programmable data processing apparatus to produce a machine such that the instructions that execute on the computer or other programmable data processing apparatus create means for implementing the functions specified. These computer program instructions may also be stored in a machine readable memory that can direct a computer or other programmable data processing apparatus to function in a particular manner such that the instructions stored in the machine readable memory produce an article of manufacture including implementing means that implement the function specified. The computer program instructions may also be loaded onto a computer or other programmable data processing apparatus to cause a series of operational steps to be performed on the computer or other programmable apparatus to produce a computer implemented process such that the instructions that execute on the computer or other programmable apparatus provide steps for implementing the functions specified.

While the principles of this disclosure have been shown in various embodiments many modifications of structure arrangements proportions elements materials and components that are particularly adapted for a specific environment and operating requirements may be used without departing from the principles and scope of this disclosure. These and other changes or modifications are intended to be included within the scope of the present disclosure.

